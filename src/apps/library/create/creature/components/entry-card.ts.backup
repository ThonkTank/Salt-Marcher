// src/apps/library/create/creature/components/entry-card.ts
// Wiederverwendbare Komponenten fÃ¼r Entry Cards im Creature Creator

import { createTextInput, createSelectDropdown, createTextArea, createNumberInput } from "../../shared/form-controls";
import { EntryAutoCalculator } from "../../shared/auto-calc";
import type { CreatureEntry, SpellGroup } from "../entry-model";
import { inferEntryType, type EntryType } from "../entry-model";
import type { StatblockData } from "../../../core/creature-files";
import { CREATURE_ABILITY_SELECTIONS, CREATURE_SAVE_OPTIONS, CREATURE_ABILITY_LABELS } from "../presets";
import { findEntryPresets, type EntryPreset } from "../entry-presets";
import { setIcon } from "obsidian";

/**
 * Options for creating an entry card
 */
export interface EntryCardOptions {
  entry: CreatureEntry;
  index: number;
  data: StatblockData;
  onDelete: () => void;
  onUpdate: () => void;
  onMoveUp?: () => void;
  onMoveDown?: () => void;
  canMoveUp?: boolean;
  canMoveDown?: boolean;
  shouldFocus?: boolean;
}

/**
 * Creates the basis section (Art, Reichweite, Ziel)
 */
export function createBasisSection(
  parent: HTMLElement,
  entry: CreatureEntry,
  onUpdate: () => void
): void {
  const section = parent.createDiv({ cls: "sm-cc-entry-section sm-cc-entry-section--basis" });
  const grid = section.createDiv({ cls: "sm-cc-entry-grid" });

  // Art (Kind)
  grid.createEl("label", { text: "Art" });
  createTextInput(grid, {
    className: "sm-cc-entry-input",
    placeholder: "Melee/Ranged â€¦",
    ariaLabel: "Art",
    value: entry.kind || "",
    onInput: (value) => {
      entry.kind = value.trim() || undefined;
    },
  });

  // Reichweite (Range)
  grid.createEl("label", { text: "Reichweite" });
  createTextInput(grid, {
    className: "sm-cc-entry-input",
    placeholder: "reach 5 ft. / range 30 ft.",
    ariaLabel: "Reichweite",
    value: entry.range || "",
    onInput: (value) => {
      entry.range = value.trim() || undefined;
    },
  });

  // Ziel (Target)
  grid.createEl("label", { text: "Ziel" });
  createTextInput(grid, {
    className: "sm-cc-entry-input",
    placeholder: "one target",
    ariaLabel: "Ziel",
    value: entry.target || "",
    onInput: (value) => {
      entry.target = value.trim() || undefined;
    },
  });
}

/**
 * Creates the combat section (To Hit, Damage with Auto-Calc)
 */
export function createCombatSection(
  parent: HTMLElement,
  entry: CreatureEntry,
  data: StatblockData,
  entryIndex: number,
  onUpdate: () => void
): void {
  const section = parent.createDiv({ cls: "sm-cc-entry-section sm-cc-entry-section--combat" });
  const autoRow = section.createDiv({ cls: "sm-cc-auto" });

  // Calculator WITHOUT onUpdate to prevent infinite loop
  // Input handlers update fields directly and call onUpdate manually
  const calculator = new EntryAutoCalculator(entry, data, undefined);

  // Shared Ability dropdown (used for both to_hit and damage)
  const abilityGroup = autoRow.createDiv({ cls: "sm-auto-group" });
  abilityGroup.createSpan({ text: "Ability:" });

  const abilityHandle = createSelectDropdown(abilityGroup, {
    options: CREATURE_ABILITY_SELECTIONS.map((v) => ({ value: v, label: v || "(von)" })),
    value: entry.to_hit_from?.ability || entry.damage_from?.ability || "",
    enableSearch: true,
    searchPlaceholder: "Such-dropdownâ€¦",
    onChange: (value) => {
      // Update to_hit
      const proficient = toHitProfCheckbox.checked;
      if (value) {
        calculator.setToHitAuto({ ability: value, proficient });
      } else {
        calculator.setToHitAuto(undefined);
      }
      toHitInput.value = entry.to_hit || "";

      // Update damage - always try if we have dice in entry data
      const dice = dmgDiceInput.value.trim() || entry.damage_from?.dice || "";
      const bonus = dmgBonusInput.value.trim() || entry.damage_from?.bonus || "";
      if (dice) {
        calculator.setDamageAuto({ dice, ability: value || undefined, bonus: bonus || undefined });
        dmgInput.value = entry.damage || "";
      } else if (entry.damage_from) {
        // Fallback: apply existing damage_from config
        calculator.apply();
        dmgInput.value = entry.damage || "";
      }
    },
  });

  // To Hit Group
  const hitGroup = autoRow.createDiv({ cls: "sm-auto-group" });
  hitGroup.createSpan({ text: "To hit:" });

  const toHitProfCheckbox = hitGroup.createEl("input", {
    attr: { type: "checkbox", id: `hit-prof-${entryIndex}` },
  }) as HTMLInputElement;
  toHitProfCheckbox.checked = entry.to_hit_from?.proficient || false;
  toHitProfCheckbox.onchange = () => {
    const ability = abilityHandle.getValue();
    if (ability) {
      calculator.setToHitAuto({ ability, proficient: toHitProfCheckbox.checked });
      toHitInput.value = entry.to_hit || "";
    }
  };

  hitGroup.createEl("label", { text: "Prof", attr: { for: `hit-prof-${entryIndex}` } });

  const toHitInput = createTextInput(hitGroup, {
    className: "sm-auto-tohit",
    placeholder: "+7",
    ariaLabel: "To hit",
    value: entry.to_hit || "",
    onInput: (value) => {
      entry.to_hit = value.trim() || undefined;
      onUpdate();
    },
  });
  (toHitInput.style as any).width = "6ch";

  // Damage Group
  const dmgGroup = autoRow.createDiv({ cls: "sm-auto-group" });
  dmgGroup.createSpan({ text: "Damage:" });

  const dmgDiceInput = createTextInput(dmgGroup, {
    placeholder: "1d8",
    ariaLabel: "WÃ¼rfel",
    value: entry.damage_from?.dice || "",
    onInput: (value) => {
      const ability = abilityHandle.getValue() || entry.damage_from?.ability || undefined;
      const bonus = dmgBonusInput.value.trim() || entry.damage_from?.bonus || undefined;
      if (value.trim()) {
        calculator.setDamageAuto({ dice: value.trim(), ability, bonus });
      } else {
        calculator.setDamageAuto(undefined);
      }
      dmgInput.value = entry.damage || "";
    },
  });
  (dmgDiceInput.style as any).width = "10ch";

  const dmgBonusInput = createTextInput(dmgGroup, {
    placeholder: "piercing / slashing â€¦",
    ariaLabel: "Art",
    value: entry.damage_from?.bonus || "",
    onInput: (value) => {
      const dice = dmgDiceInput.value.trim() || entry.damage_from?.dice || "";
      const ability = abilityHandle.getValue() || entry.damage_from?.ability || undefined;
      if (dice) {
        calculator.setDamageAuto({ dice, ability, bonus: value.trim() || undefined });
        dmgInput.value = entry.damage || "";
      }
    },
  });
  (dmgBonusInput.style as any).width = "12ch";

  const dmgInput = createTextInput(dmgGroup, {
    className: "sm-auto-dmg",
    placeholder: "1d8 +3 piercing",
    ariaLabel: "Schaden",
    value: entry.damage || "",
    onInput: (value) => {
      entry.damage = value.trim() || undefined;
      onUpdate();
    },
  });
  (dmgInput.style as any).width = "20ch";

  // Apply initial auto-calculation if configured
  if (entry.to_hit_from || entry.damage_from) {
    calculator.apply();
    toHitInput.value = entry.to_hit || "";
    dmgInput.value = entry.damage || "";
  }
}

/**
 * Creates the meta section (Save, DC, Recharge)
 */
export function createMetaSection(
  parent: HTMLElement,
  entry: CreatureEntry,
  onUpdate: () => void
): void {
  const section = parent.createDiv({ cls: "sm-cc-entry-section sm-cc-entry-section--meta" });
  const grid = section.createDiv({ cls: "sm-cc-entry-grid" });

  // Save Ability
  grid.createEl("label", { text: "Save" });
  const saveAbilHandle = createSelectDropdown(grid, {
    options: CREATURE_SAVE_OPTIONS.map((v) => ({ value: v, label: v || "(kein)" })),
    value: entry.save_ability || "",
    onChange: (value) => {
      entry.save_ability = value || undefined;
      onUpdate();
    },
  });

  // Save DC
  grid.createEl("label", { text: "DC" });
  const saveDcInput = grid.createEl("input", {
    attr: { type: "number", placeholder: "DC", "aria-label": "DC" },
  }) as HTMLInputElement;
  saveDcInput.value = entry.save_dc ? String(entry.save_dc) : "";
  saveDcInput.oninput = () => {
    entry.save_dc = saveDcInput.value ? parseInt(saveDcInput.value, 10) : (undefined as any);
    onUpdate();
  };
  (saveDcInput.style as any).width = "4ch";

  // Save Effect
  grid.createEl("label", { text: "Save-Effekt" });
  const saveEffectInput = createTextInput(grid, {
    placeholder: "half on save â€¦",
    ariaLabel: "Save-Effekt",
    value: entry.save_effect || "",
    onInput: (value) => {
      entry.save_effect = value.trim() || undefined;
      onUpdate();
    },
  });
  (saveEffectInput.style as any).width = "18ch";

  // Recharge
  grid.createEl("label", { text: "Recharge" });
  createTextInput(grid, {
    placeholder: "Recharge 5â€“6 / 1/day",
    ariaLabel: "Recharge",
    value: entry.recharge || "",
    onInput: (value) => {
      entry.recharge = value.trim() || undefined;
    },
  });
}

/**
 * Creates the details section (Text description)
 */
export function createDetailsSection(
  parent: HTMLElement,
  entry: CreatureEntry,
  onUpdate: () => void
): void {
  const section = parent.createDiv({ cls: "sm-cc-entry-section sm-cc-entry-section--details" });
  section.createEl("label", { cls: "sm-cc-entry-label", text: "Details" });

  createTextArea(section, {
    className: "sm-cc-entry-text",
    placeholder: "Details (Markdown)",
    ariaLabel: "Details",
    value: entry.text || "",
    onInput: (value) => {
      entry.text = value;
      onUpdate();
    },
  });
}

/**
 * Creates the spellcasting section (Spell Ability, DC Override, Attack Override, Spell Groups)
 */
export function createSpellcastingSection(
  parent: HTMLElement,
  entry: CreatureEntry,
  data: StatblockData,
  onUpdate: () => void
): void {
  const section = parent.createDiv({ cls: "sm-cc-entry-section sm-cc-entry-section--spellcasting" });

  // Initialize spellGroups if not present
  if (!entry.spellGroups) {
    entry.spellGroups = [];
  }

  // Header row with spell ability and overrides
  const headerGrid = section.createDiv({ cls: "sm-cc-entry-grid" });

  // Spell Ability
  headerGrid.createEl("label", { text: "Spell Ability" });
  const spellAbilityHandle = createSelectDropdown(headerGrid, {
    options: [
      { value: "", label: "(none)" },
      ...CREATURE_ABILITY_LABELS.map((label) => ({
        value: label.toLowerCase(),
        label
      })),
    ],
    value: entry.spellAbility || "",
    onChange: (value) => {
      entry.spellAbility = (value || undefined) as any;
      onUpdate();
    },
  });

  // DC Override
  headerGrid.createEl("label", { text: "DC Override" });
  createNumberInput(headerGrid, {
    placeholder: "Auto",
    ariaLabel: "DC Override",
    value: entry.spellDcOverride,
    min: 1,
    max: 30,
    onChange: (value) => {
      entry.spellDcOverride = value;
      onUpdate();
    },
  });

  // Attack Bonus Override
  headerGrid.createEl("label", { text: "Attack Override" });
  const attackOverrideInput = headerGrid.createEl("input", {
    cls: "sm-cc-input",
    attr: {
      type: "text",
      placeholder: "Auto",
      "aria-label": "Attack Override"
    },
  }) as HTMLInputElement;
  attackOverrideInput.value = entry.spellAttackOverride !== undefined ? String(entry.spellAttackOverride) : "";
  attackOverrideInput.oninput = () => {
    const val = attackOverrideInput.value.trim();
    entry.spellAttackOverride = val ? parseInt(val, 10) : undefined;
    onUpdate();
  };
  (attackOverrideInput.style as any).width = "6ch";

  // Spell Groups container
  const groupsContainer = section.createDiv({ cls: "sm-cc-spellcasting-groups" });

  // Helper to render all spell groups
  const renderAllGroups = () => {
    groupsContainer.empty();

    // Group types in order: at-will, per-day, then levels 1-9
    const groupsByType = {
      'at-will': [] as SpellGroup[],
      'per-day': [] as SpellGroup[],
      'level': [] as SpellGroup[],
    };

    // Categorize existing groups
    entry.spellGroups?.forEach(group => {
      if (groupsByType[group.type]) {
        groupsByType[group.type].push(group);
      }
    });

    // Sort level groups by level
    groupsByType.level.sort((a, b) => (a.level || 0) - (b.level || 0));

    // Render At-Will groups
    groupsByType['at-will'].forEach((group, index) => {
      renderSpellGroup(groupsContainer, group, index, 'at-will');
    });

    // Render Per-Day groups
    groupsByType['per-day'].forEach((group, index) => {
      renderSpellGroup(groupsContainer, group, index, 'per-day');
    });

    // Render Level groups
    groupsByType.level.forEach((group, index) => {
      renderSpellGroup(groupsContainer, group, index, 'level');
    });

    // Add buttons for creating new groups
    const addButtonsRow = groupsContainer.createDiv({ cls: "sm-cc-spellcasting-add-buttons" });

    const addAtWillBtn = addButtonsRow.createEl("button", {
      cls: "sm-cc-button",
      text: "+ At-Will Group",
      attr: { type: "button" },
    });
    addAtWillBtn.onclick = () => {
      entry.spellGroups!.push({
        type: 'at-will',
        label: 'At Will',
        spells: [],
      });
      renderAllGroups();
      onUpdate();
    };

    const addPerDayBtn = addButtonsRow.createEl("button", {
      cls: "sm-cc-button",
      text: "+ Per-Day Group",
      attr: { type: "button" },
    });
    addPerDayBtn.onclick = () => {
      entry.spellGroups!.push({
        type: 'per-day',
        label: '1/Day each',
        spells: [],
      });
      renderAllGroups();
      onUpdate();
    };

    const addLevelBtn = addButtonsRow.createEl("button", {
      cls: "sm-cc-button",
      text: "+ Spell Level",
      attr: { type: "button" },
    });
    addLevelBtn.onclick = () => {
      // Find first unused level
      const usedLevels = new Set(
        entry.spellGroups!
          .filter(g => g.type === 'level')
          .map(g => g.level || 0)
      );
      let nextLevel = 1;
      while (usedLevels.has(nextLevel) && nextLevel <= 9) {
        nextLevel++;
      }
      if (nextLevel <= 9) {
        entry.spellGroups!.push({
          type: 'level',
          level: nextLevel,
          slots: 2,
          label: getLevelLabel(nextLevel),
          spells: [],
        });
        renderAllGroups();
        onUpdate();
      }
    };
  };

  // Helper to render a single spell group
  const renderSpellGroup = (
    container: HTMLElement,
    group: SpellGroup,
    groupIndex: number,
    groupType: 'at-will' | 'per-day' | 'level'
  ) => {
    const groupCard = container.createDiv({ cls: `sm-cc-spellcasting-group sm-cc-spellcasting-group--${groupType}` });

    // Group header
    const groupHeader = groupCard.createDiv({ cls: "sm-cc-spellcasting-group-header" });

    // Group label/title
    if (groupType === 'level') {
      // Level selector
      const levelSelect = createSelectDropdown(groupHeader, {
        className: "sm-cc-spellcasting-level-select",
        options: [1, 2, 3, 4, 5, 6, 7, 8, 9].map(lvl => ({
          value: lvl,
          label: getLevelLabel(lvl),
        })),
        value: group.level || 1,
        onChange: (value) => {
          group.level = value as number;
          group.label = getLevelLabel(value as number);
          onUpdate();
        },
      });

      // Slots input
      groupHeader.createSpan({ text: " - " });
      const slotsInput = createNumberInput(groupHeader, {
        className: "sm-cc-spellcasting-slots",
        placeholder: "Slots",
        ariaLabel: "Spell Slots",
        value: group.slots || 0,
        min: 0,
        max: 20,
        onChange: (value) => {
          group.slots = value || 0;
          onUpdate();
        },
      });
      (slotsInput.style as any).width = "4ch";
      groupHeader.createSpan({ text: " slots" });
    } else {
      // Editable label for at-will and per-day
      const labelInput = createTextInput(groupHeader, {
        className: "sm-cc-spellcasting-group-label",
        placeholder: groupType === 'at-will' ? 'At Will' : '1/Day each',
        ariaLabel: "Group Label",
        value: group.label || "",
        onInput: (value) => {
          group.label = value.trim() || undefined;
          onUpdate();
        },
      });
    }

    // Delete group button
    const deleteGroupBtn = groupHeader.createEl("button", {
      cls: "sm-cc-entry-delete",
      text: "Ã—",
      attr: { type: "button", "aria-label": "Delete Group" },
    });
    deleteGroupBtn.onclick = () => {
      const actualIndex = entry.spellGroups!.indexOf(group);
      if (actualIndex !== -1) {
        entry.spellGroups!.splice(actualIndex, 1);
        renderAllGroups();
        onUpdate();
      }
    };

    // Spells list
    const spellsList = groupCard.createDiv({ cls: "sm-cc-spellcasting-spells-list" });

    const renderSpells = () => {
      spellsList.empty();

      group.spells.forEach((spell, spellIndex) => {
        const spellRow = spellsList.createDiv({ cls: "sm-cc-spellcasting-spell-row" });

        const spellInput = createTextInput(spellRow, {
          className: "sm-cc-spellcasting-spell-input",
          placeholder: "Spell name",
          ariaLabel: "Spell name",
          value: spell,
          onInput: (value) => {
            group.spells[spellIndex] = value.trim();
            onUpdate();
          },
        });

        const deleteSpellBtn = spellRow.createEl("button", {
          cls: "sm-cc-button-small",
          text: "Ã—",
          attr: { type: "button", "aria-label": "Delete Spell" },
        });
        deleteSpellBtn.onclick = () => {
          group.spells.splice(spellIndex, 1);
          renderSpells();
          onUpdate();
        };
      });

      // Add spell button
      const addSpellBtn = spellsList.createEl("button", {
        cls: "sm-cc-button-small",
        text: "+ Add Spell",
        attr: { type: "button" },
      });
      addSpellBtn.onclick = () => {
        group.spells.push("");
        renderSpells();
        onUpdate();
      };
    };

    renderSpells();
  };

  // Helper to get level label
  const getLevelLabel = (level: number): string => {
    const labels = ["Cantrip", "1st Level", "2nd Level", "3rd Level", "4th Level",
                    "5th Level", "6th Level", "7th Level", "8th Level", "9th Level"];
    return labels[level] || `${level}th Level`;
  };

  // Initial render
  renderAllGroups();
}

/**
 * Creates a complete entry card with all sections
 */
export function createEntryCard(
  parent: HTMLElement,
  options: EntryCardOptions
): HTMLDivElement {
  const { entry, index, data, onDelete, onMoveUp, onMoveDown, canMoveUp, canMoveDown, onUpdate, shouldFocus } = options;

  // Infer the current entry type
  const currentType = inferEntryType(entry);

  const card = parent.createDiv({
    cls: `sm-cc-entry-card sm-cc-entry-card--${entry.category} sm-cc-entry-card--type-${currentType}`,
  });

  // Header
  const head = card.createDiv({ cls: "sm-cc-entry-head" });

  // Category Badge
  const categoryLabels = {
    trait: "Trait",
    action: "Action",
    bonus: "Bonus",
    reaction: "Reaction",
    legendary: "Legendary",
  };
  const categoryLabel = categoryLabels[entry.category as keyof typeof categoryLabels] || "Unknown";
  head.createEl("span", {
    cls: `sm-cc-entry-badge sm-cc-entry-badge--${entry.category}`,
    text: categoryLabel,
  });

  // Type Selector (NEW)
  const typeRow = card.createDiv({ cls: "sm-cc-entry-type-row" });
  typeRow.createEl("label", { text: "Typ:", cls: "sm-cc-entry-type-label" });

  const typeOptions: Array<{ value: EntryType; label: string }> = [
    { value: 'passive', label: 'Passive (Text only)' },
    { value: 'attack', label: 'Attack (To Hit + Damage)' },
    { value: 'save-action', label: 'Save Action (DC + Effect)' },
    { value: 'multiattack', label: 'Multiattack' },
    { value: 'spellcasting', label: 'Spellcasting' },
  ];

  const typeHandle = createSelectDropdown(typeRow, {
    className: "sm-cc-entry-type-select",
    options: typeOptions,
    value: currentType,
    enableSearch: false,
    onChange: (newType) => {
      entry.entryType = newType as EntryType;
      // TODO: In next step, we'll re-render based on type
      onUpdate();
    },
  });

  // Type Badge (visual indicator)
  const typeBadgeLabels: Record<EntryType, string> = {
    'passive': 'Passive',
    'attack': 'Attack',
    'save-action': 'Save',
    'multiattack': 'Multi',
    'spellcasting': 'Spell',
  };
  const typeBadge = typeRow.createEl("span", {
    cls: `sm-cc-entry-type-badge sm-cc-entry-type-badge--${currentType}`,
    text: typeBadgeLabels[currentType],
  });

  // Name Input with Preset Autocomplete
  const nameBox = head.createDiv({ cls: "sm-preset-box sm-cc-entry-name-box" });
  const nameInput = nameBox.createEl("input", {
    cls: "sm-preset-input sm-cc-entry-name",
    attr: { type: "text", placeholder: "Name suchen oder eingebenâ€¦", "aria-label": "Name" },
  }) as HTMLInputElement;
  nameInput.value = entry.name || "";
  nameInput.oninput = () => {
    entry.name = nameInput.value.trim();
  };

  if (shouldFocus) {
    setTimeout(() => nameInput.focus(), 0);
  }

  // Preset Menu
  const presetMenu = nameBox.createDiv({ cls: "sm-preset-menu" });
  const renderPresets = () => {
    const query = (nameInput.value || "").toLowerCase();
    presetMenu.empty();
    const matches = findEntryPresets(query, entry.category);
    if (!matches.length) {
      nameBox.removeClass("is-open");
      return;
    }
    matches.forEach((preset) => {
      const item = presetMenu.createDiv({ cls: "sm-preset-item", text: preset.name });
      item.onclick = () => {
        console.log("[Preset Import] Importing preset:", preset.name, preset);

        // Import preset data
        entry.name = preset.name;
        entry.kind = preset.kind;
        entry.range = preset.range;
        entry.target = preset.target;
        entry.save_ability = preset.save_ability as any;
        entry.save_dc = preset.save_dc as any;
        entry.save_effect = preset.save_effect;
        entry.recharge = preset.recharge;
        entry.text = preset.text;

        // Set to_hit_from for auto-calculation
        if (preset.to_hit_ability) {
          entry.to_hit_from = {
            ability: preset.to_hit_ability as any,
            proficient: preset.to_hit_proficient ?? false,
          };
          entry.to_hit = undefined;
          console.log("[Preset Import] Set to_hit_from:", entry.to_hit_from);
        } else {
          entry.to_hit = preset.to_hit;
          entry.to_hit_from = undefined;
          console.log("[Preset Import] Set manual to_hit:", entry.to_hit);
        }

        // Set damage_from for auto-calculation
        if (preset.damage_dice) {
          entry.damage_from = {
            dice: preset.damage_dice,
            ability: preset.damage_ability as any,
            bonus: preset.damage_type,
          };
          entry.damage = undefined;
          console.log("[Preset Import] Set damage_from:", entry.damage_from);
        } else {
          entry.damage = preset.damage;
          entry.damage_from = undefined;
          console.log("[Preset Import] Set manual damage:", entry.damage);
        }

        // Apply auto-calculations immediately after preset import
        const tempCalculator = new EntryAutoCalculator(entry, data, undefined);
        tempCalculator.apply();

        console.log("[Preset Import] Entry state after calculations:", {
          to_hit: entry.to_hit,
          to_hit_from: entry.to_hit_from,
          damage: entry.damage,
          damage_from: entry.damage_from,
        });

        nameBox.removeClass("is-open");
        console.log("[Preset Import] Calling onUpdate()...");
        onUpdate(); // Re-render to show imported data
      };
    });
    nameBox.addClass("is-open");
  };

  nameInput.addEventListener("focus", renderPresets);
  nameInput.addEventListener("input", () => {
    if (document.activeElement === nameInput) renderPresets();
  });
  nameInput.addEventListener("keydown", (event) => {
    if (event.key === "Escape") {
      nameBox.removeClass("is-open");
    }
  });
  nameInput.addEventListener("blur", () => {
    window.setTimeout(() => nameBox.removeClass("is-open"), 120);
  });


  // Action buttons container
  const actionsContainer = head.createDiv({ cls: "sm-cc-entry-actions" });

  // Move Up Button
  if (onMoveUp) {
    const moveUpBtn = actionsContainer.createEl("button", {
      cls: "sm-cc-entry-move-btn",
      attr: {
        type: "button",
        "aria-label": "Move Up",
        title: "Move Up"
      },
    });
    setIcon(moveUpBtn, "arrow-up");
    moveUpBtn.disabled = !canMoveUp;
    moveUpBtn.onclick = onMoveUp;
  }

  // Move Down Button
  if (onMoveDown) {
    const moveDownBtn = actionsContainer.createEl("button", {
      cls: "sm-cc-entry-move-btn",
      attr: {
        type: "button",
        "aria-label": "Move Down",
        title: "Move Down"
      },
    });
    setIcon(moveDownBtn, "arrow-down");
    moveDownBtn.disabled = !canMoveDown;
    moveDownBtn.onclick = onMoveDown;
  }

  // Delete Button
  const deleteBtn = actionsContainer.createEl("button", {
    cls: "sm-cc-entry-delete",
    text: "ðŸ—‘",
    attr: { type: "button", "aria-label": "LÃ¶schen" },
  });
  deleteBtn.onclick = onDelete;

  // Sub-sections (conditional based on entry type)
  // Basis section: Kind, Range, Target (only for attacks)
  if (currentType === 'attack') {
    createBasisSection(card, entry, onUpdate);
  }

  // Combat section: To Hit, Damage (only for attacks)
  if (currentType === 'attack') {
    createCombatSection(card, entry, data, index, onUpdate);
  }

  // Meta section: Save, DC, Recharge (for save-actions and attacks with recharge)
  if (currentType === 'save-action' || currentType === 'attack') {
    createMetaSection(card, entry, onUpdate);
  }

  // Spellcasting section: Spell Ability, DC, Attack, Spell Groups (only for spellcasting)
  if (currentType === 'spellcasting') {
    createSpellcastingSection(card, entry, data, onUpdate);
  }

  // Details section: Text description (for all types)
  createDetailsSection(card, entry, onUpdate);

  return card;
}
