# Terrain Editor – Übersicht

## Zweck & Prinzipien

- Der Terrain Editor pflegt die globale Terrain-Palette (`TERRAIN_COLORS`, `speed`) und schreibt Änderungen direkt in `SaltMarcher/Terrains.md`.
- UI ist vollständig in `view.ts` implementiert und nutzt den Core-Service `core/terrain-store.ts` als Persistence-Schicht (via Re-Export `apps/terrain-editor/terrain-store.ts`).
- Alle Änderungen lösen eine Aktualisierung der globalen Terrain-Registry (`setTerrains`) aus und informieren verbundene Komponenten (z. B. Map Editor) über das Workspace-Event `salt:terrains-updated`.

---

## Paketstruktur

```
src/apps/terrain-editor/
├─ view.ts                       # Obsidian-View (UI, State, Event-Wiring)
├─ terrain-store.ts              # Re-Export → siehe `src/core/terrain-store.ts`
└─ TerrainEditorOverview.txt     # Dieses Dokument
```

---

## Öffentliche Konstanten & APIs

### `view.ts`

```ts
export const VIEW_TERRAIN_EDITOR = "salt-terrain-editor";
```

- Wird von der Plugin-Registrierung genutzt, um die View anzulegen.

### `core/terrain-store.ts` (Re-Export via `apps/terrain-editor/terrain-store.ts`)

```ts
export const TERRAIN_FILE = "SaltMarcher/Terrains.md";
export async function ensureTerrainFile(app: App): Promise<TFile>;
export function parseTerrainBlock(md: string): Record<string, { color: string; speed: number }>;
export function stringifyTerrainBlock(map: Record<string, { color: string; speed: number }>): string;
export async function loadTerrains(app: App): Promise<Record<string, { color: string; speed: number }>>;
export async function saveTerrains(app: App, next: Record<string, { color: string; speed: number }>): Promise<void>;
export function watchTerrains(app: App, onChange: () => void): () => void;
```

- `ensureTerrainFile` legt bei Bedarf die Markdown-Datei inklusive Default-Palette an.
- Parser/Stringifier akzeptieren V1 (`Name: #color`) und V2 (`Name: #color, speed: n`) Format.

---

## View-Lifecycle & Datenfluss (`view.ts`)

1. **`onOpen`:** Fügt CSS-Klasse `sm-terrain-editor` hinzu, lädt Datei via `loadTerrains`, normalisiert die Datenstruktur auf V2 (`{ color, speed }`), schreibt sie nach `setTerrains` und rendert das UI.
2. **Rendering:**
   - `render()` baut DOM mit Liste editierbarer Zeilen (Name, Color-Picker, Speed-Feld, Delete).
   - Erste Zeile repräsentiert das leere Terrain (`""`) und kann nicht gelöscht werden.
   - `addBar` am Ende legt neue Terrains an.
3. **Benutzerinteraktionen:** Eingaben rufen `upsert`, `renameKey` oder `remove` auf. Diese Methoden aktualisieren den internen State und lösen `render()` plus `commit()` aus.
4. **Persistenz (`commit`):** Serialisiert den State über `saveTerrains`, aktualisiert `setTerrains` global und triggert `salt:terrains-updated`.
5. **Datei-Änderungen:** `watchTerrains` beobachtet das Vault auf `modify`/`delete`. Bei Änderungen wird `refreshFromDisk()` aufgerufen (reload + render) und das Workspace-Event erneut ausgelöst.
6. **`onClose`:** Entfernt Watcher (`unwatch?.()`), weitere Ressourcen werden über Garbage-Collection freigegeben.

---

## Detailübersicht pro Datei

### `view.ts`
- Implementiert `TerrainEditorView` als Obsidian-`ItemView` mit `getViewType`, `getDisplayText`, `getIcon`.
- `normalize` akzeptiert alte Datenmodelle (V1) und ergänzt fehlende Einträge (leeres Terrain).
- Enthält UI-Helfer (`addRow`, `addBar`) und Methoden zur Mutation des lokalen State (`upsert`, `renameKey`, `remove`).
- Jede Mutation ruft `commit` asynchron auf, damit Datei und globale Registry konsistent bleiben.

### `core/terrain-store.ts`
- Sicherer Zugriff auf `Terrains.md` inklusive Erstellung fehlender Ordner.
- `parseTerrainBlock` liest einen Markdown-Codeblock ```terrain``` und erzeugt Map `name -> { color, speed }`. Kommentare/Leerzeilen werden ignoriert.
- `stringifyTerrainBlock` sortiert Einträge (leer zuerst, Rest alphabetisch) und liefert formatierten Codeblock.
- `loadTerrains`/`saveTerrains` kapseln Vault-I/O und verwenden Parser/Stringifier.
- `watchTerrains` registriert `modify`/`delete` Listener, ruft `setTerrains` und ein optionales Callback auf. Rückgabe schließt Listener wieder.
- `src/apps/terrain-editor/terrain-store.ts` re-exportiert diese Funktionen für Legacy-Importe.

---

## Integration mit anderen Modulen

- `core/terrain` nutzt `setTerrains`, um globale Farb-/Speed-Maps zu setzen. Map- und Travel-Editor lesen daraus.
- Map Editor (`brush-options.ts`) lauscht auf `salt:terrains-updated`, um seine Dropdowns zu aktualisieren.
- Parser akzeptiert weiterhin V1-Formate für Abwärtskompatibilität mit bestehenden Dateien.

---

## Erweiterungshinweise

- Erweiterungen (z. B. zusätzliche Attribute pro Terrain) sollten zuerst das Datenmodell in `core/terrain-store.ts` anpassen (Parser + Stringifier) und anschließend das UI in `view.ts` erweitern.
- Für komplexere UIs kann `view.ts` in Unterkomponenten aufgeteilt werden; wichtig ist, dass `commit` weiterhin zentrale Persistenz-Stelle bleibt.
- Bei neuen Events sollte das bestehende Workspace-Signal (`salt:terrains-updated`) weiter genutzt oder erweitert werden, damit andere Module konsistent informiert werden.
