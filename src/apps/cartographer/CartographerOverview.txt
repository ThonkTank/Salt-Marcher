# Cartographer – Overview

## Struktur

```
src/apps/cartographer/
├─ index.ts                 # Obsidian-View inkl. Ribbon/Command-Anbindung
├─ view-shell.ts            # Layout, Map-Stage und Modusverwaltung
├─ modes/
│  └─ travel-guide.ts       # Travel-Guide-Modus (Route/Token, Sidebar, Drag, Persistenz)
└─ CartographerOverview.txt # Dieses Dokument
```

## Features & Verantwortlichkeiten

- **View-Registrierung:** `index.ts` meldet `VIEW_TYPE_CARTOGRAPHER` an, richtet Ribbon & Command ein und kümmert sich um Mount/Cleanup des Views.
- **Layout-Shell:** `view-shell.ts` übernimmt das Travel-Guide-Grundlayout (Header + Body mit Map/Sidebar) und ersetzt Klassen durch `sm-cartographer`.
- **Map-Stage:** Rendert Karten via `createMapLayer`/`renderHexMap`, verwaltet RenderHandles und sorgt für korrekte Hex-Klick-Delegation.
- **Modus-System:** Stellt ein zentrales Mode-Interface (`onEnter`, `onExit`, `onFileChange`, `onHexClick`, `onSave`) bereit, schaltet per Header-Slot zwischen Modi, delegiert Events inkl. Speichern und räumt Ressourcen deterministisch auf.
- **Travel-Integration:** Der neue `modes/travel-guide.ts` spiegelt die Travel-Guide-Funktionalität (Route, Token, Playback) und kann sowohl im Cartographer als auch in der eigenständigen Travel-Guide-View eingesetzt werden.
- **Sidebar-Panels:** Jeder Modus darf den Sidebar-Host exklusiv füllen; Inspect/Notes bleiben Beispiel-Modi und illustrieren einfache Panels.

## Dateibeschreibungen

### `index.ts`
- Exportiert `CartographerView` und `VIEW_TYPE_CARTOGRAPHER`.
- Registriert Ribbon & Command, damit der neue View erreichbar ist.
- Der View erzeugt einen Host (`cartographer-host`) und mountet `view-shell.ts`, reicht `setFile`-Aufrufe weiter und räumt beim Schließen auf.

### `view-shell.ts`
- Implementiert `CartographerMode` & `CartographerModeContext` (inkl. `onSave`) als zentrale Schnittstelle für Modi.
- Baut Header, Body, Map- und Sidebar-Container mit `sm-cartographer`-Klassen auf.
- Nutzt `createMapLayer` + `renderHexMap` zum Laden der Karte (inkl. Options-Parsing via `getFirstHexBlock`/`parseOptions`).
- Leitet `hex:click` an den aktiven Modus weiter, koordiniert `onEnter`/`onExit`/`onFileChange` und serialisiert Moduswechsel.
- Bindet den Map-Header samt Mode-Switch und Save-Hook: `onSave` des Modus kann persistieren/abbrechen, anschließend greift optional die Standard-Speicherlogik (`saveMap`/`saveMapAs`).
- Registriert den Travel-Guide-Modus (`modes/travel-guide.ts`) plus einfache Beispiel-Modi (Inspect, Notes), die Sidebar-Inhalte und RenderHandles/File-State berücksichtigen.
### `modes/travel-guide.ts`
- Travel-Mode, der Sidebar, Playback-Controls, Route-/Token-Layer, Drag-Controller und Kontextmenü bündelt.
- Lädt Terrains einmalig, verwaltet `createTravelLogic` + `handleStateChange` und räumt beim Dateiwechsel konsequent auf.
- `onFileChange` erzeugt Adapter für `createTravelLogic`, ruft `initTokenFromTiles()` nach jedem Kartenwechsel auf und bindet Drag/Contextmenü an die aktuellen Layer.
- `onSave` persistiert das Token (`logic.persistTokenToTiles()`), damit Header-Speicheraktionen weiterhin korrekt arbeiten.

