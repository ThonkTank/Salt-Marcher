# Cartographer – Overview

## Struktur

```
src/apps/cartographer/
├─ index.ts                 # Obsidian-View inkl. Ribbon/Command-Anbindung
├─ view-shell.ts            # Layout, Map-Stage und Modusverwaltung
├─ modes/
│  ├─ editor.ts             # Map-Editor-Modus (Tools, Brush, Sidebar-Panel)
│  └─ travel-guide.ts       # Travel-Guide-Modus (Route/Token, Sidebar, Drag, Persistenz)
└─ CartographerOverview.txt # Dieses Dokument
```

## Features & Verantwortlichkeiten

- **View-Registrierung:** `index.ts` meldet `VIEW_TYPE_CARTOGRAPHER` an, richtet Ribbon & Command ein und kümmert sich um Mount/Cleanup des Views.
- **Layout-Shell:** `view-shell.ts` übernimmt das Cartographer-Grundlayout (Header + Body mit Map/Sidebar), verwaltet den Moduswechsel und stellt `CartographerModeContext` inkl. `getOptions()` bereit.
- **Map-Stage:** Rendert Karten via `createMapLayer`/`renderHexMap`, verwaltet `RenderHandles`, Hex-Klick-Delegation sowie Options-Parsing (`getFirstHexBlock` → `parseOptions`).
- **Modus-System:** Stellt das Mode-Interface (`onEnter`, `onExit`, `onFileChange`, `onHexClick`, `onSave`) bereit, schaltet per Header-Slot zwischen Modi, delegiert Events und räumt Ressourcen deterministisch auf.
- **Editor-Integration:** `modes/editor.ts` stellt die bisherige Map-Editor-Logik bereit (Tool-Registry, Brush-Handling, Options-Panel) und nutzt direkt die vom Cartographer gerenderten `RenderHandles`.
- **Travel-Integration:** `modes/travel-guide.ts` spiegelt die Travel-Guide-Funktionalität (Route, Token, Playback) und kann sowohl im Cartographer als auch in der eigenständigen Travel-Guide-View eingesetzt werden.
- **Beispiel-Modi:** Die internen Inspect/Notes-Modi illustrieren weiterhin einfache Panels und bleiben als Referenz implementiert.

## Dateibeschreibungen

### `index.ts`
- Exportiert `CartographerView` und `VIEW_TYPE_CARTOGRAPHER`.
- Registriert Ribbon & Command, damit der View erreichbar ist.
- Erzeugt einen Host (`cartographer-host`), mountet `view-shell.ts`, reicht `setFile`-Aufrufe weiter und räumt beim Schließen auf.

### `view-shell.ts`
- Implementiert `CartographerMode` & `CartographerModeContext` (inkl. `getOptions`) als zentrale Schnittstelle für Modi.
- Baut Header, Body, Map- und Sidebar-Container mit `sm-cartographer`-Klassen auf.
- Nutzt `createMapLayer` + `renderHexMap` zum Laden der Karte, aktualisiert `currentOptions` und leitet `hex:click`-Events an den aktiven Modus weiter.
- Bindet den Map-Header samt Mode-Switch und Save-Hook; `onSave` des Modus kann persistieren/abbrechen, anschließend greift optional die Standard-Speicherlogik.
- Registriert Travel-, Editor- sowie Beispiel-Modi und sorgt für konsistente `onEnter`/`onExit`/`onFileChange`-Sequenzen.

### `modes/editor.ts`
- Erzeugt das Editor-Panel im Sidebar-Host, zeigt Dateiname & Tool-Auswahl (derzeit nur Brush) und liefert Statusmeldungen.
- Verwaltet Tool-Lifecycle (`mountPanel`, `onActivate`, `onMapRendered`, `onHexClick`) mit einem gemeinsamen `ToolContext`.
- Reagiert auf `onFileChange`, übernimmt `RenderHandles`/Hex-Optionen vom Cartographer und aktualisiert den Brush-Kreis ohne Re-Render.

### `modes/travel-guide.ts`
- Travel-Mode mit Sidebar, Playback-Controls, Route-/Token-Layer, Drag-Controller und Kontextmenü.
- Lädt Terrains einmalig, verwaltet `createTravelLogic` + `handleStateChange` und räumt beim Dateiwechsel konsequent auf.
- Persistiert den Token über `onSave` (`logic.persistTokenToTiles()`), damit Header-Speicheraktionen korrekt arbeiten.

