# Travel Guide – Modularer Schnitt

## Prinzipien

- Eine Datei ⇢ eine klar umrissene Verantwortung.
- Öffentliche API minimal halten. UI-Schichten rufen nur wohldefinierte Logik-Funktionen auf.
- Kein dauerhafter Zustand in der UI. Mutabler Zustand liegt ausschließlich im Store.
- Rendering kümmert sich nur ums Zeichnen (SVG/DOM) und bleibt zustandslos.
- Services kapseln I/O (Hex-Notes, Terrain) und sind die einzige Schicht mit Dateisystemzugriff.

---

## Paketstruktur

```
src/apps/travel-guide/
├─ index.ts                       # Obsidian-Plugin & View-Lifecycle (Mount/Unmount)
├─ TravelGuideOverview.txt        # Dieses Architektur-Dokument
│
├─ domain/                        # Business-Logik + State
│  ├─ types.ts                    # Basistypen (Coord, RouteNode, LogicStateSnapshot)
│  ├─ state.store.ts              # Store mit subscribe/set/replace/emit
│  ├─ actions.ts                  # Public TravelLogic-API (Klick, Drag, Delete, Token, Playback)
│  ├─ expansion.ts                # lineOddR-Helfer (expand/dedupe/rebuild)
│  ├─ playback.ts                 # Token-Abspielschleife (Terrain×Speed, Persist)
│  ├─ persistence.ts              # token_travel-Flag lesen/schreiben (Hex Notes)
│  └─ terrain.service.ts          # Terrain-Geschwindigkeiten kapseln
│
├─ infra/
│  └─ adapter.ts                  # UI↔Domain-Adapter-Typen (RenderAdapter, TokenCtl)
│
├─ render/
│  └─ draw-route.ts               # Reines SVG-Rendering (Polyline, Dots, Highlight)
│
└─ ui/
   ├─ view-shell.ts               # mountTravelGuide: Layout, Adapter, Wiring, Cleanup
   ├─ map-layer.ts                # renderHexMap + Poly-Index + ensurePolys/centerOf
   ├─ route-layer.ts              # Wrapper um drawRoute + Highlight-Steuerung
   ├─ token-layer.ts              # Sichtbares Token (SVG <g>, RAF-Animation)
   ├─ drag.controller.ts          # Pointerdown/move/up, Ghost-Preview, Commit via Logik
   ├─ contextmenue.ts             # RMB auf Dots → deleteUserAt
   └─ sidebar.ts                  # Sidebar für Karten-Titel, Status & Speed-Steuerung
```

> Zielgrößen: 80–180 LOC pro Modul, maximal 300 LOC.

---

## Öffentliche Schnittstellen

### `domain/types.ts`

```ts
export type Coord = { r: number; c: number };
export type NodeKind = "user" | "auto";
export type RouteNode = Coord & { kind: NodeKind };

export type LogicStateSnapshot = {
  tokenRC: Coord;
  route: RouteNode[];        // Wegpunkte nach dem Token
  editIdx: number | null;    // aktuell selektierter Dot
  tokenSpeed: number;        // Multiplikator für playback
  currentTile: Coord | null; // Fortschritt beim Abspielen
  playing: boolean;          // true während Playback-Schleife
};
```

### `infra/adapter.ts`

```ts
export type TokenCtl = {
  setPos(x: number, y: number): void;
  moveTo(x: number, y: number, durMs: number): Promise<void> | void;
  show(): void;
  hide(): void;
  destroy?: () => void;
};

export type RenderAdapter = {
  ensurePolys(coords: Coord[]): void;
  centerOf(rc: Coord): { x: number; y: number } | null;
  draw(route: RouteNode[], tokenRC: Coord): void;
  token: TokenCtl;
};
```

### `domain/actions.ts`

```ts
export type TravelLogic = {
  getState(): LogicStateSnapshot;
  selectDot(idx: number | null): void;
  handleHexClick(rc: Coord): void;
  moveSelectedTo(rc: Coord): void;
  moveTokenTo(rc: Coord): void;
  deleteUserAt(idx: number): void;
  play(): Promise<void>;
  pause(): void;
  setTokenSpeed(v: number): void;
  bindAdapter(adapter: RenderAdapter): void;
  initTokenFromTiles(): Promise<void>;
  persistTokenToTiles(): Promise<void>;
};
```

---

## Datenfluss (kurz)

1. **Mount:** `index.ts` erstellt im View `mountTravelGuide(app, host, file)`. Die Shell richtet einen Spalten-Wrapper mit gemeinsamem Map-Header (`ui/map-header.ts`) ein, lädt Terrain-Daten, baut Map/Route/Token-Layer und instanziiert `createTravelLogic` (Basisdauer 900 ms). Der Header verknüpft Open/Create mit `enqueueLoad` und ruft beim Speichern `persistTokenToTiles` plus `saveMap`/`saveMapAs`.
2. **Store-Abos:** `createTravelLogic` subscribed auf den Store. Jede Änderung triggert `adapter.draw(route, tokenRC)` und optionales `onChange` (View rendert Highlight).
3. **Hex-Klick:** `map-layer` emittiert `hex:click` → `view-shell` ruft `logic.handleHexClick(rc)` → `expandCoords` erzeugt Autos → Store-Update → Route-Layer zeichnet neu.
4. **Dot-Drag:** `drag.controller` zeigt Ghost (nur UI), `pointerup` → `logic.moveSelectedTo(rc)` → neue Segmente via `expandCoords` → Store-Update.
5. **Token-Drag:** `drag.controller` Ghost via `TokenCtl`, Commit → `logic.moveTokenTo(rc)` liest Route-Anker aus dem Store, rekonstruiert Token + Route über `store.set` und persistiert Tiles; der Store-Subscriber zeichnet unmittelbar neu.
6. **RMB:** `contextmenue` prüft Dot-Kind, löscht nur `user` via `logic.deleteUserAt(idx)` → Brücke neu expandiert.
7. **Playback:** `logic.play()` → `createPlayback` iteriert Route, lädt Terrain-Speed, animiert Token, persistiert Position und trimmt passierte Knoten. `pause()` stoppt Schleife.
8. **Token-Initialisierung:** `logic.initTokenFromTiles()` lädt einmalig das `token_travel`-Flag, rekonstruiert Token + Route via Store und legt Flag an, falls fehlend.

---

## Modulrollen (High-Level)

- **UI-Schicht (`ui/`):** Layout, Rendering (SVG), Pointer/RMB-Interaktionen. Keine Regeln – ruft Domain-Funktionen.
- **Domain (`domain/`):** Geschäftslogik, State-Verwaltung, Route-Auf/Abbau, Playback, Persistenz.
- **Infra (`infra/adapter.ts`):** Typisierte Brücke zwischen Domain und Rendering.
- **Rendering (`render/draw-route.ts`):** Reine SVG-Manipulation (Polyline, Dots, Highlight).
- **Entry (`index.ts`):** Obsidian-spezifische Registrierung der View & Commands.

---

## Farbkonzept (Token & Route)

- **Token (`.tg-token__circle`):** kräftiges Violett (`--tg-color-token`, fallback `#9c6dfb`) mit Border (`var(--background-modifier-border)`) und 95 % Deckkraft für eine deutliche Start-/Playback-Markierung.
- **User-Anker (`.tg-route-dot--user`):** warmes Orange (`--tg-color-user-anchor`, fallback `#f59e0b`) bei 95 % Deckkraft, damit manuelle Wegpunkte hervorstechen.
- **Auto-Punkte (`.tg-route-dot--auto`):** kühles Blau (`--tg-color-auto-point`, fallback `#3b82f6`) mit reduzierter Deckkraft (55 %), um ergänzte Zwischenknoten subtiler zu halten.
- **Highlight (`.is-highlighted`):** Domain-Highlighting erhöht weiterhin Radius + Border; zusätzlich hebt CSS die Deckkraft auf 100 % (User) bzw. 90 % (Auto), damit der aktuelle Fokus sofort sichtbar ist.

Alle Farbwerte lassen sich über die jeweiligen Custom Properties überschreiben und nehmen vorhandene Obsidian-Theme-Variablen als bevorzugte Quelle.

---

## Detailübersicht pro Datei

### `index.ts`
- Registriert `VIEW_TYPE_TRAVEL_GUIDE`, Commands („Open Travel Guide“, „…for current file“) und optionales Ribbon-Icon.
- `TravelGuideView` verwaltet Host-Element, ruft beim Öffnen `mountTravelGuide`, leitet `setFile` an den Controller weiter und sorgt für Cleanup in `onClose()`; der Controller-Typ (`TravelGuideController`) wird direkt aus `ui/view-shell.ts` importiert.
- `activateTravelGuide(file?)` holt oder erstellt das Leaf, setzt den View-State aktiv und reicht optional eine Map-Datei durch.
- `getOrCreateLeaf()` bevorzugt vorhandene oder rechte Splits (Obsidian API).

- `mountTravelGuide(app, host, file)` setzt den Host auf `.sm-travel-guide`, erzeugt Header + Body (Map-/Sidebar-Container) und führt das Karten-SVG über `createMapLayer` direkt in den linken Bereich ein. Der Header stammt aus `ui/map-header.ts`, verlinkt Öffnen/Erstellen mit `enqueueLoad` und erweitert den Save-Flow um `logic.persistTokenToTiles()`.
- Lädt Terrain-Definitionen (`loadTerrains` → `setTerrains`) einmalig beim Mount.
- Erstellt `routeLayer` und `tokenLayer` gemeinsam auf `mapLayer.handles.contentG` (kamera-transformierte Content-Gruppe), damit Karte, Route und Token identisch gescaled/panned werden.
- Instanziiert `createSidebar` im rechten Bereich, füllt Titel/Status/Schnelleingaben und verbindet `onSpeedChange` mit `logic.setTokenSpeed`.
- Initialisiert `createTravelLogic` (Basisdauer 900 ms) mit einem `onChange`, der Route-Highlight, Sidebar-Tile (`currentTile ?? tokenRC`) und Speed synchronisiert.
- `logic.initTokenFromTiles()` lädt/persistiert die Tokenposition; Hook wird nach dem Mount einmal manuell aufgerufen.
- Richtet Drag- & Kontextmenüs neu ein, sobald `setFile` eine Karte lädt; `setFile` returned ein `Promise` und serialisiert Ladevorgänge.
- Der zurückgegebene `TravelGuideController` sorgt für Cleanup (Drag, Sidebar, Klassen) und akzeptiert `setFile`, um Karte, Titel und Route während der Laufzeit neu zu binden.
- Prüft zuerst `drag.consumeClickSuppression()` und kehrt bei Drag-bedingter Unterdrückung früh zurück; nur echte Klicks rufen `preventDefault`/`stopPropagation` auf, damit Obsidian keine Dash-Ansicht startet, bevor die Logik `handleHexClick` ausführt.

### `ui/map-layer.ts`
- Nutzt `renderHexMap` um das Kartensvg zu erzeugen, verwaltet `RenderHandles`.
- Pflegt `polyToCoord` (`WeakMap<SVGElement, Coord>`) für Hit-Tests.
- `ensurePolys(coords)` delegated an Renderer und indexiert neue Polygone.
- `centerOf(rc)` garantiert vorhandene Polygone und liefert Mittelpunkt (BBox).
- `destroy()` ruft `handles.destroy?.()` sicher.

### `ui/route-layer.ts`
- Erstellt `<g class="tg-route-layer">` im kamera-transformierten `contentG` und delegiert `draw(route, highlightIndex, tokenRC)` an `drawRoute`.
- `highlight(i)` ruft `updateHighlight` (nur UI-Anpassung).
- `destroy()` entfernt die Gruppe.

### `ui/token-layer.ts`
- Erstellt `<g class="tg-token">` inklusive auffälligem Kreis (Radius 14, dicker Rand), versteckt initial, und hängt ihn direkt an das kamera-transformierte `contentG`.
- Nutzt `.tg-token__circle`, damit Farbe, Border und Opazität zentral über CSS gesteuert werden.
- Stellt `setPos`, `moveTo` (RAF-Animation, optional durations), `show`, `hide`, `destroy` bereit und erfüllt damit `TokenCtl`.
- Lässt Pointer-Events aktiv (`cursor: grab`) für Drag-Start.

### `ui/drag.controller.ts`
- Verwaltet Pointer-Events für Dots (`routeLayerEl`) und Token (`tokenEl`).
- Nutzt `polyToCoord` + `document.elementFromPoint` für Ziel-Hex-Erkennung.
- `ghostMoveSelectedDot/Token` verschieben nur UI (kein State).
- `endDrag()` sorgt für Commit über `logic.moveSelectedTo` oder `logic.moveTokenTo` und ruft `adapter.ensurePolys` als Sicherheit.
- Capture-Hook auf `window` setzt früh `suppressNextHexClick`, damit `hex:click` keine Wegpunkte erzeugt, wenn Token/Dots gedrückt werden.
- Stellt `bind`, `unbind`, `consumeClickSuppression` bereit.

### `ui/contextmenue.ts`
- Bindet `contextmenu` auf dem Route-Layer.
- Ignoriert Nicht-Kreis-Elemente und `auto`-Dots, unterdrückt Browser-Menü.
- Ruft bei `user`-Dots `logic.deleteUserAt(idx)` und stoppt Event-Bubbling.

### `ui/sidebar.ts`
- Rendert einen strukturierten Sidebar-Block (`Titel`, `Status`, `Geschwindigkeit`) inkl. CSS-Klassen.
- `setTitle`, `setTile`, `setSpeed` aktualisieren sichtbare Werte; Eingaben werden (>0) validiert.
- `onSpeedChange` registriert den externen Callback, `destroy()` leert den Host. Wird von `view-shell` genutzt.

### `domain/types.ts`
- Definiert Basis-Koordinaten (`Coord`), Knotenarten (`NodeKind`) und `RouteNode`.
- `LogicStateSnapshot` umfasst Token-Position, Route nach dem Token, Edit-Index, Token-Speed, `currentTile` (Playbackfortschritt) und `playing`.

### `domain/state.store.ts`
- `createStore()` initialisiert den Logikstate (`tokenRC`, `route`, `editIdx`, `tokenSpeed`, `currentTile`, `playing`).
- Stellt `get`, `set`, `replace`, `subscribe`, `emit` bereit. `subscribe` ruft das Callback sofort einmal auf.
- `set`/`replace` aktualisieren den State und triggern `emit`.

### `domain/expansion.ts`
- `expandCoords(a,b)` nutzt `lineOddR` und liefert Pfade ohne Start-Duplikat (exkl. Start, inkl. Ende).
- `dedupeCoords(list)` entfernt aufeinanderfolgende Duplikate.
- `rebuildFromAnchors(tokenRC, anchors)` baut komplette Route (Autos + User) zwischen Token und allen User-Ankern neu auf.
- Hilfsfunktionen `asUserNode`/`asAutoNode` markieren Knotenarten.

### `domain/persistence.ts`
- Arbeitet ausschließlich mit `listTilesForMap`, `loadTile`, `saveTile`.
- `loadTokenCoordFromMap` sucht erstes Tile mit Frontmatter `token_travel: true`.
- `writeTokenToTiles` setzt das Flag exakt auf `rc`, entfernt es von allen anderen Tiles (Frontmatter-Merge).

### `domain/playback.ts`
- `createPlayback({ app, getMapFile, adapter, store, baseMs, onChange })` steuert Abspiel-Schleife.
- `play()` prüft Route, setzt `playing=true`, lädt Terrain-Speed (`loadTerrainSpeed`), berechnet Dauer (`baseMs / (terrain×tokenSpeed)`), animiert Token via `adapter.token.moveTo`, persistiert Position (`writeTokenToTiles`) und trimmt passierte Knoten.
- `pause()` setzt `playing=false` und beendet Loop.
- `trimRoutePassed` entfernt Knoten, die mit der Tokenposition übereinstimmen.

### `domain/terrain.service.ts`
- Liest Tile-Frontmatter (`loadTile`) und mappt das `terrain`-Feld über `TERRAIN_SPEEDS`.
- Liefert Fallback 1 bei fehlenden Werten oder Fehlern.
- Einzige Quelle für Terraingeschwindigkeit – derzeit nur im Playback genutzt.

### `domain/actions.ts`
- `createTravelLogic` kapselt gesamten Domänenfluss: Store, Adapterbindung, Playback, Persistenz.
- Subscription auf den Store ruft `cfg.onChange` und `adapter.draw(route, tokenRC)`.
- `handleHexClick` hängt neuen User-Punkt samt Auto-Segmenten an (Quelle = letzter User oder Token).
- `moveSelectedTo` findet Nachbar-User, expandiert Segmente neu, ersetzt Autos, setzt `editIdx` auf neue Position.
- `moveTokenTo` (asynchron) liest Route-Anker aus dem Store, rekonstruiert Route + Token via `store.set` und persistiert in Tiles.
- `deleteUserAt` entfernt nur `user`-Dots und baut Brücken neu.
- `setTokenSpeed`, `play`, `pause` reichen an Store/Playback weiter.
- `bindAdapter` erlaubt Layer-Neuaufbau (Adapter-Swap).
- `initTokenFromTiles` lädt `token_travel`, aktualisiert Token + Route über den Store und legt das Flag an, falls fehlend.
- `persistTokenToTiles` schreibt aktuelle Tokenposition (z. B. beim View-Close).

### `infra/adapter.ts`
- Definiert `TokenCtl` (UI-Kontrolle des Tokens) und `RenderAdapter` (Schnittstelle Domain ↔ Rendering).
- Keine Implementierung, reine Typen.

### `render/draw-route.ts`
- `drawRoute({ layer, route, centerOf, highlightIndex, start })` leert Layer, setzt den Token-Mittelpunkt als erstes Polyline-Segment (ohne zusätzlichen Dot), zeichnet anschließend die Route (falls ≥2 Punkte) und generiert Kreise pro Knoten inklusive `.tg-route-dot` + Typ-Klassen für CSS-gestützte Farbgebung.
- Standardradien: User-Anker = 7 px, Auto-Punkte = 5 px; beide Werte werden als `data-radius` hinterlegt, damit spätere Updates den Baseline-Radius kennen.
- `updateHighlight(layer, highlightIndex)` liest den Baseline-Radius aus `data-radius`, addiert den Highlight-Offset (+2 px), setzt Stroke/Radius, toggelt `.is-highlighted` und delegiert die finale Opazität an CSS.
- Pointer-Events der Polyline deaktiviert, Dots behalten Pointer für Interaktion.

