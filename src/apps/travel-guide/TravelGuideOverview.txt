# Travel Guide – Modularer Schnitt

## Prinzipien

- Eine Datei ⇢ eine klar umrissene Verantwortung.
- Öffentliche API minimal halten. UI-Schichten rufen nur wohldefinierte Logik-Funktionen auf.
- Kein dauerhafter Zustand in der UI. Mutabler Zustand liegt ausschließlich im Store.
- Rendering kümmert sich nur ums Zeichnen (SVG/DOM) und bleibt zustandslos.
- Services kapseln I/O (Hex-Notes, Terrain) und sind die einzige Schicht mit Dateisystemzugriff.

---

## Paketstruktur

```
src/apps/travel-guide/
├─ index.ts                       # Obsidian-Plugin & View-Lifecycle (Mount/Unmount)
├─ TravelGuideOverview.txt        # Dieses Architektur-Dokument
│
├─ domain/                        # Business-Logik + State
│  ├─ types.ts                    # Basistypen (Coord, RouteNode, LogicStateSnapshot)
│  ├─ state.store.ts              # Store mit subscribe/set/replace/emit
│  ├─ actions.ts                  # Public TravelLogic-API (Klick, Drag, Delete, Token, Playback)
│  ├─ expansion.ts                # lineOddR-Helfer (expand/dedupe/rebuild)
│  ├─ playback.ts                 # Token-Abspielschleife (Terrain×Speed, Persist)
│  ├─ persistence.ts              # token_travel-Flag lesen/schreiben (Hex Notes)
│  └─ terrain.service.ts          # Terrain-Geschwindigkeiten kapseln
│
├─ infra/
│  └─ adapter.ts                  # UI↔Domain-Adapter-Typen (RenderAdapter, TokenCtl)
│
├─ render/
│  └─ draw-route.ts               # Reines SVG-Rendering (Polyline, Dots, Highlight)
│
└─ ui/
   ├─ view-shell.ts               # mountTravelGuide: Layout, Adapter, Wiring, Cleanup
   ├─ map-layer.ts                # renderHexMap + Poly-Index + ensurePolys/centerOf
   ├─ route-layer.ts              # Wrapper um drawRoute + Highlight-Steuerung
   ├─ token-layer.ts              # Sichtbares Token (SVG <g>, RAF-Animation)
   ├─ drag.controller.ts          # Pointerdown/move/up, Ghost-Preview, Commit via Logik
   ├─ contextmenue.ts             # RMB auf Dots → deleteUserAt
   ├─ controls.ts                 # Playback-Steuerung (Start/Stopp/Reset) im Sidebar-Controls-Host
   └─ sidebar.ts                  # Sidebar inkl. Controls-Bereich für Karten-Titel, Status & Speed
```

> Zielgrößen: 80–180 LOC pro Modul, maximal 300 LOC.

---

## Featureliste

- **Kartenverwaltung & Persistenz:** Karten lassen sich öffnen, erstellen und speichern; Terrain-Geschwindigkeiten werden beim Mount geladen und Token-Positionen (`token_travel`) automatisch aus den Hex-Notes gelesen bzw. dorthin zurückgeschrieben.
- **Routenaufbau durch Hex-Klicks:** Hex-Klicks erzeugen Nutzeranker, ergänzen automatische Zwischenpunkte entlang der Linie und aktualisieren Highlight & Route-Rendering unmittelbar.
- **Präzise Drag-Interaktionen:** Nutzeranker und Token können mit Ghost-Vorschau verschoben werden; während aktiver Drags werden Hex-Klick-Events vollständig unterdrückt, damit keine zusätzlichen Wegpunkte entstehen.
- **Token-Steuerung & Playback:** Token lassen sich manuell positionieren oder über Play/Stop/Reset animieren; der Playback-Loop berücksichtigt Terrain-Speed, Token-Speed und persistiert Fortschritte pro Tile.
- **Kontextmenü für Nutzeranker:** Rechtsklick auf Nutzerpunkte bietet schnelles Löschen, während Auto-Punkte geschützt bleiben.
- **Sidebar & Statusanzeigen:** Die Sidebar bündelt Playback-Controls, aktuellen Hex, Speed-Regler sowie Karten-Titel, damit alle relevanten Zustände im Blick bleiben.

---

## Öffentliche Schnittstellen

### `domain/types.ts`

```ts
export type Coord = { r: number; c: number };
export type NodeKind = "user" | "auto";
export type RouteNode = Coord & { kind: NodeKind };

export type LogicStateSnapshot = {
  tokenRC: Coord;
  route: RouteNode[];        // Wegpunkte nach dem Token
  editIdx: number | null;    // aktuell selektierter Dot
  tokenSpeed: number;        // Multiplikator für playback
  currentTile: Coord | null; // Fortschritt beim Abspielen
  playing: boolean;          // true während Playback-Schleife
};
```

### `infra/adapter.ts`

```ts
export type TokenCtl = {
  setPos(x: number, y: number): void;
  moveTo(x: number, y: number, durMs: number): Promise<void> | void;
  show(): void;
  hide(): void;
  destroy?: () => void;
};

export type RenderAdapter = {
  ensurePolys(coords: Coord[]): void;
  centerOf(rc: Coord): { x: number; y: number } | null;
  draw(route: RouteNode[], tokenRC: Coord): void;
  token: TokenCtl;
};
```

### `domain/actions.ts`

```ts
export type TravelLogic = {
  getState(): LogicStateSnapshot;
  selectDot(idx: number | null): void;
  handleHexClick(rc: Coord): void;
  moveSelectedTo(rc: Coord): void;
  moveTokenTo(rc: Coord): void;
  deleteUserAt(idx: number): void;
  play(): Promise<void>;
  pause(): void;
  reset(): Promise<void>;
  setTokenSpeed(v: number): void;
  bindAdapter(adapter: RenderAdapter): void;
  initTokenFromTiles(): Promise<void>;
  persistTokenToTiles(): Promise<void>;
};
```

---

## Datenfluss (kurz)

1. **Mount:** `index.ts` erstellt im View `mountTravelGuide(app, host, file)`. Die Shell richtet einen Spalten-Wrapper mit gemeinsamem Map-Header (`ui/map-header.ts`) ein, lädt Terrain-Daten, baut Map/Route/Token-Layer und instanziiert `createTravelLogic` (Mindestdauer 0,1 s pro Tile). Der Header verknüpft Open/Create mit `enqueueLoad` und ruft beim Speichern `persistTokenToTiles` plus `saveMap`/`saveMapAs`.
2. **Store-Abos:** `createTravelLogic` subscribed auf den Store. Jede Änderung triggert `adapter.draw(route, tokenRC)` und optionales `onChange` (View rendert Highlight).
3. **Hex-Klick:** `map-layer` emittiert `hex:click` → `view-shell` ruft `logic.handleHexClick(rc)` → `expandCoords` erzeugt Autos → Store-Update → Route-Layer zeichnet neu.
4. **Dot-Drag:** `drag.controller` zeigt Ghost (nur UI), `pointerup` → `logic.moveSelectedTo(rc)` → neue Segmente via `expandCoords` → Store-Update.
5. **Token-Drag:** `drag.controller` Ghost via `TokenCtl`, Commit → `logic.moveTokenTo(rc)` liest Route-Anker aus dem Store, rekonstruiert Token + Route über `store.set` und persistiert Tiles; der Store-Subscriber zeichnet unmittelbar neu.
6. **RMB:** `contextmenue` prüft Dot-Kind, löscht nur `user` via `logic.deleteUserAt(idx)` → Brücke neu expandiert.
7. **Playback-Steuerung:** `ui/controls.ts` nutzt den Header-Slot für Start/Stopp/Reset. `handleStateChange` füttert `setState` mit `playing` und der aktuellen Route, damit Buttons nur bei verfügbaren Wegpunkten aktiv sind. Klicks triggern `logic.play()`, `logic.pause()` (Stop) bzw. `logic.reset()`. Der Reset stoppt Playback, leert Route/`editIdx`/`currentTile` und ruft `initTokenFromTiles()` zur Token-Neuinitialisierung.
8. **Playback:** `logic.play()` → `createPlayback` iteriert Route, lädt Terrain-Speed, animiert Token (`Math.max(minSecondsPerTile, tokenSpeed×terrainSpeed) * 1000`), persistiert Position und trimmt passierte Knoten. `pause()` setzt `playing=false`, ruft `token.stop()` auf und beendet den Durchlauf.
9. **Token-Initialisierung:** `logic.initTokenFromTiles()` lädt einmalig das `token_travel`-Flag, rekonstruiert Token + Route via Store und legt Flag an, falls fehlend.

---

## Playback-Steuerung & Reset

- Oberhalb der Sidebar-Zeilen liegt `sm-tg-sidebar__controls`; `ui/controls.ts` montiert seine Buttons in diesem Host, damit Play/Stop/Reset direkt neben Speed-Regler und Statuswerten sitzen, während der Map-Header wieder den Dateinamen im Standardslot anzeigt.
- Buttons verwenden weiterhin `applyMapButtonStyle`, zeigen „Start“, „Stopp“ und „Reset“ (Icons: Play, Square, Rotate) und rufen ausschließlich die übergebenen Callbacks (`logic.play()`, `logic.pause()`, `logic.reset()`) auf.
- `handleStateChange` liefert `playing` und `route.length` an `setState`, damit „Start“ nur mit vorhandener Route aktiv ist, „Stopp“ ausschließlich während des Playbacks verfügbar bleibt und „Reset“ die Route leert, auch wenn Playback noch läuft.
- `logic.reset()` ruft immer zuerst `logic.pause()` (sofortiges Abbrechen inkl. Token-Stop), leert Route/Edit-Index/`currentTile` und initialisiert das Token über `initTokenFromTiles()` neu, wodurch Position & Persistenz auf den Kartendaten aktualisiert werden.

---

## Modulrollen (High-Level)

- **UI-Schicht (`ui/`):** Layout, Rendering (SVG), Pointer/RMB-Interaktionen. Keine Regeln – ruft Domain-Funktionen.
- **Domain (`domain/`):** Geschäftslogik, State-Verwaltung, Route-Auf/Abbau, Playback, Persistenz.
- **Infra (`infra/adapter.ts`):** Typisierte Brücke zwischen Domain und Rendering.
- **Rendering (`render/draw-route.ts`):** Reine SVG-Manipulation (Polyline, Dots, Highlight).
- **Entry (`index.ts`):** Obsidian-spezifische Registrierung der View & Commands.

---

## Farbkonzept (Token & Route)

- **Token (`.tg-token__circle`):** kräftiges Violett (`--tg-color-token`, fallback `#9c6dfb`) mit Border (`var(--background-modifier-border)`) und 95 % Deckkraft für eine deutliche Start-/Playback-Markierung.
- **User-Anker (`.tg-route-dot--user`):** warmes Orange (`--tg-color-user-anchor`, fallback `#f59e0b`) bei 95 % Deckkraft, damit manuelle Wegpunkte hervorstechen.
- **Auto-Punkte (`.tg-route-dot--auto`):** kühles Blau (`--tg-color-auto-point`, fallback `#3b82f6`) mit reduzierter Deckkraft (55 %), um ergänzte Zwischenknoten subtiler zu halten.
- **Highlight (`.is-highlighted`):** Domain-Highlighting erhöht weiterhin Radius + Border; zusätzlich hebt CSS die Deckkraft auf 100 % (User) bzw. 90 % (Auto), damit der aktuelle Fokus sofort sichtbar ist.

Alle Farbwerte lassen sich über die jeweiligen Custom Properties überschreiben und nehmen vorhandene Obsidian-Theme-Variablen als bevorzugte Quelle.

---

## Detailübersicht pro Datei

### `index.ts`
- Registriert `VIEW_TYPE_TRAVEL_GUIDE`, Commands („Open Travel Guide“, „…for current file“) und optionales Ribbon-Icon.
- `TravelGuideView` verwaltet Host-Element, ruft beim Öffnen `mountTravelGuide`, leitet `setFile` an den Controller weiter und sorgt für Cleanup in `onClose()`; der Controller-Typ (`TravelGuideController`) wird direkt aus `ui/view-shell.ts` importiert.
- `activateTravelGuide(file?)` holt oder erstellt das Leaf, setzt den View-State aktiv und reicht optional eine Map-Datei durch.
- `getOrCreateLeaf()` bevorzugt vorhandene oder rechte Splits (Obsidian API).

- `mountTravelGuide(app, host, file)` setzt den Host auf `.sm-travel-guide`, erzeugt Header + Body (Map-/Sidebar-Container) und führt das Karten-SVG über `createMapLayer` direkt in den linken Bereich ein. Der Header stammt aus `ui/map-header.ts`, verlinkt Öffnen/Erstellen mit `enqueueLoad` und erweitert den Save-Flow um `logic.persistTokenToTiles()`.
- Lädt Terrain-Definitionen (`loadTerrains` → `setTerrains`) einmalig beim Mount.
- Erstellt `routeLayer` und `tokenLayer` gemeinsam auf `mapLayer.handles.contentG` (kamera-transformierte Content-Gruppe), damit Karte, Route und Token identisch gescaled/panned werden.
- Instanziiert `createSidebar` im rechten Bereich; der Wrapper stellt `controlsHost` für die Playback-Buttons bereit und hält zwei Status-Zeilen (aktuelles Hex, Token-Speed). `onSpeedChange` verbindet die Eingabe mit `logic.setTokenSpeed`.
- Montiert `createPlaybackControls` im `sidebar.controlsHost`, damit Play/Stop/Reset an der Sidebar angedockt bleiben; `handleStateChange` beliefert sie mit `playing/route`, um Aktivierung und Disabled-State zu steuern.
- Initialisiert `createTravelLogic` (Mindestdauer 0,1 s pro Tile) mit einem `onChange`, der Route-Highlight, Sidebar-Tile (`currentTile ?? tokenRC`) und Speed synchronisiert.
- `logic.initTokenFromTiles()` lädt/persistiert die Tokenposition; Hook wird nach dem Mount einmal manuell aufgerufen.
- Richtet Drag- & Kontextmenüs neu ein, sobald `setFile` eine Karte lädt; `setFile` returned ein `Promise` und serialisiert Ladevorgänge.
- Der zurückgegebene `TravelGuideController` sorgt für Cleanup (Drag, Sidebar, Klassen) und akzeptiert `setFile`, um Karte, Titel und Route während der Laufzeit neu zu binden.
- Prüft `drag.consumeClickSuppression()` und cancelt unterdrückte Klicks (`preventDefault` + `stopPropagation`), damit Drag-Abbrüche kein Tile-Open mehr triggern; echte Klicks leitet es weiterhin an `logic.handleHexClick` weiter.

### `ui/map-layer.ts`
- Nutzt `renderHexMap` um das Kartensvg zu erzeugen, verwaltet `RenderHandles`.
- Pflegt `polyToCoord` (`WeakMap<SVGElement, Coord>`) für Hit-Tests.
- `ensurePolys(coords)` delegated an Renderer und indexiert neue Polygone.
- `centerOf(rc)` garantiert vorhandene Polygone und liefert Mittelpunkt (BBox).
- `destroy()` ruft `handles.destroy?.()` sicher.

### `ui/route-layer.ts`
- Erstellt `<g class="tg-route-layer">` im kamera-transformierten `contentG` und delegiert `draw(route, highlightIndex, tokenRC)` an `drawRoute`.
- `highlight(i)` ruft `updateHighlight` (nur UI-Anpassung).
- `destroy()` entfernt die Gruppe.

### `ui/token-layer.ts`
- Erstellt `<g class="tg-token">` inklusive auffälligem Kreis (Radius 14, dicker Rand), versteckt initial, und hängt ihn direkt an das kamera-transformierte `contentG`.
- Nutzt `.tg-token__circle`, damit Farbe, Border und Opazität zentral über CSS gesteuert werden.
- Stellt `setPos`, `moveTo` (RAF-Animation), `stop` (bricht laufende Frames via `cancelAnimationFrame` ab), `show`, `hide`, `destroy` bereit und erfüllt damit `TokenCtl`.
- Lässt Pointer-Events aktiv (`cursor: grab`) für Drag-Start.

### `ui/controls.ts`
- Rendert Start/Stopp/Reset-Buttons im von der Sidebar bereitgestellten Controls-Host (`.sm-tg-sidebar__controls`), nutzt `applyMapButtonStyle` und Obsidian-Icons (`play`, `square`, `rotate-ccw`).
- `setState` aktiviert „Start“ nur mit Route, „Stopp“ nur beim laufenden Playback und „Reset“ sobald entweder Route existiert oder abgespielt wird.
- Klicks lösen ausschließlich die übergebenen Callbacks aus; der Helper hält keinen eigenen Zustand und lässt sich über `destroy()` vollständig entfernen.

### `ui/drag.controller.ts`
- Verwaltet Pointer-Events für Dots (`routeLayerEl`) und Token (`tokenEl`).
- Nutzt `polyToCoord` + `document.elementFromPoint` für Ziel-Hex-Erkennung.
- `ghostMoveSelectedDot/Token` verschieben nur UI (kein State).
- `endDrag()` sorgt für Commit über `logic.moveSelectedTo` oder `logic.moveTokenTo` und ruft `adapter.ensurePolys` als Sicherheit.
- Capture-Hook auf `window` setzt früh `suppressNextHexClick`, damit `hex:click` keine Wegpunkte erzeugt, wenn Token/Dots gedrückt werden.
- `consumeClickSuppression` blockiert Hex-Klicks solange der Drag läuft und leert Unterdrückungs-Flags erst nach Drag-Ende.
- Stellt `bind`, `unbind`, `consumeClickSuppression` bereit.

### `ui/contextmenue.ts`
- Bindet `contextmenu` auf dem Route-Layer.
- Ignoriert Nicht-Kreis-Elemente und `auto`-Dots, unterdrückt Browser-Menü.
- Liest den Zielindex direkt aus `data-idx` (funktioniert für sichtbare Dots & Hitboxen).
- Ruft bei `user`-Dots `logic.deleteUserAt(idx)` und stoppt Event-Bubbling.

### `ui/sidebar.ts`
- Rendert eine kompakte Sidebar mit vorgelagertem `controlsHost` (Klasse `.sm-tg-sidebar__controls`) und zwei Status-Zeilen (aktuelles Hex, Token-Speed) inklusive Styles für Label/Value/Input.
- `controlsHost` dient `view-shell` als Mount-Punkt für die Playback-Buttons; `setTile`, `setSpeed` aktualisieren Werte, `setTitle` hinterlegt den Dateinamen als `data-map-title` auf dem Host (für Tooltips/Debug) und validiert Eingaben (>0).
- `onSpeedChange` registriert den externen Callback, `destroy()` leert den Host und entfernt das Daten-Attribut. Wird von `view-shell` genutzt.

### `domain/types.ts`
- Definiert Basis-Koordinaten (`Coord`), Knotenarten (`NodeKind`) und `RouteNode`.
- `LogicStateSnapshot` umfasst Token-Position, Route nach dem Token, Edit-Index, Token-Speed, `currentTile` (Playbackfortschritt) und `playing`.

### `domain/state.store.ts`
- `createStore()` initialisiert den Logikstate (`tokenRC`, `route`, `editIdx`, `tokenSpeed`, `currentTile`, `playing`).
- Stellt `get`, `set`, `replace`, `subscribe`, `emit` bereit. `subscribe` ruft das Callback sofort einmal auf.
- `set`/`replace` aktualisieren den State und triggern `emit`.

### `domain/expansion.ts`
- `expandCoords(a,b)` nutzt `lineOddR` und liefert Pfade ohne Start-Duplikat (exkl. Start, inkl. Ende).
- `dedupeCoords(list)` entfernt aufeinanderfolgende Duplikate.
- `rebuildFromAnchors(tokenRC, anchors)` baut komplette Route (Autos + User) zwischen Token und allen User-Ankern neu auf.
- Hilfsfunktionen `asUserNode`/`asAutoNode` markieren Knotenarten.

### `domain/persistence.ts`
- Arbeitet ausschließlich mit `listTilesForMap`, `loadTile`, `saveTile`.
- `loadTokenCoordFromMap` sucht erstes Tile mit Frontmatter `token_travel: true`.
- `writeTokenToTiles` setzt das Flag exakt auf `rc`, entfernt es von allen anderen Tiles (Frontmatter-Merge).

### `domain/playback.ts`
- `createPlayback({ app, getMapFile, adapter, store, minSecondsPerTile })` kapselt die Abspiel-Schleife.
- `play()` prüft Route, setzt `playing=true`, lädt Terrain-Speed (`loadTerrainSpeed`), berechnet Dauer (`Math.max(minSecondsPerTile, tokenSpeed×terrainSpeed) * 1000`), animiert via `adapter.token.moveTo`, persistiert Position (`writeTokenToTiles`) und trimmt passierte Knoten. Abbrüche über `token.stop()` lassen die Route unverändert.
- `pause()` setzt `playing=false`, ruft `adapter.token.stop?.()` und beendet den laufenden Durchlauf.
- `trimRoutePassed` entfernt Knoten, die mit der Tokenposition übereinstimmen.

### `domain/terrain.service.ts`
- Liest Tile-Frontmatter (`loadTile`) und mappt das `terrain`-Feld über `TERRAIN_SPEEDS`.
- Liefert Fallback 1 bei fehlenden Werten oder Fehlern.
- Einzige Quelle für Terraingeschwindigkeit – derzeit nur im Playback genutzt.

### `domain/actions.ts`
- `createTravelLogic` kapselt gesamten Domänenfluss: Store, Adapterbindung, Playback, Persistenz.
- Subscription auf den Store ruft `cfg.onChange` und `adapter.draw(route, tokenRC)`.
- `handleHexClick` hängt neuen User-Punkt samt Auto-Segmenten an (Quelle = letzter User oder Token).
- `moveSelectedTo` findet Nachbar-User, expandiert Segmente neu, ersetzt Autos, setzt `editIdx` auf neue Position.
- `moveTokenTo` (asynchron) liest Route-Anker aus dem Store, rekonstruiert Route + Token via `store.set` und persistiert in Tiles.
- `deleteUserAt` entfernt nur `user`-Dots und baut Brücken neu.
- `setTokenSpeed`, `play`, `pause`, `reset` reichen an Store/Playback weiter (`pause` stoppt laufende Animationspromises sofort, `reset` pausiert, leert Route/Edit/Tile und ruft `initTokenFromTiles()`).
- `bindAdapter` erlaubt Layer-Neuaufbau (Adapter-Swap).
- `initTokenFromTiles` lädt `token_travel`, aktualisiert Token + Route über den Store und legt das Flag an, falls fehlend.
- `persistTokenToTiles` schreibt aktuelle Tokenposition (z. B. beim View-Close).

### `infra/adapter.ts`
- Definiert `TokenCtl` (UI-Kontrolle des Tokens, inkl. optionalem `stop()` zum Abbrechen laufender Animationen) und `RenderAdapter` (Schnittstelle Domain ↔ Rendering).
- Keine Implementierung, reine Typen.

### `render/draw-route.ts`
- `drawRoute({ layer, route, centerOf, highlightIndex, start })` leert Layer, setzt den Token-Mittelpunkt als erstes Polyline-Segment (ohne zusätzlichen Dot), zeichnet anschließend die Route (falls ≥2 Punkte) und generiert pro Knoten einen sichtbaren `.tg-route-dot` sowie einen unsichtbaren `.tg-route-dot-hitbox` mit größerem Radius für angenehmere Pointer-Hits.
- Standardradien: User-Anker = 7 px, Auto-Punkte = 5 px; die Hitbox addiert +6 px. Werte werden als `data-radius` hinterlegt, damit spätere Updates den Baseline-Radius kennen.
- `updateHighlight(layer, highlightIndex)` liest den Baseline-Radius aus `data-radius`, addiert den Highlight-Offset (+2 px), setzt Stroke/Radius, toggelt `.is-highlighted` und delegiert die finale Opazität an CSS.
- Pointer-Events der Polyline deaktiviert; sichtbare Dots und Hitbox übernehmen Pointer für Interaktion.

