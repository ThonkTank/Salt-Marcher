# Travel Guide – Modularer Schnitt

## Prinzipien

- Eine Datei ⇢ eine klar umrissene Verantwortung.
- Öffentliche API minimal halten. UI-Schichten rufen nur wohldefinierte Logik-Funktionen auf.
- Kein dauerhafter Zustand in der UI. Mutabler Zustand liegt ausschließlich im Store.
- Rendering kümmert sich nur ums Zeichnen (SVG/DOM) und bleibt zustandslos.
- Services kapseln I/O (Hex-Notes, Terrain) und sind die einzige Schicht mit Dateisystemzugriff.

---

## Paketstruktur

```
src/apps/travel-guide/
├─ index.ts                       # Obsidian-Plugin & View-Lifecycle (Mount/Unmount)
├─ TravelGuideOverview.txt        # Dieses Architektur-Dokument
│
├─ domain/                        # Business-Logik + State
│  ├─ types.ts                    # Basistypen (Coord, RouteNode, LogicStateSnapshot)
│  ├─ state.store.ts              # Store mit subscribe/set/replace/emit
│  ├─ actions.ts                  # Public TravelLogic-API (Klick, Drag, Delete, Token, Playback)
│  ├─ expansion.ts                # lineOddR-Helfer (expand/dedupe/rebuild)
│  ├─ playback.ts                 # Token-Abspielschleife (Terrain×Speed, Persist)
│  ├─ persistence.ts              # token_travel-Flag lesen/schreiben (Hex Notes)
│  └─ terrain.service.ts          # Terrain-Geschwindigkeiten kapseln
│
├─ infra/
│  └─ adapter.ts                  # UI↔Domain-Adapter-Typen (RenderAdapter, TokenCtl)
│
├─ render/
│  └─ draw-route.ts               # Reines SVG-Rendering (Polyline, Dots, Highlight)
│
└─ ui/
   ├─ view-shell.ts               # mountTravelGuide: Layout, Adapter, Wiring, Cleanup
   ├─ map-layer.ts                # renderHexMap + Poly-Index + ensurePolys/centerOf
   ├─ route-layer.ts              # Wrapper um drawRoute + Highlight-Steuerung
   ├─ token-layer.ts              # Sichtbares Token (SVG <g>, RAF-Animation)
   ├─ drag.controller.ts          # Pointerdown/move/up, Ghost-Preview, Commit via Logik
   ├─ contextmenue.ts             # RMB auf Dots → deleteUserAt
   └─ sidebar.ts                  # (Derzeit unbenutzte) Sidebar für Status + Speed-Input
```

> Zielgrößen: 80–180 LOC pro Modul, maximal 300 LOC.

---

## Öffentliche Schnittstellen

### `domain/types.ts`

```ts
export type Coord = { r: number; c: number };
export type NodeKind = "user" | "auto";
export type RouteNode = Coord & { kind: NodeKind };

export type LogicStateSnapshot = {
  tokenRC: Coord;
  route: RouteNode[];        // Wegpunkte nach dem Token
  editIdx: number | null;    // aktuell selektierter Dot
  tokenSpeed: number;        // Multiplikator für playback
  currentTile: Coord | null; // Fortschritt beim Abspielen
  playing: boolean;          // true während Playback-Schleife
};
```

### `infra/adapter.ts`

```ts
export type TokenCtl = {
  setPos(x: number, y: number): void;
  moveTo(x: number, y: number, durMs: number): Promise<void> | void;
  show(): void;
  hide(): void;
  destroy?: () => void;
};

export type RenderAdapter = {
  ensurePolys(coords: Coord[]): void;
  centerOf(rc: Coord): { x: number; y: number } | null;
  draw(route: RouteNode[]): void;
  token: TokenCtl;
};
```

### `domain/actions.ts`

```ts
export type TravelLogic = {
  getState(): LogicStateSnapshot;
  selectDot(idx: number | null): void;
  handleHexClick(rc: Coord): void;
  moveSelectedTo(rc: Coord): void;
  moveTokenTo(rc: Coord): void;
  deleteUserAt(idx: number): void;
  play(): Promise<void>;
  pause(): void;
  setTokenSpeed(v: number): void;
  bindAdapter(adapter: RenderAdapter): void;
  initTokenFromTiles(): Promise<void>;
  persistTokenToTiles(): Promise<void>;
};
```

---

## Datenfluss (kurz)

1. **Mount:** `index.ts` erstellt im View `mountTravelGuide(app, host, file)`. Die Shell lädt Terrain-Daten, baut Map/Route/Token-Layer und instanziiert `createTravelLogic` (Basisdauer 900 ms).
2. **Store-Abos:** `createTravelLogic` subscribed auf den Store. Jede Änderung triggert `adapter.draw(route)` und optionales `onChange` (View rendert Highlight).
3. **Hex-Klick:** `map-layer` emittiert `hex:click` → `view-shell` ruft `logic.handleHexClick(rc)` → `expandCoords` erzeugt Autos → Store-Update → Route-Layer zeichnet neu.
4. **Dot-Drag:** `drag.controller` zeigt Ghost (nur UI), `pointerup` → `logic.moveSelectedTo(rc)` → neue Segmente via `expandCoords` → Store-Update.
5. **Token-Drag:** `drag.controller` Ghost via `TokenCtl`, Commit → `logic.moveTokenTo(rc)` → `rebuildFromAnchors` + Persist in Tiles → Route neu gezeichnet.
6. **RMB:** `contextmenue` prüft Dot-Kind, löscht nur `user` via `logic.deleteUserAt(idx)` → Brücke neu expandiert.
7. **Playback:** `logic.play()` → `createPlayback` iteriert Route, lädt Terrain-Speed, animiert Token, persistiert Position und trimmt passierte Knoten. `pause()` stoppt Schleife.
8. **Token-Initialisierung:** `logic.initTokenFromTiles()` lädt einmalig das `token_travel`-Flag, setzt Token-Position und legt Flag an, falls fehlend.

---

## Modulrollen (High-Level)

- **UI-Schicht (`ui/`):** Layout, Rendering (SVG), Pointer/RMB-Interaktionen. Keine Regeln – ruft Domain-Funktionen.
- **Domain (`domain/`):** Geschäftslogik, State-Verwaltung, Route-Auf/Abbau, Playback, Persistenz.
- **Infra (`infra/adapter.ts`):** Typisierte Brücke zwischen Domain und Rendering.
- **Rendering (`render/draw-route.ts`):** Reine SVG-Manipulation (Polyline, Dots, Highlight).
- **Entry (`index.ts`):** Obsidian-spezifische Registrierung der View & Commands.

---

## Detailübersicht pro Datei

### `index.ts`
- Registriert `VIEW_TYPE_TRAVEL_GUIDE`, Commands („Open Travel Guide“, „…for current file“) und optionales Ribbon-Icon.
- `TravelGuideView` verwaltet Host-Element, ruft beim Öffnen `mountTravelGuide`, leitet `setFile` an den Controller weiter und sorgt für Cleanup in `onClose()`.
- `activateTravelGuide(file?)` holt oder erstellt das Leaf, setzt den View-State aktiv und reicht optional eine Map-Datei durch.
- `getOrCreateLeaf()` bevorzugt vorhandene oder rechte Splits (Obsidian API).

### `ui/view-shell.ts`
- `mountTravelGuide(app, host, file)` leert den Host, beendet sofort wenn keine Datei übergeben wurde, und richtet anschließend SVG-Root & Layers ein.
- Lädt Terrain-Definitionen über den Core-Terrain-Store (`loadTerrains`) und registriert sie über `setTerrains` für die restliche App.
- Baut `mapLayer`, `routeLayer`, `tokenLayer` und kombiniert sie zu einem `RenderAdapter`.
- Initialisiert `createTravelLogic` (Basisdauer 900 ms) und reicht `onChange` durch, um `routeLayer.draw(route, editIdx)` zu triggern.
- Ruft `logic.initTokenFromTiles()` (Token laden/anzeigen).
- Verkabelt `createDragController` (inkl. `polyToCoord` für Hit-Tests) und `bindContextMenu`.
- Listet auf `hex:click` (vom Map-Layer) und ruft `logic.handleHexClick` – Drag-Suppressions werden respektiert.
- Gibt einen Controller mit `destroy()` zurück (remove listener, unbind controller, destroy layers, host leeren).

### `ui/map-layer.ts`
- Nutzt `renderHexMap` um das Kartensvg zu erzeugen, verwaltet `RenderHandles`.
- Pflegt `polyToCoord` (`WeakMap<SVGElement, Coord>`) für Hit-Tests.
- `ensurePolys(coords)` delegated an Renderer und indexiert neue Polygone.
- `centerOf(rc)` garantiert vorhandene Polygone und liefert Mittelpunkt (BBox).
- `destroy()` ruft `handles.destroy?.()` sicher.

### `ui/route-layer.ts`
- Erstellt `<g class="tg-route-layer">` im SVG und delegiert `draw(route, highlightIndex)` an `drawRoute`.
- `highlight(i)` ruft `updateHighlight` (nur UI-Anpassung).
- `destroy()` entfernt die Gruppe.

### `ui/token-layer.ts`
- Erstellt `<g class="tg-token">` inklusive Kreis, versteckt initial.
- Stellt `setPos`, `moveTo` (RAF-Animation, optional durations), `show`, `hide`, `destroy` bereit und erfüllt damit `TokenCtl`.
- Lässt Pointer-Events aktiv (`cursor: grab`) für Drag-Start.

### `ui/drag.controller.ts`
- Verwaltet Pointer-Events für Dots (`routeLayerEl`) und Token (`tokenEl`).
- Nutzt `polyToCoord` + `document.elementFromPoint` für Ziel-Hex-Erkennung.
- `ghostMoveSelectedDot/Token` verschieben nur UI (kein State).
- `endDrag()` sorgt für Commit über `logic.moveSelectedTo` oder `logic.moveTokenTo` und ruft `adapter.ensurePolys` als Sicherheit.
- Stellt `bind`, `unbind`, `consumeClickSuppression` bereit.

### `ui/contextmenue.ts`
- Bindet `contextmenu` auf dem Route-Layer.
- Ignoriert Nicht-Kreis-Elemente und `auto`-Dots, unterdrückt Browser-Menü.
- Ruft bei `user`-Dots `logic.deleteUserAt(idx)` und stoppt Event-Bubbling.

### `ui/sidebar.ts`
- Baut eine rechte Sidebar mit „Status“-Heading, aktuellem Hex (`setTile`) und Speed-Input (`setSpeed`).
- Validiert Speed-Eingaben (>0, default 1) und ruft registrierten Callback `onSpeedChange`.
- `destroy()` entfernt das DOM-Fragment. Momentan noch nicht in `view-shell` eingebunden.

### `domain/types.ts`
- Definiert Basis-Koordinaten (`Coord`), Knotenarten (`NodeKind`) und `RouteNode`.
- `LogicStateSnapshot` umfasst Token-Position, Route nach dem Token, Edit-Index, Token-Speed, `currentTile` (Playbackfortschritt) und `playing`.

### `domain/state.store.ts`
- `createStore()` initialisiert den Logikstate (`tokenRC`, `route`, `editIdx`, `tokenSpeed`, `currentTile`, `playing`).
- Stellt `get`, `set`, `replace`, `subscribe`, `emit` bereit. `subscribe` ruft das Callback sofort einmal auf.
- `set`/`replace` aktualisieren den State und triggern `emit`.

### `domain/expansion.ts`
- `expandCoords(a,b)` nutzt `lineOddR` und liefert Pfade ohne Start-Duplikat (exkl. Start, inkl. Ende).
- `dedupeCoords(list)` entfernt aufeinanderfolgende Duplikate.
- `rebuildFromAnchors(tokenRC, anchors)` baut komplette Route (Autos + User) zwischen Token und allen User-Ankern neu auf.
- Hilfsfunktionen `asUserNode`/`asAutoNode` markieren Knotenarten.

### `domain/persistence.ts`
- Arbeitet ausschließlich mit `listTilesForMap`, `loadTile`, `saveTile`.
- `loadTokenCoordFromMap` sucht erstes Tile mit Frontmatter `token_travel: true`.
- `writeTokenToTiles` setzt das Flag exakt auf `rc`, entfernt es von allen anderen Tiles (Frontmatter-Merge).

### `domain/playback.ts`
- `createPlayback({ app, getMapFile, adapter, store, baseMs, onChange })` steuert Abspiel-Schleife.
- `play()` prüft Route, setzt `playing=true`, lädt Terrain-Speed (`loadTerrainSpeed`), berechnet Dauer (`baseMs / (terrain×tokenSpeed)`), animiert Token via `adapter.token.moveTo`, persistiert Position (`writeTokenToTiles`) und trimmt passierte Knoten.
- `pause()` setzt `playing=false` und beendet Loop.
- `trimRoutePassed` entfernt Knoten, die mit der Tokenposition übereinstimmen.

### `domain/terrain.service.ts`
- Liest Tile-Frontmatter (`loadTile`) und mappt das `terrain`-Feld über `TERRAIN_SPEEDS`.
- Liefert Fallback 1 bei fehlenden Werten oder Fehlern.
- Einzige Quelle für Terraingeschwindigkeit – derzeit nur im Playback genutzt.

### `domain/actions.ts`
- `createTravelLogic` kapselt gesamten Domänenfluss: Store, Adapterbindung, Playback, Persistenz.
- Subscription auf den Store ruft `cfg.onChange` und `adapter.draw(route)`.
- `handleHexClick` hängt neuen User-Punkt samt Auto-Segmenten an (Quelle = letzter User oder Token).
- `moveSelectedTo` findet Nachbar-User, expandiert Segmente neu, ersetzt Autos, setzt `editIdx` auf neue Position.
- `moveTokenTo` (asynchron) repositioniert Token (UI + Store), rebuildet Route per `rebuildFromAnchors` und persistiert in Tiles.
- `deleteUserAt` entfernt nur `user`-Dots und baut Brücken neu.
- `setTokenSpeed`, `play`, `pause` reichen an Store/Playback weiter.
- `bindAdapter` erlaubt Layer-Neuaufbau (Adapter-Swap).
- `initTokenFromTiles` lädt/persistiert Token-Startposition und zeigt Token an.
- `persistTokenToTiles` schreibt aktuelle Tokenposition (z. B. beim View-Close).

### `infra/adapter.ts`
- Definiert `TokenCtl` (UI-Kontrolle des Tokens) und `RenderAdapter` (Schnittstelle Domain ↔ Rendering).
- Keine Implementierung, reine Typen.

### `render/draw-route.ts`
- `drawRoute({ layer, route, centerOf, highlightIndex })` leert Layer, zeichnet Polyline (falls ≥2 Punkte) und generiert Kreise pro Knoten (`user` größer/opaker als `auto`).
- `updateHighlight(layer, highlightIndex)` setzt Stroke/Radius/Opacity für ausgewählten Dot.
- Pointer-Events der Polyline deaktiviert, Dots behalten Pointer für Interaktion.

