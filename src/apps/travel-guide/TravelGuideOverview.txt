# Travel Guide – Modularer Schnitt

## Prinzipien

- Eine Datei ⇢ eine klar umrissene Verantwortung.
- Öffentliche API minimal halten. UI-Schichten rufen nur wohldefinierte Logik-Funktionen auf.
- Kein dauerhafter Zustand in der UI. Mutabler Zustand liegt ausschließlich im Store.
- Rendering kümmert sich nur ums Zeichnen (SVG/DOM) und bleibt zustandslos.
- Services kapseln I/O (Hex-Notes, Terrain) und sind die einzige Schicht mit Dateisystemzugriff.

---

## Paketstruktur

```
src/apps/travel-guide/
├─ index.ts                       # Obsidian-Plugin & View-Lifecycle (Mount/Unmount)
├─ TravelGuideOverview.txt        # Dieses Architektur-Dokument
│
├─ domain/                        # Business-Logik + State
│  ├─ types.ts                    # Basistypen (Coord, RouteNode, LogicStateSnapshot)
│  ├─ state.store.ts              # Store mit subscribe/set/replace/emit
│  ├─ actions.ts                  # Public TravelLogic-API (Klick, Drag, Delete, Token, Playback)
│  ├─ expansion.ts                # lineOddR-Helfer (expand/dedupe/rebuild)
│  ├─ playback.ts                 # Token-Abspielschleife (Terrain×Speed, Persist)
│  ├─ persistence.ts              # token_travel-Flag lesen/schreiben (Hex Notes)
│  └─ terrain.service.ts          # Terrain-Geschwindigkeiten kapseln
│
├─ infra/
│  └─ adapter.ts                  # UI↔Domain-Adapter-Typen (RenderAdapter, TokenCtl)
│
├─ render/
│  └─ draw-route.ts               # Reines SVG-Rendering (Polyline, Dots, Highlight)
│
└─ ui/
   ├─ view-shell.ts               # Mount-Shell: Layout, Header + Delegation an den Cartographer-Travel-Mode
   ├─ map-layer.ts                # renderHexMap + Poly-Index + ensurePolys/centerOf
   ├─ route-layer.ts              # Wrapper um drawRoute + Highlight-Steuerung
   ├─ token-layer.ts              # Sichtbares Token (SVG <g>, RAF-Animation)
   ├─ drag.controller.ts          # Pointerdown/move/up, Ghost-Preview, Commit via Logik
   ├─ contextmenue.ts             # RMB auf Dots → deleteUserAt
   ├─ controls.ts                 # Playback-Steuerung (Start/Stopp/Reset) im Sidebar-Controls-Host
   └─ sidebar.ts                  # Sidebar inkl. Controls-Bereich für Karten-Titel, Status & Speed

├─ ../cartographer/modes/
│  └─ travel-guide.ts             # Wiederverwendbarer Modus: Sidebar, Route/Token-Layer, Drag & Persistenz
```

> Zielgrößen: 80–180 LOC pro Modul, maximal 300 LOC.

---

## Featureliste

- **Kartenverwaltung & Persistenz:** Karten lassen sich öffnen, erstellen und speichern; Terrain-Geschwindigkeiten werden beim Mount geladen und Token-Positionen (`token_travel`) automatisch aus den Hex-Notes gelesen bzw. dorthin zurückgeschrieben.
- **Cartographer-Integration:** Der Modus läuft identisch im Cartographer-View und in der Legacy-Travel-Guide-Shell. Beide mounten die `sm-cartographer`-Struktur (Header, Map-Stage, Sidebar), sodass CSS, Header-Slots und Map-Management (`createMapManager`) geteilt werden.
- **Routenaufbau durch Hex-Klicks:** Hex-Klicks erzeugen Nutzeranker, ergänzen automatische Zwischenpunkte entlang der Linie und aktualisieren Highlight & Route-Rendering unmittelbar.
- **Präzise Drag-Interaktionen:** Nutzeranker und Token können mit Ghost-Vorschau verschoben werden; während aktiver Drags werden Hex-Klick-Events vollständig unterdrückt, damit keine zusätzlichen Wegpunkte entstehen.
- **Token-Steuerung & Playback:** Token lassen sich manuell positionieren oder über Play/Stop/Reset animieren; der Playback-Loop berücksichtigt Terrain-Speed, Token-Speed und persistiert Fortschritte pro Tile.
- **Kontextmenü für Nutzeranker:** Rechtsklick auf Nutzerpunkte bietet schnelles Löschen, während Auto-Punkte geschützt bleiben.
- **Sidebar & Statusanzeigen:** Die Sidebar bündelt Playback-Controls, aktuellen Hex, Speed-Regler sowie Karten-Titel, damit alle relevanten Zustände im Blick bleiben.

---

## Öffentliche Schnittstellen

### `domain/types.ts`

```ts
export type Coord = { r: number; c: number };
export type NodeKind = "user" | "auto";
export type RouteNode = Coord & { kind: NodeKind };

export type LogicStateSnapshot = {
  tokenRC: Coord;
  route: RouteNode[];        // Wegpunkte nach dem Token
  editIdx: number | null;    // aktuell selektierter Dot
  tokenSpeed: number;        // Multiplikator für playback
  currentTile: Coord | null; // Fortschritt beim Abspielen
  playing: boolean;          // true während Playback-Schleife
};
```

### `infra/adapter.ts`

```ts
export type TokenCtl = {
  setPos(x: number, y: number): void;
  moveTo(x: number, y: number, durMs: number): Promise<void> | void;
  show(): void;
  hide(): void;
  destroy?: () => void;
};

export type RenderAdapter = {
  ensurePolys(coords: Coord[]): void;
  centerOf(rc: Coord): { x: number; y: number } | null;
  draw(route: RouteNode[], tokenRC: Coord): void;
  token: TokenCtl;
};
```

### `domain/actions.ts`

```ts
export type TravelLogic = {
  getState(): LogicStateSnapshot;
  selectDot(idx: number | null): void;
  handleHexClick(rc: Coord): void;
  moveSelectedTo(rc: Coord): void;
  moveTokenTo(rc: Coord): void;
  deleteUserAt(idx: number): void;
  play(): Promise<void>;
  pause(): void;
  reset(): Promise<void>;
  setTokenSpeed(v: number): void;
  bindAdapter(adapter: RenderAdapter): void;
  initTokenFromTiles(): Promise<void>;
  persistTokenToTiles(): Promise<void>;
};
```

---

## Datenfluss (kurz)

1. **Mount:** `index.ts` erstellt im View `mountTravelGuide(app, host, file)`. Die Shell richtet Header + Spaltenlayout ein, instanziiert `createTravelGuideMode()` und übergibt einen `CartographerModeContext` (Hosts, Dateizugriff, Map-Layer-Getter). `mode.onEnter` kümmert sich um Terrain-Setup, Sidebar/Playback-Mounting und initiale UI-Räumung. Der Header verbindet Open/Create mit `enqueueLoad` und delegiert den Save-Hook zuerst an den Modus.
2. **Dateiwechsel & Rendering:** `view-shell` serialisiert `setFile`, ruft `createMapLayer` für die Karte auf und übergibt `RenderHandles` bzw. `null` an `mode.onFileChange`. Der Modus baut Route-/Token-Layer, TravelLogic, Drag-Controller und Kontextmenü auf, synchronisiert Sidebar & Playback und räumt beim Wechsel vollständig auf.
3. **Hex-Klick:** `map-layer` emittiert `hex:click` → Shell leitet das Event an `mode.onHexClick` weiter → der Modus prüft Drag-Unterdrückung und ruft `logic.handleHexClick(rc)` → `expandCoords` ergänzt Auto-Punkte → Store-Update → Route-Layer zeichnet neu.
4. **Dot-Drag:** `drag.controller` (innerhalb des Modus) zeigt Ghost-Positionsupdates; `pointerup` commitet via `logic.moveSelectedTo(rc)` → neue Segmente durch `expandCoords` → Store-Update.
5. **Token-Drag:** Derselbe Controller behandelt Token-Drags; Commit → `logic.moveTokenTo(rc)` rekonstruiert Route über `rebuildFromAnchors`, aktualisiert Store, Token-Position & Persistenz.
6. **RMB:** `contextmenue` überwacht Dots, filtert nur `user`-Knoten und ruft `logic.deleteUserAt(idx)`; das UI bleibt vollständig im Modus gekapselt.
7. **Playback-Steuerung:** `ui/controls.ts` sitzt im Sidebar-Controls-Host des Modus. `handleStateChange` liefert `playing` + Route an `setState`, Buttons triggern `logic.play()`, `logic.pause()` bzw. `logic.reset()`.
8. **Playback:** `logic.play()` startet `createPlayback`, das Terrain-Speed + Token-Speed kombiniert, Token animiert, Tiles schreibt und Route-Knoten reduziert. `pause()` stoppt Animation & Status.
9. **Token-Initialisierung & Persistenz:** `mode.onFileChange` ruft `logic.initTokenFromTiles()` nach jedem Kartenwechsel auf. Der Map-Header löst `mode.onSave` aus, damit `logic.persistTokenToTiles()` vor `saveMap`/`saveMapAs` läuft.

---

## Playback-Steuerung & Reset

- Oberhalb der Sidebar-Zeilen liegt `sm-cartographer__travel-controls`; `ui/controls.ts` montiert seine Buttons in diesem Host, damit Play/Stop/Reset direkt neben Speed-Regler und Statuswerten sitzen, während der Map-Header wieder den Dateinamen im Standardslot anzeigt.
- Buttons verwenden weiterhin `applyMapButtonStyle`, zeigen „Start“, „Stopp“ und „Reset“ (Icons: Play, Square, Rotate) und rufen ausschließlich die übergebenen Callbacks (`logic.play()`, `logic.pause()`, `logic.reset()`) auf.
- `handleStateChange` liefert `playing` und `route.length` an `setState`, damit „Start“ nur mit vorhandener Route aktiv ist, „Stopp“ ausschließlich während des Playbacks verfügbar bleibt und „Reset“ die Route leert, auch wenn Playback noch läuft.
- `logic.reset()` ruft immer zuerst `logic.pause()` (sofortiges Abbrechen inkl. Token-Stop), leert Route/Edit-Index/`currentTile` und initialisiert das Token über `initTokenFromTiles()` neu, wodurch Position & Persistenz auf den Kartendaten aktualisiert werden.

---

## Modulrollen (High-Level)

- **UI-Schicht (`ui/`):** Layout, Rendering (SVG), Pointer/RMB-Interaktionen. Keine Regeln – ruft Domain-Funktionen.
- **Domain (`domain/`):** Geschäftslogik, State-Verwaltung, Route-Auf/Abbau, Playback, Persistenz.
- **Infra (`infra/adapter.ts`):** Typisierte Brücke zwischen Domain und Rendering.
- **Rendering (`render/draw-route.ts`):** Reine SVG-Manipulation (Polyline, Dots, Highlight).
- **Entry (`index.ts`):** Obsidian-spezifische Registrierung der View & Commands.

---

## Farbkonzept (Token & Route)

- **Token (`.tg-token__circle`):** kräftiges Violett (`--tg-color-token`, fallback `#9c6dfb`) mit Border (`var(--background-modifier-border)`) und 95 % Deckkraft für eine deutliche Start-/Playback-Markierung.
- **User-Anker (`.tg-route-dot--user`):** warmes Orange (`--tg-color-user-anchor`, fallback `#f59e0b`) bei 95 % Deckkraft, damit manuelle Wegpunkte hervorstechen.
- **Auto-Punkte (`.tg-route-dot--auto`):** kühles Blau (`--tg-color-auto-point`, fallback `#3b82f6`) mit reduzierter Deckkraft (55 %), um ergänzte Zwischenknoten subtiler zu halten.
- **Highlight (`.is-highlighted`):** Domain-Highlighting erhöht weiterhin Radius + Border; zusätzlich hebt CSS die Deckkraft auf 100 % (User) bzw. 90 % (Auto), damit der aktuelle Fokus sofort sichtbar ist.

Alle Farbwerte lassen sich über die jeweiligen Custom Properties überschreiben und nehmen vorhandene Obsidian-Theme-Variablen als bevorzugte Quelle. Die Defaults werden auf `.sm-cartographer--travel` gesetzt, damit sowohl Cartographer-View als auch Legacy-Shell identisch aussehen.

---

## Detailübersicht pro Datei

### `index.ts`
- Registriert `VIEW_TYPE_TRAVEL_GUIDE`, Commands („Open Travel Guide“, „…for current file“) und optionales Ribbon-Icon.
- `TravelGuideView` verwaltet Host-Element, ruft beim Öffnen `mountTravelGuide`, leitet `setFile` an den Controller weiter und sorgt für Cleanup in `onClose()`; der Controller-Typ (`TravelGuideController`) wird direkt aus `ui/view-shell.ts` importiert.
- `activateTravelGuide(file?)` holt oder erstellt das Leaf, setzt den View-State aktiv und reicht optional eine Map-Datei durch.
- `getOrCreateLeaf()` bevorzugt vorhandene oder rechte Splits (Obsidian API).

- `mountTravelGuide(app, host, file)` setzt den Host auf `.sm-cartographer` + `.sm-cartographer--travel`, erzeugt Header + Body (Map-/Sidebar-Container) und instanziiert `createTravelGuideMode()`.
- Baut einen `CartographerModeContext` (Hosts, File-Getter, Map-Layer-Getter), ruft `mode.onEnter` auf und serialisiert Dateiladevorgänge über `enqueueLoad`.
- Lädt Karten via `createMapLayer`, reicht `RenderHandles` an `mode.onFileChange` weiter und leitet `hex:click`-Events an `mode.onHexClick` durch.
- Koppelt den Map-Header (`createMapHeader`) mit dem Modus (`onSave`) und führt Standard-Speicherlogik (`saveMap`/`saveMapAs`) aus, falls der Modus das Speichern nicht vollständig übernimmt.
- Der zurückgegebene `TravelGuideController` wartet laufende Loads ab, ruft `mode.onExit`, zerstört Map-Layer/DOM und entfernt View-Klassen.

### `ui/map-layer.ts`
- Nutzt `renderHexMap` um das Kartensvg zu erzeugen, verwaltet `RenderHandles`.
- Pflegt `polyToCoord` (`WeakMap<SVGElement, Coord>`) für Hit-Tests.
- `ensurePolys(coords)` delegated an Renderer und indexiert neue Polygone.
- `centerOf(rc)` garantiert vorhandene Polygone und liefert Mittelpunkt (BBox).
- `destroy()` ruft `handles.destroy?.()` sicher.

### `ui/route-layer.ts`
- Erstellt `<g class="tg-route-layer">` im kamera-transformierten `contentG` und delegiert `draw(route, highlightIndex, tokenRC)` an `drawRoute`.
- `highlight(i)` ruft `updateHighlight` (nur UI-Anpassung).
- `destroy()` entfernt die Gruppe.

### `render/draw-route.ts`
- Zeichnet Polyline und Wegpunkt-Dots rein über SVG und aktualisiert Highlight-Styles ohne eigenen Zustand.
- Setzt `cursor: grab` für Dots und Hitboxen und belässt ihn auch während `updateHighlight`, damit Drag-Anker denselben Greif-Affordance wie das Token anzeigen.

### `ui/token-layer.ts`
- Erstellt `<g class="tg-token">` inklusive auffälligem Kreis (Radius 14, dicker Rand), versteckt initial, und hängt ihn direkt an das kamera-transformierte `contentG`.
- Nutzt `.tg-token__circle`, damit Farbe, Border und Opazität zentral über CSS gesteuert werden.
- Stellt `setPos`, `moveTo` (RAF-Animation), `stop` (bricht laufende Frames via `cancelAnimationFrame` ab), `show`, `hide`, `destroy` bereit und erfüllt damit `TokenCtl`.
- Lässt Pointer-Events aktiv (`cursor: grab`) für Drag-Start.

### `ui/controls.ts`
- Rendert Start/Stopp/Reset-Buttons im von der Sidebar bereitgestellten Controls-Host (`.sm-cartographer__travel-controls`), nutzt `applyMapButtonStyle` und Obsidian-Icons (`play`, `square`, `rotate-ccw`).
- `setState` aktiviert „Start“ nur mit Route, „Stopp“ nur beim laufenden Playback und „Reset“ sobald entweder Route existiert oder abgespielt wird.
- Klicks lösen ausschließlich die übergebenen Callbacks aus; der Helper hält keinen eigenen Zustand und lässt sich über `destroy()` vollständig entfernen.

### `ui/drag.controller.ts`
- Verwaltet Pointer-Events für Dots (`routeLayerEl`) und Token (`tokenEl`).
- Nutzt `polyToCoord` + `document.elementFromPoint` für Ziel-Hex-Erkennung.
- `ghostMoveSelectedDot/Token` verschieben nur UI (kein State).
- `endDrag()` sorgt für Commit über `logic.moveSelectedTo` oder `logic.moveTokenTo` und ruft `adapter.ensurePolys` als Sicherheit.
- Capture-Hook auf `window` setzt früh `suppressNextHexClick`, damit `hex:click` keine Wegpunkte erzeugt, wenn Token/Dots gedrückt werden.
- `consumeClickSuppression` blockiert Hex-Klicks solange der Drag läuft und leert Unterdrückungs-Flags erst nach Drag-Ende.
- Stellt `bind`, `unbind`, `consumeClickSuppression` bereit.

### `ui/contextmenue.ts`
- Bindet `contextmenu` auf dem Route-Layer.
- Ignoriert Nicht-Kreis-Elemente und `auto`-Dots, unterdrückt Browser-Menü.
- Liest den Zielindex direkt aus `data-idx` (funktioniert für sichtbare Dots & Hitboxen).
- Ruft bei `user`-Dots `logic.deleteUserAt(idx)` und stoppt Event-Bubbling.

### `ui/sidebar.ts`
- Rendert eine kompakte Sidebar mit vorgelagertem `controlsHost` (Klasse `.sm-cartographer__travel-controls`) und zwei Status-Zeilen (aktuelles Hex, Token-Speed) inklusive Styles für Label/Value/Input.
- `controlsHost` dient dem Travel-Mode als Mount-Punkt für die Playback-Buttons; `setTile`, `setSpeed` aktualisieren Werte, `setTitle` hinterlegt den Dateinamen als `data-map-title` auf dem Host (für Tooltips/Debug) und validiert Eingaben (>0).
- `onSpeedChange` registriert den externen Callback, `destroy()` leert den Host und entfernt das Daten-Attribut. Wird vom Travel-Mode genutzt.

### `../cartographer/modes/travel-guide.ts`
- Wiederverwendbarer Modus für Cartographer und die Travel-Guide-Shell: bündelt Sidebar, Playback, Route-/Token-Layer sowie Drag- & Kontextmenü-Handling.
- Lädt Terrain-Definitionen beim ersten `onEnter`, erstellt Sidebar + Playback-Controls und sorgt via Cleanup-Hooks für einen sauberen Abbau in `onExit`.
- `onFileChange` räumt bestehende Layer/Logik auf, baut neue Route-/Token-Layer über `handles.contentG`, instanziiert `createTravelLogic`, bindet Drag/Contextmenü und ruft `logic.initTokenFromTiles()` nach jedem Kartenwechsel auf.
- `handleStateChange` aktualisiert Route-Rendering, Sidebar (Tile/Speed) und Playback-State bei jeder Store-Änderung.
- `onHexClick` respektiert `drag.consumeClickSuppression()` und delegiert echte Klicks an `logic.handleHexClick`; `onSave` persistiert das Token via `logic.persistTokenToTiles()` bevor der Header speichert.

### `domain/types.ts`
- Definiert Basis-Koordinaten (`Coord`), Knotenarten (`NodeKind`) und `RouteNode`.
- `LogicStateSnapshot` umfasst Token-Position, Route nach dem Token, Edit-Index, Token-Speed, `currentTile` (Playbackfortschritt) und `playing`.

### `domain/state.store.ts`
- `createStore()` initialisiert den Logikstate (`tokenRC`, `route`, `editIdx`, `tokenSpeed`, `currentTile`, `playing`).
- Stellt `get`, `set`, `replace`, `subscribe`, `emit` bereit. `subscribe` ruft das Callback sofort einmal auf.
- `set`/`replace` aktualisieren den State und triggern `emit`.

### `domain/expansion.ts`
- `expandCoords(a,b)` nutzt `lineOddR` und liefert Pfade ohne Start-Duplikat (exkl. Start, inkl. Ende).
- `dedupeCoords(list)` entfernt aufeinanderfolgende Duplikate.
- `rebuildFromAnchors(tokenRC, anchors)` baut komplette Route (Autos + User) zwischen Token und allen User-Ankern neu auf.
- Hilfsfunktionen `asUserNode`/`asAutoNode` markieren Knotenarten.

### `domain/persistence.ts`
- Arbeitet ausschließlich mit `listTilesForMap`, `loadTile`, `saveTile`.
- `loadTokenCoordFromMap` sucht erstes Tile mit Frontmatter `token_travel: true`.
- `writeTokenToTiles` setzt das Flag exakt auf `rc`, entfernt es von allen anderen Tiles (Frontmatter-Merge).

### `domain/playback.ts`
- `createPlayback({ app, getMapFile, adapter, store, minSecondsPerTile })` kapselt die Abspiel-Schleife.
- `play()` prüft Route, setzt `playing=true`, lädt Terrain-Speed (`loadTerrainSpeed`), berechnet Dauer (`Math.max(minSecondsPerTile, tokenSpeed×terrainSpeed) * 1000`), animiert via `adapter.token.moveTo`, persistiert Position (`writeTokenToTiles`) und trimmt passierte Knoten. Abbrüche über `token.stop()` lassen die Route unverändert.
- `pause()` setzt `playing=false`, ruft `adapter.token.stop?.()` und beendet den laufenden Durchlauf.
- `trimRoutePassed` entfernt Knoten, die mit der Tokenposition übereinstimmen.

### `domain/terrain.service.ts`
- Liest Tile-Frontmatter (`loadTile`) und mappt das `terrain`-Feld über `TERRAIN_SPEEDS`.
- Liefert Fallback 1 bei fehlenden Werten oder Fehlern.
- Einzige Quelle für Terraingeschwindigkeit – derzeit nur im Playback genutzt.

### `domain/actions.ts`
- `createTravelLogic` kapselt gesamten Domänenfluss: Store, Adapterbindung, Playback, Persistenz.
- Subscription auf den Store ruft `cfg.onChange` und `adapter.draw(route, tokenRC)`.
- `handleHexClick` hängt neuen User-Punkt samt Auto-Segmenten an (Quelle = letzter User oder Token).
- `moveSelectedTo` findet Nachbar-User, expandiert Segmente neu, ersetzt Autos, setzt `editIdx` auf neue Position.
- `moveTokenTo` (asynchron) liest Route-Anker aus dem Store, rekonstruiert Route + Token via `store.set` und persistiert in Tiles.
- `deleteUserAt` entfernt nur `user`-Dots und baut Brücken neu.
- `setTokenSpeed`, `play`, `pause`, `reset` reichen an Store/Playback weiter (`pause` stoppt laufende Animationspromises sofort, `reset` pausiert, leert Route/Edit/Tile und ruft `initTokenFromTiles()`).
- `bindAdapter` erlaubt Layer-Neuaufbau (Adapter-Swap).
- `initTokenFromTiles` lädt `token_travel`, aktualisiert Token + Route über den Store und legt das Flag an, falls fehlend.
- `persistTokenToTiles` schreibt aktuelle Tokenposition (z. B. beim View-Close).

### `infra/adapter.ts`
- Definiert `TokenCtl` (UI-Kontrolle des Tokens, inkl. optionalem `stop()` zum Abbrechen laufender Animationen) und `RenderAdapter` (Schnittstelle Domain ↔ Rendering).
- Keine Implementierung, reine Typen.

### `render/draw-route.ts`
- `drawRoute({ layer, route, centerOf, highlightIndex, start })` leert Layer, setzt den Token-Mittelpunkt als erstes Polyline-Segment (ohne zusätzlichen Dot), zeichnet anschließend die Route (falls ≥2 Punkte) und generiert pro Knoten einen sichtbaren `.tg-route-dot` sowie einen unsichtbaren `.tg-route-dot-hitbox` mit größerem Radius für angenehmere Pointer-Hits.
- Standardradien: User-Anker = 7 px, Auto-Punkte = 5 px; die Hitbox addiert +6 px. Werte werden als `data-radius` hinterlegt, damit spätere Updates den Baseline-Radius kennen.
- `updateHighlight(layer, highlightIndex)` liest den Baseline-Radius aus `data-radius`, addiert den Highlight-Offset (+2 px), setzt Stroke/Radius, toggelt `.is-highlighted` und delegiert die finale Opazität an CSS.
- Pointer-Events der Polyline deaktiviert; sichtbare Dots und Hitbox übernehmen Pointer für Interaktion.

