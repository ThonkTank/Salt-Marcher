/**
 * Faction Simulation Engine
 *
 * Background simulation for faction activities: resource production, job progress,
 * member training, expedition movement, and event generation.
 */

import type { App } from "obsidian";
import type { FactionData, FactionMember, FactionResources, FactionJob } from "../../workmodes/library/factions/types";
import type { FactionDecision, FactionActionStep } from "./ai-types";
import { logger } from "../../app/plugin-logger";

/**
 * Simulation tick - processes one day of faction activities
 */
export interface SimulationTick {
    /** Current game date (for calendar integration) */
    currentDate: string;
    /** Elapsed time in days since last tick */
    elapsedDays: number;
}

/**
 * Result of simulating one faction
 */
export interface FactionSimulationResult {
    /** Faction name */
    factionName: string;
    /** Resource changes this tick */
    resourceChanges: Partial<FactionResources>;
    /** Jobs that completed this tick */
    completedJobs: FactionJob[];
    /** New members recruited */
    newMembers: FactionMember[];
    /** Members that died/left */
    removedMembers: string[];
    /** Events generated (for timeline) */
    events: SimulationEvent[];
    /** Warnings/issues */
    warnings: string[];
}

/**
 * Event generated by simulation
 */
export interface SimulationEvent {
    /** Event title */
    title: string;
    /** Event description */
    description: string;
    /** Event type */
    type: "resource" | "conflict" | "discovery" | "completion" | "crisis";
    /** Importance (1-5, 5 = critical) */
    importance: number;
    /** Date when event occurs */
    date: string;
    /** Related faction */
    factionName: string;
}

/**
 * Simulate one tick for a faction
 */
export async function simulateFactionTick(
    faction: FactionData,
    tick: SimulationTick,
): Promise<FactionSimulationResult> {
    const result: FactionSimulationResult = {
        factionName: faction.name,
        resourceChanges: {},
        completedJobs: [],
        newMembers: [],
        removedMembers: [],
        events: [],
        warnings: [],
    };

    // Process all active jobs
    for (const member of faction.members || []) {
        if (member.job && member.status === "Active") {
            processJob(faction, member, tick, result);
        }
    }

    // Calculate resource production
    calculateResourceProduction(faction, tick, result);

    // Calculate resource consumption
    calculateResourceConsumption(faction, tick, result);

    // Check for critical resource shortages
    checkResourceShortages(faction, result);

    // Process expeditions (move units along routes)
    processExpeditions(faction, tick, result);

    return result;
}

/**
 * Process a member's job
 */
function processJob(
    faction: FactionData,
    member: FactionMember,
    tick: SimulationTick,
    result: FactionSimulationResult,
): void {
    const job = member.job!;

    // Calculate progress (10% per day for standard jobs)
    const progressPerDay = 10;
    const newProgress = (job.progress || 0) + progressPerDay * tick.elapsedDays;

    if (newProgress >= 100) {
        // Job completed!
        job.progress = 100;
        result.completedJobs.push(job);

        // Apply job effects
        switch (job.type) {
            case "crafting":
                // Produce equipment
                result.resourceChanges.equipment = (result.resourceChanges.equipment || 0) + 50;
                result.events.push({
                    title: `${member.name} completed crafting`,
                    description: `${member.name} has finished crafting equipment for ${faction.name}.`,
                    type: "completion",
                    importance: 2,
                    date: tick.currentDate,
                    factionName: faction.name,
                });
                break;

            case "gathering":
                // Gather resources
                const resourceType = (job.resources && Object.keys(job.resources)[0]) || "food";
                const amount = 100;
                (result.resourceChanges as any)[resourceType] =
                    ((result.resourceChanges as any)[resourceType] || 0) + amount;
                result.events.push({
                    title: `${member.name} gathered resources`,
                    description: `${member.name} gathered ${amount} ${resourceType}.`,
                    type: "resource",
                    importance: 2,
                    date: tick.currentDate,
                    factionName: faction.name,
                });
                break;

            case "training":
                // Train new units
                if (!member.is_named) {
                    // Increase unit quantity
                    const newUnits = Math.floor(Math.random() * 3) + 1;
                    result.events.push({
                        title: `Training completed`,
                        description: `${faction.name} trained ${newUnits} new ${member.name}.`,
                        type: "completion",
                        importance: 3,
                        date: tick.currentDate,
                        factionName: faction.name,
                    });
                }
                break;

            case "research":
                // Increase magic resources
                result.resourceChanges.magic = (result.resourceChanges.magic || 0) + 20;
                result.events.push({
                    title: `Research breakthrough`,
                    description: `${member.name} completed research for ${faction.name}.`,
                    type: "discovery",
                    importance: 3,
                    date: tick.currentDate,
                    factionName: faction.name,
                });
                break;

            case "summoning":
                // Summon new creatures (add to members)
                result.events.push({
                    title: `Summoning ritual completed`,
                    description: `${member.name} successfully summoned creatures for ${faction.name}.`,
                    type: "discovery",
                    importance: 4,
                    date: tick.currentDate,
                    factionName: faction.name,
                });
                break;

            case "guard":
            case "patrol":
                // Security jobs don't produce resources but provide stability
                break;
        }

        // Clear job after completion
        member.job = undefined;
    } else {
        // Update progress
        job.progress = Math.min(100, newProgress);
    }
}

/**
 * Calculate resource production from passive sources
 */
function calculateResourceProduction(
    faction: FactionData,
    tick: SimulationTick,
    result: FactionSimulationResult,
): void {
    // Base production per day
    const baseProduction = {
        gold: 10,
        food: 5,
        influence: 1,
    };

    // Apply production
    for (const [resource, amount] of Object.entries(baseProduction)) {
        (result.resourceChanges as any)[resource] =
            ((result.resourceChanges as any)[resource] || 0) + amount * tick.elapsedDays;
    }
}

/**
 * Calculate resource consumption
 */
function calculateResourceConsumption(
    faction: FactionData,
    tick: SimulationTick,
    result: FactionSimulationResult,
): void {
    // Count active members
    const activeMemberCount = (faction.members || []).filter((m) => m.status === "Active").length;

    // Food consumption (1 food per member per day)
    const foodConsumption = activeMemberCount * tick.elapsedDays;
    result.resourceChanges.food = (result.resourceChanges.food || 0) - foodConsumption;

    // Gold upkeep (2 gold per member per day)
    const goldUpkeep = activeMemberCount * 2 * tick.elapsedDays;
    result.resourceChanges.gold = (result.resourceChanges.gold || 0) - goldUpkeep;
}

/**
 * Check for critical resource shortages
 */
function checkResourceShortages(faction: FactionData, result: FactionSimulationResult): void {
    const resources = faction.resources || {};

    // Calculate final resource levels
    const finalResources = { ...resources };
    for (const [key, change] of Object.entries(result.resourceChanges)) {
        (finalResources as any)[key] = ((finalResources as any)[key] || 0) + change!;
    }

    // Check for critical shortages
    if ((finalResources.food || 0) < 50) {
        result.warnings.push(`${faction.name} is critically low on food`);
        result.events.push({
            title: `Food shortage`,
            description: `${faction.name} is running dangerously low on food supplies.`,
            type: "crisis",
            importance: 5,
            date: "current",
            factionName: faction.name,
        });
    }

    if ((finalResources.gold || 0) < 100) {
        result.warnings.push(`${faction.name} is critically low on gold`);
        result.events.push({
            title: `Economic crisis`,
            description: `${faction.name} is nearly bankrupt.`,
            type: "crisis",
            importance: 4,
            date: "current",
            factionName: faction.name,
        });
    }
}

/**
 * Process expeditions (move along routes, random encounters)
 */
function processExpeditions(
    faction: FactionData,
    tick: SimulationTick,
    result: FactionSimulationResult,
): void {
    for (const member of faction.members || []) {
        if (member.position?.type === "expedition" && member.status === "Active") {
            // Roll for random events during expedition (5% chance per day)
            const eventChance = 0.05 * tick.elapsedDays;
            if (Math.random() < eventChance) {
                const eventTypes = [
                    {
                        title: "Discovery",
                        description: `${member.name} discovered something interesting during their expedition.`,
                        type: "discovery" as const,
                        importance: 3,
                    },
                    {
                        title: "Encounter",
                        description: `${member.name} encountered another faction during their expedition.`,
                        type: "conflict" as const,
                        importance: 3,
                    },
                    {
                        title: "Resource find",
                        description: `${member.name} found valuable resources.`,
                        type: "resource" as const,
                        importance: 2,
                    },
                ];

                const event = eventTypes[Math.floor(Math.random() * eventTypes.length)];

                result.events.push({
                    ...event,
                    date: tick.currentDate,
                    factionName: faction.name,
                });

                // If resource find, add gold
                if (event.type === "resource") {
                    result.resourceChanges.gold = (result.resourceChanges.gold || 0) + 50;
                }
            }
        }
    }
}

/**
 * Simulate all factions for one tick
 */
export async function simulateAllFactions(
    app: App,
    factions: FactionData[],
    tick: SimulationTick,
): Promise<FactionSimulationResult[]> {
    const results: FactionSimulationResult[] = [];

    for (const faction of factions) {
        try {
            const result = await simulateFactionTick(faction, tick);
            results.push(result);

            // Log important events
            for (const event of result.events) {
                if (event.importance >= 4) {
                    logger.info("[faction-simulation] Important event", {
                        faction: faction.name,
                        event: event.title,
                        importance: event.importance,
                    });
                }
            }
        } catch (error) {
            logger.error("[faction-simulation] Error simulating faction", {
                faction: faction.name,
                error: error.message,
            });
        }
    }

    return results;
}

/**
 * Apply simulation results to faction data
 */
export function applySimulationResults(
    faction: FactionData,
    result: FactionSimulationResult,
): void {
    // Update resources
    if (!faction.resources) {
        faction.resources = {};
    }

    for (const [key, change] of Object.entries(result.resourceChanges)) {
        const currentValue = (faction.resources as any)[key] || 0;
        (faction.resources as any)[key] = Math.max(0, currentValue + change!);
    }

    // Add new members
    if (faction.members && result.newMembers.length > 0) {
        faction.members.push(...result.newMembers);
    }

    // Remove members
    if (faction.members && result.removedMembers.length > 0) {
        faction.members = faction.members.filter((m) => !result.removedMembers.includes(m.name));
    }
}
