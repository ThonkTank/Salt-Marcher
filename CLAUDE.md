# CLAUDE.md

Guidance for Claude Code when working with this repository.

**Update when**: Adding workmodes, changing build commands, refactoring architecture, modifying key patterns.

## Project Overview

Salt Marcher is an Obsidian plugin for D&D 5e campaign management with hex-based cartography, entity libraries (creatures/spells/items), and session tools. Data stored as Markdown with YAML frontmatter.

## üéØ Quick Start - Do This First

```bash
# 1. Run tests to understand current state
npm run test:all

# 2. Explore available tools
./devkit/core/cli/devkit              # Interactive REPL - discover commands

# 3. When debugging: Read CONSOLE_LOG.txt (NOT terminal output!)
tail -200 CONSOLE_LOG.txt             # Last 200 log lines
grep -i "error" CONSOLE_LOG.txt       # Find errors
```

**Essential Reading:**
- [devkit/QUICK_REFERENCE.md](devkit/QUICK_REFERENCE.md) - Command cheat sheet ‚≠ê
- [devkit/FEATURES_V3.md](devkit/FEATURES_V3.md) - Available tools & workflows
- [docs/TESTING.md](docs/TESTING.md) - Testing guide

## üîß Common Workflows

### Debugging Issues
```bash
./devkit workflow run fix-bug        # Automated debugging workflow
# OR manually:
./devkit debug enable --all          # Enable logging
./devkit reload                      # Reload plugin
# Reproduce issue, then:
tail -500 CONSOLE_LOG.txt            # Read logs
```

### Development
```bash
npm run build                        # Build plugin
./devkit reload watch                # Hot reload - auto-reload on changes ‚≠ê
./devkit ui open creature aboleth    # Open entity editor
```

### Testing
```bash
npm run test:all                     # All tests (run before committing!) ‚≠ê
./devkit test watch                  # Auto-run tests on file changes
./devkit workflow run test-entity    # End-to-end entity testing
```

### Validation
```bash
./devkit doctor                      # System health check ‚≠ê
./devkit data validate creatures     # Validate preset schemas
./devkit validate                    # UI validation
```

**Full command reference**: [devkit/docs/COMMAND_REFERENCE.md](devkit/docs/COMMAND_REFERENCE.md)

## üìÅ Architecture - Where Things Live

### Directory Structure
```
src/
‚îú‚îÄ‚îÄ workmodes/          # Self-contained applications (cartographer, library, session-runner)
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îú‚îÄ‚îÄ data-manager/   # Generic CRUD (modal/browse/fields/storage)
‚îÇ   ‚îî‚îÄ‚îÄ maps/           # Hex rendering, terrain management
‚îî‚îÄ‚îÄ app/                # Plugin bootstrap (main.ts, ipc-server.ts, plugin-logger.ts)

Presets/                # Bundled preset data
‚îú‚îÄ‚îÄ lib/                # Registry, loaders, preset-data.ts (generated)
‚îî‚îÄ‚îÄ {EntityType}/       # Preset markdown files (Creatures/, Spells/, etc.)

devkit/                 # Development tools
‚îú‚îÄ‚îÄ core/cli/           # DevKit CLI (devkit.mjs)
‚îú‚îÄ‚îÄ testing/            # Unit & integration tests
‚îî‚îÄ‚îÄ docs/               # DevKit documentation
```

### Key Concepts

**CreateSpec Pattern** - Declarative entity definitions
- **Goal**: Single source of truth for entity structure (fields, storage, UI)
- **Where**: `src/workmodes/library/{entity}/create-spec.ts`
- **Auto-generates**: Browse view, actions, handlers from spec

**Registries** - Central entity metadata
- Entity specs: `src/workmodes/library/registry.ts`
- Preset metadata: `Presets/lib/entity-registry.ts`
- Plugin presets: `Presets/lib/plugin-presets.ts`

**Build Process**
- **Goal**: Bundle presets into plugin binary
- **Flow**: `generate-preset-data.mjs` ‚Üí `Presets/lib/preset-data.ts` ‚Üí `main.js`
- **Trigger**: Runs automatically on `npm run build`

**Library Data Flow**
- **Goal**: Transform WotC reference documents into usable preset data
- **Flow**: `/References` (WotC SRD) ‚Üí Parser ‚Üí `/Presets` (machine-readable data) ‚Üí Vault (on plugin load)
- **Result**: Users have full access to modify library data in their vault

## üõ†Ô∏è Common Tasks

### Add New Entity Type
**Goal**: Extend library with new entity category (e.g., "Traps")

1. **Create spec**: `src/workmodes/library/{entity}/create-spec.ts`
2. **Create serializer**: `src/workmodes/library/{entity}/serializer.ts`
3. **Register**: Add to `src/workmodes/library/registry.ts`
4. **Add presets**: Update `Presets/lib/entity-registry.ts` and `plugin-presets.ts`
5. **Create folder**: `Presets/{EntityType}/`

**Or use**: `./devkit generate entity` (automated)

### Modify Entity Fields
**Goal**: Add/remove/change fields in entity editor

**Where**: `src/workmodes/library/{entity}/create-spec.ts` - `fields` array
**Auto-updates**: Browse view, modal, storage, validation

### Debug Field Behavior
**Goal**: Understand why a field isn't working correctly

```bash
./devkit debug field-state fieldId       # Inspect specific field
./devkit debug dump-fields creature      # Dump all fields
# Then read CONSOLE_LOG.txt for detailed logs
```

## üß™ Testing Philosophy

**Goal**: Ensure changes don't break existing functionality

**Key Principle**: ALWAYS run tests before AND after changes

```bash
# Before changes: Understand current behavior
npm run test:all

# Make changes...

# After changes: Verify correctness
npm run test:all
```

**Test Types:**
- **Unit**: Fast, isolated (`npm test`)
- **Integration**: UI, IPC, data flow (`npm run test:integration`)
- **Contract**: CreateSpec validation (`npm run test:contracts`)

**When to update golden files**: Only when changes are INTENTIONAL
```bash
npm run golden:update
```

## üêõ Debugging

**PRIMARY RESOURCE**: `CONSOLE_LOG.txt` in plugin root
- Contains ALL plugin logs (not just recent ones)
- Directly readable (no IPC required)
- Full stack traces and context
- Timestamps for timing issues

**NOT the terminal output** - DevKit CLI shows limited subset

```bash
# Good: Read CONSOLE_LOG.txt
tail -200 CONSOLE_LOG.txt
grep "\[init:" CONSOLE_LOG.txt

# Less useful: Terminal output (limited)
./devkit logs 200
```

**Enable detailed logging**:
```bash
./devkit debug enable --all          # Enable all categories
./devkit debug enable --field fieldId # Enable specific field
```

## üìö Documentation Map

**For Quick Tasks** (what to do):
- [devkit/QUICK_REFERENCE.md](devkit/QUICK_REFERENCE.md) - Command cheat sheet

**For Understanding Systems** (how things work):
- [docs/storage-formats.md](docs/storage-formats.md) - Entity storage & CreateSpec
- [docs/PRESETS.md](docs/PRESETS.md) - Preset bundling/import system
- [docs/TESTING.md](docs/TESTING.md) - Testing guide

**For DevKit Features** (available tools):
- [devkit/FEATURES_V3.md](devkit/FEATURES_V3.md) - v3.0 capabilities overview
- [devkit/docs/COMMAND_REFERENCE.md](devkit/docs/COMMAND_REFERENCE.md) - Complete API
- [devkit/docs/GETTING_STARTED.md](devkit/docs/GETTING_STARTED.md) - First-time setup

**For Troubleshooting**:
- [devkit/docs/TROUBLESHOOTING.md](devkit/docs/TROUBLESHOOTING.md) - Common problems
- CONSOLE_LOG.txt - Live debugging logs

## üéØ Development Principles

**Before changing code:**
1. Understand the system fully (read relevant code & docs)
2. Run tests to establish baseline behavior
3. Consider `./devkit backup create` for risky changes

**While working:**
- DRY: Don't Repeat Yourself - adapt existing code instead of duplicating
- Simple > Clever: Easier maintenance saves debugging time
- Use `./devkit test watch` for instant feedback
- Read CONSOLE_LOG.txt when debugging

**Before committing:**
- Run `npm run test:all` to verify all tests pass
- Validate UI if fields changed: `./devkit validate`
- Update docs if architecture changed
- Consider `./devkit hooks install` for automatic validation

**Documentation guidelines:**
- Focus on GOAL and LOCATION, not implementation details
- Keep file headers descriptive (purpose, not just filename)
- Update relevant docs with every change

## üîë Key Technical Patterns

- **Context Objects**: Dependency injection via function parameters
- **Repository Pattern**: Data access through repository functions
- **Lifecycle Handles**: Services return cleanup functions
- **Type-Safe Frontmatter**: `smType` field identifies entity types

## ‚ö†Ô∏è Important Constraints

**Technical:**
- Use Obsidian Vault API (not Node.js `fs`)
- Use `plugin-logger.ts` (logs to CONSOLE_LOG.txt, not console)
- German UI strings (historical) - managed via `translator.ts`
- Forward slashes `/` for paths (Obsidian normalizes automatically)
- Never bypass IPC for Obsidian interactions (use DevKit commands)
- CONSOLE_LOG.txt is the primary debugging resource (not terminal output)

**Code Quality:**
- DRY: Don't Repeat Yourself - halte dich immer daran
- Je simpler der Code, desto einfacher die Wartung
- Arbeite immer mit sauberen, langfristigen L√∂sungen statt schnellen hacks
- Wann immer m√∂glich, adaptiere/generalisiere vorhandenen Code statt neuen zu schreiben
- Bevor du ein System √§nderst, stelle erst sicher dass du es vollst√§ndig verstehst
- **Development Philosophy**: Wir sind mitten im Development. Es gibt keine bestehenden User und nichts ist in Stein gemei√üelt. Wir brauchen keine backwards compatibility, weil alles einfach direkt kompatibel gemacht werden kann. Statt conversions oder workarounds zu basteln kannst du einfach die grundstruktur anpassen.

**Documentation & Testing:**
- Nutze DevKit tools um √Ñnderungen zu testen
- Halte relevante Dokumentation immer aktuell, bei allen √Ñnderungen
- Stelle sicher, dass jedes Skript eine deskriptive √úberschrift und kurze Zusammenfassung im Dateikopf hat
- Bei komplexeren Skripten, f√ºge Zwischen√ºberschriften ein
- Dokumentation soll ZIEL und ORT zeigen, nicht nur beschreiben was passiert

**Problem Solving:**
- Wenn dir Probleme auffallen (fehlende Dokumentation, nicht funktionierende Befehle, bugs, smelly code etc.):
  - Behebe es sofort, wenn das Problem klein ist
  - Oder erstelle dir eine ToDo f√ºr sp√§ter (nicht im Projekt, in der Konsole)
- Suche stets nach M√∂glichkeiten das Plugin in Architektur, Code und Wartbarkeit zu verbessern
- Versuche stets deine dev tools zu verbessern

Ziele:
- Salt Marcher soll Spielleitungen eine zentrale Oberfl√§che geben, in der Weltreise, Begegnungen und Stimmung nahtlos ineinander greifen und jede Aktion sofort sp√ºrbares Feedback liefert.
- **Cartographer**
  Wenn ich den Cartographer √∂ffne, sehe ich eine farbcodierte Hexkarte: jede Kachel repr√§sentiert Terrain und Region, und ihre Informationen liegen in eigenen Markdown-Dateien, bleiben aber bei Interaktionen im Editor. √úber den Modus-Schalter w√§hle ich zwischen Pinsel und Inspector: Der Pinsel erlaubt mir, per Brush mehrere Hexes zu bearbeiten, w√§hrend der Inspector in der Seitenleiste die Tile-Daten anzeigt, ohne Dateien aufzurufen.  
  Im Pinselmodus w√§hle ich im Dropdown eine Region aus der Library, passe Radius und Brush-Einstellungen an und sehe beim Streichen sofortige Farbupdates; ein ‚ÄûManage‚Ä¶‚Äú-Button f√ºhrt direkt zur Regionsverwaltung. Der Inspector zeigt mir bei einem Klick auf ein Hex die aktuell hinterlegte Region, Terrain-Details und Notizen in einem Panel, sodass ich alles im Blick habe, ohne den Editor zu verlassen.  
  Als Erweiterungen plane ich Ortsmarker (St√§dte, Landmarken), sichtbare Fraktions-Einflussgebiete mit einstellbaren Begegnungschancen, und Overlays f√ºr Fl√ºsse, Klippen, H√∂henlinien sowie eine h√∂henbasierte Fog-of-War-Vorschau. Zus√§tzlich soll sich das Wetter pro Region anpassen lassen, damit unterschiedliche Zonen verschiedene Arten von Wetter haben, welches die Reisen im Session runner beeinflusst.
- **Library**  
  Die Library √∂ffnet als zentrales Archiv mit Tabs f√ºr Kreaturen, Zauber, Items, Equipment, Terrains, Regionen und Kalender. Titelzeile, Sucheingabe und die einheitlichen Karten geben mir sofort einen √úberblick, w√§hrend ich per Tabs zwischen den Entit√§ten wechsle und in jedem Modus denselben Workflow vorfinde.  
  √úber der Liste sitzen Filter- und Sortierleisten: ich kombiniere Attribute wie CR, Schule, Terrainfarbe oder Encounter-Odds, wechsle Sortierungen (Name, Seltenheit, Level etc.) und lasse mir so exakt die Datens√§tze anzeigen, die ich gerade brauche. Jede Karte bietet klar platzierte Aktionen f√ºr `Open`, `Edit` und `Delete`, und beim Bearbeiten f√ºhren gef√ºhrte Formulare alle Felder durch und speichern direkt in strukturierte Markdown-Dateien.  
  Funktional gilt die Library als vollst√§ndig; k√ºnftige Arbeiten konzentrieren sich auf zus√§tzliche Tabs, verfeinerte Speicherformate, weiter ausgebaute Formulare sowie eine Zusatzoption ‚ÄûSpeichern als‚Äú, die neben dem bestehenden Speichern-Button zur Verf√ºgung stehen soll.
- **Session Runner**  
  Heute bietet der Session Runner einen Reise-Workflow: ich lade eine Cartographer-Karte, setze Wegpunkte, lasse Bewegungstempo und Routenverlauf berechnen und sehe in der Seitenleiste Fortschritt, Uhrzeit, Reiseereignisse und das aktuell simulierte Wetter, das automatisch aus den Hex-Daten aktualisiert wird. Direkt daneben h√§lt eine kompakte Kalender√ºbersicht Datum, Tageszeit, aktuelle Wetterlage, astronomische Ereignisse und die n√§chsten anstehenden Events bereit, damit ich keine Vorbereitungsl√ºcke √ºbersehe. Die Oberfl√§che bleibt bewusst reduziert, damit ich w√§hrend der Sitzung schnell zwischen Karte, Route und Notizen wechseln kann.  
  Als n√§chstes soll der Session Runner direkt auf Cartographer-Daten zugreifen und Random Encounters aus Fraktionen, Einflussgebieten, Terrain, Wetter und markierten Orten generieren. Die Ergebnisse landen in einem Seitenfenster, das Monster-Statblocks, Initiative-Reihenfolge, Loot-Vorschl√§ge, NPC-Profile und relevante Terrain-Features f√ºr die Battlemap b√ºndelt, damit ich den Encounter ohne Umwege leiten kann.  
  Der Encounter-View √ºbernimmt dabei mehr als nur importierte Zufallsbegegnungen: Ich kann Begegnungen ad hoc komponieren, indem ich aus Fraktionslisten, den auf dem aktuellen Hex pr√§senten NPCs (benannt wie unbenannt) sowie allen √ºbrigen Statbl√∂cken der Library ausw√§hle. W√§hrend ich Gegner oder Verb√ºndete hinzuf√ºge, zeigt mir der Calculator live, wie fordernd das Setup im Vergleich zum Gruppenlevel ist, und ein Klick startet die Begegnung sofort im Arbeitsbereich.  
  Erg√§nzend plane ich einen Playlist-Manager mit minimaler Steuerfl√§che: Ambience und Musik stammen aus kuratierten Playlists, die automatisch nach Terrain, Wetter, Tageszeit, Ort, Fraktion und Situation gew√§hlt werden, w√§hrend ich jederzeit per Schnellzugriff pausieren, Skippen oder auf alternative Stimmungen wechseln kann.
- **Kalender**  
  Der Kalender h√§lt Datum und Uhrzeit kampagnenweit synchron, verwaltet einmalige wie wiederkehrende Ereignisse und sorgt daf√ºr, dass vorbereitete Trigger ‚Äì von Festen √ºber Fraktionsziele bis zu saisonalen Effekten ‚Äì automatisch zur richtigen Zeit ausrollen. Im Almanac steuere ich alles zentral, entscheide welche √Ñnderungen Karte, Library oder Session Runner erreichen und habe gleichzeitig im Session Runner eine kompakte √úbersicht, die den aktuellen Status nur anzeigt (Details siehe Session Runner).  
  Der Almanac bringt daf√ºr spezialisierte Ansichten mit: Monats-, Wochen- und Timeline-Modus bieten unterschiedliche Blickwinkel auf dieselben Ereignisse, w√§hrend Editoren f√ºr Fraktionsziele, wiederkehrende Rituale, Mondphasen sowie andere astronomische oder saisonale Zyklen inklusive Vorlagen und Automatisierung bereitstehen. Ein Postfach sammelt neue, noch ungelesene Ereignisse nach Wichtigkeit sortiert, sodass ich nichts √ºbersehe. Wenn der Kalender fortschreitet, aktualisiert er Wetter und Status auf dem aktiven Hex, st√∂√üt hinterlegte Notizen oder Encounter-Hooks an und h√§lt so alle Workmodes im Gleichschritt.
- **Fraktionen**
  Fraktionen reichen von kleinen Wolfsrudeln √ºber verschworene Kulte bis hin zu K√∂nigreichen ‚Äì jede Fraktion besitzt Mitglieder (Statblocks aus der Library), deren verf√ºgbare Anzahl im Hintergrund bilanziert wird, sodass irgendwann der letzte Goblinkrieger gefallen ist. Ziele, Werte und Kultur steuern ihre Entscheidungen: Eine einfache KI setzt Pl√§ne um, passt Strategien an und erschafft neue Plot-Hooks, ohne dass der GM dauernd eingreifen muss. Auf der Karte errichten Fraktionen Camps oder andere POIs, die Einflusszonen ausbreiten. Der gesamte Mitgliederbestand ‚Äì ob namenlose Trupps, benannte NPCs oder Unterfraktionen ‚Äì wird positionsgenau verfolgt, sodass jederzeit klar ist, wie viele Einheiten ein Lager h√§lt, welche Expedition unterwegs ist und wer als Verst√§rkung bereitsteht. Innerhalb dieser Orte besetzen Mitglieder Jobs: Sie schmieden Ausr√ºstung, sammeln Ressourcen, trainieren Milizen oder beschw√∂ren Verst√§rkung ‚Äì sofern passende Geb√§ude aufgebaut und gewartet werden. Beziehungen zwischen Fraktionen entscheiden, ob Konflikte eskalieren oder Handelspreise purzeln (Angebot vs. Nachfrage), und Expeditionen ziehen √ºber die Karte, wo die Gruppe ihnen begegnen, sie aushorchen oder ausrauben kann. All diese Simulationen laufen kontinuierlich im Hintergrund, damit die Welt lebendig bleibt: Gebiete wechseln die Hand, Lager entstehen, Geschichten reifen. Der GM erh√§lt kompakte Zusammenfassungen in Karte, Session Runner und Kalender; wichtige Ereignisse wandern ausschlie√ülich in den Kalender, damit Vorbereitung und Dramaturgie Schritt halten.
  - **Unterfraktionen**  
    Unterfraktionen verhalten sich wie eigenst√§ndige Fraktionen, sind aber organisatorisch einer Oberfraktion zugeordnet. Sie erben Ressourcen, Kultur und Einfluss, setzen zus√§tzliche Ziele und k√∂nnen sich stilistisch klar unterscheiden ‚Äì etwa ein fanatischer Inquisitionszweig innerhalb eines K√∂nigreichs. Ihr Mitgliederbestand wird ebenfalls positionsgenau verfolgt, einschlie√ülich der Frage, wie viele Einheiten in welchem Lager stationiert sind oder welche Expeditionen unterwegs sind; eigene Lager, Geb√§ude und Missionen sind m√∂glich, sofern Mittel bereitstehen.
  - **NPCs**  
    Benannte Fraktionsmitglieder werden getrennt von anonymen Trupps verwaltet. Namen, Beschreibungen und Merkmale entstehen aus Listen f√ºr Spezies, Kultur und Fraktionspr√§gung, wodurch jeder NPC sofort Profil bekommt. Sie k√∂nnen Jobs √ºbernehmen oder Expeditionen leiten, wobei Rollenerwartungen respektiert werden ‚Äì ein K√∂nig delegiert Logistik, statt im Dorf Mist zu schaufeln. Ihr Aufenthaltsort wird genauso protokolliert wie der der √ºbrigen Mitglieder, damit klar bleibt, wer gerade vor Ort, auf Mission oder als Verst√§rkung verf√ºgbar ist.
- **Orte**
  Orte sind einfache Beschreibungen, die sich zu einer Hierarchie verlinken lassen ‚Äì Stadt ‚Üí Viertel ‚Üí Geb√§ude ‚Üí Raum ‚Äì und mir schnellen Zugriff auf jede Ebene geben. Jeder Ort kann einer Fraktion, Unterfraktion oder einem einzelnen NPC geh√∂ren; der Eintrag zeigt direkt, wer verantwortlich ist und welche Beziehungen oder Ressourcen daran gekn√ºpft sind.
  Basierend auf Besitzer und Art unterhalten Orte Einflussbereiche auf der Karte, sodass sichtbar bleibt, wer ein Gebiet dominiert und welche Stimmung dort herrscht.
  Geb√§ude sind eine besondere Form von (Sub-)Ort: NPCs arbeiten dort, investieren Zeit und Ressourcen und stellen Gegenst√§nde her oder warten Ausr√ºstung. Die √úbersicht h√§lt fest, welche Produktionsketten laufen und welche Kosten daf√ºr anfallen.
  - **Dungeons**  
    Dungeons sind besondere Orte (oder Geb√§ude), die eine quadratische Kartenansicht mit klaren Rasterzellen nutzen. Alle wichtigen Elemente ‚Äì Spieler- und NPC-Positionen, T√ºren, Fallen, Sch√§tze, M√∂bel, Gel√§ndestufen ‚Äì werden direkt als Tokens oder Marker auf der Karte eingezeichnet, sodass ich jederzeit eine visuelle Repr√§sentation der Situation habe. Bei Bedarf blendet ein optionales Overlay Fog of War und Ger√§uschradien ein, um Sicht- und H√∂rgrenzen abzubilden.
    Jeder Dungeon ist in R√§ume unterteilt. Ein Klick auf einen Raum √∂ffnet im Seitenfenster eine strukturierte Beschreibung mit Sinneseindr√ºcken (was man sieht, riecht, h√∂rt), einer T√ºrliste sowie s√§mtlichen Features. Ausg√§nge tragen IDs wie `T1`, `T2`, `T3`, Features erhalten Markierungen `F1`, `F2`, `F3`, erg√§nzt um Typ-K√ºrzel (`G` f√ºr Geheimnisse, `H` f√ºr Hindernisse, `S` f√ºr Sch√§tze). Tippe ich auf ein solches Label ‚Äì sei es auf der Karte oder in der Liste ‚Äì springt die Ansicht zur passenden Passage in der Raumbeschreibung.
    So arbeite ich mit einer nahtlosen Mischung aus visueller Karte und narrativem Detail: Ich sehe sofort, welche T√ºren offenstehen, welche Fallen scharf sind und wo sich Figuren gerade bewegen, w√§hrend die Panel-Texte mir die volle atmosph√§rische Beschreibung liefern.
- **Calculator**  
   Der Calculator bildet das Regel-Backend f√ºr Begegnungen und Belohnungen. Encounter-Presets als Markdown-Dateien (`SaltMarcher/EncounterPresets`) legen Basissummen und Hausregeln fest ‚Äì jede Regel hat einen Scope (`xp` oder `gold`), einen Modifikatortyp (flat, Prozent vom Gesamtwert, Prozent bis zur n√§chsten Stufe, pro Durchschnittslevel usw.), Min-/Max-Grenzen sowie optionale Notizen.
   Im Encounter-View arbeite ich direkt mit diesen Regeln: Basissumme setzen, Presets laden, Eintr√§ge per Drag & Drop ordnen, tempor√§r deaktivieren oder feinjustieren und sofort sehen, wie sich der Breakdown auf einzelne Charaktere auswirkt. Der Store √ºberwacht Level, XP-Stand und Resultat je Party-Mitglied und gleicht Werte gegen die D&D-Schwellen ab, damit Fehler auffallen.
   So kann ich handgebaute Begegnungen zuverl√§ssig balancieren ‚Äì und dieselben Regeln sorgen daf√ºr, dass Random Encounters im Session Runner automatisch nach meinen Vorgaben die passenden Belohnungen ausrechnen.
- **Audio & Atmosph√§re**
  Ein integrierter Audio-Player stellt kuratierte Playlists bereit, die sich nach Terrain, Wetter, Fraktionen und Encounter-Typ filtern lassen, damit die Stimmung ohne langes Suchen passt.  
  W√§hrend der Sitzung kann ich Stimmungen live wechseln: sanfte Fades, klare Statusanzeigen und gespeicherte Favoriten erleichtern spontane √úberg√§nge.
- **Loot**  
  Loot orientiert sich an den XP der Begegnung: Gold, Handelswaren und magische Items werden √ºber die Calculator-Regeln generiert, die Party-Level, Encounter-XP und selbst definierte Modifikatoren ber√ºcksichtigen. Der Generator zieht daf√ºr aufbereitete Listen aus der Library heran, filtert nach Tags (z.‚ÄØB. ‚ÄûSumpf‚Äú, ‚ÄûUntote‚Äú, ‚ÄûOzean‚Äú) und sorgt daf√ºr, dass Beute zur Location und den Gegnern passt.  
  Magische Items folgen Level-Limits, damit nicht jede Begegnung legend√§re Artefakte ausspuckt, w√§hrend Gold und wertvolle Waren linear mit XP und Charakterstufe skalieren. Viele Gegner bringen au√üerdem inh√§rente Beute mit: Drachen liefern Schuppen, Drow exotische Gifte, Konstrukte seltene Komponenten. Diese Werte stehen direkt im Statblock ‚Äì inklusive des Anteils, den sie vom sonstigen Loot-Pool ersetzen ‚Äì sodass ich sofort wei√ü, wie viel zus√§tzliche Beute noch verteilt wird.
- **Erlebnis-Zusammenspiel**
  Alle Bereiche greifen so ineinander, dass ich ohne Kontextwechsel von Reiseplanung zu Begegnung zu Nachbereitung wechseln kann und jederzeit den roten Faden der Kampagne sehe.
  Dashboards und Workmodes sollen die wichtigsten Aktionen prominent machen, w√§hrend weiterf√ºhrende Optionen nur einen Klick entfernt bleiben.
  Die Oberfl√§che unterst√ºtzt Improvisation durch schnelle Vorschl√§ge, merkt sich Pr√§ferenzen und liefert mir beim √ñffnen direkt die relevantesten Hinweise f√ºr die aktuelle Spielsituation.

## Architektur-Roadmap

### Roadmap Overview

| Phase | Status | Zielbild |
|-------|--------|----------|
| Phase 0-1 | ‚úÖ Abgeschlossen | Tags, Schemas, Store-Platform |
| Phase 2.1-2.7 | ‚úÖ Abgeschlossen | Travel ‚Üí Encounter ‚Üí Combat E2E |
| Phase 2.3.1 | ‚úÖ Abgeschlossen | Faction Members Display |
| Phase 2.6 | ‚úÖ Abgeschlossen | Random Encounter Generator |
| Phase 3.1 | ‚úÖ Abgeschlossen | Location CRUD (Library) |
| Phase 3.2-3.2.1 | ‚úÖ Abgeschlossen | Tree View (Hierarchy) |
| Phase 3.3-3.3.1 | ‚úÖ Abgeschlossen | Map POI Markers + Editor |
| Phase 3.4.1 | ‚úÖ Abgeschlossen | Dungeon Data Model |
| Phase 3.4.2 | ‚úÖ Abgeschlossen | Grid Renderer (Canvas) |
| **Phase 3.4.3** | ‚è≥ **N√ÑCHSTER SCHRITT** | **Zoom/Pan/Click** |
| Phase 3.4.4-5 | ‚è≥ Later | Token Management, FOW |
| Phase 4-6 | ‚è≥ Geplant | Events, Loot, Audio |

**Aktueller Fokus:** Phase 3.4.3 (Interactive Features) ‚Üê **N√ÑCHSTER SCHRITT**

**Test-Suite:** 267/269 gr√ºn (99.3% pass rate) ‚úÖ

### Phase 0-1 ‚Äì Foundation ‚úÖ
- **Phase 0:** Tag-Taxonomie (`docs/TAGS.md`), Schema-Validatoren (`src/domain/schemas.ts`)
- **Phase 1:** Store-Platform (Readable/Writable/Persistent), Event-Bus, 49‚Üí0 Test-Failures
  - Map/Almanac auf PersistentStores migriert
  - Encounter nutzt Event-driven Pattern

### Phase 2 ‚Äì Encounter System ‚úÖ
- **2.1-2.4:** Territory Marking, Faction Context, Creature Composition, XP Calculator
- **2.6:** Random Encounter Generator (Tag-Fallback, D&D 5e XP Budget, 22 Tests)
- **2.7:** Combat Tracking (HP/Initiative, Health-Bars, Defeated-State)
- **2.3.1:** Faction Members Display im Encounter Composer
- **Ergebnis:** Travel ‚Üí Encounter ‚Üí Combat E2E spielbar

---

---

### Phase 2.3 ‚Äì Member Management ‚è≥ N√ÑCHSTER SCHRITT
**User Story:** "Zeige Faction-Members im Encounter Composer basierend auf Hex-Faction"

#### Zielbild (Langfristig)
Umfassendes Fraktions-Management-System:
- Mitglieder-Tracking (Population, benannt/unbenannt, Positionen)
- Unterfraktionen-Hierarchie (Erben von Oberfraktion, eigene Ziele)
- NPC-Generierung (Namen, Traits aus Kultur/Spezies/Fraktion)
- Jobs-System (NPCs besetzen Positionen in Orten/Geb√§uden)
- Expeditionen (Einheiten ziehen √ºber Karte, Gruppe begegnet ihnen)
- Beziehungen (Inter-Fraktions-Relationen, Handel, Konflikte)

#### Phase 2.3.1 - Faction Members Display ‚úÖ ABGESCHLOSSEN
**Scope:** Minimaler Slice f√ºr sofortigen Nutzen

**User Story:**
> "Als GM will ich im Encounter Composer sehen, welche Creatures zur aktuellen Hex-Faction geh√∂ren, damit ich diese schnell zu Encounters hinzuf√ºgen kann."

**Acceptance Criteria (Alle ‚úÖ):**
1. ‚úÖ Faction-Data enth√§lt `members` Array (bereits im Schema als FactionMember[])
2. ‚úÖ Encounter-View l√§dt Members der aktuellen Hex-Faction
3. ‚úÖ Separate Sektion "Faction Members (X)" in creature-list.ts
4. ‚úÖ Members zeigen Badge "Faction Member" zur Unterscheidung
5. ‚úÖ Click auf Member f√ºgt ihn wie normale Creatures hinzu
6. ‚úÖ Falls keine Faction auf Hex: Sektion versteckt

**Implementation Summary:**
- ‚úÖ **Schema**: FactionMember[] bereits vorhanden mit name, role, status, is_named, notes
- ‚úÖ **Presenter**: `loadFactionMembers()` l√§dt Faction ‚Üí extrahiert members ‚Üí resolved zu CreatureListItems
- ‚úÖ **UI**: Neue Sektion in creature-list mit Badge, conditional rendering, click-to-add
- ‚úÖ **Integration**: workspace-view.render() l√§dt members automatisch basierend auf session.event.factionName
- ‚úÖ **Tests**: 222/224 Tests passing, Build successful (2.7mb)

**Out of Scope (sp√§tere Slices):**
- ‚ùå Population tracking (Anzahl verf√ºgbar)
- ‚ùå Named NPCs vs anonymous troops
- ‚ùå Position tracking (in camps, on expeditions)
- ‚ùå Subfactions hierarchy
- ‚ùå Jobs system
- ‚ùå Relations & diplomacy

---

#### Phase 2.3.2 - Population Tracking ‚è≥ OPTIONAL
**Scope:** Track verf√ºgbare Anzahl pro Member, zeige "(X available)" Badge

**Status:** Zur√ºckgestellt zugunsten Phase 3 (Orte sind Grundlage f√ºr Jobs/Camps)

---

### Phase 3 ‚Äì Orte & Dungeons ‚è≥ N√ÑCHSTER SCHRITT
**User Story:** "Als GM will ich Orte mit Hierarchie und Ownership verwalten, damit ich Camps, St√§dte und Dungeons strukturiert organisieren kann."

#### Zielbild (Langfristig)
Umfassendes Orts-Management-System:
- Hierarchische Struktur (Stadt ‚Üí Viertel ‚Üí Geb√§ude ‚Üí Raum)
- Ownership (Faction, Subfaction, NPC)
- Map Integration (Marker, Einflussbereiche)
- Geb√§ude-Funktionen (Jobs, Produktionsketten)
- Dungeons (Grid-Maps, Raum-Features mit IDs)

#### Phase 3.1 - Location Entities (CRUD) ‚úÖ ABGESCHLOSSEN
**Scope:** Minimale Location-Verwaltung in Library

**User Story:**
> "Als GM will ich Orte in der Library erstellen und bearbeiten, damit ich sie sp√§ter mit Fraktionen und NPCs verkn√ºpfen kann."

**Acceptance Criteria (Alle ‚úÖ):**
1. ‚úÖ Location Schema definiert (name, type, description, parent, owner)
2. ‚úÖ CreateSpec f√ºr Locations (Library Integration)
3. ‚úÖ Storage: `SaltMarcher/Locations/{name}.md`
4. ‚úÖ Browse View zeigt Orte mit Type/Owner
5. ‚úÖ Create/Edit/Delete Workflow funktioniert

**Implementation Summary:**

**Neue Dateien:**
- ‚úÖ `src/workmodes/library/locations/types.ts` - LocationData, LocationType, OwnerType
- ‚úÖ `src/workmodes/library/locations/constants.ts` - LOCATION_TYPES, OWNER_TYPE_LABELS
- ‚úÖ `src/workmodes/library/locations/serializer.ts` - locationToMarkdown()
- ‚úÖ `src/workmodes/library/locations/create-spec.ts` - Full CreateSpec
- ‚úÖ `src/workmodes/library/locations/index.ts` - Public exports

**Modifizierte Dateien:**
- ‚úÖ `src/workmodes/library/storage/data-sources.ts` - LocationEntryMeta, loadLocationEntry
- ‚úÖ `src/workmodes/library/registry.ts` - locationSpec registration

**Features:**
- ‚úÖ Location Types: Stadt, Dorf, Weiler, Geb√§ude, Dungeon, Camp, Landmark, Ruine, Festung
- ‚úÖ Owner Types: faction, npc, none (mit deutschen Labels)
- ‚úÖ Optional Fields: parent (Hierarchie), region, coordinates (Hex), notes
- ‚úÖ Browse Metadata: Type, Owner (mit Label), Parent Location
- ‚úÖ Filters: type, owner_type, owner_name, region, parent
- ‚úÖ Sorts: name, type, owner

**Test Results:**
- ‚úÖ Build: Successful (2.8mb)
- ‚úÖ Tests: 222/224 passing (99%)
- ‚úÖ No type errors

**Commits:**
- `21ad76b` feat(library): Add Location entities to library (Phase 3.1)

**Out of Scope (sp√§tere Slices):**
- ‚ùå Hierarchie-Visualisierung (Tree View) ‚Üí Phase 3.2
- ‚ùå Map Integration (Markers) ‚Üí Phase 3.3
- ‚ùå Einflussbereiche (Area of Influence) ‚Üí Phase 3.3
- ‚ùå Geb√§ude-Jobs System ‚Üí Phase 2.3.3+
- ‚ùå Dungeon Grid-Maps ‚Üí Phase 3.4

**Tats√§chlicher Aufwand:** ~1 Stunde ‚úÖ

---

#### Phase 3.2 - Location Hierarchy (Core Infrastructure) ‚úÖ ABGESCHLOSSEN
**Scope:** Hierarchie-Visualisierung und Navigation

**User Story:**
> "Als GM will ich die hierarchische Struktur von Orten (Stadt ‚Üí Viertel ‚Üí Geb√§ude ‚Üí Raum) visualisieren und navigieren, damit ich Ortsbeziehungen auf einen Blick verstehe."

**Acceptance Criteria (Core Infrastructure):**
1. ‚úÖ Tree View Component f√ºr Location-Hierarchie
2. ‚úÖ Automatic Parent-Child Resolution (basierend auf `parent` field)
3. ‚úÖ Expandable/Collapsible Nodes
4. ‚úÖ Click Callback API (ready for integration)
5. ‚úÖ Visual Indicators f√ºr Location Type (Icons: üèôÔ∏è üèòÔ∏è üè¢ ‚öîÔ∏è ‚õ∫ etc.)
6. ‚úÖ Breadcrumb Navigation Component

**Implementation Status:**

**‚úÖ Completed Steps (Core Functionality):**

**Schritt 1: Tree Data Structure** ‚úÖ (tree-builder.ts, 140 lines)
- ‚úÖ `buildLocationTree()` - Hierarchical tree construction
- ‚úÖ `flattenTree()` - Depth-first traversal
- ‚úÖ `findNodeByName()` - Tree search
- ‚úÖ `buildBreadcrumbs()` - Parent path generation
- ‚úÖ **Cycle Detection**: Detects A‚ÜíB‚ÜíC‚ÜíA patterns
- ‚úÖ **Orphan Handling**: Missing parents treated as roots

**Schritt 2: Tree View Component** ‚úÖ (tree-view.ts, 150 lines)
- ‚úÖ `LocationTreeView` class with expand/collapse
- ‚úÖ Recursive rendering
- ‚úÖ Icons: üèôÔ∏è Stadt, üèòÔ∏è Dorf, üè¢ Geb√§ude, ‚öîÔ∏è Dungeon, ‚õ∫ Camp, üóø Landmark, üèöÔ∏è Ruine, üè∞ Festung
- ‚úÖ Owner badges
- ‚úÖ Click callbacks
- ‚úÖ Depth-based indentation

**Schritt 4: Breadcrumb Component** ‚úÖ (breadcrumb.ts, 80 lines)
- ‚úÖ `LocationBreadcrumb` class
- ‚úÖ Path rendering (Root ‚Üí Parent ‚Üí Current)
- ‚úÖ Clickable parent links
- ‚úÖ Customizable separators

**Schritt 5: Tests & Validation** ‚úÖ (locations-tree.test.ts, 17 tests)
- ‚úÖ All hierarchy scenarios (1-level, multi-level, orphans, cycles)
- ‚úÖ Tree operations (flatten, search, breadcrumbs)
- ‚úÖ **Test Results**: 17/17 passing (100%)
- ‚úÖ **Overall Suite**: 239/241 passing (99%)

**Status:**
- ‚úÖ Core tree infrastructure (100%)
- ‚úÖ All components tested (17/17 tests)
- ‚úÖ Cycle detection & orphan handling
- ‚úÖ Ready for UI integration (‚Üí Phase 3.2.1)

**Out of Scope:**
- ‚ùå Drag & Drop re-parenting ‚Üí sp√§ter
- ‚ùå Map visualization ‚Üí Phase 3.3
- ‚ùå Bulk operations (move subtree) ‚Üí sp√§ter

**Commits:**
- `7a3b611` feat(locations): Add Phase 3.2 core - Tree view & breadcrumb components

**Actual Time:** ~1.5 hours (core infrastructure)

---

#### Phase 3.2.1 - Tree UI Integration ‚úÖ ABGESCHLOSSEN
**Scope:** Integration der Tree View Components in die Library UI

**User Story:**
> "Als GM will ich in der Library zwischen List- und Tree-View f√ºr Locations wechseln k√∂nnen, damit ich entweder alle Locations flach oder hierarchisch sehen kann."

**Acceptance Criteria:**
1. ‚úÖ Toggle Button "List/Tree" in Location Browse View
2. ‚úÖ View Switching zwischen GenericListRenderer und Tree View
3. ‚úÖ Click Handler ‚Üí Opens location in browse view
4. ‚è≥ Breadcrumb in Location Edit/Create Modal (deferred to Phase 3.2.2)
5. ‚è≥ Persist view preference in Plugin Settings (deferred to Phase 3.2.2)

**Implementation Summary:**

**LocationListRenderer** (location-list-renderer.ts, 170 lines):
- ‚úÖ Extends `GenericListRenderer<"locations">`
- ‚úÖ View mode state: `"list" | "tree"`
- ‚úÖ Toggle UI: üìã List / üå≥ Tree buttons
- ‚úÖ Conditional rendering:
  - List mode ‚Üí parent's GenericListRenderer
  - Tree mode ‚Üí LocationTreeView with buildLocationTree()
- ‚úÖ Click handler ‚Üí opens location via "Open" action

**Library View Integration:**
- ‚úÖ Added "locations" to LIBRARY_COPY.modes
- ‚úÖ Added "locations" to LIBRARY_MODES array
- ‚úÖ Override `createRenderer()` to inject LocationListRenderer for locations mode
- ‚úÖ All other modes use default GenericListRenderer

**Test Updates:**
- ‚úÖ Updated library/view.test.ts to expect 9 modes (added locations)
- ‚úÖ All 239/241 tests passing

**User Experience:**
1. Library ‚Üí Locations Tab
2. Default: List view (flat, sortable, filterable)
3. Click "üå≥ Tree": Hierarchical view
   - Stadt ‚Üí Dorf ‚Üí Geb√§ude with indentation
   - Expand/collapse nodes
   - Location type icons (üèôÔ∏è üèòÔ∏è üè¢ ‚öîÔ∏è ‚õ∫ üóø üèöÔ∏è üè∞)
   - Owner badges
4. Click location name ‚Üí Opens in browse view
5. Click "üìã List" ‚Üí Back to flat list

**Files:**
- `src/workmodes/library/locations/location-list-renderer.ts` (NEW, 170 lines)
- `src/workmodes/library/view.ts` (modified - renderer override)
- `devkit/testing/unit/library/view.test.ts` (modified - test updates)

**Commits:**
- `7663741` feat(locations): Complete Phase 3.2.1 - Tree view in Library UI

**Actual Time:** ~2 hours (UI integration)

---

#### Phase 3.3 - Map POI Markers ‚è≥ IN ARBEIT
**Scope:** Locations auf der Hex-Karte platzieren und visualisieren

**User Story:**
> "Als GM will ich Locations auf der Cartographer-Karte platzieren, damit ich sehen kann wo St√§dte, Dungeons und andere Orte liegen, und diese Informationen im Inspector abrufen kann."

**Acceptance Criteria:**
1. ‚è≥ Location-Marker Store (welche Location auf welchem Hex)
2. ‚è≥ Marker Rendering auf Karte (Icons/SVG-Marker √ºber Hexes)
3. ‚è≥ Inspector Integration (zeige Location-Info bei Hex-Click)
4. ‚è≥ Editor Mode Integration (Location zu Hex hinzuf√ºgen/entfernen)
5. ‚è≥ Unit Tests f√ºr Store und Rendering-Logic

**Implementation Plan:**

**Schritt 1: Location Marker Store** (~30min)
- Erstelle `src/features/maps/state/location-marker-store.ts`
- Pattern: √§hnlich wie `faction-overlay-store.ts`
- Interface:
  ```typescript
  interface LocationMarker {
      coord: TileCoord;
      locationName: string;
      locationType: LocationType;
      icon?: string; // SVG path or emoji
  }
  ```
- Store-API: `setMarkers()`, `get()`, `list()`, `clear()`

**Schritt 2: Marker Rendering** (~45min)
- SVG Marker Layer in `hex-render.ts`
- Icons basierend auf Location Type (üèôÔ∏è üèòÔ∏è üè¢ ‚öîÔ∏è etc.)
- Marker √ºber Hex-Polygon positionieren
- Subscribe zu location-marker-store

**Schritt 3: Inspector Integration** (~30min)
- Erweitere Inspector Mode (`modes/inspector.ts`)
- Zeige Location-Info wenn Hex mit Marker geklickt wird
- Display: Location Name, Type, Parent (falls vorhanden)
- Button "Open Location" ‚Üí √∂ffnet Location in Library

**Schritt 4: Editor Integration** (~45min)
- Neue Toolbar: "Location Marker" Tool
- Dropdown: Locations aus Library laden
- Click auf Hex: Location platzieren
- Shift+Click: Marker entfernen

**Schritt 5: Tests** (~30min)
- Unit Tests f√ºr `location-marker-store.ts`
- Test: setMarkers, get, list, clear
- Test: Marker persistence (via store)

**Out of Scope (sp√§tere Phasen):**
- ‚ùå Einflussbereiche (Area of Influence) ‚Üí Phase 3.3.1
- ‚ùå Automatische Marker-Platzierung ‚Üí sp√§ter
- ‚ùå Drag & Drop Marker verschieben ‚Üí sp√§ter
- ‚ùå Multi-Hex Locations (gro√üe St√§dte) ‚Üí sp√§ter

**Estimated Time:** 3-3.5 hours

**Actual Time:** ~3 hours

---

#### Phase 3.3 - Map POI Markers ‚úÖ ABGESCHLOSSEN
**Scope:** Locations auf der Hex-Karte platzieren und visualisieren

**Implementation Summary:**

**‚úÖ Completed Steps (1-3, 5):**

**Step 1: Location Marker Store** (200 lines)
- Created `location-marker-store.ts` with full store API
- Registry pattern per map file
- Icon mapping for location types (emoji-based)
- Store API: `setMarkers()`, `get()`, `list()`, `getByLocationName()`, `clear()`
- Follows `faction-overlay-store` pattern

**Step 2: Marker Rendering** (80 lines)
- Integrated marker layer in `hex-render.ts`
- SVG <g> element for location markers
- Subscribe to location-marker-store
- Render markers as SVG <text> with emojis
- Automatic positioning above hex center
- Tooltip support via SVG <title>
- Non-invasive: no changes to scene.ts

**Step 3: Inspector Integration** (90 lines)
- Added location marker info display to Inspector sidebar
- Shows: name, type, parent, owner when hex with marker is clicked
- "Open in Library" button navigates to Library view
- Automatic lookup from location-marker-store on hex selection
- Conditional rendering: only shown if marker exists

**Step 5: Unit Tests** (440 lines, 19 tests)
- Comprehensive test suite for `location-marker-store`
- Coverage: store creation, setMarkers validation, get/list/clear operations
- Bug fixes: Replace Obsidian `.empty()` with native DOM API
- Fixed test mocks for region-repository imports
- All 258/260 tests passing (99.2%)

**‚è∏ Deferred:**
- ‚ùå Step 4: Editor Mode Integration (marker placement tool)
  - Reason: Complex UI work, requires separate planning
  - Status: Deferred to Phase 3.3.1

**Architecture:**
- Marker store: WeakMap-based registry per App + Map file
- Rendering: Separate SVG <g> layer in contentG
- Inspector: Conditional UI section after "Notiz" field
- Tests: Mock-based unit tests, no E2E yet

**Files:**
- `src/features/maps/state/location-marker-store.ts` (200 lines) - Store
- `src/features/maps/rendering/hex-render.ts` (+80 lines) - Rendering
- `src/workmodes/cartographer/modes/inspector.ts` (+90 lines) - Inspector
- `devkit/testing/unit/maps/location-marker-store.test.ts` (440 lines, 19 tests)

**Commits:**
- `52a4351` feat(locations): Steps 1-2 - Marker infrastructure
- `10e69c5` feat(locations): Step 3 - Inspector integration
- `a181f08` feat(locations): Step 5 - Unit tests + bug fixes

**Test Results:**
- ‚úÖ Build: 2.8mb (successful)
- ‚úÖ Tests: 258/260 passing (99.2%)
- ‚úÖ +19 new location-marker-store tests
- ‚è≠Ô∏è 2 skipped (todo-governance, header-policy)

**Next Steps:**
- Phase 3.3.1 - Editor Mode Integration (marker placement UI) ‚Üê **NEXT**
- Phase 3.4 - Dungeons (grid maps, room features)
- Phase 4 - Event Engine (calendar automation)

---

#### Phase 3.3.1 - Marker Editor Tool ‚úÖ COMPLETED

**Scope:** Editor Mode Tool zum Platzieren und Entfernen von Location Markern

**User Story:**
> "Als GM will ich im Cartographer Editor Mode Locations auf Hexes platzieren k√∂nnen, damit ich meine Karte mit wichtigen Orten annotieren kann."

**Acceptance Criteria:**
1. ‚úÖ Neues Tool "Location Marker" im Editor Mode
2. ‚úÖ Dropdown: Locations aus Library laden
3. ‚úÖ Click auf Hex: Location platzieren (marker erscheint)
4. ‚úÖ Mode-Switcher: Place/Remove Modi
5. ‚úÖ Persistence: Marker in TileData speichern (neue Eigenschaft)
6. ‚úÖ Auto-Sync: marker-store l√§dt aus TileData

**‚úÖ Completed Implementation:**

**Schritt 1: TileData Schema erweitern** (~15min) ‚úÖ
- Extended `TileData` interface mit `locationMarker?: string` property
- Updated `tile-repository.ts` load/save functions
- Validation logic mit 200 char limit
- Backward compatibility durch optional property

**Schritt 2-5: Editor Tool & Panel** (~2h) ‚úÖ
- Created `marker-panel.ts` (330 lines) following brush-options pattern
- Location dropdown mit Library integration
- Place/Remove mode switcher
- Auto-save to TileData on hex click
- Auto-sync mit location-marker-store
- Status messages & error handling

**Schritt 6: Editor Integration** (~30min) ‚úÖ
- Updated `editor.ts` mit Multi-Tool Support
- Tool dropdown enabled mit "Brush" und "Location Marker" options
- Tool switching logic mit cleanup
- Both tools work independently
- No regressions in existing brush functionality

**Files:**
- `src/features/maps/data/tile-repository.ts` (+20 lines) - Schema extension
- `src/workmodes/cartographer/editor/tools/location-marker/marker-panel.ts` (330 lines) - Tool
- `src/workmodes/cartographer/modes/editor.ts` (+100 lines) - Multi-tool support

**Test Results:**
- ‚úÖ Build: 2.8mb (successful)
- ‚úÖ Tests: 258/260 passing (99.2%)
- ‚úÖ No regressions in existing tests
- ‚úÖ Backward compatibility maintained (optional locationMarker property)

**Out of Scope (Future Enhancements):**
- ‚ùå Drag & Drop Marker verschieben ‚Üí later
- ‚ùå Multi-Hex Locations ‚Üí later
- ‚ùå Automatic marker placement ‚Üí later
- ‚ùå Marker editing (change location) ‚Üí later (re-place stattdessen)
- ‚ùå Keyboard Shortcut: `L` f√ºr Location Marker Tool ‚Üí later

**Total Time:** ~3 hours (15min + 2h + 30min)

---

### Phase 3.4 ‚Äì Dungeons ‚è≥ N√ÑCHSTER SCHRITT

**Zielbild (Langfristig):**
Vollst√§ndiges Dungeon-Management-System f√ºr den Session Runner:
- Grid-basierte Kartenansicht (quadratisch, Rasterzellen)
- Token-Management (Spieler, NPCs, Objekte auf Grid platzieren)
- Raum-Features mit IDs (T1/T2/T3 f√ºr T√ºren, F1/F2/F3 f√ºr Features)
- Feature-Kategorien: Geheimnisse (G), Hindernisse (H), Sch√§tze (S)
- Klickbare Navigation (Feature-ID ‚Üí Beschreibung)
- Optional: Fog of War, Ger√§uschradien

**Scope-Entscheidung:**
Phase 3.4 ist zu umfangreich f√ºr einen Sprint. Aufteilung in inkrementelle Slices:

#### Phase 3.4.1 - Dungeon Data Model & Storage ‚úÖ COMPLETED
**Scope:** Minimale Dungeon-Verwaltung als spezieller Location-Typ

**User Story:**
> "Als GM will ich Dungeons als speziellen Location-Typ in der Library verwalten k√∂nnen, damit ich Grid-Gr√∂√üe, R√§ume und Features strukturiert speichern kann."

**Acceptance Criteria:**
1. ‚úÖ Dungeon-Schema: Extends Location mit grid_width, grid_height, rooms
2. ‚úÖ Room-Schema: name, description, grid_bounds, doors, features
3. ‚úÖ Feature-Schema: id, type (door|secret|trap|treasure|hazard), position, description
4. ‚úÖ Library Integration: Conditional fields in create-spec, grid_size badge in browse view
5. ‚úÖ Serializer: Markdown-Format mit YAML frontmatter

**Implementation Plan:**

**Schritt 1: Schema Definition** (~30min)
- Extend `LocationDocument` interface ‚Üí `DungeonDocument`
- Add dungeon-specific fields:
  ```typescript
  type DungeonDocument = LocationDocument & {
    grid_width: number;      // Grid-Breite (z.B. 30)
    grid_height: number;     // Grid-H√∂he (z.B. 20)
    cell_size: number;       // Zellgr√∂√üe in Pixels (default: 40)
    rooms: DungeonRoom[];    // Array von R√§umen
  };

  type DungeonRoom = {
    id: string;              // Eindeutige ID (R1, R2, ...)
    name: string;            // Name des Raums
    description: string;     // Markdown-Text mit Sinneseindr√ºcken
    grid_bounds: {           // Raum-Bereich auf Grid
      x: number;
      y: number;
      width: number;
      height: number;
    };
    doors: DungeonDoor[];    // T√ºren/Ausg√§nge
    features: DungeonFeature[]; // Features im Raum
  };

  type DungeonDoor = {
    id: string;              // T1, T2, T3, ...
    position: { x: number; y: number };
    leads_to?: string;       // Raum-ID oder "outside"
    locked: boolean;
    description?: string;
  };

  type DungeonFeature = {
    id: string;              // F1, F2, F3, ...
    type: 'secret' | 'trap' | 'treasure' | 'hazard' | 'furniture' | 'other';
    position: { x: number; y: number };
    description: string;
  };
  ```

**Schritt 2: Serializer** (~45min)
- Create `dungeon-serializer.ts` following `location-serializer.ts` pattern
- Frontmatter: Basic fields + grid dimensions
- Body: Rooms als Markdown-Sections
  ```markdown
  ## Room R1: Entrance Hall

  **Bounds:** (0,0) - (10,8)

  ### Description
  A large hall with vaulted ceilings...

  ### Doors
  - T1 (3,0): Leads to R2 (Main Corridor)
  - T2 (10,4): Locked, leads to R3 (Treasury)

  ### Features
  - F1 (Secret): Hidden door at (7,2)
  - F2 (Trap): Pressure plate at (5,4)
  - F3 (Treasure): Chest at (8,6)
  ```

**Schritt 3: Library Integration** (~1h)
- Add Dungeon to `entity-registry.ts`
- Create `dungeon/create-spec.ts` (similar to location)
- Form fields:
  - Basic: name, type, owner, parent (from Location)
  - Grid: grid_width, grid_height, cell_size
  - Rooms: Array-Field (add/remove rooms)
  - Room Editor: Modal for editing einzelner Raum
- Browse view: Show grid dimensions badge

**Schritt 4: Tests** (~30min)
- Unit tests for dungeon-serializer
- Test room parsing and generation
- Test feature ID generation

**Out of Scope (sp√§tere Slices):**
- ‚ùå Grid Renderer (visual) ‚Üí Phase 3.4.2
- ‚ùå Token Management ‚Üí Phase 3.4.3
- ‚ùå Interactive Room Editor ‚Üí Phase 3.4.3
- ‚ùå Fog of War ‚Üí Phase 3.4.4 (optional)

**Estimated Time:** 3 hours

**‚úÖ Completed Implementation:**

**Schritt 1: Schema Definition** ‚úÖ
- Extended `LocationData` interface in `types.ts` with optional dungeon fields:
  - `grid_width?: number`, `grid_height?: number`, `cell_size?: number`, `rooms?: DungeonRoom[]`
- Created comprehensive type system: `DungeonRoom`, `DungeonDoor`, `DungeonFeature`, `GridBounds`, `GridPosition`
- Added helper functions: `getFeatureTypePrefix()`, `getFeatureTypeLabel()`, `isDungeonLocation()`
- Feature type prefixes: G (Geheimnisse), H (Hindernisse), S (Sch√§tze), F (Features)

**Schritt 2: Serializer** ‚úÖ
- Extended `locationToMarkdown()` in `serializer.ts` to handle dungeon-specific sections
- Conditional rendering: Grid Size, Cell Size (non-default only), Rooms section
- Helper functions: `serializeRoom()`, `serializeDoor()`, `serializeFeature()`
- Backward compatible: Only adds sections when type === "Dungeon"

**Schritt 3: Library Integration** ‚úÖ
- Extended `LocationEntryMeta` interface with `grid_size?: string` field
- Modified `loadLocationEntry()` to extract grid dimensions for browse badges
- Added 3 conditional fields to `create-spec.ts` (visible only when type === "Dungeon"):
  - `grid_width` (number-stepper, default 30, range 5-100)
  - `grid_height` (number-stepper, default 20, range 5-100)
  - `cell_size` (number-stepper, default 40, range 20-80)
- Added grid_size badge to browse metadata: `‚¨ö 30√ó20`
- Updated frontmatter array to persist all dungeon fields

**Schritt 4: Tests** ‚úÖ
- Created `dungeon-serializer.test.ts` with 9 comprehensive test cases:
  - Basic location (no dungeon fields)
  - Dungeon with non-default cell_size
  - Dungeon without cell_size (default)
  - Single room with description
  - Room with doors (locked/unlocked)
  - Room with features (secret/trap/treasure)
  - Multi-room dungeon
  - Empty rooms array
  - All location fields preserved
- All tests passing ‚úÖ (9/9)
- No regressions in full test suite (267/269 passing)

**Files Modified:**
- `src/workmodes/library/locations/types.ts` (+110 lines) - Schema extension
- `src/workmodes/library/locations/serializer.ts` (+60 lines) - Dungeon serialization
- `src/workmodes/library/storage/data-sources.ts` (+15 lines) - Grid size extraction
- `src/workmodes/library/locations/create-spec.ts` (+50 lines) - Conditional fields & badges
- `devkit/testing/unit/library/locations/dungeon-serializer.test.ts` (260 lines) - New test file

**Test Results:**
- ‚úÖ Build: Successful (2.8mb)
- ‚úÖ Tests: 267/269 passing (99.3%)
- ‚úÖ All dungeon serializer tests passing (9/9)
- ‚úÖ No regressions in existing functionality

**Out of Scope (Future Phases):**
- ‚ùå Room array editor UI (complex nested forms) ‚Üí Phase 3.4.3
- ‚ùå Visual grid renderer ‚Üí Phase 3.4.2
- ‚ùå Interactive token placement ‚Üí Phase 3.4.3

**Total Time:** ~3 hours (matched estimate)

---

#### Phase 3.4.2 - Grid Renderer ‚úÖ COMPLETED
**Scope:** Canvas-based Visual Grid Renderer f√ºr Dungeon-Ansicht

**User Story:**
> "Als GM will ich eine visuelle Grid-Karte meines Dungeons sehen k√∂nnen, damit ich R√§ume, T√ºren und Features auf einen Blick erkenne und w√§hrend der Sitzung schnell navigieren kann."

**Acceptance Criteria:**
1. ‚úÖ Canvas-based Grid Renderer (quadratisches Raster)
2. ‚úÖ Room boundaries rendering (Raum-Rechtecke mit IDs)
3. ‚úÖ Door markers (Position + Icon, optional locked indicator)
4. ‚úÖ Feature markers (Position + Typ-Icon: G/H/S/F)
5. ‚úÖ Grid lines & cell coordinates (toggle)
6. ‚úÖ View integration: DungeonView als dedizierte Obsidian View

**Implementation Plan:**

**Schritt 1: Grid Renderer Core** (~1h)
- Create `src/features/dungeons/rendering/grid-renderer.ts`
- Canvas-based renderer mit:
  ```typescript
  interface GridRendererOptions {
    gridWidth: number;
    gridHeight: number;
    cellSize: number;
    showGrid: boolean;
    showCoordinates: boolean;
  }

  class GridRenderer {
    constructor(canvas: HTMLCanvasElement, options: GridRendererOptions);
    render(dungeon: LocationData): void;
    clear(): void;
    setOptions(options: Partial<GridRendererOptions>): void;
  }
  ```
- Grid lines drawing (horizontal/vertical)
- Cell coordinate labels (optional)

**Schritt 2: Room Rendering** (~45min)
- Render room boundaries als Rechtecke
- Room ID label im Zentrum
- Room name tooltip on hover
- Bounds: grid_bounds (x, y, width, height)
- Stroke color: distinct per room
- Fill: transparent or subtle background

**Schritt 3: Door & Feature Markers** (~1h)
- Door markers:
  - Position als kleine Icons (üö™)
  - Locked doors: üîí overlay
  - leads_to indicator (arrow?)
- Feature markers:
  - G (Secret): üëÅÔ∏è or üóùÔ∏è
  - H (Trap/Hazard): ‚ö†Ô∏è
  - S (Treasure): üí∞
  - F (Furniture/Other): üì¶
- Click handler: show tooltip mit description

**Schritt 4: View Integration** (~1h)
- Create `src/workmodes/library/locations/dungeon-view.ts`
- Mounted when location type === "Dungeon"
- Canvas container in detail view
- Toggle controls: Grid, Coordinates, Labels
- Status: "Loading...", "No rooms defined", "Ready"

**Schritt 5: Polish & Tests** (~30min)
- Responsive canvas sizing (fills container)
- Canvas exports (PNG snapshot?)
- Unit tests for grid calculations
- Visual regression test (optional)

**Out of Scope (sp√§tere Slices):**
- ‚ùå Zoom/Pan controls ‚Üí Phase 3.4.3
- ‚ùå Token placement (player/NPC positions) ‚Üí Phase 3.4.3
- ‚ùå Click-to-edit rooms ‚Üí Phase 3.4.3
- ‚ùå Fog of War overlay ‚Üí Phase 3.4.4
- ‚ùå Line-of-Sight calculations ‚Üí Phase 3.4.4
- ‚ùå Sound radius visualization ‚Üí Phase 3.4.4

**Technical Decisions:**
- Canvas API statt SVG (bessere Performance f√ºr gro√üe Grids)
- Cell size in pixels (z.B. 40px = 5ft in D&D)
- Grid origin: Top-left (0,0)
- Room IDs clickable for navigation

**Estimated Time:** 4 hours (1h + 45min + 1h + 1h + 30min)

**‚úÖ Completed Implementation:**

**Schritt 1: Grid Renderer Core** ‚úÖ
- Created `grid-renderer.ts` with Canvas-based rendering
- Grid lines drawing (horizontal/vertical) with configurable color
- Cell coordinate labels (togglable, every 5th cell)
- GridRendererOptions interface: gridWidth, gridHeight, cellSize, showGrid, showCoordinates
- Helper methods: gridToPixel(), pixelToGrid() for coordinate conversion
- Automatic canvas sizing based on grid dimensions

**Schritt 2: Room Rendering** ‚úÖ
- Room boundaries as colored rectangles with distinct colors
- 8-color palette for visual distinction between rooms
- Room ID label centered in each room
- Room name label below ID (if room height > 50px)
- Grid bounds (x, y, width, height) correctly converted to pixels
- 2px black stroke for room boundaries

**Schritt 3: Door & Feature Markers** ‚úÖ
- Door markers: üö™ emoji at door position
- Locked door indicator: üîí overlay
- Door ID label below icon
- Feature markers by type:
  - Secret (G): üîç
  - Trap/Hazard (H): ‚ö†Ô∏è
  - Treasure (S): üí∞
  - Furniture/Other (F): üì¶
- Feature ID with type prefix (GF1, HF2, SF3)

**Schritt 4: View Integration** ‚úÖ
- Created `DungeonView` class extending ItemView
- Registered in VIEW_MANIFEST as "salt-dungeon-view"
- Toggle controls: Grid, Coordinates (future: Export)
- `openDungeonView()` helper function to open dungeons from files
- Reads LocationData from frontmatter
- Validates dungeon requirements (grid_width, grid_height)
- Reuses existing view or creates new leaf

**Schritt 5: Polish** ‚úÖ
- Responsive canvas sizing (updates on grid dimension changes)
- Control buttons for toggling grid/coordinates
- Error handling and logging
- Type guards for dungeon validation
- Clean separation of concerns (renderer ‚Üî view ‚Üî integration)

**Files Created:**
- `src/features/dungeons/rendering/grid-renderer.ts` (240 lines) - Core renderer
- `src/workmodes/library/locations/dungeon-view.ts` (224 lines) - View integration
- Modified: `src/workmodes/view-manifest.ts` (+10 lines) - View registration

**Test Results:**
- ‚úÖ Build: Successful (2.8mb)
- ‚úÖ Tests: 267/269 passing (99.3%)
- ‚úÖ No regressions in existing functionality
- ‚úÖ TypeScript compilation clean

**Out of Scope (Deferred):**
- ‚ùå CSS styling for controls ‚Üí Quick follow-up
- ‚ùå "View Grid" action in Library ‚Üí Follow-up
- ‚ùå Click handlers for tooltips ‚Üí Phase 3.4.3
- ‚ùå Zoom/Pan controls ‚Üí Phase 3.4.3

**Total Time:** ~4 hours (matched estimate)

---

#### Phase 3.4.3 - Navigation & Interactivity ‚è≥ N√ÑCHSTER SCHRITT
**Scope:** Zoom/Pan Controls und Click-to-Highlight f√ºr bessere Dungeon-Navigation

**User Story:**
> "Als GM will ich gro√üe Dungeons durch Zoom/Pan navigieren und R√§ume/Features anklicken k√∂nnen, damit ich w√§hrend der Sitzung schnell Details anzeigen und den Fokus √§ndern kann."

**Acceptance Criteria:**
1. ‚è≥ Zoom/Pan Controls (Mausrad + Drag)
2. ‚è≥ Click-to-highlight rooms (visuelles Feedback)
3. ‚è≥ Hover tooltips f√ºr doors/features (zeige description)
4. ‚è≥ Room detail panel (zeige room info on click)
5. ‚è≥ Zoom-Level Indicator (z.B. "100%")

**Implementation Plan:**

**Schritt 1: Zoom/Pan Infrastructure** (~1.5h)
- Extend GridRenderer mit Transform-State (scale, offsetX, offsetY)
- Zoom via Mausrad: scale *= (1 + delta * 0.001)
- Pan via Drag: update offsetX/offsetY on mousemove
- Constrain: minScale=0.5, maxScale=3.0
- Transform all rendering coordinates

**Schritt 2: Click-to-Highlight** (~1h)
- Add click event listener to canvas
- Convert canvas coords ‚Üí grid coords (account for transform)
- Find clicked room/door/feature
- Highlight selected room (thicker border + glow effect)
- Clear highlight on background click

**Schritt 3: Hover Tooltips** (~1h)
- Track mouse position on canvas
- Detect hovered door/feature
- Show tooltip div at mouse position
- Display: ID, type, description
- Hide on mouse leave

**Schritt 4: Room Detail Panel** (~1h)
- Add side panel to DungeonView
- Show on room click: Name, Description, Doors, Features
- "Close" button
- Scroll if content exceeds height

**Schritt 5: Polish & Tests** (~30min)
- Zoom level indicator (e.g., "125%")
- Reset view button (back to 100%, centered)
- Cursor feedback (grab/grabbing for pan)
- Unit tests for coordinate transforms

**Out of Scope (Phase 3.4.4):**
- ‚ùå Token Management (player/NPC tokens) ‚Üí Phase 3.4.4
- ‚ùå Drag & Drop tokens ‚Üí Phase 3.4.4
- ‚ùå Edit room data from UI ‚Üí Phase 3.4.4
- ‚ùå Fog of War ‚Üí Phase 3.4.5 (optional)

**Technical Decisions:**
- Canvas transform via ctx.save/restore + translate/scale
- Click detection: adjust for transform with inverse matrix
- Tooltips: absolute-positioned div, not canvas rendering
- Room panel: flexbox sidebar, togglable

**Estimated Time:** 5 hours (1.5h + 1h + 1h + 1h + 30min)

---

#### Phase 3.4.4 - Token Management ‚è≥ Later
**Scope:** Drag & Drop Token-Placement f√ºr Spieler/NPCs/Objekte
- Token types: Player, NPC, Monster, Object
- Drag & Drop from palette
- Move tokens on grid
- Token state persistence

**Estimated Time:** 4-5 hours

---

#### Phase 3.4.5 - Advanced Features ‚è≥ Optional
**Scope:** Fog of War, Sound Radii, Line-of-Sight
- FOW overlay (revealed/hidden cells)
- Sound propagation visualization
- LOS calculations

**Estimated Time:** 4-6 hours (optional)

---

### Phase 2.5 ‚Äì Faction Filtering ‚è≥ QoL
Creature-Liste mit Faction-Filter-Dropdown, Relevance-Scoring (Exact > Partial > No match). Optional, da Random Generator bereits filtert.

### Calculator & Loot Status ‚ö†Ô∏è Partial

**XP Calculator (‚úÖ Bereits in Phase 2.4 implementiert):**
- ‚úÖ Implementiert in `src/workmodes/encounter/presenter.ts:248-262`
- ‚úÖ D&D 5e CR-zu-XP Lookup Table (`xpByCr`)
- ‚úÖ Party XP Distribution (`deriveEncounterXpView`)
- ‚úÖ Modifier System (`EncounterXpRule` mit flat/percent/percentNextLevel/etc.)
- ‚úÖ Level Thresholds (`DND5E_XP_THRESHOLDS` in session-store.ts)
- ‚úÖ Unit-Tests: `xp-calculator.test.ts` ‚úÖ

**Fehlende Infrastruktur (f√ºr Phase 5):**
- ‚ùå Encounter-Preset Files (`SaltMarcher/EncounterPresets/*.md`) - Noch keine Markdown-Presets
- ‚ùå Preset-Import/Export UI f√ºr Hausregeln
- ‚ùå Loot Generator (`LootTemplateDocument` Schema existiert, keine Implementation)
- ‚ùå Tag-basiertes Loot-Filtering (Terrain/Faction ‚Üí passende Items)
- ‚ùå Magic Item Level-Limits und Rarity-Distribution

**Hinweis:** Phase 5 fokussiert auf **Loot & Preset Management**, nicht XP-Berechnung (bereits fertig).

### Phase 3 ‚Äì Orte & Dungeons ‚è≥ (Details siehe oben)
Inkrementelle Slices: 3.1 (CRUD) ‚Üí 3.2 (Hierarchy) ‚Üí 3.3 (Map Integration) ‚Üí 3.4 (Dungeons)

### Phase 4 ‚Äì Event Engine ‚è≥
**Zielbild:** Kalender-Events mit Timeline/Inbox, Automations-Hooks f√ºr Reise/Fraktionen/Orte
**Kickoff:** Trigger-Engine-Design, Wetter-Integration

### Phase 5 ‚Äì Calculator & Loot ‚è≥
**Zielbild:** Modularer Calculator mit Regel-DSL, Loot-Pipeline (Gold/Items/Magie, Tag-Filter)
**Kickoff:** Calculator-API entkoppeln, Loot-YAML-Format

### Phase 6 ‚Äì Audio & Release ‚è≥
**Zielbild:** Audio-System (Playlists, Fade/Loop), UX-Finishing, Release-Doku
**Kickoff:** Audio-Format definieren, Player-Prototyp

## üß™ Test-Suite Status

**Stats (Stand: 2025-10-29 - Post Phase 2.6):**
- ‚úÖ 222/224 Tests passing (99% pass rate)
- üéØ 49‚Üí0 Failures (100% Reduktion seit Phase 1 Start!)
- ‚è≠Ô∏è 2 Tests skipped (todo-governance, header-policy - nicht kritisch)
- ‚è±Ô∏è Test-Laufzeit: ~20s (schnell genug f√ºr TDD-Workflow)

**Test-Kategorien & Coverage:**
- ‚úÖ **Encounter Generator** (filterCreaturesByTags, calculateCreatureBudget, selectCreaturesForBudget) - 22 Tests ‚ú® NEW
- ‚úÖ **Almanac** (state-machine, calendar-repository, recurring events) - 12 Tests
- ‚úÖ **Cartographer** (editor mode, inspector mode, terrain brush) - 25 Tests
- ‚úÖ **Library** (view rendering, mode switching) - 18 Tests
- ‚úÖ **Domain** (creatures, spells, terrains, regions) - 45 Tests
- ‚úÖ **Integration** (encounter sync, travel tokens, XP calculator) - 32 Tests
- ‚úÖ **Store Architecture** (writable-store, persistent-store) - 28 Tests
- ‚úÖ **Encounter System** (presenter, XP calc, combat tracking) - 40 Tests

**Coverage-Sch√§tzung:**
- Core State (Store API, Event-Bus): ~90%
- Domain Logic (Creatures, XP Calc): ~85%
- Encounter System (Presenter, Combat, Generator): ~80% ‚ú® verbessert
- UI Components (View, Modal): ~40% (Mock-basiert)

**Known Gaps:**
- ‚ùå Kein E2E Testing (echtes Obsidian Plugin)
- ‚ùå Performance-Tests f√ºr gro√üe Datens√§tze (>1000 Creatures)
- ‚ùå Coverage-Reports (kein Tool konfiguriert)

**N√§chste Schritte:**
1. Langfristig: E2E-Test-Suite mit echtem Obsidian-Plugin
2. Coverage-Reports aktivieren (Istanbul/nyc)
3. Performance-Tests f√ºr Stress-Szenarien (viele Creatures, gro√üe Karten)
