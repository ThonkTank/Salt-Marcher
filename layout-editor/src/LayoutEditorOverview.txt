# Layout Editor – Overview

Der Layout Editor ist nun als vollständig eigenständiges Obsidian-Plugin verpackt. `main.ts` registriert den View, stellt ein API-Objekt für andere Erweiterungen bereit und injiziert das dedizierte Styling aus `css.ts`. Alle Persistenz- und Registry-Funktionen liegen weiterhin in `src/` und werden über `index.ts` gebündelt exportiert.

## Struktur

```
plugins/layout-editor/
├─ manifest.json          # Eigenes Obsidian-Manifest (lädt das gebündelte main.js)
├─ esbuild.config.mjs     # Build-Skript (bundelt src/main.ts → main.js)
├─ package.json           # Dev-Abhängigkeiten & Build-Skript
├─ package-lock.json      # Feste Auflösung der Dev-Abhängigkeiten
├─ tsconfig.json          # TypeScript-Konfiguration des Plugins
├─ main.js                # Gebündeltes Plugin-Artefakt (per esbuild erzeugt)
└─ src/
   ├─ main.ts             # Plugin-Bootstrap (View, Ribbon/Command, API, CSS-Injektion)
   ├─ css.ts              # Layout-Editor-Styling als Template-String
   ├─ index.ts            # Öffentliche Re-Exports (Plugin-Klasse, API, Registry, Library)
   ├─ seed-layouts.ts     # Legt Standard-Layouts im Vault an (z. B. Kreaturenvorlage)
   ├─ LayoutEditorOverview.txt  # Diese Übersicht
   ├─ elements/ui.ts      # UI-Komponenten (Buttons, Felder, Status) für View & Modals
   ├─ attribute-popover.ts # Attribute-Popover inkl. Events & Sync
   ├─ definitions.ts       # Element-/Attribut-Registry + Label-Helfer & Defaults
   ├─ elements/
   │  ├─ base.ts           # Gemeinsame Interfaces für Komponenten (Preview/Inspector)
   │  ├─ registry.ts       # Lädt automatisch alle Komponenten aus ./components
   │  ├─ shared/
   │  │  ├─ component-bases.ts # Abstrakte Basiskomponenten für Container-, Feld- & Select-Elemente
   │  │  └─ container-preview.ts # Gemeinsamer Preview-Renderer für Container
   │  └─ components/       # Drop-in-Komponenten pro Elementtyp (Preview, Inspector, Defaults)
   ├─ element-preview.ts   # Canvas-Vorschau delegiert an Element-Komponenten
   ├─ element-picker-modal.ts # Element-Browser mit Baumansicht für das Hinzufügen neuer Typen
   ├─ history.ts           # Undo/Redo-Verwaltung für LayoutSnapshots
   ├─ inline-edit.ts       # Generischer ContentEditable-Editor für Inline-Bearbeitung
   ├─ inspector-panel.ts   # Inspector-Rendering (Formfelder, Container-Steuerung, Attribute-Trigger)
   ├─ layout-library.ts    # Persistenz-Layer für gespeicherte Layouts (Vault JSON)
   ├─ layout-picker-modal.ts # Modal zur Auswahl gespeicherter Layouts aus der Bibliothek
   ├─ name-input-modal.ts  # Leichtgewichtiger Modal zum Benennen neuer Layouts
   ├─ search-dropdown.ts   # Autocomplete-Helfer für Select-Elemente
   ├─ view-registry.ts     # Registry für View-Bindings externer Features (Layout Editor API)
   ├─ types.ts             # Gemeinsame Typen für Elemente, Container & Snapshots
   ├─ ui/
   │  ├─ editor-menu.ts    # Kontextmenü-Komponente für Inspector & weitere Schnellaktionen
   │  └─ element-tree.ts   # Generische Baumansicht mit ein-/ausklappbaren Gruppen für den Element-Browser
   └─ utils.ts             # Hilfsfunktionen (clamp, Deep-Clones, Vergleichs-Utilities)
```

## Features & Verantwortlichkeiten

- **Plugin-Einstieg (`main.ts`):** Registriert den `LayoutEditorView`, richtet Ribbon-Icon und Command ein, injiziert die Styles aus `css.ts` und stellt über `getApi()` ein `LayoutEditorPluginApi` bereit (Open-View, Registry-Hooks, Layout-Library-Funktionen).
- **Eigenes Styling (`css.ts`):** Enthält das komplette Layout-Editor-CSS. Wird ausschließlich vom Layout-Editor-Plugin injiziert und kollidiert somit nicht länger mit SaltMarcher-spezifischem Styling. Die View-Container-Vorschau nutzt `box-sizing: border-box` und erzwingt mit `min-width/min-height: 0` auf dem flexiblen Viewport, dass die Demo-Fläche auch bei großen Surface-Inhalten innerhalb des 960 px-Frames bleibt und sauber schrumpfen kann.
- **Layout-Arbeitsfläche & Kamera:** Dreigeteilte Arbeitsumgebung mit Strukturbaum links, Canvas in der Mitte und Inspector rechts. Panning, Zoom und Panel-Resizer halten Bounds-Clamping und Fokusverhalten konsistent.
- **Struktur-Überblick:** Interaktiver Baum mit Drag & Drop zur Container-Neuzuordnung (inkl. Root-Drop-Zone) und zyklusgesicherter Elternwahl. Inspector- und Baum-Breiten lassen sich über Trenner anpassen.
- **Elementbibliothek & Registry:** Der „+ Element“-Trigger öffnet den `ElementPickerModal`, der alle Definitionen als einklappbare Baumstruktur darstellt. Registry-Änderungen aktualisieren die Baumansicht live, neue Komponenten landen weiterhin nur unter `src/elements/components/`.
- **Elements-UI:** Header, Inspector, Menüs und Modals verwenden die generischen Buttons, Felder und Statusanzeigen aus `elements/ui.ts`, damit der Editor vollständig auf Elements-Komponenten basiert.
- **Komponentenbasierte Elemente:** `elements/` bündelt Preview-, Inspector- und Default-Logik je Elementtyp und reduziert Redundanz bei neuen UI-Elementen. Gemeinsame Eigenschaften (z. B. Container-Layout, Select- oder Textfeld-Verhalten) liegen nun in `shared/component-bases.ts` und werden von konkreten Komponenten geerbt.
- **Container-Layout:** Box-, VBox- und HBox-Container verwalten Gap, Padding und Align sowie verschachtelte Kinder. Inspector und Baum unterstützen das schnelle Hinzufügen und Neuzuordnen von Elementen.
- **Direkte Bearbeitung & Inspector:** Canvas rendert echte UI-Elemente. Freie Texte lassen sich inline editieren, alle Meta-Informationen pflegst du im Inspector (Labels, Placeholder, Optionen, Layout-Werte).
- **Vorschau & Inline-Editing:** `element-preview.ts` erzeugt realistische Vorschauen; `inline-edit.ts` kapselt ContentEditable inklusive Placeholder/Trim-Logik.
- **Attribute-Popover:** `attribute-popover.ts` verwaltet Öffnen, Positionierung und Callbacks, sodass Inspector, Canvas und Historie synchron bleiben.
- **Undo/Redo-Historie:** `history.ts` kapselt Snapshot-Verwaltung; `view.ts` bindet sie an Shortcuts (Strg+Z / Umschalt+Strg+Z) und automatische Pushes bei Mutationen.
- **Export & Layout-Library:** `view.ts` erstellt JSON-Exporte nun inklusive Metadaten (`id`, `name`, `createdAt`, `updatedAt`) im exakt gleichen Format wie die Bibliothek sie speichert (`canvasWidth`, `canvasHeight`, `elements`). Dadurch lassen sich Layouts ohne Nachbearbeitung wieder importieren oder direkt im Vault bearbeiten; `layout-library.ts` persistiert Layouts unter `LayoutEditor/Layouts/<id>.json`, listet vorhandene Layouts und lädt sie erneut. Die IDs werden dabei konsequent aus dem Dateinamen abgeleitet, sodass auch manuell importierte oder umbenannte Layout-Dateien gefunden werden. Beim Speichern validiert die Library IDs gegen Pfadtrenner, rundet Canvas-Maße auf Ganzzahlen, klont alle Elemente strikt und meldet bei ungültigen Feldern verständliche Fehler. Beim Einlesen werden Maße, Layout-Configs sowie Options-/Attribute-Listen tolerant geparst (Strings, Objekt-Mappings, frühere Align-Werte wie `flex-start`), sodass auch ältere oder handbearbeitete Dateien sicher geladen werden. Für Nutzer mit Bestandsdateien berücksichtigt die Library zusätzlich den Legacy-Pfad `Layout Editor/Layouts`, damit alte Layouts weiterhin erscheinen und importiert werden können. `seed-layouts.ts` sorgt beim Plugin-Start dafür, dass ein Standardlayout („Layout Editor – Kreaturenvorlage“) als JSON im Vault vorhanden ist.
- **Layout-Bibliothek Import:** `layout-picker-modal.ts` und `view.ts` öffnen gespeicherte Layouts aus der Bibliothek, setzen Canvas/Einstellungen entsprechend zurück und initialisieren die Undo/Redo-Historie direkt auf dem geladenen Stand.
- **View-Bindings & externe Features:** `view-registry.ts` hält registrierte Visualisierungen externer Plugins synchron und informiert Inspector/Preview. Die neue `view-container`-Komponente nutzt die Registry, um Feature-Dropdowns und Kamera-Demos (MMB-Pan, Wheel-Zoom) bereitzustellen, richtet die Demo-Fläche mit einem `ResizeObserver` (Fallback: RAF-Loop) unmittelbar an der aktuellen Elementgröße aus und speichert die gewählte `viewBindingId` im Layout.

## Layout-Library Workflow (Speichern, Öffnen & API-Nutzung)

### Speichern aus der View

1. **CTA "Layout speichern"** im Export-Panel triggert `promptSaveLayout()` in `view.ts`. Dieser öffnet den `NameInputModal`,
   übernimmt den zuletzt genutzten Namen als Vorschlag und wartet auf die Bestätigung.
2. **`handleSaveLayout()`** validiert den eingegebenen Namen, deaktiviert während des Vorgangs den CTA und reicht Canvas-Maße
   sowie eine Deep-Kopie der aktuellen `LayoutElement`-Liste an `saveLayoutToLibrary()` weiter.
3. **`saveLayoutToLibrary()`** legt (falls nötig) `LayoutEditor/Layouts/` an, erzeugt für neue Layouts eine UUID und speichert
   ein vollständiges `SavedLayout`-JSON (inklusive `createdAt`/`updatedAt`). Vor dem Schreiben prüft die Funktion IDs auf
   Pfadtrenner, validiert und rundet Canvas-Maße sowie normalisiert sämtliche Elemente strikt. Bei Fehlern liefert sie eine
   verständliche Meldung an den Aufrufer zurück; bei erneutem Speichern desselben Namens wird die bestehende ID
   wiederverwendet, sodass Versionen überschrieben statt dupliziert werden.
4. **View-Status aktualisieren:** Nach erfolgreichem Speichern merkt sich die View ID, Name und Zeitstempel und signalisiert
   Erfolg via `Notice`. Fehler werden geloggt und dem Nutzer über einen Fehler-`Notice` gemeldet.

### Öffnen gespeicherter Layouts

1. **"Layout öffnen"-Button** ruft `promptImportSavedLayout()` auf. Dieser instanziert den `LayoutPickerModal`, dessen
   `loadLayouts`-Callback `listSavedLayouts()` nutzt. Die Library aggregiert dabei sowohl neue (`LayoutEditor/Layouts`) als auch
   Legacy-Verzeichnisse (`Layout Editor/Layouts`) und sortiert nach `updatedAt`.
2. **Auswahl im Modal:** Dank des persistenten Auswahl-Cache liefert `onPick` stets eine valide Layout-ID zurück. Die View
   ruft anschließend `importSavedLayout()` und deaktiviert während des Imports den CTA.
3. **`loadSavedLayout()`** findet anhand der ID die passende JSON-Datei, normalisiert deren Inhalt (Dimensionen,
   Layout-Objekte inklusive Legacy-Ausrichtungen sowie Options-/Attribute-Arrays aus Listen oder Objekt-Mappings) und gibt ein
   `SavedLayout` zurück. Fehlerhafte Dateien werden übersprungen und erzeugen eine Nutzer-Meldung.
4. **`applySavedLayout()`** setzt Canvas-Maße, Element-Liste, Metadaten und Inputs zurück, zentriert die Kamera, rendert Canvas
   & Inspector neu, aktualisiert den Export-Textarea und initialisiert Undo/Redo direkt auf dem importierten Snapshot. Dadurch
   sind geladene Layouts ohne weiteren manuellen Schritt editierbar.

### Wiederverwendung in anderen Plugins

1. **API abrufen:** Andere Plugins können über Obsidians Plugin-Manager auf das Layout-Editor-Plugin zugreifen und mit
   `const layoutEditor = this.app.plugins.getPlugin("layout-editor");` den Export aus `src/index.ts` nutzen. Das Plugin stellt
   via `getApi()` die `LayoutEditorPluginApi` bereit.
2. **APIs für die Layout-Bibliothek:** `api.saveLayout()` nimmt ein `LayoutBlueprint` entgegen und speichert es identisch zur
   internen View-Logik. `api.listLayouts()` liefert alle verfügbaren `SavedLayout`-Metadaten (ID, Name, Maße, Timestamps) –
   ideal für eigene Auswahllisten. `api.loadLayout(id)` lädt und normalisiert ein Layout inklusive Elementstruktur für externe
   Renderer oder Generatoren.
3. **UI-Integration:** Mit `api.openView()` lässt sich der Editor programmatisch öffnen. Plugins, die eigene Elemente anbieten,
   registrieren Definitionen über `api.registerElementDefinition()` und erhalten Updates via `api.onDefinitionsChanged()`.

## Datenfluss

1. **Interaktionen** (Drag, Resize, Inspector, Inline): verändern `LayoutElement`-Strukturen.
2. **`view.ts`** synchronisiert Canvas, Inspector, Export und Statusmeldungen; ruft Hilfs-Renderer und Historie auf.
3. **`history.ts`** erzeugt Snapshots; Undo/Redo ruft `restoreSnapshot` und aktualisiert View + Inspector.
4. **Registry-Events** aus `definitions.ts` triggern Aktualisierungen im Element-Browser und Inspector.
5. **Attribute-Popover** sendet Änderungen via Callbacks zurück an `view.ts`; dort werden Export, Historie und Inspector synchronisiert.
6. **Layout-Library** speichert/liest Layout-JSON über `layout-library.ts` und liefert Metadaten (timestamps, Name, Maße) zurück an die View.

## Dateibeschreibungen

### `main.ts`
- Bootstrap des Plugins: registriert View, Ribbon-Icon und Command.
- Stellt `LayoutEditorPluginApi` bereit (Open-View, Registry- und Library-Methoden).
- Die API-Weiterleitungen binden die Registry-Helfer (`registerLayoutElementDefinition`/`unregisterLayoutElementDefinition`) explizit ein, damit die gebündelte Ausgabe keine fehlenden Referenzen mehr enthält.
- Integriert CSS-Injektion und sorgt beim Unload für Cleanup sowie Registry-Reset auf Default-Definitionen.

### `css.ts`
- Kapselt das komplette Layout-Editor-Styling als Template-String.
- Wird nur vom Layout-Editor-Plugin geladen, um Konflikte mit anderen Plugins zu vermeiden.
- Setzt im View-Container-Viewport `min-width`/`min-height` auf 0, damit das Flex-Item unabhängig von der Surface-Größe innerhalb des Rahmens bleiben kann.

### `index.ts`
- Re-exportiert Plugin-Klasse, API-Typ, Registry- und Library-Hilfen für Drittcode.

### `seed-layouts.ts`
- Definiert ein Start-Layout (Kreaturenformular) als `LayoutBlueprint`.
- Prüft beim Plugin-Load, ob das Layout bereits in `LayoutEditor/Layouts` existiert und legt es ansonsten via `saveLayoutToLibrary` an.
- Stellt damit sicher, dass der Vault immer mindestens ein bearbeitbares Layout ausliefert.

### `view.ts`
- Implementiert `LayoutEditorView` (`ItemView`).
- Baut Header („+ Element“-Button, Import, Status), Struktur-Baum, Stage mit Kamera, Inspector, Exportbereich und Sandbox auf – alle Controls basieren auf `elements/ui.ts`.
- Verwaltet State (Selektion, Historie, Canvas) und orchestriert Hilfs-Module.
- Öffnet gespeicherte Layouts über den `LayoutPickerModal`, setzt Canvas/Elemente zurück und initialisiert die Historie auf den importierten Stand.

### `definitions.ts`
- Enthält Element-Definitionen, Attribute-Gruppen und Registry-API (`registerLayoutElementDefinition`, `unregisterLayoutElementDefinition`, `onLayoutElementDefinitionsChanged`).

### `elements/base.ts`
- Definiert gemeinsame Interfaces für Komponenten (Preview/Inspector-Kontext, Utility-Hooks).

### `elements/registry.ts`
- Lädt zur Build-Zeit automatisch alle Komponenten unter `elements/components/` und stellt Lookup-Helfer bereit.

### `elements/components/*`
- Eine Datei pro UI-Element (Label, Textfeld, Container usw.). Enthält Definition, Preview-Renderer, Inspector-Logik und Default-Werte. Container-, Select- und Textfeld-Elemente erweitern die abstrakten Basisklassen aus `shared/component-bases.ts` und erben so Layout-, Optionen- bzw. Value-Handling.

### `elements/shared/component-bases.ts`
- Stellt abstrakte Basisklassen für generische UI-Komponenten bereit.
- `FieldComponent` bündelt gemeinsames Label-/Placeholder-Verhalten für Feld-Elemente.
- `TextFieldComponent` erweitert `FieldComponent` um Text-/Textarea-Steuerung inklusive Value-Sync.
- `ContainerComponent` kapselt Preview, Inspector und Default-Layout-Initialisierung für Container.
- `SelectComponent` erweitert `FieldComponent` und teilt das Verhalten für Dropdown-Elemente (mit/ohne Suche) inklusive Placeholder- und Optionen-Handling.

### `view-registry.ts`
- Registry für View-Bindings (ID, Label, optionale Beschreibung/Tags) samt Listener-Verwaltung.
- Wird über die Plugin-API freigegeben (`registerViewBinding`, `unregisterViewBinding`, `onViewBindingsChanged`).
- Erlaubt Drittplugins, kompatible Visualisierungen zentral anzumelden und Inspector/Preview zu aktualisieren.

### `elements/components/view-container.ts`
- Spezialisiertes Element für externe Renderflächen.
- Inspector bietet ein Dropdown der registrierten View-Bindings und speichert die Auswahl in `element.viewBindingId`.
- Preview demonstriert eine Kamera (Mittlere Maustaste zum Pannen, Mausrad zum Zoomen), beobachtet die Viewport-Größe per `ResizeObserver` (inkl. RAF-Fallback) für sofortiges Re-Fitting, räumt Observer/RAF beim Re-Render auf und blendet gewählte Feature-Namen/IDs ein.

### `layout-library.ts`
- Persistiert Layouts als JSON-Dateien im Vault-Ordner `LayoutEditor/Layouts`.
- Liefert `saveLayoutToLibrary`, `listSavedLayouts`, `loadSavedLayout` für wiederverwendbare Layout-Bibliotheken.
- Erzwingt, dass die Layout-ID dem Dateinamen entspricht, damit der Import auch bei manuell hinzugefügten oder umbenannten Dateien zuverlässig funktioniert, und blockiert Pfadtrenner in IDs.
- Validiert beim Speichern Canvas-Dimensionen und Elementdaten strikt (inkl. Klonen & Normalisierung) und meldet Fehler an den Aufrufer; beim Lesen werden Maße, Legacy-Ausrichtungen sowie Options-/Attribute-Sammlungen tolerant nachgezogen.

### `name-input-modal.ts`
- Stellt einen schlanken Modal zur Verfügung, um Layout-Namen einzutippen (inkl. Enter-Shortcut und CTA-Button).
- Baut Formular und CTA vollständig mit `elements/ui.ts` auf und verzichtet auf Obsidian-spezifische Controls.

### `search-dropdown.ts`
- Verwandelt native `<select>`-Elemente in durchsuchbare Dropdowns (Suchfeld, Keyboard-Navigation, Menü-Rendering).

### `history.ts`
- Snapshot-Verwaltung inkl. Undo/Redo-Logik und Wiederherstellungs-Callback.

### `inline-edit.ts`
- ContentEditable-Helfer mit Placeholder-, Trim- und Multiline-Unterstützung.

### `element-picker-modal.ts`
- Öffnet die neue Baumansicht für das Hinzufügen von Elementen über den „+ Element“-Button.
- Filtert Definitionen per Suchfeld und ruft `renderElementTree` zur Darstellung der Hierarchie auf.

### `ui/element-tree.ts`
- Stellt eine generische, einklappbare Baum-Komponente bereit (eigene Styles, keine Obsidian-Controls).
- Nutzt Buttons aus dem Elements-Designsystem und informiert Callbacks über die Auswahl einzelner Blätter.

### `ui/editor-menu.ts`
- Implementiert das kontextsensitive Menü des Layout-Editors.
- Stellt Keyboard- und Pointer-Handling bereit (Escape, Outside-Click) und kapselt das Positioning relativ zum Auslöser (z. B. im Inspector).

### `element-preview.ts`
- Delegiert das Rendering an die registrierten Komponenten und kapselt das gemeinsame Inline-Editing.

### `inspector-panel.ts`
- Baut den Inspector komplett mit Elements-UI-Komponenten und ruft Komponenten-Hooks für element-spezifische Felder auf (Label, Placeholder, Optionen, Layout).

### `attribute-popover.ts`
- Verwaltet Popover-Lifecycle (Öffnen, Fokus, Events) und synchronisiert ausgewählte Attribute.

### `utils.ts`
- Bietet Utility-Funktionen (Clamping, Deep-Clones, Vergleich) für View und Historie.

### `types.ts`
- Typisiert LayoutElemente, Container-Konfigurationen, Registry-Definitionen und gespeicherte Layouts.

### `layout-picker-modal.ts`
- Stellt einen Modal mit Such-Dropdown bereit, um gespeicherte Layouts auszuwählen und die Auswahl an `view.ts` zurückzumelden – inklusive Elements-Buttons, -Selects und Statusmeldungen. Bewahrt die gewählte Layout-ID jetzt vor dem Schließen auf, damit `onPick` auch nach dem Modal-Cleanup stets eine gültige ID erhält.
