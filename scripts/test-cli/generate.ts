// CLI-Generator: Scannt src/ und generiert gebundelte cli.mjs
// Nutzung: npx tsx scripts/test-cli/generate.ts

import * as fs from 'node:fs';
import * as path from 'node:path';
import { fileURLToPath } from 'node:url';
import ts from 'typescript';
import esbuild from 'esbuild';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const PROJECT_ROOT = path.resolve(__dirname, '../..');
const SRC_DIR = path.resolve(PROJECT_ROOT, 'src');
const TEMP_FILE = path.resolve(__dirname, 'cli.temp.ts');
const OUTPUT = path.resolve(__dirname, 'cli.mjs');

// Path aliases aus tsconfig.json
const PATH_ALIASES: Record<string, string> = {
  '@core': path.join(SRC_DIR, 'core'),
  '@shared': path.join(SRC_DIR, 'application/shared'),
  '@': SRC_DIR,
  '@services': path.join(SRC_DIR, 'services'),
  '@constants': path.join(SRC_DIR, 'constants'),
  '@entities': path.join(SRC_DIR, 'entities'),
  '#types': path.join(SRC_DIR, 'types'),
};

const PRESETS_DIR = path.resolve(PROJECT_ROOT, 'presets');

interface FunctionInfo {
  name: string;
  modulePath: string; // Relativer Pfad ohne .ts
}

// Module die Framework-Abhängigkeiten haben (svelte, obsidian)
const EXCLUDE_DIRS = ['views', 'application'];

// Keine einzelnen Dateien mehr ausgeschlossen - sessionState ist jetzt in infrastructure
const EXCLUDE_FILES: string[] = [];

function scanExports(): FunctionInfo[] {
  const results: FunctionInfo[] = [];

  function walk(dir: string) {
    if (!fs.existsSync(dir)) return;

    // Prüfen ob Verzeichnis ausgeschlossen ist
    const relDir = path.relative(SRC_DIR, dir);
    if (EXCLUDE_DIRS.some(exc => relDir === exc || relDir.startsWith(exc + path.sep))) {
      return;
    }

    for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        walk(fullPath);
      } else if (entry.name.endsWith('.ts') && !entry.name.endsWith('.d.ts')) {
        const relativePath = path.relative(SRC_DIR, fullPath);

        // Prüfen ob Datei ausgeschlossen ist
        if (EXCLUDE_FILES.some(exc => relativePath === exc)) {
          continue;
        }

        const modulePath = relativePath.replace('.ts', '');
        const exports = getExportedFunctions(fullPath);

        for (const name of exports) {
          results.push({ name, modulePath });
        }
      }
    }
  }

  walk(SRC_DIR);
  return results;
}

function getExportedFunctions(filePath: string): string[] {
  const content = fs.readFileSync(filePath, 'utf-8');

  // Leere Dateien überspringen
  if (content.trim().length === 0) return [];

  const sourceFile = ts.createSourceFile(filePath, content, ts.ScriptTarget.Latest, true);

  const exports: string[] = [];

  ts.forEachChild(sourceFile, node => {
    // export function foo() {}
    if (ts.isFunctionDeclaration(node) && node.name && hasExportModifier(node)) {
      exports.push(node.name.text);
    }

    // export const foo = () => {}
    if (ts.isVariableStatement(node) && hasExportModifier(node)) {
      for (const decl of node.declarationList.declarations) {
        if (ts.isIdentifier(decl.name) && decl.initializer) {
          if (ts.isArrowFunction(decl.initializer) || ts.isFunctionExpression(decl.initializer)) {
            exports.push(decl.name.text);
          }
        }
      }
    }
  });

  return exports;
}

function hasExportModifier(node: ts.Node): boolean {
  return ts.canHaveModifiers(node) &&
    (ts.getModifiers(node)?.some(m => m.kind === ts.SyntaxKind.ExportKeyword) ?? false);
}

function generateCLISource(functions: FunctionInfo[]): string {
  // Gruppiere nach Modul
  const byModule = new Map<string, string[]>();
  for (const fn of functions) {
    if (!byModule.has(fn.modulePath)) byModule.set(fn.modulePath, []);
    byModule.get(fn.modulePath)!.push(fn.name);
  }

  // Imports generieren
  const imports: string[] = [];
  const registryEntries: string[] = [];

  for (const [modulePath, names] of byModule) {
    const importPath = `../../src/${modulePath}`;
    imports.push(`import { ${names.join(', ')} } from '${importPath}';`);

    const fns = names.map(n => `    ${n},`).join('\n');
    registryEntries.push(`  '${modulePath}': {\n${fns}\n  },`);
  }

  return `// AUTO-GENERATED by generate.ts - DO NOT EDIT
import { parseArgs } from 'node:util';

// Vault-Initialisierung für CLI
import { setVault } from '../../src/infrastructure/vault/vaultInstance';
import { PresetVaultAdapter } from '../../src/infrastructure/vault/PresetVaultAdapter';
import creatures from '../../presets/creatures';
import factions from '../../presets/factions';
import terrains from '../../presets/terrains';
import genericGroupTemplates from '../../presets/encounter-templates';
import npcs from '../../presets/npcs';

// State-Initialisierung für CLI
import { resetState } from '../../src/infrastructure/state/sessionState';

// Services
${imports.join('\n')}

// Vault mit Presets initialisieren
const vaultAdapter = new PresetVaultAdapter();
vaultAdapter.register('creature', creatures);
vaultAdapter.register('faction', factions);
vaultAdapter.register('terrain', terrains);
vaultAdapter.register('group-template', genericGroupTemplates);
vaultAdapter.register('npc', npcs);
setVault(vaultAdapter);

// State mit Test-Daten initialisieren
resetState({
  activeMapId: 'test-map',
  party: {
    position: { q: 0, r: 0 },
    mapId: 'test-map',
    members: [],
    transport: 'foot',
  },
  time: {
    year: 1,
    month: 1,
    day: 1,
    hour: 8,
    minute: 0,
    daySegment: 'morning',
  },
  weather: { type: 'clear', severity: 0 },
  travel: { status: 'idle', route: null, progress: null },
  encounter: { status: 'idle', current: null },
  combat: { status: 'idle', participants: [], currentTurn: 0, round: 1 },
});

const registry: Record<string, Record<string, Function>> = {
${registryEntries.join('\n')}
};

async function main() {
  const { positionals, values } = parseArgs({
    allowPositionals: true,
    options: {
      list: { type: 'boolean', short: 'l' },
      help: { type: 'boolean', short: 'h' },
      debug: { type: 'boolean', short: 'd' },
    },
  });

  if (values.list && positionals.length === 0) {
    console.log('Verfügbare Module:');
    Object.keys(registry).forEach(m => console.log('  ' + m));
    return;
  }

  const [modulePath, functionName, argsJson] = positionals;

  if (values.help || !modulePath) {
    console.log(\`
Service-Test-CLI

Nutzung:
  node scripts/test-cli/cli.mjs <modul> <funktion> '<json-args>' [--debug]
  node scripts/test-cli/cli.mjs --list
  node scripts/test-cli/cli.mjs <modul> --list

Optionen:
  -d, --debug   Debug-Ausgaben aktivieren

Beispiel:
  node scripts/test-cli/cli.mjs services/encounterGenerator/encounterGenerator generateEncounter '{...}'
\`);
    return;
  }

  const mod = registry[modulePath];
  if (!mod) {
    console.error('Modul nicht gefunden:', modulePath);
    console.log('Verfügbare Module:', Object.keys(registry).join(', '));
    process.exit(1);
  }

  if (values.list) {
    console.log('Funktionen in', modulePath + ':');
    Object.keys(mod).forEach(f => console.log('  ' + f));
    return;
  }

  if (!functionName) {
    console.error('Funktionsname erforderlich.');
    console.log('Verfügbare Funktionen:', Object.keys(mod).join(', '));
    process.exit(1);
  }

  const fn = mod[functionName];
  if (typeof fn !== 'function') {
    console.error(functionName + ' ist keine Funktion.');
    process.exit(1);
  }

  // Debug-Modus aktivieren falls --debug Flag gesetzt
  if (values.debug) {
    process.env.DEBUG_SERVICES = 'true';
  }

  const args = argsJson ? JSON.parse(argsJson) : undefined;
  // Multi-Argument-Funktionen: Array = spread, sonst single arg
  const result = Array.isArray(args) ? await fn(...args) : await fn(args);
  console.log(JSON.stringify(result, null, 2));
}

main().catch(e => { console.error(e); process.exit(1); });
`;
}

// esbuild Plugin für Path Aliases (markiert fehlende als external)
function aliasPlugin(): esbuild.Plugin {
  const missingAliases: string[] = [];

  return {
    name: 'alias',
    setup(build) {
      // Resolve path aliases
      build.onResolve({ filter: /^@/ }, args => {
        for (const [alias, target] of Object.entries(PATH_ALIASES)) {
          if (args.path === alias || args.path.startsWith(alias + '/')) {
            const resolved = args.path.replace(alias, target);
            const tsPath = resolved + '.ts';
            const indexPath = resolved + '/index.ts';

            // Prüfen ob Datei existiert (direkt oder als index.ts)
            if (fs.existsSync(tsPath)) {
              return { path: tsPath };
            }
            if (fs.existsSync(indexPath)) {
              return { path: indexPath };
            }

            missingAliases.push(args.path);
            return { path: args.path, external: true };
          }
        }
        return null;
      });

      build.onEnd(() => {
        if (missingAliases.length > 0) {
          console.warn('\n⚠️  Fehlende Alias-Module (als external markiert):');
          [...new Set(missingAliases)].forEach(m => console.warn(`   - ${m}`));
        }
      });
    },
  };
}

// esbuild Plugin um fehlende Module zu erkennen
function missingModulesPlugin(): esbuild.Plugin {
  const missing: string[] = [];

  return {
    name: 'missing-modules',
    setup(build) {
      build.onResolve({ filter: /.*/ }, args => {
        // Relative imports prüfen
        if (args.path.startsWith('./') || args.path.startsWith('../')) {
          const dir = path.dirname(args.importer);
          const resolved = path.resolve(dir, args.path);
          const tsPath = resolved + '.ts';
          const indexPath = path.join(resolved, 'index.ts');

          if (!fs.existsSync(tsPath) && !fs.existsSync(indexPath) && !fs.existsSync(resolved)) {
            missing.push(args.path);
            return { path: args.path, external: true };
          }
        }
        return null;
      });

      build.onEnd(() => {
        if (missing.length > 0) {
          console.warn('\n⚠️  Fehlende Module (als external markiert):');
          [...new Set(missing)].forEach(m => console.warn(`   - ${m}`));
          console.warn('');
        }
      });
    },
  };
}

async function bundleCLI() {
  await esbuild.build({
    entryPoints: [TEMP_FILE],
    bundle: true,
    platform: 'node',
    format: 'esm',
    target: 'node18',
    outfile: OUTPUT,
    plugins: [aliasPlugin(), missingModulesPlugin()],
    external: ['svelte', 'svelte/*', 'obsidian'],
    logLevel: 'warning',
    banner: {
      js: '#!/usr/bin/env node',
    },
  });
}

// Main
console.log('Scanning src/ for exported functions...');
const functions = scanExports();

if (functions.length === 0) {
  console.log('Keine exportierten Funktionen gefunden.');
  process.exit(0);
}

console.log(`Found ${functions.length} functions in ${new Set(functions.map(f => f.modulePath)).size} modules.`);

const cliSource = generateCLISource(functions);

// Temporäre Datei schreiben
fs.writeFileSync(TEMP_FILE, cliSource);

try {
  // Mit esbuild bundeln
  await bundleCLI();
  console.log(`✓ Generated cli.mjs`);
} catch (e) {
  console.error('Build failed:', e);
  process.exit(1);
} finally {
  // Temporäre Datei löschen
  if (fs.existsSync(TEMP_FILE)) {
    fs.unlinkSync(TEMP_FILE);
  }
}
