/**
 * HexViewStore â€“ minimal reactive-ish store for pan/zoom/selection.
 * Keeps it framework-agnostic so we can use it in plain DOM or React/Preact.
 */
export interface HexViewState {
  zoom: number; // world scale
  panX: number; // world pan in px
  panY: number;
  hexSize: number;
  selected?: { q: number; r: number } | null;
  region?: string | null;
}

type Listener = (s: HexViewState) => void;

export class HexViewStore {
  private s: HexViewState;
  private listeners: Set<Listener> = new Set();

  constructor(initial?: Partial<HexViewState>) {
    this.s = {
      zoom: 1.0,
      panX: 0,
      panY: 0,
      hexSize: 28,
      selected: null,
      region: null,
      ...initial,
    };
  }

  get state(): HexViewState { return this.s; }

  subscribe(fn: Listener): () => void {
    this.listeners.add(fn);
    fn(this.s);
    return () => this.listeners.delete(fn);
  }

  private emit() {
    for (const l of this.listeners) l(this.s);
  }

  set(partial: Partial<HexViewState>) {
    this.s = { ...this.s, ...partial };
    this.emit();
  }

  // helpers
  nudgePan(dx: number, dy: number) {
    this.set({ panX: this.s.panX + dx, panY: this.s.panY + dy });
  }
  setZoomAt(factor: number, atWorldX: number, atWorldY: number, viewportX: number, viewportY: number) {
    // Keep focus point stationary in viewport by compensating pan.
    const oldZoom = this.s.zoom;
    const newZoom = Math.max(0.1, Math.min(6, oldZoom * factor));
    const k = newZoom / oldZoom;

    // World point that maps to viewport (vx, vy):
    // vx = worldX * zoom + panX  => panX = vx - worldX*zoom
    // Keep vx constant, adjust pan so world focus remains under mouse.
    const panX = viewportX - atWorldX * newZoom;
    const panY = viewportY - atWorldY * newZoom;

    this.set({ zoom: newZoom, panX, panY });
    return { oldZoom, newZoom };
  }
}
