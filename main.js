"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// src/app/plugin-logger.ts
var import_obsidian, LOG_FILE_PATH, PluginLogger, logger2;
var init_plugin_logger = __esm({
  "src/app/plugin-logger.ts"() {
    "use strict";
    import_obsidian = require("obsidian");
    LOG_FILE_PATH = ".obsidian/plugins/salt-marcher/CONSOLE_LOG.txt";
    PluginLogger = class _PluginLogger {
      constructor() {
        this.buffer = [];
        this.isShutdown = false;
      }
      static getInstance() {
        if (!_PluginLogger.instance) {
          _PluginLogger.instance = new _PluginLogger();
        }
        return _PluginLogger.instance;
      }
      /**
       * Initialize logger with Obsidian app instance.
       * Clears previous log file and starts new session.
       */
      async init(app) {
        this.app = app;
        this.isShutdown = false;
        this.buffer = [];
        await this.clearLogFile();
        this.log("=".repeat(80));
        this.log("Salt Marcher Plugin Logger - Session Start");
        this.log(`Timestamp: ${(/* @__PURE__ */ new Date()).toISOString()}`);
        this.log("=".repeat(80));
        this.flushInterval = window.setInterval(() => {
          void this.flush();
        }, 1e4);
      }
      /**
       * Shutdown logger and perform final flush
       */
      async shutdown() {
        if (this.isShutdown) return;
        this.isShutdown = true;
        this.log("=".repeat(80));
        this.log("Salt Marcher Plugin Logger - Session End");
        this.log("=".repeat(80));
        if (this.flushInterval !== void 0) {
          window.clearInterval(this.flushInterval);
          this.flushInterval = void 0;
        }
        await this.flush();
        this.buffer = [];
      }
      /**
       * Log a message
       */
      log(...args) {
        this.capture("LOG", args);
        console.log("[salt-marcher]", ...args);
      }
      /**
       * Log an error with stack trace
       */
      error(...args) {
        this.capture("ERROR", args);
        console.error("[salt-marcher]", ...args);
      }
      /**
       * Log a warning
       */
      warn(...args) {
        this.capture("WARN", args);
        console.warn("[salt-marcher]", ...args);
      }
      /**
       * Log info
       */
      info(...args) {
        this.capture("INFO", args);
        console.info("[salt-marcher]", ...args);
      }
      /**
       * Capture log entry to buffer
       */
      capture(level, args) {
        if (this.isShutdown) return;
        const message = args.map((arg) => {
          if (arg instanceof Error) {
            return `${arg.message}
${arg.stack || ""}`;
          }
          if (typeof arg === "object") {
            try {
              return JSON.stringify(arg, null, 2);
            } catch {
              return String(arg);
            }
          }
          return String(arg);
        }).join(" ");
        this.buffer.push({
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          level,
          message
        });
      }
      /**
       * Flush buffer to log file
       */
      async flush() {
        if (!this.app || this.buffer.length === 0) return;
        try {
          const entries = [...this.buffer];
          this.buffer = [];
          const content = entries.map(
            (entry) => `[${entry.timestamp}] ${entry.level}: ${entry.message}`
          ).join("\n") + "\n";
          try {
            const file = this.app.vault.getAbstractFileByPath(LOG_FILE_PATH);
            if (file instanceof import_obsidian.TFile) {
              const existing = await this.app.vault.read(file);
              await this.app.vault.modify(file, existing + content);
              return;
            }
          } catch (readErr) {
          }
          try {
            await this.app.vault.create(LOG_FILE_PATH, content);
          } catch (createErr) {
            if (createErr?.message?.includes("already exists")) {
              const existing = await this.app.vault.adapter.read(LOG_FILE_PATH);
              await this.app.vault.adapter.write(LOG_FILE_PATH, existing + content);
            } else {
              throw createErr;
            }
          }
        } catch (err) {
          console.error("[salt-marcher] Failed to flush logs to file:", err);
        }
      }
      /**
       * Clear/recreate log file for new session
       */
      async clearLogFile() {
        if (!this.app) return;
        try {
          const file = this.app.vault.getAbstractFileByPath(LOG_FILE_PATH);
          if (file instanceof import_obsidian.TFile) {
            await this.app.vault.modify(file, "");
            return;
          }
          try {
            await this.app.vault.create(LOG_FILE_PATH, "");
          } catch (createErr) {
            if (createErr?.message?.includes("already exists")) {
              await this.app.vault.adapter.write(LOG_FILE_PATH, "");
            } else {
              throw createErr;
            }
          }
        } catch (err) {
          console.error("[salt-marcher] Failed to clear log file:", err);
        }
      }
    };
    logger2 = PluginLogger.getInstance();
  }
});

// src/features/maps/domain/options.ts
function parseOptions(src) {
  const blockMatch = src.match(/```[\t ]*hex3x3\b[\s\S]*?\n([\s\S]*?)\n```/i);
  const body = blockMatch ? blockMatch[1] : src;
  const d = { folder: "Hexes", folderPrefix: "Hex", prefix: "hex", radius: 42 };
  const lines = body.split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
  for (const line of lines) {
    const m = /^([A-Za-z][A-Za-z0-9_]*)\s*:\s*(.+)$/.exec(line);
    if (!m) continue;
    const k = m[1].toLowerCase();
    const v = m[2].trim();
    if (k === "folder") d.folder = v;
    else if (k === "folderprefix") d.folderPrefix = v;
    else if (k === "prefix") d.prefix = v;
    else if (k === "radius") {
      const n = Number(v);
      if (!Number.isNaN(n) && n > 10) d.radius = n;
    }
  }
  if (!d.folderPrefix && d.prefix) d.folderPrefix = d.prefix;
  if (!(d.radius > 0)) d.radius = 42;
  if (d.radius < 12) d.radius = 12;
  return d;
}
var init_options = __esm({
  "src/features/maps/domain/options.ts"() {
    "use strict";
  }
});

// src/ui/components/modals.ts
var import_obsidian2, NameInputModal, MapSelectModal;
var init_modals = __esm({
  "src/ui/components/modals.ts"() {
    "use strict";
    import_obsidian2 = require("obsidian");
    NameInputModal = class extends import_obsidian2.Modal {
      constructor(app, onSubmit, options) {
        super(app);
        this.onSubmit = onSubmit;
        this.value = "";
        this.placeholder = options?.placeholder ?? "New hex map";
        this.title = options?.title ?? "Name the new map";
        this.ctaLabel = options?.cta ?? "Create";
        if (options?.initialValue) {
          this.value = options.initialValue.trim();
        }
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h3", { text: this.title });
        let inputEl;
        new import_obsidian2.Setting(contentEl).addText((t) => {
          t.setPlaceholder(this.placeholder).onChange((v) => this.value = v.trim());
          inputEl = t.inputEl;
          if (this.value) {
            inputEl.value = this.value;
          }
        }).addButton((b) => b.setButtonText(this.ctaLabel).setCta().onClick(() => this.submit()));
        this.scope.register([], "Enter", () => this.submit());
        queueMicrotask(() => inputEl?.focus());
      }
      onClose() {
        this.contentEl.empty();
      }
      submit() {
        const name = this.value || this.placeholder;
        this.close();
        this.onSubmit(name);
      }
    };
    MapSelectModal = class extends import_obsidian2.FuzzySuggestModal {
      constructor(app, files, onChoose) {
        super(app);
        this.files = files;
        this.onChoose = onChoose;
        this.setPlaceholder("Search maps\u2026");
      }
      getItems() {
        return this.files;
      }
      getItemText(f) {
        return f.basename;
      }
      onChooseItem(f) {
        this.onChoose(f);
      }
    };
  }
});

// src/ui/maps/components/map-list.ts
async function getAllMapFiles(app) {
  const mdFiles = app.vault.getMarkdownFiles();
  const results = [];
  const rx = /```[\t ]*hex3x3\b[\s\S]*?```/i;
  for (const f of mdFiles) {
    const content = await app.vault.cachedRead(f);
    if (rx.test(content)) results.push(f);
  }
  return results.sort((a, b) => (b.stat.mtime ?? 0) - (a.stat.mtime ?? 0));
}
async function getFirstHexBlock(app, file) {
  const content = await app.vault.cachedRead(file);
  const m = content.match(/```[\t ]*hex3x3\b\s*\n([\s\S]*?)\n```/i);
  return m ? m[1].trim() : null;
}
var init_map_list = __esm({
  "src/ui/maps/components/map-list.ts"() {
    "use strict";
    init_modals();
  }
});

// src/features/maps/domain/terrain.ts
function normalizeTerrainColor(input) {
  if (typeof input !== "string") return "";
  let color = input.trim();
  if (!color) return "";
  if (color.startsWith('"') && color.endsWith('"') || color.startsWith("'") && color.endsWith("'")) {
    color = color.slice(1, -1).trim();
  }
  color = color.replace(/^[\s:]+/, "");
  return color.trim();
}
function validateTerrainSchema(next) {
  const validated = {};
  const issues = [];
  for (const [rawName, rawValue] of Object.entries(next ?? {})) {
    const name = (rawName ?? "").trim();
    const color = normalizeTerrainColor(rawValue?.color);
    if (!name && rawName !== "") {
      issues.push(`Terrain name must not be empty (received: "${rawName}")`);
      continue;
    }
    if (name.length > TERRAIN_NAME_MAX_LENGTH) {
      issues.push(`Terrain name "${name}" exceeds ${TERRAIN_NAME_MAX_LENGTH} characters`);
      continue;
    }
    if (/[:\n\r]/.test(name)) {
      issues.push(`Terrain name "${name}" must not contain colons or line breaks`);
      continue;
    }
    if (!color) {
      issues.push(`Terrain "${name}" requires a color value`);
      continue;
    }
    if (color !== "transparent" && !HEX_COLOR_RE.test(color) && !CSS_VAR_RE.test(color) && !CSS_FUNCTION_RE.test(color)) {
      issues.push(`Terrain "${name}" uses unsupported color "${color}"`);
      continue;
    }
    let numericSpeed;
    if (rawValue?.speed === void 0) {
      numericSpeed = 1;
    } else {
      numericSpeed = Number(rawValue.speed);
    }
    if (!Number.isFinite(numericSpeed)) {
      issues.push(`Terrain "${name}" speed must be a finite number`);
      continue;
    }
    if (numericSpeed < REGION_SPEED_MIN || numericSpeed > REGION_SPEED_MAX) {
      issues.push(
        `Terrain "${name}" speed ${numericSpeed} must be between ${REGION_SPEED_MIN} and ${REGION_SPEED_MAX}`
      );
      continue;
    }
    validated[name] = { color, speed: numericSpeed };
  }
  if (!("" in validated)) {
    validated[""] = { color: "transparent", speed: 1 };
  }
  if (issues.length) {
    throw new TerrainValidationError(issues);
  }
  return validated;
}
function applyTerrainSchema(map2) {
  const mergedColors = { ...DEFAULT_TERRAIN_COLORS, ...Object.fromEntries(
    Object.entries(map2).map(([name, value]) => [name, value.color])
  ) };
  const mergedSpeeds = { ...DEFAULT_TERRAIN_SPEEDS, ...Object.fromEntries(
    Object.entries(map2).map(([name, value]) => [name, value.speed])
  ) };
  mergedColors[""] = map2[""]?.color ?? "transparent";
  mergedSpeeds[""] = map2[""]?.speed ?? 1;
  for (const key of Object.keys(TERRAIN_COLORS)) {
    if (!(key in mergedColors)) delete TERRAIN_COLORS[key];
  }
  Object.assign(TERRAIN_COLORS, mergedColors);
  for (const key of Object.keys(TERRAIN_SPEEDS)) {
    if (!(key in mergedSpeeds)) delete TERRAIN_SPEEDS[key];
  }
  Object.assign(TERRAIN_SPEEDS, mergedSpeeds);
}
function setTerrains(next) {
  const validated = validateTerrainSchema(next ?? {});
  applyTerrainSchema(validated);
}
var DEFAULT_TERRAIN_COLORS, DEFAULT_TERRAIN_SPEEDS, TERRAIN_COLORS, TERRAIN_SPEEDS, TERRAIN_NAME_MAX_LENGTH, REGION_SPEED_MIN, REGION_SPEED_MAX, HEX_COLOR_RE, CSS_VAR_RE, CSS_FUNCTION_RE, TerrainValidationError;
var init_terrain = __esm({
  "src/features/maps/domain/terrain.ts"() {
    "use strict";
    DEFAULT_TERRAIN_COLORS = Object.freeze({
      "": "transparent",
      Wald: "#2e7d32",
      Meer: "#0288d1",
      Berg: "#6d4c41"
    });
    DEFAULT_TERRAIN_SPEEDS = Object.freeze({
      "": 1,
      // leeres Terrain = neutral
      Wald: 0.6,
      Meer: 0.5,
      Berg: 0.4
    });
    TERRAIN_COLORS = { ...DEFAULT_TERRAIN_COLORS };
    TERRAIN_SPEEDS = { ...DEFAULT_TERRAIN_SPEEDS };
    TERRAIN_NAME_MAX_LENGTH = 64;
    REGION_SPEED_MIN = 0;
    REGION_SPEED_MAX = 10;
    HEX_COLOR_RE = /^#(?:[0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
    CSS_VAR_RE = /^var\(--[a-z0-9_-]+\)$/i;
    CSS_FUNCTION_RE = /^(?:rgb|rgba|hsl|hsla)\(/i;
    TerrainValidationError = class extends Error {
      constructor(issues) {
        super(`Invalid terrain schema: ${issues.join(", ")}`);
        this.issues = issues;
        this.name = "TerrainValidationError";
      }
    };
  }
});

// src/features/maps/rendering/core/hex-geom.ts
function oddrToAxial(rc) {
  const parity = rc.r & 1;
  const q = rc.c - (rc.r - parity) / 2;
  return { q, r: rc.r };
}
function axialToOddr(ax) {
  const parity = ax.r & 1;
  const c = ax.q + (ax.r - parity) / 2;
  return { r: ax.r, c: Math.round(c) };
}
function axialToCube(ax) {
  return { q: ax.q, r: ax.r, s: -ax.q - ax.r };
}
function cubeToAxial(cu) {
  return { q: cu.q, r: cu.r };
}
function cubeDistance(a, b) {
  return (Math.abs(a.q - b.q) + Math.abs(a.r - b.r) + Math.abs(a.s - b.s)) / 2;
}
function cubeLerp(a, b, t) {
  return {
    q: a.q + (b.q - a.q) * t,
    r: a.r + (b.r - a.r) * t,
    s: a.s + (b.s - a.s) * t
  };
}
function cubeRound(fr) {
  let q = Math.round(fr.q), r = Math.round(fr.r), s = Math.round(fr.s);
  const qd = Math.abs(q - fr.q), rd = Math.abs(r - fr.r), sd = Math.abs(s - fr.s);
  if (qd > rd && qd > sd) q = -r - s;
  else if (rd > sd) r = -q - s;
  else s = -q - r;
  return { q, r, s };
}
function lineOddR(a, b) {
  const A = axialToCube(oddrToAxial(a));
  const B = axialToCube(oddrToAxial(b));
  const N = cubeDistance(A, B);
  const out = [];
  for (let i = 0; i <= N; i++) {
    const t = N === 0 ? 0 : i / N;
    const p = cubeRound(cubeLerp(A, B, t));
    out.push(axialToOddr(cubeToAxial(p)));
  }
  return out;
}
function hexPolygonPoints(cx, cy, r) {
  const pts = [];
  for (let i = 0; i < 6; i++) {
    const ang = (60 * i - 90) * Math.PI / 180;
    pts.push(`${cx + r * Math.cos(ang)},${cy + r * Math.sin(ang)}`);
  }
  return pts.join(" ");
}
var SQRT3;
var init_hex_geom = __esm({
  "src/features/maps/rendering/core/hex-geom.ts"() {
    "use strict";
    SQRT3 = Math.sqrt(3);
  }
});

// src/features/maps/rendering/scene/scene.ts
function createHexScene(config) {
  const { host, radius, padding, base, initialCoords } = config;
  const hexW = Math.sqrt(3) * radius;
  const hexH = 2 * radius;
  const hStep = hexW;
  const vStep = 0.75 * hexH;
  const svg = document.createElementNS(SVG_NS, "svg");
  svg.setAttribute("class", "hex3x3-map");
  svg.setAttribute("width", "100%");
  svg.style.touchAction = "none";
  const overlay = document.createElementNS(SVG_NS, "rect");
  overlay.setAttribute("fill", "transparent");
  overlay.setAttribute("pointer-events", "all");
  overlay.style.touchAction = "none";
  const contentG = document.createElementNS(SVG_NS, "g");
  svg.appendChild(overlay);
  svg.appendChild(contentG);
  host.appendChild(svg);
  const polyByCoord = /* @__PURE__ */ new Map();
  const internals = {
    bounds: null,
    viewBoxInitialized: false,
    applyFrame(adjustViewBox) {
      if (!internals.bounds) return;
      const { minX, minY, maxX, maxY } = internals.bounds;
      const paddedMinX = Math.floor(minX - padding);
      const paddedMinY = Math.floor(minY - padding);
      const paddedMaxX = Math.ceil(maxX + padding);
      const paddedMaxY = Math.ceil(maxY + padding);
      const width = Math.max(1, paddedMaxX - paddedMinX);
      const height = Math.max(1, paddedMaxY - paddedMinY);
      if (adjustViewBox || !internals.viewBoxInitialized) {
        svg.setAttribute("viewBox", `${paddedMinX} ${paddedMinY} ${width} ${height}`);
        internals.viewBoxInitialized = true;
      }
      overlay.setAttribute("x", String(paddedMinX));
      overlay.setAttribute("y", String(paddedMinY));
      overlay.setAttribute("width", String(width));
      overlay.setAttribute("height", String(height));
    },
    centerOf(coord) {
      const { r, c } = coord;
      const cx = padding + (c - base.c) * hStep + (r % 2 ? hexW / 2 : 0);
      const cy = padding + (r - base.r) * vStep + hexH / 2;
      return { cx, cy };
    },
    bboxOf(coord) {
      const { cx, cy } = internals.centerOf(coord);
      return {
        minX: cx - hexW / 2,
        maxX: cx + hexW / 2,
        minY: cy - radius,
        maxY: cy + radius
      };
    }
  };
  function mergeBounds(next) {
    if (!internals.bounds) {
      internals.bounds = { ...next };
      return;
    }
    const current = internals.bounds;
    current.minX = Math.min(current.minX, next.minX);
    current.minY = Math.min(current.minY, next.minY);
    current.maxX = Math.max(current.maxX, next.maxX);
    current.maxY = Math.max(current.maxY, next.maxY);
  }
  function addHex(coord) {
    if (polyByCoord.has(keyOf(coord))) return false;
    const { cx, cy } = internals.centerOf(coord);
    const poly = document.createElementNS(SVG_NS, "polygon");
    poly.setAttribute("points", hexPolygonPoints(cx, cy, radius));
    poly.setAttribute("data-row", String(coord.r));
    poly.setAttribute("data-col", String(coord.c));
    poly.style.fill = "transparent";
    poly.style.stroke = "var(--text-muted)";
    poly.style.strokeWidth = "2";
    poly.style.transition = "fill 120ms ease, fill-opacity 120ms ease, stroke 120ms ease";
    poly.dataset.defaultStroke = "var(--text-muted)";
    poly.dataset.defaultStrokeWidth = "2";
    poly.dataset.terrainFill = "transparent";
    contentG.appendChild(poly);
    polyByCoord.set(keyOf(coord), poly);
    const label = document.createElementNS(SVG_NS, "text");
    label.setAttribute("x", String(cx));
    label.setAttribute("y", String(cy + 4));
    label.setAttribute("text-anchor", "middle");
    label.setAttribute("pointer-events", "none");
    label.setAttribute("fill", "var(--text-muted)");
    label.textContent = `${coord.r},${coord.c}`;
    contentG.appendChild(label);
    mergeBounds(internals.bboxOf(coord));
    return true;
  }
  function ensurePolys(coords) {
    let added = false;
    for (const coord of coords) {
      const key = keyOf(coord);
      if (polyByCoord.has(key)) continue;
      const created = addHex(coord);
      added = added || created;
    }
    if (added) internals.applyFrame(false);
  }
  function setFill(coord, color) {
    const poly = polyByCoord.get(keyOf(coord));
    if (!poly) return;
    const fill = color ?? "transparent";
    poly.dataset.terrainFill = fill;
    if (!poly.dataset.overlayColor) {
      poly.style.fill = fill;
      poly.style.fillOpacity = fill !== "transparent" ? "0.25" : "0";
    }
    if (fill !== "transparent") {
      poly.setAttribute("data-painted", "1");
    } else {
      poly.removeAttribute("data-painted");
    }
  }
  function setOverlay(coord, overlay2) {
    const poly = polyByCoord.get(keyOf(coord));
    if (!poly) return;
    if (overlay2) {
      const strokeWidth = overlay2.strokeWidth ?? "3";
      const fillOpacity = overlay2.fillOpacity ?? "0.5";
      poly.dataset.overlayColor = overlay2.color;
      if (overlay2.factionId) poly.dataset.factionId = overlay2.factionId;
      else delete poly.dataset.factionId;
      if (overlay2.factionName) poly.dataset.factionName = overlay2.factionName;
      else delete poly.dataset.factionName;
      poly.style.stroke = overlay2.color;
      poly.style.strokeWidth = strokeWidth;
      poly.style.strokeOpacity = "0.9";
      poly.style.mixBlendMode = "multiply";
      poly.style.fill = overlay2.color;
      poly.style.fillOpacity = fillOpacity;
    } else {
      delete poly.dataset.overlayColor;
      delete poly.dataset.factionId;
      delete poly.dataset.factionName;
      poly.style.stroke = poly.dataset.defaultStroke ?? "var(--text-muted)";
      poly.style.strokeWidth = poly.dataset.defaultStrokeWidth ?? "2";
      poly.style.strokeOpacity = "1";
      poly.style.mixBlendMode = "";
      const terrainFill = poly.dataset.terrainFill ?? "transparent";
      poly.style.fill = terrainFill;
      poly.style.fillOpacity = terrainFill !== "transparent" ? "0.25" : "0";
    }
  }
  const initial = initialCoords.length ? initialCoords : [];
  if (initial.length) {
    for (const coord of initial) addHex(coord);
    internals.applyFrame(true);
  }
  return {
    svg,
    contentG,
    overlay,
    polyByCoord,
    ensurePolys,
    setFill,
    setOverlay,
    getViewBox: () => {
      if (!internals.bounds) {
        return { minX: 0, minY: 0, width: 0, height: 0 };
      }
      const { minX, minY, maxX, maxY } = internals.bounds;
      return { minX, minY, width: maxX - minX, height: maxY - minY };
    },
    destroy: () => {
      polyByCoord.clear();
      svg.remove();
    }
  };
}
var SVG_NS, keyOf;
var init_scene = __esm({
  "src/features/maps/rendering/scene/scene.ts"() {
    "use strict";
    init_hex_geom();
    SVG_NS = "http://www.w3.org/2000/svg";
    keyOf = (coord) => `${coord.r},${coord.c}`;
  }
});

// src/features/maps/rendering/core/camera.ts
function attachCameraControls(svg, contentG, opts, extraTargets = []) {
  let scale = 1;
  let tx = 0, ty = 0;
  let panning = false;
  let lastX = 0, lastY = 0;
  svg.style.touchAction = "none";
  const apply = () => {
    contentG.setAttribute("transform", `translate(${tx},${ty}) scale(${scale})`);
  };
  apply();
  const svgPoint = (clientX, clientY) => {
    const pt = svg.createSVGPoint();
    pt.x = clientX;
    pt.y = clientY;
    const ctm = svg.getScreenCTM();
    if (!ctm) return { x: clientX, y: clientY };
    const p = pt.matrixTransform(ctm.inverse());
    return { x: p.x, y: p.y };
  };
  const normalizeDelta = (ev) => ev.deltaMode === 1 ? ev.deltaY * 16 : ev.deltaMode === 2 ? ev.deltaY * 360 : ev.deltaY;
  const onWheel = (ev) => {
    ev.preventDefault();
    ev.stopPropagation();
    const dy = normalizeDelta(ev);
    const factor = Math.exp(-dy * 1e-3 * (opts.zoomSpeed || 1));
    const newScale = Math.max(opts.minScale, Math.min(opts.maxScale, scale * factor));
    if (newScale === scale) return;
    const { x: sx, y: sy } = svgPoint(ev.clientX, ev.clientY);
    const wx = (sx - tx) / scale, wy = (sy - ty) / scale;
    scale = newScale;
    tx = sx - wx * scale;
    ty = sy - wy * scale;
    apply();
  };
  const onPointerDown = (ev) => {
    if (ev.button !== 1) return;
    ev.preventDefault();
    ev.stopPropagation();
    panning = true;
    lastX = ev.clientX;
    lastY = ev.clientY;
    ev.target.setPointerCapture?.(ev.pointerId);
    svg.style.cursor = "grabbing";
  };
  const onPointerMove = (ev) => {
    if (!panning) return;
    ev.preventDefault();
    ev.stopPropagation();
    const dx = ev.clientX - lastX, dy = ev.clientY - lastY;
    lastX = ev.clientX;
    lastY = ev.clientY;
    tx += dx;
    ty += dy;
    apply();
  };
  const endPan = (ev) => {
    if (!panning) return;
    if (ev instanceof PointerEvent) {
      ev.preventDefault();
      ev.stopPropagation();
      ev.target.releasePointerCapture?.(ev.pointerId);
    }
    panning = false;
    svg.style.cursor = "";
  };
  const targets = [svg, ...extraTargets];
  for (const t of targets) {
    t.addEventListener("wheel", onWheel, { passive: false });
    t.addEventListener("pointerdown", onPointerDown);
    t.addEventListener("pointermove", onPointerMove);
    t.addEventListener("pointerup", endPan);
    t.addEventListener("pointercancel", endPan);
    t.addEventListener("pointerleave", endPan);
    t.style.touchAction = "none";
  }
  window.addEventListener("blur", endPan);
  return () => {
    for (const t of targets) {
      t.removeEventListener("wheel", onWheel);
      t.removeEventListener("pointerdown", onPointerDown);
      t.removeEventListener("pointermove", onPointerMove);
      t.removeEventListener("pointerup", endPan);
      t.removeEventListener("pointercancel", endPan);
      t.removeEventListener("pointerleave", endPan);
    }
    window.removeEventListener("blur", endPan);
  };
}
var init_camera = __esm({
  "src/features/maps/rendering/core/camera.ts"() {
    "use strict";
  }
});

// src/features/maps/rendering/scene/camera-controller.ts
function createCameraController(svg, contentG, overlay, host, options) {
  const detach = attachCameraControls(svg, contentG, options, [overlay, host]);
  return {
    destroy() {
      try {
        detach?.();
      } catch (err) {
        logger2.error("[hex-render] camera cleanup failed", err);
      }
    }
  };
}
var init_camera_controller = __esm({
  "src/features/maps/rendering/scene/camera-controller.ts"() {
    "use strict";
    init_camera();
    init_plugin_logger();
  }
});

// src/features/maps/rendering/interactions/interactions.ts
function createInteractionController(config) {
  const { svg, overlay, toContentPoint, pointToCoord, delegateRef, onDefaultClick } = config;
  let painting = false;
  let visited = null;
  let raf = 0;
  let lastPointer = null;
  const getDelegate = () => delegateRef.current;
  function convert(ev) {
    const pt = toContentPoint(ev);
    if (!pt) return null;
    return pointToCoord(pt.x, pt.y);
  }
  async function executePaintStep(ev) {
    const coord = convert(ev);
    if (!coord) return { outcome: "handled", coord: null };
    if (painting && visited?.has(keyOf2(coord))) {
      return { outcome: "handled", coord };
    }
    const handler = getDelegate().onPaintStep;
    if (!handler) return { outcome: "default", coord };
    const outcome = await handler(coord, ev);
    return { outcome, coord };
  }
  const onClick = async (ev) => {
    ev.preventDefault();
    const coord = convert(ev);
    if (!coord) return;
    const handler = getDelegate().onClick;
    const outcome = handler ? await handler(coord, ev) : "default";
    if (outcome === "default") {
      await onDefaultClick(coord, ev);
    }
  };
  const onPointerDown = (ev) => {
    if (ev.button !== 0) return;
    if (!getDelegate().onPaintStep) return;
    lastPointer = ev;
    void (async () => {
      const { outcome, coord } = await executePaintStep(ev);
      if (outcome === "start-paint" && coord) {
        painting = true;
        visited = /* @__PURE__ */ new Set([keyOf2(coord)]);
        svg.setPointerCapture?.(ev.pointerId);
        ev.preventDefault();
      } else if (outcome !== "default") {
        ev.preventDefault();
      }
    })();
  };
  const runQueuedPaintStep = () => {
    if (!painting || !lastPointer) return;
    const ev = lastPointer;
    void (async () => {
      const { outcome, coord } = await executePaintStep(ev);
      if (!painting) return;
      if (coord && outcome !== "default") {
        visited?.add(keyOf2(coord));
      }
    })();
  };
  const onPointerMove = (ev) => {
    if (!painting) return;
    lastPointer = ev;
    if (!raf) {
      raf = requestAnimationFrame(() => {
        raf = 0;
        runQueuedPaintStep();
      });
    }
    ev.preventDefault();
  };
  const endPaint = (ev) => {
    if (!painting) return;
    painting = false;
    visited?.clear();
    visited = null;
    lastPointer = null;
    if (raf) {
      cancelAnimationFrame(raf);
      raf = 0;
    }
    svg.releasePointerCapture?.(ev.pointerId);
    getDelegate().onPaintEnd?.();
    ev.preventDefault();
  };
  const onPointerCancel = (ev) => {
    if (!painting) return;
    endPaint(ev);
  };
  svg.addEventListener("click", onClick, { passive: false });
  svg.addEventListener("pointerdown", onPointerDown, { capture: true });
  svg.addEventListener("pointermove", onPointerMove, { capture: true });
  svg.addEventListener("pointerup", endPaint, { capture: true });
  svg.addEventListener("pointercancel", onPointerCancel, { capture: true });
  overlay.addEventListener("pointerdown", onPointerDown, { capture: true });
  overlay.addEventListener("pointermove", onPointerMove, { capture: true });
  overlay.addEventListener("pointerup", endPaint, { capture: true });
  overlay.addEventListener("pointercancel", onPointerCancel, { capture: true });
  return {
    destroy() {
      svg.removeEventListener("click", onClick);
      svg.removeEventListener("pointerdown", onPointerDown);
      svg.removeEventListener("pointermove", onPointerMove);
      svg.removeEventListener("pointerup", endPaint);
      svg.removeEventListener("pointercancel", onPointerCancel);
      overlay.removeEventListener("pointerdown", onPointerDown);
      overlay.removeEventListener("pointermove", onPointerMove);
      overlay.removeEventListener("pointerup", endPaint);
      overlay.removeEventListener("pointercancel", onPointerCancel);
      if (raf) {
        cancelAnimationFrame(raf);
        raf = 0;
      }
      painting = false;
      visited?.clear();
      visited = null;
      lastPointer = null;
    }
  };
}
var keyOf2;
var init_interactions = __esm({
  "src/features/maps/rendering/interactions/interactions.ts"() {
    "use strict";
    keyOf2 = (coord) => `${coord.r},${coord.c}`;
  }
});

// src/features/maps/rendering/core/coordinates.ts
function createCoordinateTranslator(config) {
  const { svg, contentG, base, radius, padding } = config;
  const hexW = Math.sqrt(3) * radius;
  const hexH = 2 * radius;
  const hStep = hexW;
  const vStep = 0.75 * hexH;
  const svgPoint = svg.createSVGPoint();
  const toContentPoint = (ev) => {
    const matrix = contentG.getScreenCTM();
    if (!matrix) return null;
    svgPoint.x = ev.clientX;
    svgPoint.y = ev.clientY;
    return svgPoint.matrixTransform(matrix.inverse());
  };
  const pointToCoord = (px, py) => {
    const rFloat = (py - padding - hexH / 2) / vStep + base.r;
    let r = Math.round(rFloat);
    const isOdd = r % 2 !== 0;
    let c = Math.round((px - padding - (isOdd ? hexW / 2 : 0)) / hStep + base.c);
    let best = { r, c };
    let bestD2 = Infinity;
    for (let dr = -1; dr <= 1; dr++) {
      const rr = r + dr;
      const odd = rr % 2 !== 0;
      const cc = Math.round((px - padding - (odd ? hexW / 2 : 0)) / hStep + base.c);
      const cx = padding + (cc - base.c) * hStep + (rr % 2 ? hexW / 2 : 0);
      const cy = padding + (rr - base.r) * vStep + hexH / 2;
      const dx = px - cx;
      const dy = py - cy;
      const d2 = dx * dx + dy * dy;
      if (d2 < bestD2) {
        bestD2 = d2;
        best = { r: rr, c: cc };
      }
    }
    return best;
  };
  return {
    toContentPoint,
    pointToCoord
  };
}
var init_coordinates = __esm({
  "src/features/maps/rendering/core/coordinates.ts"() {
    "use strict";
  }
});

// src/ui/utils/layout.ts
var layout_exports = {};
__export(layout_exports, {
  getCenterLeaf: () => getCenterLeaf,
  getRightLeaf: () => getRightLeaf
});
function getRightLeaf(app) {
  logger2.log("[Layout] Requesting right leaf...");
  const leaf = app.workspace.getRightLeaf(false) ?? app.workspace.getRightLeaf(true) ?? app.workspace.getLeaf(true);
  logger2.log("[Layout] Right leaf resolved:", leaf);
  return leaf;
}
function getCenterLeaf(app) {
  const leaf = app.workspace.getMostRecentLeaf() ?? app.workspace.getLeaf(false) ?? app.workspace.getLeaf(true);
  logger2.log("[Layout] Center leaf resolved:", leaf);
  return leaf;
}
var init_layout = __esm({
  "src/ui/utils/layout.ts"() {
    "use strict";
    init_plugin_logger();
  }
});

// src/services/state/store.interface.ts
var init_store_interface = __esm({
  "src/services/state/store.interface.ts"() {
    "use strict";
  }
});

// src/services/state/writable-store.ts
function writable(initialValue, options) {
  const { debug = false, name = "unnamed-store" } = options || {};
  let value = initialValue;
  const subscribers = /* @__PURE__ */ new Set();
  const log = (event, payload) => {
    if (!debug) return;
    logger2.info(`[Store:${name}] ${event}`, {
      ...payload,
      storeName: name,
      event,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  };
  const notifySubscribers = (previousValue) => {
    log("value_changed", { value, previousValue });
    subscribers.forEach((subscriber) => {
      try {
        subscriber(value);
      } catch (error) {
        logger2.error(`[Store:${name}] Subscriber error:`, error);
      }
    });
  };
  const subscribe = (subscriber) => {
    subscribers.add(subscriber);
    log("subscribed", { metadata: { subscriberCount: subscribers.size } });
    try {
      subscriber(value);
    } catch (error) {
      logger2.error(`[Store:${name}] Initial subscriber call error:`, error);
    }
    return () => {
      subscribers.delete(subscriber);
      log("unsubscribed", { metadata: { subscriberCount: subscribers.size } });
    };
  };
  const get = () => {
    return value;
  };
  const set2 = (newValue) => {
    if (value === newValue) return;
    const previousValue = value;
    value = newValue;
    notifySubscribers(previousValue);
  };
  const update = (updater) => {
    const newValue = updater(value);
    set2(newValue);
  };
  log("initialized", { value: initialValue });
  return {
    subscribe,
    get,
    set: set2,
    update
  };
}
var init_writable_store = __esm({
  "src/services/state/writable-store.ts"() {
    "use strict";
    init_plugin_logger();
  }
});

// src/services/state/persistent-store.ts
var import_obsidian3;
var init_persistent_store = __esm({
  "src/services/state/persistent-store.ts"() {
    "use strict";
    init_writable_store();
    import_obsidian3 = require("obsidian");
    init_plugin_logger();
  }
});

// src/services/state/adapters/json-store-adapter.ts
var init_json_store_adapter = __esm({
  "src/services/state/adapters/json-store-adapter.ts"() {
    "use strict";
    init_writable_store();
  }
});

// src/services/state/index.ts
var init_state = __esm({
  "src/services/state/index.ts"() {
    "use strict";
    init_store_interface();
    init_writable_store();
    init_persistent_store();
    init_json_store_adapter();
  }
});

// src/services/state/store-manager.ts
function getStoreManager() {
  if (!globalStoreManager || globalStoreManager.isDisposed()) {
    globalStoreManager = new StoreManagerImpl();
  }
  return globalStoreManager;
}
var StoreManagerImpl, globalStoreManager;
var init_store_manager = __esm({
  "src/services/state/store-manager.ts"() {
    "use strict";
    init_plugin_logger();
    StoreManagerImpl = class {
      constructor() {
        this.stores = /* @__PURE__ */ new Map();
        this.disposed = false;
      }
      /**
       * Register a store with the manager
       */
      register(name, store) {
        if (this.disposed) {
          throw new Error("StoreManager has been disposed");
        }
        if (this.stores.has(name)) {
          logger2.warn(`[StoreManager] Store "${name}" already registered, replacing`);
        }
        const isPersistent = this.isPersistentStore(store);
        this.stores.set(name, {
          name,
          store,
          isPersistent
        });
        logger2.info(`[StoreManager] Registered store "${name}"${isPersistent ? " (persistent)" : ""}`);
      }
      /**
       * Get a registered store by name
       */
      get(name) {
        if (this.disposed) {
          throw new Error("StoreManager has been disposed");
        }
        return this.stores.get(name)?.store;
      }
      /**
       * List all registered store names
       */
      list() {
        if (this.disposed) {
          throw new Error("StoreManager has been disposed");
        }
        return Array.from(this.stores.keys());
      }
      /**
       * Save all persistent stores
       */
      async saveAll() {
        if (this.disposed) {
          throw new Error("StoreManager has been disposed");
        }
        const persistentStores = Array.from(this.stores.values()).filter((entry) => entry.isPersistent).map((entry) => ({
          name: entry.name,
          store: entry.store
        }));
        if (persistentStores.length === 0) {
          logger2.info("[StoreManager] No persistent stores to save");
          return;
        }
        logger2.info(`[StoreManager] Saving ${persistentStores.length} persistent stores`);
        const savePromises = persistentStores.map(async ({ name, store }) => {
          try {
            await store.save();
            logger2.debug(`[StoreManager] Saved store "${name}"`);
          } catch (error) {
            logger2.error(`[StoreManager] Failed to save store "${name}":`, error);
            throw error;
          }
        });
        await Promise.all(savePromises);
        logger2.info("[StoreManager] All persistent stores saved");
      }
      /**
       * Load all persistent stores
       */
      async loadAll() {
        if (this.disposed) {
          throw new Error("StoreManager has been disposed");
        }
        const persistentStores = Array.from(this.stores.values()).filter((entry) => entry.isPersistent).map((entry) => ({
          name: entry.name,
          store: entry.store
        }));
        if (persistentStores.length === 0) {
          logger2.info("[StoreManager] No persistent stores to load");
          return;
        }
        logger2.info(`[StoreManager] Loading ${persistentStores.length} persistent stores`);
        const loadPromises = persistentStores.map(async ({ name, store }) => {
          try {
            await store.load();
            logger2.debug(`[StoreManager] Loaded store "${name}"`);
          } catch (error) {
            logger2.error(`[StoreManager] Failed to load store "${name}":`, error);
          }
        });
        await Promise.allSettled(loadPromises);
        logger2.info("[StoreManager] Persistent stores loaded");
      }
      /**
       * Dispose of all stores and cleanup
       */
      dispose() {
        if (this.disposed) {
          return;
        }
        logger2.info(`[StoreManager] Disposing ${this.stores.size} stores`);
        this.stores.clear();
        this.disposed = true;
        logger2.info("[StoreManager] Disposed");
      }
      /**
       * Check if disposed
       */
      isDisposed() {
        return this.disposed;
      }
      /**
       * Get store statistics
       */
      getStats() {
        const persistentCount = Array.from(this.stores.values()).filter((entry) => entry.isPersistent).length;
        return {
          totalStores: this.stores.size,
          persistentStores: persistentCount,
          nonPersistentStores: this.stores.size - persistentCount
        };
      }
      /**
       * Check if a store is persistent
       */
      isPersistentStore(store) {
        return "load" in store && typeof store.load === "function" && "save" in store && typeof store.save === "function";
      }
    };
    globalStoreManager = null;
  }
});

// src/features/maps/domain/faction-colors.ts
function getFactionColor(factionId, palette = DEFAULT_FACTION_COLORS) {
  const basePalette = palette.length > 0 ? palette : DEFAULT_FACTION_COLORS;
  if (basePalette.length === 0) return FALLBACK_COLOR;
  const key = factionId.trim();
  if (!key) return basePalette[0];
  let hash = 0;
  for (let i = 0; i < key.length; i++) {
    hash = hash * 31 + key.charCodeAt(i) >>> 0;
  }
  const index = hash % basePalette.length;
  return basePalette[index] ?? basePalette[0] ?? FALLBACK_COLOR;
}
var DEFAULT_FACTION_COLORS, FALLBACK_COLOR;
var init_faction_colors = __esm({
  "src/features/maps/domain/faction-colors.ts"() {
    "use strict";
    DEFAULT_FACTION_COLORS = [
      "#2E86AB",
      "#F6AA1C",
      "#C7443E",
      "#6A994E",
      "#4A4E69",
      "#EF8354",
      "#16697A",
      "#6C5B7B",
      "#3DCCC7",
      "#D9BF77",
      "#B8336A",
      "#1B998B",
      "#FF6F59",
      "#355070",
      "#70C1B3",
      "#F25F5C"
    ];
    FALLBACK_COLOR = "#9E9E9E";
  }
});

// src/features/maps/state/faction-overlay-store.ts
function getFactionOverlayStore(app, mapFile, options = {}) {
  let storesByApp = overlayRegistry.get(app);
  if (!storesByApp) {
    storesByApp = /* @__PURE__ */ new Map();
    overlayRegistry.set(app, storesByApp);
  }
  const mapPath = (0, import_obsidian4.normalizePath)(mapFile.path);
  let store = storesByApp.get(mapPath);
  if (!store) {
    store = createFactionOverlayStore(mapPath, options);
    storesByApp.set(mapPath, store);
  }
  return store;
}
function resetFactionOverlayStore(app, mapFile) {
  const storesByApp = overlayRegistry.get(app);
  if (!storesByApp) return;
  const mapPath = (0, import_obsidian4.normalizePath)(mapFile.path);
  const store = storesByApp.get(mapPath);
  if (store) {
    store.clear();
    storesByApp.delete(mapPath);
  }
}
function createFactionOverlayStore(mapPath, options) {
  const storeName = `map-factions:${mapPath}`;
  const state = writable(createEmptyState(mapPath), {
    name: storeName,
    debug: false
  });
  getStoreManager().register(storeName, state);
  const resolveColor = (factionId, palette) => {
    const normalized = factionId.trim();
    if (!normalized) return palette.get("") ?? FALLBACK_COLOR2;
    const existing = palette.get(normalized);
    if (existing) return existing;
    const custom = options.resolveColor?.(normalized, palette);
    if (custom && typeof custom === "string") {
      const value = custom.trim() || FALLBACK_COLOR2;
      palette.set(normalized, value);
      return value;
    }
    const color = getFactionColor(normalized, options.palette ?? DEFAULT_FACTION_COLORS);
    palette.set(normalized, color);
    return color;
  };
  const setAssignments = (assignments) => {
    const snapshot = state.get();
    const nextEntries = /* @__PURE__ */ new Map();
    const nextPalette = new Map(snapshot.palette);
    const seen = /* @__PURE__ */ new Set();
    for (const assignment of assignments) {
      if (!assignment) continue;
      const coord = normalizeCoord(assignment.coord);
      if (!coord) continue;
      const factionId = normalizeFactionId(assignment.factionId);
      if (!factionId) continue;
      const key = keyFromCoord(coord);
      if (seen.has(key)) continue;
      const overrideColor = normalizeColor(assignment.color);
      const color = overrideColor ?? resolveColor(factionId, nextPalette);
      if (overrideColor) {
        nextPalette.set(factionId, color);
      }
      const entry = {
        ...assignment,
        coord,
        factionId,
        color,
        key
      };
      nextEntries.set(key, entry);
      seen.add(key);
    }
    state.set({
      mapPath,
      loaded: true,
      entries: nextEntries,
      palette: nextPalette,
      version: Date.now()
    });
  };
  const clear = () => {
    state.set(createEmptyState(mapPath));
  };
  const get = (coord) => {
    const snapshot = state.get();
    const normalized = normalizeCoord(coord);
    if (!normalized) return null;
    return snapshot.entries.get(keyFromCoord(normalized)) ?? null;
  };
  const list = () => {
    const snapshot = state.get();
    return Array.from(snapshot.entries.values());
  };
  const getColorForFaction = (factionId) => {
    const snapshot = state.get();
    const normalized = normalizeFactionId(factionId);
    if (!normalized) return FALLBACK_COLOR2;
    const palette = new Map(snapshot.palette);
    const color = palette.get(normalized) ?? resolveColor(normalized, palette);
    if (!snapshot.palette.has(normalized)) {
      state.update((current) => {
        const nextPalette = new Map(current.palette);
        nextPalette.set(normalized, color);
        return {
          ...current,
          palette: nextPalette,
          version: Date.now()
        };
      });
    }
    return color;
  };
  return {
    state,
    setAssignments,
    clear,
    get,
    list,
    getColorForFaction
  };
}
function createEmptyState(mapPath) {
  return {
    mapPath,
    loaded: false,
    entries: /* @__PURE__ */ new Map(),
    palette: /* @__PURE__ */ new Map(),
    version: Date.now()
  };
}
function normalizeCoord(coord) {
  if (!coord) return null;
  const r = Number(coord.r);
  const c = Number(coord.c);
  if (!Number.isInteger(r) || !Number.isInteger(c)) return null;
  return { r, c };
}
function normalizeFactionId(id) {
  return typeof id === "string" ? id.trim() : "";
}
function keyFromCoord(coord) {
  return `${coord.r}:${coord.c}`;
}
function normalizeColor(color) {
  if (!color) return null;
  const trimmed = color.trim();
  if (!trimmed) return null;
  return trimmed;
}
var import_obsidian4, FALLBACK_COLOR2, overlayRegistry;
var init_faction_overlay_store = __esm({
  "src/features/maps/state/faction-overlay-store.ts"() {
    "use strict";
    import_obsidian4 = require("obsidian");
    init_state();
    init_store_manager();
    init_faction_colors();
    FALLBACK_COLOR2 = "#9E9E9E";
    overlayRegistry = /* @__PURE__ */ new WeakMap();
  }
});

// src/features/maps/state/tile-store.ts
function createEmptyTileStoreState(version = Date.now()) {
  return {
    loaded: false,
    tiles: /* @__PURE__ */ new Map(),
    version
  };
}
function createTileStore(deps) {
  const storeName = deps.name;
  const base = writable(createEmptyTileStoreState(0), {
    name: storeName,
    debug: deps.storeOptions?.debug
  });
  let loadPromise = null;
  const persistent2 = {
    subscribe: base.subscribe,
    get: base.get,
    set: base.set,
    update: base.update,
    load: async () => {
      const entries = await deps.listTilesFromDisk();
      const nextTiles = /* @__PURE__ */ new Map();
      for (const entry of entries) {
        nextTiles.set(keyFromCoord2(entry.coord), {
          coord: entry.coord,
          data: entry.data,
          file: entry.file
        });
      }
      base.set({
        loaded: true,
        tiles: nextTiles,
        version: Date.now()
      });
    },
    save: async () => {
    },
    isDirty: () => false,
    getStorageKey: () => deps.storageKey
  };
  getStoreManager().register(storeName, persistent2);
  const ensureLoaded = async () => {
    const snapshot = persistent2.get();
    if (snapshot.loaded && loadPromise === null) {
      return;
    }
    if (!loadPromise) {
      loadPromise = persistent2.load().finally(() => {
        loadPromise = null;
      });
    }
    await loadPromise;
  };
  const refresh = async () => {
    loadPromise = persistent2.load().finally(() => {
      loadPromise = null;
    });
    await loadPromise;
  };
  const loadTile2 = async (coord) => {
    await ensureLoaded();
    const snapshot = persistent2.get();
    const record = snapshot.tiles.get(keyFromCoord2(coord));
    if (record) {
      return record.data;
    }
    if (deps.loadTileFromDisk) {
      const data = await deps.loadTileFromDisk(coord);
      if (data) {
        await refresh();
        const refreshed = persistent2.get().tiles.get(keyFromCoord2(coord));
        return refreshed ? refreshed.data : data;
      }
      return data;
    }
    return null;
  };
  const saveTile2 = async (coord, data) => {
    const result = await deps.saveTileToDisk(coord, data);
    await ensureLoaded();
    persistent2.update((current) => {
      const nextTiles = new Map(current.tiles);
      nextTiles.set(keyFromCoord2(coord), {
        coord,
        data: result.data,
        file: result.file
      });
      return {
        loaded: true,
        tiles: nextTiles,
        version: Date.now()
      };
    });
    return result.file;
  };
  const deleteTile2 = async (coord) => {
    await deps.deleteTileFromDisk(coord);
    await ensureLoaded();
    persistent2.update((current) => {
      const nextTiles = new Map(current.tiles);
      nextTiles.delete(keyFromCoord2(coord));
      return {
        loaded: true,
        tiles: nextTiles,
        version: Date.now()
      };
    });
  };
  const listTiles = async () => {
    await ensureLoaded();
    const snapshot = persistent2.get();
    const rows = [];
    for (const record of snapshot.tiles.values()) {
      if (!record.file) {
        continue;
      }
      rows.push({
        coord: record.coord,
        data: record.data,
        file: record.file
      });
    }
    return rows;
  };
  return {
    state: persistent2,
    loadTile: loadTile2,
    saveTile: saveTile2,
    deleteTile: deleteTile2,
    listTiles,
    refresh
  };
}
function keyFromCoord2(coord) {
  return `${coord.r}:${coord.c}`;
}
var init_tile_store = __esm({
  "src/features/maps/state/tile-store.ts"() {
    "use strict";
    init_state();
    init_store_manager();
  }
});

// src/features/maps/data/tile-repository.ts
var tile_repository_exports = {};
__export(tile_repository_exports, {
  TileValidationError: () => TileValidationError,
  deleteTile: () => deleteTile,
  initTilesForNewMap: () => initTilesForNewMap,
  listTilesForMap: () => listTilesForMap,
  loadTile: () => loadTile,
  resetTileStore: () => resetTileStore,
  saveTile: () => saveTile,
  validateTileData: () => validateTileData
});
function validateTileData(data, options = {}) {
  const { allowUnknownTerrain = false } = options;
  const issues = [];
  const terrain = typeof data.terrain === "string" ? data.terrain.trim() : "";
  if (terrain.length > TILE_TERRAIN_MAX_LENGTH) {
    issues.push(`terrain exceeds ${TILE_TERRAIN_MAX_LENGTH} characters`);
  }
  if (!allowUnknownTerrain && terrain && !(terrain in TERRAIN_COLORS)) {
    issues.push(`unknown terrain "${terrain}"`);
  }
  const regionRaw = typeof data.region === "string" ? data.region : "";
  const region = regionRaw.trim();
  if (region.length > TILE_REGION_MAX_LENGTH) {
    issues.push(`region exceeds ${TILE_REGION_MAX_LENGTH} characters`);
  }
  const factionRaw = typeof data.faction === "string" ? data.faction : "";
  const faction = factionRaw.trim();
  if (faction.length > TILE_FACTION_MAX_LENGTH) {
    issues.push(`faction exceeds ${TILE_FACTION_MAX_LENGTH} characters`);
  }
  const locationMarkerRaw = typeof data.locationMarker === "string" ? data.locationMarker : "";
  const locationMarker = locationMarkerRaw.trim();
  if (locationMarker.length > TILE_LOCATION_MARKER_MAX_LENGTH) {
    issues.push(`locationMarker exceeds ${TILE_LOCATION_MARKER_MAX_LENGTH} characters`);
  }
  const noteRaw = typeof data.note === "string" ? data.note : void 0;
  const note = noteRaw?.trim();
  if (issues.length) {
    throw new TileValidationError(issues);
  }
  return {
    terrain,
    region,
    faction: faction || void 0,
    locationMarker: locationMarker || void 0,
    note: note || void 0
  };
}
function ensureOverlaySync(app, mapFile, store) {
  let byApp = overlaySyncRegistry.get(app);
  if (!byApp) {
    byApp = /* @__PURE__ */ new Map();
    overlaySyncRegistry.set(app, byApp);
  }
  const key = mapFile.path;
  if (byApp.has(key)) return;
  const overlayStore = getFactionOverlayStore(app, mapFile);
  const applyState = (state) => {
    if (!state.loaded) {
      overlayStore.clear();
      return;
    }
    const assignments = [];
    for (const record of state.tiles.values()) {
      const factionId = (record.data.faction ?? "").trim();
      if (!factionId) continue;
      assignments.push({
        coord: record.coord,
        factionId,
        factionName: record.data.faction ?? void 0,
        sourceId: record.file?.path
      });
    }
    overlayStore.setAssignments(assignments);
  };
  const unsubscribe = store.state.subscribe(applyState);
  applyState(store.state.get());
  const dispose = () => {
    unsubscribe();
    overlayStore.clear();
  };
  byApp.set(key, dispose);
}
function releaseOverlaySync(app, mapFile) {
  const byApp = overlaySyncRegistry.get(app);
  if (!byApp) return;
  const dispose = byApp.get(mapFile.path);
  if (dispose) {
    dispose();
    byApp.delete(mapFile.path);
  }
}
function mapNameFromPath(mapPath) {
  const base = mapPath.replace(/\\/g, "/").split("/").pop() || "Map";
  return base.replace(/\.md$/i, "");
}
function safeBaseName(name) {
  return name.trim().replace(/[\\\/:*?"<>|]/g, "_").replace(/\s+/g, " ");
}
function fileNameForMap(mapFile, coord) {
  const base = safeBaseName(mapNameFromPath(mapFile.path));
  return `${base}-${coord.r},${coord.c}.md`;
}
function legacyFilenames(folderPrefix, coord) {
  return [
    `${folderPrefix} ${coord.r},${coord.c}.md`,
    // z.B. "Hex 1,2.md"
    `${folderPrefix}-r${coord.r}-c${coord.c}.md`
    // z.B. "Hex-r1-c2.md"
  ];
}
function escapeRegex(src) {
  return src.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function coordFromFrontmatter(fmc) {
  if (!fmc) return null;
  const r = Number(fmc.row);
  const c = Number(fmc.col);
  if (!Number.isInteger(r) || !Number.isInteger(c)) return null;
  return { r, c };
}
function coordFromLegacyName(file, folderPrefix) {
  const base = file.path.replace(/\\/g, "/").split("/").pop() ?? file.path;
  const prefix = folderPrefix.trim();
  if (!prefix) return null;
  const spaced = new RegExp(`^${escapeRegex(prefix)}s+(-?\\d+),(-?\\d+)\\.md$`, "i");
  const dashed = new RegExp(`^${escapeRegex(prefix)}-r(-?\\d+)-c(-?\\d+)\\.md$`, "i");
  let match = base.match(spaced);
  if (match) return { r: Number(match[1]), c: Number(match[2]) };
  match = base.match(dashed);
  if (match) return { r: Number(match[1]), c: Number(match[2]) };
  return null;
}
function getTileStore(app, mapFile) {
  let storesByApp = tileStoreRegistry.get(app);
  if (!storesByApp) {
    storesByApp = /* @__PURE__ */ new Map();
    tileStoreRegistry.set(app, storesByApp);
  }
  const key = mapFile.path;
  let store = storesByApp.get(key);
  if (!store) {
    store = createTileStore({
      storageKey: (0, import_obsidian5.normalizePath)(`tiles://${mapFile.path}`),
      name: `map-tiles:${(0, import_obsidian5.normalizePath)(mapFile.path)}`,
      listTilesFromDisk: () => listTilesForMapFromDisk(app, mapFile),
      saveTileToDisk: (coord, data) => saveTileToDisk(app, mapFile, coord, data),
      deleteTileFromDisk: (coord) => deleteTileFromDisk(app, mapFile, coord),
      loadTileFromDisk: (coord) => loadTileFromDisk(app, mapFile, coord)
    });
    storesByApp.set(key, store);
  }
  ensureOverlaySync(app, mapFile, store);
  return store;
}
async function readOptions(app, mapFile) {
  const raw = await app.vault.read(mapFile);
  const opts = parseOptions(raw);
  const folder = (opts.folder ?? "Hexes").toString().trim();
  const folderPrefix = (opts.folderPrefix ?? "Hex").toString().trim();
  return { folder, folderPrefix };
}
async function ensureFolder(app, folderPath) {
  const path = (0, import_obsidian5.normalizePath)(folderPath);
  const existing = app.vault.getAbstractFileByPath(path);
  if (existing && existing instanceof import_obsidian5.TFolder) return existing;
  if (existing) throw new Error(`Pfad existiert, ist aber kein Ordner: ${path}`);
  await app.vault.createFolder(path);
  const created = app.vault.getAbstractFileByPath(path);
  if (!(created && created instanceof import_obsidian5.TFolder)) throw new Error(`Ordner konnte nicht erstellt werden: ${path}`);
  return created;
}
function fm(app, file) {
  return app.metadataCache.getFileCache(file)?.frontmatter ?? null;
}
function buildMarkdown(coord, mapPath, folderPrefix, data) {
  const validated = validateTileData(data, { allowUnknownTerrain: true });
  const terrain = validated.terrain ?? "";
  const region = (validated.region ?? "").trim();
  const faction = (validated.faction ?? "").trim();
  const locationMarker = (validated.locationMarker ?? "").trim();
  const mapName = mapNameFromPath(mapPath);
  const bodyNote = (validated.note ?? "Notizen hier \u2026").trim();
  return [
    "---",
    `type: ${FM_TYPE}`,
    `smHexTile: true`,
    `region: "${region}"`,
    `faction: "${faction}"`,
    `locationMarker: "${locationMarker}"`,
    `row: ${coord.r}`,
    `col: ${coord.c}`,
    `map_path: "${mapPath}"`,
    `terrain: "${terrain}"`,
    "---",
    `[[${mapName}|\u21A9 Zur Karte]]`,
    `# ${folderPrefix} r${coord.r} c${coord.c}`,
    "",
    bodyNote,
    ""
  ].join("\n");
}
async function resolveTilePath(app, mapFile, coord) {
  const { folder, folderPrefix } = await readOptions(app, mapFile);
  const folderPath = (0, import_obsidian5.normalizePath)(folder);
  const newName = fileNameForMap(mapFile, coord);
  const newPath = `${folderPath}/${newName}`;
  const legacy = legacyFilenames(folderPrefix, coord).map((n) => `${folderPath}/${n}`);
  let file = app.vault.getAbstractFileByPath(newPath);
  if (!file) {
    for (const oldPath of legacy) {
      const oldFile = app.vault.getAbstractFileByPath(oldPath);
      if (oldFile) {
        await app.fileManager.renameFile(oldFile, newPath);
        break;
      }
    }
    file = app.vault.getAbstractFileByPath(newPath);
  }
  return { folder: folderPath, newPath, file };
}
function parseFrontmatterBlock(src) {
  const m = src.match(/^---\s*([\s\S]*?)\s*---/m);
  if (!m) return null;
  const obj = {};
  for (const line of m[1].split(/\r?\n/)) {
    const mm = line.match(/^\s*([A-Za-z0-9_]+)\s*:\s*(.*)\s*$/);
    if (!mm) continue;
    let val = mm[2].trim();
    if (val.startsWith('"') && val.endsWith('"') || val.startsWith("'") && val.endsWith("'")) {
      val = val.slice(1, -1);
    }
    if (/^-?\d+$/.test(val)) obj[mm[1]] = Number(val);
    else obj[mm[1]] = val;
  }
  return obj;
}
async function fmFromFile(app, file) {
  const raw = await app.vault.read(file);
  return parseFrontmatterBlock(raw);
}
async function ensureTileSchema(app, mapFile, file, coord, cached) {
  const mapPath = mapFile.path;
  const current = cached ?? await fmFromFile(app, file) ?? {};
  const needsType = current.type !== FM_TYPE;
  const needsMarker = current.smHexTile !== true;
  const needsRow = Number(current.row) !== coord.r;
  const needsCol = Number(current.col) !== coord.c;
  const needsMap = current.map_path !== mapPath;
  if (needsType || needsMarker || needsRow || needsCol || needsMap) {
    await app.fileManager.processFrontMatter(file, (f) => {
      f.type = FM_TYPE;
      f.smHexTile = true;
      f.row = coord.r;
      f.col = coord.c;
      f.map_path = mapPath;
    });
    return await fmFromFile(app, file) ?? { type: FM_TYPE, row: coord.r, col: coord.c, map_path: mapPath };
  }
  return current;
}
async function adoptLegacyTile(app, mapFile, file, folderPath, folderPrefix, cached) {
  if (cached && typeof cached.map_path === "string") return null;
  let coord = coordFromFrontmatter(cached);
  if (!coord) {
    coord = coordFromLegacyName(file, folderPrefix);
  }
  if (!coord) return null;
  const raw = await app.vault.read(file);
  const mapName = mapNameFromPath(mapFile.path);
  const backlinkNeedle = `[[${mapName.toLowerCase()}|`;
  if (!raw.toLowerCase().includes(backlinkNeedle)) return null;
  const desiredPath = (0, import_obsidian5.normalizePath)(`${folderPath}/${fileNameForMap(mapFile, coord)}`);
  if ((0, import_obsidian5.normalizePath)(file.path) !== desiredPath) {
    const existing = app.vault.getAbstractFileByPath(desiredPath);
    if (existing && existing !== file) {
      return null;
    }
    await app.fileManager.renameFile(file, desiredPath);
    const renamed2 = app.vault.getAbstractFileByPath(desiredPath);
    if (renamed2 && renamed2 instanceof import_obsidian5.TFile) {
      file = renamed2;
    }
  }
  const ensured = await ensureTileSchema(app, mapFile, file, coord, cached);
  return { file, fmc: ensured, coord };
}
async function listTilesForMapFromDisk(app, mapFile) {
  const { folder, folderPrefix } = await readOptions(app, mapFile);
  const folderPath = (0, import_obsidian5.normalizePath)(folder);
  const folderPathLower = (folderPath.endsWith("/") ? folderPath : folderPath + "/").toLowerCase();
  const out = [];
  for (const file of app.vault.getFiles()) {
    let tileFile = file;
    const p = tileFile.path.toLowerCase();
    if (!p.startsWith(folderPathLower)) continue;
    if (!p.endsWith(".md")) continue;
    let fmc = fm(app, tileFile);
    if (!fmc || fmc.type !== FM_TYPE) {
      fmc = await fmFromFile(app, tileFile);
    }
    let coord = coordFromFrontmatter(fmc ?? null);
    const mapPath = mapFile.path;
    const hasTargetMap = !!(fmc && fmc.type === FM_TYPE && typeof fmc.map_path === "string" && fmc.map_path === mapPath);
    if (!hasTargetMap) {
      if (fmc && typeof fmc.map_path === "string" && fmc.map_path !== mapPath) {
        continue;
      }
      const adoption = await adoptLegacyTile(app, mapFile, tileFile, folderPath, folderPrefix, fmc ?? null);
      if (!adoption) continue;
      tileFile = adoption.file;
      fmc = adoption.fmc;
      coord = adoption.coord;
    } else if (coord) {
      fmc = await ensureTileSchema(app, mapFile, tileFile, coord, fmc ?? null);
    }
    if (!coord) coord = coordFromFrontmatter(fmc ?? null);
    if (!coord) continue;
    out.push({
      coord,
      file: tileFile,
      data: (() => {
        const terrain = typeof fmc?.terrain === "string" ? fmc.terrain : "";
        const region = typeof fmc?.region === "string" ? fmc.region : "";
        try {
          const validated = validateTileData({ terrain, region }, { allowUnknownTerrain: true });
          return { terrain: validated.terrain, region: validated.region ?? "" };
        } catch (error) {
          logger2.warn("[salt-marcher] Ignoring invalid tile data", error);
          return { terrain: terrain.trim(), region: region.trim() };
        }
      })()
    });
  }
  return out;
}
async function loadTileFromDisk(app, mapFile, coord) {
  const { file } = await resolveTilePath(app, mapFile, coord);
  if (!file) return null;
  let fmc = fm(app, file);
  if (!fmc || fmc.type !== FM_TYPE) {
    fmc = await fmFromFile(app, file);
  }
  fmc = await ensureTileSchema(app, mapFile, file, coord, fmc ?? null);
  if (!fmc || fmc.type !== FM_TYPE) return null;
  const raw = await app.vault.read(file);
  const body = raw.replace(/^---[\s\S]*?---\s*/m, "");
  const note = (body.split(/\n{2,}/).map((s) => s.trim()).find(Boolean) ?? "").trim();
  const terrain = typeof fmc.terrain === "string" ? fmc.terrain : "";
  const region = typeof fmc.region === "string" ? fmc.region : "";
  const faction = typeof fmc.faction === "string" ? fmc.faction : "";
  const locationMarker = typeof fmc.locationMarker === "string" ? fmc.locationMarker : "";
  try {
    const validated = validateTileData({ terrain, region, faction, locationMarker, note }, { allowUnknownTerrain: true });
    return validated;
  } catch (error) {
    logger2.warn("[salt-marcher] Loaded tile contains invalid data", error);
    return { terrain: terrain.trim(), region: region.trim(), faction: faction.trim() || void 0, locationMarker: locationMarker.trim() || void 0, note: note || void 0 };
  }
}
async function saveTileToDisk(app, mapFile, coord, data) {
  const sanitized = validateTileData(data);
  const mapPath = mapFile.path;
  const { folder, newPath, file } = await resolveTilePath(app, mapFile, coord);
  await ensureFolder(app, folder);
  if (!file) {
    const { folderPrefix } = await readOptions(app, mapFile);
    const md = buildMarkdown(coord, mapPath, folderPrefix, sanitized);
    const created = await app.vault.create(newPath, md);
    return { file: created, data: sanitized };
  }
  await app.fileManager.processFrontMatter(file, (f) => {
    f.type = FM_TYPE;
    f.smHexTile = true;
    f.row = coord.r;
    f.col = coord.c;
    f.map_path = mapPath;
    if (sanitized.region !== void 0) f.region = sanitized.region ?? "";
    if (sanitized.terrain !== void 0) f.terrain = sanitized.terrain ?? "";
    if (typeof f.terrain !== "string") f.terrain = "";
    if ("faction" in data) {
      if (sanitized.faction) {
        f.faction = sanitized.faction;
      } else {
        delete f.faction;
      }
    }
  });
  if (sanitized.note !== void 0) {
    const raw = await app.vault.read(file);
    const hasFM = /^---[\s\S]*?---/m.test(raw);
    const fmPart = hasFM ? (raw.match(/^---[\s\S]*?---/m) || [""])[0] : "";
    const body = hasFM ? raw.slice(fmPart.length).trimStart() : raw;
    const lines = body.split("\n");
    const keepBacklink = lines.find((l) => /\[\[.*\|\s*↩ Zur Karte\s*\]\]/.test(l));
    const newBody = [keepBacklink ?? "", sanitized.note.trim(), ""].filter(Boolean).join("\n");
    await app.vault.modify(file, `${fmPart}
${newBody}`.trim() + "\n");
  }
  return { file, data: sanitized };
}
async function deleteTileFromDisk(app, mapFile, coord) {
  const { file } = await resolveTilePath(app, mapFile, coord);
  if (!file) return;
  await app.vault.delete(file);
}
async function initTilesForNewMap(app, mapFile) {
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      await saveTile(app, mapFile, { r, c }, { terrain: "" });
    }
  }
  const store = getTileStore(app, mapFile);
  await store.refresh();
}
async function listTilesForMap(app, mapFile) {
  const store = getTileStore(app, mapFile);
  return await store.listTiles();
}
async function loadTile(app, mapFile, coord) {
  const store = getTileStore(app, mapFile);
  return await store.loadTile(coord);
}
async function saveTile(app, mapFile, coord, data) {
  const store = getTileStore(app, mapFile);
  return await store.saveTile(coord, data);
}
async function deleteTile(app, mapFile, coord) {
  const store = getTileStore(app, mapFile);
  await store.deleteTile(coord);
}
function resetTileStore(app, mapFile) {
  const storesByApp = tileStoreRegistry.get(app);
  const store = storesByApp?.get(mapFile.path);
  if (store) {
    releaseOverlaySync(app, mapFile);
    store.state.set(createEmptyTileStoreState());
    storesByApp?.delete(mapFile.path);
  }
}
var import_obsidian5, TILE_TERRAIN_MAX_LENGTH, TILE_REGION_MAX_LENGTH, TILE_FACTION_MAX_LENGTH, TILE_LOCATION_MARKER_MAX_LENGTH, TileValidationError, FM_TYPE, tileStoreRegistry, overlaySyncRegistry;
var init_tile_repository = __esm({
  "src/features/maps/data/tile-repository.ts"() {
    "use strict";
    import_obsidian5 = require("obsidian");
    init_terrain();
    init_options();
    init_plugin_logger();
    init_faction_overlay_store();
    init_tile_store();
    TILE_TERRAIN_MAX_LENGTH = 64;
    TILE_REGION_MAX_LENGTH = 120;
    TILE_FACTION_MAX_LENGTH = 120;
    TILE_LOCATION_MARKER_MAX_LENGTH = 200;
    TileValidationError = class extends Error {
      constructor(issues) {
        super(`Invalid tile data: ${issues.join(", ")}`);
        this.issues = issues;
        this.name = "TileValidationError";
      }
    };
    FM_TYPE = "hex";
    tileStoreRegistry = /* @__PURE__ */ new WeakMap();
    overlaySyncRegistry = /* @__PURE__ */ new WeakMap();
  }
});

// src/features/maps/rendering/interactions/interaction-delegate.ts
function dispatchInteraction(host, coord, phase, nativeEvent) {
  let outcome = null;
  const detail = {
    r: coord.r,
    c: coord.c,
    phase,
    nativeEvent,
    setOutcome(next) {
      outcome = next;
    }
  };
  const evt = new CustomEvent(EVENT_NAME, {
    detail,
    bubbles: true,
    cancelable: true
  });
  host.dispatchEvent(evt);
  if (outcome) return outcome;
  if (evt.defaultPrevented) {
    if (phase === "paint" && nativeEvent instanceof PointerEvent) {
      const pointer = nativeEvent;
      if (pointer.button === 0 || pointer.buttons === 1) {
        return "start-paint";
      }
    }
    return "handled";
  }
  return "default";
}
function createEventBackedInteractionDelegate(host) {
  return {
    onClick(coord, ev) {
      return dispatchInteraction(host, coord, "click", ev);
    },
    onPaintStep(coord, ev) {
      return dispatchInteraction(host, coord, "paint", ev);
    }
  };
}
var EVENT_NAME;
var init_interaction_delegate = __esm({
  "src/features/maps/rendering/interactions/interaction-delegate.ts"() {
    "use strict";
    EVENT_NAME = "hex:click";
  }
});

// src/features/maps/rendering/interactions/interaction-adapter.ts
function resolveMapFile(app, mapPath) {
  const abstract = app.vault.getAbstractFileByPath(mapPath);
  return abstract instanceof import_obsidian6.TFile ? abstract : null;
}
function createInteractionAdapter(config) {
  const { app, host, mapPath } = config;
  const defaultDelegate = createEventBackedInteractionDelegate(host);
  const delegateRef = { current: defaultDelegate };
  const handleDefaultClick = async (coord, _ev) => {
    const file = resolveMapFile(app, mapPath);
    if (!file) return;
    const tfile = await saveTile(app, file, coord, { terrain: "" });
    const leaf = getCenterLeaf(app);
    await leaf.openFile(tfile, { active: true });
  };
  const setDelegate = (delegate) => {
    delegateRef.current = delegate ?? defaultDelegate;
  };
  return {
    delegateRef,
    handleDefaultClick,
    setDelegate
  };
}
var import_obsidian6;
var init_interaction_adapter = __esm({
  "src/features/maps/rendering/interactions/interaction-adapter.ts"() {
    "use strict";
    import_obsidian6 = require("obsidian");
    init_layout();
    init_tile_repository();
    init_interaction_delegate();
  }
});

// src/features/maps/rendering/scene/bootstrap.ts
function computeBounds(tiles) {
  if (!tiles.length) return null;
  let minR = Infinity;
  let maxR = -Infinity;
  let minC = Infinity;
  let maxC = -Infinity;
  for (const tile of tiles) {
    const { r, c } = tile.coord;
    if (r < minR) minR = r;
    if (r > maxR) maxR = r;
    if (c < minC) minC = c;
    if (c > maxC) maxC = c;
  }
  return { minR, maxR, minC, maxC };
}
function buildFallback(bounds) {
  const minR = bounds ? bounds.minR : 0;
  const maxR = bounds ? bounds.maxR : DEFAULT_FALLBACK_SPAN;
  const minC = bounds ? bounds.minC : 0;
  const maxC = bounds ? bounds.maxC : DEFAULT_FALLBACK_SPAN;
  const coords = [];
  for (let r = minR; r <= maxR; r++) {
    for (let c = minC; c <= maxC; c++) {
      coords.push({ r, c });
    }
  }
  return coords;
}
async function loadTiles(app, mapPath) {
  const file = app.vault.getAbstractFileByPath(mapPath);
  if (!(file instanceof import_obsidian7.TFile)) {
    return [];
  }
  try {
    return await listTilesForMap(app, file);
  } catch {
    return [];
  }
}
async function bootstrapHexTiles(app, mapPath) {
  const tiles = await loadTiles(app, mapPath);
  const bounds = computeBounds(tiles);
  const base = {
    r: bounds ? bounds.minR : 0,
    c: bounds ? bounds.minC : 0
  };
  const initialCoords = tiles.length ? tiles.map((tile) => tile.coord) : buildFallback(bounds);
  return {
    tiles,
    base,
    initialCoords
  };
}
var import_obsidian7, DEFAULT_FALLBACK_SPAN;
var init_bootstrap = __esm({
  "src/features/maps/rendering/scene/bootstrap.ts"() {
    "use strict";
    import_obsidian7 = require("obsidian");
    init_tile_repository();
    DEFAULT_FALLBACK_SPAN = 2;
  }
});

// src/features/maps/rendering/scene/surface.ts
function detectContext(canvas, type2) {
  try {
    const ctx = canvas.getContext(type2);
    return ctx != null;
  } catch {
    return false;
  }
}
function selectRenderSurface(options = {}) {
  const { preferGpu = true } = options;
  const canvas = document.createElement("canvas");
  const webgl2 = preferGpu ? detectContext(canvas, "webgl2") : false;
  const webgl = preferGpu ? !webgl2 && detectContext(canvas, "webgl") : false;
  const canvas2d = detectContext(canvas, "2d");
  let preferred = "svg";
  if (preferGpu && (webgl2 || webgl)) {
    preferred = webgl2 ? "webgl2" : "webgl";
  } else if (canvas2d) {
    preferred = "canvas2d";
  }
  return {
    preferred,
    actual: "svg",
    capabilities: { webgl2, webgl, canvas2d }
  };
}
var init_surface = __esm({
  "src/features/maps/rendering/scene/surface.ts"() {
    "use strict";
  }
});

// src/features/maps/state/location-marker-store.ts
function getLocationMarkerStore(app, mapFile) {
  let storesByApp = markerRegistry.get(app);
  if (!storesByApp) {
    storesByApp = /* @__PURE__ */ new Map();
    markerRegistry.set(app, storesByApp);
  }
  const mapPath = (0, import_obsidian8.normalizePath)(mapFile.path);
  let store = storesByApp.get(mapPath);
  if (!store) {
    store = createLocationMarkerStore(mapPath);
    storesByApp.set(mapPath, store);
  }
  return store;
}
function createLocationMarkerStore(mapPath) {
  const storeName = `map-location-markers:${mapPath}`;
  const state = writable(createEmptyState2(mapPath), {
    name: storeName,
    debug: false
  });
  getStoreManager().register(storeName, state);
  const setMarkers = (markers) => {
    const nextEntries = /* @__PURE__ */ new Map();
    const seen = /* @__PURE__ */ new Set();
    for (const marker of markers) {
      if (!marker) continue;
      const coord = normalizeCoord2(marker.coord);
      if (!coord) continue;
      const locationName = normalizeString(marker.locationName);
      if (!locationName) continue;
      const key = keyFromCoord3(coord);
      if (seen.has(key)) continue;
      const displayIcon = marker.icon || LOCATION_TYPE_ICONS[marker.locationType] || "\u{1F4CD}";
      const entry = {
        ...marker,
        coord,
        locationName,
        key,
        displayIcon
      };
      nextEntries.set(key, entry);
      seen.add(key);
    }
    state.set({
      mapPath,
      loaded: true,
      entries: nextEntries,
      version: Date.now()
    });
  };
  const clear = () => {
    state.set(createEmptyState2(mapPath));
  };
  const get = (coord) => {
    const snapshot = state.get();
    const normalized = normalizeCoord2(coord);
    if (!normalized) return null;
    return snapshot.entries.get(keyFromCoord3(normalized)) ?? null;
  };
  const list = () => {
    const snapshot = state.get();
    return Array.from(snapshot.entries.values());
  };
  const getByLocationName = (name) => {
    const snapshot = state.get();
    const normalized = normalizeString(name);
    if (!normalized) return null;
    for (const entry of snapshot.entries.values()) {
      if (entry.locationName === normalized) {
        return entry;
      }
    }
    return null;
  };
  return {
    state,
    setMarkers,
    clear,
    get,
    list,
    getByLocationName
  };
}
function createEmptyState2(mapPath) {
  return {
    mapPath,
    loaded: false,
    entries: /* @__PURE__ */ new Map(),
    version: Date.now()
  };
}
function normalizeCoord2(coord) {
  if (!coord) return null;
  const r = Number(coord.r);
  const c = Number(coord.c);
  if (!Number.isInteger(r) || !Number.isInteger(c)) return null;
  return { r, c };
}
function normalizeString(str2) {
  return typeof str2 === "string" ? str2.trim() : "";
}
function keyFromCoord3(coord) {
  return `${coord.r}:${coord.c}`;
}
var import_obsidian8, LOCATION_TYPE_ICONS, markerRegistry;
var init_location_marker_store = __esm({
  "src/features/maps/state/location-marker-store.ts"() {
    "use strict";
    import_obsidian8 = require("obsidian");
    init_state();
    init_store_manager();
    LOCATION_TYPE_ICONS = {
      "Stadt": "\u{1F3D9}\uFE0F",
      "Dorf": "\u{1F3D8}\uFE0F",
      "Weiler": "\u{1F3E1}",
      "Geb\xE4ude": "\u{1F3E2}",
      "Dungeon": "\u2694\uFE0F",
      "Camp": "\u26FA",
      "Landmark": "\u{1F5FF}",
      "Ruine": "\u{1F3DA}\uFE0F",
      "Festung": "\u{1F3F0}"
    };
    markerRegistry = /* @__PURE__ */ new WeakMap();
  }
});

// src/features/maps/state/location-influence-store.ts
function getLocationInfluenceStore(app, mapFile, options = {}) {
  let storesByApp = influenceRegistry.get(app);
  if (!storesByApp) {
    storesByApp = /* @__PURE__ */ new Map();
    influenceRegistry.set(app, storesByApp);
  }
  const mapPath = (0, import_obsidian9.normalizePath)(mapFile.path);
  let store = storesByApp.get(mapPath);
  if (!store) {
    store = createLocationInfluenceStore(mapPath, options);
    storesByApp.set(mapPath, store);
  }
  return store;
}
function createLocationInfluenceStore(mapPath, options) {
  const storeName = `map-location-influence:${mapPath}`;
  const state = writable(createEmptyState3(mapPath), {
    name: storeName,
    debug: false
  });
  getStoreManager().register(storeName, state);
  const resolveColor = (ownerName, ownerType, palette) => {
    const normalized = `${ownerType}:${ownerName.trim()}`;
    if (!normalized) return palette.get("") ?? FALLBACK_COLOR3;
    const existing = palette.get(normalized);
    if (existing) return existing;
    const custom = options.resolveColor?.(ownerName, ownerType, palette);
    if (custom && typeof custom === "string") {
      const value = custom.trim() || FALLBACK_COLOR3;
      palette.set(normalized, value);
      return value;
    }
    const colors = options.palette ?? DEFAULT_INFLUENCE_COLORS;
    const hash = hashString(normalized);
    const color = colors[hash % colors.length];
    palette.set(normalized, color);
    return color;
  };
  const setAssignments = (assignments) => {
    const snapshot = state.get();
    const nextEntries = /* @__PURE__ */ new Map();
    const nextPalette = new Map(snapshot.palette);
    const seen = /* @__PURE__ */ new Set();
    for (const assignment of assignments) {
      if (!assignment) continue;
      const coord = normalizeCoord3(assignment.coord);
      if (!coord) continue;
      const locationName = normalizeString2(assignment.locationName);
      if (!locationName) continue;
      const key = keyFromCoord4(coord);
      if (seen.has(key)) continue;
      const overrideColor = normalizeColor2(assignment.color);
      const ownerType = assignment.ownerType || "none";
      const ownerName = assignment.ownerName || locationName;
      const color = overrideColor ?? resolveColor(ownerName, ownerType, nextPalette);
      if (overrideColor) {
        const paletteKey = `${ownerType}:${ownerName}`;
        nextPalette.set(paletteKey, color);
      }
      const entry = {
        ...assignment,
        coord,
        locationName,
        color,
        key
      };
      nextEntries.set(key, entry);
      seen.add(key);
    }
    state.set({
      mapPath,
      loaded: true,
      entries: nextEntries,
      palette: nextPalette,
      version: Date.now()
    });
  };
  const clear = () => {
    state.set(createEmptyState3(mapPath));
  };
  const get = (coord) => {
    const snapshot = state.get();
    const normalized = normalizeCoord3(coord);
    if (!normalized) return null;
    return snapshot.entries.get(keyFromCoord4(normalized)) ?? null;
  };
  const list = () => {
    const snapshot = state.get();
    return Array.from(snapshot.entries.values());
  };
  const getColorForOwner = (ownerName, ownerType) => {
    const snapshot = state.get();
    const paletteKey = `${ownerType}:${ownerName.trim()}`;
    const palette = new Map(snapshot.palette);
    const color = palette.get(paletteKey) ?? resolveColor(ownerName, ownerType, palette);
    if (!snapshot.palette.has(paletteKey)) {
      state.update((current) => {
        const nextPalette = new Map(current.palette);
        nextPalette.set(paletteKey, color);
        return {
          ...current,
          palette: nextPalette,
          version: Date.now()
        };
      });
    }
    return color;
  };
  return {
    state,
    setAssignments,
    clear,
    get,
    list,
    getColorForOwner
  };
}
function createEmptyState3(mapPath) {
  return {
    mapPath,
    loaded: false,
    entries: /* @__PURE__ */ new Map(),
    palette: /* @__PURE__ */ new Map(),
    version: Date.now()
  };
}
function normalizeCoord3(coord) {
  if (!coord) return null;
  const r = Number(coord.r);
  const c = Number(coord.c);
  if (!Number.isInteger(r) || !Number.isInteger(c)) return null;
  return { r, c };
}
function normalizeString2(str2) {
  return typeof str2 === "string" ? str2.trim() : "";
}
function keyFromCoord4(coord) {
  return `${coord.r}:${coord.c}`;
}
function normalizeColor2(color) {
  if (!color) return null;
  const trimmed = color.trim();
  if (!trimmed) return null;
  return trimmed;
}
function hashString(str2) {
  let hash = 0;
  for (let i = 0; i < str2.length; i++) {
    const char = str2.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return Math.abs(hash);
}
var import_obsidian9, FALLBACK_COLOR3, influenceRegistry, DEFAULT_INFLUENCE_COLORS;
var init_location_influence_store = __esm({
  "src/features/maps/state/location-influence-store.ts"() {
    "use strict";
    import_obsidian9 = require("obsidian");
    init_state();
    init_store_manager();
    FALLBACK_COLOR3 = "#9E9E9E";
    influenceRegistry = /* @__PURE__ */ new WeakMap();
    DEFAULT_INFLUENCE_COLORS = [
      "#FF6B6B",
      // Red
      "#4ECDC4",
      // Teal
      "#FFE66D",
      // Yellow
      "#A8E6CF",
      // Mint
      "#FFD3B6",
      // Peach
      "#FFAAA5",
      // Coral
      "#98D8C8",
      // Seafoam
      "#C7CEEA",
      // Lavender
      "#B8E0D2",
      // Sage
      "#EAC4D5"
      // Pink
    ];
  }
});

// src/features/maps/rendering/hex-render.ts
async function renderHexMap(app, host, mapFile, opts) {
  const radius = opts.radius;
  const padding = DEFAULT_PADDING;
  const mapPath = mapFile.path;
  const { tiles, base, initialCoords } = await bootstrapHexTiles(app, mapPath);
  const surface = selectRenderSurface();
  const scene = createHexScene({
    host,
    radius,
    padding,
    base,
    initialCoords
  });
  const camera = createCameraController(
    scene.svg,
    scene.contentG,
    scene.overlay,
    host,
    { ...CAMERA_OPTIONS }
  );
  const coordinates = createCoordinateTranslator({
    svg: scene.svg,
    contentG: scene.contentG,
    base,
    radius,
    padding
  });
  const interactionAdapter = createInteractionAdapter({ app, host, mapPath });
  const interactions = createInteractionController({
    svg: scene.svg,
    overlay: scene.overlay,
    toContentPoint: coordinates.toContentPoint,
    pointToCoord: coordinates.pointToCoord,
    delegateRef: interactionAdapter.delegateRef,
    onDefaultClick: (coord, ev) => interactionAdapter.handleDefaultClick(coord, ev)
  });
  for (const { coord, data } of tiles) {
    const color = TERRAIN_COLORS[data.terrain] ?? "transparent";
    scene.setFill(coord, color);
  }
  const legendHost = createLegendHost(host);
  const overlayStore = getFactionOverlayStore(app, mapFile);
  let overlayKeys = /* @__PURE__ */ new Set();
  const applyOverlay = (state) => {
    const entries = state.loaded ? Array.from(state.entries.values()) : [];
    const ensureCoords = entries.map((entry) => entry.coord);
    scene.ensurePolys(ensureCoords);
    const nextKeys = /* @__PURE__ */ new Set();
    for (const entry of entries) {
      const key = `${entry.coord.r},${entry.coord.c}`;
      nextKeys.add(key);
      scene.setOverlay(entry.coord, {
        color: entry.color,
        factionId: entry.factionId,
        factionName: entry.factionName ?? void 0,
        fillOpacity: OVERLAY_FILL_OPACITY,
        strokeWidth: OVERLAY_STROKE_WIDTH
      });
    }
    for (const key of overlayKeys) {
      if (nextKeys.has(key)) continue;
      const [r, c] = key.split(",").map(Number);
      scene.setOverlay({ r, c }, null);
    }
    overlayKeys = nextKeys;
    updateLegend(legendHost, entries);
  };
  const overlayUnsubscribe = overlayStore.state.subscribe(applyOverlay);
  applyOverlay(overlayStore.state.get());
  const influenceStore = getLocationInfluenceStore(app, mapFile);
  let influenceKeys = /* @__PURE__ */ new Set();
  const applyInfluence = (state) => {
    const entries = state.loaded ? Array.from(state.entries.values()) : [];
    const ensureCoords = entries.map((entry) => entry.coord);
    scene.ensurePolys(ensureCoords);
    const nextKeys = /* @__PURE__ */ new Set();
    for (const entry of entries) {
      const key = `${entry.coord.r},${entry.coord.c}`;
      nextKeys.add(key);
      scene.setOverlay(entry.coord, {
        color: entry.color,
        // Store location data in dataset for inspector access
        factionId: `location:${entry.locationName}`,
        factionName: `${entry.locationName} (${entry.strength}%)`,
        fillOpacity: INFLUENCE_FILL_OPACITY,
        strokeWidth: INFLUENCE_STROKE_WIDTH
      });
    }
    for (const key of influenceKeys) {
      if (nextKeys.has(key)) continue;
      const [r, c] = key.split(",").map(Number);
      const coord = { r, c };
      const hasFactionOverlay = overlayStore.get(coord);
      if (!hasFactionOverlay) {
        scene.setOverlay(coord, null);
      }
    }
    influenceKeys = nextKeys;
  };
  const influenceUnsubscribe = influenceStore.state.subscribe(applyInfluence);
  applyInfluence(influenceStore.state.get());
  const markerStore = getLocationMarkerStore(app, mapFile);
  const markerLayer = createMarkerLayer(scene.contentG, radius, base, padding);
  let markerKeys = /* @__PURE__ */ new Set();
  const applyMarkers = (state) => {
    const entries = state.loaded ? Array.from(state.entries.values()) : [];
    const ensureCoords = entries.map((entry) => entry.coord);
    scene.ensurePolys(ensureCoords);
    const nextKeys = /* @__PURE__ */ new Set();
    for (const entry of entries) {
      const key = `${entry.coord.r},${entry.coord.c}`;
      nextKeys.add(key);
      markerLayer.setMarker(entry.coord, entry.displayIcon, entry.locationName);
    }
    for (const key of markerKeys) {
      if (nextKeys.has(key)) continue;
      const [r, c] = key.split(",").map(Number);
      markerLayer.clearMarker({ r, c });
    }
    markerKeys = nextKeys;
  };
  const markerUnsubscribe = markerStore.state.subscribe(applyMarkers);
  applyMarkers(markerStore.state.get());
  const ensurePolys = (coords) => {
    if (!coords.length) return;
    scene.ensurePolys(coords);
  };
  const cleanup = () => {
    markerUnsubscribe();
    markerKeys.clear();
    influenceUnsubscribe();
    influenceKeys.clear();
    overlayUnsubscribe();
    overlayKeys.clear();
    legendHost.remove();
    if (host.dataset.hexMapPositionChanged === "1") {
      host.style.position = host.dataset.hexMapPrevPosition ?? "";
    }
    delete host.dataset.hexMapPrevPosition;
    delete host.dataset.hexMapPositionChanged;
    host.classList.remove("sm-hex-map-host");
  };
  return {
    svg: scene.svg,
    contentG: scene.contentG,
    overlay: scene.overlay,
    polyByCoord: scene.polyByCoord,
    surface,
    setFill: (coord, color) => scene.setFill(coord, color),
    ensurePolys,
    setInteractionDelegate: (delegate) => {
      interactionAdapter.setDelegate(delegate);
    },
    destroy: () => {
      cleanup();
      interactions.destroy();
      camera.destroy();
      scene.destroy();
    }
  };
}
function createLegendHost(host) {
  var _a;
  host.classList.add("sm-hex-map-host");
  if (getComputedStyle(host).position === "static") {
    (_a = host.dataset).hexMapPrevPosition ?? (_a.hexMapPrevPosition = host.style.position ?? "");
    host.dataset.hexMapPositionChanged = "1";
    host.style.position = "relative";
  } else {
    host.dataset.hexMapPositionChanged = "0";
  }
  const legend = host.ownerDocument.createElement("div");
  legend.className = "sm-map-legend is-empty";
  host.appendChild(legend);
  return legend;
}
function updateLegend(container, entries) {
  container.empty();
  if (!entries.length) {
    container.classList.add("is-empty");
    return;
  }
  container.classList.remove("is-empty");
  const aggregate = /* @__PURE__ */ new Map();
  for (const entry of entries) {
    const id = entry.factionId;
    const name = entry.factionName && entry.factionName.trim().length > 0 ? entry.factionName : id;
    const color = entry.color;
    const current = aggregate.get(id);
    if (current) {
      current.count += 1;
    } else {
      aggregate.set(id, { id, name, color, count: 1 });
    }
  }
  const items = Array.from(aggregate.values()).sort((a, b) => {
    if (b.count !== a.count) return b.count - a.count;
    return a.name.localeCompare(b.name);
  });
  for (const item of items) {
    const row = container.createDiv({ cls: "sm-map-legend__item" });
    row.createDiv({ cls: "sm-map-legend__swatch" }).style.backgroundColor = item.color;
    row.createDiv({ cls: "sm-map-legend__label", text: item.name });
    row.createDiv({ cls: "sm-map-legend__meta", text: `${item.count}` });
  }
}
function createMarkerLayer(contentG, radius, base, padding) {
  const markerGroup = document.createElementNS(SVG_NS2, "g");
  markerGroup.setAttribute("class", "location-markers");
  contentG.appendChild(markerGroup);
  const markerByCoord = /* @__PURE__ */ new Map();
  const hexW = Math.sqrt(3) * radius;
  const hexH = 2 * radius;
  const hStep = hexW;
  const vStep = 0.75 * hexH;
  const centerOf = (coord) => {
    const { r, c } = coord;
    const cx = padding + (c - base.c) * hStep + (r % 2 ? hexW / 2 : 0);
    const cy = padding + (r - base.r) * vStep + hexH / 2;
    return { cx, cy };
  };
  const keyOf4 = (coord) => `${coord.r},${coord.c}`;
  const setMarker = (coord, icon, tooltip) => {
    const key = keyOf4(coord);
    let marker = markerByCoord.get(key);
    if (!marker) {
      marker = document.createElementNS(SVG_NS2, "text");
      marker.setAttribute("class", "location-marker");
      marker.setAttribute("text-anchor", "middle");
      marker.setAttribute("pointer-events", "none");
      marker.setAttribute("font-size", MARKER_FONT_SIZE);
      marker.setAttribute("data-coord", key);
      markerGroup.appendChild(marker);
      markerByCoord.set(key, marker);
    }
    const { cx, cy } = centerOf(coord);
    marker.setAttribute("x", String(cx));
    marker.setAttribute("y", String(cy - 10));
    marker.textContent = icon;
    if (tooltip) {
      const title = document.createElementNS(SVG_NS2, "title");
      title.textContent = tooltip;
      marker.appendChild(title);
    }
  };
  const clearMarker = (coord) => {
    const key = keyOf4(coord);
    const marker = markerByCoord.get(key);
    if (marker) {
      marker.remove();
      markerByCoord.delete(key);
    }
  };
  return {
    setMarker,
    clearMarker
  };
}
var OVERLAY_STROKE_WIDTH, OVERLAY_FILL_OPACITY, INFLUENCE_FILL_OPACITY, INFLUENCE_STROKE_WIDTH, MARKER_FONT_SIZE, SVG_NS2, DEFAULT_PADDING, CAMERA_OPTIONS;
var init_hex_render = __esm({
  "src/features/maps/rendering/hex-render.ts"() {
    "use strict";
    init_terrain();
    init_scene();
    init_camera_controller();
    init_interactions();
    init_coordinates();
    init_interaction_adapter();
    init_bootstrap();
    init_surface();
    init_interaction_delegate();
    init_faction_overlay_store();
    init_location_marker_store();
    init_location_influence_store();
    OVERLAY_STROKE_WIDTH = "3";
    OVERLAY_FILL_OPACITY = "0.55";
    INFLUENCE_FILL_OPACITY = "0.35";
    INFLUENCE_STROKE_WIDTH = "2";
    MARKER_FONT_SIZE = "24px";
    SVG_NS2 = "http://www.w3.org/2000/svg";
    DEFAULT_PADDING = 12;
    CAMERA_OPTIONS = { minScale: 0.15, maxScale: 16, zoomSpeed: 1.01 };
  }
});

// src/features/maps/state/region-store.ts
async function ensureRegionsFile(app) {
  const path = (0, import_obsidian10.normalizePath)(REGIONS_FILE);
  const existing = app.vault.getAbstractFileByPath(path);
  if (existing instanceof import_obsidian10.TFile) {
    return existing;
  }
  const dir = path.split("/").slice(0, -1).join("/");
  if (dir) {
    await app.vault.createFolder(dir).catch(() => {
    });
  }
  const body = [
    "---",
    "smList: true",
    "---",
    "# Regions",
    "",
    "```regions",
    "# Name: Terrain",
    "# Beispiel:",
    "# Saltmarsh: K\xFCste",
    "```",
    ""
  ].join("\n");
  return await app.vault.create(path, body);
}
function parseRegionsBlock(md) {
  const match = md.match(BLOCK_RE);
  if (!match) return [];
  const list = [];
  for (const raw of match[1].split(/\r?\n/)) {
    const line = raw.trim();
    if (!line || line.startsWith("#")) continue;
    const parsed = line.match(/^("?)(.*?)\1\s*:\s*(.*)$/);
    if (!parsed) continue;
    const name = (parsed[2] || "").trim();
    const rest = (parsed[3] || "").trim();
    let terrain = rest;
    let encounterOdds;
    const encounterMatch = rest.match(/,\s*encounter\s*:\s*([^,]+)\s*$/i);
    if (encounterMatch) {
      terrain = rest.slice(0, encounterMatch.index).trim();
      const spec = encounterMatch[1].trim();
      const fraction = spec.match(/^1\s*\/\s*(\d+)$/);
      if (fraction) {
        encounterOdds = parseInt(fraction[1], 10) || void 0;
      } else {
        const numeric = parseInt(spec, 10);
        if (Number.isFinite(numeric) && numeric > 0) {
          encounterOdds = numeric;
        }
      }
    }
    list.push({ name, terrain, encounterOdds });
  }
  return list;
}
function stringifyRegionsBlock(list) {
  const lines = list.map((region) => {
    const base = `${region.name}: ${region.terrain || ""}`;
    const odds = region.encounterOdds;
    return odds && odds > 0 ? `${base}, encounter: 1/${odds}` : base;
  });
  return ["```regions", ...lines, "```"].join("\n");
}
async function readRegionsFromDisk(app) {
  const file = await ensureRegionsFile(app);
  const content = await app.vault.read(file);
  return parseRegionsBlock(content);
}
async function writeRegionsToDisk(app, list) {
  const file = await ensureRegionsFile(app);
  const content = await app.vault.read(file);
  const block = stringifyRegionsBlock(list);
  const updated = content.match(BLOCK_RE) ? content.replace(BLOCK_RE, block) : `${content}

${block}
`;
  await app.vault.modify(file, updated);
}
function createInitialState() {
  return {
    loaded: false,
    list: [],
    version: 0
  };
}
function triggerRegionEvent(app) {
  app.workspace.trigger?.("salt:regions-updated");
}
function createRegionStore(app, options) {
  const base = writable(createInitialState(), {
    name: "map-regions",
    debug: options?.debug
  });
  let dirty = false;
  let loadPromise = null;
  const persistent2 = {
    subscribe: base.subscribe,
    get: base.get,
    set: (value) => {
      base.set(value);
      dirty = true;
    },
    update: (updater) => {
      base.update((current) => {
        const next = updater(current);
        dirty = true;
        return next;
      });
    },
    load: async () => {
      const regions = await readRegionsFromDisk(app);
      base.set({
        loaded: true,
        list: regions,
        version: Date.now()
      });
      dirty = false;
      triggerRegionEvent(app);
    },
    save: async () => {
      const snapshot = base.get();
      if (!snapshot.loaded) return;
      await writeRegionsToDisk(app, snapshot.list);
      dirty = false;
    },
    isDirty: () => dirty,
    getStorageKey: () => (0, import_obsidian10.normalizePath)(REGIONS_FILE)
  };
  getStoreManager().register("map-regions", persistent2);
  const ensureLoaded = async () => {
    const snapshot = persistent2.get();
    if (snapshot.loaded && loadPromise === null) {
      return;
    }
    if (!loadPromise) {
      loadPromise = persistent2.load().finally(() => {
        loadPromise = null;
      });
    }
    await loadPromise;
  };
  const refresh = async () => {
    loadPromise = persistent2.load().finally(() => {
      loadPromise = null;
    });
    await loadPromise;
  };
  const getRegions = async () => {
    await ensureLoaded();
    return persistent2.get().list;
  };
  const saveRegions3 = async (list) => {
    await ensureLoaded();
    persistent2.update(() => ({
      loaded: true,
      list: [...list],
      version: Date.now()
    }));
    await persistent2.save();
    triggerRegionEvent(app);
  };
  const watch = (onChange) => {
    const targetPath = (0, import_obsidian10.normalizePath)(REGIONS_FILE);
    const update = async (reason) => {
      try {
        if (reason === "delete") {
          logger2.warn(
            "Regions store detected deletion; attempting automatic recreation."
          );
          await ensureRegionsFile(app);
          new import_obsidian10.Notice("Regions.md wurde neu erstellt.");
        }
        await refresh();
        await onChange?.();
        triggerRegionEvent(app);
      } catch (error) {
        logger2.error(
          `[salt-marcher] Regions watcher failed after ${reason} event`,
          error
        );
      }
    };
    const maybeUpdate = (reason, file) => {
      if (!(file instanceof import_obsidian10.TFile)) return;
      if ((0, import_obsidian10.normalizePath)(file.path) !== targetPath) return;
      void update(reason);
    };
    const refs = ["modify", "delete"].map(
      (event) => app.vault.on(event, (file) => maybeUpdate(event, file))
    );
    let disposed = false;
    return () => {
      if (disposed) return;
      disposed = true;
      for (const ref of refs) {
        app.vault.offref(ref);
      }
    };
  };
  return {
    state: persistent2,
    getRegions,
    saveRegions: saveRegions3,
    refresh,
    watch
  };
}
function getRegionStore(app, options) {
  let store = storeRegistry.get(app);
  if (!store) {
    store = createRegionStore(app, options);
    storeRegistry.set(app, store);
  }
  return store;
}
async function loadRegions(app) {
  const store = getRegionStore(app);
  return await store.getRegions();
}
async function saveRegions(app, list) {
  const store = getRegionStore(app);
  await store.saveRegions(list);
}
function watchRegions(app, onChange) {
  const store = getRegionStore(app);
  return store.watch(onChange);
}
function resetRegionStore(app) {
  const store = storeRegistry.get(app);
  if (!store) return;
  store.state.set(createInitialState());
  storeRegistry.delete(app);
}
var import_obsidian10, REGIONS_FILE, BLOCK_RE, storeRegistry;
var init_region_store = __esm({
  "src/features/maps/state/region-store.ts"() {
    "use strict";
    import_obsidian10 = require("obsidian");
    init_state();
    init_store_manager();
    init_plugin_logger();
    REGIONS_FILE = "SaltMarcher/Regions.md";
    BLOCK_RE = /```regions\s*([\s\S]*?)```/i;
    storeRegistry = /* @__PURE__ */ new WeakMap();
  }
});

// src/features/maps/data/map-store-registry.ts
function getRegistry(app) {
  let set2 = MAP_STORE_REGISTRY.get(app);
  if (!set2) {
    set2 = /* @__PURE__ */ new Set();
    MAP_STORE_REGISTRY.set(app, set2);
  }
  return set2;
}
function registerMapStores(app, mapFile) {
  getRegistry(app).add(mapFile.path);
}
function unregisterMapStores(app, mapFile) {
  const set2 = MAP_STORE_REGISTRY.get(app);
  if (set2) {
    set2.delete(mapFile.path);
  }
  resetTileStore(app, mapFile);
  resetRegionStore(app);
  resetFactionOverlayStore(app, mapFile);
}
var MAP_STORE_REGISTRY;
var init_map_store_registry = __esm({
  "src/features/maps/data/map-store-registry.ts"() {
    "use strict";
    init_faction_overlay_store();
    init_region_store();
    init_tile_repository();
    MAP_STORE_REGISTRY = /* @__PURE__ */ new WeakMap();
  }
});

// src/features/maps/data/map-repository.ts
async function createHexMapFile(app, rawName, opts = { folder: "Hexes", folderPrefix: "Hex", radius: 42 }) {
  const name = sanitizeFileName(rawName) || "Neue Hex Map";
  const content = buildHexMapMarkdown(name, opts);
  const mapsFolder = "SaltMarcher/Maps";
  await app.vault.createFolder(mapsFolder).catch(() => {
  });
  const path = await ensureUniquePath(app, `${mapsFolder}/${name}.md`);
  const file = await app.vault.create(path, content);
  await initTilesForNewMap(app, file);
  registerMapStores(app, file);
  return file;
}
function buildHexMapMarkdown(name, opts) {
  const folder = (opts.folder ?? "Hexes").toString();
  const folderPrefix = (opts.folderPrefix ?? opts.prefix ?? "Hex").toString();
  const radius = typeof opts.radius === "number" ? opts.radius : 42;
  return [
    "---",
    "smMap: true",
    "---",
    `# ${name}`,
    "",
    "```hex3x3",
    `folder: ${folder}`,
    `folderPrefix: ${folderPrefix}`,
    // new: evaluated by tile-repository
    `prefix: ${folderPrefix}`,
    // legacy: kept for older parsers
    `radius: ${radius}`,
    "```",
    ""
  ].join("\n");
}
function sanitizeFileName(input) {
  return input.trim().replace(/[\\/:*?"<>|]/g, "-").replace(/\s+/g, " ").slice(0, 120);
}
async function ensureUniquePath(app, basePath) {
  if (!app.vault.getAbstractFileByPath(basePath)) return basePath;
  const dot = basePath.lastIndexOf(".");
  const stem = dot === -1 ? basePath : basePath.slice(0, dot);
  const ext = dot === -1 ? "" : basePath.slice(dot);
  for (let i = 2; i < 9999; i++) {
    const candidate = `${stem} (${i})${ext}`;
    if (!app.vault.getAbstractFileByPath(candidate)) return candidate;
  }
  return `${stem}-${Date.now()}${ext}`;
}
async function deleteMapAndTiles(app, mapFile) {
  const tiles = await listTilesForMap(app, mapFile);
  for (const t of tiles) {
    try {
      await app.vault.delete(t.file);
    } catch (e) {
      logger2.warn("Delete tile failed:", t.file.path, e);
    }
  }
  try {
    await app.vault.delete(mapFile);
  } catch (e) {
    logger2.warn("Delete map failed:", mapFile.path, e);
  }
  unregisterMapStores(app, mapFile);
}
var init_map_repository = __esm({
  "src/features/maps/data/map-repository.ts"() {
    "use strict";
    init_tile_repository();
    init_map_store_registry();
    init_plugin_logger();
  }
});

// src/ui/maps/workflows/map-workflows.ts
function applyMapButtonStyle(button) {
  Object.assign(button.style, {
    display: "flex",
    alignItems: "center",
    gap: "0.4rem",
    padding: "6px 10px",
    cursor: "pointer"
  });
}
async function promptMapSelection(app, onSelect, options) {
  const files = await getAllMapFiles(app);
  if (!files.length) {
    new import_obsidian11.Notice(options?.emptyMessage ?? "No maps available.");
    return;
  }
  new MapSelectModal(app, files, async (file) => {
    await onSelect(file);
  }).open();
}
function promptCreateMap(app, onCreate, options) {
  new NameInputModal(app, async (name) => {
    const file = await createHexMapFile(app, name);
    new import_obsidian11.Notice(options?.successMessage ?? "Map created.");
    await onCreate(file);
  }).open();
}
var import_obsidian11;
var init_map_workflows = __esm({
  "src/ui/maps/workflows/map-workflows.ts"() {
    "use strict";
    import_obsidian11 = require("obsidian");
    init_map_repository();
    init_map_list();
    init_options();
    init_hex_render();
    init_modals();
  }
});

// src/ui/components/search-dropdown.ts
function enhanceSelectToSearch(select, placeholder = "Search\u2026") {
  if (!select || select._smEnhanced) return;
  const wrap = document.createElement("div");
  wrap.className = "sm-sd";
  const input = document.createElement("input");
  input.type = "text";
  input.placeholder = placeholder;
  input.className = "sm-sd__input";
  const menu = document.createElement("div");
  menu.className = "sm-sd__menu";
  const parent = select.parentElement;
  parent.insertBefore(wrap, select);
  wrap.appendChild(input);
  wrap.appendChild(menu);
  select.style.display = "none";
  try {
    const rect = select.getBoundingClientRect();
    if (rect && rect.width) wrap.style.width = rect.width + "px";
  } catch {
  }
  let items;
  let active = -1;
  const readOptions2 = () => {
    items = Array.from(select.options).map((opt) => ({ label: opt.text, value: opt.value }));
  };
  const openMenu = () => {
    wrap.classList.add("is-open");
  };
  const closeMenu = () => {
    wrap.classList.remove("is-open");
    active = -1;
  };
  const render = (q = "") => {
    readOptions2();
    if (q === "__NOOPEN__") {
      menu.innerHTML = "";
      closeMenu();
      return;
    }
    const qq = q.toLowerCase();
    const matches = items.filter((it) => !qq || it.label.toLowerCase().includes(qq)).slice(0, 50);
    menu.innerHTML = "";
    matches.forEach((it, idx) => {
      const el = document.createElement("div");
      el.className = "sm-sd__item";
      el.textContent = it.label;
      it.el = el;
      el.onclick = () => {
        select.value = it.value;
        select.dispatchEvent(new Event("change"));
        input.value = it.label;
        closeMenu();
      };
      menu.appendChild(el);
    });
    if (matches.length) openMenu();
    else closeMenu();
  };
  input.addEventListener("focus", () => {
    input.select();
    render("");
  });
  input.addEventListener("input", () => render(input.value));
  input.addEventListener("keydown", (ev) => {
    if (!wrap.classList.contains("is-open")) return;
    const options = Array.from(menu.children);
    if (ev.key === "ArrowDown") {
      active = Math.min(options.length - 1, active + 1);
      highlight(options);
      ev.preventDefault();
    } else if (ev.key === "ArrowUp") {
      active = Math.max(0, active - 1);
      highlight(options);
      ev.preventDefault();
    } else if (ev.key === "Enter") {
      if (options[active]) {
        options[active].click();
        ev.preventDefault();
      }
    } else if (ev.key === "Escape") {
      closeMenu();
    }
  });
  const highlight = (options) => {
    options.forEach((el2, i) => el2.classList.toggle("is-active", i === active));
    const el = options[active];
    if (el) el.scrollIntoView({ block: "nearest" });
  };
  input.addEventListener("blur", () => {
    setTimeout(closeMenu, 120);
  });
  select._smEnhanced = true;
  select._smSearchInput = input;
}
var init_search_dropdown = __esm({
  "src/ui/components/search-dropdown.ts"() {
    "use strict";
  }
});

// src/workmodes/cartographer/editor/editor-telemetry.ts
function reportEditorToolIssue(payload) {
  const { stage, error } = payload;
  const toolId = payload.toolId ?? "unknown";
  const logPrefix = `[cartographer:editor] tool(${toolId}) stage(${stage}) failed`;
  logger2.error(logPrefix, error);
  const messageFactory = TOOL_STAGE_MESSAGES[stage];
  const userMessage = messageFactory(toolId);
  const dedupeKey = `${stage}:${toolId}`;
  if (!noticedIssues.has(dedupeKey)) {
    noticedIssues.add(dedupeKey);
    new import_obsidian15.Notice(userMessage);
  }
  return userMessage;
}
var import_obsidian15, noticedIssues, TOOL_STAGE_MESSAGES;
var init_editor_telemetry = __esm({
  "src/workmodes/cartographer/editor/editor-telemetry.ts"() {
    "use strict";
    import_obsidian15 = require("obsidian");
    init_plugin_logger();
    noticedIssues = /* @__PURE__ */ new Set();
    TOOL_STAGE_MESSAGES = {
      resolve: () => "No editor tools are available right now. Please ensure at least one tool module loads correctly.",
      "mount-panel": (toolId) => `Failed to mount the panel for "${toolId}". Please check the developer console.`,
      activate: (toolId) => `The tool "${toolId}" could not be activated. Please check the developer console.`,
      render: (toolId) => `The tool "${toolId}" failed to react to the rendered map. Please check the developer console.`,
      deactivate: (toolId) => `The tool "${toolId}" could not be deactivated cleanly. Please check the developer console.`,
      cleanup: (toolId) => `The tool "${toolId}" failed to clean up its panel. Please check the developer console.`,
      operation: (toolId) => `Applying changes with "${toolId}" failed. Please check the developer console.`
    };
  }
});

// src/workmodes/cartographer/editor/tools/brush-circle.ts
function attachBrushCircle(handles, opts) {
  const { svg, contentG, overlay } = handles;
  const R = opts.hexRadiusPx;
  const vStep = 1.5 * R;
  const toPx = (d) => R + Math.max(0, d) * vStep;
  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle.setAttribute("cx", "0");
  circle.setAttribute("cy", "0");
  circle.setAttribute("r", String(toPx(opts.initialRadius)));
  circle.setAttribute("fill", "none");
  circle.setAttribute("stroke", "var(--interactive-accent)");
  circle.setAttribute("stroke-width", "2");
  circle.setAttribute("pointer-events", "none");
  circle.style.opacity = "0.6";
  contentG.appendChild(circle);
  const svgPt = svg.createSVGPoint();
  let lastEvt = null;
  let raf = 0;
  function toContent() {
    const m = contentG.getScreenCTM();
    if (!m) return null;
    return svgPt.matrixTransform(m.inverse());
  }
  function bringToFront() {
    contentG.appendChild(circle);
  }
  function tick() {
    raf = 0;
    if (!lastEvt) return;
    svgPt.x = lastEvt.clientX;
    svgPt.y = lastEvt.clientY;
    const pt = toContent();
    if (!pt) return;
    circle.setAttribute("cx", String(pt.x));
    circle.setAttribute("cy", String(pt.y));
    bringToFront();
  }
  function onPointerMove(ev) {
    lastEvt = ev;
    if (!raf) raf = requestAnimationFrame(tick);
  }
  function onPointerEnter() {
    circle.style.opacity = "0.6";
  }
  function onPointerLeave() {
    circle.style.opacity = "0";
  }
  svg.addEventListener("pointermove", onPointerMove, { passive: true });
  svg.addEventListener("pointerenter", onPointerEnter, { passive: true });
  svg.addEventListener("pointerleave", onPointerLeave, { passive: true });
  function updateRadius(hexDist) {
    circle.setAttribute("r", String(toPx(hexDist)));
    bringToFront();
  }
  function show() {
    circle.style.display = "";
    circle.style.opacity = "0.6";
    bringToFront();
  }
  function hide() {
    circle.style.opacity = "0";
  }
  function destroy() {
    svg.removeEventListener("pointermove", onPointerMove);
    svg.removeEventListener("pointerenter", onPointerEnter);
    svg.removeEventListener("pointerleave", onPointerLeave);
    if (raf) cancelAnimationFrame(raf);
    circle.remove();
  }
  return { updateRadius, show, hide, destroy };
}
var init_brush_circle = __esm({
  "src/workmodes/cartographer/editor/tools/brush-circle.ts"() {
    "use strict";
  }
});

// src/workmodes/cartographer/editor/tools/terrain-brush/brush-core.ts
async function applyBrush(app, mapFile, center, opts, handles, context) {
  const mode = opts.mode ?? "paint";
  const radius = Math.max(0, opts.radius | 0);
  const targets = /* @__PURE__ */ new Map();
  for (const coord of coordsInRadius(center, radius)) {
    targets.set(`${coord.r},${coord.c}`, coord);
  }
  const applied = [];
  const tool = context?.tool ?? null;
  const toolName = context?.toolName ?? "brush";
  const abortSignal = tool?.getAbortSignal?.() ?? null;
  const throwIfAborted = () => {
    if (!abortSignal) return;
    if (abortSignal.aborted) {
      throw createAbortError();
    }
  };
  const getFillSnapshot = (coord) => {
    const key = `${coord.r},${coord.c}`;
    const poly = handles.polyByCoord.get(key);
    if (!poly) return "transparent";
    const styleFill = poly.style?.fill;
    const attrFill = poly.getAttribute("fill");
    const value = styleFill ?? attrFill;
    return value && value.trim().length > 0 ? value : "transparent";
  };
  try {
    throwIfAborted();
    for (const coord of targets.values()) {
      throwIfAborted();
      const key = `${coord.r},${coord.c}`;
      const previousFill = getFillSnapshot(coord);
      const previousData = await loadTile(app, mapFile, coord).catch((error) => {
        logger2.error(`[terrain-brush] failed to load tile ${key} before applying brush`, error);
        return null;
      });
      throwIfAborted();
      if (mode === "erase") {
        await deleteTile(app, mapFile, coord);
        handles.setFill(coord, "transparent");
        applied.push({
          coord,
          rollback: async () => {
            if (!previousData) return;
            await saveTile(app, mapFile, coord, previousData);
          },
          restoreFill: () => {
            handles.setFill(coord, previousFill);
          }
        });
        continue;
      }
      const terrain = opts.terrain ?? "";
      const region = opts.region ?? "";
      const payload = { terrain, region };
      if (opts.faction !== void 0) {
        payload.faction = opts.faction;
      } else if (previousData?.faction) {
        payload.faction = previousData.faction;
      }
      await saveTile(app, mapFile, coord, payload);
      const color = TERRAIN_COLORS[terrain] ?? "transparent";
      handles.setFill(coord, color);
      applied.push({
        coord,
        rollback: async () => {
          if (!previousData) {
            await deleteTile(app, mapFile, coord);
            return;
          }
          await saveTile(app, mapFile, coord, previousData);
        },
        restoreFill: () => {
          handles.setFill(coord, previousFill);
        }
      });
      throwIfAborted();
    }
  } catch (error) {
    const aborted = isAbortError(error);
    if (!aborted) {
      logger2.error("[terrain-brush] applyBrush failed", error);
    }
    for (const step of applied.reverse()) {
      try {
        step.restoreFill();
      } catch (restoreErr) {
        logger2.error("[terrain-brush] failed to restore hex fill", restoreErr);
      }
      try {
        await step.rollback();
      } catch (rollbackErr) {
        logger2.error("[terrain-brush] failed to rollback tile changes", rollbackErr);
      }
    }
    if (!aborted) {
      const message = reportEditorToolIssue({
        stage: "operation",
        toolId: toolName ?? "brush",
        error
      });
      if (typeof error === "object" && error) {
        error.__smToolMessage = message;
      }
      try {
        tool?.setStatus?.(message);
      } catch (statusErr) {
        logger2.error("[terrain-brush] failed to publish tool status", statusErr);
      }
      throw error;
    }
  }
}
var oddRToAxial, axialDistance, hexDistanceOddR, coordsInRadius, ABORT_ERROR_NAME, createAbortError, isAbortError;
var init_brush_core = __esm({
  "src/workmodes/cartographer/editor/tools/terrain-brush/brush-core.ts"() {
    "use strict";
    init_tile_repository();
    init_terrain();
    init_editor_telemetry();
    init_plugin_logger();
    oddRToAxial = (rc) => {
      const q = rc.c - (rc.r - (rc.r & 1) >> 1);
      return { q, r: rc.r };
    };
    axialDistance = (a, b) => {
      const dq = Math.abs(a.q - b.q);
      const dr = Math.abs(a.r - b.r);
      const ds = Math.abs(-a.q - a.r - (-b.q - b.r));
      return Math.max(dq, dr, ds);
    };
    hexDistanceOddR = (a, b) => {
      return axialDistance(oddRToAxial(a), oddRToAxial(b));
    };
    coordsInRadius = (center, radius) => {
      const out = [];
      for (let dr = -radius; dr <= radius; dr++) {
        for (let dc = -radius; dc <= radius; dc++) {
          const r = center.r + dr;
          const c = center.c + dc + (center.r & 1 ? Math.floor((dr + 1) / 2) : Math.floor(dr / 2));
          if (hexDistanceOddR(center, { r, c }) <= radius) {
            out.push({ r, c });
          }
        }
      }
      out.sort((A, B) => {
        const da = hexDistanceOddR(center, A);
        const db = hexDistanceOddR(center, B);
        if (da !== db) return da - db;
        if (A.r !== B.r) return A.r - B.r;
        return A.c - B.c;
      });
      return out;
    };
    ABORT_ERROR_NAME = "AbortError";
    createAbortError = () => {
      if (typeof DOMException === "function") {
        return new DOMException("Terrain brush application aborted", ABORT_ERROR_NAME);
      }
      const error = new Error("Terrain brush application aborted");
      error.name = ABORT_ERROR_NAME;
      return error;
    };
    isAbortError = (error) => {
      if (!error) return false;
      if (typeof DOMException === "function" && error instanceof DOMException) {
        return error.name === ABORT_ERROR_NAME;
      }
      return error instanceof Error && error.name === ABORT_ERROR_NAME;
    };
  }
});

// src/features/maps/data/region-repository.ts
var region_repository_exports = {};
__export(region_repository_exports, {
  REGIONS_FILE: () => REGIONS_FILE,
  ensureRegionsFile: () => ensureRegionsFile,
  loadRegions: () => loadRegions2,
  parseRegionsBlock: () => parseRegionsBlock,
  saveRegions: () => saveRegions2,
  stringifyRegionsBlock: () => stringifyRegionsBlock,
  watchRegions: () => watchRegions2
});
async function loadRegions2(app) {
  return await loadRegions(app);
}
async function saveRegions2(app, list) {
  await saveRegions(app, list);
}
function watchRegions2(app, onChange) {
  return watchRegions(app, onChange);
}
var init_region_repository = __esm({
  "src/features/maps/data/region-repository.ts"() {
    "use strict";
    init_region_store();
  }
});

// src/features/data-manager/browse/frontmatter-utils.ts
async function readFrontmatter(app, file, options = {}) {
  const { useCache = true } = options;
  if (useCache) {
    const cached = app.metadataCache.getFileCache(file)?.frontmatter;
    if (cached && typeof cached === "object") {
      return cached;
    }
  }
  return await parseFrontmatterFromContent(app, file);
}
async function parseFrontmatterFromContent(app, file) {
  const content = await app.vault.read(file);
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match) return {};
  const lines = match[1].split(/\r?\n/);
  const data = {};
  for (const line of lines) {
    const idx = line.indexOf(":");
    if (idx === -1) continue;
    const rawKey = line.slice(0, idx).trim();
    if (!rawKey) continue;
    let rawValue = line.slice(idx + 1).trim();
    if (!rawValue) {
      data[rawKey] = rawValue;
      continue;
    }
    if (/^".*"$/.test(rawValue)) {
      rawValue = rawValue.slice(1, -1);
    }
    const num = Number(rawValue);
    data[rawKey] = Number.isFinite(num) && rawValue === String(num) ? num : rawValue;
  }
  return data;
}
var init_frontmatter_utils = __esm({
  "src/features/data-manager/browse/frontmatter-utils.ts"() {
    "use strict";
  }
});

// Presets/lib/entity-registry.ts
var ENTITY_REGISTRY;
var init_entity_registry = __esm({
  "Presets/lib/entity-registry.ts"() {
    "use strict";
    ENTITY_REGISTRY = {
      creatures: {
        id: "creatures",
        displayName: "Creatures",
        directory: "SaltMarcher/Creatures",
        defaultBaseName: "Creature",
        singular: "creature",
        plural: "creatures"
      },
      spells: {
        id: "spells",
        displayName: "Spells",
        directory: "SaltMarcher/Spells",
        defaultBaseName: "Spell",
        singular: "spell",
        plural: "spells"
      },
      items: {
        id: "items",
        displayName: "Items",
        directory: "SaltMarcher/Items",
        defaultBaseName: "Item",
        singular: "item",
        plural: "items"
      },
      equipment: {
        id: "equipment",
        displayName: "Equipment",
        directory: "SaltMarcher/Equipment",
        defaultBaseName: "Equipment",
        singular: "equipment",
        plural: "equipment"
      },
      terrains: {
        id: "terrains",
        displayName: "Terrains",
        directory: "SaltMarcher/Terrains",
        defaultBaseName: "Terrain",
        singular: "terrain",
        plural: "terrains"
      },
      regions: {
        id: "regions",
        displayName: "Regions",
        directory: "SaltMarcher/Regions",
        defaultBaseName: "Region",
        singular: "region",
        plural: "regions"
      },
      factions: {
        id: "factions",
        displayName: "Factions",
        directory: "SaltMarcher/Factions",
        defaultBaseName: "Faction",
        singular: "faction",
        plural: "factions"
      },
      calendars: {
        id: "calendars",
        displayName: "Calendars",
        directory: "SaltMarcher/Calendars",
        defaultBaseName: "Calendar",
        singular: "calendar",
        plural: "calendars"
      },
      playlists: {
        id: "playlists",
        displayName: "Playlists",
        directory: "SaltMarcher/Playlists",
        defaultBaseName: "Playlist",
        singular: "playlist",
        plural: "playlists"
      }
    };
  }
});

// Presets/lib/vault-preset-loader.ts
async function listVaultPresets(app, entityType) {
  const entityConfig = ENTITY_REGISTRY[entityType];
  if (!entityConfig) {
    logger2.warn(`[VaultPresetLoader] Unknown entity type: ${entityType}`);
    return [];
  }
  const folder = app.vault.getAbstractFileByPath(entityConfig.directory);
  if (!folder || !(folder instanceof import_obsidian16.TFolder)) {
    return [];
  }
  const files = [];
  const collectFiles = (currentFolder) => {
    for (const child of currentFolder.children) {
      if (child instanceof import_obsidian16.TFile && child.extension === "md") {
        files.push(child);
      } else if (child instanceof import_obsidian16.TFolder) {
        collectFiles(child);
      }
    }
  };
  collectFiles(folder);
  return files;
}
function watchVaultPresets(app, entityType, onChange) {
  const entityConfig = ENTITY_REGISTRY[entityType];
  if (!entityConfig) {
    logger2.warn(`[VaultPresetLoader] Unknown entity type: ${entityType}`);
    return () => {
    };
  }
  const notify = () => {
    onChange();
  };
  const createRef = app.vault.on("create", (file) => {
    if (file instanceof import_obsidian16.TFile && file.path.startsWith(entityConfig.directory)) {
      notify();
    }
  });
  const deleteRef = app.vault.on("delete", (file) => {
    if (file instanceof import_obsidian16.TFile && file.path.startsWith(entityConfig.directory)) {
      notify();
    }
  });
  const renameRef = app.vault.on("rename", (file, oldPath) => {
    if (file instanceof import_obsidian16.TFile && (file.path.startsWith(entityConfig.directory) || oldPath.startsWith(entityConfig.directory))) {
      notify();
    }
  });
  const modifyRef = app.vault.on("modify", (file) => {
    if (file instanceof import_obsidian16.TFile && file.path.startsWith(entityConfig.directory)) {
      notify();
    }
  });
  return () => {
    app.vault.offref(createRef);
    app.vault.offref(deleteRef);
    app.vault.offref(renameRef);
    app.vault.offref(modifyRef);
  };
}
var import_obsidian16;
var init_vault_preset_loader = __esm({
  "Presets/lib/vault-preset-loader.ts"() {
    "use strict";
    import_obsidian16 = require("obsidian");
    init_entity_registry();
    init_plugin_logger();
  }
});

// src/workmodes/library/storage/data-sources.ts
var data_sources_exports = {};
__export(data_sources_exports, {
  LIBRARY_DATA_SOURCES: () => LIBRARY_DATA_SOURCES
});
function createEntryLoader(extractMeta) {
  return async (app, file) => {
    const fm2 = await readFrontmatter(app, file);
    const meta = extractMeta(fm2);
    return { file, name: file.basename, ...meta };
  };
}
function extractTokenValues(raw) {
  if (!Array.isArray(raw)) return [];
  const result = [];
  for (const entry of raw) {
    if (typeof entry === "string" && entry.trim()) {
      result.push(entry.trim());
    } else if (entry && typeof entry === "object") {
      const value = entry.value;
      if (typeof value === "string" && value.trim()) {
        result.push(value.trim());
      }
    }
  }
  return result;
}
var loadCreatureEntry, loadSpellEntry, loadItemEntry, loadEquipmentEntry, loadTerrainEntry, loadRegionEntry, loadFactionEntry, loadCalendarEntry, loadLocationEntry, loadPlaylistEntry, loadEncounterTableEntry, LIBRARY_DATA_SOURCES;
var init_data_sources = __esm({
  "src/workmodes/library/storage/data-sources.ts"() {
    "use strict";
    init_frontmatter_utils();
    init_vault_preset_loader();
    loadCreatureEntry = createEntryLoader((fm2) => ({
      type: typeof fm2.type === "string" ? fm2.type : void 0,
      cr: typeof fm2.cr === "string" ? fm2.cr : typeof fm2.cr === "number" ? String(fm2.cr) : void 0
    }));
    loadSpellEntry = createEntryLoader((fm2) => {
      const rawLevel = fm2.level;
      const level = typeof rawLevel === "number" ? rawLevel : typeof rawLevel === "string" ? Number(rawLevel) : void 0;
      return {
        school: typeof fm2.school === "string" ? fm2.school : void 0,
        level: Number.isFinite(level) ? level : void 0,
        casting_time: typeof fm2.casting_time === "string" ? fm2.casting_time : void 0,
        duration: typeof fm2.duration === "string" ? fm2.duration : void 0,
        concentration: typeof fm2.concentration === "boolean" ? fm2.concentration : void 0,
        ritual: typeof fm2.ritual === "boolean" ? fm2.ritual : void 0,
        description: typeof fm2.description === "string" ? fm2.description : void 0
      };
    });
    loadItemEntry = createEntryLoader((fm2) => ({
      category: typeof fm2.category === "string" ? fm2.category : void 0,
      rarity: typeof fm2.rarity === "string" ? fm2.rarity : void 0
    }));
    loadEquipmentEntry = createEntryLoader((fm2) => {
      const roleCandidate = [
        fm2.weapon_category,
        fm2.armor_category,
        fm2.tool_category,
        fm2.gear_category
      ].find((value) => typeof value === "string" && value.length > 0);
      return {
        type: typeof fm2.type === "string" ? fm2.type : void 0,
        role: roleCandidate
      };
    });
    loadTerrainEntry = createEntryLoader((fm2) => ({
      color: typeof fm2.color === "string" ? fm2.color : "transparent",
      speed: typeof fm2.speed === "number" ? fm2.speed : 1
    }));
    loadRegionEntry = createEntryLoader((fm2) => ({
      terrain: typeof fm2.terrain === "string" ? fm2.terrain : "",
      encounterOdds: typeof fm2.encounter_odds === "number" ? fm2.encounter_odds : void 0
    }));
    loadFactionEntry = createEntryLoader((fm2) => {
      const influenceTags = extractTokenValues(fm2.influence_tags);
      const members = Array.isArray(fm2.members) ? fm2.members : [];
      return {
        influence: influenceTags[0],
        headquarters: typeof fm2.headquarters === "string" ? fm2.headquarters : void 0,
        memberCount: members.length
      };
    });
    loadCalendarEntry = createEntryLoader((fm2) => {
      const months = Array.isArray(fm2.months) ? fm2.months : [];
      return {
        id: typeof fm2.id === "string" ? fm2.id : "",
        daysPerWeek: typeof fm2.daysPerWeek === "number" ? fm2.daysPerWeek : 7,
        monthCount: months.length
      };
    });
    loadLocationEntry = createEntryLoader((fm2) => {
      const ownerType = typeof fm2.owner_type === "string" ? fm2.owner_type : "none";
      const ownerName = typeof fm2.owner_name === "string" ? fm2.owner_name.trim() : "";
      const owner = ownerType !== "none" && ownerName ? `${ownerType}: ${ownerName}` : void 0;
      const locationType = typeof fm2.type === "string" ? fm2.type : "Unknown";
      let gridSize = void 0;
      if (locationType === "Dungeon") {
        const gridWidth = typeof fm2.grid_width === "number" ? fm2.grid_width : void 0;
        const gridHeight = typeof fm2.grid_height === "number" ? fm2.grid_height : void 0;
        if (gridWidth && gridHeight) {
          gridSize = `${gridWidth}\xD7${gridHeight}`;
        }
      }
      return {
        type: locationType,
        owner,
        parent: typeof fm2.parent === "string" ? fm2.parent : void 0,
        grid_size: gridSize
      };
    });
    loadPlaylistEntry = createEntryLoader((fm2) => {
      const type2 = typeof fm2.type === "string" && (fm2.type === "ambience" || fm2.type === "music") ? fm2.type : "ambience";
      const tracks = Array.isArray(fm2.tracks) ? fm2.tracks : [];
      return {
        type: type2,
        track_count: tracks.length,
        terrain_tags: extractTokenValues(fm2.terrain_tags),
        weather_tags: extractTokenValues(fm2.weather_tags),
        time_of_day_tags: extractTokenValues(fm2.time_of_day_tags),
        faction_tags: extractTokenValues(fm2.faction_tags),
        situation_tags: extractTokenValues(fm2.situation_tags)
      };
    });
    loadEncounterTableEntry = createEntryLoader((fm2) => {
      const entries = Array.isArray(fm2.entries) ? fm2.entries : [];
      const crRange = fm2.crRange && typeof fm2.crRange === "object" ? {
        min: typeof fm2.crRange.min === "number" ? fm2.crRange.min : void 0,
        max: typeof fm2.crRange.max === "number" ? fm2.crRange.max : void 0
      } : void 0;
      return {
        entry_count: entries.length,
        terrain_tags: extractTokenValues(fm2.terrain_tags),
        weather_tags: extractTokenValues(fm2.weather_tags),
        time_of_day_tags: extractTokenValues(fm2.time_of_day_tags),
        faction_tags: extractTokenValues(fm2.faction_tags),
        situation_tags: extractTokenValues(fm2.situation_tags),
        crRange
      };
    });
    LIBRARY_DATA_SOURCES = {
      creatures: {
        id: "creatures",
        list: (app) => listVaultPresets(app, "creatures"),
        watch: (app, onChange) => watchVaultPresets(app, "creatures", onChange),
        load: loadCreatureEntry
      },
      spells: {
        id: "spells",
        list: (app) => listVaultPresets(app, "spells"),
        watch: (app, onChange) => watchVaultPresets(app, "spells", onChange),
        load: loadSpellEntry
      },
      items: {
        id: "items",
        list: (app) => listVaultPresets(app, "items"),
        watch: (app, onChange) => watchVaultPresets(app, "items", onChange),
        load: loadItemEntry
      },
      equipment: {
        id: "equipment",
        list: (app) => listVaultPresets(app, "equipment"),
        watch: (app, onChange) => watchVaultPresets(app, "equipment", onChange),
        load: loadEquipmentEntry
      },
      terrains: {
        id: "terrains",
        list: (app) => listVaultPresets(app, "terrains"),
        watch: (app, onChange) => watchVaultPresets(app, "terrains", onChange),
        load: loadTerrainEntry
      },
      regions: {
        id: "regions",
        list: (app) => listVaultPresets(app, "regions"),
        watch: (app, onChange) => watchVaultPresets(app, "regions", onChange),
        load: loadRegionEntry
      },
      factions: {
        id: "factions",
        list: (app) => listVaultPresets(app, "factions"),
        watch: (app, onChange) => watchVaultPresets(app, "factions", onChange),
        load: loadFactionEntry
      },
      calendars: {
        id: "calendars",
        list: (app) => listVaultPresets(app, "calendars"),
        watch: (app, onChange) => watchVaultPresets(app, "calendars", onChange),
        load: loadCalendarEntry
      },
      locations: {
        id: "locations",
        list: (app) => listVaultPresets(app, "locations"),
        watch: (app, onChange) => watchVaultPresets(app, "locations", onChange),
        load: loadLocationEntry
      },
      playlists: {
        id: "playlists",
        list: (app) => listVaultPresets(app, "playlists"),
        watch: (app, onChange) => watchVaultPresets(app, "playlists", onChange),
        load: loadPlaylistEntry
      },
      "encounter-tables": {
        id: "encounter-tables",
        list: (app) => listVaultPresets(app, "encounter-tables"),
        watch: (app, onChange) => watchVaultPresets(app, "encounter-tables", onChange),
        load: loadEncounterTableEntry
      }
    };
  }
});

// src/ui/components/form-builder.ts
function buildForm(root, config) {
  const controls = /* @__PURE__ */ new Map();
  const elements = /* @__PURE__ */ new Map();
  const containers = /* @__PURE__ */ new Map();
  const hints = /* @__PURE__ */ new Map();
  const statuses = /* @__PURE__ */ new Map();
  const cleanup = [];
  const createRow = (section) => {
    const row = createElement("div");
    applyClasses(row, section.rowCls ?? "sm-row");
    const label = createElement("label");
    label.textContent = section.label;
    applyClasses(label, section.labelCls);
    row.appendChild(label);
    section.controls.forEach((control, index) => {
      if (control.kind === "select") {
        const select = createElement("select", control.cls);
        applyAttributes(select, control.attr);
        if (control.options) {
          for (const option of control.options) {
            const opt = document.createElement("option");
            opt.text = option.label;
            opt.value = option.value;
            if (option.data) {
              for (const [key, value] of Object.entries(option.data)) {
                opt.dataset[key] = value;
              }
            }
            select.appendChild(opt);
          }
        }
        if (typeof control.value === "string") {
          select.value = control.value;
        }
        select.disabled = Boolean(control.disabled);
        select.id = control.id;
        const handler = (event) => {
          control.onChange?.({ value: select.value, element: select, event });
        };
        select.addEventListener("change", handler);
        cleanup.push(() => select.removeEventListener("change", handler));
        row.appendChild(select);
        control.enhance?.(select);
        const handle = {
          kind: "select",
          element: select,
          setOptions(options) {
            select.innerHTML = "";
            for (const option of options) {
              const opt = document.createElement("option");
              opt.text = option.label;
              opt.value = option.value;
              if (option.data) {
                for (const [key, value] of Object.entries(option.data)) {
                  opt.dataset[key] = value;
                }
              }
              select.appendChild(opt);
            }
          },
          setValue(value) {
            select.value = value;
          },
          getValue() {
            return select.value;
          },
          setDisabled(disabled) {
            select.disabled = disabled;
          }
        };
        controls.set(control.id, handle);
        if (index === 0) {
          label.htmlFor = control.id;
        }
      } else if (control.kind === "slider") {
        const input = createElement("input", control.cls);
        applyAttributes(input, control.attr);
        input.type = "range";
        input.min = String(control.min);
        input.max = String(control.max);
        input.step = String(control.step ?? 1);
        input.value = String(control.value);
        input.disabled = Boolean(control.disabled);
        input.id = control.id;
        const valueFormatter = control.valueFormatter ?? ((value) => String(value));
        let valueEl = null;
        const showValue = control.showValue !== false;
        if (showValue) {
          valueEl = createElement("span");
          valueEl.textContent = valueFormatter(Number(input.value));
        }
        const handleInput = (event) => {
          const value = Number(input.value);
          if (valueEl) valueEl.textContent = valueFormatter(value);
          control.onInput?.({ value, element: input, event });
        };
        const handleChange = (event) => {
          const value = Number(input.value);
          if (valueEl) valueEl.textContent = valueFormatter(value);
          control.onChange?.({ value, element: input, event });
        };
        input.addEventListener("input", handleInput);
        input.addEventListener("change", handleChange);
        cleanup.push(() => {
          input.removeEventListener("input", handleInput);
          input.removeEventListener("change", handleChange);
        });
        row.appendChild(input);
        if (valueEl) row.appendChild(valueEl);
        const handle = {
          kind: "slider",
          element: input,
          valueElement: valueEl,
          setValue(value) {
            input.value = String(value);
            if (valueEl) valueEl.textContent = valueFormatter(value);
          },
          getValue() {
            return Number(input.value);
          },
          setDisabled(disabled) {
            input.disabled = disabled;
          }
        };
        controls.set(control.id, handle);
        if (index === 0) {
          label.htmlFor = control.id;
        }
      } else if (control.kind === "textarea") {
        const textarea = createElement("textarea", control.cls);
        applyAttributes(textarea, control.attr);
        textarea.value = control.value ?? "";
        textarea.disabled = Boolean(control.disabled);
        if (control.rows) textarea.rows = control.rows;
        if (control.placeholder) textarea.placeholder = control.placeholder;
        textarea.id = control.id;
        const handleInput = (event) => {
          control.onInput?.({ value: textarea.value, element: textarea, event });
        };
        textarea.addEventListener("input", handleInput);
        cleanup.push(() => textarea.removeEventListener("input", handleInput));
        row.appendChild(textarea);
        const handle = {
          kind: "textarea",
          element: textarea,
          setValue(value) {
            textarea.value = value;
          },
          getValue() {
            return textarea.value;
          },
          setDisabled(disabled) {
            textarea.disabled = disabled;
          }
        };
        controls.set(control.id, handle);
        if (index === 0) {
          label.htmlFor = control.id;
        }
      } else if (control.kind === "button") {
        const button = createElement("button", control.cls);
        applyAttributes(button, control.attr);
        button.type = "button";
        button.textContent = control.label;
        button.disabled = Boolean(control.disabled);
        button.id = control.id;
        const handler = (event) => {
          control.onClick?.({ element: button, event });
        };
        button.addEventListener("click", handler);
        cleanup.push(() => button.removeEventListener("click", handler));
        row.appendChild(button);
        const handle = {
          kind: "button",
          element: button,
          setDisabled(disabled) {
            button.disabled = disabled;
          }
        };
        controls.set(control.id, handle);
      }
    });
    root.appendChild(row);
  };
  const createHint = (section) => {
    const hint = createElement("p", section.cls ?? "sm-inline-hint");
    const handle = {
      element: hint,
      set(details) {
        if (!details || !details.text) {
          hint.style.display = "none";
          hint.textContent = "";
          hint.removeAttribute("data-tone");
          return;
        }
        hint.style.display = "";
        hint.textContent = details.text;
        if (details.tone) {
          hint.setAttribute("data-tone", details.tone);
        } else {
          hint.removeAttribute("data-tone");
        }
      }
    };
    if (section.hidden !== false) {
      hint.style.display = "none";
    }
    if (section.tone) {
      hint.setAttribute("data-tone", section.tone);
    }
    root.appendChild(hint);
    hints.set(section.id, handle);
  };
  const createStatus = (section) => {
    const status = createElement("div", section.cls);
    const handle = {
      element: status,
      set(details) {
        const message = details?.message ?? "";
        status.textContent = message;
        status.classList.toggle("is-empty", !message);
        status.classList.toggle("is-loading", details?.tone === "loading");
        status.classList.toggle("is-error", details?.tone === "error");
      }
    };
    status.classList.add("is-empty");
    root.appendChild(status);
    statuses.set(section.id, handle);
  };
  for (const section of config.sections) {
    switch (section.kind) {
      case "header": {
        const level = section.level ?? 3;
        const header = createElement(`h${level}`, section.cls);
        header.textContent = section.text;
        root.appendChild(header);
        break;
      }
      case "row": {
        createRow(section);
        break;
      }
      case "static": {
        const tag = section.tag ?? "div";
        const el = createElement(tag, section.cls);
        if (section.text) el.textContent = section.text;
        root.appendChild(el);
        elements.set(section.id, el);
        break;
      }
      case "hint": {
        createHint(section);
        break;
      }
      case "status": {
        createStatus(section);
        break;
      }
      case "container": {
        const tag = section.tag ?? "div";
        const el = createElement(tag, section.cls);
        root.appendChild(el);
        containers.set(section.id, el);
        break;
      }
    }
  }
  return {
    root,
    getControl(id) {
      return controls.get(id) ?? null;
    },
    getElement(id) {
      return elements.get(id) ?? null;
    },
    getContainer(id) {
      return containers.get(id) ?? null;
    },
    getHint(id) {
      return hints.get(id) ?? null;
    },
    getStatus(id) {
      return statuses.get(id) ?? null;
    },
    destroy() {
      cleanup.forEach((fn) => {
        try {
          fn();
        } catch (err) {
          logger2.error("[form-builder] cleanup failed", err);
        }
      });
      cleanup.length = 0;
    }
  };
}
var applyClasses, createElement, applyAttributes;
var init_form_builder = __esm({
  "src/ui/components/form-builder.ts"() {
    "use strict";
    init_plugin_logger();
    applyClasses = (el, cls) => {
      if (!cls) return;
      const values = Array.isArray(cls) ? cls : cls.split(/\s+/).filter(Boolean);
      for (const value of values) {
        el.classList.add(value);
      }
    };
    createElement = (tag, cls) => {
      const el = document.createElement(tag);
      applyClasses(el, cls);
      return el;
    };
    applyAttributes = (el, attr) => {
      if (!attr) return;
      for (const [key, value] of Object.entries(attr)) {
        el.setAttribute(key, value);
      }
    };
  }
});

// src/workmodes/cartographer/editor/tools/terrain-brush/brush-options.ts
function mountBrushPanel(root, ctx) {
  const state = {
    radius: 1,
    region: "",
    faction: "",
    terrain: "",
    mode: "paint"
  };
  const effectiveRadius = () => Math.max(0, state.radius - 1);
  let disposed = false;
  let fillSeq = 0;
  let fillFactionSeq = 0;
  let circle = null;
  let panelDisabled = false;
  let manageCommandAvailable = false;
  let radiusControl = null;
  let regionControl = null;
  let factionControl = null;
  let modeControl = null;
  let manageButton = null;
  let manageFactionButton = null;
  let inlineHint = null;
  let manageHint = null;
  let factionHint = null;
  const setPanelDisabled = (disabled) => {
    panelDisabled = disabled;
    if (disabled) {
      root.classList.add("is-disabled");
    } else {
      root.classList.remove("is-disabled");
    }
    radiusControl?.setDisabled(disabled);
    regionControl?.setDisabled(disabled);
    factionControl?.setDisabled(disabled);
    modeControl?.setDisabled(disabled);
    manageButton?.setDisabled(disabled || !manageCommandAvailable);
    manageFactionButton?.setDisabled(disabled || !manageCommandAvailable);
  };
  const updateStatus = (message) => {
    try {
      ctx.setStatus(message);
    } catch (err) {
      logger2.error("[terrain-brush] failed to set status", err);
    }
  };
  const form = buildForm(root, {
    sections: [
      { kind: "header", text: "Region Brush" },
      { kind: "hint", id: "inline", cls: "sm-inline-hint", hidden: true },
      {
        kind: "row",
        label: "Radius:",
        controls: [
          {
            kind: "slider",
            id: "radius",
            min: 1,
            max: 6,
            step: 1,
            value: state.radius,
            valueFormatter: (value) => String(value),
            onInput: ({ value }) => {
              state.radius = value;
              circle?.updateRadius(effectiveRadius());
            }
          }
        ]
      },
      {
        kind: "row",
        label: "Region:",
        controls: [
          {
            kind: "select",
            id: "region",
            options: [],
            enhance: (select) => enhanceSelectToSearch(select, "Search dropdown\u2026"),
            onChange: ({ element }) => {
              state.region = element.value;
              const opt = element.selectedOptions[0];
              state.terrain = opt?.dataset?.terrain ?? "";
            }
          },
          {
            kind: "button",
            id: "manage",
            label: "Manage\u2026"
          }
        ]
      },
      { kind: "hint", id: "manageHint", cls: "sm-inline-hint", hidden: true },
      {
        kind: "row",
        label: "Faction:",
        controls: [
          {
            kind: "select",
            id: "faction",
            options: [],
            enhance: (select) => enhanceSelectToSearch(select, "Search dropdown\u2026"),
            onChange: ({ element }) => {
              state.faction = element.value;
            }
          },
          {
            kind: "button",
            id: "manageFaction",
            label: "Manage\u2026"
          }
        ]
      },
      { kind: "hint", id: "factionHint", cls: "sm-inline-hint", hidden: true },
      {
        kind: "row",
        label: "Mode:",
        controls: [
          {
            kind: "select",
            id: "mode",
            value: state.mode,
            options: [
              { label: "Paint", value: "paint" },
              { label: "Erase", value: "erase" }
            ],
            enhance: (select) => enhanceSelectToSearch(select, "Search dropdown\u2026"),
            onChange: ({ element }) => {
              state.mode = element.value;
            }
          }
        ]
      }
    ]
  });
  radiusControl = form.getControl("radius");
  regionControl = form.getControl("region");
  factionControl = form.getControl("faction");
  modeControl = form.getControl("mode");
  manageButton = form.getControl("manage");
  manageFactionButton = form.getControl("manageFaction");
  inlineHint = form.getHint("inline");
  manageHint = form.getHint("manageHint");
  factionHint = form.getHint("factionHint");
  const applyInlineHint = (details) => {
    inlineHint?.set(details ? { text: details.text, tone: details.tone } : null);
  };
  const applyManageHint = (details) => {
    manageHint?.set(details ? { text: details.text, tone: details.tone } : null);
  };
  const applyFactionHint = (details) => {
    factionHint?.set(details ? { text: details.text, tone: details.tone } : null);
  };
  const handleManageClick = () => {
    if (!manageCommandAvailable) {
      updateStatus("The Library command is unavailable. Follow the manual steps below to add regions.");
      return;
    }
    try {
      const result = ctx.app.commands?.executeCommandById?.(MANAGE_REGIONS_COMMAND_ID);
      if (result instanceof Promise) {
        result.catch((err) => handleManageError(err));
        updateStatus("Opening the Library to manage regions\u2026");
      } else if (result === false) {
        handleManageError();
      } else {
        updateStatus("Opening the Library to manage regions\u2026");
      }
    } catch (err) {
      handleManageError(err);
    }
  };
  const handleManageFactionClick = () => {
    if (!manageCommandAvailable) {
      updateStatus("The Library command is unavailable. Follow the manual steps below to add factions.");
      return;
    }
    try {
      const result = ctx.app.commands?.executeCommandById?.(MANAGE_REGIONS_COMMAND_ID);
      if (result instanceof Promise) {
        result.catch((err) => handleManageFactionError(err));
        updateStatus("Opening the Library to manage factions\u2026");
      } else if (result === false) {
        handleManageFactionError();
      } else {
        updateStatus("Opening the Library to manage factions\u2026");
      }
    } catch (err) {
      handleManageFactionError(err);
    }
  };
  const refreshManageCommandAvailability = () => {
    const commandsApi = ctx.app.commands;
    manageCommandAvailable = Boolean(
      commandsApi?.executeCommandById && commandsApi?.commands?.[MANAGE_REGIONS_COMMAND_ID]
    );
    manageButton?.setDisabled(panelDisabled || !manageCommandAvailable);
    manageFactionButton?.setDisabled(panelDisabled || !manageCommandAvailable);
    if (manageButton) {
      manageButton.element.classList.toggle("is-missing-command", !manageCommandAvailable);
    }
    if (manageFactionButton) {
      manageFactionButton.element.classList.toggle("is-missing-command", !manageCommandAvailable);
    }
    if (!manageCommandAvailable) {
      applyManageHint({
        text: 'The "Open Library" command is unavailable. Open the Library view from the ribbon (book icon) and add Region entries under Library \u2192 Regions, then refresh this list.',
        tone: "warning"
      });
      applyFactionHint({
        text: 'The "Open Library" command is unavailable. Open the Library view from the ribbon (book icon) and add Faction entries under Library \u2192 Factions, then refresh this list.',
        tone: "warning"
      });
    } else {
      applyManageHint(null);
      applyFactionHint(null);
    }
  };
  const handleManageError = (err) => {
    if (err) {
      logger2.error("[terrain-brush] failed to open Library command", err);
    }
    applyManageHint({
      text: "Opening the Library command failed. Use the ribbon icon to open the Library manually and add Region entries under Library \u2192 Regions before refreshing.",
      tone: "error"
    });
    updateStatus("Failed to open the Library command. Check the console for details.");
  };
  const handleManageFactionError = (err) => {
    if (err) {
      logger2.error("[terrain-brush] failed to open Library command for factions", err);
    }
    applyFactionHint({
      text: "Opening the Library command failed. Use the ribbon icon to open the Library manually and add Faction entries under Library \u2192 Factions before refreshing.",
      tone: "error"
    });
    updateStatus("Failed to open the Library command. Check the console for details.");
  };
  if (manageButton) {
    manageButton.element.addEventListener("click", handleManageClick);
  }
  if (manageFactionButton) {
    manageFactionButton.element.addEventListener("click", handleManageFactionClick);
  }
  refreshManageCommandAvailability();
  const fillOptions = async (reason) => {
    const seq2 = ++fillSeq;
    setPanelDisabled(true);
    applyInlineHint({
      text: reason === "initial" ? "Loading regions\u2026" : "Refreshing regions\u2026",
      tone: "loading"
    });
    updateStatus(reason === "initial" ? "Loading regions\u2026" : "Refreshing regions\u2026");
    let regions = [];
    try {
      regions = await loadRegions2(ctx.app);
    } catch (err) {
      logger2.error("[terrain-brush] failed to load regions", err);
      if (seq2 === fillSeq && !disposed && !ctx.getAbortSignal()?.aborted) {
        regionControl?.setOptions([]);
        state.region = "";
        state.terrain = "";
        applyInlineHint({
          text: "Regions could not be loaded. Please retry once your vault is synced.",
          tone: "error"
        });
        updateStatus("Failed to load regions. Check the console for details.");
      }
      return;
    } finally {
      if (seq2 === fillSeq && !disposed && !ctx.getAbortSignal()?.aborted) {
        setPanelDisabled(false);
        refreshManageCommandAvailability();
      }
    }
    if (disposed || ctx.getAbortSignal()?.aborted || seq2 !== fillSeq) {
      return;
    }
    regionControl?.setOptions([
      { label: "(none)", value: "" },
      ...regions.map((r) => ({
        label: r.name || "(unnamed)",
        value: r.name ?? "",
        data: r.terrain ? { terrain: r.terrain } : void 0
      }))
    ]);
    const regionSelect = regionControl?.element;
    if (!regionSelect) return;
    let matchedTerrain = state.terrain;
    let matchedRegion = state.region;
    let preservedSelection = false;
    for (const opt of Array.from(regionSelect.options)) {
      if (!opt.value) continue;
      if (opt.value === state.region) {
        matchedRegion = opt.value;
        matchedTerrain = opt.dataset.terrain ?? "";
        preservedSelection = true;
        break;
      }
    }
    if (state.region && !preservedSelection) {
      state.region = "";
      state.terrain = "";
      regionControl.setValue("");
      applyInlineHint({
        text: "The previously selected region is no longer available and was cleared.",
        tone: "warning"
      });
      updateStatus("Region selection cleared because the entry is missing.");
    } else {
      state.region = matchedRegion;
      state.terrain = matchedTerrain;
      regionControl.setValue(matchedRegion);
      if (regions.length === 0) {
        applyInlineHint({
          text: "No regions found. Open the Library (Manage\u2026 button or ribbon icon) and add Region entries before painting.",
          tone: "info"
        });
        updateStatus("No regions available yet.");
      } else {
        applyInlineHint(null);
        updateStatus("Regions loaded.");
      }
    }
  };
  const fillFactions = async (reason) => {
    const fSeq = ++fillFactionSeq;
    setPanelDisabled(true);
    applyFactionHint({
      text: reason === "initial" ? "Loading factions\u2026" : "Refreshing factions\u2026",
      tone: "loading"
    });
    let factionFiles = [];
    try {
      factionFiles = await LIBRARY_DATA_SOURCES.factions.list(ctx.app);
    } catch (err) {
      logger2.error("[terrain-brush] failed to list factions", err);
      if (fSeq === fillFactionSeq && !disposed && !ctx.getAbortSignal()?.aborted) {
        factionControl?.setOptions([]);
        state.faction = "";
        applyFactionHint({
          text: "Factions could not be loaded. Please retry once your vault is synced.",
          tone: "error"
        });
      }
      return;
    } finally {
      if (fSeq === fillFactionSeq && !disposed && !ctx.getAbortSignal()?.aborted) {
        setPanelDisabled(false);
        refreshManageCommandAvailability();
      }
    }
    if (disposed || ctx.getAbortSignal()?.aborted || fSeq !== fillFactionSeq) {
      return;
    }
    const factions = [];
    for (const file of factionFiles) {
      try {
        const entry = await LIBRARY_DATA_SOURCES.factions.load(ctx.app, file);
        factions.push({ name: entry.name });
      } catch (err) {
        logger2.warn(`[terrain-brush] failed to load faction ${file.path}`, err);
      }
    }
    factionControl?.setOptions([
      { label: "(none)", value: "" },
      ...factions.map((f) => ({
        label: f.name || "(unnamed)",
        value: f.name ?? ""
      }))
    ]);
    const factionSelect = factionControl?.element;
    if (!factionSelect) return;
    let matchedFaction = state.faction;
    let preservedFactionSelection = false;
    for (const opt of Array.from(factionSelect.options)) {
      if (!opt.value) continue;
      if (opt.value === state.faction) {
        matchedFaction = opt.value;
        preservedFactionSelection = true;
        break;
      }
    }
    if (state.faction && !preservedFactionSelection) {
      state.faction = "";
      factionControl.setValue("");
      applyFactionHint({
        text: "The previously selected faction is no longer available and was cleared.",
        tone: "warning"
      });
    } else {
      state.faction = matchedFaction;
      factionControl.setValue(matchedFaction);
      if (factions.length === 0) {
        applyFactionHint({
          text: "No factions found. Open the Library (Manage\u2026 button or ribbon icon) and add Faction entries before painting.",
          tone: "info"
        });
      } else {
        applyFactionHint(null);
      }
    }
  };
  void fillOptions("initial");
  void fillFactions("initial");
  const workspace = ctx.app.workspace;
  const unsubscribe = [];
  const subscribeRegions = (event) => {
    const handler = () => {
      if (!disposed) void fillOptions("refresh");
    };
    const token = workspace?.on?.(event, handler);
    if (typeof workspace?.offref === "function" && token) {
      unsubscribe.push(() => workspace.offref(token));
    } else if (typeof token === "function") {
      unsubscribe.push(() => token());
    }
  };
  const subscribeFactions = (event) => {
    const handler = () => {
      if (!disposed) void fillFactions("refresh");
    };
    const token = workspace?.on?.(event, handler);
    if (typeof workspace?.offref === "function" && token) {
      unsubscribe.push(() => workspace.offref(token));
    } else if (typeof token === "function") {
      unsubscribe.push(() => token());
    }
  };
  subscribeRegions("salt:terrains-updated");
  subscribeRegions("salt:regions-updated");
  subscribeFactions("salt:factions-updated");
  const ensureCircle = (handles, options) => {
    if (!handles) return;
    circle?.destroy();
    circle = attachBrushCircle(
      { svg: handles.svg, contentG: handles.contentG, overlay: handles.overlay },
      { initialRadius: effectiveRadius(), hexRadiusPx: options?.radius ?? 42 }
    );
    circle.show();
  };
  const dispose = () => {
    disposed = true;
    fillSeq += 1;
    fillFactionSeq += 1;
    unsubscribe.forEach((off) => {
      try {
        off();
      } catch (err) {
        logger2.error("[terrain-brush] failed to unsubscribe", err);
      }
    });
    unsubscribe.length = 0;
    if (manageButton) {
      manageButton.element.removeEventListener("click", handleManageClick);
    }
    if (manageFactionButton) {
      manageFactionButton.element.removeEventListener("click", handleManageFactionClick);
    }
    form.destroy();
    circle?.destroy();
    circle = null;
    while (root.firstChild) {
      root.removeChild(root.firstChild);
    }
  };
  const handleHexClick = async (rc) => {
    const file = ctx.getFile();
    const handles = ctx.getHandles();
    if (!file || !handles) return false;
    const raw = coordsInRadius(rc, effectiveRadius());
    const targets = [...new Map(raw.map((k) => [`${k.r},${k.c}`, k])).values()];
    if (state.mode === "paint") {
      const missing = targets.filter((k) => !handles.polyByCoord.has(`${k.r},${k.c}`));
      if (missing.length) handles.ensurePolys(missing);
    }
    await applyBrush(
      ctx.app,
      file,
      rc,
      {
        radius: effectiveRadius(),
        terrain: state.terrain,
        region: state.region,
        faction: state.faction || void 0,
        mode: state.mode
      },
      handles,
      {
        tool: {
          getAbortSignal: () => ctx.getAbortSignal(),
          setStatus: (message) => ctx.setStatus(message)
        },
        toolName: TOOL_LABEL
      }
    );
    return true;
  };
  return {
    activate() {
      ensureCircle(ctx.getHandles(), ctx.getOptions());
    },
    deactivate() {
      circle?.destroy();
      circle = null;
    },
    onMapRendered() {
      ensureCircle(ctx.getHandles(), ctx.getOptions());
    },
    async handleHexClick(coord) {
      return handleHexClick(coord);
    },
    setDisabled(disabled) {
      setPanelDisabled(disabled);
      if (disabled) {
        circle?.destroy();
        circle = null;
      } else {
        ensureCircle(ctx.getHandles(), ctx.getOptions());
      }
    },
    destroy() {
      dispose();
    }
  };
}
var MANAGE_REGIONS_COMMAND_ID, TOOL_LABEL;
var init_brush_options = __esm({
  "src/workmodes/cartographer/editor/tools/terrain-brush/brush-options.ts"() {
    "use strict";
    init_brush_circle();
    init_brush_core();
    init_region_repository();
    init_data_sources();
    init_search_dropdown();
    init_plugin_logger();
    init_form_builder();
    MANAGE_REGIONS_COMMAND_ID = "salt-marcher:open-library";
    TOOL_LABEL = "Brush";
  }
});

// src/workmodes/cartographer/editor/tools/location-marker/marker-panel.ts
function mountLocationMarkerPanel(root, ctx) {
  const state = {
    selectedLocation: "",
    mode: "place"
  };
  let disposed = false;
  let panelDisabled = false;
  let manageCommandAvailable = false;
  let locationControl = null;
  let modeControl = null;
  let manageButton = null;
  let inlineHint = null;
  let manageHint = null;
  const setPanelDisabled = (disabled) => {
    panelDisabled = disabled;
    if (disabled) {
      root.classList.add("is-disabled");
    } else {
      root.classList.remove("is-disabled");
    }
    locationControl?.setDisabled(disabled);
    modeControl?.setDisabled(disabled);
    manageButton?.setDisabled(disabled || !manageCommandAvailable);
  };
  const updateStatus = (message) => {
    try {
      ctx.setStatus(message);
    } catch (err) {
      logger2.error("[location-marker] failed to set status", err);
    }
  };
  const setHint = (message, tone = "info", element = null) => {
    const target = element ?? inlineHint;
    if (!target) return;
    target.set({ message, tone });
    target.setHidden(!message);
  };
  const clearHint = (element = null) => {
    const target = element ?? inlineHint;
    if (!target) return;
    target.setHidden(true);
  };
  const form = buildForm(root, {
    sections: [
      { kind: "header", text: "Location Marker" },
      { kind: "hint", id: "inline", cls: "sm-inline-hint", hidden: true },
      {
        kind: "row",
        label: "Location:",
        controls: [
          {
            kind: "select",
            id: "location",
            options: [{ label: "(none)", value: "" }],
            enhance: (select) => enhanceSelectToSearch(select, "Search locations\u2026"),
            onChange: ({ element }) => {
              state.selectedLocation = element.value;
              clearHint();
            }
          },
          {
            kind: "button",
            id: "manage",
            label: "Manage\u2026"
          }
        ]
      },
      { kind: "hint", id: "manageHint", cls: "sm-inline-hint", hidden: true },
      {
        kind: "row",
        label: "Mode:",
        controls: [
          {
            kind: "select",
            id: "mode",
            options: [
              { label: "Place", value: "place" },
              { label: "Remove", value: "remove" }
            ],
            value: "place",
            onChange: ({ element }) => {
              state.mode = element.value;
              clearHint();
              if (state.mode === "place") {
                updateStatus("Click hex to place location marker");
              } else {
                updateStatus("Click hex to remove location marker");
              }
            }
          }
        ]
      }
    ]
  });
  locationControl = form.getControl("location");
  modeControl = form.getControl("mode");
  manageButton = form.getControl("manage");
  inlineHint = form.getHint("inline");
  manageHint = form.getHint("manageHint");
  manageCommandAvailable = !!ctx.app.commands?.commands?.[MANAGE_LOCATIONS_COMMAND_ID];
  if (manageButton) {
    manageButton.setDisabled(!manageCommandAvailable);
    manageButton.onClick(() => {
      if (manageCommandAvailable) {
        ctx.app.commands.executeCommandById(MANAGE_LOCATIONS_COMMAND_ID);
      }
    });
  }
  const loadLocations = async () => {
    try {
      const locationFiles = await LIBRARY_DATA_SOURCES.locations.list(ctx.app);
      const locations = [];
      for (const file of locationFiles) {
        try {
          const entry = await LIBRARY_DATA_SOURCES.locations.load(ctx.app, file);
          locations.push({
            name: entry.name,
            type: entry.locationType ?? "Unknown"
          });
        } catch (err) {
          logger2.warn(`[location-marker] failed to load location ${file.path}`, err);
        }
      }
      locations.sort((a, b) => a.name.localeCompare(b.name));
      locationControl?.setOptions([
        { label: "(none)", value: "" },
        ...locations.map((loc) => ({
          label: `${loc.name} (${loc.type})`,
          value: loc.name
        }))
      ]);
      if (!manageCommandAvailable) {
        setHint(
          "Library command not available. Cannot manage locations.",
          "warning",
          manageHint
        );
      }
    } catch (err) {
      logger2.error("[location-marker] failed to load locations", err);
      setHint("Failed to load locations from Library", "error");
    }
  };
  const handleHexClick = async (coord) => {
    if (disposed || panelDisabled) return false;
    const file = ctx.getFile();
    if (!file) {
      setHint("No map file selected", "error");
      return false;
    }
    const signal = ctx.getAbortSignal();
    if (signal?.aborted) return false;
    try {
      if (state.mode === "place") {
        if (!state.selectedLocation) {
          setHint("Please select a location first", "warning");
          return false;
        }
        const tileData = await loadTile(ctx.app, file, coord);
        await saveTile(ctx.app, file, coord, {
          ...tileData,
          locationMarker: state.selectedLocation
        });
        const markerStore = getLocationMarkerStore(ctx.app, file);
        const currentMarkers = markerStore.list();
        const filtered = currentMarkers.filter((m) => m.coord.r !== coord.r || m.coord.c !== coord.c);
        filtered.push({
          coord,
          locationName: state.selectedLocation,
          locationType: "Location"
          // Will be enriched by store
        });
        markerStore.setMarkers(filtered);
        updateStatus(`Placed marker: ${state.selectedLocation}`);
        clearHint();
        return true;
      } else if (state.mode === "remove") {
        const tileData = await loadTile(ctx.app, file, coord);
        if (!tileData.locationMarker) {
          setHint("No location marker at this hex", "info");
          return false;
        }
        await saveTile(ctx.app, file, coord, {
          ...tileData,
          locationMarker: void 0
        });
        const markerStore = getLocationMarkerStore(ctx.app, file);
        const currentMarkers = markerStore.list();
        const filtered = currentMarkers.filter((m) => m.coord.r !== coord.r || m.coord.c !== coord.c);
        markerStore.setMarkers(filtered);
        updateStatus("Removed location marker");
        clearHint();
        return true;
      }
    } catch (err) {
      logger2.error("[location-marker] failed to handle hex click", err);
      setHint("Failed to update location marker", "error");
      return false;
    }
    return false;
  };
  loadLocations().catch((err) => {
    logger2.error("[location-marker] initialization failed", err);
  });
  return {
    activate() {
      if (state.mode === "place") {
        updateStatus("Click hex to place location marker");
      } else {
        updateStatus("Click hex to remove location marker");
      }
    },
    deactivate() {
      clearHint();
      updateStatus("");
    },
    onMapRendered() {
      loadLocations().catch((err) => {
        logger2.error("[location-marker] onMapRendered loadLocations failed", err);
      });
    },
    handleHexClick,
    setDisabled: setPanelDisabled,
    destroy() {
      disposed = true;
      form.destroy();
      locationControl = null;
      modeControl = null;
      manageButton = null;
      inlineHint = null;
      manageHint = null;
    }
  };
}
var MANAGE_LOCATIONS_COMMAND_ID;
var init_marker_panel = __esm({
  "src/workmodes/cartographer/editor/tools/location-marker/marker-panel.ts"() {
    "use strict";
    init_data_sources();
    init_search_dropdown();
    init_plugin_logger();
    init_tile_repository();
    init_location_marker_store();
    init_form_builder();
    MANAGE_LOCATIONS_COMMAND_ID = "salt-marcher:open-library";
  }
});

// src/workmodes/cartographer/modes/lifecycle.ts
function createModeLifecycle() {
  let signal = null;
  return {
    bind(ctx) {
      signal = ctx.signal;
      return signal;
    },
    get() {
      return signal;
    },
    isAborted() {
      return signal?.aborted ?? false;
    },
    reset() {
      signal = null;
    }
  };
}
var init_lifecycle = __esm({
  "src/workmodes/cartographer/modes/lifecycle.ts"() {
    "use strict";
  }
});

// src/workmodes/cartographer/modes/editor.ts
var editor_exports = {};
__export(editor_exports, {
  createEditorMode: () => createEditorMode
});
function createEditorMode() {
  let panel = null;
  let form = null;
  let fileLabel = null;
  let statusField = null;
  let toolBody = null;
  let toolSelectHandle = null;
  let activeTool = "brush";
  let brush = null;
  let brushActive = false;
  let locationMarker = null;
  let locationMarkerActive = false;
  let state = {
    file: null,
    handles: null,
    options: null
  };
  const BASE_STATUS_READY = { message: "", tone: "info" };
  const BASE_STATUS_NO_MAP = { message: "No map selected.", tone: "info" };
  const BASE_STATUS_LOADING = { message: "Loading map\u2026", tone: "loading" };
  let baseStatus = BASE_STATUS_NO_MAP;
  let contextualStatus = null;
  let errorStatus = null;
  const lifecycle = createModeLifecycle();
  const applyStatus = () => {
    if (!statusField) return;
    const status = errorStatus ?? contextualStatus ?? baseStatus;
    statusField.set(status);
  };
  const setContextualStatus = (status) => {
    contextualStatus = status;
    refreshPanelState();
  };
  const setContextualMessage = (message, tone = "info") => {
    setContextualStatus(message ? { message, tone } : null);
  };
  const setErrorStatus = (status) => {
    errorStatus = status;
    if (status) {
      contextualStatus = null;
    }
    refreshPanelState();
  };
  const updateFileLabel = () => {
    if (!fileLabel) return;
    fileLabel.textContent = state.file ? state.file.basename : "No map";
  };
  const ensureBrush = (ctx) => {
    if (brush) return brush;
    if (!toolBody) return null;
    try {
      brush = mountBrushPanel(toolBody, {
        app: ctx.app,
        getFile: () => state.file,
        getHandles: () => state.handles,
        getOptions: () => state.options,
        getAbortSignal: () => lifecycle.get(),
        setStatus: (message) => setContextualMessage(message)
      });
      brush.setDisabled(!state.handles || !!errorStatus);
      return brush;
    } catch (error) {
      const message = reportEditorToolIssue({
        stage: "mount-panel",
        toolId: BRUSH_LABEL,
        error
      });
      setErrorStatus({ message, tone: "error" });
      return null;
    }
  };
  const ensureLocationMarker = (ctx) => {
    if (locationMarker) return locationMarker;
    if (!toolBody) return null;
    try {
      locationMarker = mountLocationMarkerPanel(toolBody, {
        app: ctx.app,
        getFile: () => state.file,
        getHandles: () => state.handles,
        getOptions: () => state.options,
        getAbortSignal: () => lifecycle.get(),
        setStatus: (message) => setContextualMessage(message)
      });
      locationMarker.setDisabled(!state.handles || !!errorStatus);
      return locationMarker;
    } catch (error) {
      const message = reportEditorToolIssue({
        stage: "mount-panel",
        toolId: LOCATION_MARKER_LABEL,
        error
      });
      setErrorStatus({ message, tone: "error" });
      return null;
    }
  };
  const clearToolBody = () => {
    if (!toolBody) return;
    while (toolBody.firstChild) {
      toolBody.removeChild(toolBody.firstChild);
    }
  };
  const switchTool = (toolId, ctx) => {
    if (activeTool === "brush" && brushActive) {
      brush?.deactivate();
      brushActive = false;
    } else if (activeTool === "location-marker" && locationMarkerActive) {
      locationMarker?.deactivate();
      locationMarkerActive = false;
    }
    clearToolBody();
    if (activeTool === "brush" && brush) {
      brush.destroy();
      brush = null;
    } else if (activeTool === "location-marker" && locationMarker) {
      locationMarker.destroy();
      locationMarker = null;
    }
    activeTool = toolId;
    if (toolId === "brush") {
      ensureBrush(ctx);
    } else if (toolId === "location-marker") {
      ensureLocationMarker(ctx);
    }
    refreshPanelState();
  };
  const refreshPanelState = () => {
    const hasHandles = !!state.handles;
    baseStatus = hasHandles ? BASE_STATUS_READY : state.file ? BASE_STATUS_LOADING : BASE_STATUS_NO_MAP;
    const toolsBlocked = !!errorStatus;
    panel?.classList.toggle("is-disabled", !hasHandles || toolsBlocked);
    panel?.classList.toggle("has-tool-error", toolsBlocked);
    brush?.setDisabled(!hasHandles || toolsBlocked);
    if (activeTool === "brush") {
      if (!brush || toolsBlocked || !hasHandles) {
        if (brushActive) {
          brush?.deactivate();
          brushActive = false;
        }
      } else if (!brushActive) {
        brush.activate();
        brushActive = true;
      }
    } else if (brushActive) {
      brush?.deactivate();
      brushActive = false;
    }
    locationMarker?.setDisabled(!hasHandles || toolsBlocked);
    if (activeTool === "location-marker") {
      if (!locationMarker || toolsBlocked || !hasHandles) {
        if (locationMarkerActive) {
          locationMarker?.deactivate();
          locationMarkerActive = false;
        }
      } else if (!locationMarkerActive) {
        locationMarker.activate();
        locationMarkerActive = true;
      }
    } else if (locationMarkerActive) {
      locationMarker?.deactivate();
      locationMarkerActive = false;
    }
    applyStatus();
  };
  const isAborted = () => lifecycle.isAborted();
  const clearHost = (host) => {
    while (host.firstChild) {
      host.removeChild(host.firstChild);
    }
  };
  return {
    id: "editor",
    label: "Editor",
    async onEnter(ctx) {
      lifecycle.bind(ctx);
      state = { ...state };
      clearHost(ctx.sidebarHost);
      panel = document.createElement("div");
      panel.className = "sm-cartographer__panel sm-cartographer__panel--editor";
      ctx.sidebarHost.appendChild(panel);
      form = buildForm(panel, {
        sections: [
          { kind: "header", text: "Map Editor" },
          { kind: "static", id: "file", cls: "sm-cartographer__panel-file" },
          {
            kind: "row",
            label: "Tool:",
            rowCls: "sm-cartographer__panel-tools",
            controls: [
              {
                kind: "select",
                id: "toolSelect",
                options: [
                  { value: "brush", label: BRUSH_LABEL },
                  { value: "location-marker", label: LOCATION_MARKER_LABEL }
                ],
                value: "brush",
                disabled: false,
                enhance: (select) => enhanceSelectToSearch(select, "Search dropdown\u2026"),
                onChange: ({ element }) => {
                  const newTool = element.value;
                  if (newTool !== activeTool) {
                    switchTool(newTool, ctx);
                  }
                }
              }
            ]
          },
          { kind: "container", id: "toolBody", cls: "sm-cartographer__panel-body" },
          { kind: "status", id: "status", cls: "sm-cartographer__panel-status" }
        ]
      });
      fileLabel = form.getElement("file");
      statusField = form.getStatus("status");
      toolBody = form.getContainer("toolBody");
      toolSelectHandle = form.getControl("toolSelect");
      toolSelectHandle?.setValue("brush");
      ensureBrush(ctx);
      updateFileLabel();
      refreshPanelState();
    },
    async onExit(ctx) {
      lifecycle.bind(ctx);
      brush?.destroy();
      brush = null;
      brushActive = false;
      locationMarker?.destroy();
      locationMarker = null;
      locationMarkerActive = false;
      activeTool = "brush";
      contextualStatus = null;
      errorStatus = null;
      baseStatus = BASE_STATUS_NO_MAP;
      form?.destroy();
      form = null;
      if (panel && panel.parentElement) {
        panel.parentElement.removeChild(panel);
      }
      panel = null;
      fileLabel = null;
      statusField = null;
      toolBody = null;
      toolSelectHandle = null;
      lifecycle.reset();
    },
    async onFileChange(file, handles, ctx) {
      lifecycle.bind(ctx);
      state.file = file;
      state.handles = handles;
      state.options = ctx.getOptions();
      updateFileLabel();
      if (activeTool === "brush") {
        ensureBrush(ctx);
      } else if (activeTool === "location-marker") {
        ensureLocationMarker(ctx);
      }
      refreshPanelState();
      if (!handles || isAborted()) return;
      if (activeTool === "brush") {
        brush?.onMapRendered();
      } else if (activeTool === "location-marker") {
        locationMarker?.onMapRendered();
      }
    },
    async onHexClick(coord, _event, ctx) {
      lifecycle.bind(ctx);
      if (isAborted()) return;
      if (activeTool === "brush") {
        const activeBrush = ensureBrush(ctx);
        if (!activeBrush) return;
        try {
          await activeBrush.handleHexClick(coord);
        } catch (err) {
          logger2.error("[editor-mode] brush interaction failed", err);
          const message = reportEditorToolIssue({
            stage: "operation",
            toolId: BRUSH_LABEL,
            error: err
          });
          setErrorStatus({ message, tone: "error" });
        }
      } else if (activeTool === "location-marker") {
        const activeMarker = ensureLocationMarker(ctx);
        if (!activeMarker) return;
        try {
          await activeMarker.handleHexClick(coord);
        } catch (err) {
          logger2.error("[editor-mode] location marker interaction failed", err);
          const message = reportEditorToolIssue({
            stage: "operation",
            toolId: LOCATION_MARKER_LABEL,
            error: err
          });
          setErrorStatus({ message, tone: "error" });
        }
      }
    }
  };
}
var BRUSH_LABEL, LOCATION_MARKER_LABEL;
var init_editor = __esm({
  "src/workmodes/cartographer/modes/editor.ts"() {
    "use strict";
    init_plugin_logger();
    init_editor_telemetry();
    init_brush_options();
    init_marker_panel();
    init_lifecycle();
    init_form_builder();
    init_search_dropdown();
    BRUSH_LABEL = "Brush";
    LOCATION_MARKER_LABEL = "Location Marker";
  }
});

// src/features/data-manager/layout/layout-utils.ts
var FieldWidthCalculator;
var init_layout_utils = __esm({
  "src/features/data-manager/layout/layout-utils.ts"() {
    "use strict";
    FieldWidthCalculator = class {
      static calculate(field) {
        const defaults = this.TYPE_DEFAULTS[field.type] ?? {
          minControlWidth: 200,
          isWide: false,
          hasFixedWidth: false
        };
        if (field.minWidth !== void 0) {
          return {
            isWide: field.preferWide ?? defaults.isWide ?? false,
            hasFixedWidth: defaults.hasFixedWidth ?? false,
            minControlWidth: field.minWidth
          };
        }
        switch (field.type) {
          case "multiselect":
            return this.calculateMultiselect(field, defaults);
          default:
            return {
              minControlWidth: defaults.minControlWidth ?? 200,
              isWide: field.preferWide ?? defaults.isWide ?? false,
              hasFixedWidth: defaults.hasFixedWidth ?? false
            };
        }
      }
      static calculateMultiselect(field, defaults) {
        const options = field.options ?? [];
        const avgOptionWidth = 108;
        const optionsPerRow = 3;
        const rows = Math.ceil(options.length / optionsPerRow);
        const minWidth = rows > 1 ? optionsPerRow * avgOptionWidth : options.length * avgOptionWidth;
        return {
          minControlWidth: Math.max(minWidth, defaults.minControlWidth ?? 200),
          isWide: rows > 2,
          // Many options → wide
          hasFixedWidth: false
        };
      }
    };
    FieldWidthCalculator.TYPE_DEFAULTS = {
      // Simple inputs - flexible width
      "text": { minControlWidth: 180, isWide: false, hasFixedWidth: false },
      "select": { minControlWidth: 160, isWide: false, hasFixedWidth: false },
      "date": { minControlWidth: 140, isWide: false, hasFixedWidth: false },
      // Composite inputs - calculated from components
      "number-stepper": {
        // Decrement (32px) + gap (4px) + input (80px) + gap (4px) + increment (32px)
        minControlWidth: 152,
        isWide: false,
        hasFixedWidth: false
      },
      "tags": {
        // Input (min 180px) + gap (8px) + button (40px)
        // Tags get sm-cc-setting--wide class in modal.ts, so treat as wide
        minControlWidth: 228,
        isWide: true,
        hasFixedWidth: false
      },
      "structured-tags": {
        // Type input (min 180px) + value input (min 120px) + gap (8px) + button (40px)
        // Structured tags are always wide due to complexity
        minControlWidth: 368,
        isWide: true,
        hasFixedWidth: false
      },
      "autocomplete": {
        minControlWidth: 200,
        isWide: false,
        hasFixedWidth: false
      },
      // Small fixed-width controls
      "toggle": { minControlWidth: 60, isWide: false, hasFixedWidth: true },
      "color": { minControlWidth: 80, isWide: false, hasFixedWidth: true },
      // Multi-option controls - depends on options
      "multiselect": {
        minControlWidth: 200,
        // Calculated dynamically
        isWide: false,
        hasFixedWidth: false
      },
      // Wide fields - always span all columns
      "textarea": { minControlWidth: 400, isWide: true, hasFixedWidth: false },
      "markdown": { minControlWidth: 500, isWide: true, hasFixedWidth: false },
      "repeating": { minControlWidth: 600, isWide: true, hasFixedWidth: false },
      "composite": { minControlWidth: 500, isWide: true, hasFixedWidth: false },
      "composite-stat": { minControlWidth: 500, isWide: true, hasFixedWidth: false },
      "array": { minControlWidth: 400, isWide: true, hasFixedWidth: false },
      "object": { minControlWidth: 400, isWide: true, hasFixedWidth: false }
    };
  }
});

// src/features/data-manager/layout/grid-layout-manager.ts
var GridLayoutManager;
var init_grid_layout_manager = __esm({
  "src/features/data-manager/layout/grid-layout-manager.ts"() {
    "use strict";
    init_layout_utils();
    init_plugin_logger();
    GridLayoutManager = class {
      constructor(container, fields8) {
        this.currentPairs = 1;
        this.container = container;
        this.fields = fields8;
        this.observer = new ResizeObserver(() => this.recalculate());
        this.observer.observe(container);
        this.recalculate();
      }
      /**
       * Returns true if the current layout uses multiple columns (pairs > 1).
       * Used to determine if label width synchronization should be disabled.
       */
      get isMultiColumn() {
        return this.currentPairs > 1;
      }
      measureMaxLabelWidth() {
        const labels = this.container.querySelectorAll(".setting-item-info");
        let maxWidth = 0;
        labels.forEach((label) => {
          const el = label;
          if (!el.offsetParent) return;
          const width = el.offsetWidth;
          if (width > maxWidth) maxWidth = width;
        });
        return maxWidth || 100;
      }
      recalculate() {
        const availableWidth = this.container.clientWidth - 30;
        const normalFields = this.fields.filter((f) => {
          const dims = FieldWidthCalculator.calculate(f);
          return !dims.isWide;
        });
        logger2.log("[GridLayoutManager] Recalculating layout:", {
          totalFields: this.fields.length,
          normalFields: normalFields.length,
          availableWidth,
          fieldTypes: this.fields.map((f) => `${f.id}:${f.type}`)
        });
        if (normalFields.length === 0) {
          logger2.log("[GridLayoutManager] No normal fields, using single column");
          this.container.style.gridTemplateColumns = "max-content 1fr";
          return;
        }
        const labelWidth = this.measureMaxLabelWidth();
        const maxControlWidth = Math.max(
          ...normalFields.map((f) => FieldWidthCalculator.calculate(f).minControlWidth)
        );
        const gap = 16;
        const minPairWidth = labelWidth + gap + maxControlWidth;
        let pairs2 = Math.floor(availableWidth / minPairWidth);
        pairs2 = Math.max(1, Math.min(pairs2, 3));
        const hasFixedWidths = normalFields.some(
          (f) => FieldWidthCalculator.calculate(f).hasFixedWidth
        );
        if (hasFixedWidths && pairs2 > 1) {
          const safeWidth = (labelWidth + gap + maxControlWidth) * 1.1;
          pairs2 = Math.floor(availableWidth / safeWidth);
          pairs2 = Math.max(1, Math.min(pairs2, 3));
        }
        this.currentPairs = pairs2;
        const columns = pairs2 === 1 ? "max-content 1fr" : `repeat(${pairs2}, max-content 1fr)`;
        logger2.log("[GridLayoutManager] Layout calculated:", {
          labelWidth,
          maxControlWidth,
          minPairWidth,
          pairs: pairs2,
          columns,
          isMultiColumn: this.isMultiColumn
        });
        this.container.style.gridTemplateColumns = columns;
      }
      destroy() {
        this.observer.disconnect();
      }
    };
  }
});

// src/features/data-manager/utils/width-utils.ts
function calculateTextWidth(text, referenceElement, options) {
  const opts = {
    includePadding: options?.includePadding ?? false,
    includeBorder: options?.includeBorder ?? false,
    extraSpace: options?.extraSpace ?? 0
  };
  const mirror = document.createElement("span");
  mirror.style.position = "absolute";
  mirror.style.visibility = "hidden";
  mirror.style.whiteSpace = "pre";
  mirror.style.pointerEvents = "none";
  mirror.textContent = text;
  const computedStyle = window.getComputedStyle(referenceElement);
  mirror.style.fontSize = computedStyle.fontSize;
  mirror.style.fontFamily = computedStyle.fontFamily;
  mirror.style.fontWeight = computedStyle.fontWeight;
  mirror.style.letterSpacing = computedStyle.letterSpacing;
  mirror.style.fontStyle = computedStyle.fontStyle;
  mirror.style.textTransform = computedStyle.textTransform;
  const container = referenceElement.parentElement || document.body;
  container.appendChild(mirror);
  let width = mirror.getBoundingClientRect().width;
  if (opts.includePadding) {
    const paddingLeft = parseFloat(computedStyle.paddingLeft) || 0;
    const paddingRight = parseFloat(computedStyle.paddingRight) || 0;
    width += paddingLeft + paddingRight;
  }
  if (opts.includeBorder) {
    const borderLeft = parseFloat(computedStyle.borderLeftWidth) || 0;
    const borderRight = parseFloat(computedStyle.borderRightWidth) || 0;
    width += borderLeft + borderRight;
  }
  width += opts.extraSpace;
  container.removeChild(mirror);
  return width;
}
var init_width_utils = __esm({
  "src/features/data-manager/utils/width-utils.ts"() {
    "use strict";
  }
});

// src/features/data-manager/layout/label-width-sync.ts
var LabelWidthSynchronizer;
var init_label_width_sync = __esm({
  "src/features/data-manager/layout/label-width-sync.ts"() {
    "use strict";
    init_plugin_logger();
    init_width_utils();
    LabelWidthSynchronizer = class {
      constructor(container, isMultiColumn) {
        this.container = container;
        this.isMultiColumn = isMultiColumn;
        this.resizeObserver = new ResizeObserver(() => {
          this.synchronize();
        });
        setTimeout(() => {
          this.synchronize();
          this.resizeObserver.observe(this.container);
        }, 100);
      }
      synchronize() {
        if (this.isMultiColumn) {
          this.synchronizeMultiColumn();
        } else {
          this.synchronizeSingleColumn();
        }
      }
      synchronizeSingleColumn() {
        const allLabels = Array.from(
          this.container.querySelectorAll(".setting-item-info")
        ).filter((label) => label.offsetParent);
        if (allLabels.length === 0) return;
        logger2.log("[LabelWidthSync] Single-column: Found", allLabels.length, "labels");
        const widths = allLabels.map((label) => {
          const text = label.textContent || "";
          return calculateTextWidth(text, label);
        });
        const maxWidth = Math.max(...widths);
        logger2.log("[LabelWidthSync] Single-column: max width:", maxWidth);
        if (maxWidth > 0) {
          allLabels.forEach((label) => {
            label.style.minWidth = `${maxWidth}px`;
          });
          logger2.log("[LabelWidthSync] Single-column: Applied to", allLabels.length, "labels");
        }
      }
      synchronizeMultiColumn() {
        const tokenLabels = Array.from(
          this.container.querySelectorAll(
            ".sm-cc-setting--token-editor .setting-item-info"
          )
        ).filter((label) => label.offsetParent);
        if (tokenLabels.length === 0) {
          logger2.log("[LabelWidthSync] Multi-column: No token labels found");
          return;
        }
        const normalLabels = Array.from(
          this.container.querySelectorAll(".setting-item-info")
        ).filter((label) => {
          if (!label.offsetParent) return false;
          const parent = label.closest(".sm-cc-setting");
          return parent && !parent.classList.contains("sm-cc-setting--token-editor");
        });
        if (normalLabels.length === 0) {
          logger2.log("[LabelWidthSync] Multi-column: No normal labels, syncing token labels with each other");
          const widths = tokenLabels.map((label) => {
            const text = label.textContent || "";
            return calculateTextWidth(text, label);
          });
          const maxTokenWidth = Math.max(...widths);
          logger2.log("[LabelWidthSync] Multi-column: max token label width:", maxTokenWidth);
          if (maxTokenWidth > 0) {
            tokenLabels.forEach((label) => {
              label.style.minWidth = `${maxTokenWidth}px`;
            });
            logger2.log("[LabelWidthSync] Multi-column: Applied", maxTokenWidth, "px to", tokenLabels.length, "token labels");
          }
          return;
        }
        logger2.log("[LabelWidthSync] Multi-column: Found", tokenLabels.length, "token labels,", normalLabels.length, "normal labels");
        const maxNormalWidth = Math.max(...normalLabels.map((l) => l.getBoundingClientRect().width));
        logger2.log("[LabelWidthSync] Multi-column: max normal label width:", maxNormalWidth);
        if (maxNormalWidth > 0) {
          tokenLabels.forEach((label) => {
            label.style.minWidth = `${maxNormalWidth}px`;
          });
          logger2.log("[LabelWidthSync] Multi-column: Applied", maxNormalWidth, "px to", tokenLabels.length, "token labels");
        }
      }
      destroy() {
        this.resizeObserver.disconnect();
      }
    };
  }
});

// src/features/data-manager/fields/field-renderer-registry.ts
var FieldRendererRegistry, fieldRendererRegistry;
var init_field_renderer_registry = __esm({
  "src/features/data-manager/fields/field-renderer-registry.ts"() {
    "use strict";
    FieldRendererRegistry = class {
      constructor() {
        this.renderers = [];
      }
      /**
       * Register a field renderer.
       */
      register(entry) {
        this.renderers.push(entry);
      }
      /**
       * Render a field using the first matching renderer.
       */
      render(args) {
        for (const renderer of this.renderers) {
          if (renderer.supports(args.spec)) {
            return renderer.render(args);
          }
        }
        const fallback = args.container.createDiv({ cls: "sm-cc-field--unsupported" });
        fallback.createEl("label", { text: args.spec.label });
        fallback.createEl("p", { text: `Unsupported field type: ${args.spec.type}` });
        return { container: fallback };
      }
    };
    fieldRendererRegistry = new FieldRendererRegistry();
  }
});

// src/features/data-manager/fields/token-field-core-new.ts
function renderModularTokenFieldCore(options) {
  const {
    container,
    fields: fields8,
    primaryField,
    value = [],
    chipTemplate,
    className = "sm-cc-token-field",
    onChange,
    getInitialValue,
    formData = {},
    onTokenFieldChange
  } = options;
  const tokens = Array.isArray(value) ? [...value] : [];
  const primaryFieldDef = fields8.find((f) => f.id === primaryField);
  if (!primaryFieldDef) {
    throw new Error(`Primary field "${primaryField}" not found in fields config`);
  }
  const inputEl = container.createEl("input", {
    cls: `${className}__input-el`,
    attr: {
      type: "text",
      placeholder: primaryFieldDef.placeholder ?? "Hinzuf\xFCgen..."
    }
  });
  inputEl.style.minWidth = "260px";
  const addButton = container.createEl("button", {
    text: "+",
    cls: "mod-cta"
  });
  const chipsContainer = document.createElement("div");
  chipsContainer.addClass("sm-cc-chips");
  let suggestionMenuEl = null;
  let activeSuggestionIndex = -1;
  let filteredSuggestions = [];
  const closeSuggestionMenu = () => {
    if (suggestionMenuEl) {
      suggestionMenuEl.remove();
      suggestionMenuEl = null;
    }
    activeSuggestionIndex = -1;
  };
  const openSuggestionMenu = (query) => {
    closeSuggestionMenu();
    const suggestions = primaryFieldDef.suggestions;
    if (!suggestions || suggestions.length === 0) return;
    const lowerQuery = query.toLowerCase();
    if (typeof suggestions[0] === "string") {
      filteredSuggestions = suggestions.filter((s) => s.toLowerCase().includes(lowerQuery)).slice(0, 10);
    } else {
      filteredSuggestions = suggestions.filter((s) => s.label.toLowerCase().includes(lowerQuery) || s.key.toLowerCase().includes(lowerQuery)).slice(0, 10);
    }
    if (filteredSuggestions.length === 0) return;
    suggestionMenuEl = container.parentElement.createDiv({ cls: "sm-cc-suggestion-menu" });
    activeSuggestionIndex = -1;
    filteredSuggestions.forEach((suggestion, index) => {
      const text = typeof suggestion === "string" ? suggestion : suggestion.label;
      const value2 = typeof suggestion === "string" ? suggestion : suggestion.key;
      const item = suggestionMenuEl.createDiv({ cls: "sm-cc-suggestion-item" });
      item.textContent = text;
      item.onclick = () => {
        inputEl.value = value2;
        closeSuggestionMenu();
      };
    });
  };
  const highlightSuggestion = () => {
    if (!suggestionMenuEl) return;
    const items = suggestionMenuEl.querySelectorAll(".sm-cc-suggestion-item");
    items.forEach((item, index) => {
      item.toggleClass("is-active", index === activeSuggestionIndex);
    });
    if (activeSuggestionIndex >= 0 && activeSuggestionIndex < items.length) {
      items[activeSuggestionIndex].scrollIntoView({ block: "nearest" });
    }
  };
  const formatFieldValue = (value2, fieldDef) => {
    if (value2 == null || value2 === "") {
      return fieldDef.placeholder || "-";
    }
    if (fieldDef.type === "select" && fieldDef.suggestions) {
      const suggestion = fieldDef.suggestions.find(
        (s) => typeof s === "object" ? s.key === value2 : s === value2
      );
      if (suggestion && typeof suggestion === "object") {
        return suggestion.label;
      }
    }
    if (fieldDef.type === "checkbox") {
      if (value2) {
        return fieldDef.icon || "\u2713";
      } else {
        if (fieldDef.icon === "\u2605") {
          return "\u2606";
        }
        return "\u2610";
      }
    }
    const str2 = String(value2);
    return fieldDef.unit ? `${str2}${fieldDef.unit}` : str2;
  };
  const renderChips = () => {
    chipsContainer.empty();
    tokens.forEach((token, index) => {
      const chip = chipsContainer.createDiv({ cls: "sm-cc-chip" });
      if (chipTemplate) {
        try {
          chip.createSpan({
            text: chipTemplate(token),
            cls: "sm-cc-chip__text"
          });
        } catch (error) {
          console.error("Chip template error:", error);
          chip.createSpan({ text: JSON.stringify(token), cls: "sm-cc-chip__text" });
        }
      } else {
        for (const fieldDef of fields8) {
          if (!fieldDef.displayInChip) continue;
          if (fieldDef.visibleIf && !fieldDef.visibleIf(token)) continue;
          const segment = chip.createSpan({
            cls: [
              "sm-cc-chip__segment",
              `sm-cc-chip__segment--${fieldDef.type}`,
              fieldDef.editable ? "sm-cc-chip__segment--editable" : ""
            ]
          });
          if (fieldDef.label) {
            segment.createSpan({ text: fieldDef.label, cls: "sm-cc-chip__label" });
          }
          const displayValue = formatFieldValue(token[fieldDef.id], fieldDef);
          segment.createSpan({ text: displayValue, cls: "sm-cc-chip__value" });
          if (fieldDef.editable) {
            segment.onclick = (e) => {
              e.stopPropagation();
              openInlineEditor(segment, token, index, fieldDef);
            };
          }
        }
      }
      const removeBtn = chip.createEl("button", { text: "\xD7", cls: "sm-cc-chip__remove" });
      removeBtn.onclick = () => {
        tokens.splice(index, 1);
        onChange([...tokens]);
        renderChips();
      };
    });
  };
  const openInlineEditor = (segment, token, tokenIndex, fieldDef) => {
    const originalContent = segment.innerHTML;
    segment.empty();
    let editor;
    let getValue;
    switch (fieldDef.type) {
      case "text": {
        const input = segment.createEl("input", {
          cls: "sm-cc-inline-editor sm-cc-inline-editor--text",
          attr: {
            type: "text",
            placeholder: fieldDef.placeholder
          }
        });
        input.value = String(token[fieldDef.id] || "");
        editor = input;
        getValue = () => input.value;
        break;
      }
      case "select": {
        const select = segment.createEl("select", {
          cls: "sm-cc-inline-editor sm-cc-inline-editor--select"
        });
        if (fieldDef.options) {
          for (const opt of fieldDef.options) {
            const option = select.createEl("option", {
              value: opt.value,
              text: opt.label
            });
            if (opt.value === token[fieldDef.id]) {
              option.selected = true;
            }
          }
        } else if (fieldDef.suggestions) {
          for (const sug of fieldDef.suggestions) {
            if (typeof sug === "string") {
              const option = select.createEl("option", { value: sug, text: sug });
              if (sug === token[fieldDef.id]) option.selected = true;
            } else {
              const option = select.createEl("option", { value: sug.key, text: sug.label });
              if (sug.key === token[fieldDef.id]) option.selected = true;
            }
          }
        }
        editor = select;
        getValue = () => select.value;
        break;
      }
      case "checkbox": {
        const oldValue = token[fieldDef.id];
        const newValue = !token[fieldDef.id];
        token[fieldDef.id] = newValue;
        logger2.log(`[TokenField] Checkbox toggled: ${fieldDef.id} ${oldValue} -> ${newValue}`);
        if (onTokenFieldChange) {
          logger2.log(`[TokenField] Calling onTokenFieldChange for ${fieldDef.id}`);
          onTokenFieldChange(token, fieldDef.id, newValue, formData);
        }
        logger2.log(`[TokenField] Calling onChange with tokens:`, JSON.stringify(tokens, null, 2));
        onChange([...tokens]);
        logger2.log(`[TokenField] onChange called, now re-rendering chips`);
        renderChips();
        return;
      }
      case "number-stepper": {
        const input = segment.createEl("input", {
          cls: "sm-cc-inline-editor sm-cc-inline-editor--number",
          attr: {
            type: "number",
            min: String(fieldDef.min ?? ""),
            max: String(fieldDef.max ?? ""),
            step: String(fieldDef.step ?? 1)
          }
        });
        input.value = String(token[fieldDef.id] || fieldDef.default || 0);
        editor = input;
        getValue = () => Number(input.value);
        break;
      }
      default:
        segment.innerHTML = originalContent;
        return;
    }
    editor.focus();
    if (editor instanceof HTMLInputElement && editor.type === "text") {
      editor.select();
    }
    const save = () => {
      const newValue = getValue();
      token[fieldDef.id] = newValue;
      if (onTokenFieldChange) {
        onTokenFieldChange(token, fieldDef.id, newValue, formData);
      }
      onChange([...tokens]);
      renderChips();
    };
    const cancel = () => {
      segment.innerHTML = originalContent;
    };
    editor.addEventListener("blur", () => {
      setTimeout(save, 100);
    });
    editor.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        save();
      } else if (e.key === "Escape") {
        e.preventDefault();
        cancel();
      }
    });
  };
  const addToken = () => {
    const inputValue = inputEl.value.trim();
    if (!inputValue) return;
    let newToken = {};
    if (getInitialValue) {
      newToken = getInitialValue(formData, inputValue);
    } else {
      for (const fieldDef of fields8) {
        if (fieldDef.id === primaryField) {
          newToken[fieldDef.id] = inputValue;
        } else if (fieldDef.default !== void 0) {
          newToken[fieldDef.id] = fieldDef.default;
        }
      }
    }
    tokens.push(newToken);
    onChange([...tokens]);
    inputEl.value = "";
    renderChips();
    closeSuggestionMenu();
  };
  if (primaryFieldDef.suggestions && primaryFieldDef.suggestions.length > 0) {
    inputEl.addEventListener("input", () => {
      openSuggestionMenu(inputEl.value);
    });
    inputEl.addEventListener("focus", () => {
      openSuggestionMenu(inputEl.value);
    });
    inputEl.addEventListener("blur", () => {
      setTimeout(closeSuggestionMenu, 150);
    });
  }
  inputEl.addEventListener("keydown", (e) => {
    if (suggestionMenuEl) {
      if (e.key === "ArrowDown") {
        e.preventDefault();
        activeSuggestionIndex = Math.min(filteredSuggestions.length - 1, activeSuggestionIndex + 1);
        highlightSuggestion();
        return;
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        activeSuggestionIndex = Math.max(0, activeSuggestionIndex - 1);
        highlightSuggestion();
        return;
      } else if (e.key === "Enter" && activeSuggestionIndex >= 0) {
        e.preventDefault();
        const suggestion = filteredSuggestions[activeSuggestionIndex];
        inputEl.value = typeof suggestion === "string" ? suggestion : suggestion.key;
        closeSuggestionMenu();
        return;
      } else if (e.key === "Escape") {
        e.preventDefault();
        closeSuggestionMenu();
        return;
      }
    }
    if (e.key === "Enter") {
      e.preventDefault();
      addToken();
    }
  });
  addButton.onclick = () => addToken();
  renderChips();
  return {
    chipsContainer,
    focus: () => inputEl.focus(),
    update: (newValue) => {
      tokens.splice(0, tokens.length);
      if (Array.isArray(newValue)) {
        tokens.push(...newValue);
      }
      renderChips();
    },
    refresh: renderChips
  };
}
var init_token_field_core_new = __esm({
  "src/features/data-manager/fields/token-field-core-new.ts"() {
    "use strict";
    init_plugin_logger();
  }
});

// src/features/data-manager/fields/field-rendering-core.ts
function normalizeToString(value) {
  if (value == null) return "";
  if (typeof value === "string") return value;
  return String(value);
}
function normalizeToBoolean(value) {
  if (typeof value === "boolean") return value;
  if (value === "true" || value === 1) return true;
  if (value === "false" || value === 0) return false;
  return Boolean(value);
}
function renderTextCore(options) {
  const { container, placeholder = "", value, className = "sm-cc-input", onChange } = options;
  if (placeholder.includes("+2") || placeholder === "z.B. +2") {
    logger2.log("[renderTextCore] Rendering field with placeholder:", placeholder);
    logger2.log("[renderTextCore] Raw value:", value);
    logger2.log("[renderTextCore] Value type:", typeof value);
  }
  const input = container.createEl("input", {
    cls: className,
    attr: {
      type: "text",
      placeholder
    }
  });
  const initialValue = normalizeToString(value);
  if (placeholder.includes("+2") || placeholder === "z.B. +2") {
    logger2.log("[renderTextCore] Normalized value:", initialValue);
    logger2.log("[renderTextCore] Setting input.value to:", initialValue);
  }
  input.value = initialValue;
  input.addEventListener("input", () => {
    onChange(input.value);
  });
  return {
    focus: () => input.focus(),
    update: (newValue) => {
      const next = normalizeToString(newValue);
      if (input.value !== next) {
        input.value = next;
      }
    }
  };
}
function renderTextareaCore(options) {
  const { container, placeholder = "", value, rows = 4, className = "sm-cc-textarea", onChange } = options;
  const textarea = container.createEl("textarea", {
    cls: className,
    attr: {
      rows: String(rows),
      placeholder
    }
  });
  const initialValue = normalizeToString(value);
  textarea.value = initialValue;
  textarea.addEventListener("input", () => {
    onChange(textarea.value);
  });
  return {
    focus: () => textarea.focus(),
    update: (newValue) => {
      const next = normalizeToString(newValue);
      if (textarea.value !== next) {
        textarea.value = next;
      }
    }
  };
}
function renderCheckboxCore(options) {
  const { container, value, className = "sm-cc-checkbox", onChange } = options;
  const checkbox = container.createEl("input", {
    cls: className,
    attr: {
      type: "checkbox"
    }
  });
  const initialValue = normalizeToBoolean(value);
  checkbox.checked = initialValue;
  checkbox.addEventListener("change", () => {
    onChange(checkbox.checked);
  });
  return {
    focus: () => checkbox.focus(),
    update: (newValue) => {
      const next = normalizeToBoolean(newValue);
      if (checkbox.checked !== next) {
        checkbox.checked = next;
      }
    }
  };
}
function renderColorCore(options) {
  const { container, value, className = "sm-cc-color-input", onChange } = options;
  const input = container.createEl("input", {
    cls: className,
    attr: {
      type: "color"
    }
  });
  const normalizeColor3 = (val) => {
    if (typeof val === "string" && /^#[0-9a-fA-F]{6}$/.test(val)) {
      return val;
    }
    return "#000000";
  };
  const initialValue = normalizeColor3(value);
  input.value = initialValue;
  input.addEventListener("input", () => {
    onChange(input.value);
  });
  input.addEventListener("change", () => {
    onChange(input.value);
  });
  return {
    focus: () => input.focus(),
    update: (newValue) => {
      const next = normalizeColor3(newValue);
      if (input.value !== next) {
        input.value = next;
      }
    }
  };
}
function renderMultiselectCore(options) {
  const { container, options: fieldOptions, value, className = "sm-cc-multiselect", onChange } = options;
  const selected = new Set(Array.isArray(value) ? value : []);
  const multiContainer = container.createDiv({ cls: className });
  const checkboxes = [];
  for (const option of fieldOptions) {
    const item = multiContainer.createDiv({ cls: "sm-cc-multiselect-item" });
    const checkbox = item.createEl("input", { attr: { type: "checkbox" } });
    checkbox.value = option.value;
    checkbox.checked = selected.has(option.value);
    const label = item.createEl("label");
    label.textContent = option.label;
    checkbox.addEventListener("change", () => {
      if (checkbox.checked) {
        selected.add(option.value);
      } else {
        selected.delete(option.value);
      }
      onChange(Array.from(selected));
    });
    checkboxes.push(checkbox);
  }
  return {
    update: (newValue) => {
      selected.clear();
      if (Array.isArray(newValue)) {
        for (const entry of newValue) {
          if (typeof entry === "string") {
            selected.add(entry);
          }
        }
      }
      checkboxes.forEach((cb) => {
        cb.checked = selected.has(cb.value);
      });
    }
  };
}
function renderDisplayCore(options) {
  const { container, config, fieldId = "unknown" } = options;
  const displayEl = container.createEl("input", {
    cls: "sm-cc-display-field",
    attr: {
      type: "text",
      disabled: "true",
      readonly: "true"
    }
  });
  if (config.className) {
    displayEl.addClass(config.className);
  }
  if (config.maxWidth) {
    displayEl.style.maxWidth = config.maxWidth;
  }
  if (config.maxTokens && config.maxTokens > 0) {
    setTimeout(() => {
      const sampleText = "M".repeat(config.maxTokens);
      const width = calculateTextWidth(sampleText, displayEl, {
        includePadding: true,
        includeBorder: true,
        extraSpace: 4
        // Small buffer
      });
      displayEl.style.width = `${width}px`;
    }, 0);
  }
  return {
    update: (value, all) => {
      try {
        const computed = config.compute(all ?? {});
        const prefixVal = typeof config.prefix === "function" ? config.prefix(all ?? {}) : config.prefix ?? "";
        const suffixVal = typeof config.suffix === "function" ? config.suffix(all ?? {}) : config.suffix ?? "";
        displayEl.value = `${prefixVal}${computed}${suffixVal}`;
      } catch (error) {
        logger2.warn(`Display field ${fieldId} compute error:`, error);
        displayEl.value = "";
      }
    }
  };
}
function renderHeadingCore(options) {
  const { container, getValue, values } = options;
  const value = getValue ? getValue(values) : String(values ?? "");
  container.createEl("strong", {
    cls: "sm-cc-field-heading",
    text: value
  });
  return {};
}
function renderCompositeCore(options) {
  const {
    container,
    childFields,
    groupBy,
    initialValue: compositeValue,
    onChange,
    renderFieldControl: renderFieldControl2
  } = options;
  const useGrouping = Boolean(groupBy && groupBy.length > 0);
  const compositeContainer = container.createDiv({
    cls: useGrouping ? "sm-cc-composite-grouped" : "sm-cc-composite-grid"
  });
  const childInstances = [];
  const evaluateChildVisibility = (childSpec) => {
    if (!childSpec.visibleIf) return true;
    try {
      return childSpec.visibleIf(compositeValue);
    } catch (error) {
      logger2.error(`Failed to evaluate visibility for ${childSpec.id}:`, error);
      return true;
    }
  };
  const updateChildVisibility = () => {
    for (const child of childInstances) {
      const shouldBeVisible = evaluateChildVisibility(child.spec);
      if (shouldBeVisible !== child.wasVisible) {
        child.wrapper.toggleClass("is-hidden", !shouldBeVisible);
        child.wasVisible = shouldBeVisible;
        if (shouldBeVisible && !child.initialized) {
          child.initialized = true;
          const initConfig = child.spec.config?.init;
          if (initConfig && typeof initConfig === "function") {
            try {
              const initValue = initConfig(compositeValue);
              compositeValue[child.id] = initValue;
              child.handle.update?.(initValue, compositeValue);
              onChange(compositeValue);
            } catch (error) {
              logger2.error(`Failed to initialize ${child.id}:`, error);
            }
          }
        }
      }
    }
  };
  const fieldsToRender = useGrouping && groupBy ? groupBy.flatMap(
    (prefix) => childFields.filter((f) => f.id === prefix || f.id?.startsWith(`${prefix}`))
  ) : childFields;
  for (const childDef of fieldsToRender) {
    const childId = childDef.id ?? "";
    const childSpec = {
      id: childId,
      label: childDef.label ?? childId,
      type: childDef.type ?? "text",
      ...childDef
    };
    const childWrapper = compositeContainer.createDiv({ cls: "sm-cc-composite-item" });
    const childInitial = compositeValue[childId] ?? childSpec.default;
    const childHandle = renderFieldControl2(
      childWrapper,
      childSpec,
      childInitial,
      (childValue) => {
        const oldValue = compositeValue[childId];
        compositeValue[childId] = childValue;
        onChange(compositeValue);
        if (oldValue !== childValue) {
          updateChildVisibility();
        }
      }
    );
    const initiallyVisible = evaluateChildVisibility(childSpec);
    childWrapper.toggleClass("is-hidden", !initiallyVisible);
    childInstances.push({
      id: childId,
      spec: childSpec,
      handle: childHandle,
      wrapper: childWrapper,
      wasVisible: initiallyVisible,
      initialized: initiallyVisible
      // Mark as initialized if initially visible
    });
  }
  return {
    update: (value) => {
      if (typeof value === "object" && value !== null) {
        const valueMap = value;
        for (const child of childInstances) {
          child.handle.update?.(valueMap[child.id], valueMap);
        }
        updateChildVisibility();
      }
    }
  };
}
function renderRepeatingEntryManagerCore(options) {
  const {
    container,
    entries,
    categories,
    filters,
    itemTemplate,
    renderEntry,
    card,
    onChange,
    insertPosition = "end",
    isStatic = false,
    mountEntryManager: mountEntryManager2,
    fieldId = "unknown"
  } = options;
  if (!categories.length) {
    logger2.warn(`Repeating field "${fieldId}" has no categories defined`);
    const errorContainer = container.createDiv({ cls: "sm-cc-field--error" });
    errorContainer.createEl("p", { text: "No categories defined for repeating field" });
    return { error: true };
  }
  if (!renderEntry && !card) {
    logger2.warn(`Repeating field "${fieldId}" requires renderEntry or card in config`);
    const errorContainer = container.createDiv({ cls: "sm-cc-field--error" });
    errorContainer.createEl("p", { text: "No renderer defined for repeating field" });
    return { error: true };
  }
  const createEntry = (category) => {
    const entry = { category };
    for (const [key, fieldDef] of Object.entries(itemTemplate)) {
      if (fieldDef.default !== void 0) {
        entry[key] = fieldDef.default;
      }
    }
    return entry;
  };
  const handle = mountEntryManager2(container, {
    label: "",
    entries,
    categories,
    filters,
    createEntry,
    renderEntry,
    card,
    onEntriesChanged: (updated) => {
      onChange(updated);
    },
    insertPosition,
    hideAddBar: isStatic,
    hideActions: isStatic
  });
  return {
    update: (value) => {
      if (Array.isArray(value)) {
        entries.splice(0, entries.length, ...value);
        handle.rerender();
      }
    }
  };
}
function renderTokenFieldCore(options) {
  return renderModularTokenFieldCore(options);
}
function createRendererWrapper(type2, coreRenderer, options) {
  return {
    supports: (spec) => spec.type === type2,
    render: (args) => {
      const { container, spec, values, onChange } = args;
      const setting = new import_obsidian17.Setting(container);
      if (spec.label) {
        setting.setName(spec.label);
      }
      setting.settingEl.addClass("sm-cc-setting");
      if (spec.help) {
        setting.setDesc(spec.help);
      }
      const validation = options?.createValidationControls?.(setting) ?? { apply: () => {
      } };
      const initial = options?.resolveInitialValue?.(spec, values) ?? values[spec.id];
      const handle = coreRenderer({
        container: setting.controlEl,
        spec,
        initial,
        onChange: (value) => onChange(spec.id, value)
      });
      return {
        ...handle,
        setErrors: validation.apply,
        container: setting.settingEl
      };
    }
  };
}
var import_obsidian17;
var init_field_rendering_core = __esm({
  "src/features/data-manager/fields/field-rendering-core.ts"() {
    "use strict";
    import_obsidian17 = require("obsidian");
    init_plugin_logger();
    init_width_utils();
    init_token_field_core_new();
  }
});

// src/features/data-manager/modal/modal-utils.ts
function createValidationControls(setting) {
  const container = setting.settingEl.createDiv({ cls: "sm-cc-field__errors", attr: { hidden: "" } });
  const list = container.createEl("ul", { cls: "sm-cc-field__errors-list" });
  const apply = (errors) => {
    const hasErrors = errors.length > 0;
    setting.settingEl.toggleClass("is-invalid", hasErrors);
    if (!hasErrors) {
      container.setAttribute("hidden", "");
      container.classList.remove("is-visible");
      list.empty();
      return;
    }
    container.removeAttribute("hidden");
    container.classList.add("is-visible");
    list.empty();
    for (const issue of errors) {
      list.createEl("li", { text: issue });
    }
  };
  return { apply, container };
}
function deepClone(value) {
  if (typeof structuredClone === "function") {
    return structuredClone(value);
  }
  return JSON.parse(JSON.stringify(value));
}
function resolveDefaults(spec, name) {
  const fromSpec = typeof spec.defaults === "function" ? spec.defaults({ presetName: name }) : spec.defaults;
  return fromSpec ? { ...fromSpec } : {};
}
function orderFields(fields8, ids) {
  if (!ids || ids.length === 0) return fields8;
  const lookup = new Map(fields8.map((field) => [field.id, field]));
  const ordered = [];
  for (const id of ids) {
    const entry = lookup.get(id);
    if (!entry) continue;
    ordered.push(entry);
  }
  return ordered;
}
function extractSchemaIssues(error) {
  if (!error || typeof error !== "object") return [];
  const maybeIssues = error.issues;
  if (!Array.isArray(maybeIssues)) return [];
  return maybeIssues.filter((issue) => typeof issue === "object" && issue !== null);
}
var init_modal_utils = __esm({
  "src/features/data-manager/modal/modal-utils.ts"() {
    "use strict";
  }
});

// src/features/data-manager/fields/number-stepper-control.ts
function createNumberInput(parent, options = {}) {
  const input = parent.createEl("input", {
    cls: options.className || "sm-cc-input",
    attr: {
      type: "number",
      placeholder: options.placeholder || "",
      "aria-label": options.ariaLabel || options.placeholder || "Number input"
    }
  });
  if (options.min !== void 0) input.min = String(options.min);
  if (options.max !== void 0) input.max = String(options.max);
  if (options.step !== void 0) input.step = String(options.step);
  if (options.value !== void 0) input.value = String(options.value);
  const parseValue = () => {
    const raw = input.value.trim();
    if (!raw) return { value: void 0, raw };
    const parsed = Number(raw);
    return { value: Number.isFinite(parsed) ? parsed : void 0, raw };
  };
  if (options.onChange) {
    input.addEventListener("change", () => {
      const { value } = parseValue();
      options.onChange(value);
    });
  }
  if (options.onInput) {
    input.addEventListener("input", () => {
      const { value, raw } = parseValue();
      options.onInput(value, raw);
    });
  }
  return input;
}
function createNumberStepper(parent, options = {}) {
  const {
    wrapperClassName,
    buttonClassName,
    decrementClassName,
    incrementClassName,
    decrementLabel = "\u2212",
    decrementAriaLabel = "Decrease value",
    incrementLabel = "+",
    incrementAriaLabel = "Increase value",
    autoSizeOnInput = true,
    // Default: true
    onChange,
    onInput,
    ...inputOptions
  } = options;
  const containerClasses = ["sm-inline-number"];
  if (wrapperClassName) {
    containerClasses.push(...wrapperClassName.split(" ").filter(Boolean));
  }
  const container = parent.createDiv({ cls: containerClasses });
  let input;
  const updateInputSize = () => {
    let measureText;
    if (inputOptions.max !== void 0) {
      measureText = String(inputOptions.max);
    } else {
      measureText = input.value || input.placeholder || "0";
    }
    const width = calculateTextWidth(measureText, input, {
      includePadding: true,
      includeBorder: true,
      extraSpace: 8
    });
    input.style.width = `${width}px`;
  };
  input = createNumberInput(container, {
    ...inputOptions,
    onChange: (value) => {
      onChange?.(value);
    },
    onInput: (value, raw) => {
      if (autoSizeOnInput) {
        updateInputSize();
      }
      onInput?.(value, raw);
    }
  });
  const buttonGroup = container.createDiv({ cls: "sm-number-stepper-buttons" });
  const incrementButton = buttonGroup.createEl("button", {
    text: incrementLabel,
    cls: incrementClassName ?? buttonClassName ?? "btn-compact",
    attr: { type: "button", "aria-label": incrementAriaLabel }
  });
  const decrementButton = buttonGroup.createEl("button", {
    text: decrementLabel,
    cls: decrementClassName ?? buttonClassName ?? "btn-compact",
    attr: { type: "button", "aria-label": decrementAriaLabel }
  });
  const decimalPlaces = (num) => {
    if (!Number.isFinite(num)) return 0;
    const parts = num.toString().split(".");
    return parts[1]?.length ?? 0;
  };
  const getValue = () => {
    const raw = input.value.trim();
    if (!raw) return void 0;
    const parsed = Number(raw);
    return Number.isFinite(parsed) ? parsed : void 0;
  };
  const setValue = (value) => {
    if (value === void 0 || Number.isNaN(value)) {
      input.value = "";
    } else {
      input.value = String(value);
    }
    updateInputSize();
  };
  const notify = () => {
    const value = getValue();
    if (onInput) {
      onInput(value, input.value);
    }
    if (onChange) {
      onChange(value);
    }
  };
  const stepValue = (direction) => {
    const stepSize = inputOptions.step ?? 1;
    const precision = Math.max(decimalPlaces(stepSize), decimalPlaces(getValue() ?? 0));
    const factor = Math.pow(10, precision);
    const baseValue = getValue();
    const current = baseValue ?? inputOptions.min ?? 0;
    let next = (current * factor + direction * stepSize * factor) / factor;
    if (inputOptions.min !== void 0) {
      next = Math.max(inputOptions.min, next);
    }
    if (inputOptions.max !== void 0) {
      next = Math.min(inputOptions.max, next);
    }
    const previousRaw = input.value;
    const rounded = Number(next.toFixed(precision));
    setValue(rounded);
    if (input.value === previousRaw) {
      return;
    }
    notify();
  };
  decrementButton.addEventListener("click", () => {
    stepValue(-1);
  });
  incrementButton.addEventListener("click", () => {
    stepValue(1);
  });
  updateInputSize();
  return {
    container,
    input,
    decrementButton,
    incrementButton,
    getValue,
    setValue
  };
}
var init_number_stepper_control = __esm({
  "src/features/data-manager/fields/number-stepper-control.ts"() {
    "use strict";
    init_width_utils();
  }
});

// src/features/data-manager/fields/select-enhancement.ts
var init_select_enhancement = __esm({
  "src/features/data-manager/fields/select-enhancement.ts"() {
    "use strict";
    init_search_dropdown();
  }
});

// src/features/data-manager/storage/entry-card.ts
function toArray(value) {
  if (!value) return [];
  return Array.isArray(value) ? value : [value];
}
function renderEntryCard(options) {
  const {
    parent,
    context,
    className,
    type: type2,
    badge,
    nameBoxClassName,
    renderName,
    renderBody,
    actions,
    shouldFocus,
    dataset,
    renderHeadExtras
  } = options;
  const classes = /* @__PURE__ */ new Set(["sm-cc-entry-card"]);
  for (const cls of toArray(className)) classes.add(cls);
  const resolvedType = typeof type2 === "function" ? type2(context) : type2;
  if (resolvedType) classes.add(`sm-cc-entry-card--type-${resolvedType}`);
  const card = parent.createDiv({ cls: Array.from(classes).join(" ") });
  if (dataset) {
    for (const [key, value] of Object.entries(dataset)) {
      card.dataset[key] = value;
    }
  }
  const head = card.createDiv({ cls: "sm-cc-entry-head" });
  const resolvedBadge = typeof badge === "function" ? badge(context) : badge;
  let badgeEl = null;
  if (resolvedBadge?.text) {
    const badgeClasses = ["sm-cc-entry-badge"];
    if (resolvedBadge.variant) {
      badgeClasses.push(`sm-cc-entry-badge--${resolvedBadge.variant}`);
    }
    badgeEl = head.createEl("span", {
      cls: badgeClasses.join(" "),
      text: resolvedBadge.text,
      attr: resolvedBadge.title ? { title: resolvedBadge.title } : void 0
    });
  }
  const nameBoxClasses = ["sm-cc-entry-name-box", ...toArray(nameBoxClassName)];
  const nameBox = head.createDiv({ cls: nameBoxClasses.join(" ") });
  let focusTarget = null;
  if (renderName) {
    const result = renderName(nameBox, context);
    if (result instanceof HTMLElement) {
      focusTarget = result;
    }
  }
  const actionsContainer = head.createDiv({ cls: "sm-cc-entry-actions" });
  const resolvedActions = actions ?? {};
  const moveUpHandler = resolvedActions.moveUp ?? context.moveUp;
  const moveDownHandler = resolvedActions.moveDown ?? context.moveDown;
  const canMoveUp = resolvedActions.canMoveUp ?? context.canMoveUp;
  const canMoveDown = resolvedActions.canMoveDown ?? context.canMoveDown;
  const includeMoveButtons = resolvedActions.showMoveButtons ?? Boolean(moveUpHandler || moveDownHandler);
  if (includeMoveButtons && moveUpHandler) {
    const attributes = {
      type: "button",
      "aria-label": resolvedActions.moveUpAriaLabel ?? "Move Up"
    };
    if (!canMoveUp) {
      attributes.disabled = "true";
    }
    const moveUpBtn = actionsContainer.createEl("button", {
      cls: "sm-cc-entry-move-btn",
      attr: attributes
    });
    (0, import_obsidian18.setIcon)(moveUpBtn, "chevron-up");
    moveUpBtn.addEventListener("click", moveUpHandler);
  }
  if (includeMoveButtons && moveDownHandler) {
    const attributes = {
      type: "button",
      "aria-label": resolvedActions.moveDownAriaLabel ?? "Move Down"
    };
    if (!canMoveDown) {
      attributes.disabled = "true";
    }
    const moveDownBtn = actionsContainer.createEl("button", {
      cls: "sm-cc-entry-move-btn",
      attr: attributes
    });
    (0, import_obsidian18.setIcon)(moveDownBtn, "chevron-down");
    moveDownBtn.addEventListener("click", moveDownHandler);
  }
  const deleteHandler = resolvedActions.remove ?? context.remove;
  const includeDeleteButton = resolvedActions.showDeleteButton ?? Boolean(deleteHandler);
  if (includeDeleteButton && deleteHandler) {
    const deleteBtn = actionsContainer.createEl("button", {
      cls: "sm-cc-entry-delete",
      text: resolvedActions.deleteLabel ?? "\xD7",
      attr: {
        type: "button",
        "aria-label": resolvedActions.deleteAriaLabel ?? "Delete Entry"
      }
    });
    deleteBtn.addEventListener("click", deleteHandler);
  }
  const slots = {
    card,
    head,
    badge: badgeEl,
    nameBox,
    actions: actionsContainer
  };
  renderHeadExtras?.(head, context, slots);
  const shouldAutoFocus = shouldFocus ?? context.shouldFocus;
  if (shouldAutoFocus) {
    setTimeout(() => {
      if (focusTarget && typeof focusTarget.focus === "function") {
        focusTarget.focus();
        return;
      }
      const candidate = nameBox.querySelector(
        "input, textarea, select, button, [tabindex]"
      );
      candidate?.focus();
    }, 0);
  }
  renderBody(card, context);
  return slots;
}
var import_obsidian18;
var init_entry_card = __esm({
  "src/features/data-manager/storage/entry-card.ts"() {
    "use strict";
    import_obsidian18 = require("obsidian");
  }
});

// src/features/data-manager/storage/entry-manager.ts
function mountEntryManager(parent, options) {
  if (!options.renderEntry && !options.card) {
    throw new Error("mountEntryManager requires either renderEntry or card configuration");
  }
  const entries = options.entries;
  const wrap = parent.createDiv({ cls: "setting-item sm-cc-entries" });
  if (options.label) {
    wrap.createDiv({ cls: "setting-item-info", text: options.label });
  }
  const control = wrap.createDiv({ cls: "setting-item-control" });
  let focusIndex = null;
  let activeFilter = options.defaultFilter ?? "all";
  const insertPosition = options.insertPosition ?? "start";
  const triggerChange = () => {
    options.onEntriesChanged?.(entries);
  };
  if (!options.hideAddBar) {
    const addBar = control.createDiv({ cls: "sm-cc-entry-add-bar" });
    addBar.createEl("span", { cls: "sm-cc-entry-add-label", text: "Hinzuf\xFCgen:" });
    const addGroup = addBar.createDiv({ cls: "sm-cc-entry-add-group" });
    for (const category of options.categories) {
      const btn = addGroup.createEl("button", {
        cls: ["sm-cc-entry-add-btn", `sm-cc-entry-add-btn--${category.id}`].join(" "),
        text: category.label,
        attr: { type: "button", title: category.title ?? category.label }
      });
      btn.addEventListener("click", () => {
        const created = options.createEntry(category.id);
        if (insertPosition === "end") {
          entries.push(created);
          focusIndex = entries.length - 1;
        } else {
          entries.unshift(created);
          focusIndex = 0;
        }
        triggerChange();
        render();
      });
    }
  }
  const filterBar = control.createDiv({
    cls: "sm-cc-entry-filter",
    attr: { role: "toolbar", "aria-label": "Eintragsliste filtern" }
  });
  const allFilter = {
    id: "all",
    label: "Alle",
    predicate: () => true
  };
  const filterDefinitions = [allFilter];
  if (options.filters) {
    for (const filter of options.filters) {
      filterDefinitions.push({
        id: filter.id,
        label: filter.label,
        hint: filter.hint,
        predicate: filter.predicate
      });
    }
  }
  const filterButtons = /* @__PURE__ */ new Map();
  const filterPredicates = /* @__PURE__ */ new Map();
  const updateFilterButtons = () => {
    for (const [id, button] of filterButtons) {
      const isActive = id === activeFilter;
      button.setAttribute("aria-pressed", isActive ? "true" : "false");
      button.classList.toggle("is-active", isActive);
    }
  };
  for (const filter of filterDefinitions) {
    const button = filterBar.createEl("button", {
      text: filter.label,
      attr: {
        type: "button",
        title: filter.hint,
        "aria-label": filter.hint ?? filter.label,
        "aria-pressed": filter.id === activeFilter ? "true" : "false"
      }
    });
    button.addEventListener("click", () => {
      activeFilter = filter.id;
      updateFilterButtons();
      render();
    });
    filterButtons.set(filter.id, button);
    filterPredicates.set(filter.id, filter.predicate);
  }
  const host = control.createDiv({ cls: "sm-cc-entry-host" });
  const revalidate = options.registerValidation ? options.registerValidation(() => options.collectIssues?.(entries) ?? []) : () => [];
  const render = () => {
    updateFilterButtons();
    host.empty();
    const predicate = filterPredicates.get(activeFilter) ?? (() => true);
    const renderEntry = options.renderEntry ?? ((container, context) => {
      if (!options.card) {
        throw new Error("card factory missing for entry-manager render");
      }
      const config = options.card(context);
      return renderEntryCard({ parent: container, context, ...config }).card;
    });
    entries.forEach((entry, index) => {
      const shouldFocus = focusIndex === index;
      if (shouldFocus) focusIndex = null;
      const context = {
        entry,
        index,
        total: entries.length,
        shouldFocus,
        canMoveUp: options.hideActions ? false : index > 0,
        canMoveDown: options.hideActions ? false : index < entries.length - 1,
        remove: options.hideActions ? () => {
        } : () => {
          entries.splice(index, 1);
          triggerChange();
          focusIndex = index > 0 ? index - 1 : 0;
          render();
        },
        moveUp: options.hideActions ? () => {
        } : () => {
          if (index <= 0) return;
          [entries[index - 1], entries[index]] = [entries[index], entries[index - 1]];
          triggerChange();
          focusIndex = index - 1;
          render();
        },
        moveDown: options.hideActions ? () => {
        } : () => {
          if (index >= entries.length - 1) return;
          [entries[index + 1], entries[index]] = [entries[index], entries[index + 1]];
          triggerChange();
          focusIndex = index + 1;
          render();
        },
        requestRender: () => {
          triggerChange();
          render();
        }
      };
      const card = renderEntry(host, context);
      const isVisible2 = predicate(entry);
      card.classList.toggle("sm-cc-entry-hidden", !isVisible2);
      card.style.display = isVisible2 ? "" : "none";
      card.setAttribute("aria-hidden", isVisible2 ? "false" : "true");
    });
    revalidate();
  };
  render();
  return {
    rerender: render,
    setFilter: (filterId) => {
      if (filterPredicates.has(filterId)) {
        activeFilter = filterId;
        render();
      }
    },
    getActiveFilter: () => activeFilter
  };
}
var init_entry_manager = __esm({
  "src/features/data-manager/storage/entry-manager.ts"() {
    "use strict";
    init_entry_card();
  }
});

// src/features/data-manager/storage/entry-system.ts
var init_entry_system = __esm({
  "src/features/data-manager/storage/entry-system.ts"() {
    "use strict";
    init_entry_card();
    init_entry_manager();
  }
});

// src/features/data-manager/layout/repeating-width-sync.ts
var RepeatingWidthSynchronizer;
var init_repeating_width_sync = __esm({
  "src/features/data-manager/layout/repeating-width-sync.ts"() {
    "use strict";
    init_width_utils();
    RepeatingWidthSynchronizer = class {
      constructor(container) {
        this.container = container;
        this.resizeObserver = new ResizeObserver(() => {
          this.synchronize();
        });
        this.mutationObserver = new MutationObserver((mutations) => {
          const hasVisibilityChange = mutations.some(
            (m) => m.type === "attributes" && m.attributeName === "class" && m.target.classList.contains("sm-cc-repeating-field")
          );
          if (hasVisibilityChange) {
            this.synchronize();
          }
        });
        this.mutationObserver.observe(container, {
          attributes: true,
          attributeFilter: ["class"],
          subtree: true
        });
        setTimeout(() => {
          this.synchronize();
          this.resizeObserver.observe(this.container);
        }, 0);
      }
      /**
       * Groups elements by their field-id data attribute.
       * All fields with id "score" across entries are grouped together, etc.
       */
      groupByFieldId() {
        const groups = /* @__PURE__ */ new Map();
        const items = this.container.querySelectorAll(".sm-cc-repeating-item");
        items.forEach((item) => {
          const fields8 = item.querySelectorAll(".sm-cc-repeating-field:not(.is-hidden)");
          fields8.forEach((field) => {
            const fieldId = field.dataset.fieldId;
            if (!fieldId) return;
            const label = field.querySelector(".sm-cc-field-label");
            if (label && label.offsetParent !== null) {
              const key = `${fieldId}__label`;
              if (!groups.has(key)) groups.set(key, []);
              groups.get(key).push(label);
            }
            const control = field.querySelector(
              ".sm-inline-number input, .sm-cc-display-field, .sm-cc-input, .checkbox-container, .sm-cc-field-heading"
            );
            if (control && control.offsetParent !== null) {
              const key = `${fieldId}__control`;
              if (!groups.has(key)) groups.set(key, []);
              groups.get(key).push(control);
            }
          });
        });
        return groups;
      }
      synchronize() {
        const groups = this.groupByFieldId();
        for (const [groupKey, elements] of groups.entries()) {
          if (elements.length === 0) continue;
          let maxWidth;
          if (groupKey.endsWith("__label")) {
            const widths = elements.map((el) => {
              const text = el.textContent || "";
              return calculateTextWidth(text, el);
            });
            maxWidth = Math.max(...widths);
          } else {
            const widths = elements.map((el) => el.getBoundingClientRect().width);
            maxWidth = Math.max(...widths);
          }
          elements.forEach((el) => {
            if (groupKey.endsWith("__label")) {
              el.style.minWidth = `${maxWidth}px`;
            } else {
              el.style.width = `${maxWidth}px`;
            }
          });
        }
      }
      destroy() {
        this.resizeObserver.disconnect();
        this.mutationObserver.disconnect();
      }
    };
  }
});

// src/app/debug-logger.ts
var debug_logger_exports = {};
__export(debug_logger_exports, {
  debugLogger: () => debugLogger
});
var DebugLogger, debugLogger;
var init_debug_logger = __esm({
  "src/app/debug-logger.ts"() {
    "use strict";
    init_plugin_logger();
    DebugLogger = class {
      constructor() {
        this.config = {
          enabled: false,
          logFields: [],
          logCategories: [],
          logAll: false
        };
      }
      /**
       * Load debug configuration from .claude/debug.json
       * Falls back to disabled if file doesn't exist
       */
      async loadConfig(app) {
        try {
          const configPath = ".obsidian/plugins/salt-marcher/.claude/debug.json";
          const adapter = app.vault.adapter;
          if (!await adapter.exists(configPath)) {
            logger2.log("[DebugLogger] No debug config found, using defaults (all disabled)");
            return;
          }
          const configContent = await adapter.read(configPath);
          this.config = JSON.parse(configContent);
          logger2.log("[DebugLogger] Config loaded:", this.config);
        } catch (error) {
          logger2.log("[DebugLogger] Failed to load config, debug logging disabled:", error);
        }
      }
      /**
       * Log a message for a specific field and category
       * Only logs if the field and category match the config
       *
       * @example
       * debugLogger.logField("saveProf", "onChange", "Value changed", { newValue: true });
       */
      logField(fieldId, category, message, ...args) {
        if (!this.shouldLog(fieldId, category)) return;
        logger2.log(`[${category}:${fieldId}] ${message}`, ...args);
      }
      /**
       * Log a message for a specific category (no field filtering)
       * Useful for general debugging that isn't field-specific
       *
       * @example
       * debugLogger.logCategory("onChange", "Callback chain triggered");
       */
      logCategory(category, message, ...args) {
        if (!this.shouldLogCategory(category)) return;
        logger2.log(`[${category}] ${message}`, ...args);
      }
      /**
       * Check if we should log for this field and category combination
       */
      shouldLog(fieldId, category) {
        if (!this.config.enabled) return false;
        if (this.config.logAll) return true;
        const fieldMatch = this.config.logFields.includes(fieldId) || this.config.logFields.includes("*");
        const categoryMatch = this.config.logCategories.includes(category) || this.config.logCategories.includes("*");
        return fieldMatch && categoryMatch;
      }
      /**
       * Check if we should log for this category (any field)
       */
      shouldLogCategory(category) {
        if (!this.config.enabled) return false;
        if (this.config.logAll) return true;
        return this.config.logCategories.includes(category) || this.config.logCategories.includes("*");
      }
      /**
       * Get current config (for debugging the debugger!)
       */
      getConfig() {
        return { ...this.config };
      }
    };
    debugLogger = new DebugLogger();
  }
});

// src/features/data-manager/fields/clickable-icon.ts
function createClickableIcon(options) {
  const {
    container,
    value: initialValue,
    icon = "\u2605",
    inactiveIcon = "\u2606",
    onChange,
    className = "sm-cc-clickable-icon",
    fieldId = "unknown"
  } = options;
  let currentValue = initialValue;
  debugLogger.logField(fieldId, "field-creation", "ClickableIcon created", { initialValue: currentValue });
  const iconEl = container.createSpan({
    cls: className,
    text: currentValue ? icon : inactiveIcon
  });
  if (currentValue) {
    iconEl.addClass(`${className}--active`);
  }
  iconEl.setAttribute("role", "checkbox");
  iconEl.setAttribute("aria-checked", String(currentValue));
  iconEl.setAttribute("tabindex", "0");
  const updateDisplay = () => {
    iconEl.textContent = currentValue ? icon : inactiveIcon;
    iconEl.toggleClass(`${className}--active`, currentValue);
    iconEl.setAttribute("aria-checked", String(currentValue));
  };
  const toggle = () => {
    const oldValue = currentValue;
    currentValue = !currentValue;
    debugLogger.logField(fieldId, "toggle", "Field toggled", { oldValue, newValue: currentValue });
    updateDisplay();
    debugLogger.logField(fieldId, "onChange", "Calling onChange", { value: currentValue });
    onChange(currentValue);
  };
  iconEl.onclick = (e) => {
    e.stopPropagation();
    toggle();
  };
  iconEl.onkeydown = (e) => {
    if (e.key === " " || e.key === "Enter") {
      e.preventDefault();
      toggle();
    }
  };
  return {
    element: iconEl,
    update: (newValue) => {
      currentValue = newValue;
      updateDisplay();
    },
    setValue: (newValue) => {
      currentValue = newValue;
      updateDisplay();
    }
  };
}
var init_clickable_icon = __esm({
  "src/features/data-manager/fields/clickable-icon.ts"() {
    "use strict";
    init_debug_logger();
  }
});

// src/features/data-manager/fields/field-utils.ts
function resolveInitialValue(spec, values) {
  if (spec.id === "pb") {
    logger2.log("[resolveInitialValue] Resolving pb field");
    logger2.log("[resolveInitialValue] values object:", values);
    logger2.log('[resolveInitialValue] values["pb"]:', values["pb"]);
    logger2.log("[resolveInitialValue] spec.default:", spec.default);
  }
  if (values[spec.id] !== void 0) {
    if (spec.id === "pb") {
      logger2.log("[resolveInitialValue] Returning from values:", values[spec.id]);
    }
    return values[spec.id];
  }
  if (spec.default !== void 0) {
    if (spec.id === "pb") {
      logger2.log("[resolveInitialValue] Returning default:", spec.default);
    }
    return spec.default;
  }
  if (spec.id === "pb") {
    logger2.log("[resolveInitialValue] Returning undefined");
  }
  return void 0;
}
function renderFieldControl(container, spec, initial, onChange, formData) {
  debugLogger.logField(spec.id, "field-creation", "renderFieldControl called", {
    type: spec.type,
    onChangeType: typeof onChange
  });
  const simpleTypes = ["text", "textarea", "markdown", "number-stepper", "checkbox", "select", "multiselect", "color", "display"];
  const shouldAddLabel = simpleTypes.includes(spec.type);
  if (shouldAddLabel && spec.label) {
    const label = container.createEl("label", {
      cls: "sm-cc-field-label",
      text: spec.label
    });
  }
  const controlContainer = container.createDiv({ cls: "sm-cc-field-control" });
  if (spec.type === "text") {
    return renderTextCore({
      container: controlContainer,
      placeholder: spec.placeholder,
      value: initial,
      onChange
    });
  }
  if (spec.type === "textarea" || spec.type === "markdown") {
    const rows = spec.type === "markdown" ? 12 : 4;
    return renderTextareaCore({
      container: controlContainer,
      placeholder: spec.placeholder,
      value: initial,
      rows,
      onChange
    });
  }
  if (spec.type === "number-stepper") {
    const numberStepperSpec = spec;
    const handle2 = createNumberStepper(controlContainer, {
      value: typeof initial === "number" ? initial : void 0,
      min: spec.min,
      max: spec.max,
      step: spec.step,
      autoSizeOnInput: numberStepperSpec.autoSizeOnInput,
      onChange: (value) => {
        onChange(value);
      }
    });
    return {
      focus: () => handle2.input.focus(),
      update: (value) => {
        if (typeof value === "number") {
          handle2.setValue(value);
        } else {
          handle2.setValue(void 0);
        }
      }
    };
  }
  if (spec.type === "checkbox") {
    const checkboxContainer = controlContainer.createDiv({ cls: "checkbox-container" });
    return renderCheckboxCore({
      container: checkboxContainer,
      value: initial,
      onChange
    });
  }
  if (spec.type === "clickable-icon") {
    const iconSpec = spec;
    debugLogger.logField(spec.id, "field-creation", "Creating clickable-icon", { initial });
    const handle2 = createClickableIcon({
      container: controlContainer,
      value: Boolean(initial),
      icon: iconSpec.icon || "\u2605",
      inactiveIcon: iconSpec.inactiveIcon || "\u2606",
      fieldId: spec.id,
      onChange: (value) => {
        debugLogger.logField(spec.id, "onChange-wrapper", "clickable-icon onChange wrapper called", {
          value,
          onChangeType: typeof onChange,
          onChangeDefined: onChange !== void 0
        });
        if (typeof onChange === "function") {
          debugLogger.logField(spec.id, "onChange-wrapper", "Calling parent onChange");
          onChange(value);
          debugLogger.logField(spec.id, "onChange-wrapper", "Parent onChange returned successfully");
        } else {
          logger2.error(`[field-utils] onChange is not a function for "${spec.id}"! Type: ${typeof onChange}`);
        }
      }
    });
    return {
      focus: () => handle2.element.focus(),
      update: (value) => {
        debugLogger.logField(spec.id, "update", "clickable-icon update() called", { value });
        handle2.update(Boolean(value));
      }
    };
  }
  if (spec.type === "select") {
    const selectSpec = spec;
    const select = controlContainer.createEl("select", {
      cls: "dropdown"
    });
    const options = selectSpec.options ?? [];
    for (const opt of options) {
      const optionEl = select.createEl("option", {
        value: opt.value,
        text: opt.label
      });
    }
    const value = initial != null ? String(initial) : options[0]?.value ?? "";
    select.value = value;
    select.addEventListener("change", () => {
      onChange(select.value);
    });
    if (options.length > 10) {
      enhanceSelectToSearch(select);
    }
    return {
      focus: () => select.focus(),
      update: (value2) => {
        select.value = value2 != null ? String(value2) : "";
      }
    };
  }
  if (spec.type === "multiselect") {
    const multiselectSpec = spec;
    const options = multiselectSpec.options ?? [];
    return renderMultiselectCore({
      container: controlContainer,
      options,
      value: initial,
      onChange
    });
  }
  if (spec.type === "color") {
    return renderColorCore({
      container: controlContainer,
      value: initial,
      onChange
    });
  }
  if (spec.type === "display") {
    const displaySpec = spec;
    return renderDisplayCore({
      container: controlContainer,
      config: displaySpec.config,
      fieldId: spec.id
    });
  }
  if (spec.type === "heading") {
    const headingSpec = spec;
    return renderHeadingCore({
      container,
      getValue: headingSpec.getValue,
      values: initial
    });
  }
  if (spec.type === "composite") {
    const compositeSpec = spec;
    const config = compositeSpec.config ?? {};
    const childFields = config.fields ?? compositeSpec.children ?? [];
    const groupBy = config.groupBy;
    const compositeValue = initial ?? {};
    return renderCompositeCore({
      container: controlContainer,
      childFields,
      groupBy,
      initialValue: compositeValue,
      onChange,
      renderFieldControl
    });
  }
  if (spec.type === "autocomplete") {
    const autocompleteSpec = spec;
    const { load: load2, renderSuggestion, onSelect, minQueryLength = 2 } = autocompleteSpec.config;
    const input = controlContainer.createEl("input", {
      cls: "sm-cc-input sm-cc-autocomplete-input",
      attr: { type: "text", placeholder: spec.placeholder ?? "Search..." }
    });
    let suggestionsContainer = null;
    let selectedIndex = -1;
    const hideSuggestions = () => {
      suggestionsContainer?.remove();
      suggestionsContainer = null;
      selectedIndex = -1;
    };
    const showSuggestions = async (query) => {
      if (query.length < minQueryLength) {
        hideSuggestions();
        return;
      }
      const items = await Promise.resolve(load2(query));
      if (items.length === 0) {
        hideSuggestions();
        return;
      }
      if (!suggestionsContainer) {
        suggestionsContainer = controlContainer.createDiv({ cls: "sm-cc-autocomplete-suggestions" });
      }
      suggestionsContainer.empty();
      selectedIndex = -1;
      items.forEach((item, index) => {
        const suggestionEl = suggestionsContainer.createDiv({ cls: "sm-cc-autocomplete-suggestion" });
        suggestionEl.innerHTML = renderSuggestion(item);
        suggestionEl.addEventListener("click", () => {
          const values = initial ?? {};
          onSelect(item, values);
          input.value = "";
          hideSuggestions();
        });
        suggestionEl.addEventListener("mouseenter", () => {
          selectedIndex = index;
          updateSelection();
        });
      });
      updateSelection();
    };
    const updateSelection = () => {
      if (!suggestionsContainer) return;
      const suggestions = suggestionsContainer.querySelectorAll(".sm-cc-autocomplete-suggestion");
      suggestions.forEach((el, index) => {
        el.classList.toggle("is-selected", index === selectedIndex);
      });
    };
    const selectCurrent = () => {
      if (!suggestionsContainer || selectedIndex < 0) return;
      const suggestions = suggestionsContainer.querySelectorAll(".sm-cc-autocomplete-suggestion");
      suggestions[selectedIndex]?.click();
    };
    input.addEventListener("input", () => void showSuggestions(input.value));
    input.addEventListener("blur", () => setTimeout(hideSuggestions, 200));
    input.addEventListener("keydown", (e) => {
      if (!suggestionsContainer) return;
      const count = suggestionsContainer.querySelectorAll(".sm-cc-autocomplete-suggestion").length;
      if (e.key === "ArrowDown") {
        e.preventDefault();
        selectedIndex = (selectedIndex + 1) % count;
        updateSelection();
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        selectedIndex = selectedIndex <= 0 ? count - 1 : selectedIndex - 1;
        updateSelection();
      } else if (e.key === "Enter" && selectedIndex >= 0) {
        e.preventDefault();
        selectCurrent();
      } else if (e.key === "Escape") {
        e.preventDefault();
        hideSuggestions();
      }
    });
    return {
      focus: () => input.focus()
    };
  }
  if (spec.type === "repeating") {
    const repeatingSpec = spec;
    const config = repeatingSpec.config ?? {};
    const isTemplateMode = Boolean(config.fields && config.fields.length > 0);
    const isStatic = Boolean(config.static);
    const entries = Array.isArray(initial) ? [...initial] : [];
    if (isTemplateMode) {
      const listContainer = controlContainer.createDiv({ cls: "sm-cc-repeating-fields" });
      const fieldTemplate = config.fields;
      const fieldHandles = /* @__PURE__ */ new Map();
      const updateEntryFields = (entryContainer, entry, template, allFormData) => {
        const fieldWrappers = entryContainer.querySelectorAll(".sm-cc-repeating-field");
        fieldWrappers.forEach((wrapper, index) => {
          const fieldSpec = template[index];
          if (!fieldSpec) return;
          const wasVisible = !wrapper.hasClass("is-hidden");
          const isVisible2 = !fieldSpec.visibleIf || fieldSpec.visibleIf(entry);
          wrapper.toggleClass("is-hidden", !isVisible2);
          debugLogger.logField(fieldSpec.id, "visibility", "Field visibility check", {
            wasVisible,
            isVisible: isVisible2,
            currentValue: entry[fieldSpec.id]
          });
          if (!wasVisible && isVisible2 && entry[fieldSpec.id] === void 0) {
            debugLogger.logField(fieldSpec.id, "init", "Field became visible, checking init function");
            const initConfig = fieldSpec.config?.init;
            if (initConfig && typeof initConfig === "function") {
              try {
                debugLogger.logField(fieldSpec.id, "init", "Calling init function", entry);
                const initValue = initConfig(entry, allFormData);
                debugLogger.logField(fieldSpec.id, "init", "Init function returned", { initValue });
                entry[fieldSpec.id] = initValue;
                const handleKey = `${wrapper.getAttribute("data-entry-index")}-${fieldSpec.id}`;
                debugLogger.logField(fieldSpec.id, "init", "Looking for handle", { handleKey });
                const handle2 = fieldHandles.get(handleKey);
                if (handle2?.update) {
                  debugLogger.logField(fieldSpec.id, "init", "Found handle, calling update()", { initValue });
                  handle2.update(initValue, entry);
                } else {
                  debugLogger.logField(fieldSpec.id, "init", "No handle found - WARNING", { handleKey });
                  logger2.warn(`[updateEntryFields] No handle found for key: "${handleKey}"`);
                }
              } catch (error) {
                logger2.error(`Failed to initialize ${fieldSpec.id}:`, error);
              }
            } else {
              debugLogger.logField(fieldSpec.id, "init", "No init function configured");
            }
          }
          if (fieldSpec.type === "display") {
            const displaySpec = fieldSpec;
            const displayEl = wrapper.querySelector(".sm-cc-display-field");
            if (displayEl && displaySpec.config?.compute) {
              try {
                const computed = displaySpec.config.compute(entry, allFormData);
                const prefix = typeof displaySpec.config.prefix === "function" ? displaySpec.config.prefix(entry, allFormData) : displaySpec.config.prefix ?? "";
                const suffix = typeof displaySpec.config.suffix === "function" ? displaySpec.config.suffix(entry, allFormData) : displaySpec.config.suffix ?? "";
                displayEl.value = `${prefix}${computed}${suffix}`;
              } catch (error) {
                logger2.warn(`Display field ${fieldSpec.id} compute error:`, error);
                displayEl.value = "";
              }
            }
          }
        });
      };
      entries.forEach((entry, entryIndex) => {
        const entryContainer = listContainer.createDiv({
          cls: "sm-cc-repeating-item",
          attr: { "data-entry-index": String(entryIndex) }
        });
        fieldTemplate.forEach((fieldSpec) => {
          const fieldWrapper = entryContainer.createDiv({
            cls: `sm-cc-repeating-field sm-cc-repeating-field--${fieldSpec.type}`,
            attr: { "data-field-id": fieldSpec.id }
          });
          const isVisible2 = !fieldSpec.visibleIf || fieldSpec.visibleIf(entry);
          if (!isVisible2) {
            fieldWrapper.addClass("is-hidden");
          }
          if (isVisible2 && entry[fieldSpec.id] === void 0) {
            const initConfig = fieldSpec.config?.init;
            if (initConfig && typeof initConfig === "function") {
              try {
                entry[fieldSpec.id] = initConfig(entry, formData || {});
              } catch (error) {
                logger2.error(`Failed to initialize ${fieldSpec.id}:`, error);
              }
            }
          }
          const fieldHandle = renderFieldControl(
            fieldWrapper,
            fieldSpec,
            fieldSpec.type === "heading" ? entry : entry[fieldSpec.id],
            (newValue) => {
              debugLogger.logField(fieldSpec.id, "repeating-onChange", "Repeating field onChange called", { newValue });
              entry[fieldSpec.id] = newValue;
              debugLogger.logField(fieldSpec.id, "repeating-onChange", "Entry updated, calling parent onChange");
              onChange([...entries]);
              debugLogger.logField(fieldSpec.id, "repeating-onChange", "Parent onChange called, now calling updateEntryFields");
              updateEntryFields(entryContainer, entry, fieldTemplate, formData || {});
              debugLogger.logField(fieldSpec.id, "repeating-onChange", "updateEntryFields completed");
            },
            formData
          );
          const handleKey = `${entryIndex}-${fieldSpec.id}`;
          fieldHandles.set(handleKey, fieldHandle);
        });
      });
      let synchronizer;
      if (config.synchronizeWidths) {
        synchronizer = new RepeatingWidthSynchronizer(listContainer);
      }
      entries.forEach((entry, entryIndex) => {
        const entryContainer = listContainer.children[entryIndex];
        if (entryContainer) {
          updateEntryFields(entryContainer, entry, fieldTemplate, formData || {});
        }
      });
      return {
        synchronizer,
        update: (value) => {
          if (Array.isArray(value)) {
            entries.splice(0, entries.length, ...value);
          }
        }
      };
    } else {
      const categories = config.categories ?? [];
      const filters = config.filters ?? void 0;
      const itemTemplate = repeatingSpec.itemTemplate ?? {};
      const renderEntry = config.renderEntry;
      const cardFactory = config.card;
      const handle2 = renderRepeatingEntryManagerCore({
        container: controlContainer,
        entries,
        categories,
        filters,
        itemTemplate,
        renderEntry,
        card: cardFactory,
        onChange,
        insertPosition: config.insertPosition ?? "end",
        isStatic,
        mountEntryManager,
        fieldId: spec.id
      });
      if ("error" in handle2 && handle2.error) {
        return {};
      }
      return handle2;
    }
  }
  const registryArgs = {
    app: null,
    // App not needed for most renderers
    container: controlContainer,
    spec,
    values: { [spec.id]: initial },
    onChange: (id, value) => {
      if (id === spec.id) {
        onChange(value);
      }
    },
    registerValidator: () => {
    }
    // No validation in entry fields
  };
  const handle = fieldRendererRegistry.render(registryArgs);
  if (handle && !handle.container?.querySelector(".sm-cc-field--unsupported")) {
    return {
      focus: handle.focus,
      update: handle.update
    };
  }
  return {};
}
var init_field_utils = __esm({
  "src/features/data-manager/fields/field-utils.ts"() {
    "use strict";
    init_number_stepper_control();
    init_select_enhancement();
    init_entry_system();
    init_repeating_width_sync();
    init_field_rendering_core();
    init_clickable_icon();
    init_field_renderer_registry();
    init_plugin_logger();
    init_debug_logger();
  }
});

// src/features/data-manager/fields/renderer-text.ts
var textFieldRenderer;
var init_renderer_text = __esm({
  "src/features/data-manager/fields/renderer-text.ts"() {
    "use strict";
    init_field_rendering_core();
    init_modal_utils();
    init_field_utils();
    textFieldRenderer = createRendererWrapper(
      "text",
      ({ container, spec, initial, onChange }) => renderTextCore({
        container,
        placeholder: spec.placeholder,
        value: initial,
        onChange
      }),
      { createValidationControls, resolveInitialValue }
    );
  }
});

// src/features/data-manager/fields/renderer-textarea.ts
var textareaFieldRenderer;
var init_renderer_textarea = __esm({
  "src/features/data-manager/fields/renderer-textarea.ts"() {
    "use strict";
    init_field_rendering_core();
    init_modal_utils();
    init_field_utils();
    textareaFieldRenderer = createRendererWrapper(
      "textarea",
      ({ container, spec, initial, onChange }) => renderTextareaCore({
        container,
        placeholder: spec.placeholder,
        value: initial,
        onChange
      }),
      { createValidationControls, resolveInitialValue }
    );
  }
});

// src/features/data-manager/fields/renderer-number-stepper.ts
var numberStepperFieldRenderer;
var init_renderer_number_stepper = __esm({
  "src/features/data-manager/fields/renderer-number-stepper.ts"() {
    "use strict";
    init_field_rendering_core();
    init_modal_utils();
    init_field_utils();
    init_number_stepper_control();
    numberStepperFieldRenderer = createRendererWrapper(
      "number-stepper",
      ({ container, spec, initial, onChange }) => {
        const handle = createNumberStepper(container, {
          value: typeof initial === "number" ? initial : void 0,
          min: spec.min,
          max: spec.max,
          step: spec.step,
          onChange
        });
        return {
          focus: () => handle.input.focus(),
          update: (value) => {
            if (typeof value === "number") {
              handle.setValue(value);
            } else {
              handle.setValue(void 0);
            }
          }
        };
      },
      { createValidationControls, resolveInitialValue }
    );
  }
});

// src/features/data-manager/fields/renderer-checkbox.ts
var checkboxFieldRenderer;
var init_renderer_checkbox = __esm({
  "src/features/data-manager/fields/renderer-checkbox.ts"() {
    "use strict";
    init_field_rendering_core();
    init_modal_utils();
    init_field_utils();
    checkboxFieldRenderer = createRendererWrapper(
      "checkbox",
      ({ container, initial, onChange }) => renderCheckboxCore({
        container: container.createDiv({ cls: "checkbox-container" }),
        value: initial,
        onChange
      }),
      { createValidationControls, resolveInitialValue }
    );
  }
});

// src/features/data-manager/fields/renderer-select.ts
var import_obsidian19, selectFieldRenderer;
var init_renderer_select = __esm({
  "src/features/data-manager/fields/renderer-select.ts"() {
    "use strict";
    import_obsidian19 = require("obsidian");
    init_modal_utils();
    init_field_utils();
    init_select_enhancement();
    init_plugin_logger();
    selectFieldRenderer = {
      supports: (spec) => spec.type === "select",
      render: (args) => {
        const { container, spec, values, onChange } = args;
        const setting = new import_obsidian19.Setting(container).setName(spec.label);
        setting.settingEl.addClass("sm-cc-setting");
        if (spec.help) {
          setting.setDesc(spec.help);
        }
        const validation = createValidationControls(setting);
        const initial = resolveInitialValue(spec, values);
        setting.addDropdown((dropdown) => {
          const options = spec.options ?? [];
          const fallback = typeof initial === "string" ? initial : "";
          if (!options.some((opt) => opt.value === "")) {
            dropdown.addOption("", "");
          }
          for (const option of options) {
            dropdown.addOption(option.value, option.label);
          }
          dropdown.setValue(fallback);
          dropdown.onChange((value) => {
            onChange(spec.id, value || void 0);
          });
          const selectEl = dropdown.selectEl;
          if (selectEl) {
            try {
              enhanceSelectToSearch(selectEl, spec.placeholder ?? "Suchen\u2026");
              if (selectEl._smSearchInput) {
                const currentOption = Array.from(selectEl.options).find((opt) => opt.value === fallback);
                if (currentOption) {
                  selectEl._smSearchInput.value = currentOption.text;
                }
              }
            } catch (error) {
              logger2.warn("Enhance select failed", error);
            }
          }
        });
        return {
          setErrors: validation.apply,
          container: setting.settingEl
        };
      }
    };
  }
});

// src/features/data-manager/fields/renderer-multiselect.ts
var multiselectFieldRenderer;
var init_renderer_multiselect = __esm({
  "src/features/data-manager/fields/renderer-multiselect.ts"() {
    "use strict";
    init_field_rendering_core();
    init_modal_utils();
    init_field_utils();
    multiselectFieldRenderer = createRendererWrapper(
      "multiselect",
      ({ container, spec, initial, onChange }) => renderMultiselectCore({
        container,
        options: spec.options ?? [],
        value: initial,
        onChange
      }),
      { createValidationControls, resolveInitialValue }
    );
  }
});

// src/features/data-manager/fields/renderer-color.ts
var colorFieldRenderer;
var init_renderer_color = __esm({
  "src/features/data-manager/fields/renderer-color.ts"() {
    "use strict";
    init_field_rendering_core();
    init_modal_utils();
    init_field_utils();
    colorFieldRenderer = createRendererWrapper(
      "color",
      ({ container, initial, onChange }) => renderColorCore({
        container,
        value: initial,
        onChange
      }),
      { createValidationControls, resolveInitialValue }
    );
  }
});

// src/features/data-manager/fields/renderer-tokens.ts
var import_obsidian20, tokenFieldRenderer;
var init_renderer_tokens = __esm({
  "src/features/data-manager/fields/renderer-tokens.ts"() {
    "use strict";
    import_obsidian20 = require("obsidian");
    init_modal_utils();
    init_field_rendering_core();
    init_plugin_logger();
    tokenFieldRenderer = {
      supports: (spec) => {
        return spec.type === "tokens";
      },
      render: (args) => {
        const { container, spec, values, onChange } = args;
        const tokenSpec = spec;
        const setting = new import_obsidian20.Setting(container).setName(spec.label);
        setting.settingEl.addClass("sm-cc-setting");
        setting.settingEl.addClass("sm-cc-setting--wide");
        setting.settingEl.addClass("sm-cc-setting--token-editor");
        if (spec.help) {
          setting.setDesc(spec.help);
        }
        const validation = createValidationControls(setting);
        const currentValue = values[spec.id];
        logger2.log(`[TokenRenderer] Field "${spec.id}" currentValue type: ${typeof currentValue}, isArray: ${Array.isArray(currentValue)}, value:`, JSON.stringify(currentValue, null, 2));
        const tokenValues = Array.isArray(currentValue) ? currentValue : Array.isArray(spec.default) ? spec.default : [];
        logger2.log(`[TokenRenderer] Field "${spec.id}" tokenValues:`, JSON.stringify(tokenValues, null, 2));
        const coreOptions = {
          container: setting.controlEl,
          fields: tokenSpec.config.fields,
          primaryField: tokenSpec.config.primaryField,
          value: tokenValues,
          chipTemplate: tokenSpec.config.chipTemplate,
          getInitialValue: tokenSpec.config.getInitialValue,
          formData: values,
          onTokenFieldChange: tokenSpec.config.onTokenFieldChange,
          onChange: (newValue) => {
            logger2.log(`[TokenRenderer] onChange called for field "${spec.id}":`, JSON.stringify(newValue, null, 2));
            tokenValues.splice(0, tokenValues.length, ...newValue);
            onChange(spec.id, [...newValue]);
            logger2.log(`[TokenRenderer] onChange propagated to modal system`);
          }
        };
        const handle = renderTokenFieldCore(coreOptions);
        setting.settingEl.appendChild(handle.chipsContainer);
        return {
          setErrors: validation.apply,
          container: setting.settingEl,
          update: (value) => {
            tokenValues.splice(0, tokenValues.length);
            if (Array.isArray(value)) {
              tokenValues.push(...value);
            }
            handle.refresh();
          }
        };
      }
    };
  }
});

// src/features/data-manager/fields/renderer-display.ts
var displayFieldRenderer;
var init_renderer_display = __esm({
  "src/features/data-manager/fields/renderer-display.ts"() {
    "use strict";
    init_field_rendering_core();
    displayFieldRenderer = {
      supports: (spec) => spec.type === "display",
      render: (args) => {
        const { container, spec, values } = args;
        const displaySpec = spec;
        if (spec.label) {
          const label = container.createEl("label", {
            cls: "sm-cc-field-label",
            text: spec.label
          });
        }
        const controlContainer = container.createDiv({ cls: "sm-cc-field-control" });
        return renderDisplayCore({
          container: controlContainer,
          config: displaySpec.config,
          fieldId: spec.id
        });
      }
    };
  }
});

// src/features/data-manager/fields/renderer-heading.ts
var headingFieldRenderer;
var init_renderer_heading = __esm({
  "src/features/data-manager/fields/renderer-heading.ts"() {
    "use strict";
    headingFieldRenderer = {
      supports: (spec) => spec.type === "heading",
      render: (args) => {
        const { container, spec, values } = args;
        const headingSpec = spec;
        const labelText = headingSpec.getValue ? headingSpec.getValue(values) : spec.label;
        container.createEl("label", {
          cls: "sm-cc-field-label",
          text: labelText
        });
        container.createDiv({ cls: "sm-cc-field-control" });
        return {};
      }
    };
  }
});

// src/features/data-manager/fields/renderer-composite.ts
var import_obsidian21, compositeFieldRenderer;
var init_renderer_composite = __esm({
  "src/features/data-manager/fields/renderer-composite.ts"() {
    "use strict";
    import_obsidian21 = require("obsidian");
    init_modal_utils();
    init_field_utils();
    init_field_rendering_core();
    compositeFieldRenderer = {
      supports: (spec) => spec.type === "composite",
      render: (args) => {
        const { container, spec, values, onChange } = args;
        const setting = new import_obsidian21.Setting(container).setName(spec.label);
        setting.settingEl.addClass("sm-cc-setting");
        if (spec.help) {
          setting.setDesc(spec.help);
        }
        const validation = createValidationControls(setting);
        const initial = resolveInitialValue(spec, values);
        const compositeSpec = spec;
        const config = compositeSpec.config ?? {};
        const childFields = config.fields ?? compositeSpec.children ?? [];
        setting.settingEl.addClass("sm-cc-composite");
        setting.settingEl.addClass("sm-cc-setting--wide");
        const compositeValue = values[spec.id] ?? {};
        const groupBy = config.groupBy;
        const handle = renderCompositeCore({
          container: setting.controlEl,
          childFields,
          groupBy,
          initialValue: compositeValue,
          onChange: (value) => onChange(spec.id, value),
          renderFieldControl
        });
        return {
          setErrors: validation.apply,
          container: setting.settingEl,
          update: handle.update
        };
      }
    };
  }
});

// src/features/data-manager/fields/renderer-autocomplete.ts
var import_obsidian22, autocompleteFieldRenderer;
var init_renderer_autocomplete = __esm({
  "src/features/data-manager/fields/renderer-autocomplete.ts"() {
    "use strict";
    import_obsidian22 = require("obsidian");
    init_modal_utils();
    init_field_utils();
    autocompleteFieldRenderer = {
      supports: (spec) => spec.type === "autocomplete",
      render: (args) => {
        const { container, spec, values, onChange } = args;
        const setting = new import_obsidian22.Setting(container).setName(spec.label);
        setting.settingEl.addClass("sm-cc-setting");
        if (spec.help) {
          setting.setDesc(spec.help);
        }
        const validation = createValidationControls(setting);
        const initial = resolveInitialValue(spec, values);
        const autocompleteSpec = spec;
        const { load: load2, renderSuggestion, onSelect, minQueryLength = 2 } = autocompleteSpec.config;
        const input = setting.controlEl.createEl("input", {
          cls: "sm-cc-input sm-cc-autocomplete-input",
          attr: { type: "text", placeholder: spec.placeholder ?? "Search..." }
        });
        let suggestionsContainer = null;
        let selectedIndex = -1;
        const hideSuggestions = () => {
          suggestionsContainer?.remove();
          suggestionsContainer = null;
          selectedIndex = -1;
        };
        const showSuggestions = async (query) => {
          if (query.length < minQueryLength) {
            hideSuggestions();
            return;
          }
          const items = await Promise.resolve(load2(query));
          if (items.length === 0) {
            hideSuggestions();
            return;
          }
          if (!suggestionsContainer) {
            suggestionsContainer = setting.controlEl.createDiv({ cls: "sm-cc-autocomplete-suggestions" });
          }
          suggestionsContainer.empty();
          selectedIndex = -1;
          items.forEach((item, index) => {
            const suggestionEl = suggestionsContainer.createDiv({ cls: "sm-cc-autocomplete-suggestion" });
            suggestionEl.innerHTML = renderSuggestion(item);
            suggestionEl.addEventListener("click", () => {
              onSelect(item, values);
              input.value = "";
              hideSuggestions();
            });
            suggestionEl.addEventListener("mouseenter", () => {
              selectedIndex = index;
              updateSelection();
            });
          });
          updateSelection();
        };
        const updateSelection = () => {
          if (!suggestionsContainer) return;
          const suggestions = suggestionsContainer.querySelectorAll(".sm-cc-autocomplete-suggestion");
          suggestions.forEach((el, index) => {
            el.classList.toggle("is-selected", index === selectedIndex);
          });
        };
        const selectCurrent = () => {
          if (!suggestionsContainer || selectedIndex < 0) return;
          const suggestions = suggestionsContainer.querySelectorAll(".sm-cc-autocomplete-suggestion");
          suggestions[selectedIndex]?.click();
        };
        input.addEventListener("input", () => void showSuggestions(input.value));
        input.addEventListener("blur", () => setTimeout(hideSuggestions, 200));
        input.addEventListener("keydown", (e) => {
          if (!suggestionsContainer) return;
          const count = suggestionsContainer.querySelectorAll(".sm-cc-autocomplete-suggestion").length;
          if (e.key === "ArrowDown") {
            e.preventDefault();
            selectedIndex = (selectedIndex + 1) % count;
            updateSelection();
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            selectedIndex = selectedIndex <= 0 ? count - 1 : selectedIndex - 1;
            updateSelection();
          } else if (e.key === "Enter" && selectedIndex >= 0) {
            e.preventDefault();
            selectCurrent();
          } else if (e.key === "Escape") {
            e.preventDefault();
            hideSuggestions();
          }
        });
        return {
          setErrors: validation.apply,
          container: setting.settingEl,
          focus: () => input.focus()
        };
      }
    };
  }
});

// src/features/data-manager/fields/renderer-repeating.ts
var import_obsidian23, repeatingFieldRenderer;
var init_renderer_repeating = __esm({
  "src/features/data-manager/fields/renderer-repeating.ts"() {
    "use strict";
    import_obsidian23 = require("obsidian");
    init_modal_utils();
    init_field_utils();
    init_repeating_width_sync();
    init_entry_system();
    init_field_rendering_core();
    init_plugin_logger();
    init_debug_logger();
    repeatingFieldRenderer = {
      supports: (spec) => spec.type === "repeating",
      render: (args) => {
        const { container, spec, values, onChange } = args;
        const setting = new import_obsidian23.Setting(container).setName(spec.label);
        setting.settingEl.addClass("sm-cc-setting");
        if (spec.help) {
          setting.setDesc(spec.help);
        }
        const validation = createValidationControls(setting);
        const initial = resolveInitialValue(spec, values);
        setting.settingEl.addClass("sm-cc-setting--wide");
        const repeatingSpec = spec;
        const config = repeatingSpec.config ?? {};
        const entries = Array.isArray(values[spec.id]) ? [...values[spec.id]] : Array.isArray(spec.default) ? [...spec.default] : [];
        const isTemplateMode = Boolean(config.fields && config.fields.length > 0);
        const isStatic = Boolean(config.static);
        if (isTemplateMode) {
          setting.settingEl.addClass("sm-cc-repeating-list");
          const listContainer = setting.controlEl.createDiv({
            cls: "sm-cc-repeating-fields"
          });
          const fieldTemplate = config.fields;
          const fieldHandles = /* @__PURE__ */ new Map();
          const updateEntryFields = (entryContainer, entry, template, allFormData) => {
            const fieldWrappers = entryContainer.querySelectorAll(
              ".sm-cc-repeating-field"
            );
            fieldWrappers.forEach((wrapper, index) => {
              const fieldSpec = template[index];
              if (!fieldSpec) return;
              const wasVisible = !wrapper.hasClass("is-hidden");
              const isVisible2 = !fieldSpec.visibleIf || fieldSpec.visibleIf(entry);
              wrapper.toggleClass("is-hidden", !isVisible2);
              debugLogger.logField(fieldSpec.id, "visibility", "Field visibility check", {
                wasVisible,
                isVisible: isVisible2,
                currentValue: entry[fieldSpec.id]
              });
              if (!wasVisible && isVisible2 && entry[fieldSpec.id] === void 0) {
                debugLogger.logField(fieldSpec.id, "init", "Field became visible, checking init function");
                const initConfig = fieldSpec.config?.init;
                if (initConfig && typeof initConfig === "function") {
                  try {
                    debugLogger.logField(fieldSpec.id, "init", "Calling init function", entry);
                    const initValue = initConfig(entry, allFormData);
                    debugLogger.logField(fieldSpec.id, "init", "Init function returned", { initValue });
                    entry[fieldSpec.id] = initValue;
                    const handleKey = `${wrapper.closest(".sm-cc-repeating-item")?.getAttribute("data-entry-index")}-${fieldSpec.id}`;
                    debugLogger.logField(fieldSpec.id, "init", "Looking for handle", { handleKey });
                    const handle = fieldHandles.get(handleKey);
                    if (handle?.update) {
                      debugLogger.logField(fieldSpec.id, "init", "Found handle, calling update()", { initValue });
                      handle.update(initValue, entry);
                    } else {
                      debugLogger.logField(fieldSpec.id, "init", "No handle found - WARNING", { handleKey });
                      logger2.warn(`[updateEntryFields] No handle found for key: "${handleKey}"`);
                    }
                  } catch (error) {
                    logger2.error(`Failed to initialize ${fieldSpec.id}:`, error);
                  }
                } else {
                  debugLogger.logField(fieldSpec.id, "init", "No init function configured");
                }
              }
              if (fieldSpec.type === "display") {
                const displaySpec = fieldSpec;
                const displayEl = wrapper.querySelector(".sm-cc-display-field");
                if (displayEl && displaySpec.config?.compute) {
                  try {
                    const computed = displaySpec.config.compute(entry, allFormData);
                    const prefix = typeof displaySpec.config.prefix === "function" ? displaySpec.config.prefix(entry, allFormData) : displaySpec.config.prefix ?? "";
                    const suffix = typeof displaySpec.config.suffix === "function" ? displaySpec.config.suffix(entry, allFormData) : displaySpec.config.suffix ?? "";
                    displayEl.value = `${prefix}${computed}${suffix}`;
                  } catch (error) {
                    logger2.warn(`Display field ${fieldSpec.id} compute error:`, error);
                    displayEl.value = "";
                  }
                }
              }
            });
          };
          entries.forEach((entry, entryIndex) => {
            const entryContainer = listContainer.createDiv({
              cls: "sm-cc-repeating-item",
              attr: { "data-entry-index": String(entryIndex) }
            });
            fieldTemplate.forEach((fieldSpec, fieldIndex) => {
              const fieldWrapper = entryContainer.createDiv({
                cls: `sm-cc-repeating-field sm-cc-repeating-field--${fieldSpec.type}`,
                attr: { "data-field-id": fieldSpec.id }
              });
              const isVisible2 = !fieldSpec.visibleIf || fieldSpec.visibleIf(entry);
              if (!isVisible2) {
                fieldWrapper.addClass("is-hidden");
              }
              if (isVisible2 && entry[fieldSpec.id] === void 0) {
                const initConfig = fieldSpec.config?.init;
                if (initConfig && typeof initConfig === "function") {
                  try {
                    entry[fieldSpec.id] = initConfig(entry, values);
                  } catch (error) {
                    logger2.error(`Failed to initialize ${fieldSpec.id}:`, error);
                  }
                }
              }
              const fieldHandle = renderFieldControl(
                fieldWrapper,
                fieldSpec,
                // For heading fields, pass entire entry object so getValue can access any property
                // For other fields, pass the specific field value
                fieldSpec.type === "heading" ? entry : entry[fieldSpec.id],
                (newValue) => {
                  entry[fieldSpec.id] = newValue;
                  onChange(spec.id, [...entries]);
                  updateEntryFields(entryContainer, entry, fieldTemplate, values);
                },
                values
                // Pass formData so nested fields can access it
              );
              const handleKey = `${entryIndex}-${fieldSpec.id}`;
              fieldHandles.set(handleKey, fieldHandle);
            });
          });
          let synchronizer;
          if (config.synchronizeWidths) {
            synchronizer = new RepeatingWidthSynchronizer(listContainer);
          }
          entries.forEach((entry, entryIndex) => {
            const entryContainer = listContainer.children[entryIndex];
            if (entryContainer) {
              updateEntryFields(entryContainer, entry, fieldTemplate, values);
            }
          });
          return {
            setErrors: validation.apply,
            container: setting.settingEl,
            synchronizer,
            update: (value) => {
              if (Array.isArray(value)) {
                entries.splice(0, entries.length, ...value);
              }
            }
          };
        } else {
          const categories = config.categories ?? [];
          const filters = config.filters ?? void 0;
          const itemTemplate = repeatingSpec.itemTemplate ?? {};
          const renderEntry = config.renderEntry;
          const cardFactory = config.card;
          const handle = renderRepeatingEntryManagerCore({
            container: setting.controlEl,
            entries,
            categories,
            filters,
            itemTemplate,
            renderEntry,
            card: cardFactory,
            onChange: (updated) => onChange(spec.id, updated),
            insertPosition: config.insertPosition ?? "end",
            isStatic,
            mountEntryManager,
            fieldId: spec.id
          });
          if ("error" in handle && handle.error) {
            const fallback = container.createDiv({ cls: "sm-cc-field--error" });
            fallback.createEl("label", { text: spec.label });
            return { container: fallback };
          }
          return {
            setErrors: validation.apply,
            container: setting.settingEl,
            update: handle.update
          };
        }
      }
    };
  }
});

// src/features/data-manager/fields/register-renderers.ts
function registerAllFieldRenderers() {
  fieldRendererRegistry.register(textFieldRenderer);
  fieldRendererRegistry.register(textareaFieldRenderer);
  fieldRendererRegistry.register(numberStepperFieldRenderer);
  fieldRendererRegistry.register(checkboxFieldRenderer);
  fieldRendererRegistry.register(selectFieldRenderer);
  fieldRendererRegistry.register(multiselectFieldRenderer);
  fieldRendererRegistry.register(colorFieldRenderer);
  fieldRendererRegistry.register(tokenFieldRenderer);
  fieldRendererRegistry.register(displayFieldRenderer);
  fieldRendererRegistry.register(headingFieldRenderer);
  fieldRendererRegistry.register(compositeFieldRenderer);
  fieldRendererRegistry.register(autocompleteFieldRenderer);
  fieldRendererRegistry.register(repeatingFieldRenderer);
}
var init_register_renderers = __esm({
  "src/features/data-manager/fields/register-renderers.ts"() {
    "use strict";
    init_field_renderer_registry();
    init_renderer_text();
    init_renderer_textarea();
    init_renderer_number_stepper();
    init_renderer_checkbox();
    init_renderer_select();
    init_renderer_multiselect();
    init_renderer_color();
    init_renderer_tokens();
    init_renderer_display();
    init_renderer_heading();
    init_renderer_composite();
    init_renderer_autocomplete();
    init_renderer_repeating();
  }
});

// src/features/data-manager/modal/data-initializer.ts
var DataInitializer;
var init_data_initializer = __esm({
  "src/features/data-manager/modal/data-initializer.ts"() {
    "use strict";
    init_modal_utils();
    init_plugin_logger();
    DataInitializer = class {
      constructor(options) {
        this.options = options;
      }
      /**
       * Initialize draft data with all sources merged in correct order.
       */
      initialize() {
        const name = this.resolveName();
        const base = this.createBase(name);
        const withDefaults = this.applyDefaults(base, name);
        const withPreset = this.applyPreset(withDefaults);
        const final = this.applyCustomInitializer(withPreset);
        return final;
      }
      /**
       * Resolve the name from preset or generate default name.
       */
      resolveName() {
        const { preset } = this.options;
        const defaultName = this.resolveDefaultName();
        if (typeof preset === "string") {
          return preset;
        }
        if (typeof preset === "object" && preset && "name" in preset) {
          const nameValue = preset.name;
          return typeof nameValue === "string" && nameValue.trim() ? nameValue : defaultName;
        }
        return defaultName;
      }
      /**
       * Create base draft with name and filename.
       */
      createBase(name) {
        const draft = { name };
        const filenameField = this.options.spec.storage.filenameFrom;
        if (draft[filenameField] === void 0) {
          draft[filenameField] = name;
        }
        return draft;
      }
      /**
       * Apply defaults from spec.defaults and field defaults.
       */
      applyDefaults(base, name) {
        const { spec } = this.options;
        const specDefaults = resolveDefaults(spec, name);
        let result = { ...base, ...specDefaults };
        for (const field of spec.fields) {
          if (result[field.id] !== void 0) {
            continue;
          }
          if (field.default !== void 0) {
            result[field.id] = field.default;
          }
        }
        const filenameField = spec.storage.filenameFrom;
        if (result[filenameField] === void 0) {
          result[filenameField] = result.name;
        }
        return result;
      }
      /**
       * Apply preset data (if preset is an object).
       */
      applyPreset(data) {
        const { preset } = this.options;
        if (preset && typeof preset === "object") {
          if ("pb" in preset || "initiative" in preset) {
            logger2.debug("[data-initializer] Preset contains numeric fields", {
              pb: preset.pb,
              initiative: preset.initiative
            });
          }
          if ("passivesList" in preset) {
            logger2.debug("[data-initializer] Preset passivesList", { passivesList: preset.passivesList });
          }
          if ("languagesList" in preset) {
            logger2.debug("[data-initializer] Preset languagesList", { languagesList: preset.languagesList });
          }
          if ("sensesList" in preset) {
            logger2.debug("[data-initializer] Preset sensesList", { sensesList: preset.sensesList });
          }
          return { ...data, ...preset };
        }
        return data;
      }
      /**
       * Apply custom initializer function (if provided).
       */
      applyCustomInitializer(data) {
        const { customInitializer } = this.options;
        if (!customInitializer) {
          return data;
        }
        const adjusted = customInitializer(deepClone(data));
        if (adjusted && typeof adjusted === "object") {
          return { ...data, ...adjusted };
        }
        return data;
      }
      /**
       * Resolve default name from name field default or spec.kind.
       */
      resolveDefaultName() {
        const { spec } = this.options;
        const nameField = spec.fields.find((field) => field.id === "name");
        if (nameField && typeof nameField.default === "string" && nameField.default.trim()) {
          return nameField.default;
        }
        const kind = spec.kind || "Eintrag";
        const normalized = kind.charAt(0).toUpperCase() + kind.slice(1);
        return `Neue/r ${normalized}`;
      }
    };
  }
});

// src/features/data-manager/storage/storage.ts
function slugify(value) {
  const trimmed = value.trim().toLowerCase();
  const replaced = trimmed.normalize("NFKD").replace(/\p{Diacritic}/gu, "").replace(/[^a-z0-9]+/g, "-").replace(/-{2,}/g, "-").replace(/^-+|-+$/g, "");
  return replaced || "entry";
}
function preserveCaseSlugify(value) {
  const trimmed = value.trim();
  const replaced = trimmed.normalize("NFKD").replace(/\p{Diacritic}/gu, "").replace(/[^a-zA-Z0-9]+/g, "-").replace(/-{2,}/g, "-").replace(/^-+|-+$/g, "");
  return replaced || "entry";
}
function ensureExtension(path, extension) {
  if (path.toLowerCase().endsWith(`.${extension}`)) return path;
  return `${path}.${extension}`;
}
function applyTemplate(template, replacements) {
  return template.replace(/\{([^}]+)\}/g, (_, key) => {
    const replacement = replacements[key];
    return replacement ?? "";
  });
}
function collectReplacements(values, preserveCase = false) {
  const map2 = {};
  for (const [key, raw] of Object.entries(values)) {
    if (raw == null) continue;
    map2[key] = typeof raw === "string" ? raw : String(raw);
  }
  if (values.name) {
    const nameStr = String(values.name);
    map2.slug = preserveCase ? preserveCaseSlugify(nameStr) : slugify(nameStr);
    map2.name = nameStr;
  }
  return map2;
}
function resolveTargetPath(storage, values) {
  const preserveCase = storage.preserveCase ?? false;
  const replacements = collectReplacements(values, preserveCase);
  const filenameSource = values[storage.filenameFrom];
  const slugFn = preserveCase ? preserveCaseSlugify : slugify;
  const slug = typeof filenameSource === "string" ? slugFn(filenameSource) : slugFn(String(filenameSource ?? "entry"));
  replacements.slug = slug;
  replacements.filename = slug;
  const templatePath = applyTemplate(storage.pathTemplate, replacements);
  const extension = storage.format === "md-frontmatter" || storage.format === "codeblock" ? "md" : storage.format === "json" ? "json" : "yaml";
  const target = ensureExtension(templatePath, extension);
  if (storage.directory) {
    const sanitizedDir = (0, import_obsidian24.normalizePath)(storage.directory);
    const fileName = target.split("/").pop() ?? target;
    return (0, import_obsidian24.normalizePath)(`${sanitizedDir}/${fileName}`);
  }
  return (0, import_obsidian24.normalizePath)(target);
}
function buildFrontmatter(values, storage) {
  const frontmatter = {};
  if (Array.isArray(storage.frontmatter)) {
    for (const key of storage.frontmatter) {
      if (values[key] !== void 0) {
        frontmatter[key] = values[key];
      }
    }
  } else if (storage.frontmatter) {
    for (const [fieldId, fmKey] of Object.entries(storage.frontmatter)) {
      if (values[fieldId] !== void 0) {
        frontmatter[fmKey] = values[fieldId];
      }
    }
  }
  if (!("name" in frontmatter) && typeof values.name === "string") {
    frontmatter.name = values.name;
  }
  return frontmatter;
}
function buildMarkdownBody(values, storage) {
  if (storage.bodyTemplate) {
    return storage.bodyTemplate(values);
  }
  if (storage.bodyFields?.length) {
    const parts = [];
    for (const fieldId of storage.bodyFields) {
      const value = values[fieldId];
      if (value == null) continue;
      if (typeof value === "string") {
        parts.push(value);
      } else if (Array.isArray(value)) {
        parts.push(value.join(", "));
      } else {
        parts.push(String(value));
      }
    }
    return parts.join("\n\n");
  }
  return "";
}
function serializeMarkdown(storage, values, path) {
  const frontmatter = buildFrontmatter(values, storage);
  const body = buildMarkdownBody(values, storage);
  const fm2 = (0, import_obsidian24.stringifyYaml)(frontmatter ?? {});
  const content = [`---`, fm2.trimEnd(), `---`, "", body.trimEnd()].join("\n").trimEnd() + "\n";
  return { path, content, metadata: { frontmatter, format: storage.format } };
}
function serializeJson(values, path) {
  const content = JSON.stringify(values, null, 2) + "\n";
  return { path, content, metadata: { format: "json" } };
}
function serializeYaml(values, path) {
  const content = (0, import_obsidian24.stringifyYaml)(values ?? {}) + "\n";
  return { path, content, metadata: { format: "yaml" } };
}
function serializeCodeblock(storage, values, path) {
  if (!storage.blockRenderer) {
    throw new Error("Codeblock storage requires a blockRenderer definition");
  }
  const raw = storage.blockRenderer.serialize(values);
  const content = typeof raw === "string" ? raw.trim() : String(raw ?? "");
  return {
    path,
    content,
    metadata: {
      format: "codeblock",
      language: storage.blockRenderer.language,
      values
    }
  };
}
function buildSerializedPayload(storage, values) {
  const path = resolveTargetPath(storage, values);
  switch (storage.format) {
    case "json":
      return serializeJson(values, path);
    case "yaml":
      return serializeYaml(values, path);
    case "codeblock":
      return serializeCodeblock(storage, values, path);
    case "md-frontmatter":
    default:
      return serializeMarkdown(storage, values, path);
  }
}
function ensureFolder2(app, path) {
  const parts = path.split("/");
  parts.pop();
  const folder = parts.join("/");
  if (!folder) return Promise.resolve();
  const normalized = (0, import_obsidian24.normalizePath)(folder);
  const existing = app.vault.getAbstractFileByPath(normalized);
  if (existing) return Promise.resolve();
  return app.vault.createFolder(normalized).catch(() => {
  });
}
function toContentString(content) {
  if (typeof content === "string") return content;
  return JSON.stringify(content, null, 2);
}
async function persistSerializedPayload(app, storage, payload) {
  await storage.hooks?.ensureDirectory?.(app);
  await ensureFolder2(app, payload.path);
  await storage.hooks?.beforeWrite?.(payload);
  const existing = app.vault.getAbstractFileByPath(payload.path);
  let file;
  const content = toContentString(payload.content);
  if (storage.format === "codeblock") {
    if (!storage.blockRenderer) {
      throw new Error("Codeblock storage requires a blockRenderer definition");
    }
    const language = storage.blockRenderer.language;
    const fence = "```";
    const blockRegex = new RegExp(`^\\s*${fence}${language}(?:\\s|$)[\\s\\S]*?${fence}`, "im");
    const normalizedBlock = content.trim();
    const blockWithNewline = normalizedBlock.endsWith("\\n") ? normalizedBlock : `${normalizedBlock}\\n`;
    if (existing instanceof import_obsidian24.TFile) {
      const current = await app.vault.read(existing);
      const trimmedCurrent = current.trimEnd();
      const replacement = blockWithNewline.trimEnd();
      const hasBlock = blockRegex.test(current);
      const next = hasBlock ? current.replace(blockRegex, replacement) : `${trimmedCurrent}\\n\\n${replacement}`;
      await app.vault.modify(existing, next.trimEnd() + "\\n");
      file = existing;
    } else {
      const initial = storage.bodyTemplate ? storage.bodyTemplate({ ...payload.metadata?.values ?? {}, block: blockWithNewline }) : blockWithNewline;
      file = await app.vault.create(payload.path, initial.endsWith("\\n") ? initial : `${initial}\\n`);
    }
  } else {
    if (existing instanceof import_obsidian24.TFile) {
      await app.vault.modify(existing, content);
      file = existing;
    } else {
      file = await app.vault.create(payload.path, content);
    }
  }
  const result = { filePath: payload.path, file };
  await storage.hooks?.afterWrite?.(result);
  return result;
}
var import_obsidian24;
var init_storage = __esm({
  "src/features/data-manager/storage/storage.ts"() {
    "use strict";
    import_obsidian24 = require("obsidian");
  }
});

// src/features/data-manager/modal/modal-persistence.ts
var ModalPersistence;
var init_modal_persistence = __esm({
  "src/features/data-manager/modal/modal-persistence.ts"() {
    "use strict";
    init_storage();
    ModalPersistence = class {
      constructor(app, spec, transformer) {
        this.app = app;
        this.spec = spec;
        this.transformer = transformer;
      }
      /**
       * Save draft data: transform → parse → serialize → persist
       */
      async save(data) {
        const serialized = await this.serialize(data);
        const result = await this.persist(serialized);
        return result;
      }
      /**
       * Serialize draft to payload (transform + parse + build payload)
       */
      async serialize(draft) {
        const transformed = this.transformer.apply(draft);
        const parsed = this.spec.schema.parse(transformed);
        const prepared = this.spec.transformers?.preSave ? this.spec.transformers.preSave(parsed) : parsed;
        const payload = buildSerializedPayload(
          this.spec.storage,
          prepared
        );
        return { values: prepared, payload };
      }
      /**
       * Persist serialized payload to vault
       */
      async persist(serialized) {
        const result = await persistSerializedPayload(
          this.app,
          this.spec.storage,
          serialized.payload
        );
        return {
          filePath: result.filePath,
          values: serialized.values
        };
      }
    };
  }
});

// src/features/data-manager/modal/modal-validator.ts
var DefaultFieldTransformer, ModalValidator;
var init_modal_validator = __esm({
  "src/features/data-manager/modal/modal-validator.ts"() {
    "use strict";
    init_modal_utils();
    init_plugin_logger();
    DefaultFieldTransformer = class {
      constructor(fields8) {
        this.fields = fields8;
      }
      /**
       * Apply all field transforms to data.
       * Returns a new object with transformed values.
       */
      apply(data) {
        const result = { ...data };
        for (const field of this.fields) {
          if (!field.transform) continue;
          try {
            const transformed = field.transform(result[field.id], result);
            result[field.id] = transformed;
          } catch (error) {
            logger2.error(`Transform failed for field ${field.id}`, error);
          }
        }
        return result;
      }
    };
    ModalValidator = class {
      constructor(spec, fieldInstances, data, customValidators, transformer) {
        this.spec = spec;
        this.fieldInstances = fieldInstances;
        this.data = data;
        this.customValidators = customValidators;
        this.transformer = transformer;
      }
      /**
       * Run comprehensive validation:
       * 1. Field validation (required, custom validate functions)
       * 2. Field transforms
       * 3. Schema validation
       * 4. Custom validators
       */
      validate() {
        const summary = [];
        const fieldErrors = this.validateFields();
        for (const [id, errors] of fieldErrors) {
          if (errors.length > 0) {
            const instance = this.fieldInstances.get(id);
            if (instance) {
              summary.push(`${instance.spec.label}: ${errors[0]}`);
            }
          }
        }
        const transformed = this.transformer.apply(this.data());
        const schemaErrors = this.validateSchema(transformed, fieldErrors);
        summary.push(...schemaErrors);
        const customErrors = this.runCustomValidators();
        summary.push(...customErrors);
        this.applyFieldErrors(fieldErrors);
        const isValid = summary.length === 0;
        if (!isValid) {
          const errorObj = {};
          for (const [id, errors] of fieldErrors) {
            if (errors.length > 0) {
              errorObj[id] = errors;
            }
          }
          logger2.log("[UI-TEST] Validation errors:", JSON.stringify({ errors: errorObj, summary }));
        } else {
          logger2.log("[UI-TEST] Validation passed");
        }
        return {
          isValid,
          errors: fieldErrors,
          summary,
          transformed: isValid ? transformed : void 0
        };
      }
      /**
       * Validate all fields: required and custom validate functions.
       */
      validateFields() {
        const fieldErrors = /* @__PURE__ */ new Map();
        const currentData = this.data();
        for (const [id, instance] of this.fieldInstances) {
          if (!instance.isVisible) {
            instance.handle.setErrors?.([]);
            fieldErrors.set(id, []);
            continue;
          }
          const value = currentData[id];
          const errors = [];
          if (instance.spec.required) {
            if (value === void 0 || value === null || value === "") {
              errors.push("Pflichtfeld");
            } else if (Array.isArray(value) && value.length === 0) {
              errors.push("Mindestens ein Wert erforderlich");
            }
          }
          if (instance.spec.validate) {
            try {
              const result = instance.spec.validate(value, currentData);
              if (typeof result === "string" && result.trim()) {
                errors.push(result.trim());
              }
            } catch (error) {
              errors.push(String(error));
            }
          }
          fieldErrors.set(id, errors);
        }
        return fieldErrors;
      }
      /**
       * Validate transformed data with schema.
       * Adds schema errors to existing field errors.
       */
      validateSchema(transformed, fieldErrors) {
        const summary = [];
        const schema2 = this.spec.schema.safeParse(transformed);
        if (!schema2.success) {
          const issues = extractSchemaIssues(schema2.error);
          if (issues.length === 0) {
            summary.push(String(schema2.error));
          }
          for (const issue of issues) {
            const target = issue.path?.[0];
            if (typeof target === "string" && fieldErrors.has(target)) {
              const list = fieldErrors.get(target);
              if (issue.message) {
                list.push(issue.message);
              }
              summary.push(`${target}: ${issue.message ?? "Ung\xFCltiger Wert"}`);
            } else if (issue.message) {
              summary.push(issue.message);
            }
          }
        }
        return summary;
      }
      /**
       * Run custom validator functions (used in navigation mode).
       */
      runCustomValidators() {
        const collected = [];
        for (const validator of this.customValidators) {
          collected.push(...validator());
        }
        return collected;
      }
      /**
       * Apply field errors to UI (set errors on field handles).
       */
      applyFieldErrors(errors) {
        for (const [id, instance] of this.fieldInstances) {
          const fieldErrors = errors.get(id) ?? [];
          instance.handle.setErrors?.(fieldErrors);
        }
      }
    };
  }
});

// src/features/data-manager/fields/field-manager.ts
var FieldManager;
var init_field_manager = __esm({
  "src/features/data-manager/fields/field-manager.ts"() {
    "use strict";
    init_field_renderer_registry();
    init_modal_utils();
    init_plugin_logger();
    FieldManager = class {
      constructor(fields8, getData, onChange, widthSynchronizers) {
        this.fields = fields8;
        this.getData = getData;
        this.onChange = onChange;
        this.widthSynchronizers = widthSynchronizers;
        this.fieldInstances = /* @__PURE__ */ new Map();
      }
      /**
       * Render fields in container, optionally filtered by fieldIds.
       * If fieldIds is undefined, renders all fields.
       */
      renderFields(container, fieldIds) {
        const ordered = orderFields(this.fields, fieldIds);
        for (const field of ordered) {
          this.renderSingleField(container, field);
        }
        this.updateVisibility();
      }
      /**
       * Render a single field and register its instance.
       */
      renderSingleField(container, field) {
        const values = this.getData();
        if (field.id === "pb") {
          logger2.log("[field-manager] Rendering pb field");
          logger2.log("[field-manager] values object:", values);
          logger2.log('[field-manager] values["pb"]:', values["pb"]);
        }
        const handle = this.renderField(
          container,
          field,
          values,
          (id, value) => this.onChange(id, value)
        );
        if (handle.synchronizer) {
          this.widthSynchronizers.push(handle.synchronizer);
        }
        this.fieldInstances.set(field.id, {
          spec: field,
          handle: {
            setErrors: handle.setErrors
          },
          container: handle.container,
          isVisible: true
        });
        if (handle.container) {
          setTimeout(() => {
            this.logFieldState(field.id, handle.container);
          }, 50);
        }
      }
      /**
       * Log field state for UI testing purposes.
       */
      logFieldState(fieldId, container) {
        const instance = this.fieldInstances.get(fieldId);
        if (!instance) return;
        const inputEl = container.querySelector("input, select, textarea");
        const state = {
          id: fieldId,
          type: instance.spec.type,
          label: instance.spec.label,
          visible: instance.isVisible,
          hasContainer: !!container
        };
        if (inputEl) {
          state.value = inputEl.value;
          state.width = inputEl.offsetWidth;
          state.height = inputEl.offsetHeight;
          if (inputEl instanceof HTMLSelectElement) {
            state.selectedOption = inputEl.options[inputEl.selectedIndex]?.text;
          }
        }
        const chipsEl = container.querySelector(".sm-cc-chips");
        if (chipsEl) {
          const chips = Array.from(chipsEl.querySelectorAll(".sm-cc-chip > span")).map((el) => el.textContent);
          state.chips = chips;
          state.chipCount = chips.length;
        }
        if (instance.spec.type === "tags" || instance.spec.type === "structured-tags") {
          state.domStructure = this.analyzeDOMStructure(container);
          state.gridLayout = this.analyzeGridLayout(container);
        }
        logger2.log("[UI-TEST] Field rendered:", JSON.stringify(state));
      }
      /**
       * Analyze DOM structure for tag editor fields.
       */
      analyzeDOMStructure(container) {
        const structure = {
          classes: Array.from(container.classList),
          children: []
        };
        for (let i = 0; i < container.children.length; i++) {
          const child = container.children[i];
          structure.children.push({
            tag: child.tagName.toLowerCase(),
            classes: Array.from(child.classList),
            hasInput: !!child.querySelector("input"),
            hasButton: !!child.querySelector("button"),
            hasChips: !!child.querySelector(".sm-cc-chips")
          });
        }
        return structure;
      }
      /**
       * Analyze grid layout properties.
       */
      analyzeGridLayout(container) {
        const computed = window.getComputedStyle(container);
        const gridInfo = {
          display: computed.display,
          gridTemplateColumns: computed.gridTemplateColumns,
          gridTemplateRows: computed.gridTemplateRows,
          gap: computed.gap
        };
        const children = Array.from(container.children);
        gridInfo.childrenGrid = children.map((child, index) => {
          const childComputed = window.getComputedStyle(child);
          return {
            index,
            classes: Array.from(child.classList),
            gridRow: childComputed.gridRow,
            gridColumn: childComputed.gridColumn
          };
        });
        return gridInfo;
      }
      /**
       * Render field using registry.
       * Internal wrapper around fieldRendererRegistry.render().
       */
      renderField(container, spec, values, onChange) {
        return fieldRendererRegistry.render({
          app: null,
          // App not needed for current renderers
          container,
          spec,
          values,
          onChange,
          registerValidator: () => {
          }
          // Not used in this context
        });
      }
      /**
       * Update visibility of all fields based on visibleIf conditions.
       */
      updateVisibility() {
        const data = this.getData();
        for (const [id, instance] of this.fieldInstances) {
          const visible = this.evaluateVisibility(instance.spec, data);
          instance.isVisible = visible;
          const target = instance.container;
          if (target) {
            target.toggleClass("is-hidden", !visible);
            if (!visible) {
              instance.handle.setErrors?.([]);
            }
          }
        }
      }
      /**
       * Evaluate visibility condition for a field.
       */
      evaluateVisibility(field, data) {
        if (!field.visibleIf) return true;
        try {
          return field.visibleIf(data);
        } catch (error) {
          logger2.error("Failed to evaluate field visibility", error);
          return true;
        }
      }
      /**
       * Get the field instances map (for validator integration).
       */
      getFieldInstances() {
        return this.fieldInstances;
      }
      /**
       * Cleanup field instances.
       */
      dispose() {
        this.fieldInstances.clear();
      }
    };
  }
});

// src/features/data-manager/layout/layouts.ts
function createFormCard(parent, options) {
  const { title, subtitle, registerValidator, id, headingId, role } = options;
  const card = parent.createDiv({ cls: "sm-cc-card" });
  if (id) card.id = id;
  const computedHeadingId = headingId ?? (id ? `${id}__title` : void 0);
  card.setAttribute("role", role ?? "region");
  if (computedHeadingId) {
    card.setAttribute("aria-labelledby", computedHeadingId);
  }
  const head = card.createDiv({ cls: "sm-cc-card__head" });
  const heading = head.createDiv({ cls: "sm-cc-card__heading" });
  const headingTitle = heading.createEl("h3", { text: title, cls: "sm-cc-card__title" });
  if (computedHeadingId) headingTitle.id = computedHeadingId;
  const status = heading.createSpan({
    cls: "sm-cc-card__status",
    attr: { hidden: "" }
  });
  if (subtitle) head.createEl("p", { text: subtitle, cls: "sm-cc-card__subtitle" });
  const validation = card.createDiv({ cls: "sm-cc-card__validation", attr: { hidden: "" } });
  const validationList = validation.createEl("ul", { cls: "sm-cc-card__validation-list" });
  const applyValidation = (issues, summary) => {
    const hasIssues = issues.length > 0;
    card.toggleClass("is-invalid", hasIssues);
    if (!hasIssues) {
      validation.setAttribute("hidden", "");
      validation.classList.remove("is-visible");
      validationList.empty();
      status.textContent = "";
      status.setAttribute("hidden", "");
      status.classList.remove("is-active");
      return;
    }
    validation.removeAttribute("hidden");
    validation.classList.add("is-visible");
    validationList.empty();
    for (const message of issues) {
      validationList.createEl("li", { text: message });
    }
    const fallbackSummary = issues.length === 1 ? issues[0] : `${issues.length} Probleme`;
    status.textContent = summary?.trim() || fallbackSummary;
    status.removeAttribute("hidden");
    status.classList.add("is-active");
  };
  const body = card.createDiv({ cls: "sm-cc-card__body" });
  const registerValidation = (compute) => {
    const runner = () => {
      const result = compute();
      const normalized = Array.isArray(result) ? { issues: result, summary: void 0 } : result ?? { issues: [], summary: void 0 };
      applyValidation(normalized.issues, normalized.summary);
      return normalized.issues;
    };
    return registerValidator ? registerValidator(runner) : runner;
  };
  return { card, body, heading: headingTitle, registerValidation };
}
var init_layouts = __esm({
  "src/features/data-manager/layout/layouts.ts"() {
    "use strict";
  }
});

// src/features/data-manager/modal/modal-navigation.ts
var ModalNavigation;
var init_modal_navigation = __esm({
  "src/features/data-manager/modal/modal-navigation.ts"() {
    "use strict";
    init_layouts();
    ModalNavigation = class {
      constructor(options) {
        this.options = options;
        this.sectionObserver = null;
        this.navButtons = [];
      }
      /**
       * Mount the navigation layout: header, shell (nav + content), and footer.
       * Returns the footer element for action buttons.
       */
      mount() {
        const { container, sections, title, subtitle, onMountSection, addValidator } = this.options;
        const header = container.createDiv({ cls: "sm-cc-modal-header" });
        header.createEl("h2", { text: title });
        if (subtitle) {
          header.createEl("p", {
            cls: "sm-cc-modal-subtitle",
            text: subtitle
          });
        }
        const shell = container.createDiv({ cls: "sm-cc-shell" });
        const nav = shell.createEl("nav", { cls: "sm-cc-shell__nav", attr: { "aria-label": "Abschnitte" } });
        nav.createEl("p", { cls: "sm-cc-shell__nav-label", text: "Abschnitte" });
        const navList = nav.createDiv({ cls: "sm-cc-shell__nav-list" });
        const content = shell.createDiv({ cls: "sm-cc-shell__content" });
        const setActive = (sectionId) => {
          for (const entry of this.navButtons) {
            const isActive = entry.id === sectionId;
            entry.button.classList.toggle("is-active", isActive);
            if (isActive) {
              entry.button.setAttribute("aria-current", "true");
            } else {
              entry.button.removeAttribute("aria-current");
            }
          }
        };
        const observer = new IntersectionObserver((entries) => {
          const visible = entries.filter((entry) => entry.isIntersecting);
          if (!visible.length) return;
          visible.sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top);
          const next = visible[0].target.id;
          if (next) setActive(next);
        }, { root: container, rootMargin: "-45% 0px -45% 0px", threshold: 0 });
        this.sectionObserver = observer;
        for (const section of sections) {
          this.createSection(section, content, navList, observer, setActive, onMountSection, addValidator);
        }
        if (sections.length) {
          setActive(sections[0].id);
        }
        const footer = container.createDiv({ cls: "sm-cc-modal-footer" });
        return footer;
      }
      /**
       * Create a single section with navigation button and form card.
       */
      createSection(section, content, navList, observer, setActive, onMountSection, addValidator) {
        const handles = createFormCard(content, {
          title: section.label,
          subtitle: section.description,
          registerValidator: (runner) => addValidator(runner),
          id: section.id
        });
        const navButton = navList.createEl("button", {
          cls: "sm-cc-shell__nav-button",
          text: section.label
        });
        navButton.type = "button";
        navButton.setAttribute("aria-controls", handles.card.id);
        this.navButtons.push({ id: handles.card.id, button: navButton });
        navButton.addEventListener("click", () => {
          setActive(handles.card.id);
          handles.card.scrollIntoView({ behavior: "smooth", block: "start" });
        });
        if (section.subItems && section.subItems.length > 0) {
          const subList = navList.createDiv({ cls: "sm-cc-shell__nav-subitems" });
          for (const subItem of section.subItems) {
            const subButton = subList.createEl("button", {
              cls: "sm-cc-shell__nav-subitem",
              text: subItem.label
            });
            subButton.type = "button";
            subButton.addEventListener("click", () => {
              const entryEl = document.querySelector(`[data-entry-id="${subItem.id}"]`);
              if (entryEl) {
                entryEl.scrollIntoView({ behavior: "smooth", block: "center" });
              }
            });
          }
        }
        observer.observe(handles.card);
        onMountSection(handles, section);
      }
      /**
       * Scroll to a specific section by ID.
       */
      scrollToSection(id) {
        const entry = this.navButtons.find((btn) => btn.id === id);
        if (entry) {
          const section = document.getElementById(id);
          section?.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      }
      /**
       * Cleanup navigation resources.
       */
      dispose() {
        this.sectionObserver?.disconnect();
        this.sectionObserver = null;
        this.navButtons = [];
      }
    };
  }
});

// src/features/data-manager/modal/modal.ts
var import_obsidian25, CreateModal;
var init_modal = __esm({
  "src/features/data-manager/modal/modal.ts"() {
    "use strict";
    import_obsidian25 = require("obsidian");
    init_grid_layout_manager();
    init_label_width_sync();
    init_register_renderers();
    init_data_initializer();
    init_modal_persistence();
    init_modal_validator();
    init_field_manager();
    init_modal_navigation();
    init_modal_utils();
    init_plugin_logger();
    registerAllFieldRenderers();
    CreateModal = class extends import_obsidian25.Modal {
      constructor(app, spec, options, resolve) {
        super(app);
        this.completion = null;
        this.resolved = false;
        // Navigation support
        this.navigation = null;
        this.validators = [];
        // Layout managers for dynamic grid
        this.layoutManagers = [];
        // Width synchronizers for repeating fields
        this.widthSynchronizers = [];
        // Label width synchronizers for sections
        this.labelSynchronizers = [];
        // Background pointer lock
        this.bgLock = null;
        // Submission state
        this.submitButton = null;
        this.cancelButton = null;
        this.isSubmitting = false;
        this.spec = spec;
        this.resolveResult = resolve;
        this.sectionOrder = spec.ui?.sections ?? [];
        const initializer = new DataInitializer({
          spec,
          preset: options?.preset,
          customInitializer: options?.initialize
        });
        this.data = initializer.initialize();
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("sm-cc-create-modal");
        this.validators = [];
        logger2.log("[UI-TEST] Modal opened:", JSON.stringify({
          kind: this.spec.kind,
          title: this.spec.title,
          entity: this.data.name || "new",
          timestamp: Date.now()
        }));
        this.transformer = new DefaultFieldTransformer(this.spec.fields);
        this.persistence = new ModalPersistence(this.app, this.spec, this.transformer);
        this.fieldManager = new FieldManager(
          this.spec.fields,
          () => this.data,
          // Getter for current data
          (id, value) => this.handleFieldChange(id, value),
          this.widthSynchronizers
        );
        this.validator = new ModalValidator(
          this.spec,
          this.fieldManager.getFieldInstances(),
          () => this.data,
          // Getter for current data
          this.validators,
          this.transformer
        );
        this.lockBackgroundPointer();
        const navigationEnabled = this.spec.ui?.enableNavigation ?? Boolean(this.sectionOrder.length);
        if (navigationEnabled) {
          this.modalEl.addClass("sm-cc-create-modal-host");
        }
        if (navigationEnabled && this.sectionOrder.length) {
          this.buildNavigationLayout(contentEl);
        } else {
          this.buildSimpleLayout(contentEl);
        }
      }
      buildSimpleLayout(contentEl) {
        contentEl.createEl("h3", { text: this.spec.title });
        this.fieldManager.renderFields(contentEl, void 0);
        this.buildActionButtons(contentEl);
        this.scope.register([], "Enter", (evt) => {
          if (!(evt.target instanceof HTMLTextAreaElement)) {
            void this.submit();
          }
        });
      }
      buildNavigationLayout(contentEl) {
        this.navigation = new ModalNavigation({
          container: contentEl,
          sections: this.sectionOrder,
          title: this.spec.title,
          subtitle: this.spec.subtitle,
          onMountSection: (handles, section) => this.mountSection(handles, section),
          addValidator: (runner) => this.addValidator(runner)
        });
        const footer = this.navigation.mount();
        this.buildActionButtons(footer);
      }
      mountSection(handles, section) {
        const ordered = orderFields(this.spec.fields, section.fieldIds);
        this.fieldManager.renderFields(handles.body, section.fieldIds);
        const layoutManager = new GridLayoutManager(handles.body, ordered);
        this.layoutManagers.push(layoutManager);
        const labelSync = new LabelWidthSynchronizer(handles.body, layoutManager.isMultiColumn);
        this.labelSynchronizers.push(labelSync);
        logger2.log("[Modal] Label sync enabled for section:", section.id, "Multi-column:", layoutManager.isMultiColumn);
        handles.registerValidation(() => {
          const result = this.validator.validate();
          const issues = [];
          for (const field of ordered) {
            const fieldErrors = result.errors.get(field.id) ?? [];
            if (fieldErrors.length) {
              issues.push(`${field.label}: ${fieldErrors[0]}`);
            }
          }
          const summary = issues.length > 0 ? `${issues.length} Feld${issues.length > 1 ? "er" : ""} ben\xF6tigt Aufmerksamkeit` : void 0;
          return { issues, summary };
        });
      }
      handleFieldChange(id, value) {
        if (id === "name" && typeof value === "string") {
          this.data.name = value.trim();
        }
        this.data[id] = value;
        this.fieldManager.updateVisibility();
      }
      buildActionButtons(container) {
        const buttons = new import_obsidian25.Setting(container);
        buttons.addButton((btn) => {
          this.cancelButton = btn;
          btn.setButtonText(this.spec.ui?.cancelLabel || "Abbrechen").onClick(() => {
            if (this.isSubmitting) return;
            this.close();
          });
        });
        buttons.addButton((btn) => {
          this.submitButton = btn;
          btn.setButtonText(this.spec.ui?.submitLabel || "Erstellen").setCta().onClick(() => void this.submit());
        });
      }
      async submit() {
        if (this.isSubmitting) return;
        const validationResult = this.validator.validate();
        if (!validationResult.isValid) {
          if (this.spec.ui?.enableNavigation) {
            const firstInvalid = this.contentEl.querySelector(".sm-cc-card.is-invalid");
            if (firstInvalid) firstInvalid.scrollIntoView({ behavior: "smooth", block: "center" });
          }
          return;
        }
        if (!this.data.name || !this.data.name.trim()) {
          return;
        }
        this.setButtonsDisabled(true);
        this.isSubmitting = true;
        try {
          const result = await this.persistence.save(this.data);
          await this.spec.transformers?.postSave?.(result.filePath, result.values);
          this.completion = {
            filePath: result.filePath,
            values: result.values
          };
          this.close();
        } catch (error) {
          logger2.error("Failed to submit create modal", error);
          this.handleSubmissionError(error);
        } finally {
          this.isSubmitting = false;
          this.setButtonsDisabled(false);
        }
      }
      onClose() {
        this.fieldManager?.dispose();
        this.navigation?.dispose();
        this.navigation = null;
        this.validators = [];
        for (const manager of this.layoutManagers) {
          manager.destroy();
        }
        this.layoutManagers = [];
        for (const synchronizer of this.widthSynchronizers) {
          synchronizer.destroy();
        }
        this.widthSynchronizers = [];
        for (const synchronizer of this.labelSynchronizers) {
          synchronizer.destroy();
        }
        this.labelSynchronizers = [];
        this.modalEl.removeClass("sm-cc-create-modal-host");
        this.restoreBackgroundPointer();
        if (!this.resolved) {
          this.resolved = true;
          this.resolveResult(this.completion);
        }
        this.contentEl.empty();
        this.submitButton = null;
        this.cancelButton = null;
        this.isSubmitting = false;
      }
      addValidator(run) {
        this.validators.push(run);
        return run;
      }
      setButtonsDisabled(disabled) {
        this.submitButton?.setDisabled(disabled);
        this.cancelButton?.setDisabled(disabled);
      }
      handleSubmissionError(error) {
        const message = error instanceof Error ? error.message : String(error ?? "Unbekannter Fehler");
        new import_obsidian25.Notice(`Fehler beim Speichern: ${message}`);
      }
      lockBackgroundPointer() {
        const bg = document.querySelector(".modal-bg");
        if (!bg) return;
        this.bgLock = { el: bg, pointer: bg.style.pointerEvents };
        bg.style.pointerEvents = "none";
      }
      restoreBackgroundPointer() {
        if (!this.bgLock) return;
        this.bgLock.el.style.pointerEvents = this.bgLock.pointer || "";
        this.bgLock = null;
      }
    };
  }
});

// src/features/data-manager/modal/open-create-modal.ts
function resolveAppInstance(options) {
  if (options?.app) return options.app;
  const globalApp = globalThis.app;
  if (!globalApp) {
    throw new Error("Obsidian App instance is required to open the create modal");
  }
  return globalApp;
}
function openCreateModal(spec, options) {
  const app = resolveAppInstance(options);
  return new Promise((resolve) => {
    const modal = new CreateModal(app, spec, options, resolve);
    modal.open();
  });
}
var init_open_create_modal = __esm({
  "src/features/data-manager/modal/open-create-modal.ts"() {
    "use strict";
    init_modal();
  }
});

// src/features/data-manager/types.ts
var init_types = __esm({
  "src/features/data-manager/types.ts"() {
    "use strict";
  }
});

// src/features/data-manager/browse/types.ts
var init_types2 = __esm({
  "src/features/data-manager/browse/types.ts"() {
    "use strict";
  }
});

// src/features/data-manager/browse/generic-list-renderer.ts
var GenericListRenderer;
var init_generic_list_renderer = __esm({
  "src/features/data-manager/browse/generic-list-renderer.ts"() {
    "use strict";
    init_plugin_logger();
    init_browse();
    GenericListRenderer = class {
      constructor(app, container, config) {
        this.app = app;
        this.container = container;
        this.query = "";
        this.entries = [];
        this.renderToken = 0;
        this.disposed = false;
        this.cleanups = [];
        this.mode = config.mode;
        this.source = config.source;
        this.schema = config.schema;
        this.viewConfig = config.viewConfig;
        this.watchers = config.watchers;
        this.state = new FilterSortState();
      }
      async init() {
        await this.refreshEntries();
        if (this.disposed) return;
        const unsubscribe = this.watchers.subscribe(
          this.mode,
          (onChange) => this.source.watch(this.app, onChange),
          () => void this.handleSourceChange()
        );
        this.registerCleanup(unsubscribe);
      }
      render() {
        if (this.disposed) return;
        this.renderInternal();
      }
      setQuery(query) {
        this.query = query.toLowerCase();
      }
      destroy() {
        this.disposed = true;
        for (const cleanup of this.cleanups) {
          cleanup();
        }
        this.cleanups = [];
      }
      isDisposed() {
        return this.disposed;
      }
      registerCleanup(fn) {
        this.cleanups.push(fn);
      }
      createActionContext() {
        return {
          app: this.app,
          reloadEntries: () => this.reloadEntries(),
          getRenderer: () => this.viewConfig,
          getFilterSelection: (id) => this.getFilterSelection(id)
        };
      }
      async handleCreate(name) {
        const context = this.createActionContext();
        await this.viewConfig.handleCreate(context, name);
      }
      async reloadEntries() {
        await this.refreshEntries();
        if (!this.disposed) {
          this.render();
        }
      }
      getFilterSelection(id) {
        return this.state.getFilterValue(id);
      }
      async handleSourceChange() {
        await this.refreshEntries();
        if (!this.disposed) {
          this.render();
        }
      }
      async refreshEntries() {
        try {
          const files = await this.source.list(this.app);
          logger2.log(`[library:${this.mode}] Found ${files.length} files`);
          const entries = await Promise.all(files.map((file) => this.source.load(this.app, file)));
          logger2.log(`[library:${this.mode}] Loaded ${entries.length} entries`);
          this.entries = entries;
          this.loadError = void 0;
        } catch (err) {
          logger2.error(`[library:${this.mode}] Failed to load entries`, err);
          this.entries = [];
          this.loadError = err;
        }
      }
      renderInternal() {
        const token = ++this.renderToken;
        const container = this.container;
        container.empty();
        if (this.loadError) {
          renderWorkmodeFeedback(container, "error", "Failed to load entries.");
          return;
        }
        const filters = this.schema.filters;
        const sorts = this.schema.sorts;
        this.state.ensureSortAvailable(sorts);
        const optionValues = collectFilterOptions(this.entries, filters);
        this.state.pruneInvalidFilters(optionValues);
        if (filters.length || sorts.length) {
          renderFilterSortControls({
            container,
            filters,
            sorts,
            optionValues,
            state: this.state,
            onChange: () => this.render()
          });
        }
        const query = this.query;
        const prepared = this.entries.map((entry) => ({
          entry,
          score: this.computeSearchScore(entry, query)
        }));
        const filtered = prepared.filter((item) => this.state.matches(item.entry, filters));
        const visible = query ? filtered.filter((item) => item.score > -Infinity) : filtered;
        const sortDef = sorts.find((option) => option.id === this.state.getSortId()) ?? sorts[0];
        visible.sort((a, b) => {
          if (query && a.score !== b.score) {
            return b.score - a.score;
          }
          let comparison = sortDef ? sortDef.compare(a.entry, b.entry) : a.entry.name.localeCompare(b.entry.name);
          if (comparison === 0) {
            comparison = a.entry.name.localeCompare(b.entry.name);
          }
          return this.state.getSortDirection() === "asc" ? comparison : -comparison;
        });
        if (token !== this.renderToken || this.disposed) {
          return;
        }
        const entriesToRender = visible.map((item) => item.entry);
        logger2.log(`[library:${this.mode}] Rendering ${entriesToRender.length} entries (filtered from ${this.entries.length} total)`);
        if (!entriesToRender.length) {
          renderWorkmodeFeedback(container, "empty", "No entries found.");
          return;
        }
        const actionContext = this.createActionContext();
        renderWorkmodeList({
          container,
          entries: entriesToRender,
          getName: (entry) => entry.name,
          metadata: this.viewConfig.metadataFields,
          actions: this.viewConfig.actions,
          actionContext
        });
      }
      computeSearchScore(entry, query) {
        if (!query) return 1e-4;
        const candidates = [entry.name, ...this.schema.search(entry)];
        let best = -Infinity;
        for (const candidate of candidates) {
          if (!candidate) continue;
          const score = this.scoreName(candidate.toLowerCase(), query);
          if (score > best) {
            best = score;
          }
        }
        return best;
      }
      scoreName(candidate, query) {
        if (candidate.includes(query)) {
          return candidate.startsWith(query) ? 2 : 1;
        }
        return -Infinity;
      }
    };
  }
});

// src/features/data-manager/browse/action-factory.ts
function createOpenAction() {
  return {
    id: "open",
    label: "Open",
    execute: async (entry, context) => {
      await context.app.workspace.openLinkText(entry.file.path, entry.file.path, true);
    }
  };
}
function createDeleteAction(typeName) {
  return {
    id: "delete",
    label: "Delete",
    execute: async (entry, context) => {
      const question = `Delete ${entry.name}? This moves the file to the trash.`;
      const confirmation = typeof window !== "undefined" && typeof window.confirm === "function" ? window.confirm(question) : true;
      if (!confirmation) return;
      try {
        await context.app.vault.trash(entry.file, true);
        await context.reloadEntries();
      } catch (err) {
        logger2.error(`Failed to delete ${typeName}`, err);
      }
    }
  };
}
function createStandardActions(typeName, createEditAction) {
  return [
    createOpenAction(),
    createEditAction(),
    createDeleteAction(typeName)
  ];
}
var init_action_factory = __esm({
  "src/features/data-manager/browse/action-factory.ts"() {
    "use strict";
    init_plugin_logger();
  }
});

// src/features/data-manager/browse/schema-builder.ts
var init_schema_builder = __esm({
  "src/features/data-manager/browse/schema-builder.ts"() {
    "use strict";
  }
});

// src/features/data-manager/browse/mode-renderer.ts
var init_mode_renderer = __esm({
  "src/features/data-manager/browse/mode-renderer.ts"() {
    "use strict";
    init_plugin_logger();
  }
});

// src/features/data-manager/browse/tab-navigation.ts
function appendElement(parent, tag, options = {}) {
  const maybeCreateEl = parent.createEl;
  if (typeof maybeCreateEl === "function") {
    return maybeCreateEl.call(parent, tag, options);
  }
  const doc = parent.ownerDocument ?? document;
  const el = doc.createElement(tag);
  if (options.cls) {
    el.className = options.cls;
  }
  if (options.text !== void 0) {
    el.textContent = options.text;
  }
  parent.appendChild(el);
  return el;
}
function createTabNavigation(parent, config) {
  const container = parent.createDiv({ cls: "sm-tab-nav" });
  if (config.className) {
    container.addClass(config.className);
  }
  const buttons = /* @__PURE__ */ new Map();
  let currentActive = config.activeTab;
  const updateActiveState = () => {
    for (const [tabId, { button }] of buttons.entries()) {
      button.classList.toggle("is-active", tabId === currentActive);
      button.setAttribute("aria-selected", String(tabId === currentActive));
    }
  };
  const createTabButton = (tab) => {
    const button = container.createEl("button", {
      cls: "sm-tab-nav__button",
      attr: {
        "data-tab-id": tab.id,
        "role": "tab",
        "aria-selected": String(tab.id === currentActive),
        "tabindex": tab.id === currentActive ? "0" : "-1"
      }
    });
    if (tab.disabled) {
      button.disabled = true;
      button.addClass("is-disabled");
    }
    if (tab.icon) {
      const icon = appendElement(button, "span", { cls: "sm-tab-nav__icon" });
      icon.innerHTML = tab.icon;
    }
    appendElement(button, "span", { cls: "sm-tab-nav__label", text: tab.label });
    let badge;
    if (tab.badgeCount !== void 0 && tab.badgeCount > 0) {
      badge = appendElement(button, "span", { cls: "sm-tab-nav__badge", text: String(tab.badgeCount) });
    }
    if (tab.description) {
      button.setAttribute("aria-label", tab.description);
      button.setAttribute("title", tab.description);
    }
    button.onclick = () => {
      if (button.disabled) return;
      currentActive = tab.id;
      updateActiveState();
      config.onSelect(tab.id);
    };
    return { button, badge };
  };
  for (const tab of config.tabs) {
    const tabButton = createTabButton(tab);
    buttons.set(tab.id, tabButton);
  }
  updateActiveState();
  container.addEventListener("keydown", (e) => {
    if (e.key !== "ArrowLeft" && e.key !== "ArrowRight") return;
    const tabIds = Array.from(buttons.keys());
    const currentIndex = tabIds.indexOf(currentActive);
    if (currentIndex === -1) return;
    let nextIndex;
    if (e.key === "ArrowRight") {
      nextIndex = (currentIndex + 1) % tabIds.length;
    } else {
      nextIndex = (currentIndex - 1 + tabIds.length) % tabIds.length;
    }
    const nextTab = tabIds[nextIndex];
    const nextButton = buttons.get(nextTab);
    if (nextButton && !nextButton.button.disabled) {
      currentActive = nextTab;
      updateActiveState();
      nextButton.button.focus();
      config.onSelect(nextTab);
    }
  });
  return {
    element: container,
    setActiveTab(tabId) {
      if (!buttons.has(tabId)) {
        logger2.warn(`Tab ${tabId} not found in navigation`);
        return;
      }
      currentActive = tabId;
      updateActiveState();
    },
    setBadgeCount(tabId, count) {
      const entry = buttons.get(tabId);
      if (!entry) return;
      if (entry.badge) {
        if (count !== void 0 && count > 0) {
          entry.badge.setText(String(count));
          entry.badge.style.display = "";
        } else {
          entry.badge.style.display = "none";
        }
      } else if (count !== void 0 && count > 0) {
        entry.badge = appendElement(entry.button, "span", { cls: "sm-tab-nav__badge", text: String(count) });
      }
    },
    setDisabled(tabId, disabled) {
      const entry = buttons.get(tabId);
      if (!entry) return;
      entry.button.disabled = disabled;
      entry.button.classList.toggle("is-disabled", disabled);
    },
    destroy() {
      container.remove();
    }
  };
}
var init_tab_navigation = __esm({
  "src/features/data-manager/browse/tab-navigation.ts"() {
    "use strict";
    init_plugin_logger();
  }
});

// src/features/data-manager/browse/filter-controls.ts
function collectFilterOptions(entries, filters) {
  const options = /* @__PURE__ */ new Map();
  for (const filter of filters) {
    const values = /* @__PURE__ */ new Set();
    for (const entry of entries) {
      const rawValues = filter.getValues(entry) || [];
      for (const raw of rawValues) {
        const value = String(raw ?? "").trim();
        if (value) {
          values.add(value);
        }
      }
    }
    const list = Array.from(values);
    const comparator = filter.sortComparator ?? ((a, b) => a.localeCompare(b, void 0, { sensitivity: "base" }));
    list.sort(comparator);
    options.set(filter.id, list);
  }
  return options;
}
function renderFilterSortControls({
  container,
  filters,
  sorts,
  optionValues,
  state,
  onChange,
  copy
}) {
  const strings = { ...DEFAULT_COPY, ...copy };
  const controls = container.createDiv({ cls: "sm-cc-controls" });
  if (filters.length) {
    const filterContainer = controls.createDiv({ cls: "sm-cc-filters" });
    filterContainer.createEl("h4", { text: strings.filterTitle, cls: "sm-cc-section-header" });
    const filterContent = filterContainer.createDiv({ cls: "sm-cc-filter-content" });
    for (const filter of filters) {
      const wrapper = filterContent.createDiv({ cls: "sm-cc-filter" });
      wrapper.createEl("label", { text: `${filter.label}: ` });
      const select = wrapper.createEl("select");
      select.createEl("option", { value: "", text: filter.emptyLabel ?? strings.emptyOptionLabel });
      const values = optionValues.get(filter.id) ?? [];
      for (const value of values) {
        select.createEl("option", { value, text: filter.formatOption ? filter.formatOption(value) : value });
      }
      select.value = state.getFilterValue(filter.id) ?? "";
      select.onchange = () => {
        state.setFilterValue(filter.id, select.value);
        onChange();
      };
    }
    if (state.hasFilters()) {
      const clearBtn = filterContent.createEl("button", { text: strings.clearFiltersLabel, cls: "sm-cc-clear-filters" });
      clearBtn.onclick = () => {
        state.clearFilters();
        onChange();
      };
    }
  }
  if (sorts.length) {
    const sortContainer = controls.createDiv({ cls: "sm-cc-sorting" });
    sortContainer.createEl("h4", { text: strings.sortTitle, cls: "sm-cc-section-header" });
    const sortContent = sortContainer.createDiv({ cls: "sm-cc-sort-content" });
    const sortWrapper = sortContent.createDiv({ cls: "sm-cc-sort" });
    sortWrapper.createEl("label", { text: `${strings.sortByLabel} ` });
    const select = sortWrapper.createEl("select");
    for (const option of sorts) {
      select.createEl("option", { value: option.id, text: option.label });
    }
    const directionBtn = sortContent.createEl("button", {
      cls: "sm-cc-sort-direction",
      attr: { "aria-label": state.getSortDirection() === "asc" ? strings.sortAscendingAria : strings.sortDescendingAria }
    });
    const updateDirectionVisuals = () => {
      const direction = state.getSortDirection();
      directionBtn.innerHTML = direction === "asc" ? "\u2191" : "\u2193";
      directionBtn.title = direction === "asc" ? strings.sortAscendingTitle : strings.sortDescendingTitle;
      directionBtn.setAttribute("aria-label", direction === "asc" ? strings.sortAscendingAria : strings.sortDescendingAria);
    };
    updateDirectionVisuals();
    const currentSort = state.getSortId();
    if (currentSort) {
      select.value = currentSort;
    }
    select.onchange = () => {
      state.setSort(select.value);
      updateDirectionVisuals();
      onChange();
    };
    directionBtn.onclick = () => {
      const targetId = state.getSortId() ?? sorts[0]?.id;
      if (!targetId) return;
      state.setSort(targetId);
      updateDirectionVisuals();
      onChange();
    };
  }
}
var DEFAULT_COPY, FilterSortState;
var init_filter_controls = __esm({
  "src/features/data-manager/browse/filter-controls.ts"() {
    "use strict";
    DEFAULT_COPY = {
      filterTitle: "Filter",
      sortTitle: "Sort",
      sortByLabel: "Sort by:",
      emptyOptionLabel: "All",
      clearFiltersLabel: "Clear filters",
      sortAscendingAria: "Sort ascending",
      sortDescendingAria: "Sort descending",
      sortAscendingTitle: "Ascending",
      sortDescendingTitle: "Descending"
    };
    FilterSortState = class {
      constructor() {
        this.filters = /* @__PURE__ */ new Map();
        this.sortDirection = "asc";
      }
      ensureSortAvailable(sorts) {
        if (!sorts.length) {
          this.sortId = void 0;
          this.sortDirection = "asc";
          return;
        }
        if (!this.sortId || !sorts.some((option) => option.id === this.sortId)) {
          this.sortId = sorts[0].id;
          this.sortDirection = "asc";
        }
      }
      getSortId() {
        return this.sortId;
      }
      getSortDirection() {
        return this.sortDirection;
      }
      setSort(id) {
        if (!id) return;
        if (this.sortId === id) {
          this.sortDirection = this.sortDirection === "asc" ? "desc" : "asc";
        } else {
          this.sortId = id;
          this.sortDirection = "asc";
        }
      }
      getFilterValue(id) {
        return this.filters.get(id);
      }
      setFilterValue(id, value) {
        if (value) {
          this.filters.set(id, value);
        } else {
          this.filters.delete(id);
        }
      }
      hasFilters() {
        return this.filters.size > 0;
      }
      clearFilters() {
        this.filters.clear();
      }
      pruneInvalidFilters(options) {
        for (const [id, value] of Array.from(this.filters.entries())) {
          if (!value) continue;
          if (!options.get(id)?.includes(value)) {
            this.filters.delete(id);
          }
        }
      }
      matches(entry, filters) {
        if (!this.filters.size) return true;
        for (const [id, selected] of this.filters.entries()) {
          if (!selected) continue;
          const definition = filters.find((filter) => filter.id === id);
          if (!definition) continue;
          const values = (definition.getValues(entry) || []).map((value) => String(value ?? "").trim()).filter((value) => Boolean(value));
          if (!values.includes(selected)) {
            return false;
          }
        }
        return true;
      }
    };
  }
});

// src/features/data-manager/browse/list-renderer.ts
function renderWorkmodeFeedback(container, kind, message) {
  container.createDiv({ cls: `sm-cc-feedback sm-cc-feedback--${kind}`, text: message });
}
function renderWorkmodeList({
  container,
  entries,
  getName,
  metadata = [],
  actions = [],
  actionContext,
  onRenderRow
}) {
  const rows = [];
  for (const entry of entries) {
    const row = container.createDiv({ cls: "sm-cc-item" });
    rows.push(row);
    const nameContainer = row.createDiv({ cls: "sm-cc-item__name-container" });
    nameContainer.createDiv({ cls: "sm-cc-item__name", text: getName(entry) });
    if (metadata.length > 0) {
      const infoContainer = row.createDiv({ cls: "sm-cc-item__info" });
      for (const field of metadata) {
        const value = field.getValue(entry);
        if (value) {
          infoContainer.createEl("span", { cls: field.cls, text: value });
        }
      }
    }
    if (actions.length > 0) {
      const actionsContainer = row.createDiv({ cls: "sm-cc-item__actions" });
      for (const action of actions) {
        const cls = action.cls ? `sm-cc-item__action ${action.cls}` : "sm-cc-item__action";
        const button = actionsContainer.createEl("button", { text: action.label, cls });
        button.onclick = async () => {
          await action.execute(entry, actionContext);
        };
      }
    }
    if (onRenderRow) {
      onRenderRow(row, entry, actionContext);
    }
  }
  return rows;
}
var init_list_renderer = __esm({
  "src/features/data-manager/browse/list-renderer.ts"() {
    "use strict";
  }
});

// src/features/data-manager/browse/map-styling.ts
var init_map_styling = __esm({
  "src/features/data-manager/browse/map-styling.ts"() {
    "use strict";
    init_map_workflows();
  }
});

// src/features/data-manager/browse/workmode-header.ts
function createWorkmodeHeader(parent, config) {
  const titleEl = parent.createEl("h2", { text: config.title });
  let tabNavigation;
  if (config.tabs && config.tabs.items.length > 0) {
    tabNavigation = createTabNavigation(parent, {
      tabs: config.tabs.items,
      activeTab: config.tabs.active,
      className: config.tabs.className ?? "sm-lib-header",
      onSelect: config.tabs.onSelect
    });
  }
  let searchInput;
  let actionButton;
  if (config.search || config.action) {
    const bar = parent.createDiv({ cls: "sm-cc-searchbar" });
    if (config.search) {
      searchInput = bar.createEl("input", {
        attr: {
          type: "text",
          placeholder: config.search.placeholder
        }
      });
      if (config.search.value) {
        searchInput.value = config.search.value;
      }
      searchInput.disabled = Boolean(config.search.disabled);
      searchInput.oninput = () => {
        if (!config.search?.onChange) return;
        const next = searchInput ? searchInput.value.trim() : "";
        config.search.onChange(next);
      };
    }
    if (config.action) {
      actionButton = bar.createEl("button", { text: config.action.label, attr: { type: "button" } });
      applyMapButtonStyle(actionButton);
      actionButton.disabled = Boolean(config.action.disabled);
      actionButton.onclick = () => {
        if (!config.action?.onClick || actionButton?.disabled) return;
        const value = searchInput ? searchInput.value.trim() : "";
        config.action.onClick(value);
      };
    }
  }
  return {
    titleEl,
    tabNavigation,
    searchInput,
    actionButton,
    setActiveTab(tabId) {
      tabNavigation?.setActiveTab(tabId);
    },
    setSearchValue(value) {
      if (searchInput) {
        searchInput.value = value;
      }
    },
    focusSearch() {
      searchInput?.focus();
    },
    destroy() {
      tabNavigation?.destroy();
    }
  };
}
var init_workmode_header = __esm({
  "src/features/data-manager/browse/workmode-header.ts"() {
    "use strict";
    init_tab_navigation();
    init_map_styling();
  }
});

// src/ui/utils/watcher-hub.ts
var WatcherHub;
var init_watcher_hub = __esm({
  "src/ui/utils/watcher-hub.ts"() {
    "use strict";
    init_plugin_logger();
    WatcherHub = class {
      constructor() {
        this.registry = /* @__PURE__ */ new Map();
      }
      /**
       * Subscribe to changes for a specific source.
       *
       * @param key - The unique identifier for the watched resource
       * @param factory - Factory function that creates the watcher
       * @param listener - Callback to be invoked when changes occur
       * @returns Unsubscribe function
       */
      subscribe(key, factory, listener) {
        let entry = this.registry.get(key);
        if (!entry) {
          const listeners2 = /* @__PURE__ */ new Set();
          const stop = factory(() => {
            for (const cb of listeners2) {
              try {
                cb();
              } catch (err) {
                logger2.error(`Watcher listener failed for key ${key}:`, err);
              }
            }
          });
          entry = { stop, listeners: listeners2 };
          this.registry.set(key, entry);
        }
        entry.listeners.add(listener);
        return () => {
          const current = this.registry.get(key);
          if (!current) return;
          current.listeners.delete(listener);
          if (current.listeners.size === 0) {
            try {
              current.stop?.();
            } catch (err) {
              logger2.error(`Failed to stop watcher for key ${key}:`, err);
            }
            this.registry.delete(key);
          }
        };
      }
      /**
       * Get the number of active watchers.
       */
      getActiveWatcherCount() {
        return this.registry.size;
      }
      /**
       * Get the number of listeners for a specific key.
       */
      getListenerCount(key) {
        return this.registry.get(key)?.listeners.size ?? 0;
      }
      /**
       * Stop all watchers and clear all listeners.
       */
      destroy() {
        for (const [key, entry] of this.registry.entries()) {
          try {
            entry.stop?.();
          } catch (err) {
            logger2.error(`Failed to stop watcher for key ${key}:`, err);
          }
        }
        this.registry.clear();
      }
    };
  }
});

// src/ui/utils/split-view-container.ts
var init_split_view_container = __esm({
  "src/ui/utils/split-view-container.ts"() {
    "use strict";
  }
});

// src/ui/index.ts
var init_ui = __esm({
  "src/ui/index.ts"() {
    "use strict";
    init_browse();
    init_split_view_container();
    init_watcher_hub();
    init_data_manager();
  }
});

// src/features/data-manager/browse/tabbed-browse-view.ts
var import_obsidian26, TabbedBrowseView;
var init_tabbed_browse_view = __esm({
  "src/features/data-manager/browse/tabbed-browse-view.ts"() {
    "use strict";
    import_obsidian26 = require("obsidian");
    init_generic_list_renderer();
    init_watcher_hub();
    init_ui();
    TabbedBrowseView = class extends import_obsidian26.ItemView {
      constructor(leaf) {
        super(leaf);
        this.queries = /* @__PURE__ */ new Map();
        this.watchers = new WatcherHub();
        this.mode = this.config.defaultMode;
      }
      getViewType() {
        return this.config.viewType;
      }
      getDisplayText() {
        return this.config.copy.title;
      }
      getIcon() {
        return this.config.icon;
      }
      async onOpen() {
        this.contentEl.addClass("sm-browsable-view");
        this.renderShell();
        await this.activateMode(this.mode);
      }
      async onClose() {
        await this.activeRenderer?.destroy();
        this.activeRenderer = void 0;
        this.header?.destroy();
        this.header = void 0;
        this.watchers.destroy();
        this.contentEl.removeClass("sm-browsable-view");
      }
      /**
       * Renders the shell UI (header, tabs, containers)
       */
      renderShell() {
        const root = this.contentEl;
        root.empty();
        const tabs = this.config.modes.map((id) => ({
          id,
          label: this.config.copy.modes[id]
        }));
        this.header = createWorkmodeHeader(root, {
          title: this.config.copy.title,
          tabs: {
            items: tabs,
            active: this.mode,
            className: "sm-browse-header",
            onSelect: (mode) => {
              this.mode = mode;
              this.header?.setActiveTab(mode);
              this.updateSourceDescription();
              const query = this.getQueryForMode(mode);
              this.header?.setSearchValue(query);
              setTimeout(() => {
                void this.activateModeAsync(mode, query);
              }, 20);
            }
          },
          search: {
            placeholder: this.config.copy.searchPlaceholder,
            value: this.getQueryForMode(this.mode),
            onChange: (value) => {
              this.queries.set(this.mode, value);
              this.activeRenderer?.setQuery(value);
              this.activeRenderer?.render();
            }
          },
          action: {
            label: this.config.copy.createButton,
            onClick: (value) => {
              void this.onCreate(value);
            }
          }
        });
        if (this.config.describeSource) {
          const prefix = this.config.copy.sources?.prefix ?? "";
          this.descEl = root.createDiv({ cls: "desc" });
        }
        this.listEl = root.createDiv({ cls: "sm-cc-list" });
      }
      /**
       * Activates a specific mode/tab (called from onOpen with initial mode)
       */
      async activateMode(mode) {
        this.mode = mode;
        this.header?.setActiveTab(mode);
        this.updateSourceDescription();
        const query = this.getQueryForMode(mode);
        this.header?.setSearchValue(query);
        await this.activateModeAsync(mode, query);
      }
      /**
       * Async part of mode activation (data loading)
       */
      async activateModeAsync(mode, query) {
        if (this.activeRenderer?.mode === mode) {
          this.activeRenderer.setQuery(query);
          this.activeRenderer.render();
          return;
        }
        if (this.activeRenderer) {
          await this.activeRenderer.destroy();
          this.activeRenderer = void 0;
        }
        if (!this.listEl) return;
        if (this.config.ensureSources) {
          await this.config.ensureSources(this.app, [mode]);
        }
        const renderer = this.createRenderer(mode, this.listEl);
        this.activeRenderer = renderer;
        await renderer.init();
        renderer.setQuery(query);
        renderer.render();
      }
      /**
       * Creates a renderer for the specified mode
       */
      createRenderer(mode, container) {
        const rendererConfig = {
          mode,
          source: this.config.dataSources[mode],
          schema: this.config.schemas[mode],
          viewConfig: this.config.viewConfigs[mode],
          watchers: this.watchers
        };
        return new GenericListRenderer(this.app, container, rendererConfig);
      }
      /**
       * Updates the source description text
       */
      updateSourceDescription() {
        if (!this.descEl || !this.config.describeSource) return;
        const prefix = this.config.copy.sources?.prefix ?? "";
        const description = this.config.describeSource(this.mode);
        this.descEl.setText(`${prefix}${description}`);
      }
      /**
       * Handles create action (when user submits create form)
       */
      async onCreate(name) {
        if (!this.activeRenderer) return;
        if (this.activeRenderer.handleCreate) {
          await this.activeRenderer.handleCreate(name);
        }
        this.header?.focusSearch();
      }
      /**
       * Gets the search query for a specific mode
       */
      getQueryForMode(mode) {
        return this.queries.get(mode) ?? "";
      }
    };
  }
});

// src/features/data-manager/browse/index.ts
var init_browse = __esm({
  "src/features/data-manager/browse/index.ts"() {
    "use strict";
    init_types2();
    init_generic_list_renderer();
    init_action_factory();
    init_frontmatter_utils();
    init_schema_builder();
    init_mode_renderer();
    init_tab_navigation();
    init_filter_controls();
    init_list_renderer();
    init_workmode_header();
    init_tabbed_browse_view();
  }
});

// src/features/data-manager/index.ts
var init_data_manager = __esm({
  "src/features/data-manager/index.ts"() {
    "use strict";
    init_modal();
    init_open_create_modal();
    init_types();
    init_storage();
    init_layouts();
    init_number_stepper_control();
    init_entry_system();
    init_browse();
  }
});

// src/features/data-manager/browse/auto-loader.ts
async function loadFromFrontmatter(app, file, spec) {
  if (spec.loader?.fromFrontmatter) {
    const cache2 = app.metadataCache.getFileCache(file);
    const fm3 = cache2?.frontmatter ?? {};
    return await spec.loader.fromFrontmatter(fm3, file);
  }
  const cache = app.metadataCache.getFileCache(file);
  const fm2 = cache?.frontmatter ?? {};
  const data = {
    name: typeof fm2.name === "string" && fm2.name.trim().length > 0 ? fm2.name.trim() : file.basename
  };
  if (Array.isArray(spec.storage.frontmatter)) {
    for (const fieldId of spec.storage.frontmatter) {
      if (fm2[fieldId] !== void 0) {
        data[fieldId] = fm2[fieldId];
        if (fieldId === "pb" || fieldId === "initiative" || fieldId === "passivesList" || fieldId === "sensesList" || fieldId === "languagesList") {
          logger2.debug("[auto-loader] Loading token field", { fieldId, value: fm2[fieldId] });
        }
      }
    }
  } else if (spec.storage.frontmatter) {
    for (const [fieldId, fmKey] of Object.entries(spec.storage.frontmatter)) {
      if (fm2[fmKey] !== void 0) {
        data[fieldId] = fm2[fmKey];
      }
    }
  }
  if (!data.description && spec.storage.format === "md-frontmatter") {
    const content = await app.vault.read(file);
    const bodyMatch = content.match(/^---[\s\S]*?---\s*\n([\s\S]*)/);
    if (bodyMatch) {
      data.description = bodyMatch[1].trim();
    }
  }
  return data;
}
var init_auto_loader = __esm({
  "src/features/data-manager/browse/auto-loader.ts"() {
    "use strict";
    init_plugin_logger();
  }
});

// src/features/data-manager/browse/auto-config.ts
function createAutoEditAction(spec) {
  return {
    id: "edit",
    label: "Edit",
    execute: async (entry, context) => {
      const { app } = context;
      try {
        const data = await loadFromFrontmatter(app, entry.file, spec);
        const result = await openCreateModal(spec, {
          app,
          preset: data
        });
        if (result) {
          await context.reloadEntries();
          await app.workspace.openLinkText(result.filePath, result.filePath, true, { state: { mode: "source" } });
        }
      } catch (err) {
        logger2.error(`Failed to load ${spec.kind} for editing`, err);
      }
    }
  };
}
function createAutoCreateHandler(spec) {
  return async (context, name) => {
    const { app } = context;
    const preset = { name: name.trim() || `New ${spec.kind}` };
    if (context.getFilterSelection && spec.browse?.filters) {
      for (const filter of spec.browse.filters) {
        const value = context.getFilterSelection(filter.id);
        if (value) {
          preset[filter.field] = value;
        }
      }
    }
    const result = await openCreateModal(spec, {
      app,
      preset
    });
    if (result) {
      await context.reloadEntries();
      await app.workspace.openLinkText(result.filePath, result.filePath, true, { state: { mode: "source" } });
    }
  };
}
function createAutoActions(spec) {
  return createStandardActions(spec.kind, () => createAutoEditAction(spec));
}
function createAutoViewConfig(spec) {
  return {
    metadataFields: spec.browse?.metadata ?? [],
    actions: createAutoActions(spec),
    handleCreate: createAutoCreateHandler(spec)
  };
}
var init_auto_config = __esm({
  "src/features/data-manager/browse/auto-config.ts"() {
    "use strict";
    init_data_manager();
    init_auto_loader();
    init_action_factory();
    init_plugin_logger();
  }
});

// src/features/data-manager/browse/schema-from-spec.ts
function convertFilter(filter) {
  return {
    id: filter.id,
    label: filter.label,
    getValues: (entry) => {
      const value = entry[filter.field];
      return [value];
    },
    sortComparator: filter.sortComparator
  };
}
function convertSort(sort) {
  return {
    id: sort.id,
    label: sort.label,
    compare: sort.compareFn ?? ((a, b) => {
      const field = sort.field;
      if (!field) return 0;
      const aVal = a[field] ?? "";
      const bVal = b[field] ?? "";
      if (typeof aVal === "string" && typeof bVal === "string") {
        return aVal.localeCompare(bVal);
      }
      return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
    })
  };
}
function createListSchemaFromSpec(spec) {
  const browse = spec.browse;
  if (!browse) {
    return {
      filters: [],
      sorts: [],
      search: () => []
    };
  }
  return {
    filters: (browse.filters ?? []).map(convertFilter),
    sorts: (browse.sorts ?? []).map(convertSort),
    search: (entry) => {
      const searchFields = browse.search ?? [];
      return searchFields.map((fieldId) => {
        const value = entry[fieldId];
        return typeof value === "string" ? value : typeof value === "number" ? String(value) : void 0;
      }).filter((v) => Boolean(v));
    }
  };
}
var init_schema_from_spec = __esm({
  "src/features/data-manager/browse/schema-from-spec.ts"() {
    "use strict";
  }
});

// src/features/data-manager/browse/spec-to-config.ts
function generateViewConfigs(specs) {
  const result = {};
  for (const key in specs) {
    const spec = specs[key];
    if (spec) {
      result[key] = createAutoViewConfig(spec);
    }
  }
  return result;
}
function generateListSchemas(specs) {
  const result = {};
  for (const key in specs) {
    const spec = specs[key];
    if (spec) {
      result[key] = createListSchemaFromSpec(spec);
    }
  }
  return result;
}
var init_spec_to_config = __esm({
  "src/features/data-manager/browse/spec-to-config.ts"() {
    "use strict";
    init_auto_config();
    init_schema_from_spec();
  }
});

// src/workmodes/library/storage/utils.ts
function formatSigned(n) {
  return (n >= 0 ? "+" : "") + n;
}
function parseNumericValue(v) {
  if (!v) return null;
  const m = String(v).match(/-?\d+/);
  if (!m) return null;
  return Number(m[0]);
}
var init_utils = __esm({
  "src/workmodes/library/storage/utils.ts"() {
    "use strict";
  }
});

// src/workmodes/library/creatures/serializer.ts
function abilityModifierFromScore(score) {
  const n = typeof score === "number" ? score : parseNumericValue(score);
  if (n == null || Number.isNaN(n)) return null;
  return Math.floor((n - 10) / 2);
}
function getAbilityModifier(data, ability) {
  const abilityScore = data.abilities?.find((a) => a.ability === ability);
  return abilityScore ? abilityModifierFromScore(abilityScore.score) : null;
}
function getProficiencyBonus(data) {
  return parseNumericValue(data.pb);
}
function calculateSaveDc({
  abilityMod,
  proficiencyBonus,
  override
}) {
  if (override != null) return override;
  if (abilityMod == null || proficiencyBonus == null) return null;
  return 8 + abilityMod + proficiencyBonus;
}
function calculateAttackBonus({
  abilityMod,
  proficiencyBonus,
  override
}) {
  if (override != null) return override;
  if (abilityMod == null || proficiencyBonus == null) return null;
  return abilityMod + proficiencyBonus;
}
function composeAlignment(d) {
  const override = d.alignmentOverride?.trim();
  if (override) return override;
  const a = d.alignmentLawChaos?.trim();
  const b = d.alignmentGoodEvil?.trim();
  if (!a && !b) return void 0;
  if (a?.toLowerCase() === "neutral" && b?.toLowerCase() === "neutral") return "Neutral";
  return [a, b].filter(Boolean).join(" ");
}
function composeTypeLine(d) {
  const base = d.type?.trim();
  const tags = (d.typeTags ?? []).map((tag) => tag.trim()).filter(Boolean);
  if (base && tags.length) return `${base} (${tags.join(", ")})`;
  if (base) return base;
  if (tags.length) return tags.join(", ");
  return void 0;
}
function formatSpeedExtra(entry) {
  const parts = [entry.label];
  if (entry.distance) parts.push(entry.distance);
  if (entry.note) parts.push(entry.note);
  if (entry.hover) parts.push("(hover)");
  return parts.map((p) => p?.trim()).filter((p) => Boolean(p && p.length)).join(" ");
}
function serializeSense(sense) {
  if (sense.value) return sense.value;
  if (sense.type && sense.range) return `${sense.type} ${sense.range} ft.`;
  if (sense.type) return sense.type;
  return "";
}
function serializeLanguage(lang) {
  if (lang.value) return lang.value;
  if (lang.type === "telepathy" && lang.range) return `telepathy ${lang.range} ft.`;
  if (lang.type) return lang.type;
  return "";
}
function serializeSimpleToken(token) {
  return token.value;
}
function resolveSpellcastingData(d) {
  if (!d.spellcasting) return void 0;
  return withComputedSpellcasting(d, d.spellcasting);
}
function withComputedSpellcasting(d, base) {
  const abilityMod = base.ability ? getAbilityModifier(d, base.ability) : null;
  const proficiencyBonus = getProficiencyBonus(d);
  const saveDc = calculateSaveDc({ abilityMod, proficiencyBonus, override: base.saveDcOverride });
  const attackBonus = calculateAttackBonus({ abilityMod, proficiencyBonus, override: base.attackBonusOverride });
  return {
    ...base,
    computed: {
      abilityMod,
      proficiencyBonus,
      saveDc,
      attackBonus
    }
  };
}
function renderSpellcasting(lines, d, spellcasting) {
  const title = spellcasting.title?.trim() || "Spellcasting";
  lines.push(`## ${title}`);
  lines.push("");
  if (spellcasting.summary) {
    lines.push(spellcasting.summary.trim());
    lines.push("");
  }
  const saveDc = spellcasting.computed?.saveDc;
  const attackBonus = spellcasting.computed?.attackBonus;
  const summaryParts = [];
  if (saveDc != null) summaryParts.push(`Spell save DC ${saveDc}`);
  if (attackBonus != null) summaryParts.push(`${formatSigned(attackBonus)} to hit with spell attacks`);
  if (summaryParts.length) {
    lines.push(`*${summaryParts.join(", ")}*`);
    lines.push("");
  }
  if (spellcasting.notes && spellcasting.notes.length) {
    for (const note of spellcasting.notes) {
      if (note && note.trim()) {
        lines.push(note.trim());
      }
    }
    if (spellcasting.notes.some((note) => note && note.trim())) {
      lines.push("");
    }
  }
  for (const group of spellcasting.groups) {
    switch (group.type) {
      case "at-will":
        renderSpellGroup(lines, group.title ?? "At Will", group.spells);
        break;
      case "per-day": {
        const heading = group.title ?? group.uses;
        renderSpellGroup(lines, heading, group.spells, group.note);
        break;
      }
      case "level": {
        const base = group.title ?? formatSpellLevelHeading(group.level);
        const slots = group.slots == null ? void 0 : typeof group.slots === "number" ? `${group.slots} slot${group.slots === 1 ? "" : "s"}` : String(group.slots);
        const heading = slots ? `${base} (${slots})` : base;
        renderSpellGroup(lines, heading, group.spells, group.note);
        break;
      }
      case "custom": {
        renderSpellGroup(lines, group.title, group.spells ?? [], group.description);
        break;
      }
    }
  }
  if (lines[lines.length - 1] !== "") lines.push("");
}
function renderSpellGroup(lines, heading, spells, note) {
  lines.push(`### ${heading}`);
  lines.push("");
  if (note && note.trim()) {
    lines.push(note.trim());
    lines.push("");
  }
  if (!spells.length) {
    lines.push("- none");
    lines.push("");
    return;
  }
  for (const spell of spells) {
    const details = [];
    if (spell.prepared != null) details.push(spell.prepared ? "prepared" : "known");
    if (spell.notes) details.push(spell.notes);
    const suffix = details.length ? ` (${details.join(", ")})` : "";
    lines.push(`- ${spell.name}${suffix}`);
  }
  lines.push("");
}
function formatSpellLevelHeading(level) {
  if (level <= 0) return "Cantrips";
  const suffix = level === 1 ? "st" : level === 2 ? "nd" : level === 3 ? "rd" : "th";
  return `${level}${suffix} Level`;
}
function statblockToMarkdown(d) {
  var _a;
  const identity = [d.size?.trim(), composeTypeLine(d)].filter(Boolean).join(" ");
  const alignment = composeAlignment(d);
  const header = [identity, alignment].filter(Boolean).join(", ");
  const name = d.name || "Unnamed Creature";
  const lines = [];
  lines.push(`# ${name}`);
  if (header) lines.push(`*${header}*`);
  lines.push("");
  if (d.ac || d.initiative) lines.push(`AC ${d.ac ?? "-"}    Initiative ${d.initiative ?? "-"}`);
  if (d.hp || d.hitDice) lines.push(`HP ${d.hp ?? "-"}${d.hitDice ? ` (${d.hitDice})` : ""}`);
  const speeds = d.speeds;
  if (speeds) {
    const speedParts = [];
    if (Array.isArray(speeds)) {
      for (const entry of speeds) {
        const prefix = entry.type === "walk" ? "" : `${entry.type} `;
        const hoverSuffix = entry.hover ? " (hover)" : "";
        const noteSuffix = entry.note ? ` (${entry.note})` : "";
        speedParts.push(`${prefix}${entry.value}${hoverSuffix}${noteSuffix}`);
      }
    } else {
      if (speeds.walk?.distance) speedParts.push(speeds.walk.distance);
      if (speeds.climb?.distance) speedParts.push(`climb ${speeds.climb.distance}`);
      if (speeds.swim?.distance) speedParts.push(`swim ${speeds.swim.distance}`);
      if (speeds.fly?.distance) speedParts.push(`fly ${speeds.fly.distance}${speeds.fly.hover ? " (hover)" : ""}`);
      if (speeds.burrow?.distance) speedParts.push(`burrow ${speeds.burrow.distance}`);
      if (speeds.extras) {
        for (const extra of speeds.extras) {
          speedParts.push(formatSpeedExtra(extra));
        }
      }
    }
    if (speedParts.length) lines.push(`Speed ${speedParts.join(", ")}`);
  }
  lines.push("");
  if (d.abilities && d.abilities.length) {
    lines.push("| Ability | Score |");
    lines.push("| ------: | :---- |");
    const abilityLabels = { str: "STR", dex: "DEX", con: "CON", int: "INT", wis: "WIS", cha: "CHA" };
    const orderedAbilities = ["str", "dex", "con", "int", "wis", "cha"];
    for (const key of orderedAbilities) {
      const ability = d.abilities.find((a) => a.ability === key);
      if (ability) {
        lines.push(`| ${abilityLabels[key]} | ${ability.score} |`);
      }
    }
    lines.push("");
  }
  const pbValue = parseNumericValue(d.pb);
  if (d.saves && d.saves.length) {
    const abilityLabels = { str: "Str", dex: "Dex", con: "Con", int: "Int", wis: "Wis", cha: "Cha" };
    const parts = d.saves.map((save) => `${abilityLabels[save.ability]} ${formatSigned(save.bonus)}`);
    lines.push(`Saves ${parts.join(", ")}`);
  }
  if (d.skills && d.skills.length) {
    const parts = d.skills.map((skill) => `${skill.name} ${formatSigned(skill.bonus)}`);
    lines.push(`Skills ${parts.join(", ")}`);
  }
  const sensesParts = [];
  if (d.sensesList && d.sensesList.length) {
    sensesParts.push(d.sensesList.map(serializeSense).filter(Boolean).join(", "));
  }
  const passiveChunk = d.passivesList && d.passivesList.length ? d.passivesList.map(serializeSimpleToken).filter(Boolean).join("; ") : "";
  if (sensesParts.length || passiveChunk) {
    const tail = passiveChunk ? sensesParts.length ? `; ${passiveChunk}` : passiveChunk : "";
    lines.push(`Senses ${[sensesParts.join(", "), tail].filter(Boolean).join("")}`);
  }
  if (d.damageVulnerabilitiesList && d.damageVulnerabilitiesList.length) {
    lines.push(`Vulnerabilities ${d.damageVulnerabilitiesList.map(serializeSimpleToken).filter(Boolean).join(", ")}`);
  }
  if (d.damageResistancesList && d.damageResistancesList.length) {
    lines.push(`Resistances ${d.damageResistancesList.map(serializeSimpleToken).filter(Boolean).join(", ")}`);
  }
  if (d.damageImmunitiesList && d.damageImmunitiesList.length) {
    lines.push(`Immunities ${d.damageImmunitiesList.map(serializeSimpleToken).filter(Boolean).join(", ")}`);
  }
  if (d.conditionImmunitiesList && d.conditionImmunitiesList.length) {
    lines.push(`Condition Immunities ${d.conditionImmunitiesList.map(serializeSimpleToken).filter(Boolean).join(", ")}`);
  }
  if (d.languagesList && d.languagesList.length) {
    lines.push(`Languages ${d.languagesList.map(serializeLanguage).filter(Boolean).join(", ")}`);
  }
  if (d.gearList && d.gearList.length) {
    lines.push(`Gear ${d.gearList.map(serializeSimpleToken).filter(Boolean).join(", ")}`);
  }
  if (d.cr || d.pb || d.xp) {
    const bits = [];
    if (d.cr) bits.push(`CR ${d.cr}`);
    if (pbValue != null && !Number.isNaN(pbValue) && pbValue !== 0) bits.push(`PB ${formatSigned(pbValue)}`);
    if (d.xp) bits.push(`XP ${d.xp}`);
    if (bits.length) lines.push(bits.join("; "));
  }
  lines.push("");
  const entries = d.entries && d.entries.length ? d.entries : d.actionsList && d.actionsList.length ? d.actionsList.map((a) => ({ category: "action", ...a })) : void 0;
  if (entries && entries.length) {
    const groups = { trait: [], action: [], bonus: [], reaction: [], legendary: [] };
    for (const e of entries) {
      (groups[_a = e.category] || (groups[_a] = [])).push(e);
    }
    const renderGroup = (title, arr) => {
      if (!arr || arr.length === 0) return;
      lines.push(`## ${title}
`);
      for (const a of arr) {
        const headParts = [a.name, a.recharge].filter(Boolean).join(" ");
        lines.push(`- **${headParts}**`);
        const sub = [];
        if (a.kind) sub.push(a.kind);
        if (a.to_hit) sub.push(`to hit ${a.to_hit}`);
        else if (a.to_hit_from) {
          const abil = a.to_hit_from.ability;
          const abilMod = abil === "best_of_str_dex" ? Math.max(abilityModifierFromScore(d.str) ?? 0, abilityModifierFromScore(d.dex) ?? 0) : abilityModifierFromScore(d[abil]) ?? 0;
          const pb = parseNumericValue(d.pb) ?? 0;
          const total = abilMod + (a.to_hit_from.proficient ? pb : 0);
          sub.push(`to hit ${formatSigned(total)}`);
        }
        if (a.range) sub.push(a.range);
        if (a.target) sub.push(a.target);
        if (a.damage) sub.push(a.damage);
        else if (a.damage_from) {
          const abilKey = a.damage_from.ability;
          const abilMod = abilKey ? abilKey === "best_of_str_dex" ? Math.max(abilityModifierFromScore(d.str) ?? 0, abilityModifierFromScore(d.dex) ?? 0) : abilityModifierFromScore(d[abilKey]) ?? 0 : 0;
          const bonus = a.damage_from.bonus ? ` ${a.damage_from.bonus}` : "";
          const modTxt = abilMod ? ` ${formatSigned(abilMod)}` : "";
          sub.push(`${a.damage_from.dice}${modTxt}${bonus}`.trim());
        }
        if (a.save_ability) sub.push(`Save ${a.save_ability}${a.save_dc ? ` DC ${a.save_dc}` : ""}${a.save_effect ? ` (${a.save_effect})` : ""}`);
        if (sub.length) lines.push(`  - ${sub.join(", ")}`);
        if (a.text && a.text.trim()) lines.push(`  ${a.text.trim()}`);
      }
      lines.push("");
    };
    renderGroup("Traits", groups.trait);
    renderGroup("Actions", groups.action);
    renderGroup("Bonus Actions", groups.bonus);
    renderGroup("Reactions", groups.reaction);
    renderGroup("Legendary Actions", groups.legendary);
  } else {
    if (d.traits) {
      lines.push("## Traits\n");
      lines.push(d.traits.trim());
      lines.push("");
    }
    if (d.actions) {
      lines.push("## Actions\n");
      lines.push(d.actions.trim());
      lines.push("");
    }
    if (d.legendary) {
      lines.push("## Legendary Actions\n");
      lines.push(d.legendary.trim());
      lines.push("");
    }
  }
  const spellcasting = resolveSpellcastingData(d);
  if (spellcasting && spellcasting.groups.length) {
    renderSpellcasting(lines, d, spellcasting);
  }
  return lines.join("\n");
}
var init_serializer = __esm({
  "src/workmodes/library/creatures/serializer.ts"() {
    "use strict";
    init_utils();
  }
});

// src/workmodes/library/creatures/constants.ts
var CREATURE_SIZES, CREATURE_TYPES, CREATURE_ALIGNMENT_LAW_CHAOS, CREATURE_ALIGNMENT_GOOD_EVIL, CREATURE_ABILITY_KEYS, CREATURE_ABILITY_LABELS, CREATURE_ABILITIES, CREATURE_SKILLS, CREATURE_ENTRY_CATEGORIES, CREATURE_ABILITY_SELECTIONS, CREATURE_SAVE_OPTIONS, CREATURE_MOVEMENT_TYPES, CREATURE_DAMAGE_PRESETS, CREATURE_CONDITION_PRESETS, CREATURE_SENSE_TYPES, CREATURE_LANGUAGE_PRESETS;
var init_constants = __esm({
  "src/workmodes/library/creatures/constants.ts"() {
    "use strict";
    CREATURE_SIZES = [
      "Tiny",
      "Small",
      "Medium",
      "Large",
      "Huge",
      "Gargantuan"
    ];
    CREATURE_TYPES = [
      "Aberration",
      "Beast",
      "Celestial",
      "Construct",
      "Dragon",
      "Elemental",
      "Fey",
      "Fiend",
      "Giant",
      "Humanoid",
      "Monstrosity",
      "Ooze",
      "Plant",
      "Undead"
    ];
    CREATURE_ALIGNMENT_LAW_CHAOS = [
      "Lawful",
      "Neutral",
      "Chaotic"
    ];
    CREATURE_ALIGNMENT_GOOD_EVIL = [
      "Good",
      "Neutral",
      "Evil"
    ];
    CREATURE_ABILITY_KEYS = ["str", "dex", "con", "int", "wis", "cha"];
    CREATURE_ABILITY_LABELS = ["STR", "DEX", "CON", "INT", "WIS", "CHA"];
    CREATURE_ABILITIES = [
      { key: "str", label: "STR" },
      { key: "dex", label: "DEX" },
      { key: "con", label: "CON" },
      { key: "int", label: "INT" },
      { key: "wis", label: "WIS" },
      { key: "cha", label: "CHA" }
    ];
    CREATURE_SKILLS = [
      ["Athletics", "str"],
      ["Acrobatics", "dex"],
      ["Sleight of Hand", "dex"],
      ["Stealth", "dex"],
      ["Arcana", "int"],
      ["History", "int"],
      ["Investigation", "int"],
      ["Nature", "int"],
      ["Religion", "int"],
      ["Animal Handling", "wis"],
      ["Insight", "wis"],
      ["Medicine", "wis"],
      ["Perception", "wis"],
      ["Survival", "wis"],
      ["Deception", "cha"],
      ["Intimidation", "cha"],
      ["Performance", "cha"],
      ["Persuasion", "cha"]
    ];
    CREATURE_ENTRY_CATEGORIES = [
      ["trait", "Eigenschaft"],
      ["action", "Aktion"],
      ["bonus", "Bonusaktion"],
      ["reaction", "Reaktion"],
      ["legendary", "Legend\xE4re Aktion"]
    ];
    CREATURE_ABILITY_SELECTIONS = [
      "",
      "best_of_str_dex",
      ...CREATURE_ABILITY_KEYS
    ];
    CREATURE_SAVE_OPTIONS = [
      "",
      ...CREATURE_ABILITY_LABELS
    ];
    CREATURE_MOVEMENT_TYPES = [
      ["walk", "Gehen"],
      ["climb", "Klettern"],
      ["fly", "Fliegen"],
      ["swim", "Schwimmen"],
      ["burrow", "Graben"]
    ];
    CREATURE_DAMAGE_PRESETS = [
      "Acid",
      "Bludgeoning",
      "Bludgeoning (magisch)",
      "Bludgeoning (nichtmagisch)",
      "Cold",
      "Fire",
      "Force",
      "Lightning",
      "Necrotic",
      "Piercing",
      "Piercing (magisch)",
      "Piercing (nichtmagisch)",
      "Poison",
      "Psychic",
      "Radiant",
      "Slashing",
      "Slashing (magisch)",
      "Slashing (nichtmagisch)",
      "Thunder",
      "Alle au\xDFer Force",
      "Alle au\xDFer Psychic",
      "Nichtmagische Angriffe",
      "Magische Angriffe",
      "Nichtmagische Waffen",
      "Nichtmagische Angriffe (nicht versilbert)",
      "Nichtmagische Angriffe (nicht aus Adamantit)"
    ];
    CREATURE_CONDITION_PRESETS = [
      "Blinded",
      "Charmed",
      "Deafened",
      "Exhaustion",
      "Frightened",
      "Grappled",
      "Incapacitated",
      "Invisible",
      "Paralyzed",
      "Petrified",
      "Poisoned",
      "Prone",
      "Restrained",
      "Stunned",
      "Unconscious"
    ];
    CREATURE_SENSE_TYPES = [
      { key: "blindsight", label: "Blindsight" },
      { key: "darkvision", label: "Darkvision" },
      { key: "tremorsense", label: "Tremorsense" },
      { key: "truesight", label: "Truesight" }
    ];
    CREATURE_LANGUAGE_PRESETS = [
      "Common",
      "Dwarvish",
      "Elvish",
      "Giant",
      "Gnomish",
      "Goblin",
      "Halfling",
      "Orc",
      "Abyssal",
      "Celestial",
      "Draconic",
      "Deep Speech",
      "Infernal",
      "Primordial",
      "Aquan",
      "Auran",
      "Ignan",
      "Terran",
      "Sylvan",
      "Undercommon",
      "Druidic",
      "Thieves' Cant"
    ];
  }
});

// src/workmodes/library/creatures/create-spec.ts
function renderSpellcastingEntry(container, entry, ctx) {
  const configSection = container.createDiv({ cls: "sm-cc-spell-config" });
  configSection.createEl("span", { text: "F\xE4higkeit:", cls: "sm-cc-spell-label" });
  const abilitySelect = configSection.createEl("select", {
    cls: "sm-cc-compact-select"
  });
  const abilities = [
    { value: "int", label: "INT" },
    { value: "wis", label: "WIS" },
    { value: "cha", label: "CHA" },
    { value: "str", label: "STR" },
    { value: "dex", label: "DEX" },
    { value: "con", label: "CON" }
  ];
  abilities.forEach((ab) => {
    const opt = abilitySelect.createEl("option", { value: ab.value, text: ab.label });
    if (ab.value === (entry["spellcasting.ability"] || "int")) opt.selected = true;
  });
  abilitySelect.addEventListener("change", () => {
    entry["spellcasting.ability"] = abilitySelect.value;
  });
  configSection.createEl("span", { text: "Zauber DC:", cls: "sm-cc-spell-label" });
  const dcInput = configSection.createEl("input", {
    type: "number",
    cls: "sm-cc-compact-number",
    value: String(entry["spellcasting.saveDC"] || 10),
    placeholder: "DC"
  });
  dcInput.addEventListener("input", () => {
    entry["spellcasting.saveDC"] = parseInt(dcInput.value) || 10;
  });
  configSection.createEl("span", { text: "Angriffsbonus:", cls: "sm-cc-spell-label" });
  const bonusWrapper = configSection.createDiv({ cls: "sm-cc-entry-row" });
  bonusWrapper.createEl("span", { text: "+" });
  const bonusInput = bonusWrapper.createEl("input", {
    type: "number",
    cls: "sm-cc-compact-number",
    value: String(entry["spellcasting.attackBonus"] || 0),
    placeholder: "Bonus"
  });
  bonusInput.addEventListener("input", () => {
    entry["spellcasting.attackBonus"] = parseInt(bonusInput.value) || 0;
  });
  configSection.createEl("span", { text: "Ohne:", cls: "sm-cc-spell-label" });
  const componentsDiv = configSection.createDiv({ cls: "sm-cc-entry-row" });
  const excludedComponents = entry["spellcasting.excludeComponents"] || [];
  ["V", "S", "M"].forEach((comp) => {
    const checkbox = componentsDiv.createEl("input", {
      type: "checkbox",
      attr: { id: `exclude-${comp}` }
    });
    checkbox.checked = excludedComponents.includes(comp);
    checkbox.addEventListener("change", () => {
      const current = entry["spellcasting.excludeComponents"] || [];
      if (checkbox.checked && !current.includes(comp)) {
        current.push(comp);
      } else if (!checkbox.checked) {
        const index = current.indexOf(comp);
        if (index > -1) current.splice(index, 1);
      }
      entry["spellcasting.excludeComponents"] = current;
    });
    const label = componentsDiv.createEl("label", {
      text: comp,
      attr: { for: `exclude-${comp}` },
      cls: "sm-cc-checkbox-label"
    });
    label.style.marginRight = "12px";
  });
  const listsSection = container.createDiv({ cls: "sm-cc-spell-lists" });
  listsSection.createEl("h4", { text: "Zauberlisten", cls: "sm-cc-spell-label" });
  const spellLists = entry["spellcasting.spellLists"] || [];
  spellLists.forEach((list, index) => {
    const listItem = listsSection.createDiv({ cls: "sm-cc-spell-list-item" });
    const freqInput = listItem.createEl("input", {
      cls: "sm-cc-spell-frequency",
      value: list.frequency || "At Will",
      placeholder: "Frequency"
    });
    freqInput.addEventListener("input", () => {
      list.frequency = freqInput.value;
      ctx.requestRender();
    });
    const spellsDiv = listItem.createDiv({ cls: "sm-cc-spell-names" });
    const spells = list.spells || [];
    spells.forEach((spell) => {
      spellsDiv.createEl("span", {
        text: spell,
        cls: "sm-cc-spell-chip"
      });
    });
    const addSpellBtn = listItem.createEl("button", {
      cls: "sm-cc-compact-btn",
      text: "+ Zauber"
    });
    addSpellBtn.addEventListener("click", () => {
    });
  });
  const addListBtn = listsSection.createEl("button", {
    cls: "sm-cc-compact-btn",
    text: "+ Neue Zauberliste"
  });
  addListBtn.addEventListener("click", () => {
    if (!entry["spellcasting.spellLists"]) {
      entry["spellcasting.spellLists"] = [];
    }
    entry["spellcasting.spellLists"].push({
      frequency: "1/Tag",
      spells: []
    });
    ctx.requestRender();
  });
}
function renderAttackEffect(container, entry, ctx) {
  const effectCard = container.createDiv({ cls: "sm-cc-effect-card" });
  effectCard.createEl("h5", { text: "Angriff", cls: "sm-cc-effect-title" });
  const attackContent = effectCard.createDiv({ cls: "sm-cc-effect-content" });
  const configRow = attackContent.createDiv({ cls: "sm-cc-field-row" });
  const typeSelect = configRow.createEl("select", {
    cls: "sm-cc-compact-select",
    value: entry["attack.type"] || "melee"
  });
  ["melee", "ranged"].forEach((type2) => {
    const opt = typeSelect.createEl("option", { value: type2, text: type2 });
    if (type2 === entry["attack.type"]) opt.selected = true;
  });
  typeSelect.addEventListener("change", () => {
    entry["attack.type"] = typeSelect.value;
    ctx.requestRender();
  });
  configRow.createEl("span", { text: "+" });
  const bonusInput = configRow.createEl("input", {
    type: "number",
    cls: "sm-cc-compact-number",
    value: String(entry["attack.bonus"] || 0),
    placeholder: "bonus"
  });
  bonusInput.addEventListener("input", () => {
    entry["attack.bonus"] = parseInt(bonusInput.value) || 0;
  });
  if (entry["attack.type"] === "melee") {
    configRow.createEl("span", { text: "Reichweite:" });
    const reachInput = configRow.createEl("input", {
      cls: "sm-cc-compact-text",
      value: entry["attack.reach"] || "",
      placeholder: "5 ft."
    });
    reachInput.addEventListener("input", () => {
      entry["attack.reach"] = reachInput.value;
    });
  } else {
    configRow.createEl("span", { text: "Distanz:" });
    const rangeInput = configRow.createEl("input", {
      cls: "sm-cc-compact-text",
      value: entry["attack.range"] || "",
      placeholder: "30/120 ft."
    });
    rangeInput.addEventListener("input", () => {
      entry["attack.range"] = rangeInput.value;
    });
  }
  const damageRow = attackContent.createDiv({ cls: "sm-cc-field-row" });
  damageRow.createEl("span", { text: "Schaden:", cls: "sm-cc-field-label" });
  const damageList = entry["attack.damage"] || [];
  if (damageList.length > 0) {
    const firstDamage = damageList[0];
    const damageText = `${firstDamage.dice || ""}${firstDamage.bonus ? "+" + firstDamage.bonus : ""} ${firstDamage.type || ""}`;
    damageRow.createEl("span", { text: damageText, cls: "sm-cc-damage-text" });
  }
  const addDamageBtn = damageRow.createEl("button", {
    cls: "sm-cc-compact-btn",
    text: "+ Schaden"
  });
}
function renderSaveEffect(container, entry, ctx) {
  const effectCard = container.createDiv({ cls: "sm-cc-effect-card" });
  effectCard.createEl("h5", { text: "Rettungswurf", cls: "sm-cc-effect-title" });
  const saveContent = effectCard.createDiv({ cls: "sm-cc-effect-content" });
  const configRow = saveContent.createDiv({ cls: "sm-cc-field-row" });
  const abilitySelect = configRow.createEl("select", {
    cls: "sm-cc-compact-select"
  });
  const abilities = [
    { value: "str", label: "STR" },
    { value: "dex", label: "DEX" },
    { value: "con", label: "CON" },
    { value: "int", label: "INT" },
    { value: "wis", label: "WIS" },
    { value: "cha", label: "CHA" }
  ];
  abilities.forEach((ab) => {
    const opt = abilitySelect.createEl("option", { value: ab.value, text: ab.label });
    if (ab.value === entry["save.ability"]) opt.selected = true;
  });
  abilitySelect.addEventListener("change", () => {
    entry["save.ability"] = abilitySelect.value;
  });
  configRow.createEl("span", { text: "DC" });
  const dcInput = configRow.createEl("input", {
    type: "number",
    cls: "sm-cc-compact-number",
    value: String(entry["save.dc"] || 10),
    placeholder: "DC"
  });
  dcInput.addEventListener("input", () => {
    entry["save.dc"] = parseInt(dcInput.value) || 10;
  });
  const targetRow = saveContent.createDiv({ cls: "sm-cc-field-row" });
  targetRow.createEl("span", { text: "Ziele:", cls: "sm-cc-field-label" });
  const targetInput = targetRow.createEl("input", {
    cls: "sm-cc-compact-text",
    value: entry["save.area"] || "",
    placeholder: "z.B. 30 ft. cone"
  });
  targetInput.addEventListener("input", () => {
    entry["save.area"] = targetInput.value;
  });
  const effectsRow = saveContent.createDiv({ cls: "sm-cc-field-row" });
  effectsRow.createEl("span", { text: "Fehlschlag:", cls: "sm-cc-field-label" });
  const failDamage = entry["save.onFail.damage"];
  if (failDamage && failDamage.length > 0) {
    const damage = failDamage[0];
    effectsRow.createEl("span", {
      text: `${damage.dice} ${damage.type}`,
      cls: "sm-cc-damage-text"
    });
  }
}
function renderMultiattackEffect(container, entry, ctx) {
  const effectCard = container.createDiv({ cls: "sm-cc-effect-card" });
  effectCard.createEl("h5", { text: "Mehrfachangriff", cls: "sm-cc-effect-title" });
  const multiContent = effectCard.createDiv({ cls: "sm-cc-effect-content" });
  const attacksRow = multiContent.createDiv({ cls: "sm-cc-field-row" });
  attacksRow.createEl("span", { text: "Angriffe:", cls: "sm-cc-field-label" });
  const attacks = entry["multiattack.attacks"] || [];
  attacks.forEach((attack) => {
    const chip = attacksRow.createEl("span", {
      text: `${attack.count}x ${attack.name}`,
      cls: "sm-cc-attack-chip"
    });
  });
  const addAttackBtn = attacksRow.createEl("button", {
    cls: "sm-cc-compact-btn",
    text: "+ Angriff"
  });
}
var import_obsidian27, creatureSchema, basicInfoFields, combatStatsFields, movementFields, abilitiesFields, skillsFields, sensesLanguagesFields, resistancesFields, equipmentFields, spellcastingFields, entriesFields, creatureSpec;
var init_create_spec = __esm({
  "src/workmodes/library/creatures/create-spec.ts"() {
    "use strict";
    import_obsidian27 = require("obsidian");
    init_serializer();
    init_debug_logger();
    init_constants();
    creatureSchema = {
      parse: (data) => data,
      safeParse: (data) => {
        try {
          return { success: true, data };
        } catch (error) {
          return { success: false, error };
        }
      }
    };
    basicInfoFields = [
      {
        id: "name",
        label: "Name",
        type: "text",
        required: true,
        placeholder: "Kreaturname eingeben..."
      },
      {
        id: "size",
        label: "Gr\xF6\xDFe",
        type: "select",
        options: CREATURE_SIZES.map((s) => ({ value: s, label: s })),
        default: "Medium"
      },
      {
        id: "type",
        label: "Typ",
        type: "select",
        options: CREATURE_TYPES.map((t) => ({ value: t, label: t }))
      },
      {
        id: "typeTags",
        label: "Typ-Tags",
        type: "tokens",
        config: {
          fields: [{
            id: "value",
            type: "text",
            displayInChip: true,
            editable: true,
            placeholder: "Tag hinzuf\xFCgen..."
          }],
          primaryField: "value"
        },
        default: []
      },
      {
        id: "alignmentLawChaos",
        label: "Gesetz/Chaos",
        type: "select",
        options: CREATURE_ALIGNMENT_LAW_CHAOS.map((a) => ({ value: a, label: a }))
      },
      {
        id: "alignmentGoodEvil",
        label: "Gut/B\xF6se",
        type: "select",
        options: CREATURE_ALIGNMENT_GOOD_EVIL.map((a) => ({ value: a, label: a }))
      },
      {
        id: "alignmentOverride",
        label: "Gesinnung (Freiform)",
        type: "text",
        placeholder: "z.B. unaligned"
      }
    ];
    combatStatsFields = [
      {
        id: "ac",
        label: "AC",
        type: "text",
        placeholder: "z.B. 15 (Lederr\xFCstung)"
      },
      {
        id: "initiative",
        label: "INI",
        type: "text",
        placeholder: "z.B. +2"
      },
      {
        id: "hp",
        label: "TP",
        type: "text",
        placeholder: "z.B. 45"
      },
      {
        id: "hitDice",
        label: "TW",
        type: "text",
        placeholder: "z.B. 6d8+18"
      },
      {
        id: "cr",
        label: "CR",
        type: "text",
        placeholder: "z.B. 3"
      },
      {
        id: "xp",
        label: "EP",
        type: "text",
        placeholder: "z.B. 700"
      },
      {
        id: "pb",
        label: "\xDCB",
        type: "text",
        placeholder: "z.B. +2"
      }
    ];
    movementFields = [
      {
        id: "speeds",
        label: "Bewegungsraten",
        type: "tokens",
        config: {
          fields: [
            {
              id: "type",
              type: "select",
              displayInChip: true,
              editable: true,
              suggestions: CREATURE_MOVEMENT_TYPES.map(([key, label]) => ({ key, label })),
              placeholder: "Bewegungsart w\xE4hlen..."
            },
            {
              id: "value",
              type: "text",
              label: ": ",
              displayInChip: true,
              editable: true,
              unit: "ft.",
              placeholder: "30"
            },
            {
              id: "hover",
              type: "checkbox",
              displayInChip: true,
              editable: true,
              icon: "\u27E8hover\u27E9",
              visibleIf: (token) => token.type === "fly",
              default: false
            }
          ],
          primaryField: "type"
        },
        default: []
      }
    ];
    abilitiesFields = [
      {
        id: "abilities",
        label: "",
        type: "repeating",
        config: {
          static: true,
          // No add/remove/reorder controls
          synchronizeWidths: true,
          // Synchronize widths across all ability rows
          fields: [
            // Heading (ability abbreviation - STR, DEX, etc.)
            {
              id: "name",
              label: "",
              type: "heading",
              getValue: (data) => data.key?.toUpperCase() || ""
            },
            // Score
            {
              id: "score",
              label: "",
              type: "number-stepper",
              min: 1,
              max: 30,
              step: 1,
              autoSizeOnInput: false
              // Suppress auto-sizing on input for width sync
            },
            // Modifier (display)
            {
              id: "mod",
              label: "",
              type: "display",
              config: {
                compute: (data) => {
                  const score = data.score || 10;
                  const mod2 = Math.floor((score - 10) / 2);
                  return mod2;
                },
                prefix: (data) => {
                  const score = data.score || 10;
                  const mod2 = Math.floor((score - 10) / 2);
                  return mod2 >= 0 ? "+" : "";
                },
                maxTokens: 3
                // Format: +/-XX (e.g., "+5", "-1")
              }
            },
            // Save Proficiency (star icon - click to toggle)
            {
              id: "saveProf",
              label: "Save",
              type: "clickable-icon",
              icon: "\u2605",
              inactiveIcon: "\u2606"
            },
            // Save Modifier (conditional - only visible when save checkbox is true)
            // Initial value = ability modifier + proficiency bonus
            {
              id: "saveMod",
              label: "Save",
              type: "number-stepper",
              min: -10,
              max: 20,
              step: 1,
              autoSizeOnInput: false,
              // Suppress auto-sizing on input for width sync
              visibleIf: (data) => Boolean(data.saveProf),
              config: {
                // Auto-initialize with ability modifier + PB when field becomes visible
                init: (data, allFormData) => {
                  debugLogger.logField("saveMod", "init-function", "saveMod init called", data);
                  const score = data.score || 10;
                  debugLogger.logField("saveMod", "init-function", "Calculated score", { score });
                  const abilityMod = Math.floor((score - 10) / 2);
                  debugLogger.logField("saveMod", "init-function", "Calculated abilityMod", { abilityMod });
                  const pbStr = allFormData.pb || "+2";
                  const pb = parseInt(pbStr.replace(/[^\d-]/g, "")) || 2;
                  debugLogger.logField("saveMod", "init-function", "Using PB from form", { pbStr, pb });
                  const result = abilityMod + pb;
                  debugLogger.logField("saveMod", "init-function", "Returning result", { result });
                  return result;
                }
              }
            }
          ]
        },
        // Default: Array of ability entries (data) - template defined once above
        default: CREATURE_ABILITIES.map((ability) => ({
          key: ability.key,
          label: ability.label,
          score: 10,
          saveProf: false
          // saveMod will be auto-initialized when saveProf checkbox is checked
        }))
      }
    ];
    skillsFields = [
      {
        id: "skills",
        label: "Fertigkeiten",
        type: "tokens",
        config: {
          fields: [
            {
              id: "skill",
              type: "select",
              displayInChip: true,
              editable: true,
              suggestions: CREATURE_SKILLS.map(([name, ability]) => ({ key: name, label: name })),
              placeholder: "Fertigkeit w\xE4hlen..."
            },
            {
              id: "value",
              type: "text",
              label: " ",
              displayInChip: true,
              editable: true,
              placeholder: "+0"
            },
            {
              id: "expertise",
              type: "checkbox",
              displayInChip: true,
              editable: true,
              icon: "\u2605",
              default: false
            }
          ],
          primaryField: "skill",
          getInitialValue: (formData, skillName) => {
            const skillEntry = CREATURE_SKILLS.find(([name]) => name === skillName);
            if (!skillEntry) {
              return { skill: skillName, value: "+0", expertise: false };
            }
            const [, abilityKey] = skillEntry;
            const pbStr = formData.pb || "+2";
            const pb = parseInt(pbStr.replace(/[^\d-]/g, "")) || 2;
            const abilities = formData.abilities || [];
            const abilityEntry = abilities.find((a) => a.key === abilityKey || a.ability === abilityKey);
            const abilityScore = abilityEntry?.score || 10;
            const abilityMod = Math.floor((abilityScore - 10) / 2);
            const skillBonus = abilityMod + pb;
            const sign = skillBonus >= 0 ? "+" : "";
            const valueStr = `${sign}${skillBonus}`;
            return {
              skill: skillName,
              value: valueStr,
              expertise: false
            };
          },
          onTokenFieldChange: (token, fieldId, newValue, formData) => {
            if (fieldId !== "expertise") return;
            const skillName = token.skill;
            if (!skillName) return;
            const skillEntry = CREATURE_SKILLS.find(([name]) => name === skillName);
            if (!skillEntry) return;
            const [, abilityKey] = skillEntry;
            const pbStr = formData.pb || "+2";
            const pb = parseInt(pbStr.replace(/[^\d-]/g, "")) || 2;
            const abilities = formData.abilities || [];
            const abilityEntry = abilities.find((a) => a.key === abilityKey || a.ability === abilityKey);
            const abilityScore = abilityEntry?.score || 10;
            const abilityMod = Math.floor((abilityScore - 10) / 2);
            const expertise = newValue;
            const pbBonus = expertise ? 2 * pb : pb;
            const skillBonus = abilityMod + pbBonus;
            const sign = skillBonus >= 0 ? "+" : "";
            const valueStr = `${sign}${skillBonus}`;
            token.value = valueStr;
          }
        },
        default: []
      }
    ];
    sensesLanguagesFields = [
      {
        id: "sensesList",
        label: "Sinne",
        type: "tokens",
        config: {
          fields: [
            {
              id: "type",
              type: "select",
              displayInChip: true,
              editable: true,
              suggestions: CREATURE_SENSE_TYPES,
              placeholder: "Sinn w\xE4hlen..."
            },
            {
              id: "range",
              type: "text",
              label: ": ",
              displayInChip: true,
              editable: true,
              unit: "ft.",
              placeholder: "60",
              visibleIf: (token) => Boolean(token.type)
            }
          ],
          primaryField: "type"
        },
        default: []
      },
      {
        id: "passivesList",
        label: "Passive Werte",
        type: "tokens",
        config: {
          fields: [
            {
              id: "skill",
              type: "select",
              label: "Passive ",
              displayInChip: true,
              editable: true,
              suggestions: [
                { key: "Perception", label: "Perception" },
                { key: "Insight", label: "Insight" },
                { key: "Investigation", label: "Investigation" }
              ],
              placeholder: "Fertigkeit w\xE4hlen..."
            },
            {
              id: "value",
              type: "text",
              label: " ",
              displayInChip: true,
              editable: true,
              placeholder: "Wert"
            }
          ],
          primaryField: "skill"
          // chipTemplate removed - use automatic segment rendering for editability
        },
        default: []
      },
      {
        id: "languagesList",
        label: "Sprachen",
        type: "tokens",
        config: {
          fields: [
            {
              id: "value",
              type: "text",
              displayInChip: true,
              editable: true,
              placeholder: "Sprache hinzuf\xFCgen...",
              suggestions: CREATURE_LANGUAGE_PRESETS,
              visibleIf: (token) => !token.type
            },
            {
              id: "type",
              type: "select",
              displayInChip: true,
              editable: true,
              suggestions: [{ key: "telepathy", label: "Telepathy" }],
              placeholder: "Telepathie",
              optional: true,
              visibleIf: (token) => Boolean(token.type)
            },
            {
              id: "range",
              type: "text",
              label: ": ",
              displayInChip: true,
              editable: true,
              unit: "ft.",
              placeholder: "120",
              visibleIf: (token) => token.type === "telepathy"
            }
          ],
          primaryField: "value"
        },
        default: []
      }
    ];
    resistancesFields = [
      {
        id: "damageVulnerabilitiesList",
        label: "Schadensanf\xE4lligkeiten",
        type: "tokens",
        config: {
          fields: [{
            id: "value",
            type: "text",
            displayInChip: true,
            editable: true,
            placeholder: "Anf\xE4lligkeit hinzuf\xFCgen...",
            suggestions: CREATURE_DAMAGE_PRESETS
          }],
          primaryField: "value"
        },
        default: []
      },
      {
        id: "damageResistancesList",
        label: "Schadenswiderst\xE4nde",
        type: "tokens",
        config: {
          fields: [{
            id: "value",
            type: "text",
            displayInChip: true,
            editable: true,
            placeholder: "Widerstand hinzuf\xFCgen...",
            suggestions: CREATURE_DAMAGE_PRESETS
          }],
          primaryField: "value"
        },
        default: []
      },
      {
        id: "damageImmunitiesList",
        label: "Schadensimmunit\xE4ten",
        type: "tokens",
        config: {
          fields: [{
            id: "value",
            type: "text",
            displayInChip: true,
            editable: true,
            placeholder: "Immunit\xE4t hinzuf\xFCgen...",
            suggestions: CREATURE_DAMAGE_PRESETS
          }],
          primaryField: "value"
        },
        default: []
      },
      {
        id: "conditionImmunitiesList",
        label: "Zustandsimmunit\xE4ten",
        type: "tokens",
        config: {
          fields: [{
            id: "value",
            type: "text",
            displayInChip: true,
            editable: true,
            placeholder: "Zustand hinzuf\xFCgen...",
            suggestions: CREATURE_CONDITION_PRESETS
          }],
          primaryField: "value"
        },
        default: []
      }
    ];
    equipmentFields = [
      {
        id: "gearList",
        label: "Ausr\xFCstung",
        type: "tokens",
        config: {
          fields: [{
            id: "value",
            type: "text",
            displayInChip: true,
            editable: true,
            placeholder: "Gegenstand hinzuf\xFCgen..."
          }],
          primaryField: "value"
        },
        default: []
      }
    ];
    spellcastingFields = [
      {
        id: "spellcastingEntries",
        label: "Zauber & Zauberwirken",
        type: "repeating",
        config: {
          static: false,
          card: (context) => {
            const entry = context.entry;
            return {
              className: "sm-cc-spellcasting-entry",
              type: "spellcasting",
              badge: () => ({
                text: "Zauberwirken",
                variant: "spellcasting"
              }),
              renderName: (nameBox, ctx) => {
                const nameInput = nameBox.createEl("input", {
                  value: entry.name || "",
                  placeholder: "Zaubername oder Beschreibung",
                  cls: "sm-cc-entry-name-input",
                  attr: { type: "text" }
                });
                nameInput.addEventListener("input", () => {
                  entry.name = nameInput.value;
                });
                return nameInput;
              },
              renderBody: (card, ctx) => {
                const body = card.createDiv({ cls: "sm-cc-spell-body" });
                renderSpellcastingEntry(body, entry, ctx);
              }
            };
          }
        },
        default: []
      }
    ];
    entriesFields = [
      {
        id: "entries",
        label: "Eigenschaften & Aktionen (ohne Zauber)",
        type: "repeating",
        // Transform when saving: flatten keys to nested objects
        transform: (entries) => {
          if (!entries) return [];
          return entries.map((entry) => {
            const result = {};
            for (const [key, value] of Object.entries(entry)) {
              if (key.includes(".")) {
                if (value === void 0 || value === null || value === "") continue;
                const parts = key.split(".");
                let current = result;
                for (let i = 0; i < parts.length - 1; i++) {
                  if (!current[parts[i]]) {
                    current[parts[i]] = {};
                  }
                  current = current[parts[i]];
                }
                current[parts[parts.length - 1]] = value;
              } else {
                result[key] = value;
              }
            }
            if (result.save?.onSuccess) {
              const onSuccess = result.save.onSuccess;
              if (onSuccess.legacyText && !onSuccess.damage) {
                result.save.onSuccess = onSuccess.legacyText;
              }
            }
            const cleanEmpty = (obj) => {
              for (const key in obj) {
                if (obj[key] && typeof obj[key] === "object" && !Array.isArray(obj[key])) {
                  cleanEmpty(obj[key]);
                  if (Object.keys(obj[key]).length === 0) {
                    delete obj[key];
                  }
                }
              }
            };
            cleanEmpty(result);
            return result;
          });
        },
        config: {
          static: false,
          // Use card-based rendering instead of template fields
          card: (context) => {
            const entry = context.entry;
            const entryType = entry.entryType || "special";
            const category = entry.category || "trait";
            return {
              className: "sm-cc-creature-entry",
              type: entryType,
              // Badge showing category
              badge: () => {
                const categoryLabel = CREATURE_ENTRY_CATEGORIES.find(
                  ([id]) => id === category
                )?.[1] ?? "Unknown";
                return {
                  text: categoryLabel,
                  variant: category
                };
              },
              // Simple single-line header with just name
              renderName: (nameBox, ctx) => {
                const nameInput = nameBox.createEl("input", {
                  value: entry.name || "",
                  placeholder: "Eigenschaft benennen...",
                  cls: "sm-cc-entry-name-full",
                  attr: { type: "text" }
                });
                nameInput.addEventListener("input", () => {
                  entry.name = nameInput.value;
                });
                return nameInput;
              },
              // Modular trigger/effect based rendering
              renderBody: (card, ctx) => {
                const body = card.createDiv({ cls: "sm-cc-entry-body-modular" });
                const triggerSection = body.createDiv({ cls: "sm-cc-trigger-section" });
                triggerSection.createEl("h4", { text: "TRIGGER", cls: "sm-cc-section-label" });
                const triggerContent = triggerSection.createDiv({ cls: "sm-cc-trigger-content" });
                const activationRow = triggerContent.createDiv({ cls: "sm-cc-field-row" });
                activationRow.createEl("span", { text: "Aktivierung:", cls: "sm-cc-field-label" });
                const activationSelect = activationRow.createEl("select", {
                  cls: "sm-cc-compact-select",
                  value: entry["trigger.activation"] || "action"
                });
                const activationOptions = [
                  { value: "action", label: "Aktion" },
                  { value: "bonus", label: "Bonusaktion" },
                  { value: "reaction", label: "Reaktion" },
                  { value: "passive", label: "Passiv" },
                  { value: "automatic", label: "Automatisch" }
                ];
                activationOptions.forEach((opt) => {
                  const option = activationSelect.createEl("option", { value: opt.value, text: opt.label });
                  if (opt.value === (entry["trigger.activation"] || "action")) option.selected = true;
                });
                activationSelect.addEventListener("change", () => {
                  entry["trigger.activation"] = activationSelect.value;
                  if (activationSelect.value === "bonus") entry.category = "bonus";
                  else if (activationSelect.value === "reaction") entry.category = "reaction";
                  else if (activationSelect.value === "passive") entry.category = "trait";
                  else entry.category = "action";
                  ctx.requestRender();
                });
                const modifiersRow = triggerContent.createDiv({ cls: "sm-cc-field-row" });
                modifiersRow.createEl("span", { text: "Modifikatoren:", cls: "sm-cc-field-label" });
                const rechargeCheck = modifiersRow.createEl("input", {
                  type: "checkbox",
                  attr: { id: "recharge-check" }
                });
                rechargeCheck.checked = Boolean(entry.recharge);
                rechargeCheck.addEventListener("change", () => {
                  if (rechargeCheck.checked) {
                    entry.recharge = "5-6";
                  } else {
                    delete entry.recharge;
                  }
                  ctx.requestRender();
                });
                modifiersRow.createEl("label", {
                  text: "Aufladung:",
                  attr: { for: "recharge-check" },
                  cls: "sm-cc-checkbox-label"
                });
                if (entry.recharge) {
                  const rechargeMin = modifiersRow.createEl("input", {
                    type: "number",
                    cls: "sm-cc-tiny-number",
                    value: String(entry.recharge).split("-")[0] || "5"
                  });
                  modifiersRow.createEl("span", { text: "-" });
                  const rechargeMax = modifiersRow.createEl("input", {
                    type: "number",
                    cls: "sm-cc-tiny-number",
                    value: String(entry.recharge).split("-")[1] || "6"
                  });
                  [rechargeMin, rechargeMax].forEach((input) => {
                    input.addEventListener("input", () => {
                      entry.recharge = `${rechargeMin.value}-${rechargeMax.value}`;
                    });
                  });
                }
                const limitedCheck = modifiersRow.createEl("input", {
                  type: "checkbox",
                  attr: { id: "limited-check" }
                });
                limitedCheck.checked = Boolean(entry.limitedUse);
                limitedCheck.addEventListener("change", () => {
                  if (limitedCheck.checked) {
                    entry.limitedUse = { count: 3, reset: "day" };
                  } else {
                    delete entry.limitedUse;
                  }
                  ctx.requestRender();
                });
                modifiersRow.createEl("label", {
                  text: "Begrenzt:",
                  attr: { for: "limited-check" },
                  cls: "sm-cc-checkbox-label"
                });
                if (entry.limitedUse) {
                  const limitInput = modifiersRow.createEl("input", {
                    type: "number",
                    cls: "sm-cc-tiny-number",
                    value: String(entry.limitedUse?.count || 3)
                  });
                  modifiersRow.createEl("span", { text: "pro" });
                  const resetSelect = modifiersRow.createEl("select", {
                    cls: "sm-cc-tiny-select"
                  });
                  const resetOptions = [
                    { value: "day", label: "Tag" },
                    { value: "short-rest", label: "Kurze Rast" },
                    { value: "long-rest", label: "Lange Rast" }
                  ];
                  resetOptions.forEach((opt) => {
                    const option = resetSelect.createEl("option", { value: opt.value, text: opt.label });
                    if (opt.value === entry.limitedUse?.reset) option.selected = true;
                  });
                  limitInput.addEventListener("input", () => {
                    if (!entry.limitedUse) entry.limitedUse = {};
                    entry.limitedUse.count = parseInt(limitInput.value) || 1;
                  });
                  resetSelect.addEventListener("change", () => {
                    if (!entry.limitedUse) entry.limitedUse = {};
                    entry.limitedUse.reset = resetSelect.value;
                  });
                }
                const legendaryCheck = modifiersRow.createEl("input", {
                  type: "checkbox",
                  attr: { id: "legendary-check" }
                });
                legendaryCheck.checked = Boolean(entry["trigger.legendaryCost"]);
                legendaryCheck.addEventListener("change", () => {
                  if (legendaryCheck.checked) {
                    entry["trigger.legendaryCost"] = 1;
                    entry.category = "legendary";
                  } else {
                    delete entry["trigger.legendaryCost"];
                    if (entry["trigger.activation"] !== "passive") {
                      entry.category = "action";
                    }
                  }
                  ctx.requestRender();
                });
                modifiersRow.createEl("label", {
                  text: "Legend\xE4r:",
                  attr: { for: "legendary-check" },
                  cls: "sm-cc-checkbox-label"
                });
                if (entry["trigger.legendaryCost"]) {
                  const costInput = modifiersRow.createEl("input", {
                    type: "number",
                    cls: "sm-cc-tiny-number",
                    value: String(entry["trigger.legendaryCost"] || 1)
                  });
                  modifiersRow.createEl("span", { text: "Kosten" });
                  costInput.addEventListener("input", () => {
                    entry["trigger.legendaryCost"] = parseInt(costInput.value) || 1;
                  });
                }
                if (entry["trigger.activation"] === "reaction") {
                  const reactionRow = triggerContent.createDiv({ cls: "sm-cc-field-row" });
                  reactionRow.createEl("span", { text: "Ausl\xF6ser:", cls: "sm-cc-field-label" });
                  const reactionInput = reactionRow.createEl("input", {
                    cls: "sm-cc-long-text",
                    value: entry["trigger.reactionTrigger"] || "",
                    placeholder: "z.B. wird getroffen, sieht einen Zauber gewirkt..."
                  });
                  reactionInput.addEventListener("input", () => {
                    entry["trigger.reactionTrigger"] = reactionInput.value;
                  });
                } else if (entry["trigger.activation"] === "automatic") {
                  const timingRow = triggerContent.createDiv({ cls: "sm-cc-field-row" });
                  timingRow.createEl("span", { text: "Zeitpunkt:", cls: "sm-cc-field-label" });
                  const timingSelect = timingRow.createEl("select", {
                    cls: "sm-cc-compact-select",
                    value: entry["trigger.automaticTiming"] || "start-of-turn"
                  });
                  const timingOptions = [
                    { value: "start-of-turn", label: "Am Beginn der Runde der Kreatur" },
                    { value: "end-of-turn", label: "Am Ende der Runde der Kreatur" },
                    { value: "start-of-any-turn", label: "Am Beginn jeder Kreatur-Runde" },
                    { value: "end-of-any-turn", label: "Am Ende jeder Kreatur-Runde" }
                  ];
                  timingOptions.forEach((opt) => {
                    const option = timingSelect.createEl("option", { value: opt.value, text: opt.label });
                    if (opt.value === entry["trigger.automaticTiming"]) option.selected = true;
                  });
                  timingSelect.addEventListener("change", () => {
                    entry["trigger.automaticTiming"] = timingSelect.value;
                  });
                }
                const targetingRow = triggerContent.createDiv({ cls: "sm-cc-field-row" });
                targetingRow.createEl("span", { text: "Zielbereich:", cls: "sm-cc-field-label" });
                const targetTypeSelect = targetingRow.createEl("select", {
                  cls: "sm-cc-compact-select",
                  value: entry["trigger.targeting.type"] || "single"
                });
                const targetTypes = [
                  { value: "self", label: "Selbst" },
                  { value: "single", label: "Einzelziel" },
                  { value: "multiple", label: "Mehrere Ziele" },
                  { value: "area", label: "Bereich" }
                ];
                targetTypes.forEach((opt) => {
                  const option = targetTypeSelect.createEl("option", { value: opt.value, text: opt.label });
                  if (opt.value === (entry["trigger.targeting.type"] || "single")) option.selected = true;
                });
                targetTypeSelect.addEventListener("change", () => {
                  if (!entry["trigger.targeting"]) entry["trigger.targeting"] = {};
                  entry["trigger.targeting"].type = targetTypeSelect.value;
                  ctx.requestRender();
                });
                const targetType = entry["trigger.targeting.type"] || "single";
                if (targetType === "single" || targetType === "multiple") {
                  if (targetType === "multiple") {
                    targetingRow.createEl("span", { text: "Anzahl:" });
                    const countInput = targetingRow.createEl("input", {
                      type: "number",
                      cls: "sm-cc-tiny-number",
                      value: String(entry["trigger.targeting.count"] || 2)
                    });
                    countInput.addEventListener("input", () => {
                      if (!entry["trigger.targeting"]) entry["trigger.targeting"] = {};
                      entry["trigger.targeting"].count = parseInt(countInput.value) || 1;
                    });
                  }
                  targetingRow.createEl("span", { text: "Reichweite:" });
                  const rangeInput = targetingRow.createEl("input", {
                    cls: "sm-cc-compact-text",
                    value: entry["trigger.targeting.range"] || "",
                    placeholder: "z.B. 30 ft."
                  });
                  rangeInput.addEventListener("input", () => {
                    if (!entry["trigger.targeting"]) entry["trigger.targeting"] = {};
                    entry["trigger.targeting"].range = rangeInput.value;
                  });
                  const sightCheck = targetingRow.createEl("input", {
                    type: "checkbox",
                    attr: { id: "sight-required" }
                  });
                  sightCheck.checked = entry["trigger.targeting.sightRequired"] === true;
                  sightCheck.addEventListener("change", () => {
                    if (!entry["trigger.targeting"]) entry["trigger.targeting"] = {};
                    entry["trigger.targeting"].sightRequired = sightCheck.checked;
                  });
                  targetingRow.createEl("label", {
                    text: "Sichtlinie erforderlich",
                    attr: { for: "sight-required" },
                    cls: "sm-cc-checkbox-label"
                  });
                } else if (targetType === "area") {
                  targetingRow.createEl("span", { text: "Form:" });
                  const shapeSelect = targetingRow.createEl("select", {
                    cls: "sm-cc-compact-select",
                    value: entry["trigger.targeting.shape"] || "cone"
                  });
                  const shapes = [
                    { value: "cone", label: "Kegel" },
                    { value: "emanation", label: "Aura" },
                    { value: "line", label: "Linie" },
                    { value: "cube", label: "W\xFCrfel" },
                    { value: "sphere", label: "Kugel" }
                  ];
                  shapes.forEach((opt) => {
                    const option = shapeSelect.createEl("option", { value: opt.value, text: opt.label });
                    if (opt.value === entry["trigger.targeting.shape"]) option.selected = true;
                  });
                  shapeSelect.addEventListener("change", () => {
                    if (!entry["trigger.targeting"]) entry["trigger.targeting"] = {};
                    entry["trigger.targeting"].shape = shapeSelect.value;
                  });
                  targetingRow.createEl("span", { text: "Gr\xF6\xDFe:" });
                  const sizeInput = targetingRow.createEl("input", {
                    cls: "sm-cc-compact-text",
                    value: entry["trigger.targeting.size"] || "",
                    placeholder: "z.B. 15 ft."
                  });
                  sizeInput.addEventListener("input", () => {
                    if (!entry["trigger.targeting"]) entry["trigger.targeting"] = {};
                    entry["trigger.targeting"].size = sizeInput.value;
                  });
                }
                const restrictionsRow = triggerContent.createDiv({ cls: "sm-cc-field-row" });
                restrictionsRow.createEl("span", { text: "Einschr\xE4nkungen:", cls: "sm-cc-field-label" });
                const sizeCheck = restrictionsRow.createEl("input", {
                  type: "checkbox",
                  attr: { id: "size-restriction" }
                });
                const restrictions = entry["trigger.restrictions"] || {};
                sizeCheck.checked = Boolean(restrictions.maxSize);
                sizeCheck.addEventListener("change", () => {
                  if (sizeCheck.checked) {
                    if (!entry["trigger.restrictions"]) entry["trigger.restrictions"] = {};
                    entry["trigger.restrictions"].maxSize = "Mittel";
                  } else {
                    if (entry["trigger.restrictions"]) {
                      delete entry["trigger.restrictions"].maxSize;
                      if (Object.keys(entry["trigger.restrictions"]).length === 0) {
                        delete entry["trigger.restrictions"];
                      }
                    }
                  }
                  ctx.requestRender();
                });
                restrictionsRow.createEl("label", {
                  text: "Max. Gr\xF6\xDFe:",
                  attr: { for: "size-restriction" },
                  cls: "sm-cc-checkbox-label-small"
                });
                if (restrictions.maxSize) {
                  const sizeSelect = restrictionsRow.createEl("select", {
                    cls: "sm-cc-tiny-select"
                  });
                  ["Klein", "Mittel", "Gro\xDF", "Riesig"].forEach((size) => {
                    const opt = sizeSelect.createEl("option", { value: size, text: size });
                    if (size === restrictions.maxSize) opt.selected = true;
                  });
                  sizeSelect.addEventListener("change", () => {
                    if (!entry["trigger.restrictions"]) entry["trigger.restrictions"] = {};
                    entry["trigger.restrictions"].maxSize = sizeSelect.value;
                  });
                }
                const otherInput = restrictionsRow.createEl("input", {
                  cls: "sm-cc-long-text",
                  value: restrictions.other || "",
                  placeholder: "Weitere Einschr\xE4nkungen (z.B. muss ergriffen sein)"
                });
                otherInput.addEventListener("input", () => {
                  if (otherInput.value) {
                    if (!entry["trigger.restrictions"]) entry["trigger.restrictions"] = {};
                    entry["trigger.restrictions"].other = otherInput.value;
                  } else {
                    if (entry["trigger.restrictions"]) {
                      delete entry["trigger.restrictions"].other;
                      if (Object.keys(entry["trigger.restrictions"]).length === 0) {
                        delete entry["trigger.restrictions"];
                      }
                    }
                  }
                });
                const effectsSection = body.createDiv({ cls: "sm-cc-effects-section" });
                effectsSection.createEl("h4", { text: "EFFEKTE", cls: "sm-cc-section-label" });
                const effectsContent = effectsSection.createDiv({ cls: "sm-cc-effects-content" });
                if (entryType === "attack") {
                  renderAttackEffect(effectsContent, entry, ctx);
                } else if (entryType === "save") {
                  renderSaveEffect(effectsContent, entry, ctx);
                } else if (entryType === "multiattack") {
                  renderMultiattackEffect(effectsContent, entry, ctx);
                }
                const addEffectsRow = effectsContent.createDiv({ cls: "sm-cc-add-effects-row" });
                ["+ Angriff", "+ Rettungswurf", "+ Schaden", "+ Zustand"].forEach((label) => {
                  const btn = addEffectsRow.createEl("button", {
                    cls: "sm-cc-compact-btn",
                    text: label
                  });
                  btn.addEventListener("click", () => {
                  });
                });
                const descSection = body.createDiv({ cls: "sm-cc-description-section" });
                const textarea = descSection.createEl("textarea", {
                  cls: "sm-cc-entry-description",
                  placeholder: "Beschreibungstext...",
                  value: entry.text || ""
                });
                textarea.addEventListener("input", () => {
                  entry.text = textarea.value;
                });
              },
              // Add data-entry-id for navigation
              dataset: {
                entryId: String(entry.name || `entry-${context.index}`)
              },
              // Add collapse toggle in head
              renderHeadExtras: (head, ctx, slots) => {
                const toggle = head.createDiv({
                  cls: "sm-cc-entry-toggle",
                  attr: { "aria-expanded": "true", "aria-label": "Toggle entry" }
                });
                (0, import_obsidian27.setIcon)(toggle, "chevron-down");
                head.prepend(toggle);
                toggle.addEventListener("click", (e) => {
                  e.stopPropagation();
                  const isExpanded = toggle.getAttribute("aria-expanded") === "true";
                  toggle.setAttribute("aria-expanded", String(!isExpanded));
                  slots.card.toggleClass("is-collapsed", isExpanded);
                  (0, import_obsidian27.setIcon)(toggle, isExpanded ? "chevron-right" : "chevron-down");
                });
              }
            };
          },
          // Categories for filtering
          categories: CREATURE_ENTRY_CATEGORIES.map(([id, label]) => ({
            id,
            label,
            defaultActive: true
          })),
          // Filters for entry types
          filters: CREATURE_ENTRY_CATEGORIES.map(([id, label]) => ({
            id,
            label,
            predicate: (entry) => entry.category === id
          }))
        },
        default: []
      }
    ];
    creatureSpec = {
      kind: "creature",
      title: "Kreatur erstellen",
      subtitle: "Neue Kreatur f\xFCr deine Kampagne",
      schema: creatureSchema,
      fields: [
        ...basicInfoFields,
        ...combatStatsFields,
        ...movementFields,
        ...abilitiesFields,
        ...skillsFields,
        ...sensesLanguagesFields,
        ...resistancesFields,
        ...equipmentFields,
        ...spellcastingFields,
        ...entriesFields
      ],
      storage: {
        format: "md-frontmatter",
        pathTemplate: "SaltMarcher/Creatures/{name}.md",
        filenameFrom: "name",
        directory: "SaltMarcher/Creatures",
        preserveCase: true,
        frontmatter: [
          "name",
          "size",
          "type",
          "typeTags",
          "alignmentLawChaos",
          "alignmentGoodEvil",
          "alignmentOverride",
          "ac",
          "initiative",
          "hp",
          "hitDice",
          "speeds",
          "abilities",
          "pb",
          "saves",
          "skills",
          "sensesList",
          "languagesList",
          "passivesList",
          "damageVulnerabilitiesList",
          "damageResistancesList",
          "damageImmunitiesList",
          "conditionImmunitiesList",
          "gearList",
          "cr",
          "xp",
          "entries",
          "spellcasting"
        ],
        bodyTemplate: (data) => statblockToMarkdown(data)
      },
      ui: {
        submitLabel: "Kreatur erstellen",
        cancelLabel: "Abbrechen",
        enableNavigation: true,
        sections: [
          {
            id: "basic",
            label: "Grunddaten",
            description: "Name, Gr\xF6\xDFe, Typ und Gesinnung",
            fieldIds: ["name", "size", "alignmentLawChaos", "alignmentGoodEvil", "alignmentOverride", "type", "typeTags"]
          },
          {
            id: "combat",
            label: "Kampfwerte",
            description: "AC, HP, Initiative und CR",
            fieldIds: ["ac", "initiative", "hp", "hitDice", "cr", "xp", "pb"]
          },
          {
            id: "abilities",
            label: "Attribute",
            description: "Grundattribute und Modifikatoren",
            fieldIds: ["abilities"]
          },
          {
            id: "senses",
            label: "F\xE4higkeiten",
            description: "Bewegungsraten, Fertigkeiten, Sinneswahrnehmungen und Kommunikation",
            fieldIds: ["speeds", "skills", "sensesList", "passivesList", "languagesList"]
          },
          {
            id: "resistances",
            label: "Widerst\xE4nde",
            description: "Schadenswiderst\xE4nde und Immunit\xE4ten",
            fieldIds: ["damageVulnerabilitiesList", "damageResistancesList", "damageImmunitiesList", "conditionImmunitiesList"]
          },
          {
            id: "equipment",
            label: "Ausr\xFCstung",
            description: "Gegenst\xE4nde und Ausr\xFCstung",
            fieldIds: ["gearList"]
          },
          {
            id: "spellcasting",
            label: "Zauber & Zauberwirken",
            description: "Zauberspr\xFCche und Zauberf\xE4higkeiten",
            fieldIds: ["spellcastingEntries"]
          },
          {
            id: "entries",
            label: "Eigenschaften & Aktionen",
            description: "Spezialf\xE4higkeiten, Angriffe und Reaktionen (ohne Zauber)",
            fieldIds: ["entries"]
          }
        ]
      },
      // Browse configuration - replaces view-config.ts and list-schema.ts
      browse: {
        metadata: [
          {
            id: "type",
            cls: "sm-cc-item__type",
            getValue: (entry) => entry.type
          },
          {
            id: "cr",
            cls: "sm-cc-item__cr",
            getValue: (entry) => entry.cr ? `CR ${entry.cr}` : void 0
          }
        ],
        filters: [
          { id: "type", field: "type", label: "Type", type: "string" },
          {
            id: "cr",
            field: "cr",
            label: "CR",
            type: "custom",
            sortComparator: (a, b) => {
              const parseCr = (value) => {
                if (!value) return Number.POSITIVE_INFINITY;
                if (value.includes("/")) {
                  const [num, denom] = value.split("/").map((part) => Number(part.trim()));
                  if (Number.isFinite(num) && Number.isFinite(denom) && denom !== 0) {
                    return num / denom;
                  }
                }
                const numeric = Number(value);
                return Number.isFinite(numeric) ? numeric : Number.POSITIVE_INFINITY;
              };
              return parseCr(a) - parseCr(b);
            }
          }
        ],
        sorts: [
          { id: "name", label: "Name", field: "name" },
          { id: "type", label: "Type", field: "type" },
          {
            id: "cr",
            label: "CR",
            compareFn: (a, b) => {
              const parseCr = (value) => {
                if (!value) return Number.POSITIVE_INFINITY;
                if (value.includes("/")) {
                  const [num, denom] = value.split("/").map((part) => Number(part.trim()));
                  if (Number.isFinite(num) && Number.isFinite(denom) && denom !== 0) {
                    return num / denom;
                  }
                }
                const numeric = Number(value);
                return Number.isFinite(numeric) ? numeric : Number.POSITIVE_INFINITY;
              };
              return parseCr(a.cr) - parseCr(b.cr) || a.name.localeCompare(b.name);
            }
          }
        ],
        search: ["type", "cr"]
      },
      // Loader configuration - replaces loader.ts (uses auto-loader by default)
      loader: {
        fromFrontmatter: (fm2, file) => {
          const stripUnit = (value) => {
            if (!value) return "";
            return value.replace(/\s*ft\.?$/i, "").trim();
          };
          if (fm2.speeds && !Array.isArray(fm2.speeds)) {
            const oldSpeeds = fm2.speeds;
            const newSpeeds = [];
            const speedTypes = ["walk", "burrow", "climb", "fly", "swim"];
            for (const type2 of speedTypes) {
              if (oldSpeeds[type2]?.distance) {
                const entry = {
                  type: type2,
                  value: stripUnit(oldSpeeds[type2].distance)
                  // Strip unit
                };
                if (type2 === "fly" && oldSpeeds[type2].hover === true) {
                  entry.hover = true;
                }
                newSpeeds.push(entry);
              }
            }
            if (oldSpeeds.extras && Array.isArray(oldSpeeds.extras)) {
              for (const extra of oldSpeeds.extras) {
                if (extra.label && extra.distance) {
                  newSpeeds.push({
                    type: extra.label,
                    value: stripUnit(extra.distance)
                    // Strip unit
                  });
                }
              }
            }
            fm2.speeds = newSpeeds.length > 0 ? newSpeeds : void 0;
          }
          if (fm2.passivesList && Array.isArray(fm2.passivesList)) {
            fm2.passivesList = fm2.passivesList.map((item) => {
              let text;
              if (typeof item === "string") {
                text = item;
              } else if (item && typeof item === "object" && "value" in item) {
                text = String(item.value);
              } else if (item && typeof item === "object" && "skill" in item && "value" in item) {
                return item;
              } else {
                return item;
              }
              const match = text.match(/^Passive\s+(\w+)\s+(\d+)$/i);
              if (match) {
                return {
                  skill: match[1],
                  // e.g., "Perception"
                  value: match[2]
                  // e.g., "20"
                };
              }
              return {
                skill: "Perception",
                value: text.replace(/\D/g, "") || "10"
              };
            });
          }
          if (fm2.languagesList && Array.isArray(fm2.languagesList)) {
            fm2.languagesList = fm2.languagesList.map((item) => {
              if (typeof item === "string") {
                return { value: item };
              }
              const cleaned = {};
              for (const [key, value] of Object.entries(item)) {
                if (typeof value === "string" && value.trim() === "") {
                  continue;
                }
                cleaned[key] = value;
              }
              if (cleaned.value && cleaned.type && !cleaned.range) {
                return { value: cleaned.value };
              }
              return cleaned;
            });
          }
          if (fm2.sensesList && Array.isArray(fm2.sensesList)) {
            fm2.sensesList = fm2.sensesList.map((item) => {
              if (typeof item === "string") {
                return { value: item };
              }
              const cleaned = {};
              for (const [key, value] of Object.entries(item)) {
                if (typeof value === "string" && value.trim() === "") {
                  continue;
                }
                cleaned[key] = value;
              }
              return cleaned;
            });
          }
          if (fm2.entries && Array.isArray(fm2.entries)) {
            fm2.entries = fm2.entries.map((entry) => {
              const flattened = {};
              const flatten = (obj, prefix = "") => {
                for (const [key, value] of Object.entries(obj)) {
                  const newKey = prefix ? `${prefix}.${key}` : key;
                  if (newKey === "save.onSuccess" && typeof value === "string") {
                    flattened["save.onSuccess.legacyText"] = value;
                    continue;
                  }
                  if (value && typeof value === "object" && !Array.isArray(value)) {
                    flatten(value, newKey);
                  } else {
                    flattened[newKey] = value;
                  }
                }
              };
              flatten(entry);
              return flattened;
            });
          }
          return fm2;
        }
      }
    };
  }
});

// src/workmodes/library/creatures/index.ts
var init_creatures = __esm({
  "src/workmodes/library/creatures/index.ts"() {
    "use strict";
    init_create_spec();
    init_serializer();
  }
});

// src/workmodes/library/spells/serializer.ts
function spellToMarkdown(d) {
  const lines = [];
  const name = d.name || "Unnamed Spell";
  lines.push(`# ${name}`);
  const levelStr = d.level == null ? "" : d.level === 0 ? "Cantrip" : `Level ${d.level}`;
  const parts = [levelStr, d.school].filter(Boolean);
  if (parts.length) {
    lines.push(parts.join(" "));
  }
  lines.push("");
  const stat = (label, val) => {
    if (val) lines.push(`- ${label}: ${val}`);
  };
  stat("Casting Time", d.casting_time);
  stat("Range", d.range);
  const compLine = (d.components || []).join(", ") + (d.materials ? ` (${d.materials})` : "");
  if (d.components && d.components.length) {
    stat("Components", compLine);
  }
  stat("Duration", d.duration);
  if (d.concentration) lines.push("- Concentration: yes");
  if (d.ritual) lines.push("- Ritual: yes");
  if (d.classes && d.classes.length) {
    stat("Classes", (d.classes || []).join(", "));
  }
  if (d.attack) stat("Attack", d.attack);
  if (d.save_ability) {
    stat("Save", `${d.save_ability}${d.save_effect ? ` (${d.save_effect})` : ""}`);
  }
  if (d.damage) {
    stat("Damage", `${d.damage}${d.damage_type ? ` ${d.damage_type}` : ""}`);
  }
  lines.push("");
  if (d.description) {
    lines.push(d.description.trim());
    lines.push("");
  }
  if (d.higher_levels) {
    lines.push("## At Higher Levels\n");
    lines.push(d.higher_levels.trim());
    lines.push("");
  }
  return lines.join("\n");
}
var init_serializer2 = __esm({
  "src/workmodes/library/spells/serializer.ts"() {
    "use strict";
  }
});

// src/workmodes/library/spells/validation.ts
function collectSpellScalingIssues(data) {
  const issues = [];
  const scalingText = data.higher_levels?.trim();
  if (!scalingText) return issues;
  const level = data.level;
  if (!Number.isFinite(level)) {
    issues.push(SCALING_REQUIRES_LEVEL_MESSAGE);
    return issues;
  }
  if ((level ?? 0) <= 0) {
    issues.push(SCALING_DISALLOWS_CANTRIPS_MESSAGE);
  }
  return issues;
}
var SCALING_REQUIRES_LEVEL_MESSAGE, SCALING_DISALLOWS_CANTRIPS_MESSAGE;
var init_validation = __esm({
  "src/workmodes/library/spells/validation.ts"() {
    "use strict";
    SCALING_REQUIRES_LEVEL_MESSAGE = "Skalierende Effekte ben\xF6tigen einen Zaubergrad zwischen 1 und 9.";
    SCALING_DISALLOWS_CANTRIPS_MESSAGE = "Zaubertricks verwenden keine h\xF6heren Zauberstufen \u2013 entferne den Abschnitt oder w\xE4hle Grad 1\u20139.";
  }
});

// src/workmodes/library/spells/constants.ts
var SPELL_SCHOOLS, SPELL_ATTACK_TYPES, SPELL_SAVE_ABILITIES, SPELL_CLASS_SUGGESTIONS;
var init_constants2 = __esm({
  "src/workmodes/library/spells/constants.ts"() {
    "use strict";
    SPELL_SCHOOLS = [
      "Abjuration",
      "Conjuration",
      "Divination",
      "Enchantment",
      "Evocation",
      "Illusion",
      "Necromancy",
      "Transmutation"
    ];
    SPELL_ATTACK_TYPES = [
      "Melee Spell Attack",
      "Ranged Spell Attack",
      "Melee Weapon Attack",
      "Ranged Weapon Attack"
    ];
    SPELL_SAVE_ABILITIES = ["STR", "DEX", "CON", "INT", "WIS", "CHA"];
    SPELL_CLASS_SUGGESTIONS = [
      "Bard",
      "Cleric",
      "Druid",
      "Paladin",
      "Ranger",
      "Sorcerer",
      "Warlock",
      "Wizard",
      "Artificer"
    ];
  }
});

// src/workmodes/library/spells/create-spec.ts
var spellSchema, basicInfoFields2, timingComponentsFields, flagsFields, combatFields, damageFields, classesFields, descriptionFields, spellSpec;
var init_create_spec2 = __esm({
  "src/workmodes/library/spells/create-spec.ts"() {
    "use strict";
    init_serializer2();
    init_validation();
    init_constants2();
    spellSchema = {
      parse: (data) => data,
      safeParse: (data) => {
        try {
          const spellData = data;
          const scalingIssues = collectSpellScalingIssues(spellData);
          if (scalingIssues.length > 0) {
            return {
              success: false,
              error: new Error(scalingIssues.join("\n"))
            };
          }
          return { success: true, data: spellData };
        } catch (error) {
          return { success: false, error };
        }
      }
    };
    basicInfoFields2 = [
      {
        id: "name",
        label: "Name",
        type: "text",
        required: true,
        placeholder: "Fireball"
      },
      {
        id: "level",
        label: "Grad",
        type: "select",
        description: "0 = Zaubertrick",
        options: Array.from({ length: 10 }, (_, i) => ({
          value: String(i),
          label: i === 0 ? "Cantrip" : `Level ${i}`
        })),
        default: "0"
      },
      {
        id: "school",
        label: "Schule",
        type: "select",
        options: [
          { value: "", label: "(keine)" },
          ...SPELL_SCHOOLS.map((s) => ({ value: s, label: s }))
        ]
      }
    ];
    timingComponentsFields = [
      {
        id: "casting_time",
        label: "Wirkzeit",
        type: "text",
        placeholder: "1 Aktion"
      },
      {
        id: "range",
        label: "Reichweite",
        type: "text",
        placeholder: "60 Fu\xDF"
      },
      {
        id: "duration",
        label: "Dauer",
        type: "text",
        placeholder: "Augenblicklich / Konzentration, bis zu 1 Minute"
      },
      {
        id: "components",
        label: "Komponenten",
        type: "composite",
        config: {
          fields: [
            {
              id: "v",
              label: "V",
              type: "checkbox"
            },
            {
              id: "s",
              label: "S",
              type: "checkbox"
            },
            {
              id: "m",
              label: "M",
              type: "checkbox"
            }
          ],
          layout: "horizontal",
          toData: (value) => {
            const arr = [];
            if (value.v) arr.push("V");
            if (value.s) arr.push("S");
            if (value.m) arr.push("M");
            return arr.length > 0 ? arr : void 0;
          },
          fromData: (data) => ({
            v: data?.includes("V") ?? false,
            s: data?.includes("S") ?? false,
            m: data?.includes("M") ?? false
          })
        }
      },
      {
        id: "materials",
        label: "Materialien",
        type: "text",
        placeholder: "winzige Kugel aus Guano und Schwefel"
      }
    ];
    flagsFields = [
      {
        id: "concentration",
        label: "Konzentration",
        type: "checkbox",
        default: false
      },
      {
        id: "ritual",
        label: "Ritual",
        type: "checkbox",
        default: false
      }
    ];
    combatFields = [
      {
        id: "attack",
        label: "Angriff",
        type: "select",
        options: [
          { value: "", label: "(kein)" },
          ...SPELL_ATTACK_TYPES.map((a) => ({ value: a, label: a }))
        ]
      },
      {
        id: "save_ability",
        label: "Rettungswurf",
        type: "select",
        options: [
          { value: "", label: "(kein)" },
          ...SPELL_SAVE_ABILITIES.map((a) => ({ value: a, label: a }))
        ]
      },
      {
        id: "save_effect",
        label: "Effekt",
        type: "text",
        placeholder: "Half on save / Negates \u2026",
        visibleIf: (data) => Boolean(data.save_ability)
      }
    ];
    damageFields = [
      {
        id: "damage",
        label: "Schadensw\xFCrfel",
        type: "text",
        placeholder: "8d6"
      },
      {
        id: "damage_type",
        label: "Schadenstyp",
        type: "text",
        placeholder: "fire / radiant \u2026"
      }
    ];
    classesFields = [
      {
        id: "classes",
        label: "Klassen",
        type: "tokens",
        config: {
          fields: [{
            id: "value",
            type: "text",
            displayInChip: true,
            editable: true,
            placeholder: "Klasse hinzuf\xFCgen...",
            suggestions: SPELL_CLASS_SUGGESTIONS
          }],
          primaryField: "value"
        },
        default: []
      }
    ];
    descriptionFields = [
      {
        id: "description",
        label: "Beschreibung",
        type: "textarea",
        placeholder: "Beschreibung (Markdown)"
      },
      {
        id: "higher_levels",
        label: "H\xF6here Grade",
        type: "textarea",
        placeholder: "Bei h\xF6heren Graden (Markdown)",
        description: "Optional: Skalierung des Zaubers bei h\xF6heren Stufen"
      }
    ];
    spellSpec = {
      kind: "spell",
      title: "Zauber erstellen",
      subtitle: "Neuer Zauber f\xFCr deine Kampagne",
      schema: spellSchema,
      fields: [
        ...basicInfoFields2,
        ...timingComponentsFields,
        ...flagsFields,
        ...combatFields,
        ...damageFields,
        ...classesFields,
        ...descriptionFields
      ],
      storage: {
        format: "md-frontmatter",
        pathTemplate: "SaltMarcher/Spells/{name}.md",
        filenameFrom: "name",
        directory: "SaltMarcher/Spells",
        preserveCase: true,
        frontmatter: [
          "name",
          "level",
          "school",
          "casting_time",
          "range",
          "components",
          "materials",
          "duration",
          "concentration",
          "ritual",
          "classes",
          "attack",
          "save_ability",
          "save_effect",
          "damage",
          "damage_type"
        ],
        bodyTemplate: (data) => spellToMarkdown(data)
      },
      ui: {
        submitLabel: "Zauber erstellen",
        cancelLabel: "Abbrechen",
        enableNavigation: true,
        sections: [
          {
            id: "basic",
            label: "Grunddaten",
            description: "Name, Grad und Schule",
            fieldIds: ["name", "level", "school"]
          },
          {
            id: "timing",
            label: "Timing & Komponenten",
            description: "Wirkzeit, Reichweite, Dauer und Komponenten",
            fieldIds: ["casting_time", "range", "duration", "components", "materials"]
          },
          {
            id: "flags",
            label: "Eigenschaften",
            description: "Konzentration und Ritual",
            fieldIds: ["concentration", "ritual"]
          },
          {
            id: "combat",
            label: "Kampf & Targeting",
            description: "Angriffe und Rettungsw\xFCrfe",
            fieldIds: ["attack", "save_ability", "save_effect"]
          },
          {
            id: "damage",
            label: "Schaden",
            description: "Schadensw\xFCrfel und Typ",
            fieldIds: ["damage", "damage_type"]
          },
          {
            id: "classes",
            label: "Klassen",
            description: "Verf\xFCgbare Klassen",
            fieldIds: ["classes"]
          },
          {
            id: "description",
            label: "Beschreibung",
            description: "Zauberbeschreibung und Skalierung",
            fieldIds: ["description", "higher_levels"]
          }
        ]
      },
      // Browse configuration - replaces view-config.ts and list-schema.ts
      browse: {
        metadata: [
          {
            id: "level",
            cls: "sm-cc-item__type",
            getValue: (entry) => {
              const level = entry.level;
              if (level == null) return "Unknown";
              if (level === 0) return "Cantrip";
              return `Level ${level}`;
            }
          },
          {
            id: "school",
            cls: "sm-cc-item__cr",
            getValue: (entry) => entry.school
          }
        ],
        filters: [
          { id: "school", field: "school", label: "School", type: "string" },
          {
            id: "level",
            field: "level",
            label: "Level",
            type: "custom",
            sortComparator: (a, b) => Number(a) - Number(b)
          },
          {
            id: "ritual",
            field: "ritual",
            label: "Ritual",
            type: "custom",
            sortComparator: (a, b) => {
              const order = { "undefined": 0, "false": 1, "true": 2 };
              return (order[a] ?? 0) - (order[b] ?? 0);
            }
          }
        ],
        sorts: [
          { id: "name", label: "Name", field: "name" },
          { id: "school", label: "School", field: "school" },
          {
            id: "level",
            label: "Level",
            compareFn: (a, b) => (a.level ?? 0) - (b.level ?? 0) || a.name.localeCompare(b.name)
          }
        ],
        search: ["school", "casting_time", "duration", "description"]
      },
      // Loader configuration - replaces loader.ts (uses auto-loader by default)
      loader: {
        // Auto-loader from frontmatter is sufficient for spells
        // No custom loader needed
      }
    };
  }
});

// src/workmodes/library/spells/index.ts
var init_spells = __esm({
  "src/workmodes/library/spells/index.ts"() {
    "use strict";
    init_create_spec2();
    init_serializer2();
  }
});

// src/workmodes/library/items/serializer.ts
function itemToMarkdown(d) {
  const lines = [];
  const name = d.name || "Unnamed Item";
  lines.push(`# ${name}`);
  const typeParts = [];
  if (d.category) typeParts.push(d.category);
  if (d.type) typeParts.push(`(${d.type})`);
  if (d.rarity) typeParts.push(d.rarity);
  if (d.attunement) {
    const attunementText = d.attunement_req ? `Requires Attunement ${d.attunement_req}` : "Requires Attunement";
    typeParts.push(`(${attunementText})`);
  }
  if (typeParts.length > 0) {
    lines.push(`*${typeParts.join(" ")}*`);
  }
  lines.push("");
  const stats = [];
  if (d.weight) stats.push(`- Weight: ${d.weight}`);
  if (d.value) stats.push(`- Value: ${d.value}`);
  if (stats.length > 0) {
    lines.push(...stats);
    lines.push("");
  }
  if (d.max_charges != null) {
    lines.push(`## Charges
`);
    lines.push(`This item has ${d.max_charges} charges.`);
    if (d.recharge_formula || d.recharge_time) {
      const rechargeParts = [];
      if (d.recharge_formula) rechargeParts.push(`regains ${d.recharge_formula} charges`);
      if (d.recharge_time) rechargeParts.push(`at ${d.recharge_time}`);
      lines.push(rechargeParts.join(" ") + ".");
    }
    if (d.destruction_risk) {
      lines.push(d.destruction_risk);
    }
    lines.push("");
  }
  if (d.spells && d.spells.length > 0) {
    lines.push(`## Spells
`);
    lines.push("This item can cast the following spells:");
    lines.push("");
    for (const spell of d.spells) {
      const parts = [spell.name];
      if (spell.charge_cost != null) parts.push(`(${spell.charge_cost} charge${spell.charge_cost === 1 ? "" : "s"})`);
      if (spell.level != null) parts.push(`[Level ${spell.level}]`);
      if (spell.save_dc != null) parts.push(`DC ${spell.save_dc}`);
      if (spell.uses_caster_dc) parts.push("(uses caster's DC)");
      lines.push(`- ${parts.join(" ")}`);
    }
    lines.push("");
  }
  if (d.spell_storage_capacity != null) {
    lines.push(`## Spell Storage
`);
    lines.push(`This item can store up to ${d.spell_storage_capacity} levels of spells.`);
    lines.push("");
  }
  if (d.bonuses && d.bonuses.length > 0) {
    lines.push(`## Bonuses
`);
    for (const bonus of d.bonuses) {
      const parts = [`${bonus.value} to ${bonus.type}`];
      if (bonus.applies_to) parts.push(`(${bonus.applies_to})`);
      lines.push(`- ${parts.join(" ")}`);
    }
    lines.push("");
  }
  if (d.resistances && d.resistances.length > 0) {
    lines.push(`- Resistances: ${d.resistances.join(", ")}`);
  }
  if (d.immunities && d.immunities.length > 0) {
    lines.push(`- Immunities: ${d.immunities.join(", ")}`);
  }
  if (d.resistances && d.resistances.length > 0 || d.immunities && d.immunities.length > 0) {
    lines.push("");
  }
  if (d.ability_changes && d.ability_changes.length > 0) {
    lines.push(`## Ability Changes
`);
    for (const change of d.ability_changes) {
      const parts = [`${change.ability.toUpperCase()} becomes ${change.value}`];
      if (change.condition) parts.push(`(${change.condition})`);
      lines.push(`- ${parts.join(" ")}`);
    }
    lines.push("");
  }
  if (d.speed_changes && d.speed_changes.length > 0) {
    lines.push(`## Speed Modifications
`);
    for (const speed of d.speed_changes) {
      const parts = [`${speed.type} ${speed.value}`];
      if (speed.condition) parts.push(`(${speed.condition})`);
      lines.push(`- ${parts.join(" ")}`);
    }
    lines.push("");
  }
  if (d.properties && d.properties.length > 0) {
    lines.push(`## Properties
`);
    for (const prop of d.properties) {
      lines.push(`**${prop.name}${prop.range ? ` (${prop.range})` : ""}**`);
      lines.push(prop.description);
      lines.push("");
    }
  }
  if (d.usage_limit) {
    lines.push(`## Usage
`);
    lines.push(`Can be used ${d.usage_limit.amount}, resets ${d.usage_limit.reset}.`);
    if (d.usage_limit.cumulative_failure) {
      lines.push(`${d.usage_limit.cumulative_failure.chance_per_use}% chance per use: ${d.usage_limit.cumulative_failure.on_failure}`);
    }
    lines.push("");
  }
  if (d.description) {
    lines.push(d.description.trim());
    lines.push("");
  }
  if (d.tables && d.tables.length > 0) {
    for (const table of d.tables) {
      lines.push(`## ${table.name}
`);
      if (table.description) {
        lines.push(table.description);
        lines.push("");
      }
      lines.push("| Roll | Result |");
      lines.push("| :--- | :----- |");
      for (const entry of table.entries) {
        lines.push(`| ${entry.roll} | ${entry.result} |`);
      }
      lines.push("");
    }
  }
  if (d.cursed && d.curse_description) {
    lines.push(`## Curse
`);
    lines.push(d.curse_description.trim());
    lines.push("");
  }
  if (d.sentient && d.sentient_props) {
    lines.push(`## Sentient Item
`);
    const sp = d.sentient_props;
    if (sp.intelligence != null || sp.wisdom != null || sp.charisma != null) {
      lines.push(`**Ability Scores:** INT ${sp.intelligence ?? "-"}, WIS ${sp.wisdom ?? "-"}, CHA ${sp.charisma ?? "-"}`);
    }
    if (sp.alignment) lines.push(`**Alignment:** ${sp.alignment}`);
    if (sp.senses) lines.push(`**Senses:** ${sp.senses}`);
    if (sp.communication) lines.push(`**Communication:** ${sp.communication}`);
    if (sp.languages && sp.languages.length > 0) {
      lines.push(`**Languages:** ${sp.languages.join(", ")}`);
    }
    if (sp.purpose) {
      lines.push(`**Purpose:** ${sp.purpose}`);
    }
    lines.push("");
  }
  if (d.has_variants && d.variant_info) {
    lines.push(`## Variants
`);
    lines.push(d.variant_info.trim());
    lines.push("");
  }
  if (d.notes) {
    lines.push(`## Notes
`);
    lines.push(d.notes.trim());
    lines.push("");
  }
  return lines.join("\n");
}
var init_serializer3 = __esm({
  "src/workmodes/library/items/serializer.ts"() {
    "use strict";
  }
});

// src/workmodes/library/items/constants.ts
var ITEM_CATEGORIES, ITEM_RARITIES, RECHARGE_TIMES, ITEM_TAGS;
var init_constants3 = __esm({
  "src/workmodes/library/items/constants.ts"() {
    "use strict";
    ITEM_CATEGORIES = [
      "Armor",
      "Potion",
      "Ring",
      "Rod",
      "Scroll",
      "Staff",
      "Wand",
      "Weapon",
      "Wondrous Item"
    ];
    ITEM_RARITIES = [
      "Common",
      "Uncommon",
      "Rare",
      "Very Rare",
      "Legendary",
      "Artifact"
    ];
    RECHARGE_TIMES = [
      "Dawn",
      "Dusk",
      "Long Rest",
      "Short Rest"
    ];
    ITEM_TAGS = [
      "Armor",
      "Potion",
      "Ring",
      "Rod",
      "Scroll",
      "Staff",
      "Wand",
      "Weapon",
      "Wondrous"
    ];
  }
});

// src/workmodes/library/items/create-spec.ts
var itemSchema, basicInfoFields3, attunementFields, chargesFields, propertiesFields, metadataFields, curseFields, itemSpec;
var init_create_spec3 = __esm({
  "src/workmodes/library/items/create-spec.ts"() {
    "use strict";
    init_serializer3();
    init_constants3();
    itemSchema = {
      parse: (data) => data,
      safeParse: (data) => {
        try {
          return { success: true, data };
        } catch (error) {
          return { success: false, error };
        }
      }
    };
    basicInfoFields3 = [
      {
        id: "name",
        label: "Name",
        type: "text",
        required: true,
        placeholder: "Flaming Longsword"
      },
      {
        id: "category",
        label: "Category",
        type: "select",
        options: [
          { value: "", label: "(none)" },
          ...ITEM_CATEGORIES.map((c) => ({ value: c, label: c }))
        ]
      },
      {
        id: "tags",
        label: "Tags",
        type: "tokens",
        config: {
          fields: [{
            id: "value",
            type: "select",
            displayInChip: true,
            editable: true,
            suggestions: ITEM_TAGS.map((tag) => ({ key: tag, label: tag })),
            placeholder: "Tag ausw\xE4hlen..."
          }],
          primaryField: "value"
        },
        default: [],
        description: "Classification tags for filtering and organization"
      },
      {
        id: "type",
        label: "Type",
        type: "text",
        description: "e.g., 'Armor (Plate)', 'Weapon (Longsword)'",
        placeholder: "Weapon (Longsword)"
      },
      {
        id: "rarity",
        label: "Rarity",
        type: "select",
        options: [
          { value: "", label: "(none)" },
          ...ITEM_RARITIES.map((r) => ({ value: r, label: r }))
        ]
      }
    ];
    attunementFields = [
      {
        id: "attunement",
        label: "Requires Attunement",
        type: "checkbox",
        default: false
      },
      {
        id: "attunement_req",
        label: "Attunement Requirement",
        type: "text",
        description: "e.g., 'by a Cleric'",
        placeholder: "by a Druid, Sorcerer, Warlock, or Wizard",
        visibleIf: (data) => Boolean(data.attunement)
      }
    ];
    chargesFields = [
      {
        id: "max_charges",
        label: "Max Charges",
        type: "number-stepper",
        min: 0,
        max: 50,
        step: 1,
        placeholder: "10"
      },
      {
        id: "recharge_formula",
        label: "Recharge Formula",
        type: "text",
        description: "e.g., '1d6 + 4'",
        placeholder: "1d6 + 4",
        visibleIf: (data) => typeof data.max_charges === "number" && data.max_charges > 0
      },
      {
        id: "recharge_time",
        label: "Recharge Time",
        type: "select",
        options: [
          { value: "", label: "(none)" },
          ...RECHARGE_TIMES.map((t) => ({ value: t, label: t }))
        ],
        visibleIf: (data) => typeof data.max_charges === "number" && data.max_charges > 0
      },
      {
        id: "destruction_risk",
        label: "Destruction Risk",
        type: "text",
        description: "e.g., 'On 1, turns to water'",
        placeholder: "On 1, turns to water and is destroyed",
        visibleIf: (data) => typeof data.max_charges === "number" && data.max_charges > 0
      }
    ];
    propertiesFields = [
      {
        id: "description",
        label: "Description",
        type: "textarea",
        placeholder: "While wearing this armor..."
      },
      {
        id: "notes",
        label: "Notes",
        type: "textarea",
        placeholder: "Additional information..."
      }
    ];
    metadataFields = [
      {
        id: "weight",
        label: "Weight",
        type: "text",
        placeholder: "5 pounds"
      },
      {
        id: "value",
        label: "Value",
        type: "text",
        placeholder: "2,000 GP"
      }
    ];
    curseFields = [
      {
        id: "cursed",
        label: "Cursed Item",
        type: "checkbox",
        default: false
      },
      {
        id: "curse_description",
        label: "Curse Description",
        type: "textarea",
        placeholder: "This armor is cursed...",
        visibleIf: (data) => Boolean(data.cursed)
      }
    ];
    itemSpec = {
      kind: "item",
      title: "Item erstellen",
      subtitle: "Neues magisches Item f\xFCr deine Kampagne",
      schema: itemSchema,
      fields: [
        ...basicInfoFields3,
        ...attunementFields,
        ...chargesFields,
        ...propertiesFields,
        ...metadataFields,
        ...curseFields
      ],
      storage: {
        format: "md-frontmatter",
        pathTemplate: "SaltMarcher/Items/{name}.md",
        filenameFrom: "name",
        directory: "SaltMarcher/Items",
        preserveCase: true,
        frontmatter: [
          "name",
          "category",
          "tags",
          "type",
          "rarity",
          "attunement",
          "attunement_req",
          "max_charges",
          "recharge_formula",
          "recharge_time",
          "destruction_risk",
          "spell_storage_capacity",
          "spells_json",
          "bonuses_json",
          "ability_changes_json",
          "speed_changes_json",
          "properties_json",
          "usage_limit_json",
          "tables_json",
          "sentient_props_json",
          "resistances",
          "immunities",
          "weight",
          "value",
          "cursed",
          "curse_description",
          "has_variants",
          "variant_info",
          "sentient"
        ],
        bodyTemplate: (data) => itemToMarkdown(data)
      },
      ui: {
        submitLabel: "Item erstellen",
        cancelLabel: "Abbrechen",
        enableNavigation: true,
        sections: [
          {
            id: "basic",
            label: "Grunddaten",
            description: "Name, Kategorie, Tags, Typ und Seltenheit",
            fieldIds: ["name", "category", "tags", "type", "rarity"]
          },
          {
            id: "attunement",
            label: "Einstimmung",
            description: "Einstimmungsanforderungen",
            fieldIds: ["attunement", "attunement_req"]
          },
          {
            id: "charges",
            label: "Ladungen",
            description: "Ladungssystem und Aufladung",
            fieldIds: ["max_charges", "recharge_formula", "recharge_time", "destruction_risk"]
          },
          {
            id: "properties",
            label: "Eigenschaften",
            description: "Beschreibung und Notizen",
            fieldIds: ["description", "notes"]
          },
          {
            id: "metadata",
            label: "Metadaten",
            description: "Gewicht und Wert",
            fieldIds: ["weight", "value"]
          },
          {
            id: "curse",
            label: "Fluch",
            description: "Verfluchte Items",
            fieldIds: ["cursed", "curse_description"]
          }
        ]
      },
      // Browse configuration - replaces view-config.ts and list-schema.ts
      browse: {
        metadata: [
          {
            id: "category",
            cls: "sm-cc-item__type",
            getValue: (entry) => entry.category
          },
          {
            id: "rarity",
            cls: "sm-cc-item__cr",
            getValue: (entry) => entry.rarity
          }
        ],
        filters: [
          { id: "category", field: "category", label: "Category", type: "string" },
          { id: "tags", field: "tags", label: "Tags", type: "array" },
          {
            id: "rarity",
            field: "rarity",
            label: "Rarity",
            type: "custom",
            sortComparator: (a, b) => {
              const RARITY_ORDER = /* @__PURE__ */ new Map([
                ["common", 0],
                ["uncommon", 1],
                ["rare", 2],
                ["very rare", 3],
                ["legendary", 4],
                ["artifact", 5]
              ]);
              const orderA = RARITY_ORDER.get(a?.toLowerCase() ?? "") ?? Number.POSITIVE_INFINITY;
              const orderB = RARITY_ORDER.get(b?.toLowerCase() ?? "") ?? Number.POSITIVE_INFINITY;
              return orderA - orderB || a.localeCompare(b);
            }
          }
        ],
        sorts: [
          { id: "name", label: "Name", field: "name" },
          { id: "category", label: "Category", field: "category" },
          {
            id: "rarity",
            label: "Rarity",
            compareFn: (a, b) => {
              const RARITY_ORDER = /* @__PURE__ */ new Map([
                ["common", 0],
                ["uncommon", 1],
                ["rare", 2],
                ["very rare", 3],
                ["legendary", 4],
                ["artifact", 5]
              ]);
              const orderA = RARITY_ORDER.get(a.rarity?.toLowerCase() ?? "") ?? Number.POSITIVE_INFINITY;
              const orderB = RARITY_ORDER.get(b.rarity?.toLowerCase() ?? "") ?? Number.POSITIVE_INFINITY;
              return orderA - orderB || a.name.localeCompare(b.name);
            }
          }
        ],
        search: ["category", "tags", "rarity"]
      },
      // Loader configuration - replaces loader.ts (uses auto-loader by default)
      loader: {
        // Auto-loader from frontmatter is sufficient for items
        // No custom loader needed
      }
    };
  }
});

// src/workmodes/library/items/index.ts
var init_items = __esm({
  "src/workmodes/library/items/index.ts"() {
    "use strict";
    init_create_spec3();
    init_serializer3();
  }
});

// src/workmodes/library/equipment/serializer.ts
function equipmentToMarkdown(d) {
  const lines = [];
  const name = d.name || "Unnamed Equipment";
  lines.push(`# ${name}`);
  const typeParts = [];
  if (d.type === "weapon") {
    if (d.weapon_category) typeParts.push(d.weapon_category);
    if (d.weapon_type) typeParts.push(d.weapon_type);
    typeParts.push("Weapon");
  } else if (d.type === "armor") {
    if (d.armor_category) typeParts.push(d.armor_category);
    typeParts.push("Armor");
  } else if (d.type === "tool") {
    if (d.tool_category) typeParts.push(d.tool_category);
    typeParts.push("Tool");
  } else if (d.type === "gear") {
    typeParts.push("Adventuring Gear");
    if (d.gear_category) typeParts.push(`(${d.gear_category})`);
  }
  if (typeParts.length > 0) {
    lines.push(`*${typeParts.join(" ")}*`);
  }
  lines.push("");
  const stats = [];
  if (d.cost) stats.push(`- **Cost:** ${d.cost}`);
  if (d.weight) stats.push(`- **Weight:** ${d.weight}`);
  if (stats.length > 0) {
    lines.push(...stats);
    lines.push("");
  }
  if (d.type === "weapon") {
    if (d.damage) {
      lines.push(`**Damage:** ${d.damage}`);
      lines.push("");
    }
    if (d.properties && d.properties.length > 0) {
      lines.push(`**Properties:** ${d.properties.join(", ")}`);
      lines.push("");
    }
    if (d.mastery) {
      lines.push(`**Mastery:** ${d.mastery}`);
      lines.push("");
    }
  }
  if (d.type === "armor") {
    if (d.ac) {
      lines.push(`**Armor Class (AC):** ${d.ac}`);
      lines.push("");
    }
    if (d.strength_requirement) {
      lines.push(`**Strength Requirement:** ${d.strength_requirement}`);
      lines.push("");
    }
    if (d.stealth_disadvantage) {
      lines.push(`**Stealth:** Disadvantage`);
      lines.push("");
    }
    if (d.don_time || d.doff_time) {
      const timeParts = [];
      if (d.don_time) timeParts.push(`Don: ${d.don_time}`);
      if (d.doff_time) timeParts.push(`Doff: ${d.doff_time}`);
      lines.push(`**Time:** ${timeParts.join(", ")}`);
      lines.push("");
    }
  }
  if (d.type === "tool") {
    if (d.ability) {
      lines.push(`**Ability:** ${d.ability}`);
      lines.push("");
    }
    if (d.utilize && d.utilize.length > 0) {
      lines.push(`## Utilize`);
      lines.push("");
      for (const use of d.utilize) {
        lines.push(`- ${use}`);
      }
      lines.push("");
    }
    if (d.craft && d.craft.length > 0) {
      lines.push(`## Craft`);
      lines.push("");
      lines.push(d.craft.join(", "));
      lines.push("");
    }
    if (d.variants && d.variants.length > 0) {
      lines.push(`## Variants`);
      lines.push("");
      for (const variant of d.variants) {
        lines.push(`- ${variant}`);
      }
      lines.push("");
    }
  }
  if (d.type === "gear") {
    if (d.capacity) {
      lines.push(`**Capacity:** ${d.capacity}`);
      lines.push("");
    }
    if (d.duration) {
      lines.push(`**Duration:** ${d.duration}`);
      lines.push("");
    }
    if (d.special_use) {
      lines.push(`## Special Use`);
      lines.push("");
      lines.push(d.special_use);
      lines.push("");
    }
  }
  if (d.description) {
    lines.push(d.description.trim());
    lines.push("");
  }
  return lines.join("\n");
}
var init_serializer4 = __esm({
  "src/workmodes/library/equipment/serializer.ts"() {
    "use strict";
  }
});

// src/workmodes/library/equipment/constants.ts
var EQUIPMENT_TYPES, WEAPON_CATEGORIES, WEAPON_TYPES, WEAPON_PROPERTIES, ARMOR_CATEGORIES, TOOL_CATEGORIES, CRAFT_SUGGESTIONS, EQUIPMENT_TAGS;
var init_constants4 = __esm({
  "src/workmodes/library/equipment/constants.ts"() {
    "use strict";
    EQUIPMENT_TYPES = ["weapon", "armor", "tool", "gear"];
    WEAPON_CATEGORIES = ["Simple", "Martial"];
    WEAPON_TYPES = ["Melee", "Ranged"];
    WEAPON_PROPERTIES = [
      "Finesse",
      "Light",
      "Heavy",
      "Reach",
      "Thrown",
      "Two-Handed",
      "Versatile",
      "Loading",
      "Ammunition"
    ];
    ARMOR_CATEGORIES = ["Light", "Medium", "Heavy", "Shield"];
    TOOL_CATEGORIES = ["Artisan", "Gaming", "Musical", "Other"];
    CRAFT_SUGGESTIONS = [
      "Acid",
      "Alchemist's Fire",
      "Oil",
      "Perfume",
      "Soap"
    ];
    EQUIPMENT_TAGS = [
      "Armor",
      "Weapon",
      "Tool",
      "Gear",
      "Mount",
      "Trade Goods"
    ];
  }
});

// src/workmodes/library/equipment/create-spec.ts
var equipmentSchema, basicInfoFields4, weaponFields, armorFields, toolFields, gearFields, descriptionFields2, equipmentSpec;
var init_create_spec4 = __esm({
  "src/workmodes/library/equipment/create-spec.ts"() {
    "use strict";
    init_serializer4();
    init_constants4();
    equipmentSchema = {
      parse: (data) => data,
      safeParse: (data) => {
        try {
          return { success: true, data };
        } catch (error) {
          return { success: false, error };
        }
      }
    };
    basicInfoFields4 = [
      {
        id: "name",
        label: "Name",
        type: "text",
        required: true,
        placeholder: "Longsword"
      },
      {
        id: "type",
        label: "Type",
        type: "select",
        required: true,
        options: EQUIPMENT_TYPES.map((type2) => ({
          value: type2,
          label: type2.charAt(0).toUpperCase() + type2.slice(1)
        })),
        default: "weapon"
      },
      {
        id: "tags",
        label: "Tags",
        type: "tokens",
        config: {
          fields: [{
            id: "value",
            type: "select",
            displayInChip: true,
            editable: true,
            suggestions: EQUIPMENT_TAGS.map((tag) => ({ key: tag, label: tag })),
            placeholder: "Tag ausw\xE4hlen..."
          }],
          primaryField: "value"
        },
        default: [],
        description: "Classification tags for filtering and organization"
      },
      {
        id: "cost",
        label: "Cost",
        type: "text",
        description: "e.g., '15 GP', '2 SP'",
        placeholder: "15 GP"
      },
      {
        id: "weight",
        label: "Weight",
        type: "text",
        description: "e.g., '3 lb.', '\u2014'",
        placeholder: "3 lb."
      }
    ];
    weaponFields = [
      {
        id: "weapon_category",
        label: "Category",
        type: "select",
        options: [
          { value: "", label: "(none)" },
          ...WEAPON_CATEGORIES.map((c) => ({ value: c, label: c }))
        ],
        visibleIf: (data) => data.type === "weapon"
      },
      {
        id: "weapon_type",
        label: "Weapon Type",
        type: "select",
        options: [
          { value: "", label: "(none)" },
          ...WEAPON_TYPES.map((t) => ({ value: t, label: t }))
        ],
        visibleIf: (data) => data.type === "weapon"
      },
      {
        id: "damage",
        label: "Damage",
        type: "text",
        description: "e.g., '1d8 Slashing'",
        placeholder: "1d8 Slashing",
        visibleIf: (data) => data.type === "weapon"
      },
      {
        id: "properties",
        label: "Properties",
        type: "tokens",
        description: "e.g., Finesse, Light, Thrown",
        config: {
          fields: [{
            id: "value",
            type: "text",
            displayInChip: true,
            editable: true,
            placeholder: "Property hinzuf\xFCgen...",
            suggestions: WEAPON_PROPERTIES
          }],
          primaryField: "value"
        },
        visibleIf: (data) => data.type === "weapon",
        default: []
      },
      {
        id: "mastery",
        label: "Mastery",
        type: "text",
        description: "e.g., 'Sap', 'Vex'",
        placeholder: "Sap",
        visibleIf: (data) => data.type === "weapon"
      }
    ];
    armorFields = [
      {
        id: "armor_category",
        label: "Category",
        type: "select",
        options: [
          { value: "", label: "(none)" },
          ...ARMOR_CATEGORIES.map((c) => ({ value: c, label: c }))
        ],
        visibleIf: (data) => data.type === "armor"
      },
      {
        id: "ac",
        label: "Armor Class (AC)",
        type: "text",
        description: "e.g., '11 + Dex modifier', '18'",
        placeholder: "11 + Dex modifier",
        visibleIf: (data) => data.type === "armor"
      },
      {
        id: "strength_requirement",
        label: "Strength Requirement",
        type: "text",
        description: "e.g., 'Str 13'",
        placeholder: "Str 13",
        visibleIf: (data) => data.type === "armor"
      },
      {
        id: "stealth_disadvantage",
        label: "Stealth Disadvantage",
        type: "checkbox",
        visibleIf: (data) => data.type === "armor",
        default: false
      },
      {
        id: "don_time",
        label: "Don Time",
        type: "text",
        description: "e.g., '1 Minute'",
        placeholder: "1 Minute",
        visibleIf: (data) => data.type === "armor"
      },
      {
        id: "doff_time",
        label: "Doff Time",
        type: "text",
        description: "e.g., '1 Minute'",
        placeholder: "1 Minute",
        visibleIf: (data) => data.type === "armor"
      }
    ];
    toolFields = [
      {
        id: "tool_category",
        label: "Category",
        type: "select",
        options: [
          { value: "", label: "(none)" },
          ...TOOL_CATEGORIES.map((c) => ({ value: c, label: c }))
        ],
        visibleIf: (data) => data.type === "tool"
      },
      {
        id: "ability",
        label: "Ability",
        type: "text",
        description: "e.g., 'Intelligence', 'Dexterity'",
        placeholder: "Intelligence",
        visibleIf: (data) => data.type === "tool"
      },
      {
        id: "utilize",
        label: "Utilize",
        type: "tokens",
        description: "Available utilize actions",
        config: {
          fields: [{
            id: "value",
            type: "text",
            displayInChip: true,
            editable: true,
            placeholder: "Action hinzuf\xFCgen..."
          }],
          primaryField: "value"
        },
        visibleIf: (data) => data.type === "tool",
        default: []
      },
      {
        id: "craft",
        label: "Craft",
        type: "tokens",
        description: "Craftable items",
        config: {
          fields: [{
            id: "value",
            type: "text",
            displayInChip: true,
            editable: true,
            placeholder: "Item hinzuf\xFCgen...",
            suggestions: CRAFT_SUGGESTIONS
          }],
          primaryField: "value"
        },
        visibleIf: (data) => data.type === "tool",
        default: []
      },
      {
        id: "variants",
        label: "Variants",
        type: "tokens",
        description: "Available variants",
        config: {
          fields: [{
            id: "value",
            type: "text",
            displayInChip: true,
            editable: true,
            placeholder: "Variant hinzuf\xFCgen..."
          }],
          primaryField: "value"
        },
        visibleIf: (data) => data.type === "tool",
        default: []
      }
    ];
    gearFields = [
      {
        id: "gear_category",
        label: "Category",
        type: "text",
        description: "e.g., 'Container', 'Light Source'",
        placeholder: "Container",
        visibleIf: (data) => data.type === "gear"
      },
      {
        id: "capacity",
        label: "Capacity",
        type: "text",
        description: "For containers",
        placeholder: "30 cubic feet / 300 lb.",
        visibleIf: (data) => data.type === "gear"
      },
      {
        id: "duration",
        label: "Duration",
        type: "text",
        description: "For consumables",
        placeholder: "1 hour",
        visibleIf: (data) => data.type === "gear"
      },
      {
        id: "special_use",
        label: "Special Use",
        type: "textarea",
        description: "Special usage rules",
        placeholder: "When you take the Attack action...",
        visibleIf: (data) => data.type === "gear"
      }
    ];
    descriptionFields2 = [
      {
        id: "description",
        label: "Description",
        type: "textarea",
        placeholder: "Equipment description..."
      }
    ];
    equipmentSpec = {
      kind: "equipment",
      title: "Equipment erstellen",
      subtitle: "Neue Ausr\xFCstung f\xFCr deine Kampagne",
      schema: equipmentSchema,
      fields: [
        ...basicInfoFields4,
        ...weaponFields,
        ...armorFields,
        ...toolFields,
        ...gearFields,
        ...descriptionFields2
      ],
      storage: {
        format: "md-frontmatter",
        pathTemplate: "SaltMarcher/Equipment/{name}.md",
        filenameFrom: "name",
        directory: "SaltMarcher/Equipment",
        preserveCase: true,
        frontmatter: [
          "name",
          "type",
          "tags",
          "cost",
          "weight",
          // Weapon fields
          "weapon_category",
          "weapon_type",
          "damage",
          "properties",
          "mastery",
          // Armor fields
          "armor_category",
          "ac",
          "strength_requirement",
          "stealth_disadvantage",
          "don_time",
          "doff_time",
          // Tool fields
          "tool_category",
          "ability",
          "utilize",
          "craft",
          "variants",
          // Gear fields
          "gear_category",
          "capacity",
          "duration",
          "special_use"
        ],
        bodyTemplate: (data) => equipmentToMarkdown(data)
      },
      ui: {
        submitLabel: "Equipment erstellen",
        cancelLabel: "Abbrechen",
        enableNavigation: true,
        sections: [
          {
            id: "basic",
            label: "Grunddaten",
            description: "Name, Typ, Tags, Kosten und Gewicht",
            fieldIds: ["name", "type", "tags", "cost", "weight"]
          },
          {
            id: "weapon",
            label: "Waffeneigenschaften",
            description: "Kategorie, Schaden und Eigenschaften",
            fieldIds: ["weapon_category", "weapon_type", "damage", "properties", "mastery"]
          },
          {
            id: "armor",
            label: "R\xFCstungseigenschaften",
            description: "Kategorie, AC und Anforderungen",
            fieldIds: ["armor_category", "ac", "strength_requirement", "stealth_disadvantage", "don_time", "doff_time"]
          },
          {
            id: "tool",
            label: "Werkzeugeigenschaften",
            description: "Kategorie, F\xE4higkeit und Verwendungen",
            fieldIds: ["tool_category", "ability", "utilize", "craft", "variants"]
          },
          {
            id: "gear",
            label: "Ausr\xFCstungseigenschaften",
            description: "Kategorie, Kapazit\xE4t und spezielle Verwendung",
            fieldIds: ["gear_category", "capacity", "duration", "special_use"]
          },
          {
            id: "description",
            label: "Beschreibung",
            description: "Allgemeine Beschreibung",
            fieldIds: ["description"]
          }
        ]
      },
      // Browse configuration - replaces view-config.ts and list-schema.ts
      browse: {
        metadata: [
          {
            id: "type",
            cls: "sm-cc-item__type",
            getValue: (entry) => entry.type
          },
          {
            id: "role",
            cls: "sm-cc-item__cr",
            getValue: (entry) => {
              if (entry.type === "weapon") return entry.weapon_category;
              if (entry.type === "armor") return entry.armor_category;
              if (entry.type === "tool") return entry.tool_category;
              if (entry.type === "gear") return entry.gear_category;
              return void 0;
            }
          }
        ],
        filters: [
          { id: "type", field: "type", label: "Type", type: "string" },
          { id: "tags", field: "tags", label: "Tags", type: "array" },
          {
            id: "role",
            field: "role",
            label: "Role",
            type: "custom"
            // Role is derived from multiple category fields, needs custom handling
          }
        ],
        sorts: [
          { id: "name", label: "Name", field: "name" },
          { id: "type", label: "Type", field: "type" },
          {
            id: "role",
            label: "Role",
            compareFn: (a, b) => {
              const roleA = a.type === "weapon" ? a.weapon_category : a.type === "armor" ? a.armor_category : a.type === "tool" ? a.tool_category : a.type === "gear" ? a.gear_category : "";
              const roleB = b.type === "weapon" ? b.weapon_category : b.type === "armor" ? b.armor_category : b.type === "tool" ? b.tool_category : b.type === "gear" ? b.gear_category : "";
              return (roleA ?? "").localeCompare(roleB ?? "") || a.name.localeCompare(b.name);
            }
          }
        ],
        search: ["type", "tags"]
      },
      // Loader configuration - replaces loader.ts (uses auto-loader by default)
      loader: {
        // Auto-loader from frontmatter is sufficient for equipment
        // No custom loader needed
      }
    };
  }
});

// src/workmodes/library/equipment/index.ts
var init_equipment = __esm({
  "src/workmodes/library/equipment/index.ts"() {
    "use strict";
    init_create_spec4();
    init_serializer4();
  }
});

// src/workmodes/library/terrains/serializer.ts
function terrainToMarkdown(data) {
  const lines = [];
  lines.push(`# ${data.display_name || data.name || "(default)"}`);
  lines.push("");
  if (data.name) {
    lines.push(`**Color:** ${data.color}`);
    lines.push(`**Movement Speed:** ${Math.round(data.speed * 100)}%`);
    lines.push("");
    if (data.speed < 0.5) {
      lines.push("*Very difficult terrain - significantly slows movement*");
    } else if (data.speed < 0.8) {
      lines.push("*Difficult terrain - slows movement*");
    } else if (data.speed < 1) {
      lines.push("*Slightly difficult terrain - minor movement penalty*");
    } else {
      lines.push("*Normal terrain - no movement penalty*");
    }
  } else {
    lines.push("Default terrain (transparent background).");
    lines.push("Used for areas without specific terrain.");
  }
  return lines.join("\n");
}
var init_serializer5 = __esm({
  "src/workmodes/library/terrains/serializer.ts"() {
    "use strict";
  }
});

// src/workmodes/library/terrains/constants.ts
var TERRAIN_BIOME_TAGS, TERRAIN_DIFFICULTY_TAGS;
var init_constants5 = __esm({
  "src/workmodes/library/terrains/constants.ts"() {
    "use strict";
    TERRAIN_BIOME_TAGS = [
      "Forest",
      "Mountain",
      "Coastal",
      "Desert",
      "Arctic",
      "Swamp",
      "Grassland",
      "Hills",
      "Urban",
      "Underground"
    ];
    TERRAIN_DIFFICULTY_TAGS = [
      "Easy",
      "Difficult",
      "Very Difficult"
    ];
  }
});

// src/workmodes/library/terrains/create-spec.ts
var terrainSchema, fields, terrainSpec;
var init_create_spec5 = __esm({
  "src/workmodes/library/terrains/create-spec.ts"() {
    "use strict";
    init_serializer5();
    init_constants5();
    terrainSchema = {
      parse: (data) => data,
      safeParse: (data) => {
        try {
          const terrain = data;
          if (typeof terrain.speed !== "number" || terrain.speed < 0.1 || terrain.speed > 1) {
            return {
              success: false,
              error: new Error("Speed must be between 0.1 and 1.0")
            };
          }
          if (!terrain.color || typeof terrain.color !== "string") {
            return {
              success: false,
              error: new Error("Color is required")
            };
          }
          return { success: true, data: terrain };
        } catch (error) {
          return { success: false, error };
        }
      }
    };
    fields = [
      {
        id: "name",
        label: "Name",
        type: "text",
        required: true,
        placeholder: "Wald",
        description: "Terrain name (leave empty for default/transparent terrain)"
      },
      {
        id: "biome_tags",
        label: "Biome Tags",
        type: "tokens",
        config: {
          fields: [{
            id: "value",
            type: "select",
            displayInChip: true,
            editable: true,
            suggestions: TERRAIN_BIOME_TAGS.map((tag) => ({ key: tag, label: tag })),
            placeholder: "Biome ausw\xE4hlen..."
          }],
          primaryField: "value"
        },
        default: [],
        description: "Terrain classification (Forest, Mountain, etc.)"
      },
      {
        id: "difficulty_tags",
        label: "Difficulty Tags",
        type: "tokens",
        config: {
          fields: [{
            id: "value",
            type: "select",
            displayInChip: true,
            editable: true,
            suggestions: TERRAIN_DIFFICULTY_TAGS.map((tag) => ({ key: tag, label: tag })),
            placeholder: "Difficulty ausw\xE4hlen..."
          }],
          primaryField: "value"
        },
        default: [],
        description: "Movement difficulty (Easy, Difficult, Very Difficult)"
      },
      {
        id: "color",
        label: "Color",
        type: "select",
        required: true,
        options: [
          { value: "transparent", label: "Transparent (Default)" },
          { value: "#2e7d32", label: "Wald (Gr\xFCn)" },
          { value: "#0288d1", label: "Meer (Blau)" },
          { value: "#6d4c41", label: "Berg (Braun)" },
          { value: "#ffeb3b", label: "W\xFCste (Gelb)" },
          { value: "#9e9e9e", label: "Gebirge (Grau)" },
          { value: "#757575", label: "Stein (Dunkelgrau)" },
          { value: "#795548", label: "Erde (Erdbraun)" },
          { value: "#4caf50", label: "Gras (Hellgr\xFCn)" },
          { value: "#00bcd4", label: "Eis (Cyan)" },
          { value: "custom", label: "Custom Hex Color..." }
        ],
        default: "transparent"
      },
      {
        id: "color_custom",
        label: "Custom Color",
        type: "text",
        placeholder: "#ff5722",
        description: "Hex color code (e.g., #ff5722)",
        visibleIf: (data) => data.color === "custom"
      },
      {
        id: "speed",
        label: "Movement Speed",
        type: "number-stepper",
        min: 0.1,
        max: 1,
        step: 0.1,
        default: 1,
        description: "Movement speed multiplier (1.0 = 100% normal speed)"
      }
    ];
    terrainSpec = {
      kind: "terrain",
      title: "Terrain erstellen",
      subtitle: "Neues Terrain f\xFCr deine Karten",
      schema: terrainSchema,
      fields,
      storage: {
        format: "md-frontmatter",
        pathTemplate: "SaltMarcher/Terrains/{name}.md",
        filenameFrom: "name",
        directory: "SaltMarcher/Terrains",
        frontmatter: ["name", "display_name", "biome_tags", "difficulty_tags", "color", "speed"],
        bodyTemplate: (data) => terrainToMarkdown(data)
      },
      ui: {
        submitLabel: "Terrain erstellen",
        cancelLabel: "Abbrechen",
        enableNavigation: false
        // Single section, no nav needed
      },
      // Browse configuration - replaces view-config.ts and list-schema.ts
      browse: {
        metadata: [
          {
            id: "color",
            cls: "sm-cc-item__type",
            getValue: (entry) => entry.color
          },
          {
            id: "speed",
            cls: "sm-cc-item__cr",
            getValue: (entry) => `Speed: ${Math.round(entry.speed * 100)}%`
          }
        ],
        filters: [
          { id: "biome_tags", field: "biome_tags", label: "Biome", type: "array" },
          { id: "difficulty_tags", field: "difficulty_tags", label: "Difficulty", type: "array" },
          { id: "speed", field: "speed", label: "Speed", type: "number" }
        ],
        sorts: [
          { id: "name", label: "Name", field: "name" },
          { id: "speed", label: "Speed", field: "speed" }
        ],
        search: ["name", "biome_tags", "difficulty_tags", "color"]
      },
      // Loader configuration - uses auto-loader by default
      loader: {}
    };
  }
});

// src/workmodes/library/terrains/index.ts
var init_terrains = __esm({
  "src/workmodes/library/terrains/index.ts"() {
    "use strict";
    init_create_spec5();
    init_serializer5();
  }
});

// src/workmodes/library/regions/serializer.ts
function regionToMarkdown(data) {
  const lines = [];
  lines.push(`# ${data.name}`);
  lines.push("");
  if (data.terrain) {
    lines.push(`**Terrain:** ${data.terrain}`);
  }
  if (data.encounter_odds && data.encounter_odds > 0) {
    lines.push(`**Encounter Rate:** 1/${data.encounter_odds}`);
    if (data.encounter_odds <= 2) {
      lines.push("*Very dangerous - encounters are very frequent*");
    } else if (data.encounter_odds <= 4) {
      lines.push("*Dangerous - encounters are frequent*");
    } else if (data.encounter_odds <= 8) {
      lines.push("*Moderate danger - occasional encounters*");
    } else if (data.encounter_odds <= 12) {
      lines.push("*Relatively safe - encounters are rare*");
    } else {
      lines.push("*Very safe - encounters are very rare*");
    }
  } else {
    lines.push("**Encounter Rate:** None");
    lines.push("*Safe zone - no random encounters*");
  }
  if (data.description) {
    lines.push("");
    lines.push("## Description");
    lines.push(data.description);
  }
  return lines.join("\n");
}
var init_serializer6 = __esm({
  "src/workmodes/library/regions/serializer.ts"() {
    "use strict";
  }
});

// src/workmodes/library/regions/constants.ts
var REGION_BIOME_TAGS, REGION_DANGER_TAGS, REGION_CLIMATE_TAGS, REGION_SETTLEMENT_TAGS, ENCOUNTER_ODDS_PRESETS, TERRAIN_SUGGESTIONS;
var init_constants6 = __esm({
  "src/workmodes/library/regions/constants.ts"() {
    "use strict";
    REGION_BIOME_TAGS = [
      "Forest",
      "Mountain",
      "Coastal",
      "Desert",
      "Arctic",
      "Swamp",
      "Grassland",
      "Hills",
      "Urban",
      "Underground"
    ];
    REGION_DANGER_TAGS = [
      "Safe",
      "Moderate",
      "Dangerous",
      "Deadly"
    ];
    REGION_CLIMATE_TAGS = [
      "Arctic",
      "Cold",
      "Temperate",
      "Warm",
      "Hot",
      "Desert"
    ];
    REGION_SETTLEMENT_TAGS = [
      "Civilized",
      "Frontier",
      "Wilderness",
      "Ruins"
    ];
    ENCOUNTER_ODDS_PRESETS = [
      { value: 0, label: "No encounters" },
      { value: 20, label: "Very rare (1/20)" },
      { value: 12, label: "Rare (1/12)" },
      { value: 8, label: "Uncommon (1/8)" },
      { value: 6, label: "Common (1/6)" },
      { value: 4, label: "Frequent (1/4)" },
      { value: 2, label: "Very frequent (1/2)" }
    ];
    TERRAIN_SUGGESTIONS = [
      "Wald",
      "Meer",
      "Berg",
      "W\xFCste",
      "Grasland",
      "Sumpf",
      "K\xFCste",
      "Stadt",
      "Ruinen",
      "H\xF6hlen"
    ];
  }
});

// src/workmodes/library/regions/create-spec.ts
var regionSchema, fields2, regionSpec;
var init_create_spec6 = __esm({
  "src/workmodes/library/regions/create-spec.ts"() {
    "use strict";
    init_serializer6();
    init_constants6();
    regionSchema = {
      parse: (data) => data,
      safeParse: (data) => {
        try {
          const region = data;
          if (region.encounter_odds !== void 0) {
            if (typeof region.encounter_odds !== "number" || region.encounter_odds < 0) {
              return {
                success: false,
                error: new Error("Encounter odds must be a positive number")
              };
            }
          }
          return { success: true, data: region };
        } catch (error) {
          return { success: false, error };
        }
      }
    };
    fields2 = [
      {
        id: "name",
        label: "Name",
        type: "text",
        required: true,
        placeholder: "Saltmarsh",
        description: "Name of the region"
      },
      {
        id: "biome_tags",
        label: "Biome Tags",
        type: "tokens",
        config: {
          fields: [{
            id: "value",
            type: "select",
            displayInChip: true,
            editable: true,
            suggestions: REGION_BIOME_TAGS.map((tag) => ({ key: tag, label: tag })),
            placeholder: "Biome ausw\xE4hlen..."
          }],
          primaryField: "value"
        },
        default: [],
        description: "Terrain classification (Forest, Mountain, Coastal, etc.)"
      },
      {
        id: "danger_tags",
        label: "Danger Tags",
        type: "tokens",
        config: {
          fields: [{
            id: "value",
            type: "select",
            displayInChip: true,
            editable: true,
            suggestions: REGION_DANGER_TAGS.map((tag) => ({ key: tag, label: tag })),
            placeholder: "Danger ausw\xE4hlen..."
          }],
          primaryField: "value"
        },
        default: [],
        description: "Danger level (Safe, Moderate, Dangerous, Deadly)"
      },
      {
        id: "climate_tags",
        label: "Climate Tags",
        type: "tokens",
        config: {
          fields: [{
            id: "value",
            type: "select",
            displayInChip: true,
            editable: true,
            suggestions: REGION_CLIMATE_TAGS.map((tag) => ({ key: tag, label: tag })),
            placeholder: "Climate ausw\xE4hlen..."
          }],
          primaryField: "value"
        },
        default: [],
        description: "Climate type (Arctic, Cold, Temperate, Warm, Hot, Desert)"
      },
      {
        id: "settlement_tags",
        label: "Settlement Tags",
        type: "tokens",
        config: {
          fields: [{
            id: "value",
            type: "select",
            displayInChip: true,
            editable: true,
            suggestions: REGION_SETTLEMENT_TAGS.map((tag) => ({ key: tag, label: tag })),
            placeholder: "Settlement ausw\xE4hlen..."
          }],
          primaryField: "value"
        },
        default: [],
        description: "Settlement type (Civilized, Frontier, Wilderness, Ruins)"
      },
      {
        id: "terrain",
        label: "Terrain",
        type: "text",
        placeholder: "K\xFCste",
        description: "Primary terrain type of this region",
        config: {
          suggestions: TERRAIN_SUGGESTIONS
        }
      },
      {
        id: "encounter_odds",
        label: "Encounter Rate",
        type: "select",
        options: ENCOUNTER_ODDS_PRESETS.map((p) => ({
          value: String(p.value),
          label: p.label
        })),
        default: "0",
        description: "Chance of random encounters (1/N per travel period)"
      },
      {
        id: "description",
        label: "Description",
        type: "textarea",
        placeholder: "A bustling coastal town known for fishing and trade...",
        description: "Optional description of the region"
      }
    ];
    regionSpec = {
      kind: "region",
      title: "Region erstellen",
      subtitle: "Neue Region f\xFCr deine Welt",
      schema: regionSchema,
      fields: fields2,
      storage: {
        format: "md-frontmatter",
        pathTemplate: "SaltMarcher/Regions/{name}.md",
        filenameFrom: "name",
        directory: "SaltMarcher/Regions",
        frontmatter: ["name", "biome_tags", "danger_tags", "climate_tags", "settlement_tags", "terrain", "encounter_odds", "description"],
        bodyTemplate: (data) => regionToMarkdown(data)
      },
      ui: {
        submitLabel: "Region erstellen",
        cancelLabel: "Abbrechen",
        enableNavigation: false
        // Single section, no nav needed
      },
      // Browse configuration - replaces view-config.ts and list-schema.ts
      browse: {
        metadata: [
          {
            id: "terrain",
            cls: "sm-cc-item__type",
            getValue: (entry) => entry.terrain || "Unknown"
          },
          {
            id: "encounter_odds",
            cls: "sm-cc-item__cr",
            getValue: (entry) => {
              if (!entry.encounter_odds || entry.encounter_odds === 0) return "No encounters";
              return `Encounters: 1/${entry.encounter_odds}`;
            }
          }
        ],
        filters: [
          { id: "biome_tags", field: "biome_tags", label: "Biome", type: "array" },
          { id: "danger_tags", field: "danger_tags", label: "Danger", type: "array" },
          { id: "climate_tags", field: "climate_tags", label: "Climate", type: "array" },
          { id: "settlement_tags", field: "settlement_tags", label: "Settlement", type: "array" },
          { id: "terrain", field: "terrain", label: "Terrain", type: "string" },
          { id: "encounter_odds", field: "encounter_odds", label: "Encounter Rate", type: "number" }
        ],
        sorts: [
          { id: "name", label: "Name", field: "name" },
          { id: "terrain", label: "Terrain", field: "terrain" },
          {
            id: "encounter_odds",
            label: "Danger Level",
            compareFn: (a, b) => {
              const oddsA = a.encounter_odds || Number.MAX_VALUE;
              const oddsB = b.encounter_odds || Number.MAX_VALUE;
              return oddsA - oddsB;
            }
          }
        ],
        search: ["name", "biome_tags", "danger_tags", "climate_tags", "settlement_tags", "terrain", "description"]
      },
      // Loader configuration - uses auto-loader by default
      loader: {}
    };
  }
});

// src/workmodes/library/regions/index.ts
var init_regions = __esm({
  "src/workmodes/library/regions/index.ts"() {
    "use strict";
    init_create_spec6();
    init_serializer6();
  }
});

// src/workmodes/library/calendars/serializer.ts
function calendarToMarkdown(data) {
  const lines = [];
  lines.push(`# ${data.name}`);
  lines.push("");
  if (data.description) {
    lines.push(data.description);
    lines.push("");
  }
  lines.push("## Months");
  lines.push("");
  lines.push("| Month | Days |");
  lines.push("|-------|------|");
  for (const month of data.months) {
    lines.push(`| ${month.name} | ${month.length} |`);
  }
  lines.push("");
  lines.push("## Time Structure");
  lines.push("");
  lines.push(`- **Week**: ${data.daysPerWeek} days`);
  if (data.hoursPerDay) {
    lines.push(`- **Day**: ${data.hoursPerDay} hours`);
  }
  if (data.minutesPerHour) {
    lines.push(`- **Hour**: ${data.minutesPerHour} minutes`);
  }
  if (data.secondsPerMinute) {
    lines.push(`- **Minute**: ${data.secondsPerMinute} seconds`);
  }
  lines.push("");
  lines.push("## Epoch");
  lines.push("");
  const epochMonth = data.months.find((m) => m.id === data.epoch.monthId);
  const epochMonthName = epochMonth ? epochMonth.name : data.epoch.monthId;
  lines.push(`The epoch (reference point) for this calendar is set to **${epochMonthName} ${data.epoch.day}, ${data.epoch.year}**.`);
  return lines.join("\n");
}
var init_serializer7 = __esm({
  "src/workmodes/library/calendars/serializer.ts"() {
    "use strict";
  }
});

// src/workmodes/library/calendars/constants.ts
var DEFAULT_HOURS_PER_DAY, DEFAULT_MINUTES_PER_HOUR, DEFAULT_SECONDS_PER_MINUTE, DEFAULT_MINUTE_STEP, DEFAULT_DAYS_PER_WEEK;
var init_constants7 = __esm({
  "src/workmodes/library/calendars/constants.ts"() {
    "use strict";
    DEFAULT_HOURS_PER_DAY = 24;
    DEFAULT_MINUTES_PER_HOUR = 60;
    DEFAULT_SECONDS_PER_MINUTE = 60;
    DEFAULT_MINUTE_STEP = 15;
    DEFAULT_DAYS_PER_WEEK = 7;
  }
});

// src/workmodes/library/calendars/create-spec.ts
var calendarSchema, fields3, calendarSpec;
var init_create_spec7 = __esm({
  "src/workmodes/library/calendars/create-spec.ts"() {
    "use strict";
    init_serializer7();
    init_constants7();
    calendarSchema = {
      parse: (data) => data,
      safeParse: (data) => {
        try {
          const calendar = data;
          if (!calendar.name || typeof calendar.name !== "string") {
            return {
              success: false,
              error: new Error("Calendar name is required")
            };
          }
          if (!calendar.id || typeof calendar.id !== "string") {
            return {
              success: false,
              error: new Error("Calendar ID is required")
            };
          }
          if (!calendar.months || !Array.isArray(calendar.months) || calendar.months.length === 0) {
            return {
              success: false,
              error: new Error("Calendar must have at least one month")
            };
          }
          for (const month of calendar.months) {
            if (!month.id || !month.name || typeof month.length !== "number") {
              return {
                success: false,
                error: new Error("Each month must have id, name, and length")
              };
            }
            if (month.length < 1 || month.length > 100) {
              return {
                success: false,
                error: new Error(`Month "${month.name}" length must be between 1 and 100 days`)
              };
            }
          }
          if (!calendar.epoch || typeof calendar.epoch.year !== "number") {
            return {
              success: false,
              error: new Error("Epoch year is required")
            };
          }
          return { success: true, data: calendar };
        } catch (error) {
          return { success: false, error };
        }
      }
    };
    fields3 = [
      {
        id: "name",
        label: "Calendar Name",
        type: "text",
        required: true,
        placeholder: "Gregorian Calendar",
        description: "Display name for the calendar"
      },
      {
        id: "id",
        label: "Calendar ID",
        type: "text",
        required: true,
        placeholder: "gregorian-standard",
        description: "Unique identifier (lowercase, hyphens allowed)"
      },
      {
        id: "description",
        label: "Description",
        type: "textarea",
        placeholder: "A calendar system for...",
        description: "Optional description of the calendar system"
      },
      {
        id: "daysPerWeek",
        label: "Days per Week",
        type: "number",
        min: 1,
        max: 30,
        default: DEFAULT_DAYS_PER_WEEK,
        description: "Number of days in a week"
      },
      {
        id: "hoursPerDay",
        label: "Hours per Day",
        type: "number",
        min: 1,
        max: 100,
        default: DEFAULT_HOURS_PER_DAY,
        description: "Number of hours in a day"
      },
      {
        id: "minutesPerHour",
        label: "Minutes per Hour",
        type: "number",
        min: 1,
        max: 100,
        default: DEFAULT_MINUTES_PER_HOUR,
        description: "Number of minutes in an hour"
      },
      {
        id: "secondsPerMinute",
        label: "Seconds per Minute",
        type: "number",
        min: 1,
        max: 100,
        default: DEFAULT_SECONDS_PER_MINUTE,
        description: "Number of seconds in a minute"
      },
      {
        id: "minuteStep",
        label: "Minute Step",
        type: "number",
        min: 1,
        max: 60,
        default: DEFAULT_MINUTE_STEP,
        description: "Step size for minute selection (e.g., 15 = 00, 15, 30, 45)"
      }
    ];
    calendarSpec = {
      kind: "calendar",
      title: "Calendar erstellen",
      subtitle: "Neues Kalendersystem f\xFCr deine Welt",
      schema: calendarSchema,
      fields: fields3,
      storage: {
        format: "md-frontmatter",
        pathTemplate: "SaltMarcher/Calendars/{name}.md",
        filenameFrom: "name",
        directory: "SaltMarcher/Calendars",
        frontmatter: [
          "name",
          "id",
          "description",
          "daysPerWeek",
          "months",
          "hoursPerDay",
          "minutesPerHour",
          "secondsPerMinute",
          "minuteStep",
          "epoch",
          "schemaVersion"
        ],
        bodyTemplate: (data) => calendarToMarkdown(data)
      },
      ui: {
        submitLabel: "Calendar erstellen",
        cancelLabel: "Abbrechen",
        enableNavigation: false
      },
      // Browse configuration
      browse: {
        metadata: [
          {
            id: "daysPerWeek",
            cls: "sm-cc-item__type",
            getValue: (entry) => `${entry.daysPerWeek}-day week`
          },
          {
            id: "months",
            cls: "sm-cc-item__cr",
            getValue: (entry) => `${entry.monthCount || 0} months`
          }
        ],
        filters: [
          { id: "daysPerWeek", field: "daysPerWeek", label: "Days per Week", type: "number" }
        ],
        sorts: [
          { id: "name", label: "Name", field: "name" },
          { id: "daysPerWeek", label: "Days per Week", field: "daysPerWeek" }
        ],
        search: ["name", "id", "description"]
      },
      loader: {}
    };
  }
});

// src/workmodes/library/calendars/index.ts
var init_calendars = __esm({
  "src/workmodes/library/calendars/index.ts"() {
    "use strict";
    init_create_spec7();
    init_serializer7();
  }
});

// src/workmodes/library/factions/constants.ts
var FACTION_INFLUENCE_TAGS, FACTION_CULTURE_TAGS, FACTION_GOAL_TAGS, FACTION_MEMBER_ROLES, FACTION_MEMBER_STATUSES, FACTION_JOB_TYPES, FACTION_POSITION_TYPES, FACTION_RELATIONSHIP_TYPES, FACTION_RESOURCE_TYPES;
var init_constants8 = __esm({
  "src/workmodes/library/factions/constants.ts"() {
    "use strict";
    FACTION_INFLUENCE_TAGS = [
      "Political",
      "Military",
      "Religious",
      "Economic",
      "Arcane",
      "Criminal",
      "Scholarly",
      "Mercantile",
      "Civic",
      "Shadow"
    ];
    FACTION_CULTURE_TAGS = [
      "Human",
      "Elven",
      "Dwarven",
      "Halfling",
      "Orcish",
      "Dragonborn",
      "Tiefling",
      "Mixed",
      "Outsider",
      "Undead"
    ];
    FACTION_GOAL_TAGS = [
      "Expansion",
      "Defense",
      "Knowledge",
      "Dominance",
      "Reformation",
      "Profit",
      "Faith",
      "Revenge",
      "Exploration",
      "Stability"
    ];
    FACTION_MEMBER_ROLES = [
      "Leader",
      "Advisor",
      "Envoy",
      "Operative",
      "Spy",
      "Champion",
      "Agent",
      "Quartermaster",
      "Scout",
      "Guard",
      "Worker",
      "Crafter",
      "Mage",
      "Cleric"
    ];
    FACTION_MEMBER_STATUSES = [
      "Active",
      "On Assignment",
      "Missing",
      "Deceased",
      "Retired"
    ];
    FACTION_JOB_TYPES = [
      "crafting",
      "gathering",
      "training",
      "summoning",
      "guard",
      "patrol",
      "research"
    ];
    FACTION_POSITION_TYPES = [
      "hex",
      "poi",
      "expedition",
      "unassigned"
    ];
    FACTION_RELATIONSHIP_TYPES = [
      "allied",
      "neutral",
      "hostile",
      "trade",
      "rivalry",
      "vassal"
    ];
    FACTION_RESOURCE_TYPES = [
      "gold",
      "food",
      "equipment",
      "magic",
      "influence"
    ];
  }
});

// src/workmodes/library/factions/serializer.ts
function formatTagList(values) {
  if (!values || values.length === 0) return "\u2014";
  const items = values.map((entry) => typeof entry === "object" && entry ? entry.value : void 0).filter((value) => typeof value === "string" && value.trim().length > 0);
  return items.length > 0 ? items.join(", ") : "\u2014";
}
function formatResources(resources) {
  if (!resources || Object.keys(resources).length === 0) return "\u2014";
  const lines = [];
  for (const [key, value] of Object.entries(resources)) {
    if (value !== void 0) {
      lines.push(`- **${key}**: ${value}`);
    }
  }
  return lines.length > 0 ? lines.join("\n") : "\u2014";
}
function formatRelationship(rel) {
  const parts = [];
  parts.push(`**${rel.faction_name}**`);
  const value = rel.value >= 0 ? `+${rel.value}` : `${rel.value}`;
  parts.push(`(${value})`);
  if (rel.type) {
    parts.push(`[${rel.type}]`);
  }
  if (rel.notes) {
    parts.push(`\u2014 ${rel.notes}`);
  }
  return parts.join(" ");
}
function formatPosition(member) {
  if (!member.position || member.position.type === "unassigned") return null;
  const pos = member.position;
  switch (pos.type) {
    case "hex":
      if (pos.coords) {
        return `Hex (${pos.coords.q}, ${pos.coords.r}, ${pos.coords.s})`;
      }
      return "Hex";
    case "poi":
      return pos.location_name || "POI";
    case "expedition":
      return pos.route ? `Expedition: ${pos.route}` : "Expedition";
    default:
      return null;
  }
}
function formatJob(member) {
  if (!member.job || !member.job.type) return null;
  const parts = [member.job.type];
  if (member.job.building) {
    parts.push(`at ${member.job.building}`);
  }
  if (member.job.progress !== void 0) {
    parts.push(`(${member.job.progress}%)`);
  }
  return parts.join(" ");
}
function formatMember(member) {
  const parts = [];
  const name = member.name?.trim();
  if (name) {
    parts.push(`**${name}**`);
  }
  const details = [];
  if (!member.is_named && member.quantity && member.quantity > 1) {
    details.push(`\xD7${member.quantity}`);
  }
  if (member.statblock_ref) {
    details.push(`[${member.statblock_ref}]`);
  }
  if (member.role) {
    details.push(member.role);
  }
  if (member.status) {
    details.push(member.status);
  }
  if (details.length > 0) {
    parts.push(`(${details.join(" \xB7 ")})`);
  }
  const position = formatPosition(member);
  if (position) {
    parts.push(`\u{1F4CD} ${position}`);
  }
  const job = formatJob(member);
  if (job) {
    parts.push(`\u{1F4BC} ${job}`);
  }
  if (member.notes) {
    parts.push(`\u2014 ${member.notes}`);
  }
  return parts.join(" ");
}
function factionToMarkdown(data) {
  const lines = [];
  lines.push(`# ${data.name}`);
  lines.push("");
  if (data.motto) {
    lines.push(`> ${data.motto}`);
    lines.push("");
  }
  lines.push("## Overview");
  lines.push(`- **Headquarters:** ${data.headquarters?.trim() || "\u2014"}`);
  lines.push(`- **Territory:** ${data.territory?.trim() || "\u2014"}`);
  lines.push(`- **Influence:** ${formatTagList(data.influence_tags)}`);
  lines.push(`- **Culture:** ${formatTagList(data.culture_tags)}`);
  lines.push(`- **Goals:** ${formatTagList(data.goal_tags)}`);
  if (data.summary) {
    lines.push("");
    lines.push("## Summary");
    lines.push(data.summary);
  }
  if (data.resources && Object.keys(data.resources).length > 0) {
    lines.push("");
    lines.push("## Resources");
    lines.push(formatResources(data.resources));
  } else if (data.assets) {
    lines.push("");
    lines.push("## Assets & Resources");
    lines.push(data.assets);
  }
  if (data.faction_relationships && data.faction_relationships.length > 0) {
    lines.push("");
    lines.push("## Faction Relationships");
    lines.push("");
    for (const rel of data.faction_relationships) {
      if (!rel || !rel.faction_name) continue;
      lines.push(`- ${formatRelationship(rel)}`);
    }
  } else if (data.relationships) {
    lines.push("");
    lines.push("## Relationships");
    lines.push(data.relationships);
  }
  if (data.members && data.members.length > 0) {
    lines.push("");
    lines.push("## Members & Units");
    lines.push("");
    for (const member of data.members) {
      if (!member || !member.name) continue;
      lines.push(`- ${formatMember(member)}`);
    }
  }
  return lines.join("\n");
}
var init_serializer8 = __esm({
  "src/workmodes/library/factions/serializer.ts"() {
    "use strict";
  }
});

// src/workmodes/library/factions/create-spec.ts
function isStringArray(value) {
  return Array.isArray(value) && value.every((entry) => {
    if (typeof entry === "string") return entry.trim().length > 0;
    return typeof entry === "object" && entry !== null && typeof entry.value === "string";
  });
}
function normalizeTagArray(value) {
  if (!value) return void 0;
  if (!Array.isArray(value)) return void 0;
  const normalized = [];
  for (const entry of value) {
    if (typeof entry === "string" && entry.trim()) {
      normalized.push({ value: entry.trim() });
    } else if (entry && typeof entry === "object" && typeof entry.value === "string") {
      const val = entry.value.trim();
      if (val) normalized.push({ value: val });
    }
  }
  return normalized;
}
function normalizeMembers(value) {
  if (!value) return void 0;
  if (!Array.isArray(value)) return void 0;
  const result = [];
  for (const entry of value) {
    if (!entry || typeof entry !== "object") continue;
    const record = entry;
    const name = typeof record.name === "string" ? record.name.trim() : "";
    if (!name) continue;
    result.push({
      name,
      role: typeof record.role === "string" ? record.role.trim() || void 0 : void 0,
      status: typeof record.status === "string" ? record.status.trim() || void 0 : void 0,
      is_named: typeof record.is_named === "boolean" ? record.is_named : void 0,
      notes: typeof record.notes === "string" ? record.notes.trim() || void 0 : void 0
    });
  }
  return result;
}
var factionSchema, tagField, fields4, factionSpec;
var init_create_spec8 = __esm({
  "src/workmodes/library/factions/create-spec.ts"() {
    "use strict";
    init_constants8();
    init_serializer8();
    factionSchema = {
      parse: (data) => data,
      safeParse: (data) => {
        try {
          if (!data || typeof data !== "object") {
            throw new Error("Faction data must be an object");
          }
          const faction = data;
          if (typeof faction.name !== "string" || faction.name.trim().length === 0) {
            throw new Error("Name is required");
          }
          if (faction.influence_tags && !isStringArray(faction.influence_tags)) {
            throw new Error("Influence tags must be an array of values");
          }
          if (faction.culture_tags && !isStringArray(faction.culture_tags)) {
            throw new Error("Culture tags must be an array of values");
          }
          if (faction.goal_tags && !isStringArray(faction.goal_tags)) {
            throw new Error("Goal tags must be an array of values");
          }
          if (faction.members) {
            const members = normalizeMembers(faction.members);
            if (!members) {
              throw new Error("Members must be an array of objects");
            }
            faction.members = members;
          }
          faction.influence_tags = normalizeTagArray(faction.influence_tags) ?? [];
          faction.culture_tags = normalizeTagArray(faction.culture_tags) ?? [];
          faction.goal_tags = normalizeTagArray(faction.goal_tags) ?? [];
          return { success: true, data: faction };
        } catch (error) {
          return { success: false, error: error instanceof Error ? error : new Error(String(error)) };
        }
      }
    };
    tagField = (id, label, suggestions, description) => ({
      id,
      label,
      type: "tokens",
      config: {
        fields: [
          {
            id: "value",
            type: "select",
            displayInChip: true,
            editable: true,
            suggestions: suggestions.map((value) => ({ key: value, label: value })),
            placeholder: `${label} ausw\xE4hlen\u2026`
          }
        ],
        primaryField: "value"
      },
      default: [],
      description
    });
    fields4 = [
      {
        id: "name",
        label: "Name",
        type: "text",
        required: true,
        placeholder: "Die Schildbr\xFCder",
        description: "Name der Fraktion"
      },
      {
        id: "motto",
        label: "Motto",
        type: "text",
        placeholder: "In Schatten liegt unsere St\xE4rke",
        description: "Optionales Motto oder Leitspruch"
      },
      tagField(
        "influence_tags",
        "Einfluss",
        FACTION_INFLUENCE_TAGS,
        "Welche Bereiche dominiert die Fraktion?"
      ),
      tagField(
        "goal_tags",
        "Ziele",
        FACTION_GOAL_TAGS,
        "Strategische Ziele oder Agenda der Fraktion"
      ),
      tagField(
        "culture_tags",
        "Kultur",
        FACTION_CULTURE_TAGS,
        "Kulturelle Ausrichtung oder Herkunft"
      ),
      {
        id: "headquarters",
        label: "Hauptquartier",
        type: "text",
        placeholder: "Zitadelle von Sturmlicht",
        description: "Zentrale Operationsbasis der Fraktion"
      },
      {
        id: "territory",
        label: "Territorium",
        type: "text",
        placeholder: "Region, Einflussbereich oder Revier",
        description: "Gebiete, die von der Fraktion kontrolliert oder beansprucht werden"
      },
      {
        id: "summary",
        label: "Kurzbeschreibung",
        type: "textarea",
        placeholder: "Kurzprofil der Fraktion, Geschichte oder Ruf\u2026",
        description: "Zusammenfassung f\xFCr den schnellen \xDCberblick"
      },
      {
        id: "assets",
        label: "Ressourcen & Besitz",
        type: "textarea",
        placeholder: "Truppenst\xE4rke, finanzielle Mittel, Artefakte\u2026",
        description: "Wichtige Ressourcen, Besitz oder milit\xE4rische St\xE4rke"
      },
      {
        id: "relationships",
        label: "Beziehungen (Legacy)",
        type: "textarea",
        placeholder: "Wichtige B\xFCndnisse, Rivalit\xE4ten oder Verpflichtungen\u2026",
        description: "Freitext-Beziehungen (Legacy-Feld)",
        visibleIf: (values) => Boolean(values.relationships)
      },
      {
        id: "resources",
        label: "Ressourcen",
        type: "repeating",
        description: "Strukturiertes Ressourcen-Tracking (Gold, Food, Equipment, etc.)",
        config: {
          insertPosition: "end",
          synchronizeWidths: true
        },
        itemTemplate: {
          type: {
            type: "select",
            label: "Typ",
            options: FACTION_RESOURCE_TYPES.map((type2) => ({ value: type2, label: type2 })),
            required: true
          },
          amount: {
            type: "number-stepper",
            label: "Menge",
            min: 0,
            max: 999999,
            default: 0
          }
        },
        default: []
      },
      {
        id: "faction_relationships",
        label: "Fraktionsbeziehungen",
        type: "repeating",
        description: "Strukturierte Beziehungen zu anderen Fraktionen",
        config: {
          insertPosition: "end",
          synchronizeWidths: true
        },
        itemTemplate: {
          faction_name: {
            type: "text",
            label: "Fraktion",
            placeholder: "Name der anderen Fraktion",
            required: true
          },
          value: {
            type: "number-stepper",
            label: "Wert",
            min: -100,
            max: 100,
            default: 0,
            help: "-100 (feindlich) bis +100 (verb\xFCndet)"
          },
          type: {
            type: "select",
            label: "Typ",
            options: FACTION_RELATIONSHIP_TYPES.map((type2) => ({ value: type2, label: type2 }))
          },
          notes: {
            type: "textarea",
            label: "Notizen",
            placeholder: "Details zur Beziehung\u2026"
          }
        },
        default: []
      },
      {
        id: "members",
        label: "Mitglieder & Einheiten",
        type: "repeating",
        description: "Benannte NSCs oder Einheitentypen mit Positions- und Job-Tracking",
        config: {
          insertPosition: "end",
          synchronizeWidths: false
        },
        itemTemplate: {
          name: {
            type: "text",
            label: "Name / Einheit",
            placeholder: "Captain Thorne / Goblin Warrior",
            required: true
          },
          is_named: {
            type: "toggle",
            label: "Benannter NSC",
            default: true,
            help: "Benannte NSCs vs. Einheitentypen mit Menge"
          },
          quantity: {
            type: "number-stepper",
            label: "Anzahl",
            min: 1,
            max: 9999,
            default: 1,
            visibleIf: (data) => !data.is_named,
            help: "Nur f\xFCr Einheitentypen (nicht benannte NSCs)"
          },
          statblock_ref: {
            type: "text",
            label: "Statblock-Referenz",
            placeholder: "Goblin / Guard",
            help: "Name des Creature-Statblocks aus der Library"
          },
          role: {
            type: "text",
            label: "Rolle",
            placeholder: "Spymaster",
            config: {
              suggestions: FACTION_MEMBER_ROLES.map((role) => ({ key: role, label: role }))
            }
          },
          status: {
            type: "select",
            label: "Status",
            options: FACTION_MEMBER_STATUSES.map((status) => ({ value: status, label: status }))
          },
          "position.type": {
            type: "select",
            label: "Position-Typ",
            options: FACTION_POSITION_TYPES.map((type2) => ({ value: type2, label: type2 })),
            default: "unassigned"
          },
          "position.location_name": {
            type: "text",
            label: "Ort",
            placeholder: "Camp Alpha / Zitadelle",
            visibleIf: (data) => data["position.type"] === "poi"
          },
          "position.coords.q": {
            type: "number-stepper",
            label: "Hex Q",
            min: -100,
            max: 100,
            visibleIf: (data) => data["position.type"] === "hex"
          },
          "position.coords.r": {
            type: "number-stepper",
            label: "Hex R",
            min: -100,
            max: 100,
            visibleIf: (data) => data["position.type"] === "hex"
          },
          "position.coords.s": {
            type: "number-stepper",
            label: "Hex S",
            min: -100,
            max: 100,
            visibleIf: (data) => data["position.type"] === "hex"
          },
          "position.route": {
            type: "text",
            label: "Expeditionsroute",
            placeholder: "Norden via Wald",
            visibleIf: (data) => data["position.type"] === "expedition"
          },
          "job.type": {
            type: "select",
            label: "Job-Typ",
            options: FACTION_JOB_TYPES.map((type2) => ({ value: type2, label: type2 }))
          },
          "job.building": {
            type: "text",
            label: "Geb\xE4ude",
            placeholder: "Schmiede / Wachturm",
            visibleIf: (data) => Boolean(data["job.type"])
          },
          "job.progress": {
            type: "number-stepper",
            label: "Fortschritt %",
            min: 0,
            max: 100,
            default: 0,
            visibleIf: (data) => Boolean(data["job.type"])
          },
          notes: {
            type: "textarea",
            label: "Notizen",
            placeholder: "Besonderheiten, Loyalit\xE4t, Geheimnisse\u2026"
          }
        },
        default: []
      }
    ];
    factionSpec = {
      kind: "faction",
      title: "Fraktion erstellen",
      subtitle: "Neue Organisation f\xFCr deine Kampagne",
      schema: factionSchema,
      fields: fields4,
      storage: {
        format: "md-frontmatter",
        pathTemplate: "SaltMarcher/Factions/{name}.md",
        filenameFrom: "name",
        directory: "SaltMarcher/Factions",
        frontmatter: [
          "name",
          "motto",
          "headquarters",
          "territory",
          "influence_tags",
          "goal_tags",
          "culture_tags",
          "summary",
          "assets",
          "relationships",
          "resources",
          "faction_relationships",
          "members"
        ],
        bodyTemplate: (data) => factionToMarkdown(data)
      },
      ui: {
        submitLabel: "Fraktion speichern",
        cancelLabel: "Abbrechen"
      },
      browse: {
        metadata: [
          {
            id: "primaryInfluence",
            cls: "sm-cc-item__type",
            getValue: (entry) => {
              const tags = entry.influence_tags;
              if (!tags || tags.length === 0) return "Neutral";
              const first = tags[0];
              return typeof first === "string" ? first : first?.value || "Neutral";
            }
          },
          {
            id: "headquarters",
            cls: "sm-cc-item__cr",
            getValue: (entry) => entry.headquarters || "Unbekannter Sitz"
          },
          {
            id: "memberCount",
            cls: "sm-cc-item__meta",
            getValue: (entry) => {
              const list = Array.isArray(entry.members) ? entry.members : [];
              return `${list.length} Mitglieder`;
            }
          }
        ],
        filters: [
          { id: "influence_tags", field: "influence_tags", label: "Einfluss", type: "array" },
          { id: "goal_tags", field: "goal_tags", label: "Ziele", type: "array" },
          { id: "culture_tags", field: "culture_tags", label: "Kultur", type: "array" },
          { id: "headquarters", field: "headquarters", label: "Hauptquartier", type: "string" },
          { id: "territory", field: "territory", label: "Territorium", type: "string" }
        ],
        sorts: [
          { id: "name", label: "Name", field: "name" },
          { id: "primaryInfluence", label: "Einfluss", field: "influence_tags" },
          { id: "memberCount", label: "Mitgliederzahl", field: "members" }
        ]
      }
    };
  }
});

// src/workmodes/library/factions/index.ts
var init_factions = __esm({
  "src/workmodes/library/factions/index.ts"() {
    "use strict";
    init_create_spec8();
    init_serializer8();
  }
});

// src/workmodes/library/locations/constants.ts
var LOCATION_TYPES, OWNER_TYPES, OWNER_TYPE_LABELS;
var init_constants9 = __esm({
  "src/workmodes/library/locations/constants.ts"() {
    "use strict";
    LOCATION_TYPES = [
      "Stadt",
      "Dorf",
      "Weiler",
      "Geb\xE4ude",
      "Dungeon",
      "Camp",
      "Landmark",
      "Ruine",
      "Festung"
    ];
    OWNER_TYPES = [
      "none",
      "faction",
      "npc"
    ];
    OWNER_TYPE_LABELS = {
      none: "Kein Besitzer",
      faction: "Fraktion",
      npc: "NPC"
    };
  }
});

// src/workmodes/library/locations/types.ts
function getFeatureTypePrefix(type2) {
  switch (type2) {
    case "secret":
      return "G";
    case "trap":
    case "hazard":
      return "H";
    case "treasure":
      return "S";
    case "furniture":
    case "other":
      return "F";
  }
}
function getFeatureTypeLabel(type2) {
  switch (type2) {
    case "secret":
      return "Secret";
    case "trap":
      return "Trap";
    case "treasure":
      return "Treasure";
    case "hazard":
      return "Hazard";
    case "furniture":
      return "Furniture";
    case "other":
      return "Other";
  }
}
function getDefaultTokenColor(type2) {
  switch (type2) {
    case "player":
      return "#4a90e2";
    case "npc":
      return "#50c878";
    case "monster":
      return "#e74c3c";
    case "object":
      return "#f39c12";
  }
}
function isDungeonLocation(data) {
  return data.type === "Dungeon" && typeof data.grid_width === "number" && typeof data.grid_height === "number";
}
function isBuildingLocation(data) {
  return data.type === "Geb\xE4ude" && typeof data.building_production === "object" && data.building_production !== null;
}
var init_types3 = __esm({
  "src/workmodes/library/locations/types.ts"() {
    "use strict";
  }
});

// src/features/locations/building-production.ts
function calculateProductionRate(buildingType, condition, maintenanceOverdue) {
  const template = BUILDING_TEMPLATES[buildingType];
  if (!template) return 0;
  let rate = template.productionMultiplier;
  const conditionMultiplier = 0.5 + condition / 200;
  rate *= conditionMultiplier;
  const maintenancePenalty = Math.min(0.5, maintenanceOverdue * 0.05);
  rate *= 1 - maintenancePenalty;
  return Math.max(0.1, rate);
}
function calculateMaintenanceCost(buildingType) {
  const template = BUILDING_TEMPLATES[buildingType];
  return template?.maintenanceCost || {};
}
function getBuildingBonuses(buildingType) {
  const template = BUILDING_TEMPLATES[buildingType];
  return template?.bonuses || {};
}
function calculateRepairCosts(currentCondition, repairAmount) {
  const costMultiplier = repairAmount / 10;
  return {
    gold: Math.ceil(1 * costMultiplier),
    equipment: Math.ceil(0.5 * costMultiplier)
  };
}
function repairBuilding(production, goldSpent, equipmentSpent) {
  const repairAmount = (goldSpent + equipmentSpent * 0.5) * 10;
  const oldCondition = production.condition;
  production.condition = Math.min(100, production.condition + repairAmount);
  if (production.condition >= 90) {
    production.maintenanceOverdue = 0;
  }
  return production.condition - oldCondition;
}
var BUILDING_TEMPLATES;
var init_building_production = __esm({
  "src/features/locations/building-production.ts"() {
    "use strict";
    BUILDING_TEMPLATES = {
      // Military buildings
      barracks: {
        name: "Barracks",
        category: "military",
        description: "Training facility for military units",
        allowedJobs: ["training", "guard"],
        maxWorkers: 20,
        productionMultiplier: 1,
        maintenanceCost: { gold: 5, food: 10 },
        bonuses: { trainingSpeed: 1.2 }
      },
      armory: {
        name: "Armory",
        category: "military",
        description: "Storage and maintenance for military equipment",
        allowedJobs: ["crafting", "guard"],
        maxWorkers: 10,
        productionMultiplier: 1.1,
        maintenanceCost: { gold: 8, equipment: 5 },
        bonuses: { qualityBonus: 0.15 }
      },
      training_grounds: {
        name: "Training Grounds",
        category: "military",
        description: "Large open area for combat training and drills",
        allowedJobs: ["training", "patrol"],
        maxWorkers: 30,
        productionMultiplier: 1.2,
        maintenanceCost: { gold: 3, food: 15 },
        bonuses: { trainingSpeed: 1.5 }
      },
      // Economic buildings
      smithy: {
        name: "Smithy",
        category: "economic",
        description: "Workshop for metalworking and equipment crafting",
        allowedJobs: ["crafting"],
        maxWorkers: 5,
        productionMultiplier: 1.3,
        maintenanceCost: { gold: 10, equipment: 8 },
        bonuses: { qualityBonus: 0.25 }
      },
      workshop: {
        name: "Workshop",
        category: "economic",
        description: "General crafting facility for tools and goods",
        allowedJobs: ["crafting", "gathering"],
        maxWorkers: 8,
        productionMultiplier: 1,
        maintenanceCost: { gold: 5, equipment: 3 }
      },
      market: {
        name: "Market",
        category: "economic",
        description: "Trading hub for goods and resources",
        allowedJobs: ["gathering"],
        maxWorkers: 15,
        productionMultiplier: 1.2,
        maintenanceCost: { gold: 8 }
      },
      // Magical buildings
      mage_tower: {
        name: "Mage Tower",
        category: "magical",
        description: "Arcane research and spellcasting facility",
        allowedJobs: ["research", "crafting", "summoning"],
        maxWorkers: 6,
        productionMultiplier: 1.4,
        maintenanceCost: { gold: 15, magic: 10 },
        bonuses: { qualityBonus: 0.3, researchBonus: 0.4 }
      },
      shrine: {
        name: "Shrine",
        category: "magical",
        description: "Sacred place for divine magic and healing",
        allowedJobs: ["summoning", "research"],
        maxWorkers: 8,
        productionMultiplier: 1.2,
        maintenanceCost: { gold: 10, magic: 5 },
        bonuses: { researchBonus: 0.25 }
      },
      ritual_circle: {
        name: "Ritual Circle",
        category: "magical",
        description: "Outdoor ceremonial site for powerful rituals",
        allowedJobs: ["summoning", "research"],
        maxWorkers: 4,
        productionMultiplier: 1.5,
        maintenanceCost: { gold: 5, magic: 15 },
        bonuses: { qualityBonus: 0.2 }
      },
      // Research buildings
      library: {
        name: "Library",
        category: "research",
        description: "Repository of knowledge and study",
        allowedJobs: ["research"],
        maxWorkers: 12,
        productionMultiplier: 1.3,
        maintenanceCost: { gold: 12 },
        bonuses: { researchBonus: 0.5 }
      },
      laboratory: {
        name: "Laboratory",
        category: "research",
        description: "Scientific experimentation facility",
        allowedJobs: ["research", "crafting"],
        maxWorkers: 6,
        productionMultiplier: 1.4,
        maintenanceCost: { gold: 18, magic: 8 },
        bonuses: { researchBonus: 0.45, qualityBonus: 0.2 }
      },
      // Logistic buildings
      warehouse: {
        name: "Warehouse",
        category: "logistic",
        description: "Storage facility for resources and goods",
        allowedJobs: ["gathering", "guard"],
        maxWorkers: 10,
        productionMultiplier: 1,
        maintenanceCost: { gold: 3 }
      },
      stable: {
        name: "Stable",
        category: "logistic",
        description: "Housing for mounts and beasts of burden",
        allowedJobs: ["gathering", "training"],
        maxWorkers: 8,
        productionMultiplier: 1,
        maintenanceCost: { gold: 5, food: 20 }
      },
      granary: {
        name: "Granary",
        category: "logistic",
        description: "Food storage and preservation facility",
        allowedJobs: ["gathering", "guard"],
        maxWorkers: 6,
        productionMultiplier: 1.1,
        maintenanceCost: { gold: 4 }
      },
      // Residential buildings
      inn: {
        name: "Inn",
        category: "residential",
        description: "Lodging for travelers and workers",
        allowedJobs: ["gathering"],
        maxWorkers: 12,
        productionMultiplier: 1,
        maintenanceCost: { gold: 6, food: 15 }
      },
      palace: {
        name: "Palace",
        category: "residential",
        description: "Grand residence for leadership",
        allowedJobs: ["guard", "research"],
        maxWorkers: 25,
        productionMultiplier: 1.3,
        maintenanceCost: { gold: 30, food: 20 },
        bonuses: { researchBonus: 0.2 }
      }
    };
  }
});

// src/workmodes/library/locations/serializer.ts
function locationToMarkdown(data) {
  const lines = [];
  lines.push(`# ${data.name}`);
  lines.push("");
  lines.push("## Overview");
  lines.push(`- **Type:** ${data.type}`);
  if (data.parent) {
    lines.push(`- **Parent Location:** ${data.parent}`);
  }
  if (data.owner_type && data.owner_type !== "none") {
    const ownerLabel = OWNER_TYPE_LABELS[data.owner_type];
    const ownerName = data.owner_name?.trim() || "\u2014";
    lines.push(`- **Owner:** ${ownerLabel} (${ownerName})`);
  }
  if (data.region) {
    lines.push(`- **Region:** ${data.region}`);
  }
  if (data.coordinates) {
    lines.push(`- **Coordinates:** ${data.coordinates}`);
  }
  if (isDungeonLocation(data)) {
    lines.push(`- **Grid Size:** ${data.grid_width}\xD7${data.grid_height}`);
    if (data.cell_size && data.cell_size !== 40) {
      lines.push(`- **Cell Size:** ${data.cell_size}px`);
    }
  }
  if (data.description) {
    lines.push("");
    lines.push("## Description");
    lines.push(data.description);
  }
  if (isBuildingLocation(data)) {
    lines.push("");
    lines.push("## Building Production");
    const production = data.building_production;
    const template = BUILDING_TEMPLATES[production.buildingType];
    if (template) {
      lines.push(`- **Building Type:** ${template.name}`);
      lines.push(`- **Category:** ${template.category}`);
      lines.push(`- **Condition:** ${production.condition}%`);
      lines.push(`- **Maintenance Overdue:** ${production.maintenanceOverdue} days`);
      lines.push(`- **Workers:** ${production.currentWorkers}/${template.maxWorkers}`);
      if (production.activeJobs.length > 0) {
        lines.push("");
        lines.push("**Active Jobs:**");
        for (const job of production.activeJobs) {
          lines.push(`- ${job.workerName}: ${job.jobType} (${job.progress}%)`);
        }
      }
      const hasProduction = Object.values(production.periodProduction).some((v) => v && v > 0);
      if (hasProduction) {
        lines.push("");
        lines.push("**Period Production:**");
        if (production.periodProduction.gold) lines.push(`- Gold: ${production.periodProduction.gold}`);
        if (production.periodProduction.food) lines.push(`- Food: ${production.periodProduction.food}`);
        if (production.periodProduction.equipment) lines.push(`- Equipment: ${production.periodProduction.equipment}`);
        if (production.periodProduction.magic) lines.push(`- Magic: ${production.periodProduction.magic}`);
        if (production.periodProduction.influence) lines.push(`- Influence: ${production.periodProduction.influence}`);
      }
    }
  }
  if (isDungeonLocation(data) && data.rooms && data.rooms.length > 0) {
    lines.push("");
    lines.push("## Rooms");
    lines.push("");
    for (const room of data.rooms) {
      serializeRoom(room, lines);
    }
  }
  if (isDungeonLocation(data) && data.tokens && data.tokens.length > 0) {
    lines.push("");
    lines.push("## Tokens");
    lines.push("");
    for (const token of data.tokens) {
      serializeToken(token, lines);
    }
  }
  if (data.notes) {
    lines.push("");
    lines.push("## Notes");
    lines.push(data.notes);
  }
  return lines.join("\n");
}
function serializeRoom(room, lines) {
  lines.push(`### Room ${room.id}: ${room.name}`);
  lines.push("");
  const { x, y, width, height } = room.grid_bounds;
  lines.push(`**Bounds:** (${x},${y}) \u2192 (${x + width},${y + height})`);
  lines.push("");
  if (room.description) {
    lines.push("**Description:**");
    lines.push(room.description);
    lines.push("");
  }
  if (room.doors && room.doors.length > 0) {
    lines.push("**Doors:**");
    for (const door of room.doors) {
      serializeDoor(door, lines);
    }
    lines.push("");
  }
  if (room.features && room.features.length > 0) {
    lines.push("**Features:**");
    for (const feature of room.features) {
      serializeFeature(feature, lines);
    }
    lines.push("");
  }
}
function serializeDoor(door, lines) {
  let line = `- **${door.id}** (${door.position.x},${door.position.y})`;
  if (door.locked) {
    line += " \u{1F512}";
  }
  if (door.leads_to) {
    line += ` \u2192 ${door.leads_to}`;
  }
  if (door.description) {
    line += `: ${door.description}`;
  }
  lines.push(line);
}
function serializeFeature(feature, lines) {
  const prefix = getFeatureTypePrefix(feature.type);
  const label = getFeatureTypeLabel(feature.type);
  const line = `- **${prefix}${feature.id}** (${label}, ${feature.position.x},${feature.position.y}): ${feature.description}`;
  lines.push(line);
}
function serializeToken(token, lines) {
  let line = `- **${token.label}** (${token.type}, ${token.position.x},${token.position.y})`;
  if (token.color) {
    line += ` [${token.color}]`;
  }
  if (token.size && token.size !== 1) {
    line += ` size=${token.size}`;
  }
  lines.push(line);
}
var init_serializer9 = __esm({
  "src/workmodes/library/locations/serializer.ts"() {
    "use strict";
    init_constants9();
    init_types3();
    init_building_production();
  }
});

// src/workmodes/library/locations/create-spec.ts
var locationSchema, fields5, locationSpec;
var init_create_spec9 = __esm({
  "src/workmodes/library/locations/create-spec.ts"() {
    "use strict";
    init_constants9();
    init_serializer9();
    init_building_production();
    locationSchema = {
      parse: (data) => data,
      safeParse: (data) => {
        try {
          if (!data || typeof data !== "object") {
            throw new Error("Location data must be an object");
          }
          const location = data;
          if (typeof location.name !== "string" || location.name.trim().length === 0) {
            throw new Error("Name is required");
          }
          if (typeof location.type !== "string" || location.type.trim().length === 0) {
            throw new Error("Type is required");
          }
          return { success: true, data: location };
        } catch (error) {
          return { success: false, error: error instanceof Error ? error : new Error(String(error)) };
        }
      }
    };
    fields5 = [
      {
        id: "name",
        label: "Name",
        type: "text",
        required: true,
        placeholder: "Die Taverne zum Goldenen Drachen",
        description: "Name des Ortes"
      },
      {
        id: "type",
        label: "Typ",
        type: "select",
        required: true,
        options: LOCATION_TYPES.map((type2) => ({ value: type2, label: type2 })),
        default: "Geb\xE4ude",
        description: "Art des Ortes"
      },
      {
        id: "description",
        label: "Beschreibung",
        type: "textarea",
        placeholder: "Eine gem\xFCtliche Taverne im Herzen der Stadt...",
        description: "Ausf\xFChrliche Beschreibung des Ortes"
      },
      {
        id: "parent",
        label: "\xDCbergeordneter Ort",
        type: "text",
        placeholder: "Marktplatz-Viertel",
        description: "Name des \xFCbergeordneten Ortes (f\xFCr Hierarchie)"
      },
      {
        id: "owner_type",
        label: "Besitzertyp",
        type: "select",
        options: OWNER_TYPES.map((type2) => ({
          value: type2,
          label: OWNER_TYPE_LABELS[type2]
        })),
        default: "none",
        description: "Wer besitzt oder kontrolliert diesen Ort?"
      },
      {
        id: "owner_name",
        label: "Besitzer Name",
        type: "text",
        placeholder: "Die Schildbr\xFCder",
        description: "Name der Fraktion oder des NPCs (falls zutreffend)"
      },
      {
        id: "region",
        label: "Region",
        type: "text",
        placeholder: "Salzmarsch",
        description: "Optionale Regionszuordnung"
      },
      {
        id: "coordinates",
        label: "Koordinaten",
        type: "text",
        placeholder: "12,34",
        description: "Optionale Hex-Koordinaten (Format: X,Y)"
      },
      {
        id: "notes",
        label: "Notizen",
        type: "textarea",
        placeholder: "Wichtige Details, Geheimnisse, Hooks...",
        description: "Zus\xE4tzliche Notizen und Informationen"
      },
      // Dungeon-specific fields (only visible when type === "Dungeon")
      {
        id: "grid_width",
        label: "Rasterbreite",
        type: "number-stepper",
        min: 5,
        max: 100,
        step: 5,
        default: 30,
        placeholder: "30",
        description: "Breite des Dungeon-Rasters (Anzahl Zellen)",
        visibleIf: (values) => values.type === "Dungeon",
        dependsOn: ["type"]
      },
      {
        id: "grid_height",
        label: "Rasterh\xF6he",
        type: "number-stepper",
        min: 5,
        max: 100,
        step: 5,
        default: 20,
        placeholder: "20",
        description: "H\xF6he des Dungeon-Rasters (Anzahl Zellen)",
        visibleIf: (values) => values.type === "Dungeon",
        dependsOn: ["type"]
      },
      {
        id: "cell_size",
        label: "Zellgr\xF6\xDFe",
        type: "number-stepper",
        min: 20,
        max: 80,
        step: 5,
        default: 40,
        placeholder: "40",
        description: "Gr\xF6\xDFe einer Rasterzelle in Pixeln (Standard: 40)",
        visibleIf: (values) => values.type === "Dungeon",
        dependsOn: ["type"]
      },
      // Building-specific fields (only visible when type === "Gebäude")
      {
        id: "building_production.buildingType",
        label: "Geb\xE4udetyp",
        type: "select",
        required: false,
        options: Object.keys(BUILDING_TEMPLATES).map((key) => ({
          value: key,
          label: BUILDING_TEMPLATES[key].name
        })),
        placeholder: "W\xE4hle einen Geb\xE4udetyp",
        description: "Art des Geb\xE4udes (bestimmt erlaubte Jobs und Produktion)",
        visibleIf: (values) => values.type === "Geb\xE4ude",
        dependsOn: ["type"]
      },
      {
        id: "building_production.condition",
        label: "Zustand",
        type: "number-stepper",
        min: 0,
        max: 100,
        step: 1,
        default: 100,
        placeholder: "100",
        description: "Geb\xE4udezustand (0-100%, beeinflusst Produktionsrate)",
        visibleIf: (values) => values.type === "Geb\xE4ude" && !!values.building_production?.buildingType,
        dependsOn: ["type", "building_production.buildingType"]
      },
      {
        id: "building_production.maintenanceOverdue",
        label: "Wartung \xFCberf\xE4llig",
        type: "number-stepper",
        min: 0,
        max: 365,
        step: 1,
        default: 0,
        placeholder: "0",
        description: "Tage seit f\xE4lliger Wartung (reduziert Produktionsrate um -5%/Tag, max -50%)",
        visibleIf: (values) => values.type === "Geb\xE4ude" && !!values.building_production?.buildingType,
        dependsOn: ["type", "building_production.buildingType"]
      },
      {
        id: "building_production.currentWorkers",
        label: "Aktuelle Arbeiter",
        type: "number-stepper",
        min: 0,
        max: 100,
        step: 1,
        default: 0,
        placeholder: "0",
        description: "Anzahl der zugewiesenen Arbeiter (max. durch Geb\xE4udetyp begrenzt)",
        visibleIf: (values) => values.type === "Geb\xE4ude" && !!values.building_production?.buildingType,
        dependsOn: ["type", "building_production.buildingType"]
      }
    ];
    locationSpec = {
      kind: "location",
      title: "Ort erstellen",
      subtitle: "Neuer Ort f\xFCr deine Kampagne",
      schema: locationSchema,
      fields: fields5,
      storage: {
        format: "md-frontmatter",
        pathTemplate: "SaltMarcher/Locations/{name}.md",
        filenameFrom: "name",
        directory: "SaltMarcher/Locations",
        frontmatter: [
          "name",
          "type",
          "parent",
          "owner_type",
          "owner_name",
          "region",
          "coordinates",
          "description",
          "notes",
          "grid_width",
          "grid_height",
          "cell_size",
          "rooms",
          "tokens",
          "building_production"
        ],
        bodyTemplate: (data) => locationToMarkdown(data)
      },
      ui: {
        submitLabel: "Ort speichern",
        cancelLabel: "Abbrechen"
      },
      browse: {
        metadata: [
          {
            id: "type",
            cls: "sm-cc-item__type",
            getValue: (entry) => entry.type || "\u2014"
          },
          {
            id: "owner",
            cls: "sm-cc-item__cr",
            getValue: (entry) => {
              if (!entry.owner_type || entry.owner_type === "none") return "Kein Besitzer";
              const ownerName = entry.owner_name?.trim() || "\u2014";
              const ownerLabel = OWNER_TYPE_LABELS[entry.owner_type];
              return `${ownerLabel}: ${ownerName}`;
            }
          },
          {
            id: "parent",
            cls: "sm-cc-item__meta",
            getValue: (entry) => {
              if (!entry.parent) return "Top-Level";
              return `In: ${entry.parent}`;
            }
          },
          {
            id: "grid_size",
            cls: "sm-cc-item__meta sm-cc-item__grid-badge",
            getValue: (entry) => {
              if (!entry.grid_size) return null;
              return `\u2B1A ${entry.grid_size}`;
            }
          },
          {
            id: "building_status",
            cls: "sm-cc-item__meta sm-cc-item__building-status",
            getValue: (entry) => {
              if (entry.type !== "Geb\xE4ude" || !entry.building_production) return null;
              const prod = entry.building_production;
              const template = BUILDING_TEMPLATES[prod.buildingType];
              if (!template) return null;
              const conditionIcon = prod.condition >= 80 ? "\u{1F7E2}" : prod.condition >= 40 ? "\u{1F7E1}" : "\u{1F534}";
              return `${conditionIcon} ${template.name} (${prod.condition}%) \u2022 ${prod.currentWorkers}/${template.maxWorkers} workers`;
            }
          }
        ],
        filters: [
          { id: "type", field: "type", label: "Typ", type: "string" },
          { id: "owner_type", field: "owner_type", label: "Besitzertyp", type: "string" },
          { id: "owner_name", field: "owner_name", label: "Besitzer", type: "string" },
          { id: "region", field: "region", label: "Region", type: "string" },
          { id: "parent", field: "parent", label: "\xDCbergeordneter Ort", type: "string" }
        ],
        sorts: [
          { id: "name", label: "Name", field: "name" },
          { id: "type", label: "Typ", field: "type" },
          { id: "owner", label: "Besitzer", field: "owner_name" }
        ]
      }
    };
  }
});

// src/workmodes/library/locations/tree-builder.ts
function buildLocationTree(locations) {
  const locationMap = /* @__PURE__ */ new Map();
  for (const loc of locations) {
    locationMap.set(loc.name, loc);
  }
  function isInCycle(locName) {
    const visited = /* @__PURE__ */ new Set();
    let current = locName;
    while (current) {
      if (visited.has(current)) {
        return true;
      }
      visited.add(current);
      const loc = locationMap.get(current);
      if (!loc || !loc.parent || loc.parent.trim() === "") {
        return false;
      }
      current = loc.parent;
    }
    return false;
  }
  const childrenMap = /* @__PURE__ */ new Map();
  const roots = [];
  for (const loc of locations) {
    if (!loc.parent || loc.parent.trim() === "") {
      roots.push(loc);
    } else if (!locationMap.has(loc.parent)) {
      roots.push(loc);
    } else if (isInCycle(loc.name)) {
      roots.push(loc);
    } else {
      if (!childrenMap.has(loc.parent)) {
        childrenMap.set(loc.parent, []);
      }
      childrenMap.get(loc.parent).push(loc);
    }
  }
  function buildNode(loc, depth, visited) {
    if (visited.has(loc.name)) {
      return null;
    }
    visited.add(loc.name);
    const children = [];
    const childLocations = childrenMap.get(loc.name) || [];
    for (const child of childLocations) {
      const childNode = buildNode(child, depth + 1, new Set(visited));
      if (childNode !== null) {
        children.push(childNode);
      }
    }
    return {
      location: loc,
      children,
      depth
    };
  }
  const treeNodes = [];
  for (const root of roots) {
    const node = buildNode(root, 0, /* @__PURE__ */ new Set());
    if (node !== null) {
      treeNodes.push(node);
    }
  }
  return treeNodes;
}
var init_tree_builder = __esm({
  "src/workmodes/library/locations/tree-builder.ts"() {
    "use strict";
  }
});

// src/workmodes/library/locations/tree-view.ts
var LOCATION_TYPE_ICONS2, LocationTreeView;
var init_tree_view = __esm({
  "src/workmodes/library/locations/tree-view.ts"() {
    "use strict";
    LOCATION_TYPE_ICONS2 = {
      "Stadt": "\u{1F3D9}\uFE0F",
      "Dorf": "\u{1F3D8}\uFE0F",
      "Weiler": "\u{1F3E1}",
      "Geb\xE4ude": "\u{1F3E2}",
      "Dungeon": "\u2694\uFE0F",
      "Camp": "\u26FA",
      "Landmark": "\u{1F5FF}",
      "Ruine": "\u{1F3DA}\uFE0F",
      "Festung": "\u{1F3F0}"
    };
    LocationTreeView = class {
      constructor(containerEl, options = {}) {
        this.currentNodes = [];
        this.containerEl = containerEl;
        this.expandedNodes = options.initialExpanded || /* @__PURE__ */ new Set();
        this.options = options;
      }
      /**
       * Renders the tree view with the given nodes.
       */
      render(nodes) {
        this.currentNodes = nodes;
        this.containerEl.empty();
        if (nodes.length === 0) {
          this.containerEl.createDiv({ cls: "sm-tree-empty", text: "Keine Orte vorhanden" });
          return;
        }
        const treeContainer = this.containerEl.createDiv({ cls: this.options.containerClass || "sm-tree-view" });
        for (const node of nodes) {
          this.renderNode(treeContainer, node);
        }
      }
      /**
       * Recursively renders a tree node and its children.
       */
      renderNode(parentEl, node) {
        const nodeEl = parentEl.createDiv({ cls: "sm-tree-node" });
        nodeEl.style.paddingLeft = `${node.depth * 20}px`;
        const contentEl = nodeEl.createDiv({ cls: "sm-tree-node-content" });
        if (node.children.length > 0) {
          const toggleBtn = contentEl.createSpan({ cls: "sm-tree-toggle" });
          const isExpanded = this.expandedNodes.has(node.location.name);
          toggleBtn.setText(isExpanded ? "\u25BC" : "\u25B6");
          toggleBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            this.toggleNode(node.location.name);
          });
        } else {
          contentEl.createSpan({ cls: "sm-tree-toggle sm-tree-toggle-empty", text: " " });
        }
        const icon = LOCATION_TYPE_ICONS2[node.location.type] || "\u{1F4CD}";
        contentEl.createSpan({ cls: "sm-tree-icon", text: icon });
        const nameEl = contentEl.createSpan({ cls: "sm-tree-name", text: node.location.name });
        nameEl.addEventListener("click", () => {
          if (this.options.onLocationClick) {
            this.options.onLocationClick(node.location.name);
          }
        });
        if (node.location.owner_type && node.location.owner_type !== "none" && node.location.owner_name) {
          const ownerBadge = contentEl.createSpan({ cls: "sm-tree-badge" });
          ownerBadge.setText(`${node.location.owner_name}`);
        }
        if (this.expandedNodes.has(node.location.name)) {
          for (const child of node.children) {
            this.renderNode(parentEl, child);
          }
        }
      }
      /**
       * Toggles a node's expanded state and re-renders.
       */
      toggleNode(name) {
        if (this.expandedNodes.has(name)) {
          this.expandedNodes.delete(name);
        } else {
          this.expandedNodes.add(name);
        }
        this.render(this.currentNodes);
      }
      /**
       * Expands all nodes in the tree.
       */
      expandAll(nodes) {
        const collectNames = (ns) => {
          for (const node of ns) {
            this.expandedNodes.add(node.location.name);
            collectNames(node.children);
          }
        };
        collectNames(nodes);
      }
      /**
       * Collapses all nodes in the tree.
       */
      collapseAll() {
        this.expandedNodes.clear();
      }
      /**
       * Gets the current expanded state.
       */
      getExpandedNodes() {
        return new Set(this.expandedNodes);
      }
    };
  }
});

// src/workmodes/library/locations/breadcrumb.ts
var init_breadcrumb = __esm({
  "src/workmodes/library/locations/breadcrumb.ts"() {
    "use strict";
    init_tree_builder();
  }
});

// src/workmodes/library/locations/index.ts
var init_locations = __esm({
  "src/workmodes/library/locations/index.ts"() {
    "use strict";
    init_create_spec9();
    init_types3();
    init_serializer9();
    init_tree_builder();
    init_tree_view();
    init_breadcrumb();
  }
});

// src/workmodes/library/playlists/types.ts
var init_types4 = __esm({
  "src/workmodes/library/playlists/types.ts"() {
    "use strict";
  }
});

// src/workmodes/library/playlists/constants.ts
var PLAYLIST_TYPES, TERRAIN_TAGS, WEATHER_TAGS, TIME_OF_DAY_TAGS, FACTION_TAGS, SITUATION_TAGS, DEFAULT_CROSSFADE_DURATION, DEFAULT_VOLUME;
var init_constants10 = __esm({
  "src/workmodes/library/playlists/constants.ts"() {
    "use strict";
    PLAYLIST_TYPES = [
      { value: "ambience", label: "Ambience" },
      { value: "music", label: "Music" }
    ];
    TERRAIN_TAGS = [
      "Forest",
      "Mountain",
      "Desert",
      "Swamp",
      "Coastal",
      "Ocean",
      "Arctic",
      "Cave",
      "Underground",
      "Urban",
      "Ruins",
      "Plains",
      "Hills",
      "Jungle",
      "Volcanic"
    ];
    WEATHER_TAGS = [
      "Clear",
      "Cloudy",
      "Rain",
      "Storm",
      "Snow",
      "Fog",
      "Wind",
      "Hot",
      "Cold"
    ];
    TIME_OF_DAY_TAGS = [
      "Dawn",
      "Morning",
      "Noon",
      "Afternoon",
      "Dusk",
      "Evening",
      "Night",
      "Midnight"
    ];
    FACTION_TAGS = [
      "Friendly",
      "Neutral",
      "Hostile",
      "Undead",
      "Fey",
      "Fiend",
      "Celestial",
      "Elemental",
      "Dragon",
      "Giant",
      "Humanoid",
      "Beast"
    ];
    SITUATION_TAGS = [
      "Exploration",
      "Combat",
      "Social",
      "Stealth",
      "Chase",
      "Rest",
      "Tension",
      "Mystery",
      "Horror",
      "Celebration",
      "Travel",
      "Dungeon",
      "Boss",
      "Victory",
      "Defeat"
    ];
    DEFAULT_CROSSFADE_DURATION = 2;
    DEFAULT_VOLUME = 0.7;
  }
});

// src/workmodes/library/playlists/serializer.ts
function playlistToMarkdown(data) {
  const lines = [];
  lines.push(`# ${data.display_name || data.name || "Unnamed Playlist"}`);
  lines.push("");
  if (data.description) {
    lines.push(data.description);
    lines.push("");
  }
  lines.push(`**Type:** ${data.type}`);
  lines.push(`**Tracks:** ${data.tracks?.length || 0}`);
  lines.push("");
  const hasTags = data.terrain_tags && data.terrain_tags.length > 0 || data.weather_tags && data.weather_tags.length > 0 || data.time_of_day_tags && data.time_of_day_tags.length > 0 || data.faction_tags && data.faction_tags.length > 0 || data.situation_tags && data.situation_tags.length > 0;
  if (hasTags) {
    lines.push("## Tags");
    lines.push("");
    if (data.terrain_tags && data.terrain_tags.length > 0) {
      lines.push(`**Terrain:** ${data.terrain_tags.map((t) => t.value).join(", ")}`);
    }
    if (data.weather_tags && data.weather_tags.length > 0) {
      lines.push(`**Weather:** ${data.weather_tags.map((t) => t.value).join(", ")}`);
    }
    if (data.time_of_day_tags && data.time_of_day_tags.length > 0) {
      lines.push(`**Time of Day:** ${data.time_of_day_tags.map((t) => t.value).join(", ")}`);
    }
    if (data.faction_tags && data.faction_tags.length > 0) {
      lines.push(`**Faction:** ${data.faction_tags.map((t) => t.value).join(", ")}`);
    }
    if (data.situation_tags && data.situation_tags.length > 0) {
      lines.push(`**Situation:** ${data.situation_tags.map((t) => t.value).join(", ")}`);
    }
    lines.push("");
  }
  lines.push("## Playback");
  lines.push("");
  lines.push(`**Shuffle:** ${data.shuffle ? "Yes" : "No"}`);
  lines.push(`**Loop:** ${data.loop ? "Yes" : "No"}`);
  if (data.crossfade_duration !== void 0) {
    lines.push(`**Crossfade:** ${data.crossfade_duration}s`);
  }
  if (data.default_volume !== void 0) {
    lines.push(`**Volume:** ${Math.round(data.default_volume * 100)}%`);
  }
  lines.push("");
  if (data.tracks && data.tracks.length > 0) {
    lines.push("## Tracks");
    lines.push("");
    data.tracks.forEach((track, index) => {
      lines.push(`${index + 1}. **${track.name}**`);
      lines.push(`   - Source: \`${track.source}\``);
      if (track.duration) {
        const minutes = Math.floor(track.duration / 60);
        const seconds = Math.round(track.duration % 60);
        lines.push(`   - Duration: ${minutes}:${seconds.toString().padStart(2, "0")}`);
      }
      if (track.volume !== void 0) {
        lines.push(`   - Volume: ${Math.round(track.volume * 100)}%`);
      }
      lines.push("");
    });
  }
  return lines.join("\n");
}
var init_serializer10 = __esm({
  "src/workmodes/library/playlists/serializer.ts"() {
    "use strict";
  }
});

// src/workmodes/library/playlists/create-spec.ts
var playlistSchema, fields6, playlistSpec;
var init_create_spec10 = __esm({
  "src/workmodes/library/playlists/create-spec.ts"() {
    "use strict";
    init_serializer10();
    init_constants10();
    playlistSchema = {
      parse: (data) => data,
      safeParse: (data) => {
        try {
          const playlist = data;
          if (!playlist.name || typeof playlist.name !== "string" || playlist.name.trim().length === 0) {
            return {
              success: false,
              error: new Error("Name is required")
            };
          }
          if (!playlist.type || !["ambience", "music"].includes(playlist.type)) {
            return {
              success: false,
              error: new Error("Type must be 'ambience' or 'music'")
            };
          }
          if (!Array.isArray(playlist.tracks)) {
            return {
              success: false,
              error: new Error("Tracks must be an array")
            };
          }
          if (playlist.default_volume !== void 0) {
            if (typeof playlist.default_volume !== "number" || playlist.default_volume < 0 || playlist.default_volume > 1) {
              return {
                success: false,
                error: new Error("Default volume must be between 0.0 and 1.0")
              };
            }
          }
          if (playlist.crossfade_duration !== void 0) {
            if (typeof playlist.crossfade_duration !== "number" || playlist.crossfade_duration < 0) {
              return {
                success: false,
                error: new Error("Crossfade duration must be non-negative")
              };
            }
          }
          return { success: true, data: playlist };
        } catch (error) {
          return { success: false, error };
        }
      }
    };
    fields6 = [
      {
        id: "name",
        label: "Name",
        type: "text",
        required: true,
        placeholder: "Forest Ambience",
        description: "Internal name for the playlist (used for file path)"
      },
      {
        id: "display_name",
        label: "Display Name",
        type: "text",
        placeholder: "Mystical Forest Sounds",
        description: "Human-readable name shown in UI (defaults to name if not set)"
      },
      {
        id: "type",
        label: "Type",
        type: "select",
        required: true,
        options: PLAYLIST_TYPES.map((t) => ({ value: t.value, label: t.label })),
        default: "ambience",
        description: "Playlist type: ambience (background sounds) or music (tracks with melody)"
      },
      {
        id: "description",
        label: "Description",
        type: "textarea",
        placeholder: "A collection of atmospheric forest sounds...",
        description: "Optional description of the playlist's mood and content"
      },
      // Tag fields for automatic selection
      {
        id: "terrain_tags",
        label: "Terrain Tags",
        type: "tokens",
        config: {
          fields: [
            {
              id: "value",
              type: "select",
              displayInChip: true,
              editable: true,
              suggestions: TERRAIN_TAGS.map((tag) => ({ key: tag, label: tag })),
              placeholder: "Terrain ausw\xE4hlen..."
            }
          ],
          primaryField: "value"
        },
        default: [],
        description: "Terrain types this playlist matches (Forest, Mountain, etc.)"
      },
      {
        id: "weather_tags",
        label: "Weather Tags",
        type: "tokens",
        config: {
          fields: [
            {
              id: "value",
              type: "select",
              displayInChip: true,
              editable: true,
              suggestions: WEATHER_TAGS.map((tag) => ({ key: tag, label: tag })),
              placeholder: "Weather ausw\xE4hlen..."
            }
          ],
          primaryField: "value"
        },
        default: [],
        description: "Weather conditions this playlist matches (Clear, Rain, Storm, etc.)"
      },
      {
        id: "time_of_day_tags",
        label: "Time of Day Tags",
        type: "tokens",
        config: {
          fields: [
            {
              id: "value",
              type: "select",
              displayInChip: true,
              editable: true,
              suggestions: TIME_OF_DAY_TAGS.map((tag) => ({ key: tag, label: tag })),
              placeholder: "Time ausw\xE4hlen..."
            }
          ],
          primaryField: "value"
        },
        default: [],
        description: "Time of day this playlist matches (Dawn, Night, etc.)"
      },
      {
        id: "faction_tags",
        label: "Faction Tags",
        type: "tokens",
        config: {
          fields: [
            {
              id: "value",
              type: "select",
              displayInChip: true,
              editable: true,
              suggestions: FACTION_TAGS.map((tag) => ({ key: tag, label: tag })),
              placeholder: "Faction ausw\xE4hlen..."
            }
          ],
          primaryField: "value"
        },
        default: [],
        description: "Faction types this playlist matches (Friendly, Hostile, Undead, etc.)"
      },
      {
        id: "situation_tags",
        label: "Situation Tags",
        type: "tokens",
        config: {
          fields: [
            {
              id: "value",
              type: "select",
              displayInChip: true,
              editable: true,
              suggestions: SITUATION_TAGS.map((tag) => ({ key: tag, label: tag })),
              placeholder: "Situation ausw\xE4hlen..."
            }
          ],
          primaryField: "value"
        },
        default: [],
        description: "Situations this playlist matches (Combat, Exploration, Stealth, etc.)"
      },
      // Playback settings
      {
        id: "shuffle",
        label: "Shuffle",
        type: "checkbox",
        default: false,
        description: "Randomize track order during playback"
      },
      {
        id: "loop",
        label: "Loop",
        type: "checkbox",
        default: true,
        description: "Restart playlist after last track finishes"
      },
      {
        id: "crossfade_duration",
        label: "Crossfade Duration (seconds)",
        type: "number-stepper",
        min: 0,
        max: 10,
        step: 0.5,
        default: DEFAULT_CROSSFADE_DURATION,
        description: "Seconds to fade between tracks (0 = no crossfade)"
      },
      {
        id: "default_volume",
        label: "Default Volume",
        type: "number-stepper",
        min: 0,
        max: 1,
        step: 0.05,
        default: DEFAULT_VOLUME,
        description: "Default volume level (0.0 = muted, 1.0 = full volume)"
      },
      // Tracks list
      {
        id: "tracks",
        label: "Tracks",
        type: "list",
        config: {
          fields: [
            {
              id: "name",
              label: "Track Name",
              type: "text",
              required: true,
              placeholder: "Wind Through Trees"
            },
            {
              id: "source",
              label: "Source Path",
              type: "text",
              required: true,
              placeholder: "Audio/forest_ambience.mp3",
              description: "File path relative to vault root or external URL"
            },
            {
              id: "duration",
              label: "Duration (seconds)",
              type: "number-stepper",
              min: 0,
              step: 1,
              placeholder: "180",
              description: "Track length in seconds (optional, for display)"
            },
            {
              id: "volume",
              label: "Track Volume",
              type: "number-stepper",
              min: 0,
              max: 1,
              step: 0.05,
              placeholder: "1.0",
              description: "Volume multiplier for this track (0.0 - 1.0)"
            }
          ],
          itemLabel: (item) => item.name || "Unnamed Track"
        },
        default: [],
        description: "Audio tracks in this playlist"
      }
    ];
    playlistSpec = {
      kind: "playlist",
      title: "Playlist erstellen",
      subtitle: "Neue Audio-Playlist f\xFCr Session Runner",
      schema: playlistSchema,
      fields: fields6,
      storage: {
        format: "md-frontmatter",
        pathTemplate: "SaltMarcher/Playlists/{name}.md",
        filenameFrom: "name",
        directory: "SaltMarcher/Playlists",
        frontmatter: [
          "name",
          "display_name",
          "type",
          "description",
          "terrain_tags",
          "weather_tags",
          "time_of_day_tags",
          "faction_tags",
          "situation_tags",
          "shuffle",
          "loop",
          "crossfade_duration",
          "default_volume",
          "tracks"
        ],
        bodyTemplate: (data) => playlistToMarkdown(data)
      },
      ui: {
        submitLabel: "Playlist erstellen",
        cancelLabel: "Abbrechen",
        enableNavigation: false
      },
      browse: {
        metadata: [
          {
            id: "type",
            cls: "sm-cc-item__type",
            getValue: (entry) => entry.type || "Unknown"
          },
          {
            id: "track_count",
            cls: "sm-cc-item__cr",
            getValue: (entry) => `${entry.track_count || 0} tracks`
          }
        ],
        filters: [
          { id: "type", field: "type", label: "Type", type: "string" },
          { id: "terrain_tags", field: "terrain_tags", label: "Terrain", type: "array" },
          { id: "weather_tags", field: "weather_tags", label: "Weather", type: "array" },
          { id: "time_of_day_tags", field: "time_of_day_tags", label: "Time", type: "array" },
          { id: "faction_tags", field: "faction_tags", label: "Faction", type: "array" },
          { id: "situation_tags", field: "situation_tags", label: "Situation", type: "array" }
        ],
        sorts: [
          { id: "name", label: "Name", field: "name" },
          { id: "type", label: "Type", field: "type" },
          { id: "track_count", label: "Track Count", field: "track_count" }
        ],
        search: ["name", "display_name", "description", "type"]
      },
      loader: {}
    };
  }
});

// src/workmodes/library/playlists/index.ts
var init_playlists = __esm({
  "src/workmodes/library/playlists/index.ts"() {
    "use strict";
    init_types4();
    init_constants10();
    init_serializer10();
    init_create_spec10();
  }
});

// src/workmodes/library/encounter-tables/types.ts
var init_types5 = __esm({
  "src/workmodes/library/encounter-tables/types.ts"() {
    "use strict";
  }
});

// src/workmodes/library/encounter-tables/constants.ts
var TERRAIN_TAGS2, WEATHER_TAGS2, TIME_OF_DAY_TAGS2, FACTION_TAGS2, SITUATION_TAGS2, DEFAULT_ENTRY_WEIGHT;
var init_constants11 = __esm({
  "src/workmodes/library/encounter-tables/constants.ts"() {
    "use strict";
    TERRAIN_TAGS2 = [
      "Forest",
      "Mountain",
      "Desert",
      "Swamp",
      "Coastal",
      "Ocean",
      "Arctic",
      "Cave",
      "Underground",
      "Urban",
      "Ruins",
      "Plains",
      "Hills",
      "Jungle",
      "Volcanic"
    ];
    WEATHER_TAGS2 = [
      "Clear",
      "Cloudy",
      "Rain",
      "Storm",
      "Snow",
      "Fog",
      "Wind",
      "Hot",
      "Cold"
    ];
    TIME_OF_DAY_TAGS2 = [
      "Dawn",
      "Morning",
      "Noon",
      "Afternoon",
      "Dusk",
      "Evening",
      "Night",
      "Midnight"
    ];
    FACTION_TAGS2 = [
      "Friendly",
      "Neutral",
      "Hostile",
      "Undead",
      "Fey",
      "Fiend",
      "Celestial",
      "Elemental",
      "Dragon",
      "Giant",
      "Humanoid",
      "Beast"
    ];
    SITUATION_TAGS2 = [
      "Exploration",
      "Combat",
      "Social",
      "Stealth",
      "Chase",
      "Rest",
      "Tension",
      "Mystery",
      "Horror",
      "Celebration",
      "Travel",
      "Dungeon",
      "Boss",
      "Victory",
      "Defeat"
    ];
    DEFAULT_ENTRY_WEIGHT = 1;
  }
});

// src/workmodes/library/encounter-tables/serializer.ts
function encounterTableToMarkdown(data) {
  const lines = [];
  lines.push(`# ${data.display_name || data.name}`);
  lines.push("");
  if (data.description) {
    lines.push(data.description);
    lines.push("");
  }
  if (data.crRange) {
    const { min, max } = data.crRange;
    const minStr = min !== void 0 ? formatCR(min) : "\u2014";
    const maxStr = max !== void 0 ? formatCR(max) : "\u2014";
    lines.push(`**CR Range:** ${minStr} to ${maxStr}`);
    lines.push("");
  }
  const tagSections = [];
  if (data.terrain_tags && data.terrain_tags.length > 0) {
    tagSections.push(`**Terrain:** ${data.terrain_tags.map((t) => t.value).join(", ")}`);
  }
  if (data.weather_tags && data.weather_tags.length > 0) {
    tagSections.push(`**Weather:** ${data.weather_tags.map((t) => t.value).join(", ")}`);
  }
  if (data.time_of_day_tags && data.time_of_day_tags.length > 0) {
    tagSections.push(`**Time:** ${data.time_of_day_tags.map((t) => t.value).join(", ")}`);
  }
  if (data.faction_tags && data.faction_tags.length > 0) {
    tagSections.push(`**Faction:** ${data.faction_tags.map((t) => t.value).join(", ")}`);
  }
  if (data.situation_tags && data.situation_tags.length > 0) {
    tagSections.push(`**Situation:** ${data.situation_tags.map((t) => t.value).join(", ")}`);
  }
  if (tagSections.length > 0) {
    lines.push(...tagSections);
    lines.push("");
  }
  if (data.entries && data.entries.length > 0) {
    lines.push("## Encounter Entries");
    lines.push("");
    lines.push("| Weight | Creatures | Quantity | Description |");
    lines.push("|--------|-----------|----------|-------------|");
    for (const entry of data.entries) {
      const weight = entry.weight || 1;
      const creatures = entry.creatures.join(", ");
      const quantity = entry.quantity || "1";
      const desc = entry.description || "\u2014";
      lines.push(`| ${weight} | ${creatures} | ${quantity} | ${desc} |`);
    }
    lines.push("");
  }
  return lines.join("\n");
}
function formatCR(cr) {
  if (cr === 0.125) return "1/8";
  if (cr === 0.25) return "1/4";
  if (cr === 0.5) return "1/2";
  return cr.toString();
}
function parseCR(cr) {
  if (typeof cr === "number") return cr;
  if (cr === "1/8") return 0.125;
  if (cr === "1/4") return 0.25;
  if (cr === "1/2") return 0.5;
  const parsed = parseFloat(cr);
  return isNaN(parsed) ? 0 : parsed;
}
var init_serializer11 = __esm({
  "src/workmodes/library/encounter-tables/serializer.ts"() {
    "use strict";
  }
});

// src/workmodes/library/encounter-tables/create-spec.ts
function formatCRDisplay(cr) {
  if (cr === 0.125) return "1/8";
  if (cr === 0.25) return "1/4";
  if (cr === 0.5) return "1/2";
  return cr.toString();
}
var encounterTableSchema, fields7, encounterTableSpec;
var init_create_spec11 = __esm({
  "src/workmodes/library/encounter-tables/create-spec.ts"() {
    "use strict";
    init_serializer11();
    init_constants11();
    encounterTableSchema = {
      parse: (data) => data,
      safeParse: (data) => {
        try {
          const table = data;
          if (!table.name || typeof table.name !== "string" || table.name.trim().length === 0) {
            return {
              success: false,
              error: new Error("Name is required")
            };
          }
          if (!Array.isArray(table.entries)) {
            return {
              success: false,
              error: new Error("Entries must be an array")
            };
          }
          if (table.entries.length === 0) {
            return {
              success: false,
              error: new Error("At least one encounter entry is required")
            };
          }
          if (table.crRange) {
            const { min, max } = table.crRange;
            if (min !== void 0 && (typeof min !== "number" || min < 0)) {
              return {
                success: false,
                error: new Error("CR min must be a non-negative number")
              };
            }
            if (max !== void 0 && (typeof max !== "number" || max < 0)) {
              return {
                success: false,
                error: new Error("CR max must be a non-negative number")
              };
            }
            if (min !== void 0 && max !== void 0 && min > max) {
              return {
                success: false,
                error: new Error("CR min cannot exceed CR max")
              };
            }
          }
          return { success: true, data: table };
        } catch (error) {
          return { success: false, error };
        }
      }
    };
    fields7 = [
      {
        id: "name",
        label: "Name",
        type: "text",
        required: true,
        placeholder: "Forest Encounters",
        description: "Internal name for the encounter table (used for file path)"
      },
      {
        id: "display_name",
        label: "Display Name",
        type: "text",
        placeholder: "Random Forest Encounters",
        description: "Human-readable name shown in UI (defaults to name if not set)"
      },
      {
        id: "description",
        label: "Description",
        type: "textarea",
        placeholder: "Encounters for dense forest hexes...",
        description: "Optional description of the encounter table's purpose and context"
      },
      // Tag fields for automatic selection (matches playlist pattern)
      {
        id: "terrain_tags",
        label: "Terrain Tags",
        type: "tokens",
        config: {
          fields: [
            {
              id: "value",
              type: "select",
              displayInChip: true,
              editable: true,
              suggestions: TERRAIN_TAGS2.map((tag) => ({ key: tag, label: tag })),
              placeholder: "Terrain ausw\xE4hlen..."
            }
          ],
          primaryField: "value"
        },
        default: [],
        description: "Terrain types this table applies to (Forest, Mountain, etc.)"
      },
      {
        id: "weather_tags",
        label: "Weather Tags",
        type: "tokens",
        config: {
          fields: [
            {
              id: "value",
              type: "select",
              displayInChip: true,
              editable: true,
              suggestions: WEATHER_TAGS2.map((tag) => ({ key: tag, label: tag })),
              placeholder: "Weather ausw\xE4hlen..."
            }
          ],
          primaryField: "value"
        },
        default: [],
        description: "Weather conditions this table applies to (Clear, Rain, etc.)"
      },
      {
        id: "time_of_day_tags",
        label: "Time of Day Tags",
        type: "tokens",
        config: {
          fields: [
            {
              id: "value",
              type: "select",
              displayInChip: true,
              editable: true,
              suggestions: TIME_OF_DAY_TAGS2.map((tag) => ({ key: tag, label: tag })),
              placeholder: "Time ausw\xE4hlen..."
            }
          ],
          primaryField: "value"
        },
        default: [],
        description: "Time of day this table applies to (Dawn, Night, etc.)"
      },
      {
        id: "faction_tags",
        label: "Faction Tags",
        type: "tokens",
        config: {
          fields: [
            {
              id: "value",
              type: "select",
              displayInChip: true,
              editable: true,
              suggestions: FACTION_TAGS2.map((tag) => ({ key: tag, label: tag })),
              placeholder: "Faction ausw\xE4hlen..."
            }
          ],
          primaryField: "value"
        },
        default: [],
        description: "Faction types this table applies to (Hostile, Undead, etc.)"
      },
      {
        id: "situation_tags",
        label: "Situation Tags",
        type: "tokens",
        config: {
          fields: [
            {
              id: "value",
              type: "select",
              displayInChip: true,
              editable: true,
              suggestions: SITUATION_TAGS2.map((tag) => ({ key: tag, label: tag })),
              placeholder: "Situation ausw\xE4hlen..."
            }
          ],
          primaryField: "value"
        },
        default: [],
        description: "Situations this table applies to (Exploration, Combat, etc.)"
      },
      // CR Range
      {
        id: "crRange",
        label: "CR Range (Optional)",
        type: "group",
        config: {
          fields: [
            {
              id: "min",
              label: "Minimum CR",
              type: "number-stepper",
              min: 0,
              max: 30,
              step: 0.125,
              placeholder: "0",
              description: "Minimum challenge rating (e.g. 0.125 = 1/8, 0.5 = 1/2)"
            },
            {
              id: "max",
              label: "Maximum CR",
              type: "number-stepper",
              min: 0,
              max: 30,
              step: 0.125,
              placeholder: "30",
              description: "Maximum challenge rating"
            }
          ]
        },
        description: "CR range filter for creatures in this table"
      },
      // Encounter Entries
      {
        id: "entries",
        label: "Encounter Entries",
        type: "list",
        config: {
          fields: [
            {
              id: "weight",
              label: "Weight",
              type: "number-stepper",
              required: true,
              min: 1,
              max: 100,
              step: 1,
              default: DEFAULT_ENTRY_WEIGHT,
              description: "Probability weight (higher = more likely)"
            },
            {
              id: "creatures",
              label: "Creatures",
              type: "tokens",
              required: true,
              config: {
                fields: [
                  {
                    id: "value",
                    type: "text",
                    displayInChip: true,
                    editable: true,
                    placeholder: "Creature name..."
                  }
                ],
                primaryField: "value"
              },
              description: "Creature names from Library (will be resolved at generation time)"
            },
            {
              id: "quantity",
              label: "Quantity",
              type: "text",
              placeholder: "1d4",
              description: "Dice formula or number (e.g. '1d4', '2', '1d6+2')"
            },
            {
              id: "description",
              label: "Description",
              type: "textarea",
              placeholder: "Optional flavor text...",
              description: "Optional description or context for this entry"
            }
          ],
          itemLabel: (item) => {
            const creatures = Array.isArray(item.creatures) ? item.creatures.map((c) => typeof c === "string" ? c : c.value).join(", ") : "No creatures";
            const weight = item.weight || 1;
            return `[${weight}] ${creatures}`;
          }
        },
        default: [],
        description: "Weighted encounter entries (roll to select)"
      }
    ];
    encounterTableSpec = {
      kind: "encounter-table",
      title: "Encounter Table erstellen",
      subtitle: "Neue zuf\xE4llige Begegnungstabelle",
      schema: encounterTableSchema,
      fields: fields7,
      storage: {
        format: "md-frontmatter",
        pathTemplate: "SaltMarcher/EncounterTables/{name}.md",
        filenameFrom: "name",
        directory: "SaltMarcher/EncounterTables",
        frontmatter: [
          "name",
          "display_name",
          "description",
          "terrain_tags",
          "weather_tags",
          "time_of_day_tags",
          "faction_tags",
          "situation_tags",
          "crRange",
          "entries"
        ],
        bodyTemplate: (data) => encounterTableToMarkdown(data)
      },
      ui: {
        submitLabel: "Table erstellen",
        cancelLabel: "Abbrechen",
        enableNavigation: false
      },
      browse: {
        metadata: [
          {
            id: "entry_count",
            cls: "sm-cc-item__cr",
            getValue: (entry) => `${entry.entry_count || 0} entries`
          },
          {
            id: "cr_range",
            cls: "sm-cc-item__type",
            getValue: (entry) => {
              if (!entry.crRange) return "All CRs";
              const min = entry.crRange.min !== void 0 ? formatCRDisplay(entry.crRange.min) : "\u2014";
              const max = entry.crRange.max !== void 0 ? formatCRDisplay(entry.crRange.max) : "\u2014";
              return `CR ${min}-${max}`;
            }
          }
        ],
        filters: [
          { id: "terrain_tags", field: "terrain_tags", label: "Terrain", type: "array" },
          { id: "weather_tags", field: "weather_tags", label: "Weather", type: "array" },
          { id: "time_of_day_tags", field: "time_of_day_tags", label: "Time", type: "array" },
          { id: "faction_tags", field: "faction_tags", label: "Faction", type: "array" },
          { id: "situation_tags", field: "situation_tags", label: "Situation", type: "array" }
        ],
        sorts: [
          { id: "name", label: "Name", field: "name" },
          { id: "entry_count", label: "Entry Count", field: "entry_count" }
        ],
        search: ["name", "display_name", "description"]
      },
      loader: {}
    };
  }
});

// src/workmodes/library/encounter-tables/index.ts
var init_encounter_tables = __esm({
  "src/workmodes/library/encounter-tables/index.ts"() {
    "use strict";
    init_types5();
    init_constants11();
    init_serializer11();
    init_create_spec11();
  }
});

// src/workmodes/library/registry.ts
function getCreateSpec(entity) {
  return LIBRARY_CREATE_SPECS[entity];
}
var LIBRARY_CREATE_SPECS, LIBRARY_VIEW_CONFIGS, LIBRARY_LIST_SCHEMAS;
var init_registry = __esm({
  "src/workmodes/library/registry.ts"() {
    "use strict";
    init_spec_to_config();
    init_creatures();
    init_spells();
    init_items();
    init_equipment();
    init_terrains();
    init_regions();
    init_calendars();
    init_factions();
    init_locations();
    init_playlists();
    init_encounter_tables();
    LIBRARY_CREATE_SPECS = {
      creatures: creatureSpec,
      spells: spellSpec,
      items: itemSpec,
      equipment: equipmentSpec,
      terrains: terrainSpec,
      regions: regionSpec,
      factions: factionSpec,
      calendars: calendarSpec,
      locations: locationSpec,
      playlists: playlistSpec,
      "encounter-tables": encounterTableSpec
    };
    LIBRARY_VIEW_CONFIGS = {
      ...generateViewConfigs(LIBRARY_CREATE_SPECS)
    };
    LIBRARY_LIST_SCHEMAS = {
      ...generateListSchemas(LIBRARY_CREATE_SPECS)
    };
  }
});

// src/features/maps/state/terrain-store.ts
async function ensureTerrainFile(app) {
  const path = (0, import_obsidian28.normalizePath)(TERRAIN_FILE);
  const existing = app.vault.getAbstractFileByPath(path);
  if (existing instanceof import_obsidian28.TFile) {
    return existing;
  }
  const dir = path.split("/").slice(0, -1).join("/");
  if (dir) {
    await app.vault.createFolder(dir).catch(() => {
    });
  }
  const body = [
    "---",
    "smList: true",
    "---",
    "# Terrains",
    "",
    "```terrain",
    ": transparent, speed: 1",
    "Wald: #2e7d32, speed: 0.6",
    "Meer: #0288d1, speed: 0.5",
    "Berg: #6d4c41, speed: 0.4",
    "```",
    ""
  ].join("\n");
  return await app.vault.create(path, body);
}
function parseTerrainBlock(md) {
  const match = md.match(BLOCK_RE2);
  if (!match) return {};
  const map2 = {};
  for (const raw of match[1].split(/\r?\n/)) {
    const line = raw.trim();
    if (!line || line.startsWith("#")) continue;
    const parsed = line.match(
      /^("?)(.*?)(\1)\s*:\s*([^,]+?)(?:\s*,\s*speed\s*:\s*([-+]?\d*\.?\d+))?\s*$/i
    );
    if (!parsed) continue;
    const name = parsed[2].trim();
    const color = parsed[4].trim();
    const speedValue = parsed[5] !== void 0 ? parseFloat(parsed[5]) : 1;
    const speed = Number.isFinite(speedValue) ? speedValue : 1;
    map2[name] = { color, speed };
  }
  if (!map2[""]) {
    map2[""] = { color: "transparent", speed: 1 };
  }
  return map2;
}
function stringifyTerrainBlock(map2) {
  const entries = Object.entries(map2);
  entries.sort(([a], [b]) => a === "" ? -1 : b === "" ? 1 : a.localeCompare(b));
  const lines = entries.map(([key, value]) => `${key || ":"}: ${value.color}, speed: ${value.speed}`);
  return ["```terrain", ...lines, "```"].join("\n");
}
async function readTerrainsFromDisk(app) {
  const file = await ensureTerrainFile(app);
  const content = await app.vault.read(file);
  return parseTerrainBlock(content);
}
async function writeTerrainsToDisk(app, map2) {
  const file = await ensureTerrainFile(app);
  const content = await app.vault.read(file);
  const block = stringifyTerrainBlock(map2);
  const updated = content.match(BLOCK_RE2) ? content.replace(BLOCK_RE2, block) : `${content}

${block}
`;
  await app.vault.modify(file, updated);
}
function createInitialState2() {
  return {
    loaded: false,
    map: {},
    version: 0
  };
}
function triggerTerrainEvent(app) {
  app.workspace.trigger?.("salt:terrains-updated");
}
function createTerrainStore(app, options) {
  const base = writable(createInitialState2(), {
    name: "map-terrains",
    debug: options?.debug
  });
  let dirty = false;
  let loadPromise = null;
  const persistent2 = {
    subscribe: base.subscribe,
    get: base.get,
    set: (value) => {
      base.set(value);
      dirty = true;
    },
    update: (updater) => {
      base.update((current) => {
        const next = updater(current);
        dirty = true;
        return next;
      });
    },
    load: async () => {
      const terrainMap = await readTerrainsFromDisk(app);
      base.set({
        loaded: true,
        map: terrainMap,
        version: Date.now()
      });
      dirty = false;
      setTerrains(terrainMap);
      triggerTerrainEvent(app);
    },
    save: async () => {
      const snapshot = base.get();
      if (!snapshot.loaded) return;
      await writeTerrainsToDisk(app, snapshot.map);
      dirty = false;
    },
    isDirty: () => dirty,
    getStorageKey: () => (0, import_obsidian28.normalizePath)(TERRAIN_FILE)
  };
  getStoreManager().register("map-terrains", persistent2);
  const ensureLoaded = async () => {
    const snapshot = persistent2.get();
    if (snapshot.loaded && loadPromise === null) {
      return;
    }
    if (!loadPromise) {
      loadPromise = persistent2.load().finally(() => {
        loadPromise = null;
      });
    }
    await loadPromise;
  };
  const refresh = async () => {
    loadPromise = persistent2.load().finally(() => {
      loadPromise = null;
    });
    await loadPromise;
  };
  const getTerrains = async () => {
    await ensureLoaded();
    return persistent2.get().map;
  };
  const saveTerrains3 = async (next) => {
    await ensureLoaded();
    persistent2.update(() => ({
      loaded: true,
      map: { ...next },
      version: Date.now()
    }));
    setTerrains(next);
    await persistent2.save();
    triggerTerrainEvent(app);
  };
  const watch = (options2) => {
    const resolved = resolveWatcherOptions(options2);
    const handleError = (error, reason) => {
      if (resolved.onError) {
        try {
          resolved.onError(error, { reason });
        } catch (handlerError) {
          logger2.error("[salt-marcher] Terrain watcher error handler threw", handlerError);
        }
        return;
      }
      logger2.error(`[salt-marcher] Terrain watcher failed after ${reason} event`, error);
    };
    const update = async (reason) => {
      try {
        if (reason === "delete") {
          await ensureTerrainFile(app);
        }
        await refresh();
        triggerTerrainEvent(app);
        await resolved.onChange?.();
      } catch (error) {
        handleError(error, reason);
      }
    };
    const maybeUpdate = (reason, file) => {
      if (!(file instanceof import_obsidian28.TFile)) return;
      if ((0, import_obsidian28.normalizePath)(file.path) !== (0, import_obsidian28.normalizePath)(TERRAIN_FILE)) return;
      void update(reason);
    };
    const refs = ["modify", "delete"].map(
      (event) => app.vault.on(event, (file) => maybeUpdate(event, file))
    );
    let disposed = false;
    return () => {
      if (disposed) return;
      disposed = true;
      for (const ref of refs) {
        app.vault.offref(ref);
      }
    };
  };
  return {
    state: persistent2,
    getTerrains,
    saveTerrains: saveTerrains3,
    refresh,
    watch
  };
}
function getTerrainStore(app, options) {
  let store = storeRegistry2.get(app);
  if (!store) {
    store = createTerrainStore(app, options);
    storeRegistry2.set(app, store);
  }
  return store;
}
function resolveWatcherOptions(maybe) {
  if (typeof maybe === "function") {
    return { onChange: maybe };
  }
  return maybe ?? {};
}
async function loadTerrains(app) {
  const store = getTerrainStore(app);
  return await store.getTerrains();
}
async function saveTerrains(app, map2) {
  const store = getTerrainStore(app);
  await store.saveTerrains(map2);
}
function watchTerrains(app, options) {
  const store = getTerrainStore(app, typeof options === "object" ? options.storeOptions : void 0);
  return store.watch(options);
}
var import_obsidian28, TERRAIN_FILE, BLOCK_RE2, storeRegistry2;
var init_terrain_store = __esm({
  "src/features/maps/state/terrain-store.ts"() {
    "use strict";
    import_obsidian28 = require("obsidian");
    init_state();
    init_store_manager();
    init_plugin_logger();
    init_terrain();
    TERRAIN_FILE = "SaltMarcher/Terrains.md";
    BLOCK_RE2 = /```terrain\s*([\s\S]*?)```/i;
    storeRegistry2 = /* @__PURE__ */ new WeakMap();
  }
});

// src/features/maps/data/terrain-repository.ts
var terrain_repository_exports = {};
__export(terrain_repository_exports, {
  TERRAIN_FILE: () => TERRAIN_FILE,
  ensureTerrainFile: () => ensureTerrainFile,
  loadTerrains: () => loadTerrains2,
  parseTerrainBlock: () => parseTerrainBlock,
  saveTerrains: () => saveTerrains2,
  stringifyTerrainBlock: () => stringifyTerrainBlock,
  watchTerrains: () => watchTerrains2
});
async function loadTerrains2(app) {
  return await loadTerrains(app);
}
async function saveTerrains2(app, next) {
  await saveTerrains(app, next);
}
function watchTerrains2(app, options) {
  return watchTerrains(app, options);
}
var init_terrain_repository = __esm({
  "src/features/maps/data/terrain-repository.ts"() {
    "use strict";
    init_terrain_store();
  }
});

// src/workmodes/library/core/sources.ts
async function ensureDir(app, dir) {
  const normalizedDir = (0, import_obsidian29.normalizePath)(dir);
  const folder = app.vault.getAbstractFileByPath(normalizedDir);
  if (!folder) {
    await app.vault.createFolder(normalizedDir).catch(() => {
    });
  }
}
async function ensureLibrarySource(app, source) {
  const spec = SOURCE_MAP[source];
  if (!spec) throw new Error(`Unknown library source: ${source}`);
  await spec.ensure(app);
}
async function ensureLibrarySources(app, sources) {
  const requested = sources ? Array.from(new Set(sources)) : LIBRARY_SOURCE_IDS;
  await Promise.all(requested.map((source) => ensureLibrarySource(app, source)));
}
function describeLibrarySource(source) {
  const spec = SOURCE_MAP[source];
  if (!spec) throw new Error(`Unknown library source: ${source}`);
  return spec.description;
}
var import_obsidian29, ensureCreatureDir, ensureSpellDir, ensureItemDir, ensureEquipmentDir, ensureFactionDir, ensureCalendarDir, SOURCE_MAP, LIBRARY_SOURCE_IDS;
var init_sources = __esm({
  "src/workmodes/library/core/sources.ts"() {
    "use strict";
    import_obsidian29 = require("obsidian");
    init_terrain_repository();
    init_region_repository();
    init_entity_registry();
    ensureCreatureDir = (app) => ensureDir(app, ENTITY_REGISTRY.creatures.directory);
    ensureSpellDir = (app) => ensureDir(app, ENTITY_REGISTRY.spells.directory);
    ensureItemDir = (app) => ensureDir(app, ENTITY_REGISTRY.items.directory);
    ensureEquipmentDir = (app) => ensureDir(app, ENTITY_REGISTRY.equipment.directory);
    ensureFactionDir = (app) => ensureDir(app, ENTITY_REGISTRY.factions.directory);
    ensureCalendarDir = (app) => ensureDir(app, ENTITY_REGISTRY.calendars.directory);
    SOURCE_MAP = Object.freeze({
      creatures: {
        ensure: ensureCreatureDir,
        description: `${ENTITY_REGISTRY.creatures.directory}/`
      },
      spells: {
        ensure: ensureSpellDir,
        description: `${ENTITY_REGISTRY.spells.directory}/`
      },
      items: {
        ensure: ensureItemDir,
        description: `${ENTITY_REGISTRY.items.directory}/`
      },
      equipment: {
        ensure: ensureEquipmentDir,
        description: `${ENTITY_REGISTRY.equipment.directory}/`
      },
      terrains: {
        ensure: ensureTerrainFile,
        description: TERRAIN_FILE
      },
      regions: {
        ensure: ensureRegionsFile,
        description: REGIONS_FILE
      },
      factions: {
        ensure: ensureFactionDir,
        description: `${ENTITY_REGISTRY.factions.directory}/`
      },
      calendars: {
        ensure: ensureCalendarDir,
        description: `${ENTITY_REGISTRY.calendars.directory}/`
      }
    });
    LIBRARY_SOURCE_IDS = Object.freeze(Object.keys(SOURCE_MAP));
  }
});

// src/workmodes/library/locations/location-list-renderer.ts
var LocationListRenderer;
var init_location_list_renderer = __esm({
  "src/workmodes/library/locations/location-list-renderer.ts"() {
    "use strict";
    init_generic_list_renderer();
    init_locations();
    LocationListRenderer = class extends GenericListRenderer {
      constructor(app, container, config) {
        super(app, container, config);
        this.viewMode = "list";
      }
      /**
       * Sets the view mode and triggers re-render.
       */
      setViewMode(mode) {
        if (this.viewMode !== mode) {
          this.viewMode = mode;
          this.render();
        }
      }
      /**
       * Gets the current view mode.
       */
      getViewMode() {
        return this.viewMode;
      }
      /**
       * Override render to add view mode toggle and conditional rendering.
       */
      render() {
        if (this.isDisposed()) return;
        const container = this.container;
        container.empty();
        this.renderViewModeToggle(container);
        if (this.viewMode === "tree") {
          this.renderTreeView(container);
        } else {
          this.renderInternal();
        }
      }
      /**
       * Renders the view mode toggle button.
       */
      renderViewModeToggle(container) {
        const toggleContainer = container.createDiv({ cls: "sm-location-view-toggle" });
        const listBtn = toggleContainer.createEl("button", {
          cls: this.viewMode === "list" ? "sm-toggle-active" : "",
          text: "\u{1F4CB} List"
        });
        const treeBtn = toggleContainer.createEl("button", {
          cls: this.viewMode === "tree" ? "sm-toggle-active" : "",
          text: "\u{1F333} Tree"
        });
        listBtn.addEventListener("click", () => {
          this.setViewMode("list");
        });
        treeBtn.addEventListener("click", () => {
          this.setViewMode("tree");
        });
      }
      /**
       * Renders locations in tree view.
       */
      renderTreeView(container) {
        const entries = this.entries;
        if (!entries || entries.length === 0) {
          container.createDiv({ cls: "sm-tree-empty", text: "Keine Orte vorhanden" });
          return;
        }
        const locations = entries.map((entry) => ({
          name: entry.name,
          type: entry.type || "Geb\xE4ude",
          description: entry.description,
          parent: entry.parent,
          owner_type: entry.owner_type,
          owner_name: entry.owner_name,
          region: entry.region,
          coordinates: entry.coordinates,
          notes: entry.notes
        }));
        const treeNodes = buildLocationTree(locations);
        this.treeContainer = container.createDiv({ cls: "sm-location-tree-container" });
        this.treeView = new LocationTreeView(this.treeContainer, {
          onLocationClick: (locationName) => {
            this.handleLocationClick(locationName);
          }
        });
        this.treeView.render(treeNodes);
      }
      /**
       * Handles click on a location in tree view.
       * Opens the location details by triggering the "Open" action.
       */
      handleLocationClick(locationName) {
        const entries = this.entries;
        const entry = entries.find((e) => e.name === locationName);
        if (!entry) return;
        const viewConfig = this.viewConfig;
        const actionContext = this.createActionContext();
        const openAction = viewConfig.actions?.find((a) => a.id === "open");
        if (openAction) {
          openAction.handler(entry, actionContext);
        }
      }
      /**
       * Override destroy to clean up tree view.
       */
      destroy() {
        this.treeView = void 0;
        this.treeContainer = void 0;
        super.destroy();
      }
    };
  }
});

// src/workmodes/library/view.ts
async function openLibrary(app) {
  const leaf = app.workspace.getLeaf(true);
  await leaf.setViewState({ type: VIEW_LIBRARY, active: true });
  app.workspace.revealLeaf(leaf);
}
var LIBRARY_COPY, VIEW_LIBRARY, LIBRARY_MODES, _LibraryView, LibraryView;
var init_view = __esm({
  "src/workmodes/library/view.ts"() {
    "use strict";
    init_data_manager();
    init_data_sources();
    init_registry();
    init_sources();
    init_location_list_renderer();
    LIBRARY_COPY = {
      title: "Library",
      searchPlaceholder: "Search the library or enter a name\u2026",
      createButton: "Create entry",
      modes: {
        creatures: "Creatures",
        spells: "Spells",
        items: "Items",
        equipment: "Equipment",
        terrains: "Terrains",
        regions: "Regions",
        factions: "Factions",
        calendars: "Calendars",
        locations: "Locations",
        playlists: "Playlists",
        "encounter-tables": "Encounter Tables"
      },
      sources: {
        prefix: "Source: "
      }
    };
    VIEW_LIBRARY = "salt-library";
    LIBRARY_MODES = ["creatures", "spells", "items", "equipment", "terrains", "regions", "factions", "calendars", "locations", "playlists", "encounter-tables"];
    _LibraryView = class _LibraryView extends TabbedBrowseView {
      get config() {
        return _LibraryView.LIBRARY_CONFIG;
      }
      constructor(leaf) {
        super(leaf);
      }
      /**
       * Override createRenderer to use LocationListRenderer for locations mode.
       */
      createRenderer(mode, container) {
        const rendererConfig = {
          mode,
          source: this.config.dataSources[mode],
          schema: this.config.schemas[mode],
          viewConfig: this.config.viewConfigs[mode],
          watchers: this.watchers
        };
        if (mode === "locations") {
          return new LocationListRenderer(
            this.app,
            container,
            rendererConfig
            // Type assertion needed due to Mode generics
          );
        }
        return new GenericListRenderer(this.app, container, rendererConfig);
      }
    };
    _LibraryView.LIBRARY_CONFIG = {
      viewType: VIEW_LIBRARY,
      icon: "library",
      copy: LIBRARY_COPY,
      defaultMode: "creatures",
      modes: LIBRARY_MODES,
      dataSources: LIBRARY_DATA_SOURCES,
      schemas: LIBRARY_LIST_SCHEMAS,
      viewConfigs: LIBRARY_VIEW_CONFIGS,
      ensureSources: ensureLibrarySources,
      describeSource: describeLibrarySource
    };
    LibraryView = _LibraryView;
  }
});

// src/features/locations/production-visualization.ts
function createProgressBar(percentage, options = {}) {
  const {
    label,
    color = "var(--interactive-accent)",
    height = "20px",
    showPercentage = true
  } = options;
  const container = document.createElement("div");
  container.style.marginBottom = "0.5em";
  if (label) {
    const labelEl = document.createElement("div");
    labelEl.style.fontSize = "0.85em";
    labelEl.style.marginBottom = "0.25em";
    labelEl.style.display = "flex";
    labelEl.style.justifyContent = "space-between";
    labelEl.style.alignItems = "center";
    const labelText = document.createElement("span");
    labelText.textContent = label;
    labelEl.appendChild(labelText);
    if (showPercentage) {
      const percentText = document.createElement("span");
      percentText.textContent = `${percentage.toFixed(0)}%`;
      percentText.style.fontWeight = "600";
      labelEl.appendChild(percentText);
    }
    container.appendChild(labelEl);
  }
  const track = document.createElement("div");
  track.style.width = "100%";
  track.style.height = height;
  track.style.background = "var(--background-modifier-border)";
  track.style.borderRadius = "4px";
  track.style.overflow = "hidden";
  track.style.position = "relative";
  container.appendChild(track);
  const fill = document.createElement("div");
  fill.style.width = `${Math.min(100, Math.max(0, percentage))}%`;
  fill.style.height = "100%";
  fill.style.background = color;
  fill.style.transition = "width 0.3s ease";
  track.appendChild(fill);
  return container;
}
function getConditionColor(condition) {
  if (condition >= 75) return "var(--color-green)";
  if (condition >= 50) return "var(--color-yellow)";
  if (condition >= 25) return "var(--color-orange)";
  return "var(--color-red)";
}
function createProductionRateVisualization(production) {
  const container = document.createElement("div");
  container.className = "sm-production-rate-viz";
  container.style.padding = "0.75em";
  container.style.background = "var(--background-secondary)";
  container.style.borderRadius = "4px";
  container.style.marginBottom = "1em";
  const header = document.createElement("h4");
  header.textContent = "Production Rate";
  header.style.fontSize = "0.95em";
  header.style.marginBottom = "0.75em";
  header.style.marginTop = "0";
  container.appendChild(header);
  const productionRate = calculateProductionRate(
    production.buildingType,
    production.condition,
    production.maintenanceOverdue
  );
  const productionPercentage = productionRate * 100;
  const conditionBar = createProgressBar(production.condition, {
    label: "Building Condition",
    color: getConditionColor(production.condition),
    showPercentage: true
  });
  container.appendChild(conditionBar);
  const rateColor = productionPercentage >= 75 ? "var(--color-green)" : productionPercentage >= 50 ? "var(--color-yellow)" : productionPercentage >= 25 ? "var(--color-orange)" : "var(--color-red)";
  const rateBar = createProgressBar(productionPercentage, {
    label: "Effective Production Rate",
    color: rateColor,
    showPercentage: true
  });
  container.appendChild(rateBar);
  if (production.maintenanceOverdue > 0) {
    const warningDiv = document.createElement("div");
    warningDiv.style.marginTop = "0.5em";
    warningDiv.style.padding = "0.5em";
    warningDiv.style.background = "var(--background-modifier-error)";
    warningDiv.style.borderRadius = "4px";
    warningDiv.style.fontSize = "0.85em";
    warningDiv.style.display = "flex";
    warningDiv.style.alignItems = "center";
    warningDiv.style.gap = "0.5em";
    const icon = document.createElement("span");
    icon.textContent = "\u26A0\uFE0F";
    warningDiv.appendChild(icon);
    const text = document.createElement("span");
    text.textContent = `Maintenance ${production.maintenanceOverdue} days overdue (-${((1 - productionRate) * 100).toFixed(0)}% production)`;
    warningDiv.appendChild(text);
    container.appendChild(warningDiv);
  }
  return container;
}
function createWorkerEfficiencyVisualization(production) {
  const container = document.createElement("div");
  container.className = "sm-worker-efficiency-viz";
  container.style.padding = "0.75em";
  container.style.background = "var(--background-secondary)";
  container.style.borderRadius = "4px";
  container.style.marginBottom = "1em";
  const header = document.createElement("h4");
  header.textContent = "Worker Efficiency";
  header.style.fontSize = "0.95em";
  header.style.marginBottom = "0.75em";
  header.style.marginTop = "0";
  container.appendChild(header);
  const template = BUILDING_TEMPLATES[production.buildingType];
  if (!template) {
    const errorDiv = document.createElement("div");
    errorDiv.textContent = "Unknown building type";
    container.appendChild(errorDiv);
    return container;
  }
  const capacityPercentage = production.currentWorkers / template.maxWorkers * 100;
  const capacityColor = capacityPercentage >= 100 ? "var(--color-green)" : capacityPercentage >= 75 ? "var(--color-yellow)" : capacityPercentage >= 50 ? "var(--color-orange)" : "var(--color-red)";
  const capacityBar = createProgressBar(capacityPercentage, {
    label: `Workers (${production.currentWorkers}/${template.maxWorkers})`,
    color: capacityColor,
    showPercentage: true
  });
  container.appendChild(capacityBar);
  const breakdownDiv = document.createElement("div");
  breakdownDiv.style.marginTop = "0.75em";
  breakdownDiv.style.fontSize = "0.85em";
  breakdownDiv.style.display = "grid";
  breakdownDiv.style.gridTemplateColumns = "1fr 1fr";
  breakdownDiv.style.gap = "0.5em";
  container.appendChild(breakdownDiv);
  const workerInfo = document.createElement("div");
  workerInfo.style.padding = "0.5em";
  workerInfo.style.background = "var(--background-primary)";
  workerInfo.style.borderRadius = "4px";
  const workerLabel = document.createElement("div");
  workerLabel.textContent = "Active Workers";
  workerLabel.style.color = "var(--text-muted)";
  workerInfo.appendChild(workerLabel);
  const workerCount = document.createElement("div");
  workerCount.textContent = production.currentWorkers.toString();
  workerCount.style.fontWeight = "600";
  workerInfo.appendChild(workerCount);
  breakdownDiv.appendChild(workerInfo);
  const jobsInfo = document.createElement("div");
  jobsInfo.style.padding = "0.5em";
  jobsInfo.style.background = "var(--background-primary)";
  jobsInfo.style.borderRadius = "4px";
  const jobsLabel = document.createElement("div");
  jobsLabel.textContent = "Active Jobs";
  jobsLabel.style.color = "var(--text-muted)";
  jobsInfo.appendChild(jobsLabel);
  const jobsCount = document.createElement("div");
  jobsCount.textContent = (production.activeJobs?.length || 0).toString();
  jobsCount.style.fontWeight = "600";
  jobsInfo.appendChild(jobsCount);
  breakdownDiv.appendChild(jobsInfo);
  if (capacityPercentage < 50) {
    const warningDiv = document.createElement("div");
    warningDiv.style.marginTop = "0.5em";
    warningDiv.style.padding = "0.5em";
    warningDiv.style.background = "var(--background-modifier-error)";
    warningDiv.style.borderRadius = "4px";
    warningDiv.style.fontSize = "0.85em";
    warningDiv.style.display = "flex";
    warningDiv.style.alignItems = "center";
    warningDiv.style.gap = "0.5em";
    const icon = document.createElement("span");
    icon.textContent = "\u26A0\uFE0F";
    warningDiv.appendChild(icon);
    const text = document.createElement("span");
    text.textContent = `Low staffing - Building operating at ${capacityPercentage.toFixed(0)}% capacity`;
    warningDiv.appendChild(text);
    container.appendChild(warningDiv);
  }
  return container;
}
function createResourceVisualization(production) {
  const container = document.createElement("div");
  container.className = "sm-resource-viz";
  container.style.padding = "0.75em";
  container.style.background = "var(--background-secondary)";
  container.style.borderRadius = "4px";
  container.style.marginBottom = "1em";
  const header = document.createElement("h4");
  header.textContent = "Resource Flow";
  header.style.fontSize = "0.95em";
  header.style.marginBottom = "0.75em";
  header.style.marginTop = "0";
  container.appendChild(header);
  if (!production.periodProduction || Object.keys(production.periodProduction).length === 0) {
    const noDataDiv = document.createElement("div");
    noDataDiv.style.textAlign = "center";
    noDataDiv.style.color = "var(--text-muted)";
    noDataDiv.style.padding = "1em 0";
    noDataDiv.textContent = "No production data for this period";
    container.appendChild(noDataDiv);
    return container;
  }
  const template = BUILDING_TEMPLATES[production.buildingType];
  if (!template) {
    const errorDiv = document.createElement("div");
    errorDiv.textContent = "Unknown building type";
    container.appendChild(errorDiv);
    return container;
  }
  const productionRate = calculateProductionRate(
    production.buildingType,
    production.condition,
    production.maintenanceOverdue
  );
  const resourcesDiv = document.createElement("div");
  resourcesDiv.style.display = "flex";
  resourcesDiv.style.flexDirection = "column";
  resourcesDiv.style.gap = "0.5em";
  container.appendChild(resourcesDiv);
  Object.entries(production.periodProduction).forEach(([resource, amount]) => {
    if (!amount || amount <= 0) return;
    const estimatedMax = productionRate > 0 ? amount / productionRate : amount;
    const percentage = amount / estimatedMax * 100;
    const resourceBar = createProgressBar(percentage, {
      label: `${resource}: ${amount}`,
      color: "var(--interactive-accent)",
      showPercentage: false
    });
    resourcesDiv.appendChild(resourceBar);
  });
  const efficiencyNote = document.createElement("div");
  efficiencyNote.style.marginTop = "0.75em";
  efficiencyNote.style.fontSize = "0.85em";
  efficiencyNote.style.color = "var(--text-muted)";
  efficiencyNote.style.fontStyle = "italic";
  efficiencyNote.textContent = `Currently operating at ${(productionRate * 100).toFixed(0)}% efficiency`;
  container.appendChild(efficiencyNote);
  return container;
}
function createProductionDashboard(production) {
  const dashboard = document.createElement("div");
  dashboard.className = "sm-production-dashboard";
  dashboard.appendChild(createProductionRateVisualization(production));
  dashboard.appendChild(createWorkerEfficiencyVisualization(production));
  dashboard.appendChild(createResourceVisualization(production));
  return dashboard;
}
var init_production_visualization = __esm({
  "src/features/locations/production-visualization.ts"() {
    "use strict";
    init_building_production();
  }
});

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray2(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer) return null;
  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent !== "number") options.indent = 1;
  if (typeof options.linesBefore !== "number") options.linesBefore = 3;
  if (typeof options.linesAfter !== "number") options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
function resolveYamlNull(data) {
  if (data === null) return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null) return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max) return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max) return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_") continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-") delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64) continue;
    if (code < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
function resolveYamlSet(data) {
  if (data === null) return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33) return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38) return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42) return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0) readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null) return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs) getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
  return "";
}
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var isNothing_1, isObject_1, toArray_1, repeat_1, isNegativeZero_1, extend_1, common, exception, snippet, TYPE_CONSTRUCTOR_OPTIONS, YAML_NODE_KINDS, type, schema, str, seq, map, failsafe, _null, bool, int, YAML_FLOAT_PATTERN, SCIENTIFIC_WITHOUT_DOT, float, json, core, YAML_DATE_REGEXP, YAML_TIMESTAMP_REGEXP, timestamp, merge, BASE64_MAP, binary, _hasOwnProperty$3, _toString$2, omap, _toString$1, pairs, _hasOwnProperty$2, set, _default, _hasOwnProperty$1, CONTEXT_FLOW_IN, CONTEXT_FLOW_OUT, CONTEXT_BLOCK_IN, CONTEXT_BLOCK_OUT, CHOMPING_CLIP, CHOMPING_STRIP, CHOMPING_KEEP, PATTERN_NON_PRINTABLE, PATTERN_NON_ASCII_LINE_BREAKS, PATTERN_FLOW_INDICATORS, PATTERN_TAG_HANDLE, PATTERN_TAG_URI, simpleEscapeCheck, simpleEscapeMap, i, directiveHandlers, loadAll_1, load_1, loader, _toString, _hasOwnProperty, CHAR_BOM, CHAR_TAB, CHAR_LINE_FEED, CHAR_CARRIAGE_RETURN, CHAR_SPACE, CHAR_EXCLAMATION, CHAR_DOUBLE_QUOTE, CHAR_SHARP, CHAR_PERCENT, CHAR_AMPERSAND, CHAR_SINGLE_QUOTE, CHAR_ASTERISK, CHAR_COMMA, CHAR_MINUS, CHAR_COLON, CHAR_EQUALS, CHAR_GREATER_THAN, CHAR_QUESTION, CHAR_COMMERCIAL_AT, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_GRAVE_ACCENT, CHAR_LEFT_CURLY_BRACKET, CHAR_VERTICAL_LINE, CHAR_RIGHT_CURLY_BRACKET, ESCAPE_SEQUENCES, DEPRECATED_BOOLEANS_SYNTAX, DEPRECATED_BASE60_SYNTAX, QUOTING_TYPE_SINGLE, QUOTING_TYPE_DOUBLE, STYLE_PLAIN, STYLE_SINGLE, STYLE_LITERAL, STYLE_FOLDED, STYLE_DOUBLE, dump_1, dumper, load, loadAll, dump, safeLoad, safeLoadAll, safeDump;
var init_js_yaml = __esm({
  "node_modules/js-yaml/dist/js-yaml.mjs"() {
    "use strict";
    isNothing_1 = isNothing;
    isObject_1 = isObject;
    toArray_1 = toArray2;
    repeat_1 = repeat;
    isNegativeZero_1 = isNegativeZero;
    extend_1 = extend;
    common = {
      isNothing: isNothing_1,
      isObject: isObject_1,
      toArray: toArray_1,
      repeat: repeat_1,
      isNegativeZero: isNegativeZero_1,
      extend: extend_1
    };
    YAMLException$1.prototype = Object.create(Error.prototype);
    YAMLException$1.prototype.constructor = YAMLException$1;
    YAMLException$1.prototype.toString = function toString(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    exception = YAMLException$1;
    snippet = makeSnippet;
    TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    type = Type$1;
    Schema$1.prototype.extend = function extend2(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof type) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit) implicit = implicit.concat(definition.implicit);
        if (definition.explicit) explicit = explicit.concat(definition.explicit);
      } else {
        throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) {
          throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type$1.loadKind && type$1.loadKind !== "scalar") {
          throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type$1.multi) {
          throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) {
          throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema$1.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    schema = Schema$1;
    str = new type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
    seq = new type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
    map = new type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
    failsafe = new schema({
      explicit: [
        str,
        seq,
        map
      ]
    });
    _null = new type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
    bool = new type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
    int = new type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
    YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    float = new type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
    json = failsafe.extend({
      implicit: [
        _null,
        bool,
        int,
        float
      ]
    });
    core = json;
    YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    timestamp = new type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
    merge = new type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
    BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    binary = new type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
    _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    _toString$2 = Object.prototype.toString;
    omap = new type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
    _toString$1 = Object.prototype.toString;
    pairs = new type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
    _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    set = new type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
    _default = core.extend({
      implicit: [
        timestamp,
        merge
      ],
      explicit: [
        binary,
        omap,
        pairs,
        set
      ]
    });
    _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    CONTEXT_FLOW_IN = 1;
    CONTEXT_FLOW_OUT = 2;
    CONTEXT_BLOCK_IN = 3;
    CONTEXT_BLOCK_OUT = 4;
    CHOMPING_CLIP = 1;
    CHOMPING_STRIP = 2;
    CHOMPING_KEEP = 3;
    PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    simpleEscapeCheck = new Array(256);
    simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty$1.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    loadAll_1 = loadAll$1;
    load_1 = load$1;
    loader = {
      loadAll: loadAll_1,
      load: load_1
    };
    _toString = Object.prototype.toString;
    _hasOwnProperty = Object.prototype.hasOwnProperty;
    CHAR_BOM = 65279;
    CHAR_TAB = 9;
    CHAR_LINE_FEED = 10;
    CHAR_CARRIAGE_RETURN = 13;
    CHAR_SPACE = 32;
    CHAR_EXCLAMATION = 33;
    CHAR_DOUBLE_QUOTE = 34;
    CHAR_SHARP = 35;
    CHAR_PERCENT = 37;
    CHAR_AMPERSAND = 38;
    CHAR_SINGLE_QUOTE = 39;
    CHAR_ASTERISK = 42;
    CHAR_COMMA = 44;
    CHAR_MINUS = 45;
    CHAR_COLON = 58;
    CHAR_EQUALS = 61;
    CHAR_GREATER_THAN = 62;
    CHAR_QUESTION = 63;
    CHAR_COMMERCIAL_AT = 64;
    CHAR_LEFT_SQUARE_BRACKET = 91;
    CHAR_RIGHT_SQUARE_BRACKET = 93;
    CHAR_GRAVE_ACCENT = 96;
    CHAR_LEFT_CURLY_BRACKET = 123;
    CHAR_VERTICAL_LINE = 124;
    CHAR_RIGHT_CURLY_BRACKET = 125;
    ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    QUOTING_TYPE_SINGLE = 1;
    QUOTING_TYPE_DOUBLE = 2;
    STYLE_PLAIN = 1;
    STYLE_SINGLE = 2;
    STYLE_LITERAL = 3;
    STYLE_FOLDED = 4;
    STYLE_DOUBLE = 5;
    dump_1 = dump$1;
    dumper = {
      dump: dump_1
    };
    load = loader.load;
    loadAll = loader.loadAll;
    dump = dumper.dump;
    safeLoad = renamed("safeLoad", "load");
    safeLoadAll = renamed("safeLoadAll", "loadAll");
    safeDump = renamed("safeDump", "dump");
  }
});

// src/workmodes/cartographer/building-management-modal.ts
var import_obsidian30, BuildingManagementModal;
var init_building_management_modal = __esm({
  "src/workmodes/cartographer/building-management-modal.ts"() {
    "use strict";
    import_obsidian30 = require("obsidian");
    init_building_production();
    init_production_visualization();
    init_plugin_logger();
    init_js_yaml();
    BuildingManagementModal = class extends import_obsidian30.Modal {
      constructor(app, options) {
        super(app);
        this.availableWorkers = [];
        this.assignedWorkers = [];
        this.unsavedChanges = false;
        this.options = options;
        this.production = JSON.parse(JSON.stringify(
          options.locationData.building_production
        ));
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("sm-building-management-modal");
        const title = contentEl.createEl("h2", {
          text: `Manage Building: ${this.options.locationData.name}`
        });
        title.style.marginBottom = "1em";
        const template = BUILDING_TEMPLATES[this.production.buildingType];
        if (!template) {
          new import_obsidian30.Notice("Invalid building type");
          this.close();
          return;
        }
        await this.loadAvailableWorkers();
        this.renderBuildingStatus(contentEl, template);
        this.renderWorkerManagement(contentEl, template);
        this.renderProductionTracking(contentEl, template);
        this.renderActionButtons(contentEl);
      }
      /**
       * Load available faction members that can work at this building
       */
      async loadAvailableWorkers() {
        try {
          const factions = await this.loadAllFactions();
          const template = BUILDING_TEMPLATES[this.production.buildingType];
          if (!template) return;
          const locationName = this.options.locationData.name;
          for (const faction of factions) {
            if (!faction.members) continue;
            for (const member of faction.members) {
              const isAtLocation = member.position?.type === "poi" && member.position?.location_name === locationName;
              const isUnassigned = !member.position || member.position.type === "unassigned";
              if (!isAtLocation && !isUnassigned) continue;
              const hasJobHere = member.job?.building === locationName;
              if (hasJobHere) {
                this.assignedWorkers.push({ faction, member });
              } else if (!member.job) {
                this.availableWorkers.push({ faction, member });
              }
            }
          }
          logger2.debug("[building-management] Loaded workers", {
            available: this.availableWorkers.length,
            assigned: this.assignedWorkers.length
          });
        } catch (error) {
          logger2.error("[building-management] Failed to load workers", { error });
          new import_obsidian30.Notice("Failed to load faction members");
        }
      }
      /**
       * Load all factions from vault
       */
      async loadAllFactions() {
        const factions = [];
        try {
          const files = this.app.vault.getMarkdownFiles();
          const factionFiles = files.filter(
            (f) => f.path.startsWith("SaltMarcher/Factions/") && !f.path.includes("Presets")
          );
          for (const file of factionFiles) {
            try {
              const content = await this.app.vault.read(file);
              const fmMatch = content.match(/^---\n([\s\S]*?)\n---/);
              if (!fmMatch) continue;
              const fm2 = fmMatch[1];
              if (!fm2.includes("smType: faction")) continue;
              const parsed = load(fm2);
              if (!parsed || typeof parsed !== "object") continue;
              if (!parsed.name || typeof parsed.name !== "string") continue;
              factions.push(parsed);
            } catch (error) {
              logger2.warn("[building-management] Error loading faction file", {
                file: file.path,
                error
              });
            }
          }
        } catch (error) {
          logger2.error("[building-management] Failed to load factions", { error });
        }
        return factions;
      }
      renderBuildingStatus(container, template) {
        const section = container.createDiv({ cls: "sm-building-section" });
        section.style.marginBottom = "1.5em";
        const header = section.createEl("h3", { text: "Building Status" });
        header.style.marginBottom = "0.5em";
        const infoDiv = section.createDiv({ cls: "sm-building-info" });
        infoDiv.style.marginBottom = "1em";
        infoDiv.createDiv({ text: `Type: ${template.name}` });
        infoDiv.createDiv({ text: `Category: ${template.category}` });
        infoDiv.createDiv({ text: `Max Workers: ${template.maxWorkers}` });
        new import_obsidian30.Setting(section).setName("Condition").setDesc(`Current: ${this.production.condition}% | Production Rate: ${(calculateProductionRate(this.production.buildingType, this.production.condition, this.production.maintenanceOverdue) * 100).toFixed(0)}%`).addSlider(
          (slider) => slider.setLimits(0, 100, 1).setValue(this.production.condition).onChange((value) => {
            this.production.condition = value;
            this.unsavedChanges = true;
            const productionRate = calculateProductionRate(
              this.production.buildingType,
              this.production.condition,
              this.production.maintenanceOverdue
            );
            slider.sliderEl.parentElement?.querySelector(".setting-item-description")?.setText(
              `Current: ${value}% | Production Rate: ${(productionRate * 100).toFixed(0)}%`
            );
          })
        );
        new import_obsidian30.Setting(section).setName("Maintenance Overdue").setDesc("Days since last maintenance").addText(
          (text) => text.setValue(String(this.production.maintenanceOverdue)).onChange((value) => {
            const days = parseInt(value) || 0;
            this.production.maintenanceOverdue = Math.max(0, days);
            this.unsavedChanges = true;
          })
        );
        const repairAmount = 10;
        const repairCosts = calculateRepairCosts(this.production.condition, repairAmount);
        const repairSetting = new import_obsidian30.Setting(section).setName("Repair Building").setDesc(`Cost: ${repairCosts.gold} gold, ${repairCosts.equipment} equipment`).addButton(
          (btn) => btn.setButtonText(`Repair (+${repairAmount} condition)`).onClick(async () => {
            await this.repairBuilding(repairCosts.gold, repairCosts.equipment, repairAmount);
          })
        );
        const maintenance = calculateMaintenanceCost(this.production.buildingType);
        const maintenanceText = Object.entries(maintenance).filter(([, value]) => value && value > 0).map(([key, value]) => `${key}: ${value}`).join(", ");
        if (maintenanceText) {
          const maintenanceDiv = section.createDiv({ cls: "sm-maintenance-cost" });
          maintenanceDiv.style.fontSize = "0.9em";
          maintenanceDiv.style.color = "var(--text-muted)";
          maintenanceDiv.style.marginTop = "0.5em";
          maintenanceDiv.setText(`Daily maintenance: ${maintenanceText}`);
        }
        const bonuses = getBuildingBonuses(this.production.buildingType);
        if (bonuses && Object.keys(bonuses).length > 0) {
          const bonusDiv = section.createDiv({ cls: "sm-building-bonuses" });
          bonusDiv.style.marginTop = "0.5em";
          bonusDiv.style.padding = "0.5em";
          bonusDiv.style.background = "var(--background-secondary)";
          bonusDiv.style.borderRadius = "4px";
          bonusDiv.createEl("div", {
            text: "Building Bonuses:",
            cls: "sm-bonus-header"
          }).style.fontWeight = "600";
          if (bonuses.qualityBonus) {
            bonusDiv.createDiv({
              text: `\u2728 Quality: +${(bonuses.qualityBonus * 100).toFixed(0)}%`
            });
          }
          if (bonuses.trainingSpeed) {
            bonusDiv.createDiv({
              text: `\u26A1 Training Speed: ${(bonuses.trainingSpeed * 100).toFixed(0)}%`
            });
          }
          if (bonuses.researchBonus) {
            bonusDiv.createDiv({
              text: `\u{1F4DA} Research: +${(bonuses.researchBonus * 100).toFixed(0)}%`
            });
          }
        }
      }
      renderWorkerManagement(container, template) {
        const section = container.createDiv({ cls: "sm-worker-section" });
        section.style.marginBottom = "1.5em";
        const header = section.createEl("h3", { text: "Worker Management" });
        header.style.marginBottom = "0.5em";
        new import_obsidian30.Setting(section).setName("Current Workers").setDesc(`Assigned: ${this.production.currentWorkers}/${template.maxWorkers}`).addText(
          (text) => text.setValue(String(this.production.currentWorkers)).onChange((value) => {
            const workers = parseInt(value) || 0;
            this.production.currentWorkers = Math.max(0, Math.min(template.maxWorkers, workers));
            this.unsavedChanges = true;
            text.inputEl.parentElement?.querySelector(".setting-item-description")?.setText(
              `Assigned: ${this.production.currentWorkers}/${template.maxWorkers}`
            );
          })
        );
        const jobsDiv = section.createDiv({ cls: "sm-allowed-jobs" });
        jobsDiv.style.marginTop = "0.5em";
        jobsDiv.style.padding = "0.5em";
        jobsDiv.style.background = "var(--background-secondary)";
        jobsDiv.style.borderRadius = "4px";
        jobsDiv.createEl("div", {
          text: "Allowed Jobs:",
          cls: "sm-jobs-header"
        }).style.fontWeight = "600";
        template.allowedJobs.forEach((job) => {
          jobsDiv.createDiv({ text: `\u2022 ${job}` });
        });
        const assignedHeader = section.createEl("h4", { text: "Assigned Workers" });
        assignedHeader.style.fontSize = "0.95em";
        assignedHeader.style.marginTop = "1em";
        assignedHeader.style.marginBottom = "0.5em";
        const assignedDiv = section.createDiv({ cls: "sm-assigned-workers" });
        assignedDiv.style.minHeight = "80px";
        assignedDiv.style.padding = "0.5em";
        assignedDiv.style.background = "var(--background-secondary)";
        assignedDiv.style.borderRadius = "4px";
        assignedDiv.style.border = "1px dashed var(--background-modifier-border)";
        if (this.assignedWorkers.length === 0) {
          const emptyDiv = assignedDiv.createDiv();
          emptyDiv.style.textAlign = "center";
          emptyDiv.style.color = "var(--text-muted)";
          emptyDiv.style.padding = "1.5em 0";
          emptyDiv.setText("No workers assigned");
        } else {
          this.assignedWorkers.forEach((worker, idx) => {
            const workerCard = this.createWorkerCard(worker, "assigned", idx);
            assignedDiv.appendChild(workerCard);
          });
        }
        const availableHeader = section.createEl("h4", { text: "Available Workers" });
        availableHeader.style.fontSize = "0.95em";
        availableHeader.style.marginTop = "1em";
        availableHeader.style.marginBottom = "0.5em";
        const availableDiv = section.createDiv({ cls: "sm-available-workers" });
        availableDiv.style.minHeight = "80px";
        availableDiv.style.maxHeight = "200px";
        availableDiv.style.overflowY = "auto";
        availableDiv.style.padding = "0.5em";
        availableDiv.style.background = "var(--background-secondary)";
        availableDiv.style.borderRadius = "4px";
        availableDiv.style.border = "1px dashed var(--background-modifier-border)";
        if (this.availableWorkers.length === 0) {
          const emptyDiv = availableDiv.createDiv();
          emptyDiv.style.textAlign = "center";
          emptyDiv.style.color = "var(--text-muted)";
          emptyDiv.style.padding = "1.5em 0";
          emptyDiv.setText("No available workers at this location");
        } else {
          this.availableWorkers.forEach((worker, idx) => {
            const workerCard = this.createWorkerCard(worker, "available", idx);
            availableDiv.appendChild(workerCard);
          });
        }
      }
      /**
       * Create a draggable worker card
       */
      createWorkerCard(worker, pool, index) {
        const card = document.createElement("div");
        card.className = "sm-worker-card";
        card.style.padding = "0.5em";
        card.style.marginBottom = "0.5em";
        card.style.background = "var(--background-primary)";
        card.style.borderRadius = "4px";
        card.style.border = "1px solid var(--background-modifier-border)";
        card.style.cursor = "grab";
        card.draggable = true;
        const template = BUILDING_TEMPLATES[this.production.buildingType];
        const workerJobType = worker.member.job?.type;
        const isJobCompatible = !workerJobType || template && template.allowedJobs.includes(workerJobType);
        if (pool === "available" && !isJobCompatible) {
          card.style.opacity = "0.5";
          card.style.border = "1px solid var(--text-error)";
          card.style.cursor = "not-allowed";
          card.draggable = false;
        }
        const nameDiv = card.createDiv();
        nameDiv.style.fontWeight = "600";
        nameDiv.style.marginBottom = "0.25em";
        nameDiv.setText(worker.member.name);
        const infoDiv = card.createDiv();
        infoDiv.style.fontSize = "0.85em";
        infoDiv.style.color = "var(--text-muted)";
        infoDiv.setText(`${worker.faction.name}${worker.member.role ? ` \u2022 ${worker.member.role}` : ""}`);
        if (workerJobType) {
          const jobDiv = card.createDiv();
          jobDiv.style.fontSize = "0.75em";
          jobDiv.style.marginTop = "0.25em";
          jobDiv.style.padding = "0.15em 0.35em";
          jobDiv.style.borderRadius = "3px";
          jobDiv.style.display = "inline-block";
          if (pool === "available" && !isJobCompatible) {
            jobDiv.style.background = "var(--background-modifier-error)";
            jobDiv.style.color = "var(--text-error)";
            jobDiv.setText(`\u26A0\uFE0F Job: ${workerJobType} (incompatible)`);
          } else {
            jobDiv.style.background = "var(--background-modifier-success)";
            jobDiv.style.color = "var(--text-success)";
            jobDiv.setText(`Job: ${workerJobType}`);
          }
        }
        card.ondragstart = (e) => {
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.setData("text/plain", JSON.stringify({
            pool,
            index,
            factionName: worker.faction.name,
            memberName: worker.member.name
          }));
          card.style.opacity = "0.5";
        };
        card.ondragend = () => {
          card.style.opacity = "1";
        };
        if (pool === "assigned") {
          card.ondragover = (e) => {
            e.preventDefault();
            card.style.background = "var(--interactive-accent)";
          };
          card.ondragleave = () => {
            card.style.background = "var(--background-primary)";
          };
          card.ondrop = (e) => {
            e.preventDefault();
            card.style.background = "var(--background-primary)";
            const data = JSON.parse(e.dataTransfer.getData("text/plain"));
            if (data.pool === "available") {
              this.assignWorker(data.index);
              this.refresh();
            }
          };
        }
        if (pool === "assigned") {
          const unassignBtn = card.createEl("button", { text: "Unassign" });
          unassignBtn.style.marginTop = "0.5em";
          unassignBtn.style.fontSize = "0.8em";
          unassignBtn.onclick = (e) => {
            e.stopPropagation();
            this.unassignWorker(index);
            this.refresh();
          };
        }
        if (pool === "available") {
          const assignBtn = card.createEl("button", { text: "Assign" });
          assignBtn.style.marginTop = "0.5em";
          assignBtn.style.fontSize = "0.8em";
          assignBtn.onclick = (e) => {
            e.stopPropagation();
            this.assignWorker(index);
            this.refresh();
          };
        }
        return card;
      }
      /**
       * Assign a worker from available pool to this building
       */
      assignWorker(availableIndex) {
        const template = BUILDING_TEMPLATES[this.production.buildingType];
        if (!template) return;
        if (this.assignedWorkers.length >= template.maxWorkers) {
          new import_obsidian30.Notice(`Building is at max capacity (${template.maxWorkers} workers)`);
          return;
        }
        const worker = this.availableWorkers[availableIndex];
        if (!worker) return;
        const workerJobType = worker.member.job?.type;
        if (workerJobType && !template.allowedJobs.includes(workerJobType)) {
          const allowedJobsStr = template.allowedJobs.join(", ");
          new import_obsidian30.Notice(
            `Cannot assign worker: ${worker.member.name} has job type "${workerJobType}" but this building only allows: ${allowedJobsStr}`,
            5e3
            // Show for 5 seconds
          );
          logger2.warn("[building-management] Job validation failed", {
            member: worker.member.name,
            memberJob: workerJobType,
            buildingType: this.production.buildingType,
            allowedJobs: template.allowedJobs
          });
          return;
        }
        this.availableWorkers.splice(availableIndex, 1);
        this.assignedWorkers.push(worker);
        this.production.currentWorkers = this.assignedWorkers.length;
        this.unsavedChanges = true;
        logger2.debug("[building-management] Assigned worker", {
          member: worker.member.name,
          faction: worker.faction.name,
          jobType: workerJobType,
          totalWorkers: this.assignedWorkers.length
        });
      }
      /**
       * Unassign a worker from this building back to available pool
       */
      unassignWorker(assignedIndex) {
        const worker = this.assignedWorkers[assignedIndex];
        if (!worker) return;
        this.assignedWorkers.splice(assignedIndex, 1);
        this.availableWorkers.push(worker);
        this.production.currentWorkers = this.assignedWorkers.length;
        this.unsavedChanges = true;
        logger2.debug("[building-management] Unassigned worker", {
          member: worker.member.name,
          faction: worker.faction.name,
          totalWorkers: this.assignedWorkers.length
        });
      }
      renderProductionTracking(container, template) {
        const section = container.createDiv({ cls: "sm-production-section" });
        section.style.marginBottom = "1.5em";
        const header = section.createEl("h3", { text: "Production Tracking & Analytics" });
        header.style.marginBottom = "0.5em";
        const dashboard = createProductionDashboard(this.production);
        section.appendChild(dashboard);
        if (this.production.activeJobs && this.production.activeJobs.length > 0) {
          const jobsSection = section.createDiv({ cls: "sm-active-jobs-section" });
          jobsSection.style.marginTop = "1.5em";
          jobsSection.style.padding = "0.75em";
          jobsSection.style.background = "var(--background-secondary)";
          jobsSection.style.borderRadius = "4px";
          const jobsHeader = jobsSection.createEl("h4", { text: "Active Jobs" });
          jobsHeader.style.fontSize = "0.95em";
          jobsHeader.style.marginTop = "0";
          jobsHeader.style.marginBottom = "0.5em";
          const jobsList = jobsSection.createDiv({ cls: "sm-active-jobs-list" });
          this.production.activeJobs.forEach((job, index) => {
            const jobDiv = jobsList.createDiv({ cls: "sm-job-item" });
            jobDiv.style.padding = "0.5em";
            jobDiv.style.marginBottom = "0.5em";
            jobDiv.style.background = "var(--background-primary)";
            jobDiv.style.borderRadius = "4px";
            jobDiv.style.border = "1px solid var(--background-modifier-border)";
            jobDiv.createDiv({ text: `${job.workerName} - ${job.jobType}` }).style.fontWeight = "600";
            jobDiv.createDiv({ text: `Progress: ${job.progress}%` });
            if (job.startedAt) {
              jobDiv.createDiv({ text: `Started: ${job.startedAt}` }).style.fontSize = "0.85em";
            }
            const removeBtn = jobDiv.createEl("button", { text: "Remove" });
            removeBtn.style.marginTop = "0.5em";
            removeBtn.style.fontSize = "0.8em";
            removeBtn.onclick = () => {
              this.production.activeJobs.splice(index, 1);
              this.unsavedChanges = true;
              this.refresh();
            };
          });
        }
      }
      renderActionButtons(container) {
        const buttonContainer = container.createDiv({ cls: "sm-button-container" });
        buttonContainer.style.display = "flex";
        buttonContainer.style.gap = "0.5em";
        buttonContainer.style.justifyContent = "flex-end";
        buttonContainer.style.marginTop = "1.5em";
        buttonContainer.style.paddingTop = "1em";
        buttonContainer.style.borderTop = "1px solid var(--background-modifier-border)";
        const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
        cancelBtn.onclick = () => {
          if (this.unsavedChanges) {
            const confirmed = confirm("You have unsaved changes. Are you sure you want to cancel?");
            if (!confirmed) return;
          }
          this.close();
        };
        const saveBtn = buttonContainer.createEl("button", { text: "Save Changes", cls: "mod-cta" });
        saveBtn.onclick = async () => {
          await this.saveChanges();
        };
      }
      /**
       * Repair building and deduct resources from owning faction
       */
      async repairBuilding(goldCost, equipmentCost, conditionIncrease) {
        try {
          if (this.options.locationData.owner_type !== "faction" || !this.options.locationData.owner_name) {
            new import_obsidian30.Notice("Building has no owning faction. Cannot deduct repair costs.");
            return;
          }
          const factionName = this.options.locationData.owner_name;
          const factionFile = await this.findFactionFile(factionName);
          if (!factionFile) {
            new import_obsidian30.Notice(`Faction "${factionName}" not found.`);
            return;
          }
          const content = await this.app.vault.read(factionFile);
          const fmMatch = content.match(/^---\n([\s\S]*?)\n---/);
          if (!fmMatch) {
            new import_obsidian30.Notice(`Invalid faction file format for "${factionName}".`);
            return;
          }
          const faction = load(fmMatch[1]);
          if (!faction.resources) {
            faction.resources = {};
          }
          const currentGold = faction.resources.gold || 0;
          const currentEquipment = faction.resources.equipment || 0;
          if (currentGold < goldCost || currentEquipment < equipmentCost) {
            new import_obsidian30.Notice(
              `Insufficient resources. Faction has ${currentGold} gold (need ${goldCost}) and ${currentEquipment} equipment (need ${equipmentCost}).`
            );
            return;
          }
          faction.resources.gold = currentGold - goldCost;
          faction.resources.equipment = currentEquipment - equipmentCost;
          const updatedFrontmatter = dump(faction);
          const updatedContent = `---
${updatedFrontmatter}---${content.substring(fmMatch[0].length)}`;
          await this.app.vault.modify(factionFile, updatedContent);
          const actualRepair = repairBuilding(this.production, goldCost, equipmentCost);
          logger2.info("[building-management] Building repaired", {
            location: this.options.locationData.name,
            faction: factionName,
            goldSpent: goldCost,
            equipmentSpent: equipmentCost,
            conditionIncrease: actualRepair,
            newCondition: this.production.condition
          });
          new import_obsidian30.Notice(
            `Repaired building: +${actualRepair.toFixed(0)} condition (now ${this.production.condition}%). Spent ${goldCost} gold and ${equipmentCost} equipment.`
          );
          this.unsavedChanges = true;
          this.refresh();
        } catch (error) {
          logger2.error("[building-management] Failed to repair building", { error });
          new import_obsidian30.Notice("Failed to repair building. Check console for details.");
        }
      }
      async saveChanges() {
        try {
          await this.app.fileManager.processFrontMatter(
            this.options.locationFile,
            (frontmatter) => {
              frontmatter.building_production = this.production;
            }
          );
          await this.saveFactionWorkerAssignments();
          logger2.info("[building-management] Saved building changes", {
            location: this.options.locationData.name,
            buildingType: this.production.buildingType,
            condition: this.production.condition,
            workers: this.production.currentWorkers
          });
          new import_obsidian30.Notice("Building changes saved");
          if (this.options.onSave) {
            const updatedData = { ...this.options.locationData };
            updatedData.building_production = this.production;
            this.options.onSave(updatedData);
          }
          this.unsavedChanges = false;
          this.close();
        } catch (error) {
          logger2.error("[building-management] Failed to save building changes", { error });
          new import_obsidian30.Notice("Failed to save changes. Check console for details.");
        }
      }
      /**
       * Update faction files to reflect worker position and job assignments
       */
      async saveFactionWorkerAssignments() {
        const locationName = this.options.locationData.name;
        const workersByFaction = /* @__PURE__ */ new Map();
        for (const { faction, member } of this.assignedWorkers) {
          if (!workersByFaction.has(faction.name)) {
            workersByFaction.set(faction.name, []);
          }
          workersByFaction.get(faction.name).push(member);
        }
        for (const [factionName, members] of workersByFaction.entries()) {
          try {
            const factionFile = await this.findFactionFile(factionName);
            if (!factionFile) {
              logger2.warn("[building-management] Faction file not found", { factionName });
              continue;
            }
            const content = await this.app.vault.read(factionFile);
            const fmMatch = content.match(/^---\n([\s\S]*?)\n---/);
            if (!fmMatch) continue;
            const parsed = load(fmMatch[1]);
            if (!parsed.members) parsed.members = [];
            for (const assignedMember of members) {
              const member = parsed.members.find((m) => m.name === assignedMember.name);
              if (member) {
                member.position = {
                  type: "poi",
                  location_name: locationName
                };
                if (!member.job) {
                  member.job = {
                    type: "guard",
                    // Default job type
                    building: locationName,
                    progress: 0
                  };
                } else {
                  member.job.building = locationName;
                }
              }
            }
            const yamlStr = dump(parsed, { lineWidth: -1, noRefs: true });
            const body = content.split(/\n---\n/)[1] || "";
            const newContent = `---
${yamlStr}---
${body}`;
            await this.app.vault.modify(factionFile, newContent);
            logger2.debug("[building-management] Updated faction file", {
              faction: factionName,
              workers: members.length
            });
          } catch (error) {
            logger2.error("[building-management] Failed to update faction", {
              faction: factionName,
              error
            });
          }
        }
      }
      /**
       * Find faction file by name
       */
      async findFactionFile(factionName) {
        const files = this.app.vault.getMarkdownFiles();
        const factionFiles = files.filter(
          (f) => f.path.startsWith("SaltMarcher/Factions/") && !f.path.includes("Presets")
        );
        for (const file of factionFiles) {
          const content = await this.app.vault.read(file);
          const fmMatch = content.match(/^---\n([\s\S]*?)\n---/);
          if (!fmMatch) continue;
          const parsed = load(fmMatch[1]);
          if (parsed && parsed.name === factionName) {
            return file;
          }
        }
        return null;
      }
      refresh() {
        this.onOpen();
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// src/workmodes/cartographer/modes/inspector.ts
var inspector_exports = {};
__export(inspector_exports, {
  createInspectorMode: () => createInspectorMode
});
function createInspectorMode() {
  let ui = {
    panel: null,
    form: null,
    fileLabel: null,
    message: null,
    terrain: null,
    region: null,
    faction: null,
    note: null
  };
  let state = {
    file: null,
    handles: null,
    selection: null,
    saveTimer: null
  };
  const lifecycle = createModeLifecycle();
  const isAborted = () => lifecycle.isAborted();
  const clearSaveTimer = () => {
    if (state.saveTimer !== null) {
      window.clearTimeout(state.saveTimer);
      state.saveTimer = null;
    }
  };
  const resetInputs = () => {
    ui.terrain?.setValue("");
    ui.terrain?.setDisabled(true);
    ui.region?.setValue("");
    ui.region?.setDisabled(true);
    ui.faction?.setValue("");
    ui.faction?.setDisabled(true);
    ui.note?.setValue("");
    ui.note?.setDisabled(true);
  };
  const updateMessage = () => {
    if (!ui.message) return;
    if (!state.file || !state.handles) {
      ui.message.set({ message: state.file ? "Karte wird geladen \u2026" : "Keine Karte ausgew\xE4hlt.", tone: "info" });
    } else if (!state.selection) {
      ui.message.set({ message: "Hex anklicken, um Terrain & Notiz zu bearbeiten.", tone: "info" });
    } else {
      ui.message.set({ message: `Hex r${state.selection.r}, c${state.selection.c}`, tone: "info" });
    }
  };
  const updateFileLabel = () => {
    if (!ui.fileLabel) return;
    ui.fileLabel.textContent = state.file ? state.file.basename : "Keine Karte";
  };
  const updatePanelState = () => {
    const hasMap = !!state.file && !!state.handles;
    ui.panel?.classList.toggle("is-disabled", !hasMap);
    if (!hasMap) {
      state.selection = null;
      resetInputs();
    }
    updateMessage();
  };
  const scheduleSave = (ctx) => {
    if (ctx.signal.aborted) return;
    if (!state.selection) return;
    const file = ctx.getFile();
    if (!file) return;
    const handles = ctx.getRenderHandles();
    clearSaveTimer();
    state.saveTimer = window.setTimeout(async () => {
      if (ctx.signal.aborted) return;
      const terrain = ui.terrain?.getValue() ?? "";
      const region = ui.region?.getValue() ?? "";
      const faction = ui.faction?.getValue() ?? "";
      const note = ui.note?.getValue() ?? "";
      try {
        await saveTile(ctx.app, file, state.selection, { terrain, region, faction, note });
      } catch (err) {
        logger2.error("[inspector-mode] saveTile failed", err);
      }
      const color = TERRAIN_COLORS[terrain] ?? "transparent";
      try {
        handles?.setFill(state.selection, color);
      } catch (err) {
        logger2.error("[inspector-mode] setFill failed", err);
      }
    }, 250);
  };
  const loadSelection = async (ctx) => {
    if (!state.selection) return;
    const file = ctx.getFile();
    if (!file) return;
    let data = null;
    try {
      data = await loadTile(ctx.app, file, state.selection);
    } catch (err) {
      logger2.error("[inspector-mode] loadTile failed", err);
      data = null;
    }
    if (ctx.signal.aborted) return;
    ui.terrain?.setValue(data?.terrain ?? "");
    ui.terrain?.setDisabled(false);
    ui.region?.setValue(data?.region ?? "");
    ui.region?.setDisabled(false);
    ui.faction?.setValue(data?.faction ?? "");
    ui.faction?.setDisabled(false);
    ui.note?.setValue(data?.note ?? "");
    ui.note?.setDisabled(false);
    if (ui.locationInfo) {
      while (ui.locationInfo.firstChild) {
        ui.locationInfo.removeChild(ui.locationInfo.firstChild);
      }
      const markerStore = getLocationMarkerStore(ctx.app, file);
      const marker = markerStore.get(state.selection);
      const influenceStore = getLocationInfluenceStore(ctx.app, file);
      const influence = influenceStore.get(state.selection);
      if (marker || influence) {
        const header = ui.locationInfo.createEl("h4", { text: "\u{1F4CD} Location Info" });
        header.style.marginTop = "0";
        header.style.marginBottom = "8px";
        if (marker) {
          const infoDiv = ui.locationInfo.createDiv({ cls: "sm-location-marker-info" });
          infoDiv.createDiv({ text: `${marker.displayIcon} ${marker.locationName}`, cls: "sm-location-name" });
          infoDiv.createDiv({ text: `Type: ${marker.locationType}`, cls: "sm-location-type" });
          if (marker.parent) {
            infoDiv.createDiv({ text: `Parent: ${marker.parent}`, cls: "sm-location-parent" });
          }
          if (marker.ownerName) {
            const ownerLabel = marker.ownerType === "faction" ? "Faction" : marker.ownerType === "npc" ? "Owner (NPC)" : "Owner";
            infoDiv.createDiv({ text: `${ownerLabel}: ${marker.ownerName}`, cls: "sm-location-owner" });
          }
          const openBtn = ui.locationInfo.createEl("button", { text: "Open in Library" });
          openBtn.style.marginTop = "8px";
          openBtn.addEventListener("click", async () => {
            const leaf = ctx.app.workspace.getLeaf(false);
            await leaf.setViewState({ type: VIEW_LIBRARY, active: true });
            ctx.app.workspace.revealLeaf(leaf);
          });
        }
        if (influence) {
          const influenceDiv = ui.locationInfo.createDiv({ cls: "sm-location-influence-info" });
          influenceDiv.style.marginTop = marker ? "12px" : "0";
          influenceDiv.style.padding = "8px";
          influenceDiv.style.background = "var(--background-secondary)";
          influenceDiv.style.borderRadius = "4px";
          const influenceHeader = influenceDiv.createEl("div", {
            text: `Influence Area: ${influence.locationName}`,
            cls: "sm-influence-header"
          });
          influenceHeader.style.fontWeight = "600";
          influenceHeader.style.marginBottom = "4px";
          influenceDiv.createDiv({
            text: `Strength: ${Math.round(influence.strength)}%`,
            cls: "sm-influence-strength"
          });
          if (influence.ownerName) {
            const ownerLabel = influence.ownerType === "faction" ? "Faction" : influence.ownerType === "npc" ? "NPC" : "Owner";
            influenceDiv.createDiv({
              text: `${ownerLabel}: ${influence.ownerName}`,
              cls: "sm-influence-owner"
            });
          }
          const locationPath = `SaltMarcher/Locations/${influence.locationName}.md`;
          const locationFile = lifecycle.ctx?.app.vault.getAbstractFileByPath(locationPath);
          if (locationFile && "extension" in locationFile) {
            (async () => {
              try {
                const fm2 = await readFrontmatter(lifecycle.ctx.app, locationFile);
                const locationData = fm2;
                if (isBuildingLocation(locationData)) {
                  const prod = locationData.building_production;
                  const template = BUILDING_TEMPLATES[prod.buildingType];
                  if (template) {
                    const buildingDiv = influenceDiv.createDiv({ cls: "sm-building-details" });
                    buildingDiv.style.marginTop = "8px";
                    buildingDiv.style.paddingTop = "8px";
                    buildingDiv.style.borderTop = "1px solid var(--background-modifier-border)";
                    const buildingHeader = buildingDiv.createEl("div", {
                      text: "Building Details",
                      cls: "sm-building-header"
                    });
                    buildingHeader.style.fontWeight = "600";
                    buildingHeader.style.marginBottom = "4px";
                    const conditionIcon = prod.condition >= 80 ? "\u{1F7E2}" : prod.condition >= 40 ? "\u{1F7E1}" : "\u{1F534}";
                    buildingDiv.createDiv({
                      text: `${conditionIcon} ${template.name} (${prod.condition}% condition)`,
                      cls: "sm-building-type"
                    });
                    buildingDiv.createDiv({
                      text: `Workers: ${prod.currentWorkers}/${template.maxWorkers}`,
                      cls: "sm-building-workers"
                    });
                    if (prod.maintenanceOverdue > 0) {
                      const maintenanceDiv = buildingDiv.createDiv({
                        text: `\u26A0\uFE0F Maintenance overdue: ${prod.maintenanceOverdue} days`,
                        cls: "sm-building-maintenance"
                      });
                      maintenanceDiv.style.color = "var(--text-warning)";
                    }
                    if (prod.activeJobs && prod.activeJobs.length > 0) {
                      const jobsDiv = buildingDiv.createDiv({ cls: "sm-building-jobs" });
                      jobsDiv.style.marginTop = "4px";
                      jobsDiv.createEl("div", {
                        text: `Active Jobs: ${prod.activeJobs.length}`,
                        cls: "sm-jobs-header"
                      }).style.fontSize = "0.9em";
                    }
                    const manageButton = buildingDiv.createEl("button", {
                      text: "Manage Building",
                      cls: "sm-manage-building-btn"
                    });
                    manageButton.style.marginTop = "8px";
                    manageButton.style.width = "100%";
                    manageButton.onclick = () => {
                      const modal = new BuildingManagementModal(lifecycle.ctx.app, {
                        locationFile,
                        locationData,
                        onSave: (updatedData) => {
                          logger2.info("[cartographer:inspector] Building updated, refreshing display");
                        }
                      });
                      modal.open();
                    };
                  }
                }
              } catch (error) {
                logger2.warn("[cartographer:inspector] Failed to load building details", {
                  locationName: influence.locationName,
                  error
                });
              }
            })();
          }
        }
      }
    }
    updateMessage();
  };
  const clearHost = (host) => {
    while (host.firstChild) {
      host.removeChild(host.firstChild);
    }
  };
  return {
    id: "inspector",
    label: "Inspector",
    async onEnter(ctx) {
      lifecycle.bind(ctx);
      ui = { panel: null, form: null, fileLabel: null, message: null, terrain: null, region: null, faction: null, note: null, locationInfo: null };
      state = { ...state, selection: null };
      clearHost(ctx.sidebarHost);
      ui.panel = document.createElement("div");
      ui.panel.className = "sm-cartographer__panel sm-cartographer__panel--inspector";
      ctx.sidebarHost.appendChild(ui.panel);
      ui.form = buildForm(ui.panel, {
        sections: [
          { kind: "header", text: "Inspektor" },
          { kind: "static", id: "file", cls: "sm-cartographer__panel-file" },
          { kind: "status", id: "message", cls: "sm-cartographer__panel-info" },
          {
            kind: "row",
            label: "Terrain:",
            rowCls: "sm-cartographer__panel-row",
            controls: [
              {
                kind: "select",
                id: "terrain",
                options: Object.keys(TERRAIN_COLORS).map((key) => ({
                  value: key,
                  label: key || "(leer)"
                })),
                disabled: true,
                enhance: (select) => enhanceSelectToSearch(select, "Such-dropdown\u2026"),
                onChange: () => scheduleSave(ctx)
              }
            ]
          },
          {
            kind: "row",
            label: "Region:",
            rowCls: "sm-cartographer__panel-row",
            controls: [
              {
                kind: "select",
                id: "region",
                options: [],
                disabled: true,
                enhance: (select) => enhanceSelectToSearch(select, "Such-dropdown\u2026"),
                onChange: () => scheduleSave(ctx)
              }
            ]
          },
          {
            kind: "row",
            label: "Faction:",
            rowCls: "sm-cartographer__panel-row",
            controls: [
              {
                kind: "select",
                id: "faction",
                options: [],
                disabled: true,
                enhance: (select) => enhanceSelectToSearch(select, "Such-dropdown\u2026"),
                onChange: () => scheduleSave(ctx)
              }
            ]
          },
          {
            kind: "row",
            label: "Notiz:",
            rowCls: "sm-cartographer__panel-row",
            controls: [
              {
                kind: "textarea",
                id: "note",
                rows: 6,
                disabled: true,
                onInput: () => scheduleSave(ctx)
              }
            ]
          },
          { kind: "separator" },
          { kind: "static", id: "location", cls: "sm-cartographer__location-info" }
        ]
      });
      ui.fileLabel = ui.form.getElement("file");
      ui.message = ui.form.getStatus("message");
      ui.terrain = ui.form.getControl("terrain");
      ui.region = ui.form.getControl("region");
      ui.faction = ui.form.getControl("faction");
      ui.note = ui.form.getControl("note");
      ui.locationInfo = ui.form.getElement("location");
      try {
        const regions = await loadRegions2(ctx.app);
        ui.region?.setOptions([
          { label: "(none)", value: "" },
          ...regions.map((r) => ({
            label: r.name || "(unnamed)",
            value: r.name ?? ""
          }))
        ]);
      } catch (err) {
        logger2.error("[inspector-mode] failed to load regions", err);
      }
      try {
        const factionFiles = await LIBRARY_DATA_SOURCES.factions.list(ctx.app);
        const factions = [];
        for (const file of factionFiles) {
          try {
            const entry = await LIBRARY_DATA_SOURCES.factions.load(ctx.app, file);
            factions.push({ name: entry.name });
          } catch (err) {
            logger2.warn(`[inspector-mode] failed to load faction ${file.path}`, err);
          }
        }
        ui.faction?.setOptions([
          { label: "(none)", value: "" },
          ...factions.map((f) => ({
            label: f.name || "(unnamed)",
            value: f.name ?? ""
          }))
        ]);
      } catch (err) {
        logger2.error("[inspector-mode] failed to load factions", err);
      }
      updateFileLabel();
      updatePanelState();
    },
    async onExit(ctx) {
      lifecycle.bind(ctx);
      clearSaveTimer();
      ui.form?.destroy();
      ui.panel?.remove();
      ui = { panel: null, form: null, fileLabel: null, message: null, terrain: null, region: null, faction: null, note: null, locationInfo: null };
      state = { file: null, handles: null, selection: null, saveTimer: null };
      lifecycle.reset();
    },
    async onFileChange(file, handles, ctx) {
      lifecycle.bind(ctx);
      state.file = file;
      state.handles = handles;
      clearSaveTimer();
      resetInputs();
      updateFileLabel();
      updatePanelState();
      if (state.selection && state.file && state.handles && !isAborted()) {
        await loadSelection(ctx);
      }
    },
    async onHexClick(coord, _event, ctx) {
      lifecycle.bind(ctx);
      if (isAborted()) return;
      if (!state.file || !state.handles) return;
      clearSaveTimer();
      state.selection = coord;
      updateMessage();
      if (isAborted()) return;
      await loadSelection(ctx);
    }
  };
}
var init_inspector = __esm({
  "src/workmodes/cartographer/modes/inspector.ts"() {
    "use strict";
    init_tile_repository();
    init_terrain();
    init_region_repository();
    init_data_sources();
    init_search_dropdown();
    init_plugin_logger();
    init_lifecycle();
    init_form_builder();
    init_location_marker_store();
    init_view();
    init_location_influence_store();
    init_frontmatter_utils();
    init_types3();
    init_building_production();
    init_building_management_modal();
  }
});

// src/workmodes/encounter/session-store.ts
function createInitialEncounterXpState() {
  return {
    party: [],
    encounterXp: 0,
    rules: []
  };
}
function clonePartyMember(member) {
  return { ...member };
}
function cloneRule(rule) {
  return { ...rule };
}
function cloneMutableEncounterXpState(state) {
  return {
    party: state.party.map(clonePartyMember),
    encounterXp: state.encounterXp,
    rules: state.rules.map(cloneRule)
  };
}
function createImmutableEncounterXpState(state) {
  const party = Object.freeze(state.party.map(clonePartyMember));
  const rules = Object.freeze(state.rules.map(cloneRule));
  return {
    party,
    encounterXp: state.encounterXp,
    rules
  };
}
function emitEncounterXpState() {
  const snapshot = createImmutableEncounterXpState(encounterXpState);
  if (!xpStateListeners.size) {
    return snapshot;
  }
  for (const listener of [...xpStateListeners]) {
    try {
      listener(snapshot);
    } catch (err) {
      logger2.error("[encounter] xp listener failed", err);
    }
  }
  return snapshot;
}
function publishEncounterEvent(event) {
  latestEvent = event;
  for (const listener of [...listeners]) {
    try {
      listener(event);
    } catch (err) {
      logger2.error("[encounter] listener failed", err);
    }
  }
}
function subscribeToEncounterEvents(listener) {
  listeners.add(listener);
  if (latestEvent) {
    try {
      listener(latestEvent);
    } catch (err) {
      logger2.error("[encounter] listener failed", err);
    }
  }
  return () => {
    listeners.delete(listener);
  };
}
function peekLatestEncounterEvent() {
  return latestEvent;
}
function getEncounterXpState() {
  return createImmutableEncounterXpState(encounterXpState);
}
function subscribeEncounterXpState(listener) {
  xpStateListeners.add(listener);
  try {
    listener(getEncounterXpState());
  } catch (err) {
    logger2.error("[encounter] xp listener failed", err);
  }
  return () => {
    xpStateListeners.delete(listener);
  };
}
function updateEncounterXpState(mutator) {
  const next = cloneMutableEncounterXpState(encounterXpState);
  mutator(next);
  encounterXpState = next;
  return emitEncounterXpState();
}
function setEncounterXp(value) {
  return updateEncounterXpState((draft) => {
    draft.encounterXp = value;
  });
}
function addPartyMember(member) {
  return updateEncounterXpState((draft) => {
    draft.party.push(clonePartyMember(member));
  });
}
function updatePartyMember(id, patch) {
  return updateEncounterXpState((draft) => {
    const index = draft.party.findIndex((member) => member.id === id);
    if (index === -1) {
      return;
    }
    draft.party[index] = { ...draft.party[index], ...patch };
  });
}
function removePartyMember(id) {
  return updateEncounterXpState((draft) => {
    draft.party = draft.party.filter((member) => member.id !== id);
  });
}
function addRule(rule) {
  return updateEncounterXpState((draft) => {
    draft.rules.push(cloneRule(rule));
  });
}
function updateRule(id, patch) {
  return updateEncounterXpState((draft) => {
    const index = draft.rules.findIndex((rule) => rule.id === id);
    if (index === -1) {
      return;
    }
    draft.rules[index] = { ...draft.rules[index], ...patch };
  });
}
function removeRule(id) {
  return updateEncounterXpState((draft) => {
    draft.rules = draft.rules.filter((rule) => rule.id !== id);
  });
}
function replaceEncounterXpState(state) {
  encounterXpState = {
    party: state.party.map(clonePartyMember),
    encounterXp: state.encounterXp,
    rules: state.rules.map(cloneRule)
  };
  return emitEncounterXpState();
}
var DND5E_XP_THRESHOLDS, latestEvent, listeners, encounterXpState, xpStateListeners;
var init_session_store = __esm({
  "src/workmodes/encounter/session-store.ts"() {
    "use strict";
    init_plugin_logger();
    DND5E_XP_THRESHOLDS = {
      1: 0,
      2: 300,
      3: 900,
      4: 2700,
      5: 6500,
      6: 14e3,
      7: 23e3,
      8: 34e3,
      9: 48e3,
      10: 64e3,
      11: 85e3,
      12: 1e5,
      13: 12e4,
      14: 14e4,
      15: 165e3,
      16: 195e3,
      17: 225e3,
      18: 265e3,
      19: 305e3,
      20: 355e3
    };
    latestEvent = null;
    listeners = /* @__PURE__ */ new Set();
    encounterXpState = createInitialEncounterXpState();
    xpStateListeners = /* @__PURE__ */ new Set();
  }
});

// src/workmodes/encounter/generator.ts
var generator_exports = {};
__export(generator_exports, {
  calculateCreatureBudget: () => calculateCreatureBudget,
  filterCreaturesByTags: () => filterCreaturesByTags,
  generateRandomEncounter: () => generateRandomEncounter,
  selectCreaturesForBudget: () => selectCreaturesForBudget
});
function getXpMultiplier(count) {
  if (count === 1) return 1;
  if (count === 2) return 1.5;
  if (count >= 3 && count <= 6) return 2;
  if (count >= 7 && count <= 10) return 2.5;
  if (count >= 11 && count <= 14) return 3;
  return 4;
}
function filterCreaturesByTags(ctx) {
  const { faction, terrain, region, creatures } = ctx;
  const factionTags = faction?.influence_tags?.map((t) => t.value.toLowerCase()) ?? [];
  const terrainTags = [
    ...terrain?.biome_tags?.map((t) => t.value.toLowerCase()) ?? [],
    ...terrain?.difficulty_tags?.map((t) => t.value.toLowerCase()) ?? []
  ];
  const regionTags = [
    ...region?.biome_tags?.map((t) => t.value.toLowerCase()) ?? [],
    ...region?.danger_tags?.map((t) => t.value.toLowerCase()) ?? [],
    ...region?.climate_tags?.map((t) => t.value.toLowerCase()) ?? [],
    ...region?.settlement_tags?.map((t) => t.value.toLowerCase()) ?? []
  ];
  const matchesAnyTag = (creatureTags, filterTags) => {
    if (filterTags.length === 0) return true;
    if (creatureTags.length === 0) return false;
    return creatureTags.some((ct) => filterTags.includes(ct.toLowerCase()));
  };
  const filterLevels = [
    // Level 1: Faction + Terrain + Region (skip if any is empty)
    ...factionTags.length > 0 && terrainTags.length > 0 && regionTags.length > 0 ? [{ level: 1, tags: [factionTags, terrainTags, regionTags] }] : [],
    // Level 2: Faction + Terrain (skip if either is empty)
    ...factionTags.length > 0 && terrainTags.length > 0 ? [{ level: 2, tags: [factionTags, terrainTags] }] : [],
    // Level 3: Terrain only (skip if empty)
    ...terrainTags.length > 0 ? [{ level: 3, tags: [terrainTags] }] : [],
    // Level 4: No filter (always present)
    { level: 4, tags: [] }
  ];
  for (const { level, tags } of filterLevels) {
    const filtered = creatures.filter((creature) => {
      const creatureTags = creature.typeTags?.map((t) => {
        return typeof t === "string" ? t : t;
      }) ?? [];
      if (tags.length === 0) return true;
      if (creatureTags.length === 0) return false;
      return tags.every((filterTagSet) => matchesAnyTag(creatureTags, filterTagSet));
    });
    if (filtered.length > 0) {
      logger2.debug(`[generator] Filter level ${level}: ${filtered.length} matches`, {
        factionTags,
        terrainTags,
        regionTags,
        filterLevel: level
      });
      return { creatures: filtered, filterLevel: level };
    }
  }
  logger2.warn("[generator] No creatures found at any filter level");
  return { creatures: [], filterLevel: 4 };
}
function calculateCreatureBudget(options) {
  const { partyLevel, partySize, difficulty } = options;
  if (partyLevel < 1 || partyLevel > 20) {
    logger2.warn(`[generator] Invalid party level: ${partyLevel}, clamping to 1-20`);
  }
  if (partySize < 1) {
    logger2.warn(`[generator] Invalid party size: ${partySize}, defaulting to 1`);
  }
  const level = Math.max(1, Math.min(20, partyLevel));
  const size = Math.max(1, partySize);
  const xpPerCharacter = XP_THRESHOLDS[difficulty][level - 1];
  const targetXP = xpPerCharacter * size;
  const minXP = Math.floor(targetXP * 0.8);
  const maxXP = Math.ceil(targetXP * 1.2);
  logger2.debug(`[generator] Budget: ${targetXP} XP (${minXP}-${maxXP})`, {
    partyLevel: level,
    partySize: size,
    difficulty,
    xpPerCharacter
  });
  return { targetXP, minXP, maxXP };
}
function selectCreaturesForBudget(creatures, budget, options) {
  if (creatures.length === 0) {
    logger2.warn("[generator] No creatures available for selection");
    return [];
  }
  const { minXP, maxXP } = budget;
  const MAX_CREATURES = 6;
  const MAX_COPIES = 3;
  const sorted = [...creatures].sort((a, b) => {
    const crA = typeof a.cr === "string" ? parseFloat(a.cr) : 0;
    const crB = typeof b.cr === "string" ? parseFloat(b.cr) : 0;
    return crA - crB;
  });
  const getAdjustedXP = (selections) => {
    const totalCount = Array.from(selections.values()).reduce((sum, count) => sum + count, 0);
    const multiplier = getXpMultiplier(totalCount);
    let rawXP = 0;
    for (const [name, count] of selections) {
      const creature = sorted.find((c) => c.name === name);
      if (!creature) continue;
      const cr = typeof creature.cr === "string" ? parseFloat(creature.cr) : 0;
      const xpPerCreature = XP_BY_CR[cr] ?? 0;
      rawXP += xpPerCreature * count;
    }
    return Math.round(rawXP * multiplier);
  };
  const rng = options.seed !== void 0 ? seededRandom(options.seed) : Math.random;
  let bestSelection = /* @__PURE__ */ new Map();
  let bestXP = 0;
  for (let attempt = 0; attempt < 10; attempt++) {
    const selection = /* @__PURE__ */ new Map();
    const shuffled = [...sorted].sort(() => rng() - 0.5);
    for (const creature of shuffled) {
      if (Array.from(selection.values()).reduce((sum, c) => sum + c, 0) >= MAX_CREATURES) {
        break;
      }
      const currentCopies = selection.get(creature.name) ?? 0;
      if (currentCopies >= MAX_COPIES) continue;
      selection.set(creature.name, currentCopies + 1);
      const adjustedXP = getAdjustedXP(selection);
      if (adjustedXP > maxXP) {
        if (currentCopies === 0) {
          selection.delete(creature.name);
        } else {
          selection.set(creature.name, currentCopies);
        }
      } else if (adjustedXP >= minXP) {
        if (adjustedXP > bestXP || bestSelection.size === 0) {
          bestSelection = new Map(selection);
          bestXP = adjustedXP;
        }
      }
    }
    const finalXP = getAdjustedXP(selection);
    if (finalXP >= minXP && finalXP <= maxXP) {
      if (finalXP > bestXP || bestSelection.size === 0) {
        bestSelection = new Map(selection);
        bestXP = finalXP;
      }
    }
  }
  if (bestSelection.size === 0) {
    for (let i = sorted.length - 1; i >= 0; i--) {
      const creature = sorted[i];
      const cr = typeof creature.cr === "string" ? parseFloat(creature.cr) : 0;
      const xp = XP_BY_CR[cr] ?? 0;
      if (xp <= maxXP) {
        bestSelection.set(creature.name, 1);
        bestXP = xp;
        logger2.debug("[generator] Fallback: Single creature", { name: creature.name, xp });
        break;
      }
    }
  }
  const result = [];
  for (const [name, count] of bestSelection) {
    const creature = sorted.find((c) => c.name === name);
    if (!creature) continue;
    const cr = typeof creature.cr === "string" ? parseFloat(creature.cr) : 0;
    result.push({
      id: `${name}-${Date.now()}`,
      name: creature.name,
      count,
      cr,
      source: "library",
      statblockPath: `Creatures/${creature.name}.md`
      // TODO: Get actual path
    });
  }
  logger2.debug("[generator] Selected creatures", {
    count: result.length,
    totalXP: bestXP,
    budget: `${minXP}-${maxXP}`,
    creatures: result.map((c) => `${c.name} x${c.count}`)
  });
  return result;
}
function generateRandomEncounter(ctx, options) {
  logger2.info("[generator] Starting encounter generation", {
    partyLevel: options.partyLevel,
    partySize: options.partySize,
    difficulty: options.difficulty,
    availableCreatures: ctx.creatures.length
  });
  const { creatures: filteredCreatures, filterLevel } = filterCreaturesByTags(ctx);
  if (filteredCreatures.length === 0) {
    logger2.error("[generator] No matching creatures found");
    return { creatures: [], totalXP: 0, filterLevel: 4 };
  }
  const budget = calculateCreatureBudget(options);
  const selectedCreatures = selectCreaturesForBudget(filteredCreatures, budget, options);
  const totalXP = selectedCreatures.reduce((sum, creature) => {
    const xpPerCreature = XP_BY_CR[creature.cr] ?? 0;
    return sum + xpPerCreature * creature.count;
  }, 0);
  logger2.info("[generator] Encounter generated successfully", {
    creatureCount: selectedCreatures.length,
    totalCreatures: selectedCreatures.reduce((sum, c) => sum + c.count, 0),
    totalXP,
    filterLevel
  });
  return {
    creatures: selectedCreatures,
    totalXP,
    filterLevel
  };
}
function seededRandom(seed) {
  let state = seed;
  return () => {
    state = (state * 1664525 + 1013904223) % 4294967296;
    return state / 4294967296;
  };
}
var XP_THRESHOLDS, XP_BY_CR;
var init_generator = __esm({
  "src/workmodes/encounter/generator.ts"() {
    "use strict";
    init_plugin_logger();
    XP_THRESHOLDS = {
      easy: [25, 50, 75, 125, 250, 300, 350, 450, 550, 600, 800, 1e3, 1100, 1250, 1400, 1600, 2e3, 2100, 2400, 2800],
      medium: [50, 100, 150, 250, 500, 600, 750, 900, 1100, 1200, 1600, 2e3, 2200, 2500, 2800, 3200, 3900, 4200, 4900, 5700],
      hard: [75, 150, 225, 375, 750, 900, 1100, 1400, 1600, 1900, 2400, 3e3, 3400, 3800, 4300, 4800, 5900, 6300, 7300, 8500],
      deadly: [100, 200, 400, 500, 1100, 1400, 1700, 2100, 2400, 2800, 3600, 4500, 5100, 5700, 6400, 7200, 8800, 9500, 10900, 12700]
    };
    XP_BY_CR = {
      0: 10,
      0.125: 25,
      0.25: 50,
      0.5: 100,
      1: 200,
      2: 450,
      3: 700,
      4: 1100,
      5: 1800,
      6: 2300,
      7: 2900,
      8: 3900,
      9: 5e3,
      10: 5900,
      11: 7200,
      12: 8400,
      13: 1e4,
      14: 11500,
      15: 13e3,
      16: 15e3,
      17: 18e3,
      18: 2e4,
      19: 22e3,
      20: 25e3,
      21: 33e3,
      22: 41e3,
      23: 5e4,
      24: 62e3,
      25: 75e3,
      26: 9e4,
      27: 105e3,
      28: 12e4,
      29: 135e3,
      30: 155e3
    };
  }
});

// src/workmodes/encounter/presenter.ts
function deriveEncounterXpView(state) {
  const party = state.party ?? [];
  const baseEncounterXp = sanitizeNonNegativeNumber(state.encounterXp ?? 0);
  const partyCount = party.length;
  const basePerMember = partyCount > 0 ? baseEncounterXp / partyCount : 0;
  const globalWarnings = [];
  if (partyCount === 0 && baseEncounterXp > 0) {
    pushWarning(globalWarnings, "Encounter XP assigned but no party members present.");
  }
  const members = party.map((member) => {
    const xpToNext = calculateXpToNextLevel(member.level, member.currentXp);
    const warnings = [];
    if (xpToNext === null) {
      const sanitizedLevel = sanitizeLevel(member.level);
      if (sanitizedLevel >= 20) {
        pushWarning(warnings, "Maximum level reached.");
      } else {
        pushWarning(warnings, "XP threshold for next level unavailable.");
      }
    }
    return {
      member,
      baseXp: basePerMember,
      modifiersDelta: 0,
      totalXp: basePerMember,
      xpToNextLevel: xpToNext,
      warnings
    };
  });
  const ruleViews = [];
  for (const rule of state.rules ?? []) {
    const ruleWarnings = [];
    const perMemberDeltas = [];
    let totalDelta = 0;
    if (!rule.enabled) {
      for (const member of members) {
        perMemberDeltas.push({
          memberId: member.member.id,
          memberName: member.member.name,
          delta: 0
        });
      }
      ruleViews.push({ rule, totalDelta, perMemberDeltas, warnings: ruleWarnings });
      continue;
    }
    if (!partyCount) {
      if (rule.modifierValue !== 0) {
        pushWarning(ruleWarnings, "Rule effect ignored because no party members are present.");
      }
      ruleViews.push({ rule, totalDelta, perMemberDeltas, warnings: ruleWarnings });
      for (const warning of ruleWarnings) {
        pushWarning(globalWarnings, warning);
      }
      continue;
    }
    if (rule.scope !== "xp") {
      for (const member of members) {
        perMemberDeltas.push({
          memberId: member.member.id,
          memberName: member.member.name,
          delta: 0
        });
      }
      ruleViews.push({ rule, totalDelta, perMemberDeltas, warnings: ruleWarnings });
      continue;
    }
    const appendMemberDelta = (member, delta) => {
      member.modifiersDelta += delta;
      member.totalXp += delta;
      perMemberDeltas.push({
        memberId: member.member.id,
        memberName: member.member.name,
        delta
      });
      totalDelta += delta;
    };
    switch (rule.modifierType) {
      case "flat": {
        const perMember = rule.modifierValue / partyCount;
        for (const member of members) {
          appendMemberDelta(member, perMember);
        }
        break;
      }
      case "flatPerAverageLevel": {
        let totalLevels = 0;
        for (const member of members) {
          totalLevels += sanitizeLevel(member.member.level);
        }
        const averageLevel = totalLevels / partyCount;
        const totalAverageDelta = rule.modifierValue * averageLevel;
        const perMember = totalAverageDelta / partyCount;
        for (const member of members) {
          appendMemberDelta(member, perMember);
        }
        break;
      }
      case "flatPerTotalLevel": {
        for (const member of members) {
          const sanitizedLevel = sanitizeLevel(member.member.level);
          const delta = rule.modifierValue * sanitizedLevel;
          appendMemberDelta(member, delta);
        }
        break;
      }
      case "percentTotal": {
        const percent = rule.modifierValue / 100;
        for (const member of members) {
          const delta = member.totalXp * percent;
          appendMemberDelta(member, delta);
        }
        break;
      }
      case "percentNextLevel": {
        let aggregateNext = 0;
        for (const member of members) {
          if (member.xpToNextLevel == null) {
            pushWarning(ruleWarnings, `${member.member.name} has no next-level XP threshold.`);
            continue;
          }
          aggregateNext += member.xpToNextLevel;
        }
        if (aggregateNext === 0) {
          for (const member of members) {
            perMemberDeltas.push({
              memberId: member.member.id,
              memberName: member.member.name,
              delta: 0
            });
          }
          break;
        }
        const total = aggregateNext * (rule.modifierValue / 100);
        const perMember = total / partyCount;
        for (const member of members) {
          appendMemberDelta(member, perMember);
        }
        break;
      }
    }
    ruleViews.push({ rule, totalDelta, perMemberDeltas, warnings: ruleWarnings });
    for (const warning of ruleWarnings) {
      pushWarning(globalWarnings, warning);
    }
  }
  const finalParty = members.map((member) => ({
    member: member.member,
    baseXp: member.baseXp,
    modifiersDelta: member.modifiersDelta,
    totalXp: member.totalXp,
    xpToNextLevel: member.xpToNextLevel,
    warnings: member.warnings
  }));
  const totalEncounterXp = finalParty.reduce((sum, member) => sum + member.totalXp, 0);
  return {
    baseEncounterXp,
    totalEncounterXp,
    party: finalParty,
    rules: ruleViews,
    warnings: globalWarnings
  };
}
function calculateXpToNextLevel(level, currentXp) {
  const sanitizedLevel = sanitizeLevel(level);
  if (sanitizedLevel >= 20) {
    return null;
  }
  const currentThreshold = DND5E_XP_THRESHOLDS[sanitizedLevel];
  const nextThreshold = DND5E_XP_THRESHOLDS[sanitizedLevel + 1];
  if (typeof currentThreshold !== "number" || typeof nextThreshold !== "number") {
    return null;
  }
  const effectiveCurrentXp = sanitizeOptionalNonNegativeNumber(currentXp) ?? currentThreshold;
  if (effectiveCurrentXp >= nextThreshold) {
    return 0;
  }
  return nextThreshold - effectiveCurrentXp;
}
function sanitizeRuleScope(scope) {
  if (scope === "gold") {
    return "gold";
  }
  return "xp";
}
function sanitizeNumber(value) {
  if (typeof value !== "number" || !Number.isFinite(value)) {
    return 0;
  }
  return value;
}
function sanitizeNonNegativeNumber(value) {
  const numeric = sanitizeNumber(value);
  return numeric < 0 ? 0 : numeric;
}
function sanitizeOptionalNonNegativeNumber(value) {
  if (value === null || value === void 0) {
    return void 0;
  }
  return sanitizeNonNegativeNumber(value);
}
function sanitizeLevel(level) {
  const numeric = Math.floor(sanitizeNumber(level));
  return numeric < 1 ? 1 : numeric;
}
function clampPercentage(value) {
  if (!Number.isFinite(value)) {
    return 0;
  }
  if (value > 100) return 100;
  if (value < -100) return -100;
  return value;
}
function clampIndex(index, length) {
  if (length <= 0) return 0;
  if (!Number.isFinite(index)) return 0;
  const truncated = Math.trunc(index);
  if (truncated < 0) return 0;
  if (truncated >= length) return length - 1;
  return truncated;
}
function clampToRange(value, range) {
  if (value < range.min) return range.min;
  if (value > range.max) return range.max;
  return value;
}
function rollBetween(min, max) {
  if (max <= min) {
    return min;
  }
  return min + (max - min) * Math.random();
}
function pushWarning(collection, warning) {
  if (!warning) return;
  if (!collection.includes(warning)) {
    collection.push(warning);
  }
}
function shallowEqualPartyMembers(a, b) {
  return a.id === b.id && a.name === b.name && a.level === b.level && (a.currentXp ?? void 0) === (b.currentXp ?? void 0);
}
function shallowEqualRules(a, b) {
  return a.id === b.id && a.title === b.title && a.modifierType === b.modifierType && a.modifierValue === b.modifierValue && a.modifierValueMin === b.modifierValueMin && a.modifierValueMax === b.modifierValueMax && a.enabled === b.enabled && a.scope === b.scope && (a.notes ?? "") === (b.notes ?? "");
}
var defaultDeps, EncounterPresenter;
var init_presenter = __esm({
  "src/workmodes/encounter/presenter.ts"() {
    "use strict";
    init_session_store();
    defaultDeps = {
      now: () => (/* @__PURE__ */ new Date()).toISOString()
    };
    EncounterPresenter = class _EncounterPresenter {
      constructor(initial, deps) {
        this.listeners = /* @__PURE__ */ new Set();
        this.deps = { ...defaultDeps, ...deps };
        this.persisted = _EncounterPresenter.normalise(initial);
        this.viewState = _EncounterPresenter.createViewState(this.persisted);
        this.unsubscribeStore = subscribeToEncounterEvents((event) => this.applyEvent(event));
        this.unsubscribeXpStore = subscribeEncounterXpState((xp) => this.applyXpState(xp));
        if (initial?.xp) {
          replaceEncounterXpState(this.persisted.xp);
        }
      }
      dispose() {
        this.unsubscribeStore?.();
        this.unsubscribeXpStore?.();
        this.listeners.clear();
      }
      /** Restores persisted state (e.g. when `setViewData` fires before `onOpen`). */
      restore(state) {
        const normalisedSession = _EncounterPresenter.normaliseSession(state?.session);
        this.persisted = {
          ...this.persisted,
          session: normalisedSession
        };
        if (state?.xp) {
          replaceEncounterXpState(_EncounterPresenter.normaliseXpState(state.xp));
        } else {
          this.emit();
        }
      }
      getState() {
        return this.viewState;
      }
      subscribe(listener) {
        this.listeners.add(listener);
        listener(this.viewState);
        return () => {
          this.listeners.delete(listener);
        };
      }
      setNotes(notes) {
        if (!this.persisted.session) return;
        if (this.persisted.session.notes === notes) return;
        this.persisted = {
          ...this.persisted,
          session: {
            ...this.persisted.session,
            notes
          }
        };
        this.emit();
      }
      markResolved() {
        const session = this.persisted.session;
        if (!session) return;
        if (session.status === "resolved") return;
        this.persisted = {
          ...this.persisted,
          session: {
            ...session,
            status: "resolved",
            resolvedAt: this.deps.now()
          }
        };
        this.emit();
      }
      reset() {
        if (!this.persisted.session) return;
        this.persisted = {
          ...this.persisted,
          session: null
        };
        this.emit();
      }
      addCreature(creature) {
        let session = this.persisted.session;
        if (!session) {
          session = this.createDefaultManualSession();
          this.persisted = {
            ...this.persisted,
            session
          };
        }
        const sanitized = {
          ...creature,
          count: Math.max(1, Math.floor(creature.count)),
          cr: Math.max(0, creature.cr)
        };
        const existing = session.creatures.find((c) => c.id === sanitized.id);
        if (existing) {
          this.updateCreature(sanitized.id, { count: existing.count + sanitized.count });
          return;
        }
        this.persisted = {
          ...this.persisted,
          session: {
            ...session,
            creatures: [...session.creatures, sanitized]
          }
        };
        this.updateEncounterXpFromCreatures();
      }
      updateCreature(id, patch) {
        const session = this.persisted.session;
        if (!session) return;
        const index = session.creatures.findIndex((c) => c.id === id);
        if (index === -1) return;
        const existing = session.creatures[index];
        const updated = {
          ...existing,
          ...patch,
          count: patch.count !== void 0 ? Math.max(1, Math.floor(patch.count)) : existing.count,
          cr: patch.cr !== void 0 ? Math.max(0, patch.cr) : existing.cr
        };
        const nextCreatures = [...session.creatures];
        nextCreatures[index] = updated;
        this.persisted = {
          ...this.persisted,
          session: {
            ...session,
            creatures: nextCreatures
          }
        };
        this.updateEncounterXpFromCreatures();
      }
      removeCreature(id) {
        const session = this.persisted.session;
        if (!session) return;
        const filtered = session.creatures.filter((c) => c.id !== id);
        if (filtered.length === session.creatures.length) return;
        this.persisted = {
          ...this.persisted,
          session: {
            ...session,
            creatures: filtered
          }
        };
        this.updateEncounterXpFromCreatures();
      }
      updateEncounterXpFromCreatures() {
        const session = this.persisted.session;
        if (!session) return;
        const xpByCr = {
          0: 10,
          0.125: 25,
          0.25: 50,
          0.5: 100,
          1: 200,
          2: 450,
          3: 700,
          4: 1100,
          5: 1800,
          6: 2300,
          7: 2900,
          8: 3900,
          9: 5e3,
          10: 5900,
          11: 7200,
          12: 8400,
          13: 1e4,
          14: 11500,
          15: 13e3,
          16: 15e3,
          17: 18e3,
          18: 2e4,
          19: 22e3,
          20: 25e3,
          21: 33e3,
          22: 41e3,
          23: 5e4,
          24: 62e3,
          25: 75e3,
          26: 9e4,
          27: 105e3,
          28: 12e4,
          29: 135e3,
          30: 155e3
        };
        const totalXp = session.creatures.reduce((sum, creature) => {
          const xpPerCreature = xpByCr[creature.cr] ?? 0;
          return sum + xpPerCreature * creature.count;
        }, 0);
        this.setEncounterXp(totalXp);
        this.emit();
      }
      // ============================================================================
      // Random Encounter Generation (Phase 2.6)
      // ============================================================================
      /**
       * Generates a random encounter based on current travel context.
       *
       * @param difficulty Encounter difficulty (easy/medium/hard/deadly)
       * @param app Obsidian App instance (for loading creatures from library)
       * @param clearExisting If true, removes existing creatures before adding generated ones
       * @returns Generated creatures or error
       */
      async generateEncounter(difficulty, app, clearExisting = false) {
        let session = this.persisted.session;
        if (!session) {
          session = this.createDefaultManualSession();
          this.persisted = {
            ...this.persisted,
            session
          };
        }
        try {
          const { generateRandomEncounter: generateRandomEncounter2 } = await Promise.resolve().then(() => (init_generator(), generator_exports));
          const { LIBRARY_DATA_SOURCES: LIBRARY_DATA_SOURCES2 } = await Promise.resolve().then(() => (init_data_sources(), data_sources_exports));
          const { loadRegions: loadRegions3 } = await Promise.resolve().then(() => (init_region_repository(), region_repository_exports));
          const { loadTerrains: loadTerrains3 } = await Promise.resolve().then(() => (init_terrain_repository(), terrain_repository_exports));
          const event = session.event;
          const factionName = event.factionName;
          const regionName = event.regionName;
          const terrainName = event.terrainName;
          const [allCreatures, allFactions, allRegions, allTerrains] = await Promise.all([
            LIBRARY_DATA_SOURCES2.creatures.list(app).then(
              (files) => Promise.all(files.map((f) => LIBRARY_DATA_SOURCES2.creatures.load(app, f)))
            ),
            LIBRARY_DATA_SOURCES2.factions.list(app).then(
              (files) => Promise.all(files.map((f) => LIBRARY_DATA_SOURCES2.factions.load(app, f)))
            ),
            loadRegions3(app),
            loadTerrains3(app)
          ]);
          const faction = factionName ? allFactions.find((f) => f.name.toLowerCase() === factionName.toLowerCase()) : null;
          const region = regionName ? allRegions.find((r) => r.name.toLowerCase() === regionName.toLowerCase()) : null;
          const terrain = terrainName ? allTerrains.find((t) => t.name.toLowerCase() === terrainName.toLowerCase()) : null;
          const xpState = getEncounterXpState();
          const partyMembers = xpState.party ?? [];
          if (partyMembers.length === 0) {
            return { success: false, error: "No party members configured. Add party members first." };
          }
          const partyLevel = Math.round(
            partyMembers.reduce((sum, m) => sum + m.level, 0) / partyMembers.length
          );
          const partySize = partyMembers.length;
          const result = generateRandomEncounter2(
            {
              faction: faction ?? null,
              terrain: terrain ?? null,
              region: region ?? null,
              creatures: allCreatures
            },
            {
              partyLevel,
              partySize,
              difficulty
            }
          );
          if (result.creatures.length === 0) {
            return { success: false, error: "No matching creatures found for this context." };
          }
          if (clearExisting && session.creatures.length > 0) {
            this.persisted = {
              ...this.persisted,
              session: {
                ...session,
                creatures: []
              }
            };
          }
          for (const creature of result.creatures) {
            this.addCreature(creature);
          }
          return { success: true, creatures: result.creatures };
        } catch (err) {
          return {
            success: false,
            error: err?.message ?? "Unknown error during generation"
          };
        }
      }
      /**
       * Loads faction members as CreatureListItems for display in Encounter Composer.
       *
       * @param factionName Name of the faction to load members from
       * @param app Obsidian App instance (for loading creatures from library)
       * @returns Array of CreatureListItems representing faction members
       */
      async loadFactionMembers(factionName, app) {
        if (!factionName) return [];
        try {
          const { LIBRARY_DATA_SOURCES: LIBRARY_DATA_SOURCES2 } = await Promise.resolve().then(() => (init_data_sources(), data_sources_exports));
          const allFactions = await LIBRARY_DATA_SOURCES2.factions.list(app).then(
            (files) => Promise.all(files.map((f) => LIBRARY_DATA_SOURCES2.factions.load(app, f)))
          );
          const faction = allFactions.find((f) => f.name.toLowerCase() === factionName.toLowerCase());
          if (!faction || !faction.members || faction.members.length === 0) {
            return [];
          }
          const allCreatures = await LIBRARY_DATA_SOURCES2.creatures.list(app).then(
            (files) => Promise.all(files.map((f) => LIBRARY_DATA_SOURCES2.creatures.load(app, f)))
          );
          const result = [];
          for (const member of faction.members) {
            const creature = allCreatures.find((c) => c.name.toLowerCase() === member.name.toLowerCase());
            if (!creature) {
              logger.warn(`[presenter] Faction member "${member.name}" not found in library`);
              continue;
            }
            const crString = creature.cr;
            let cr = 0;
            if (crString) {
              if (crString.includes("/")) {
                const [num, denom] = crString.split("/").map((s) => Number(s.trim()));
                if (Number.isFinite(num) && Number.isFinite(denom) && denom !== 0) {
                  cr = num / denom;
                }
              } else {
                const num = Number(crString);
                if (Number.isFinite(num)) cr = num;
              }
            }
            result.push({
              name: creature.name,
              cr,
              type: creature.type,
              path: `SaltMarcher/Creatures/${creature.name}.md`
              // TODO: Get actual path from file
            });
          }
          logger.debug(`[presenter] Loaded ${result.length} faction members for "${factionName}"`);
          return result;
        } catch (err) {
          logger.error(`[presenter] Failed to load faction members for "${factionName}"`, err);
          return [];
        }
      }
      // ============================================================================
      // Combat Tracking Methods
      // ============================================================================
      startCombat() {
        const session = this.persisted.session;
        if (!session) return;
        if (session.combat?.isActive) return;
        const participants = [];
        for (const creature of session.creatures) {
          for (let i = 0; i < creature.count; i++) {
            const participantId = `${creature.id}-${i}`;
            const name = creature.count > 1 ? `${creature.name} ${i + 1}` : creature.name;
            participants.push({
              id: participantId,
              creatureId: creature.id,
              name,
              initiative: 0,
              currentHp: 0,
              // UI will prompt for max HP
              maxHp: 0,
              defeated: false
            });
          }
        }
        const combat = {
          isActive: true,
          participants: Object.freeze(participants),
          activeParticipantId: null
        };
        this.persisted = {
          ...this.persisted,
          session: {
            ...session,
            combat
          }
        };
        this.emit();
      }
      endCombat() {
        const session = this.persisted.session;
        if (!session) return;
        if (!session.combat?.isActive) return;
        this.persisted = {
          ...this.persisted,
          session: {
            ...session,
            combat: null
          }
        };
        this.emit();
      }
      updateParticipantInitiative(id, initiative) {
        const session = this.persisted.session;
        if (!session?.combat) return;
        const sanitized = sanitizeNumber(initiative);
        const participants = [...session.combat.participants];
        const index = participants.findIndex((p) => p.id === id);
        if (index === -1) return;
        participants[index] = { ...participants[index], initiative: sanitized };
        this.persisted = {
          ...this.persisted,
          session: {
            ...session,
            combat: {
              ...session.combat,
              participants: Object.freeze(participants)
            }
          }
        };
        this.emit();
      }
      updateParticipantHp(id, currentHp, maxHp) {
        const session = this.persisted.session;
        if (!session?.combat) return;
        const sanitizedCurrent = sanitizeNonNegativeNumber(currentHp);
        const participants = [...session.combat.participants];
        const index = participants.findIndex((p) => p.id === id);
        if (index === -1) return;
        const participant = participants[index];
        const sanitizedMax = maxHp !== void 0 ? sanitizeNonNegativeNumber(maxHp) : participant.maxHp;
        const clampedCurrent = Math.min(sanitizedCurrent, sanitizedMax);
        participants[index] = {
          ...participant,
          currentHp: clampedCurrent,
          maxHp: sanitizedMax,
          defeated: clampedCurrent <= 0
        };
        this.persisted = {
          ...this.persisted,
          session: {
            ...session,
            combat: {
              ...session.combat,
              participants: Object.freeze(participants)
            }
          }
        };
        this.emit();
      }
      applyDamage(id, amount) {
        const session = this.persisted.session;
        if (!session?.combat) return;
        const participants = [...session.combat.participants];
        const index = participants.findIndex((p) => p.id === id);
        if (index === -1) return;
        const participant = participants[index];
        const sanitizedAmount = sanitizeNonNegativeNumber(amount);
        const newHp = Math.max(0, participant.currentHp - sanitizedAmount);
        participants[index] = {
          ...participant,
          currentHp: newHp,
          defeated: newHp <= 0
        };
        this.persisted = {
          ...this.persisted,
          session: {
            ...session,
            combat: {
              ...session.combat,
              participants: Object.freeze(participants)
            }
          }
        };
        this.emit();
      }
      applyHealing(id, amount) {
        const session = this.persisted.session;
        if (!session?.combat) return;
        const participants = [...session.combat.participants];
        const index = participants.findIndex((p) => p.id === id);
        if (index === -1) return;
        const participant = participants[index];
        const sanitizedAmount = sanitizeNonNegativeNumber(amount);
        const newHp = Math.min(participant.maxHp, participant.currentHp + sanitizedAmount);
        participants[index] = {
          ...participant,
          currentHp: newHp,
          defeated: newHp <= 0
        };
        this.persisted = {
          ...this.persisted,
          session: {
            ...session,
            combat: {
              ...session.combat,
              participants: Object.freeze(participants)
            }
          }
        };
        this.emit();
      }
      toggleDefeated(id) {
        const session = this.persisted.session;
        if (!session?.combat) return;
        const participants = [...session.combat.participants];
        const index = participants.findIndex((p) => p.id === id);
        if (index === -1) return;
        const participant = participants[index];
        participants[index] = {
          ...participant,
          defeated: !participant.defeated
        };
        this.persisted = {
          ...this.persisted,
          session: {
            ...session,
            combat: {
              ...session.combat,
              participants: Object.freeze(participants)
            }
          }
        };
        this.emit();
      }
      setActiveParticipant(id) {
        const session = this.persisted.session;
        if (!session?.combat) return;
        if (session.combat.activeParticipantId === id) return;
        this.persisted = {
          ...this.persisted,
          session: {
            ...session,
            combat: {
              ...session.combat,
              activeParticipantId: id
            }
          }
        };
        this.emit();
      }
      sortParticipantsByInitiative() {
        const session = this.persisted.session;
        if (!session?.combat) return;
        const sorted = [...session.combat.participants].sort((a, b) => b.initiative - a.initiative);
        this.persisted = {
          ...this.persisted,
          session: {
            ...session,
            combat: {
              ...session.combat,
              participants: Object.freeze(sorted)
            }
          }
        };
        this.emit();
      }
      setEncounterXp(value) {
        const sanitized = sanitizeNonNegativeNumber(value);
        if (sanitized === this.persisted.xp.encounterXp) return;
        setEncounterXp(sanitized);
      }
      addPartyMember(member) {
        const sanitized = _EncounterPresenter.normalisePartyMember(member);
        if (this.persisted.xp.party.some((existing) => existing.id === sanitized.id)) {
          this.updatePartyMember(sanitized.id, sanitized);
          return;
        }
        addPartyMember(sanitized);
      }
      updatePartyMember(id, patch) {
        const existing = this.persisted.xp.party.find((member) => member.id === id);
        if (!existing) return;
        const sanitizedPatch = _EncounterPresenter.normalisePartyMemberPatch(patch, existing);
        const next = { ...existing, ...sanitizedPatch };
        if (shallowEqualPartyMembers(existing, next)) return;
        updatePartyMember(id, sanitizedPatch);
      }
      removePartyMember(id) {
        if (!this.persisted.xp.party.some((member) => member.id === id)) return;
        removePartyMember(id);
      }
      removeRule(id) {
        if (!this.persisted.xp.rules.some((rule) => rule.id === id)) return;
        removeRule(id);
      }
      addRule(rule) {
        const sanitized = _EncounterPresenter.normaliseRule(rule);
        if (this.persisted.xp.rules.some((existing) => existing.id === sanitized.id)) {
          this.updateRule(sanitized.id, sanitized);
          return;
        }
        addRule(sanitized);
      }
      updateRule(id, patch) {
        const existing = this.persisted.xp.rules.find((rule) => rule.id === id);
        if (!existing) return;
        const sanitizedPatch = _EncounterPresenter.normaliseRulePatch(patch, existing);
        const next = { ...existing, ...sanitizedPatch };
        if (shallowEqualRules(existing, next)) return;
        updateRule(id, sanitizedPatch);
      }
      toggleRule(id, enabled) {
        const existing = this.persisted.xp.rules.find((rule) => rule.id === id);
        if (!existing) return;
        const nextEnabled = enabled ?? !existing.enabled;
        if (existing.enabled === nextEnabled) return;
        updateRule(id, { enabled: nextEnabled });
      }
      replaceRules(rules) {
        const sanitized = rules.map((rule) => _EncounterPresenter.normaliseRule(rule));
        updateEncounterXpState((draft) => {
          draft.rules = sanitized.map((rule) => ({ ...rule }));
        });
      }
      moveRule(id, targetIndex) {
        updateEncounterXpState((draft) => {
          const currentIndex = draft.rules.findIndex((rule2) => rule2.id === id);
          if (currentIndex === -1) return;
          const normalisedIndex = clampIndex(targetIndex, draft.rules.length);
          if (normalisedIndex === currentIndex) return;
          const [rule] = draft.rules.splice(currentIndex, 1);
          draft.rules.splice(normalisedIndex, 0, rule);
        });
      }
      resetXpState() {
        replaceEncounterXpState({
          party: [],
          encounterXp: 0,
          rules: []
        });
      }
      applyEvent(event) {
        const prev = this.persisted.session;
        if (!prev || prev.event.id !== event.id) {
          this.persisted = {
            ...this.persisted,
            session: {
              event,
              notes: "",
              status: "pending",
              creatures: []
            }
          };
        } else {
          this.persisted = {
            ...this.persisted,
            session: {
              ...prev,
              event
            }
          };
        }
        this.emit();
      }
      applyXpState(xp) {
        this.persisted = {
          ...this.persisted,
          xp: _EncounterPresenter.normaliseXpState(xp)
        };
        this.emit();
      }
      emit() {
        this.viewState = _EncounterPresenter.createViewState(this.persisted);
        for (const listener of [...this.listeners]) {
          listener(this.viewState);
        }
      }
      /**
       * Creates a default manual session for encounters composed without a travel context.
       * This allows users to open the Calculator directly and manually add creatures.
       */
      createDefaultManualSession() {
        const event = {
          id: `manual-${Date.now()}`,
          source: "manual",
          triggeredAt: this.deps.now(),
          coord: null
        };
        return {
          event,
          notes: "",
          status: "pending",
          creatures: [],
          combat: null
        };
      }
      static normalise(initial) {
        return {
          session: _EncounterPresenter.normaliseSession(initial?.session),
          xp: _EncounterPresenter.normaliseXpState(initial?.xp ?? getEncounterXpState())
        };
      }
      static createViewState(persisted) {
        return {
          session: persisted.session,
          xp: persisted.xp,
          xpView: deriveEncounterXpView(persisted.xp)
        };
      }
      static normaliseSession(session) {
        if (!session || !session.event) {
          return null;
        }
        const status = session.status === "resolved" ? "resolved" : "pending";
        const creatures = (session.creatures ?? []).map((creature) => ({
          ...creature,
          count: Math.max(1, Math.floor(creature.count)),
          cr: Math.max(0, creature.cr)
        }));
        const combat = session.combat ? _EncounterPresenter.normaliseCombat(session.combat) : null;
        return {
          event: session.event,
          notes: session.notes ?? "",
          status,
          resolvedAt: session.resolvedAt ?? null,
          creatures,
          combat
        };
      }
      static normaliseCombat(combat) {
        const participants = (combat.participants ?? []).map((participant) => ({
          ...participant,
          initiative: sanitizeNumber(participant.initiative),
          currentHp: sanitizeNonNegativeNumber(participant.currentHp),
          maxHp: sanitizeNonNegativeNumber(participant.maxHp),
          defeated: !!participant.defeated
        }));
        return {
          isActive: !!combat.isActive,
          participants: Object.freeze(participants),
          activeParticipantId: combat.activeParticipantId ?? null
        };
      }
      static normaliseXpState(xp) {
        const baseEncounterXp = sanitizeNonNegativeNumber(xp?.encounterXp ?? 0);
        const party = Object.freeze((xp?.party ?? []).map((member) => ({
          ..._EncounterPresenter.normalisePartyMember(member)
        })));
        const rules = Object.freeze((xp?.rules ?? []).map((rule) => ({
          ..._EncounterPresenter.normaliseRule(rule)
        })));
        return {
          party,
          encounterXp: baseEncounterXp,
          rules
        };
      }
      static normalisePartyMember(member) {
        return {
          ...member,
          level: sanitizeLevel(member.level),
          currentXp: sanitizeOptionalNonNegativeNumber(member.currentXp)
        };
      }
      static normalisePartyMemberPatch(patch, existing) {
        const next = {};
        if (patch.name !== void 0) {
          next.name = patch.name;
        }
        if (patch.level !== void 0) {
          next.level = sanitizeLevel(patch.level);
        }
        if (patch.currentXp !== void 0) {
          next.currentXp = sanitizeOptionalNonNegativeNumber(patch.currentXp);
        }
        if (patch.currentXp === null) {
          next.currentXp = void 0;
        }
        if (patch.id !== void 0 && patch.id !== existing.id) {
          next.id = existing.id;
        }
        return next;
      }
      static normaliseRule(rule) {
        const modifierType = rule.modifierType;
        const sanitizedValue = _EncounterPresenter.normaliseRuleModifierValue(modifierType, rule.modifierValue);
        const range = _EncounterPresenter.normaliseRuleModifierRange(
          modifierType,
          rule.modifierValueMin,
          rule.modifierValueMax,
          sanitizedValue
        );
        return {
          ...rule,
          modifierType,
          modifierValue: clampToRange(sanitizedValue, range),
          modifierValueMin: range.min,
          modifierValueMax: range.max,
          enabled: rule.enabled !== false,
          scope: sanitizeRuleScope(rule.scope),
          notes: rule.notes ?? (rule.notes === "" ? "" : void 0)
        };
      }
      static normaliseRulePatch(patch, existing) {
        const next = {};
        if (patch.title !== void 0) {
          next.title = patch.title;
        }
        if (patch.scope !== void 0) {
          next.scope = sanitizeRuleScope(patch.scope);
        }
        if (patch.notes !== void 0) {
          next.notes = patch.notes;
        }
        const modifierType = patch.modifierType ?? existing.modifierType;
        if (patch.modifierType !== void 0) {
          next.modifierType = modifierType;
        }
        const hasRangeUpdate = patch.modifierValueMin !== void 0 || patch.modifierValueMax !== void 0 || patch.modifierType !== void 0;
        let range = null;
        if (hasRangeUpdate) {
          range = _EncounterPresenter.normaliseRuleModifierRange(
            modifierType,
            patch.modifierValueMin ?? existing.modifierValueMin,
            patch.modifierValueMax ?? existing.modifierValueMax,
            existing.modifierValue
          );
          next.modifierValueMin = range.min;
          next.modifierValueMax = range.max;
        }
        if (patch.modifierValue !== void 0) {
          const sanitized = _EncounterPresenter.normaliseRuleModifierValue(modifierType, patch.modifierValue);
          if (range) {
            next.modifierValue = clampToRange(sanitized, range);
          } else {
            const currentRange = _EncounterPresenter.normaliseRuleModifierRange(
              modifierType,
              existing.modifierValueMin,
              existing.modifierValueMax,
              existing.modifierValue
            );
            next.modifierValue = clampToRange(sanitized, currentRange);
          }
        } else if (range) {
          const sanitizedExisting = _EncounterPresenter.normaliseRuleModifierValue(
            modifierType,
            existing.modifierValue
          );
          if ((patch.modifierValueMin !== void 0 || patch.modifierValueMax !== void 0) && range.min !== range.max) {
            next.modifierValue = rollBetween(range.min, range.max);
          } else {
            const clamped = clampToRange(sanitizedExisting, range);
            if (clamped !== existing.modifierValue) {
              next.modifierValue = clamped;
            }
          }
        }
        if (patch.enabled !== void 0) {
          next.enabled = !!patch.enabled;
        }
        return next;
      }
      static normaliseRuleModifierValue(type2, value) {
        if (type2 === "flat" || type2 === "flatPerAverageLevel" || type2 === "flatPerTotalLevel") {
          return sanitizeNumber(value);
        }
        return clampPercentage(sanitizeNumber(value));
      }
      static normaliseRuleModifierRange(type2, min, max, fallback) {
        const sanitizedFallback = _EncounterPresenter.normaliseRuleModifierValue(type2, fallback);
        const hasMin = min !== null && min !== void 0;
        const hasMax = max !== null && max !== void 0;
        const sanitizedMin = hasMin ? _EncounterPresenter.normaliseRuleModifierValue(type2, min) : sanitizedFallback;
        const sanitizedMax = hasMax ? _EncounterPresenter.normaliseRuleModifierValue(type2, max) : sanitizedFallback;
        if (sanitizedMin > sanitizedMax) {
          return { min: sanitizedMax, max: sanitizedMin };
        }
        return { min: sanitizedMin, max: sanitizedMax };
      }
    };
  }
});

// src/workmodes/encounter/rule-presets.ts
async function ensureEncounterRulePresetDir(app) {
  const normalized = (0, import_obsidian33.normalizePath)(ENCOUNTER_RULE_PRESET_DIR);
  let file = app.vault.getAbstractFileByPath(normalized);
  if (file instanceof import_obsidian33.TFolder) return file;
  await app.vault.createFolder(normalized).catch(() => {
  });
  file = app.vault.getAbstractFileByPath(normalized);
  if (file instanceof import_obsidian33.TFolder) return file;
  throw new Error(`Could not ensure encounter preset directory: ${normalized}`);
}
async function listEncounterRulePresets(app) {
  const dir = await ensureEncounterRulePresetDir(app);
  const files = [];
  const walk = (folder) => {
    for (const child of folder.children) {
      if (child instanceof import_obsidian33.TFolder) walk(child);
      else if (child instanceof import_obsidian33.TFile && child.extension === "md") files.push(child);
    }
  };
  walk(dir);
  const summaries = files.map((file) => {
    const cache = app.metadataCache.getFileCache(file);
    const fm2 = cache?.frontmatter ?? {};
    const name = typeof fm2.name === "string" && fm2.name.trim() ? fm2.name.trim() : file.basename;
    const encounterXp = typeof fm2.encounterXp === "number" ? fm2.encounterXp : void 0;
    return { file, name, encounterXp };
  });
  summaries.sort((a, b) => a.name.localeCompare(b.name, void 0, { sensitivity: "base" }));
  return summaries;
}
async function loadEncounterRulePreset(app, file) {
  const cache = app.metadataCache.getFileCache(file);
  const fm2 = cache?.frontmatter ?? {};
  const name = typeof fm2.name === "string" && fm2.name.trim() ? fm2.name.trim() : file.basename;
  const encounterXp = typeof fm2.encounterXp === "number" ? fm2.encounterXp : void 0;
  const rules = parsePresetRules(fm2.rules);
  return { name, encounterXp, rules };
}
async function saveEncounterRulePreset(app, doc, options = {}) {
  const sanitizedName = sanitizePresetName(doc.name);
  const content = serializePreset(doc, sanitizedName);
  const dir = await ensureEncounterRulePresetDir(app);
  if (options.path) {
    const existing = app.vault.getAbstractFileByPath(options.path);
    if (existing instanceof import_obsidian33.TFile) {
      await app.vault.modify(existing, content);
      return existing;
    }
  }
  const baseName = sanitizeFileName2(sanitizedName, DEFAULT_PRESET_NAME);
  let fileName = `${baseName}.md`;
  let targetPath = (0, import_obsidian33.normalizePath)(`${dir.path}/${fileName}`);
  let counter = 2;
  while (app.vault.getAbstractFileByPath(targetPath)) {
    fileName = `${baseName} (${counter}).md`;
    targetPath = (0, import_obsidian33.normalizePath)(`${dir.path}/${fileName}`);
    counter += 1;
  }
  const file = await app.vault.create(targetPath, content);
  return file;
}
async function deleteEncounterRulePreset(app, file) {
  await app.vault.delete(file);
}
function parsePresetRules(raw) {
  if (!Array.isArray(raw)) return [];
  const rules = [];
  for (const entry of raw) {
    if (!entry || typeof entry !== "object") continue;
    const data = entry;
    const modifierType = parseModifierType(data.modifierType);
    const modifierValue = parseNumber(data.modifierValue, 0);
    const minValue = parseNumber(data.modifierValueMin, modifierValue);
    const maxValue = parseNumber(data.modifierValueMax, modifierValue);
    const scope = data.scope === PRESET_SCOPE_GOLD ? PRESET_SCOPE_GOLD : PRESET_SCOPE_XP;
    let notes;
    if (typeof data.notes === "string") {
      notes = data.notes;
    } else if (data.notes === "") {
      notes = "";
    }
    const id = typeof data.id === "string" && data.id.trim() ? data.id.trim() : createRuleId();
    const title = typeof data.title === "string" ? data.title : "";
    const enabled = data.enabled !== false;
    const normalisedMin = Math.min(minValue, maxValue);
    const normalisedMax = Math.max(minValue, maxValue);
    rules.push({
      id,
      title,
      modifierType,
      modifierValue,
      modifierValueMin: normalisedMin,
      modifierValueMax: normalisedMax,
      enabled,
      scope,
      notes
    });
  }
  return rules;
}
function parseModifierType(value) {
  if (typeof value === "string" && MODIFIER_TYPES.has(value)) {
    return value;
  }
  return "flat";
}
function parseNumber(value, fallback) {
  if (typeof value === "number" && Number.isFinite(value)) return value;
  if (typeof value === "string" && value.trim() !== "") {
    const numeric = Number(value);
    if (Number.isFinite(numeric)) return numeric;
  }
  return fallback;
}
function sanitizePresetName(name) {
  const trimmed = (name ?? "").trim();
  return trimmed || DEFAULT_PRESET_NAME;
}
function sanitizeFileName2(name, fallback) {
  const trimmed = name.trim();
  const base = trimmed || fallback;
  return base.replace(/[\\/:*?"<>|]/g, "-").replace(/\s+/g, " ").replace(/^\.+$/, fallback).slice(0, 120);
}
function serializePreset(doc, sanitizedName) {
  const lines = ["---", `name: ${JSON.stringify(sanitizedName)}`];
  if (typeof doc.encounterXp === "number" && Number.isFinite(doc.encounterXp)) {
    lines.push(`encounterXp: ${Number(doc.encounterXp)}`);
  }
  if (!doc.rules.length) {
    lines.push("rules: []", "---", "");
    return lines.join("\n");
  }
  lines.push("rules:");
  for (const rule of doc.rules) {
    lines.push(`  - id: ${JSON.stringify(rule.id)}`);
    lines.push(`    title: ${JSON.stringify(rule.title ?? "")}`);
    lines.push(`    modifierType: ${JSON.stringify(rule.modifierType)}`);
    lines.push(`    modifierValue: ${formatNumeric(rule.modifierValue)}`);
    lines.push(`    modifierValueMin: ${formatNumeric(rule.modifierValueMin)}`);
    lines.push(`    modifierValueMax: ${formatNumeric(rule.modifierValueMax)}`);
    lines.push(`    enabled: ${rule.enabled ? "true" : "false"}`);
    lines.push(`    scope: ${JSON.stringify(rule.scope)}`);
    if (rule.notes !== void 0) {
      lines.push(`    notes: ${JSON.stringify(rule.notes)}`);
    }
  }
  lines.push("---", "");
  return lines.join("\n");
}
function formatNumeric(value) {
  if (typeof value !== "number" || !Number.isFinite(value)) return "0";
  return Number(value).toString();
}
function createRuleId() {
  const cryptoApi = globalThis.crypto;
  if (cryptoApi?.randomUUID) {
    return `rule-${cryptoApi.randomUUID()}`;
  }
  const random = Math.random().toString(36).slice(2, 10);
  return `rule-${Date.now().toString(36)}-${random}`;
}
function isEncounterPresetFile(file) {
  if (!(file instanceof import_obsidian33.TFile)) return false;
  if (file.extension !== "md") return false;
  const normalized = (0, import_obsidian33.normalizePath)(ENCOUNTER_RULE_PRESET_DIR);
  const base = `${normalized}/`;
  return file.path === normalized || file.path.startsWith(base);
}
var import_obsidian33, ENCOUNTER_RULE_PRESET_DIR, DEFAULT_PRESET_NAME, MODIFIER_TYPES, PRESET_SCOPE_GOLD, PRESET_SCOPE_XP;
var init_rule_presets = __esm({
  "src/workmodes/encounter/rule-presets.ts"() {
    "use strict";
    import_obsidian33 = require("obsidian");
    ENCOUNTER_RULE_PRESET_DIR = "SaltMarcher/EncounterPresets";
    DEFAULT_PRESET_NAME = "Encounter Rule Preset";
    MODIFIER_TYPES = /* @__PURE__ */ new Set([
      "flat",
      "flatPerAverageLevel",
      "flatPerTotalLevel",
      "percentTotal",
      "percentNextLevel"
    ]);
    PRESET_SCOPE_GOLD = "gold";
    PRESET_SCOPE_XP = "xp";
  }
});

// src/workmodes/encounter/session-view.ts
var EncounterSessionView;
var init_session_view = __esm({
  "src/workmodes/encounter/session-view.ts"() {
    "use strict";
    EncounterSessionView = class {
      constructor(parentEl) {
        this.rootEl = null;
        this.parentEl = parentEl;
      }
      mount() {
        this.unmount();
        const section = this.parentEl.createDiv({
          cls: "sm-encounter-section sm-encounter-session sm-encounter-header"
        });
        this.rootEl = section;
        this.titleEl = section.createEl("h2", {
          cls: "sm-encounter-heading",
          text: "Encounter"
        });
        this.statusEl = section.createDiv({
          cls: "sm-encounter-status",
          text: "Waiting for travel events\u2026"
        });
        const metaEl = section.createDiv({ cls: "sm-encounter-meta" });
        this.summaryListEl = metaEl.createEl("ul", { cls: "sm-encounter-summary" });
        this.emptyStateEl = section.createDiv({
          cls: "sm-encounter-empty",
          text: "No active encounter. Travel mode will populate this workspace when an encounter triggers."
        });
      }
      unmount() {
        this.rootEl?.remove();
        this.rootEl = null;
      }
      render(session) {
        if (!this.rootEl) return;
        if (!session) {
          this.titleEl.setText("Encounter");
          this.statusEl.setText("Waiting for travel events\u2026");
          this.summaryListEl.empty();
          this.emptyStateEl.removeClass("sm-encounter-hidden");
          return;
        }
        this.emptyStateEl.addClass("sm-encounter-hidden");
        const { event, status, resolvedAt } = session;
        const region = event.regionName ?? "Unknown region";
        this.titleEl.setText(`Encounter \u2013 ${region}`);
        if (status === "resolved") {
          this.statusEl.setText(resolvedAt ? `Resolved ${resolvedAt}` : "Resolved");
        } else {
          this.statusEl.setText("Awaiting resolution");
        }
        this.summaryListEl.empty();
        const summaryEntries = [];
        if (event.coord) {
          summaryEntries.push(["Hex", `${event.coord.r}, ${event.coord.c}`]);
        }
        if (event.factionName) {
          summaryEntries.push(["Faction", event.factionName]);
        }
        if (event.mapName) {
          summaryEntries.push(["Map", event.mapName]);
        }
        if (event.mapPath) {
          summaryEntries.push(["Map path", event.mapPath]);
        }
        summaryEntries.push(["Triggered", event.triggeredAt]);
        if (typeof event.travelClockHours === "number") {
          summaryEntries.push(["Travel clock", `${event.travelClockHours.toFixed(2)} h`]);
        }
        if (typeof event.encounterOdds === "number") {
          summaryEntries.push(["Encounter odds", `1 in ${event.encounterOdds}`]);
        }
        for (const [label, value] of summaryEntries) {
          const li = this.summaryListEl.createEl("li");
          li.createSpan({ cls: "label", text: `${label}: ` });
          li.createSpan({ cls: "value", text: value });
        }
      }
    };
  }
});

// src/workmodes/encounter/creature-list.ts
function parseCR2(crString) {
  if (!crString) return 0;
  const str2 = crString.trim();
  if (str2.includes("/")) {
    const [num2, denom] = str2.split("/").map((s) => Number(s.trim()));
    if (Number.isFinite(num2) && Number.isFinite(denom) && denom !== 0) {
      return num2 / denom;
    }
  }
  const num = Number(str2);
  return Number.isFinite(num) ? num : 0;
}
function formatCR2(cr) {
  if (cr === 0.125) return "1/8";
  if (cr === 0.25) return "1/4";
  if (cr === 0.5) return "1/2";
  return String(cr);
}
var EncounterCreatureList;
var init_creature_list = __esm({
  "src/workmodes/encounter/creature-list.ts"() {
    "use strict";
    init_data_sources();
    init_plugin_logger();
    EncounterCreatureList = class {
      constructor(app, containerEl, callbacks) {
        this.creatures = [];
        this.filteredCreatures = [];
        this.currentDifficulty = "medium";
        // Faction members
        this.factionMembers = [];
        this.factionName = null;
        this.app = app;
        this.containerEl = containerEl;
        this.callbacks = callbacks;
      }
      async mount() {
        this.containerEl.empty();
        this.containerEl.addClass("sm-encounter-creature-list");
        const header = this.containerEl.createDiv({ cls: "sm-encounter-creature-list-header" });
        header.createEl("h3", { text: "Add Creatures", cls: "sm-encounter-section-title" });
        if (this.callbacks.onGenerateEncounter) {
          const generateRow = this.containerEl.createDiv({ cls: "sm-encounter-generate-row" });
          const difficultyGroup = generateRow.createDiv({ cls: "sm-encounter-generate-difficulty" });
          difficultyGroup.createEl("label", { text: "Difficulty:", cls: "sm-encounter-label" });
          this.difficultySelect = difficultyGroup.createEl("select", {
            cls: "sm-encounter-select"
          });
          const difficulties = [
            { value: "easy", label: "Easy" },
            { value: "medium", label: "Medium" },
            { value: "hard", label: "Hard" },
            { value: "deadly", label: "Deadly" }
          ];
          for (const diff of difficulties) {
            const option = this.difficultySelect.createEl("option", {
              value: diff.value,
              text: diff.label
            });
            if (diff.value === this.currentDifficulty) {
              option.selected = true;
            }
          }
          this.difficultySelect.addEventListener("change", () => {
            this.currentDifficulty = this.difficultySelect.value;
          });
          this.generateButton = generateRow.createEl("button", {
            cls: "sm-encounter-button sm-encounter-button-primary",
            text: "\u{1F3B2} Generate Random Encounter",
            attr: {
              title: "Generate encounter based on current hex (Faction, Terrain, Region)"
            }
          });
          this.generateButton.type = "button";
          this.generateButton.addEventListener("click", () => this.handleGenerateClick());
        }
        this.factionMembersSection = this.containerEl.createDiv({ cls: "sm-encounter-faction-members" });
        const searchRow = this.containerEl.createDiv({ cls: "sm-encounter-creature-search" });
        this.searchInput = searchRow.createEl("input", {
          cls: "sm-encounter-input",
          attr: {
            type: "text",
            placeholder: "Search creatures..."
          }
        });
        this.searchInput.addEventListener("input", () => this.applyFilter());
        this.listEl = this.containerEl.createDiv({ cls: "sm-encounter-creature-list-items" });
        await this.loadCreatures();
        this.renderFactionMembers();
      }
      handleGenerateClick() {
        if (!this.callbacks.onGenerateEncounter) return;
        this.setGenerateButtonState(true);
        try {
          this.callbacks.onGenerateEncounter(this.currentDifficulty);
        } catch (err) {
          logger2.error("[creature-list] Generate encounter failed", err);
          this.setGenerateButtonState(false);
        }
      }
      setGenerateButtonState(loading) {
        if (!this.generateButton) return;
        this.generateButton.disabled = loading;
        this.generateButton.setText(loading ? "Generating..." : "\u{1F3B2} Generate Random Encounter");
      }
      setGenerateButtonEnabled(enabled) {
        if (!this.generateButton) return;
        this.generateButton.disabled = !enabled;
        if (!enabled) {
          this.generateButton.setAttribute("title", "No travel context available (travel required)");
        } else {
          this.generateButton.setAttribute("title", "Generate encounter based on current hex (Faction, Terrain, Region)");
        }
      }
      unmount() {
        this.containerEl.empty();
        this.creatures = [];
        this.filteredCreatures = [];
        this.factionMembers = [];
        this.factionName = null;
      }
      /**
       * Sets faction members to display in separate section.
       * Call this whenever the hex faction changes.
       */
      setFactionMembers(members, factionName) {
        this.factionMembers = members;
        this.factionName = factionName;
        this.renderFactionMembers();
      }
      renderFactionMembers() {
        this.factionMembersSection.empty();
        if (!this.factionMembers.length || !this.factionName) {
          this.factionMembersSection.style.display = "none";
          return;
        }
        this.factionMembersSection.style.display = "block";
        const header = this.factionMembersSection.createDiv({ cls: "sm-encounter-faction-members-header" });
        header.createEl("h4", {
          text: `${this.factionName} Members (${this.factionMembers.length})`,
          cls: "sm-encounter-section-subtitle"
        });
        const membersList = this.factionMembersSection.createDiv({ cls: "sm-encounter-faction-members-list" });
        for (const member of this.factionMembers) {
          const row = membersList.createDiv({ cls: "sm-encounter-creature-item sm-encounter-faction-member-item" });
          const nameEl = row.createDiv({ cls: "sm-encounter-creature-name" });
          nameEl.setText(member.name);
          const badge = nameEl.createSpan({ cls: "sm-faction-member-badge", text: "Faction Member" });
          const metaEl = row.createDiv({ cls: "sm-encounter-creature-meta" });
          metaEl.createSpan({ cls: "sm-encounter-creature-cr", text: `CR ${formatCR2(member.cr)}` });
          if (member.type) {
            metaEl.createSpan({ cls: "sm-encounter-creature-type", text: member.type });
          }
          const addButton = row.createEl("button", {
            cls: "sm-encounter-button sm-encounter-button-primary",
            text: "Add"
          });
          addButton.type = "button";
          addButton.addEventListener("click", () => {
            this.callbacks.onAddCreature(member);
          });
        }
      }
      async loadCreatures() {
        try {
          const files = await LIBRARY_DATA_SOURCES.creatures.list(this.app);
          const loaded = [];
          for (const file of files) {
            try {
              const entry = await LIBRARY_DATA_SOURCES.creatures.load(this.app, file);
              const cr = parseCR2(entry.cr);
              loaded.push({
                name: entry.name,
                cr,
                type: entry.type,
                path: file.path
              });
            } catch (err) {
              logger2.warn(`[creature-list] failed to load ${file.path}`, err);
            }
          }
          loaded.sort((a, b) => {
            if (a.cr !== b.cr) return a.cr - b.cr;
            return a.name.localeCompare(b.name);
          });
          this.creatures = loaded;
          this.applyFilter();
        } catch (err) {
          logger2.error("[creature-list] failed to load creatures", err);
          this.listEl.setText("Failed to load creatures from library.");
        }
      }
      applyFilter() {
        const query = this.searchInput.value.toLowerCase().trim();
        if (!query) {
          this.filteredCreatures = this.creatures;
        } else {
          this.filteredCreatures = this.creatures.filter((creature) => {
            return creature.name.toLowerCase().includes(query) || creature.type?.toLowerCase().includes(query);
          });
        }
        this.renderList();
      }
      renderList() {
        this.listEl.empty();
        if (!this.filteredCreatures.length) {
          this.listEl.createDiv({
            cls: "sm-encounter-empty-row",
            text: this.creatures.length ? "No creatures match your search." : "No creatures found in library."
          });
          return;
        }
        for (const creature of this.filteredCreatures) {
          const row = this.listEl.createDiv({ cls: "sm-encounter-creature-item" });
          const nameEl = row.createDiv({ cls: "sm-encounter-creature-name" });
          nameEl.setText(creature.name);
          const metaEl = row.createDiv({ cls: "sm-encounter-creature-meta" });
          metaEl.createSpan({ cls: "sm-encounter-creature-cr", text: `CR ${formatCR2(creature.cr)}` });
          if (creature.type) {
            metaEl.createSpan({ cls: "sm-encounter-creature-type", text: creature.type });
          }
          const addButton = row.createEl("button", {
            cls: "sm-encounter-button sm-encounter-button-primary",
            text: "Add"
          });
          addButton.type = "button";
          addButton.addEventListener("click", () => {
            this.callbacks.onAddCreature(creature);
          });
        }
      }
    };
  }
});

// src/workmodes/encounter/composition-view.ts
function formatCR3(cr) {
  if (cr === 0.125) return "1/8";
  if (cr === 0.25) return "1/4";
  if (cr === 0.5) return "1/2";
  return String(cr);
}
var EncounterCompositionView;
var init_composition_view = __esm({
  "src/workmodes/encounter/composition-view.ts"() {
    "use strict";
    EncounterCompositionView = class {
      constructor(containerEl, callbacks) {
        this.containerEl = containerEl;
        this.callbacks = callbacks;
      }
      mount() {
        this.containerEl.empty();
        this.containerEl.addClass("sm-encounter-composition");
        const header = this.containerEl.createDiv({ cls: "sm-encounter-composition-header" });
        header.createEl("h3", { text: "Encounter Composition", cls: "sm-encounter-section-title" });
        this.listEl = this.containerEl.createDiv({ cls: "sm-encounter-composition-list" });
      }
      unmount() {
        this.containerEl.empty();
      }
      render(creatures) {
        this.listEl.empty();
        if (!creatures.length) {
          this.listEl.createDiv({
            cls: "sm-encounter-empty-row",
            text: "No creatures added yet. Use the list above to add creatures."
          });
          return;
        }
        for (const creature of creatures) {
          const row = this.listEl.createDiv({ cls: "sm-encounter-composition-item" });
          const nameEl = row.createDiv({ cls: "sm-encounter-composition-name" });
          nameEl.setText(creature.name);
          const metaEl = row.createDiv({ cls: "sm-encounter-composition-meta" });
          metaEl.createSpan({ cls: "sm-encounter-composition-cr", text: `CR ${formatCR3(creature.cr)}` });
          const countField = row.createDiv({ cls: "sm-encounter-composition-count" });
          countField.createEl("label", {
            attr: { for: `creature-count-${creature.id}` },
            text: "Count:"
          });
          const countInput = countField.createEl("input", {
            cls: "sm-encounter-input",
            attr: {
              id: `creature-count-${creature.id}`,
              type: "number",
              min: "1",
              max: "99",
              value: String(creature.count)
            }
          });
          countInput.addEventListener("change", () => {
            const value = Number(countInput.value);
            if (!Number.isFinite(value) || value < 1) {
              countInput.value = String(creature.count);
              return;
            }
            const clamped = Math.max(1, Math.min(99, Math.floor(value)));
            if (clamped !== value) {
              countInput.value = String(clamped);
            }
            this.callbacks.onUpdateCount(creature.id, clamped);
          });
          const removeButton = row.createEl("button", {
            cls: "sm-encounter-button sm-encounter-button-danger",
            text: "Remove"
          });
          removeButton.type = "button";
          removeButton.addEventListener("click", () => {
            this.callbacks.onRemove(creature.id);
          });
        }
      }
    };
  }
});

// src/workmodes/encounter/combat-tracker.ts
var CombatTrackerView;
var init_combat_tracker = __esm({
  "src/workmodes/encounter/combat-tracker.ts"() {
    "use strict";
    CombatTrackerView = class {
      constructor(containerEl, callbacks) {
        this.containerEl = containerEl;
        this.callbacks = callbacks;
      }
      mount() {
        this.containerEl.empty();
        this.containerEl.addClass("sm-combat-tracker");
        this.headerEl = this.containerEl.createDiv({ cls: "sm-combat-tracker-header" });
        this.headerEl.createEl("h3", { text: "Combat Tracker", cls: "sm-encounter-section-title" });
        this.controlsEl = this.containerEl.createDiv({ cls: "sm-combat-tracker-controls" });
        this.listEl = this.containerEl.createDiv({ cls: "sm-combat-tracker-list" });
      }
      unmount() {
        this.containerEl.empty();
      }
      render(combat, hasCreatures) {
        this.renderControls(combat, hasCreatures);
        this.renderParticipants(combat);
      }
      renderControls(combat, hasCreatures) {
        this.controlsEl.empty();
        if (!combat || !combat.isActive) {
          const startButton = this.controlsEl.createEl("button", {
            cls: "sm-encounter-button sm-encounter-button-primary",
            text: "Start Combat"
          });
          startButton.type = "button";
          startButton.disabled = !hasCreatures;
          startButton.addEventListener("click", () => {
            this.callbacks.onStartCombat();
          });
          if (!hasCreatures) {
            this.controlsEl.createDiv({
              cls: "sm-combat-tracker-hint",
              text: "Add creatures to start combat"
            });
          }
        } else {
          const sortButton = this.controlsEl.createEl("button", {
            cls: "sm-encounter-button",
            text: "Sort by Initiative"
          });
          sortButton.type = "button";
          sortButton.addEventListener("click", () => {
            this.callbacks.onSortByInitiative();
          });
          const endButton = this.controlsEl.createEl("button", {
            cls: "sm-encounter-button sm-encounter-button-danger",
            text: "End Combat"
          });
          endButton.type = "button";
          endButton.addEventListener("click", () => {
            this.callbacks.onEndCombat();
          });
        }
      }
      renderParticipants(combat) {
        this.listEl.empty();
        if (!combat || !combat.isActive) {
          this.listEl.createDiv({
            cls: "sm-encounter-empty-row",
            text: "Combat not started. Click 'Start Combat' to begin tracking initiative and HP."
          });
          return;
        }
        if (!combat.participants.length) {
          this.listEl.createDiv({
            cls: "sm-encounter-empty-row",
            text: "No participants in combat."
          });
          return;
        }
        for (const participant of combat.participants) {
          const row = this.listEl.createDiv({ cls: "sm-combat-participant" });
          if (participant.id === combat.activeParticipantId) {
            row.addClass("sm-combat-participant-active");
          }
          if (participant.defeated) {
            row.addClass("sm-combat-participant-defeated");
          }
          const initiativeCol = row.createDiv({ cls: "sm-combat-initiative" });
          initiativeCol.createEl("label", {
            attr: { for: `initiative-${participant.id}` },
            text: "Init:"
          });
          const initiativeInput = initiativeCol.createEl("input", {
            cls: "sm-encounter-input sm-combat-initiative-input",
            attr: {
              id: `initiative-${participant.id}`,
              type: "number",
              value: String(participant.initiative)
            }
          });
          initiativeInput.addEventListener("change", () => {
            const value = Number(initiativeInput.value);
            if (Number.isFinite(value)) {
              this.callbacks.onUpdateInitiative(participant.id, value);
            } else {
              initiativeInput.value = String(participant.initiative);
            }
          });
          const nameCol = row.createDiv({ cls: "sm-combat-name" });
          nameCol.setText(participant.name);
          const hpCol = row.createDiv({ cls: "sm-combat-hp" });
          const hpBar = hpCol.createDiv({ cls: "sm-combat-hp-bar" });
          const hpFill = hpBar.createDiv({ cls: "sm-combat-hp-fill" });
          const hpPercent = participant.maxHp > 0 ? participant.currentHp / participant.maxHp * 100 : 0;
          hpFill.style.width = `${hpPercent}%`;
          if (hpPercent > 66) {
            hpFill.addClass("sm-combat-hp-high");
          } else if (hpPercent > 33) {
            hpFill.addClass("sm-combat-hp-medium");
          } else {
            hpFill.addClass("sm-combat-hp-low");
          }
          const hpInputs = hpCol.createDiv({ cls: "sm-combat-hp-inputs" });
          hpInputs.createEl("label", {
            attr: { for: `current-hp-${participant.id}` },
            text: "HP:"
          });
          const currentHpInput = hpInputs.createEl("input", {
            cls: "sm-encounter-input sm-combat-hp-input",
            attr: {
              id: `current-hp-${participant.id}`,
              type: "number",
              min: "0",
              value: String(participant.currentHp)
            }
          });
          hpInputs.createSpan({ text: "/" });
          const maxHpInput = hpInputs.createEl("input", {
            cls: "sm-encounter-input sm-combat-hp-input",
            attr: {
              id: `max-hp-${participant.id}`,
              type: "number",
              min: "0",
              value: String(participant.maxHp)
            }
          });
          currentHpInput.addEventListener("change", () => {
            const current = Number(currentHpInput.value);
            const max = Number(maxHpInput.value);
            if (Number.isFinite(current)) {
              this.callbacks.onUpdateHp(participant.id, current, max);
            } else {
              currentHpInput.value = String(participant.currentHp);
            }
          });
          maxHpInput.addEventListener("change", () => {
            const current = Number(currentHpInput.value);
            const max = Number(maxHpInput.value);
            if (Number.isFinite(max)) {
              this.callbacks.onUpdateHp(participant.id, current, max);
            } else {
              maxHpInput.value = String(participant.maxHp);
            }
          });
          const quickActions = row.createDiv({ cls: "sm-combat-quick-actions" });
          const damageButton = quickActions.createEl("button", {
            cls: "sm-encounter-button sm-combat-damage-btn",
            text: "\u2212",
            attr: { title: "Apply 1 damage" }
          });
          damageButton.type = "button";
          damageButton.addEventListener("click", () => {
            this.callbacks.onApplyDamage(participant.id, 1);
          });
          const healButton = quickActions.createEl("button", {
            cls: "sm-encounter-button sm-combat-heal-btn",
            text: "+",
            attr: { title: "Apply 1 healing" }
          });
          healButton.type = "button";
          healButton.addEventListener("click", () => {
            this.callbacks.onApplyHealing(participant.id, 1);
          });
          const defeatedCheckbox = row.createEl("input", {
            cls: "sm-combat-defeated-checkbox",
            attr: {
              type: "checkbox",
              id: `defeated-${participant.id}`
            }
          });
          defeatedCheckbox.checked = participant.defeated;
          defeatedCheckbox.addEventListener("change", () => {
            this.callbacks.onToggleDefeated(participant.id);
          });
          const defeatedLabel = row.createEl("label", {
            cls: "sm-combat-defeated-label",
            attr: { for: `defeated-${participant.id}` },
            text: "Defeated"
          });
          const activeButton = row.createEl("button", {
            cls: "sm-encounter-button sm-combat-active-btn",
            text: participant.id === combat.activeParticipantId ? "Active" : "Set Active"
          });
          activeButton.type = "button";
          if (participant.id === combat.activeParticipantId) {
            activeButton.addClass("sm-combat-active-btn-selected");
          }
          activeButton.addEventListener("click", () => {
            if (participant.id === combat.activeParticipantId) {
              this.callbacks.onSetActive(null);
            } else {
              this.callbacks.onSetActive(participant.id);
            }
          });
        }
      }
    };
  }
});

// src/workmodes/encounter/workspace-view.ts
function createSection(parent, className) {
  return parent.createDiv({ cls: `sm-encounter-section ${className}` });
}
function getGoldBaseMultiplier(averageLevel) {
  if (averageLevel >= 17) {
    return 3.2;
  }
  if (averageLevel >= 11) {
    return 1.6;
  }
  if (averageLevel >= 5) {
    return 0.415;
  }
  if (averageLevel > 0) {
    return 0.475;
  }
  return 0;
}
function createTextInput(parent, options) {
  const field = createFieldContainer(parent);
  field.createEl("label", { attr: { for: options.id }, text: options.label });
  return field.createEl("input", {
    cls: "sm-encounter-input",
    attr: {
      id: options.id,
      type: "text",
      placeholder: options.placeholder ?? "",
      value: options.value != null ? String(options.value) : ""
    }
  });
}
function createNumberInput2(parent, options) {
  const field = createFieldContainer(parent);
  field.createEl("label", { attr: { for: options.id }, text: options.label });
  const attrs = {
    id: options.id,
    type: "number"
  };
  if (options.min !== void 0) attrs.min = String(options.min);
  if (options.max !== void 0) attrs.max = String(options.max);
  if (options.step !== void 0) attrs.step = String(options.step);
  if (options.placeholder) attrs.placeholder = options.placeholder;
  if (options.value !== void 0) attrs.value = String(options.value);
  return field.createEl("input", {
    cls: "sm-encounter-input",
    attr: attrs
  });
}
function createFieldContainer(parent) {
  return parent.createDiv({ cls: "sm-encounter-field" });
}
function createStatItem(list, label, value) {
  const item = list.createEl("li", { cls: "sm-encounter-result-summary-item" });
  item.createEl("span", { cls: "label", text: `${label}:` });
  item.createEl("span", { cls: "value", text: value });
  return item;
}
function formatNumber(value) {
  if (!Number.isFinite(value)) {
    return "0";
  }
  return numberFormatter.format(value);
}
function formatSignedNumber(value) {
  const formatted = formatNumber(Math.abs(value));
  if (value > 0) return `+${formatted}`;
  if (value < 0) return `-${formatted}`;
  return formatted;
}
function createId(prefix) {
  const globalCrypto = globalThis.crypto;
  if (globalCrypto?.randomUUID) {
    return `${prefix}-${globalCrypto.randomUUID()}`;
  }
  const random = Math.random().toString(36).slice(2, 8);
  return `${prefix}-${Date.now().toString(36)}-${random}`;
}
var import_obsidian34, EncounterWorkspaceView, ConfirmReplaceModal, numberFormatter;
var init_workspace_view = __esm({
  "src/workmodes/encounter/workspace-view.ts"() {
    "use strict";
    import_obsidian34 = require("obsidian");
    init_modals();
    init_plugin_logger();
    init_rule_presets();
    init_session_view();
    init_creature_list();
    init_composition_view();
    init_combat_tracker();
    EncounterWorkspaceView = class {
      constructor(app, containerEl) {
        this.presenter = null;
        this.presetOptions = [];
        this.presetRefreshTimeout = null;
        this.sessionView = null;
        this.creatureList = null;
        this.compositionView = null;
        this.combatTracker = null;
        this.app = app;
        this.containerEl = containerEl;
      }
      mount() {
        this.containerEl.addClass("sm-encounter-view");
        this.renderShell();
        this.registerPresetWatcher();
        void this.refreshPresetOptions();
        this.syncPresetControlsState();
      }
      unmount() {
        this.sessionView?.unmount();
        this.sessionView = null;
        this.creatureList?.unmount();
        this.creatureList = null;
        this.compositionView?.unmount();
        this.compositionView = null;
        this.combatTracker?.unmount();
        this.combatTracker = null;
        this.containerEl.empty();
        this.containerEl.removeClass("sm-encounter-view");
        this.presenter = null;
        this.detachPresetWatcher?.();
        this.detachPresetWatcher = void 0;
        if (this.presetRefreshTimeout != null) {
          window.clearTimeout(this.presetRefreshTimeout);
          this.presetRefreshTimeout = null;
        }
        this.presetOptions = [];
      }
      setPresenter(presenter) {
        this.presenter = presenter;
        this.syncPresetControlsState();
      }
      render(state) {
        const session = state.session ?? null;
        if (session && this.sessionView) {
          this.sessionView.render(session.event);
        }
        if (this.compositionView) {
          const creatures = session?.creatures ?? [];
          this.compositionView.render(creatures);
        }
        if (this.combatTracker) {
          const combat = session?.combat ?? null;
          const hasCreatures = (session?.creatures?.length ?? 0) > 0;
          this.combatTracker.render(combat, hasCreatures);
        }
        this.renderParty(state);
        this.renderRules(state);
        this.renderResults(state);
        this.renderRuleEffectsDebug(state);
        if (session && this.creatureList) {
          const factionName = session.event.factionName;
          void this.loadAndRenderFactionMembers(factionName);
        }
        this.syncSessionControls(session);
      }
      renderShell() {
        this.containerEl.empty();
        const sessionSection = createSection(this.containerEl, "sm-encounter-session");
        this.sessionView = new EncounterSessionView(sessionSection);
        this.sessionView.mount();
        const creaturesSection = createSection(this.containerEl, "sm-encounter-creatures");
        const creaturesLayout = creaturesSection.createDiv({ cls: "sm-encounter-creatures-layout" });
        const creatureListContainer = creaturesLayout.createDiv({ cls: "sm-encounter-creature-list-container" });
        this.creatureList = new EncounterCreatureList(this.app, creatureListContainer, {
          onAddCreature: (creature) => this.handleAddCreature(creature),
          onGenerateEncounter: (difficulty) => void this.handleGenerateEncounter(difficulty)
        });
        void this.creatureList.mount();
        const compositionContainer = creaturesLayout.createDiv({ cls: "sm-encounter-composition-container" });
        this.compositionView = new EncounterCompositionView(compositionContainer, {
          onUpdateCount: (id, count) => this.handleUpdateCreatureCount(id, count),
          onRemove: (id) => this.handleRemoveCreature(id)
        });
        this.compositionView.mount();
        const combatSection = createSection(this.containerEl, "sm-encounter-combat");
        this.combatTracker = new CombatTrackerView(combatSection, {
          onStartCombat: () => this.handleStartCombat(),
          onEndCombat: () => this.handleEndCombat(),
          onUpdateInitiative: (id, initiative) => this.handleUpdateInitiative(id, initiative),
          onUpdateHp: (id, currentHp, maxHp) => this.handleUpdateHp(id, currentHp, maxHp),
          onApplyDamage: (id, amount) => this.handleApplyDamage(id, amount),
          onApplyHealing: (id, amount) => this.handleApplyHealing(id, amount),
          onToggleDefeated: (id) => this.handleToggleDefeated(id),
          onSetActive: (id) => this.handleSetActive(id),
          onSortByInitiative: () => this.handleSortByInitiative()
        });
        this.combatTracker.mount();
        const xpSection = createSection(this.containerEl, "sm-encounter-xp");
        xpSection.createEl("h3", { cls: "sm-encounter-section-title", text: "Encounter XP & Rules" });
        const xpRow = xpSection.createDiv({ cls: "sm-encounter-xp-row" });
        const xpLeftGroup = xpRow.createDiv({ cls: "sm-encounter-xp-group sm-encounter-xp-group-left" });
        this.xpInputEl = createNumberInput2(xpLeftGroup, {
          id: "encounter-base-xp",
          label: "Base XP",
          min: 0,
          step: 1
        });
        this.xpInputEl.parentElement?.addClass("sm-encounter-field-inline");
        this.xpInputEl.parentElement?.addClass("sm-encounter-field-base-xp");
        this.xpInputEl.addEventListener("change", () => this.handleEncounterXpChange());
        this.xpInputEl.addEventListener("input", () => {
          this.xpErrorEl.setText("");
        });
        const xpLeftActions = xpLeftGroup.createDiv({ cls: "sm-encounter-inline-actions sm-encounter-inline-actions-left" });
        const addRuleButton = xpLeftActions.createEl("button", {
          cls: "sm-encounter-button",
          text: "Add rule"
        });
        addRuleButton.type = "button";
        addRuleButton.addEventListener("click", () => {
          this.handleAddRule();
        });
        const xpRightGroup = xpRow.createDiv({ cls: "sm-encounter-xp-group sm-encounter-xp-group-right" });
        this.presetSelectEl = xpRightGroup.createEl("select", {
          cls: "sm-encounter-input sm-encounter-preset-select",
          attr: { "aria-label": "Encounter rule preset" }
        });
        this.presetSelectEl.addEventListener("change", () => {
          this.syncPresetControlsState();
        });
        const xpPresetActions = xpRightGroup.createDiv({
          cls: "sm-encounter-inline-actions sm-encounter-inline-actions-right"
        });
        this.presetOpenButton = xpPresetActions.createEl("button", {
          cls: "sm-encounter-button",
          text: "Open preset"
        });
        this.presetOpenButton.type = "button";
        this.presetOpenButton.addEventListener("click", () => {
          void this.handleOpenPreset();
        });
        this.presetSaveButton = xpPresetActions.createEl("button", {
          cls: "sm-encounter-button sm-encounter-button-primary",
          text: "Save preset"
        });
        this.presetSaveButton.type = "button";
        this.presetSaveButton.addEventListener("click", () => {
          void this.handleSavePreset();
        });
        this.presetDeleteButton = xpPresetActions.createEl("button", {
          cls: "sm-encounter-button sm-encounter-button-danger",
          text: "Delete preset"
        });
        this.presetDeleteButton.type = "button";
        this.presetDeleteButton.addEventListener("click", () => {
          void this.handleDeletePreset();
        });
        this.xpErrorEl = xpSection.createDiv({ cls: "sm-encounter-error" });
        this.ruleListEl = xpSection.createDiv({ cls: "sm-encounter-rule-list" });
        const layoutEl = this.containerEl.createDiv({ cls: "sm-encounter-columns" });
        const leftColumn = layoutEl.createDiv({ cls: "sm-encounter-column" });
        const partySection = createSection(leftColumn, "sm-encounter-party");
        partySection.createEl("h3", { cls: "sm-encounter-section-title", text: "Party" });
        const partyForm = partySection.createEl("form", { cls: "sm-encounter-form" });
        const partyFormGrid = partyForm.createDiv({ cls: "sm-encounter-form-grid" });
        this.partyFormNameEl = createTextInput(partyFormGrid, {
          id: "encounter-party-name",
          label: "Name",
          placeholder: "Character name"
        });
        this.partyFormLevelEl = createNumberInput2(partyFormGrid, {
          id: "encounter-party-level",
          label: "Level",
          min: 1,
          step: 1,
          value: 1
        });
        this.partyFormCurrentXpEl = createNumberInput2(partyFormGrid, {
          id: "encounter-party-current-xp",
          label: "Current XP",
          min: 0,
          step: 1,
          placeholder: "Optional"
        });
        const partySubmitWrapper = partyFormGrid.createDiv({ cls: "sm-encounter-field sm-encounter-field-actions" });
        const partySubmitButton = partySubmitWrapper.createEl("button", {
          cls: "sm-encounter-button",
          text: "Add party member"
        });
        partySubmitButton.type = "submit";
        this.partyFormErrorEl = partyForm.createDiv({ cls: "sm-encounter-error" });
        partyForm.addEventListener("submit", (event) => {
          event.preventDefault();
          this.handleAddPartyMember();
        });
        partyForm.addEventListener("input", () => {
          this.partyFormErrorEl.setText("");
        });
        this.partyListEl = partySection.createDiv({ cls: "sm-encounter-party-list" });
        const rightColumn = layoutEl.createDiv({ cls: "sm-encounter-column" });
        const resultsSection = createSection(rightColumn, "sm-encounter-results");
        resultsSection.createEl("h3", { cls: "sm-encounter-section-title", text: "Results" });
        this.resultWarningsEl = resultsSection.createDiv({ cls: "sm-encounter-result-warnings" });
        const breakdownWrapper = resultsSection.createDiv({ cls: "sm-encounter-breakdowns" });
        this.xpResultsEl = breakdownWrapper.createDiv({ cls: "sm-encounter-result-party" });
        this.treasureResultsEl = breakdownWrapper.createDiv({ cls: "sm-encounter-result-party" });
        this.debugSectionEl = createSection(rightColumn, "sm-encounter-debug");
        this.debugSectionEl.createEl("h3", {
          cls: "sm-encounter-section-title",
          text: "Debug"
        });
        this.debugRuleEffectsDetailsEl = this.debugSectionEl.createEl("details", {
          cls: "sm-encounter-debug-details"
        });
        this.debugRuleEffectsDetailsEl.createEl("summary", {
          cls: "sm-encounter-debug-summary",
          text: "Rule effects"
        });
        this.debugRuleEffectsEl = this.debugRuleEffectsDetailsEl.createDiv({
          cls: "sm-encounter-debug-rule-effects"
        });
        const notesSection = resultsSection.createDiv({ cls: "sm-encounter-notes" });
        notesSection.createEl("label", {
          cls: "sm-encounter-notes-label",
          attr: { for: "encounter-notes" },
          text: "Notes"
        });
        this.notesEl = notesSection.createEl("textarea", {
          cls: "sm-encounter-notes-input",
          attr: {
            id: "encounter-notes",
            placeholder: "Record tactical notes, initiative order, or follow-up tasks\u2026",
            rows: "6"
          }
        });
        this.notesEl.disabled = true;
        this.notesEl.addEventListener("input", () => {
          if (!this.presenter) return;
          this.presenter.setNotes(this.notesEl.value);
        });
        const actionsRow = resultsSection.createDiv({ cls: "sm-encounter-actions" });
        this.resolveBtn = actionsRow.createEl("button", {
          cls: "sm-encounter-button sm-encounter-button-primary",
          text: "Mark encounter resolved"
        });
        this.resolveBtn.type = "button";
        this.resolveBtn.disabled = true;
        this.resolveBtn.addEventListener("click", () => {
          this.presenter?.markResolved();
        });
      }
      registerPresetWatcher() {
        this.detachPresetWatcher?.();
        const baseDir = (0, import_obsidian34.normalizePath)(ENCOUNTER_RULE_PRESET_DIR);
        const prefix = `${baseDir}/`;
        const handler = (file) => {
          if (file instanceof import_obsidian34.TFile) {
            if (isEncounterPresetFile(file)) {
              this.schedulePresetRefresh();
            }
            return;
          }
          if (file.path === baseDir || file.path.startsWith(prefix)) {
            this.schedulePresetRefresh();
          }
        };
        this.app.vault.on("create", handler);
        this.app.vault.on("delete", handler);
        this.app.vault.on("rename", handler);
        this.app.vault.on("modify", handler);
        this.detachPresetWatcher = () => {
          this.app.vault.off("create", handler);
          this.app.vault.off("delete", handler);
          this.app.vault.off("rename", handler);
          this.app.vault.off("modify", handler);
        };
      }
      schedulePresetRefresh() {
        if (this.presetRefreshTimeout != null) return;
        this.presetRefreshTimeout = window.setTimeout(() => {
          this.presetRefreshTimeout = null;
          void this.refreshPresetOptions();
        }, 100);
      }
      async refreshPresetOptions() {
        const select = this.presetSelectEl;
        if (!select || !select.isConnected) return;
        const previousValue = select.value;
        try {
          const entries = await listEncounterRulePresets(this.app);
          this.presetOptions = entries;
          while (select.firstChild) {
            select.removeChild(select.firstChild);
          }
          const placeholder = select.createEl("option", {
            attr: { value: "" },
            text: entries.length ? "Preset ausw\xE4hlen\u2026" : "Keine Presets gespeichert"
          });
          if (!entries.length) {
            placeholder.selected = true;
          }
          for (const entry of entries) {
            const option = select.createEl("option", {
              attr: { value: entry.file.path },
              text: entry.name
            });
            if (entry.file.path === previousValue) {
              option.selected = true;
            }
          }
          if (select.value !== previousValue) {
            if (entries.some((entry) => entry.file.path === previousValue)) {
              select.value = previousValue;
            } else {
              select.value = "";
            }
          }
        } catch (error) {
          logger2.error("[encounter] failed to list rule presets", error);
        }
        this.syncPresetControlsState();
      }
      getSelectedPreset() {
        const value = this.presetSelectEl?.value;
        if (!value) return null;
        return this.presetOptions.find((entry) => entry.file.path === value) ?? null;
      }
      syncPresetControlsState() {
        const hasPresenter = !!this.presenter;
        const selected = this.getSelectedPreset();
        if (this.presetOpenButton) {
          this.presetOpenButton.disabled = !hasPresenter || !selected;
        }
        if (this.presetDeleteButton) {
          this.presetDeleteButton.disabled = !selected;
        }
        if (this.presetSaveButton) {
          this.presetSaveButton.disabled = !hasPresenter;
        }
      }
      async handleOpenPreset() {
        const presenter = this.presenter;
        const selected = this.getSelectedPreset();
        if (!presenter) {
          new import_obsidian34.Notice("Encounter-Presenter nicht verf\xFCgbar.");
          return;
        }
        if (!selected) {
          new import_obsidian34.Notice("Bitte ein Preset ausw\xE4hlen.");
          return;
        }
        try {
          const preset = await loadEncounterRulePreset(this.app, selected.file);
          const seen = /* @__PURE__ */ new Set();
          const rules = preset.rules.map((rule) => {
            let id = rule.id;
            if (!id || seen.has(id)) {
              id = createId("rule");
            }
            seen.add(id);
            return { ...rule, id };
          });
          presenter.replaceRules(rules);
          if (typeof preset.encounterXp === "number" && Number.isFinite(preset.encounterXp)) {
            presenter.setEncounterXp(preset.encounterXp);
          }
          new import_obsidian34.Notice(`Preset "${preset.name}" geladen.`);
        } catch (error) {
          logger2.error("[encounter] failed to load preset", error);
          new import_obsidian34.Notice("Preset konnte nicht geladen werden.");
        }
      }
      async handleSavePreset() {
        const presenter = this.presenter;
        if (!presenter) {
          new import_obsidian34.Notice("Encounter-Presenter nicht verf\xFCgbar.");
          return;
        }
        const selected = this.getSelectedPreset();
        const currentState = presenter.getState();
        const rules = currentState.xp.rules.map((rule) => ({ ...rule }));
        const encounterXp = currentState.xp.encounterXp;
        const modal = new NameInputModal(
          this.app,
          async (rawName) => {
            const name = rawName.trim();
            const fallbackName = name || "Encounter Rule Preset";
            try {
              const file = await saveEncounterRulePreset(
                this.app,
                { name: name || fallbackName, encounterXp, rules },
                {
                  path: selected && selected.name === (name || fallbackName) ? selected.file.path : void 0
                }
              );
              new import_obsidian34.Notice(`Preset "${name || fallbackName}" gespeichert.`);
              await this.refreshPresetOptions();
              if (this.presetSelectEl && this.presetSelectEl.isConnected) {
                this.presetSelectEl.value = file.path;
              }
            } catch (error) {
              logger2.error("[encounter] failed to save preset", error);
              new import_obsidian34.Notice("Preset konnte nicht gespeichert werden.");
            }
            this.syncPresetControlsState();
          },
          {
            title: "Preset speichern",
            placeholder: "Preset-Name",
            cta: "Speichern",
            initialValue: selected?.name ?? ""
          }
        );
        modal.open();
      }
      async handleDeletePreset() {
        const selected = this.getSelectedPreset();
        if (!selected) {
          new import_obsidian34.Notice("Bitte ein Preset ausw\xE4hlen.");
          return;
        }
        const confirmed = window.confirm(`Preset "${selected.name}" l\xF6schen?`);
        if (!confirmed) return;
        try {
          await deleteEncounterRulePreset(this.app, selected.file);
          new import_obsidian34.Notice(`Preset "${selected.name}" gel\xF6scht.`);
          await this.refreshPresetOptions();
          if (this.presetSelectEl && this.presetSelectEl.isConnected) {
            this.presetSelectEl.value = "";
          }
        } catch (error) {
          logger2.error("[encounter] failed to delete preset", error);
          new import_obsidian34.Notice("Preset konnte nicht gel\xF6scht werden.");
        }
        this.syncPresetControlsState();
      }
      syncSessionControls(session) {
        if (!session) {
          this.notesEl.value = "";
          this.notesEl.disabled = true;
          this.resolveBtn.disabled = true;
          this.resolveBtn.setText("Mark encounter resolved");
          return;
        }
        if (this.notesEl.value !== session.notes) {
          this.notesEl.value = session.notes;
        }
        this.notesEl.disabled = false;
        if (session.status === "resolved") {
          this.resolveBtn.disabled = true;
          this.resolveBtn.setText("Encounter resolved");
        } else {
          this.resolveBtn.disabled = false;
          this.resolveBtn.setText("Mark encounter resolved");
        }
      }
      renderParty(state) {
        const { party } = state.xp;
        this.partyListEl.empty();
        if (!party.length) {
          this.partyListEl.createDiv({
            cls: "sm-encounter-empty-row",
            text: "No party members added yet."
          });
        }
        for (const member of party) {
          const itemEl = this.partyListEl.createDiv({ cls: "sm-encounter-party-item" });
          const nameField = createFieldContainer(itemEl);
          nameField.addClass("sm-encounter-party-field");
          const nameLabel = nameField.createEl("label", {
            attr: { for: `party-${member.id}-name` },
            text: "Name"
          });
          nameLabel.addClass("sm-encounter-inline-label");
          const nameInput = nameField.createEl("input", {
            cls: "sm-encounter-input",
            attr: {
              id: `party-${member.id}-name`,
              type: "text",
              value: member.name
            }
          });
          nameInput.addEventListener("change", () => {
            const presenter = this.presenter;
            if (!presenter) return;
            const nextName = nameInput.value.trim();
            presenter.updatePartyMember(member.id, { name: nextName });
          });
          const levelField = createFieldContainer(itemEl);
          levelField.addClass("sm-encounter-party-field");
          const levelLabel = levelField.createEl("label", {
            attr: { for: `party-${member.id}-level` },
            text: "Level"
          });
          levelLabel.addClass("sm-encounter-inline-label");
          const levelInput = levelField.createEl("input", {
            cls: "sm-encounter-input",
            attr: {
              id: `party-${member.id}-level`,
              type: "number",
              min: "1",
              step: "1",
              value: String(member.level)
            }
          });
          levelInput.addEventListener("change", () => {
            const presenter = this.presenter;
            if (!presenter) return;
            const numeric = Number(levelInput.value);
            if (!Number.isFinite(numeric) || numeric < 1) {
              levelInput.value = String(member.level);
              return;
            }
            presenter.updatePartyMember(member.id, { level: Math.floor(numeric) });
          });
          const removeButton = itemEl.createEl("button", {
            cls: "sm-encounter-button sm-encounter-button-danger sm-encounter-party-remove",
            text: "Remove"
          });
          removeButton.type = "button";
          removeButton.addEventListener("click", () => {
            this.presenter?.removePartyMember(member.id);
          });
        }
      }
      renderRules(state) {
        const rules = state.xp.rules;
        const ruleViews = new Map(state.xpView.rules.map((view) => [view.rule.id, view]));
        this.ruleListEl.empty();
        if (!rules.length) {
          this.ruleListEl.createDiv({
            cls: "sm-encounter-empty-row",
            text: "No rules configured yet."
          });
          return;
        }
        rules.forEach((rule) => {
          const ruleItem = this.ruleListEl.createDiv({ cls: "sm-encounter-rule" });
          if (!rule.enabled) {
            ruleItem.addClass("is-disabled");
          }
          const headerRow = ruleItem.createDiv({ cls: "sm-encounter-rule-header" });
          const toggleWrapper = headerRow.createDiv({ cls: "sm-encounter-rule-toggle" });
          const toggleInput = toggleWrapper.createEl("input", {
            cls: "sm-encounter-rule-toggle-input",
            attr: {
              type: "checkbox",
              "aria-label": "Toggle rule",
              checked: rule.enabled ? "true" : void 0
            }
          });
          toggleInput.checked = rule.enabled;
          toggleInput.addEventListener("change", () => {
            const presenter = this.presenter;
            if (!presenter) return;
            presenter.toggleRule(rule.id, toggleInput.checked);
          });
          const titleInput = headerRow.createEl("input", {
            cls: "sm-encounter-input sm-encounter-rule-title",
            attr: {
              type: "text",
              value: rule.title,
              placeholder: "Rule name",
              "aria-label": "Rule name"
            }
          });
          titleInput.addEventListener("change", () => {
            const presenter = this.presenter;
            if (!presenter) return;
            presenter.updateRule(rule.id, { title: titleInput.value.trim() });
          });
          const scopeWrapper = headerRow.createDiv({ cls: "sm-encounter-rule-scope" });
          const scopeSelect = scopeWrapper.createEl("select", {
            cls: "sm-encounter-input",
            attr: { "aria-label": "Rule scope" }
          });
          const scopeOptions = [
            { value: "xp", label: "XP" },
            { value: "gold", label: "Gold" }
          ];
          for (const option of scopeOptions) {
            scopeSelect.createEl("option", {
              attr: { value: option.value, selected: option.value === rule.scope ? "true" : void 0 },
              text: option.label
            });
          }
          scopeSelect.value = rule.scope;
          scopeSelect.addEventListener("change", () => {
            const presenter = this.presenter;
            if (!presenter) return;
            presenter.updateRule(rule.id, { scope: scopeSelect.value });
          });
          const valueWrapper = headerRow.createDiv({ cls: "sm-encounter-rule-range" });
          const minInput = valueWrapper.createEl("input", {
            cls: "sm-encounter-input sm-encounter-rule-range-input",
            attr: {
              id: `rule-${rule.id}-min`,
              type: "number",
              value: String(rule.modifierValueMin),
              "aria-label": "Modifier minimum value"
            }
          });
          valueWrapper.createSpan({ cls: "sm-encounter-rule-range-separator", text: "\u2013" });
          const maxInput = valueWrapper.createEl("input", {
            cls: "sm-encounter-input sm-encounter-rule-range-input",
            attr: {
              id: `rule-${rule.id}-max`,
              type: "number",
              value: String(rule.modifierValueMax),
              "aria-label": "Modifier maximum value"
            }
          });
          valueWrapper.createSpan({
            cls: "sm-encounter-rule-range-result",
            text: `\u2192 ${formatNumber(rule.modifierValue)}`
          });
          const typeSelect = headerRow.createEl("select", {
            cls: "sm-encounter-input sm-encounter-rule-type",
            attr: { "aria-label": "Modifier type" }
          });
          const typeOptions = [
            { value: "flat", label: "Flat" },
            { value: "flatPerAverageLevel", label: "Flat * avrg lvl" },
            { value: "flatPerTotalLevel", label: "Flat * total lvl" },
            { value: "percentTotal", label: "% of total" },
            { value: "percentNextLevel", label: "% to next level" }
          ];
          for (const option of typeOptions) {
            typeSelect.createEl("option", {
              attr: { value: option.value, selected: option.value === rule.modifierType ? "true" : void 0 },
              text: option.label
            });
          }
          typeSelect.value = rule.modifierType;
          typeSelect.addEventListener("change", () => {
            const presenter = this.presenter;
            if (!presenter) return;
            presenter.updateRule(rule.id, { modifierType: typeSelect.value });
          });
          const ruleErrorEl = ruleItem.createDiv({ cls: "sm-encounter-error" });
          const handleRangeChange = () => {
            const presenter = this.presenter;
            if (!presenter) return;
            const minRaw = minInput.value.trim();
            const maxRaw = maxInput.value.trim();
            if (minRaw === "" || maxRaw === "") {
              ruleErrorEl.setText("Modifier range requires both values.");
              minInput.value = String(rule.modifierValueMin);
              maxInput.value = String(rule.modifierValueMax);
              return;
            }
            const minNumeric = Number(minRaw);
            const maxNumeric = Number(maxRaw);
            if (!Number.isFinite(minNumeric) || !Number.isFinite(maxNumeric)) {
              ruleErrorEl.setText("Modifier range values must be numbers.");
              minInput.value = String(rule.modifierValueMin);
              maxInput.value = String(rule.modifierValueMax);
              return;
            }
            ruleErrorEl.setText("");
            const nextMin = Math.min(minNumeric, maxNumeric);
            const nextMax = Math.max(minNumeric, maxNumeric);
            if (nextMin !== minNumeric || nextMax !== maxNumeric) {
              minInput.value = String(nextMin);
              maxInput.value = String(nextMax);
            }
            presenter.updateRule(rule.id, { modifierValueMin: nextMin, modifierValueMax: nextMax });
          };
          minInput.addEventListener("change", handleRangeChange);
          maxInput.addEventListener("change", handleRangeChange);
          minInput.addEventListener("input", () => {
            ruleErrorEl.setText("");
          });
          maxInput.addEventListener("input", () => {
            ruleErrorEl.setText("");
          });
          const notesField = createFieldContainer(ruleItem);
          notesField.addClass("sm-encounter-rule-notes");
          notesField.createEl("label", {
            attr: { for: `rule-${rule.id}-notes` },
            text: "Notes"
          });
          const notesInput = notesField.createEl("textarea", {
            cls: "sm-encounter-input",
            attr: {
              id: `rule-${rule.id}-notes`,
              rows: rule.notes?.trim() ? "2" : "1"
            },
            text: rule.notes ?? ""
          });
          const syncNoteRows = () => {
            const trimmed = notesInput.value.trim();
            if (!trimmed) {
              notesInput.rows = 1;
              return;
            }
            const lineCount = trimmed.split(/\r?\n/).length;
            notesInput.rows = Math.min(6, Math.max(2, lineCount));
          };
          syncNoteRows();
          notesInput.addEventListener("input", () => {
            syncNoteRows();
          });
          notesInput.addEventListener("change", () => {
            const presenter = this.presenter;
            if (!presenter) return;
            const trimmed = notesInput.value.trim();
            presenter.updateRule(rule.id, { notes: trimmed === "" ? "" : trimmed });
          });
          const removeButton = ruleItem.createEl("button", {
            cls: "sm-encounter-button sm-encounter-button-danger",
            text: "Remove rule"
          });
          removeButton.type = "button";
          removeButton.addEventListener("click", () => {
            this.presenter?.removeRule(rule.id);
          });
          const view = ruleViews.get(rule.id);
          if (view?.warnings.length) {
            const warningEl = ruleItem.createDiv({ cls: "sm-encounter-callout" });
            view.warnings.forEach((warning) => {
              warningEl.createEl("p", { text: warning });
            });
          }
        });
      }
      renderResults(state) {
        const { xpView } = state;
        const partyViews = xpView.party;
        const enabledXpRuleViews = xpView.rules.filter(
          (ruleView) => ruleView.rule.enabled && ruleView.rule.scope === "xp"
        );
        const totalModifierDelta = enabledXpRuleViews.reduce((sum, ruleView) => sum + ruleView.totalDelta, 0);
        const xpPerMember = partyViews.length ? xpView.totalEncounterXp / partyViews.length : 0;
        const treasureSummary = this.calculateTreasureSummary(state);
        const warnings = [];
        const pushWarning2 = (message) => {
          if (!message) return;
          if (!warnings.includes(message)) {
            warnings.push(message);
          }
        };
        xpView.warnings.forEach(pushWarning2);
        treasureSummary.warnings.forEach(pushWarning2);
        this.resultWarningsEl.empty();
        if (warnings.length) {
          const warning = this.resultWarningsEl.createDiv({ cls: "sm-encounter-callout" });
          warnings.forEach((message) => {
            warning.createEl("p", { text: message });
          });
        }
        this.xpResultsEl.empty();
        this.xpResultsEl.createEl("h4", {
          cls: "sm-encounter-subheading",
          text: "XP Result."
        });
        const summaryCard = this.xpResultsEl.createDiv({
          cls: "sm-encounter-result-party-member sm-encounter-result-party-member--xp-only"
        });
        const summaryList = summaryCard.createEl("ul", { cls: "sm-encounter-result-summary" });
        createStatItem(summaryList, "Base XP", formatNumber(xpView.baseEncounterXp));
        const modifiersItem = summaryList.createEl("li", {
          cls: "sm-encounter-result-summary-item sm-encounter-result-summary-item--modifiers"
        });
        modifiersItem.createEl("span", { cls: "label", text: "Modifiers:" });
        const modifiersValue = modifiersItem.createDiv({ cls: "value" });
        if (enabledXpRuleViews.length) {
          const modifiersList = modifiersValue.createEl("ul", { cls: "sm-encounter-result-modifier-list" });
          for (const ruleView of enabledXpRuleViews) {
            const modifierRow = modifiersList.createEl("li", { cls: "sm-encounter-result-modifier" });
            const ruleTitle = ruleView.rule.title.trim();
            modifierRow.createEl("span", {
              cls: "name",
              text: ruleTitle || "Untitled rule"
            });
            modifierRow.createEl("span", {
              cls: "delta",
              text: formatSignedNumber(ruleView.totalDelta)
            });
          }
        } else {
          modifiersValue.createEl("span", {
            cls: "sm-encounter-result-modifier-empty",
            text: "None"
          });
        }
        createStatItem(summaryList, "Total Modifiers", formatSignedNumber(totalModifierDelta));
        createStatItem(summaryList, "Total XP", formatNumber(xpView.totalEncounterXp));
        createStatItem(summaryList, "XP per Character", formatNumber(xpPerMember));
        if (!partyViews.length) {
          this.xpResultsEl.createDiv({
            cls: "sm-encounter-empty-row",
            text: "No party members added yet."
          });
          this.renderTreasureResults(state, treasureSummary);
          return;
        }
        const aggregatedWarnings = [];
        for (const memberView of partyViews) {
          for (const warning of memberView.warnings) {
            aggregatedWarnings.push(`${memberView.member.name}: ${warning}`);
          }
        }
        if (aggregatedWarnings.length) {
          const warningEl = this.xpResultsEl.createDiv({ cls: "sm-encounter-callout" });
          aggregatedWarnings.forEach((warning) => {
            warningEl.createEl("p", { text: warning });
          });
        }
        this.renderTreasureResults(state, treasureSummary);
      }
      renderTreasureResults(state, summary) {
        this.treasureResultsEl.empty();
        this.treasureResultsEl.createEl("h4", {
          cls: "sm-encounter-subheading",
          text: "Treasure."
        });
        const party = state.xp.party;
        if (!party.length) {
          this.treasureResultsEl.createDiv({
            cls: "sm-encounter-empty-row",
            text: "No party members added yet."
          });
          return;
        }
        const summaryCard = this.treasureResultsEl.createDiv({
          cls: "sm-encounter-result-party-member sm-encounter-result-party-member--xp-only"
        });
        const summaryList = summaryCard.createEl("ul", { cls: "sm-encounter-result-summary" });
        createStatItem(summaryList, "Gold Base", formatNumber(summary.baseGold));
        const modifiersItem = summaryList.createEl("li", {
          cls: "sm-encounter-result-summary-item sm-encounter-result-summary-item--modifiers"
        });
        modifiersItem.createEl("span", { cls: "label", text: "Modifiers:" });
        const modifiersValue = modifiersItem.createDiv({ cls: "value" });
        if (summary.enabledRules.length) {
          const modifiersList = modifiersValue.createEl("ul", { cls: "sm-encounter-result-modifier-list" });
          for (const rule of summary.enabledRules) {
            const modifierRow = modifiersList.createEl("li", { cls: "sm-encounter-result-modifier" });
            const ruleTitle = rule.rule.title.trim();
            modifierRow.createEl("span", {
              cls: "name",
              text: ruleTitle || "Untitled rule"
            });
            modifierRow.createEl("span", {
              cls: "delta",
              text: formatSignedNumber(rule.delta)
            });
          }
        } else {
          modifiersValue.createEl("span", {
            cls: "sm-encounter-result-modifier-empty",
            text: "None"
          });
        }
        createStatItem(summaryList, "Total Modifiers", formatSignedNumber(summary.totalModifierDelta));
        createStatItem(summaryList, "Total Gold", formatNumber(summary.totalGold));
        const goldPerCharacter = party.length ? summary.totalGold / party.length : 0;
        createStatItem(summaryList, "Gold per Character", formatNumber(goldPerCharacter));
      }
      calculateTreasureSummary(state) {
        const xpState = state.xp;
        const xpView = state.xpView;
        const party = xpState.party ?? [];
        const partyViews = xpView.party;
        const partyCount = party.length;
        const totalLevels = party.reduce((sum, member) => sum + member.level, 0);
        const averageLevel = partyCount > 0 ? totalLevels / partyCount : 0;
        const baseMultiplier = getGoldBaseMultiplier(averageLevel);
        const baseGold = partyCount > 0 ? xpView.baseEncounterXp * baseMultiplier : 0;
        let runningGold = baseGold;
        let totalModifierDelta = 0;
        const enabledRules = [];
        const warnings = [];
        const pushWarning2 = (message) => {
          if (!message) return;
          if (!warnings.includes(message)) {
            warnings.push(message);
          }
        };
        const xpToNextByMember = new Map(
          partyViews.map((memberView) => [memberView.member.id, memberView.xpToNextLevel])
        );
        for (const rule of xpState.rules ?? []) {
          if (rule.scope !== "gold" || !rule.enabled) {
            continue;
          }
          if (!partyCount) {
            pushWarning2(`Gold rule "${rule.title}" ignored because no party members are present.`);
            enabledRules.push({ rule, delta: 0 });
            continue;
          }
          let delta = 0;
          switch (rule.modifierType) {
            case "flat": {
              delta = rule.modifierValue;
              break;
            }
            case "flatPerAverageLevel": {
              delta = rule.modifierValue * averageLevel;
              break;
            }
            case "flatPerTotalLevel": {
              delta = rule.modifierValue * totalLevels;
              break;
            }
            case "percentTotal": {
              delta = runningGold * (rule.modifierValue / 100);
              break;
            }
            case "percentNextLevel": {
              let aggregateNext = 0;
              let applied = false;
              for (const member of party) {
                const xpToNext = xpToNextByMember.get(member.id);
                if (xpToNext == null) {
                  pushWarning2(
                    `${member.name} has no next-level XP threshold; "${rule.title}" gold modifier ignored for them.`
                  );
                  continue;
                }
                aggregateNext += xpToNext;
                applied = true;
              }
              if (!applied || aggregateNext === 0) {
                delta = 0;
              } else {
                delta = aggregateNext * rule.modifierValue / 100;
              }
              break;
            }
          }
          totalModifierDelta += delta;
          runningGold += delta;
          enabledRules.push({ rule, delta });
        }
        return {
          baseGold,
          totalGold: baseGold + totalModifierDelta,
          totalModifierDelta,
          enabledRules,
          warnings
        };
      }
      renderRuleEffectsDebug(state) {
        if (!this.debugRuleEffectsEl || !this.debugSectionEl || !this.debugRuleEffectsDetailsEl) {
          return;
        }
        const { xpView } = state;
        const partyViews = xpView.party;
        const ruleViews = xpView.rules;
        this.debugRuleEffectsEl.empty();
        if (!ruleViews.length) {
          this.debugSectionEl.addClass("sm-encounter-hidden");
          this.debugRuleEffectsDetailsEl.open = false;
          return;
        }
        this.debugSectionEl.removeClass("sm-encounter-hidden");
        const runningTotals = /* @__PURE__ */ new Map();
        for (const memberView of partyViews) {
          runningTotals.set(memberView.member.id, memberView.baseXp);
        }
        for (const ruleView of ruleViews) {
          const ruleResult = this.debugRuleEffectsEl.createDiv({ cls: "sm-encounter-result-rule" });
          const title = ruleResult.createEl("div", {
            cls: "sm-encounter-result-rule-title",
            text: ruleView.rule.title
          });
          if (!ruleView.rule.enabled) {
            title.addClass("is-disabled");
          }
          const deltaSummary = ruleResult.createDiv({ cls: "sm-encounter-result-rule-total" });
          deltaSummary.createEl("span", { cls: "label", text: "Total delta:" });
          deltaSummary.createEl("span", { cls: "value", text: formatSignedNumber(ruleView.totalDelta) });
          const perMemberFinals = ruleView.perMemberDeltas.map((delta) => {
            const previous = runningTotals.get(delta.memberId) ?? 0;
            const shouldApply = ruleView.rule.enabled;
            const total = shouldApply ? previous + delta.delta : previous;
            if (shouldApply) {
              runningTotals.set(delta.memberId, total);
            }
            return { ...delta, previous, total };
          });
          if (perMemberFinals.length) {
            const perMemberList = ruleResult.createEl("ul", { cls: "sm-encounter-rule-deltas" });
            perMemberFinals.forEach((delta) => {
              perMemberList.createEl("li", {
                text: `${delta.memberName}: ${formatSignedNumber(delta.delta)}`
              });
            });
          }
          if (ruleView.warnings.length) {
            const warningEl = ruleResult.createDiv({ cls: "sm-encounter-callout" });
            ruleView.warnings.forEach((warning) => {
              warningEl.createEl("p", { text: warning });
            });
          }
        }
      }
      handleAddPartyMember() {
        const presenter = this.presenter;
        if (!presenter) return;
        const name = this.partyFormNameEl.value.trim();
        const levelValue = Number(this.partyFormLevelEl.value);
        const currentXpRaw = this.partyFormCurrentXpEl.value.trim();
        const errors = [];
        if (!name) {
          errors.push("Name is required.");
        }
        if (!Number.isFinite(levelValue) || levelValue < 1) {
          errors.push("Level must be 1 or greater.");
        }
        let currentXp;
        if (currentXpRaw !== "") {
          const numericCurrent = Number(currentXpRaw);
          if (!Number.isFinite(numericCurrent) || numericCurrent < 0) {
            errors.push("Current XP must be a non-negative number.");
          } else {
            currentXp = numericCurrent;
          }
        }
        if (errors.length) {
          this.partyFormErrorEl.setText(errors.join(" "));
          return;
        }
        const member = {
          id: createId("party"),
          name,
          level: Math.floor(levelValue)
        };
        if (currentXp !== void 0) {
          member.currentXp = currentXp;
        }
        presenter.addPartyMember(member);
        this.partyFormNameEl.value = "";
        this.partyFormLevelEl.value = "1";
        this.partyFormCurrentXpEl.value = "";
        this.partyFormErrorEl.setText("");
        this.partyFormNameEl.focus();
      }
      handleEncounterXpChange() {
        const presenter = this.presenter;
        if (!presenter) return;
        const raw = this.xpInputEl.value.trim();
        if (raw === "") {
          this.xpErrorEl.setText("");
          presenter.setEncounterXp(0);
          return;
        }
        const numeric = Number(raw);
        if (!Number.isFinite(numeric) || numeric < 0) {
          this.xpErrorEl.setText("Encounter XP must be a non-negative number.");
          return;
        }
        this.xpErrorEl.setText("");
        presenter.setEncounterXp(numeric);
      }
      handleAddRule() {
        const presenter = this.presenter;
        if (!presenter) return;
        const rule = {
          id: createId("rule"),
          title: "",
          modifierType: "flat",
          modifierValue: 0,
          modifierValueMin: 0,
          modifierValueMax: 0,
          enabled: true,
          scope: "xp"
        };
        presenter.addRule(rule);
      }
      handleAddCreature(creature) {
        const presenter = this.presenter;
        if (!presenter) return;
        presenter.addCreature({
          id: createId("creature"),
          name: creature.name,
          count: 1,
          cr: creature.cr,
          source: "library",
          statblockPath: creature.path
        });
      }
      async handleGenerateEncounter(difficulty) {
        const presenter = this.presenter;
        if (!presenter) return;
        this.creatureList?.setGenerateButtonState(true);
        try {
          const state = presenter.getState();
          const session = state.session;
          const hasCreatures = session?.creatures && session.creatures.length > 0;
          if (hasCreatures) {
            const confirmed = await this.showConfirmReplaceModal(session.creatures.length);
            if (!confirmed) {
              this.creatureList?.setGenerateButtonState(false);
              return;
            }
          }
          const result = await presenter.generateEncounter(difficulty, this.app, hasCreatures);
          if (result.success) {
            const xpByCr = {
              0: 10,
              0.125: 25,
              0.25: 50,
              0.5: 100,
              1: 200,
              2: 450,
              3: 700,
              4: 1100,
              5: 1800,
              6: 2300,
              7: 2900,
              8: 3900,
              9: 5e3,
              10: 5900,
              11: 7200,
              12: 8400,
              13: 1e4,
              14: 11500,
              15: 13e3,
              16: 15e3,
              17: 18e3,
              18: 2e4,
              19: 22e3,
              20: 25e3,
              21: 33e3,
              22: 41e3,
              23: 5e4,
              24: 62e3,
              25: 75e3,
              26: 9e4,
              27: 105e3,
              28: 12e4,
              29: 135e3,
              30: 155e3
            };
            const totalXP = result.creatures.reduce((sum, c) => {
              return sum + (xpByCr[c.cr] ?? 0) * c.count;
            }, 0);
            const totalCreatureCount = result.creatures.reduce((sum, c) => sum + c.count, 0);
            new import_obsidian34.Notice(`\u2705 Generated encounter: ${totalCreatureCount} creatures, ${totalXP} XP`);
          } else {
            new import_obsidian34.Notice(`\u274C ${result.error}`);
          }
        } catch (err) {
          logger2.error("[workspace-view] Generate encounter failed", err);
          new import_obsidian34.Notice(`\u274C Failed to generate encounter: ${err instanceof Error ? err.message : "Unknown error"}`);
        } finally {
          this.creatureList?.setGenerateButtonState(false);
        }
      }
      async showConfirmReplaceModal(creatureCount) {
        return new Promise((resolve) => {
          const modal = new ConfirmReplaceModal(this.app, creatureCount, (confirmed) => {
            resolve(confirmed);
          });
          modal.open();
        });
      }
      handleUpdateCreatureCount(id, count) {
        const presenter = this.presenter;
        if (!presenter) return;
        presenter.updateCreature(id, { count });
      }
      handleRemoveCreature(id) {
        const presenter = this.presenter;
        if (!presenter) return;
        presenter.removeCreature(id);
      }
      handleStartCombat() {
        const presenter = this.presenter;
        if (!presenter) return;
        presenter.startCombat();
      }
      handleEndCombat() {
        const presenter = this.presenter;
        if (!presenter) return;
        presenter.endCombat();
      }
      handleUpdateInitiative(id, initiative) {
        const presenter = this.presenter;
        if (!presenter) return;
        presenter.updateParticipantInitiative(id, initiative);
      }
      handleUpdateHp(id, currentHp, maxHp) {
        const presenter = this.presenter;
        if (!presenter) return;
        presenter.updateParticipantHp(id, currentHp, maxHp);
      }
      handleApplyDamage(id, amount) {
        const presenter = this.presenter;
        if (!presenter) return;
        presenter.applyDamage(id, amount);
      }
      handleApplyHealing(id, amount) {
        const presenter = this.presenter;
        if (!presenter) return;
        presenter.applyHealing(id, amount);
      }
      handleToggleDefeated(id) {
        const presenter = this.presenter;
        if (!presenter) return;
        presenter.toggleDefeated(id);
      }
      handleSetActive(id) {
        const presenter = this.presenter;
        if (!presenter) return;
        presenter.setActiveParticipant(id);
      }
      handleSortByInitiative() {
        const presenter = this.presenter;
        if (!presenter) return;
        presenter.sortParticipantsByInitiative();
      }
      async loadAndRenderFactionMembers(factionName) {
        const presenter = this.presenter;
        if (!presenter || !this.creatureList) return;
        try {
          const members = await presenter.loadFactionMembers(factionName, this.app);
          this.creatureList.setFactionMembers(members, factionName ?? null);
        } catch (err) {
          logger2.error("[workspace-view] Failed to load faction members", err);
          this.creatureList.setFactionMembers([], null);
        }
      }
    };
    ConfirmReplaceModal = class extends import_obsidian34.Modal {
      constructor(app, creatureCount, onConfirm) {
        super(app);
        this.creatureCount = creatureCount;
        this.onConfirm = onConfirm;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("sm-confirm-modal");
        contentEl.createEl("h2", { text: "Replace Existing Encounter?" });
        const message = contentEl.createDiv({ cls: "sm-confirm-message" });
        message.createEl("p", {
          text: `You have ${this.creatureCount} creature${this.creatureCount === 1 ? "" : "s"} in the current encounter.`
        });
        message.createEl("p", {
          text: "Generating a new encounter will remove all existing creatures."
        });
        message.createEl("p", {
          text: "Do you want to continue?",
          cls: "sm-confirm-question"
        });
        const buttonRow = contentEl.createDiv({ cls: "sm-confirm-buttons" });
        const cancelButton = buttonRow.createEl("button", {
          text: "Cancel",
          cls: "sm-confirm-button sm-confirm-button-secondary"
        });
        cancelButton.addEventListener("click", () => {
          this.onConfirm(false);
          this.close();
        });
        const replaceButton = buttonRow.createEl("button", {
          text: "Replace Encounter",
          cls: "sm-confirm-button sm-confirm-button-danger"
        });
        replaceButton.addEventListener("click", () => {
          this.onConfirm(true);
          this.close();
        });
        cancelButton.focus();
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
    numberFormatter = new Intl.NumberFormat(void 0, {
      maximumFractionDigits: 2,
      minimumFractionDigits: 0
    });
  }
});

// src/workmodes/encounter/view.ts
var view_exports = {};
__export(view_exports, {
  EncounterView: () => EncounterView,
  VIEW_ENCOUNTER: () => VIEW_ENCOUNTER,
  openEncounter: () => openEncounter
});
async function openEncounter(app) {
  const leaf = getCenterLeaf(app);
  await leaf.setViewState({ type: VIEW_ENCOUNTER, active: true });
  app.workspace.revealLeaf(leaf);
}
var import_obsidian35, VIEW_ENCOUNTER, EncounterView;
var init_view2 = __esm({
  "src/workmodes/encounter/view.ts"() {
    "use strict";
    import_obsidian35 = require("obsidian");
    init_presenter();
    init_workspace_view();
    init_layout();
    VIEW_ENCOUNTER = "salt-encounter";
    EncounterView = class extends import_obsidian35.ItemView {
      constructor(leaf) {
        super(leaf);
        this.presenter = null;
        this.pendingState = null;
        this.workspaceView = null;
      }
      getViewType() {
        return VIEW_ENCOUNTER;
      }
      getDisplayText() {
        return "Calculator";
      }
      getIcon() {
        return "calculator";
      }
      async onOpen() {
        const workspaceView = new EncounterWorkspaceView(this.app, this.contentEl);
        workspaceView.mount();
        this.workspaceView = workspaceView;
        const presenter = new EncounterPresenter(this.pendingState);
        this.pendingState = null;
        this.presenter = presenter;
        workspaceView.setPresenter(presenter);
        this.detachPresenter = presenter.subscribe((state) => {
          this.workspaceView?.render(state);
        });
      }
      async onClose() {
        this.detachPresenter?.();
        this.presenter?.dispose();
        this.detachPresenter = void 0;
        this.presenter = null;
        this.pendingState = null;
        this.workspaceView?.setPresenter(null);
        this.workspaceView?.unmount();
        this.workspaceView = null;
      }
      getViewData() {
        return this.presenter?.getState() ?? this.pendingState;
      }
      setViewData(data) {
        if (this.presenter) {
          this.presenter.restore(data);
        } else {
          this.pendingState = data;
        }
      }
    };
  }
});

// src/workmodes/almanac/view/event-editor-modal.ts
function openEventEditor(app, options = {}) {
  const modal = new EventEditorModal(app, options);
  modal.open();
}
var import_obsidian36, EventEditorModal;
var init_event_editor_modal = __esm({
  "src/workmodes/almanac/view/event-editor-modal.ts"() {
    "use strict";
    import_obsidian36 = require("obsidian");
    init_plugin_logger();
    EventEditorModal = class extends import_obsidian36.Modal {
      constructor(app, options = {}) {
        super(app);
        this.options = options;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("sm-almanac-event-editor");
        const isEditMode = !!this.options.event;
        const title = isEditMode ? "Edit Event" : "Create Event";
        contentEl.createEl("h2", { text: title });
        const notice = contentEl.createDiv({ cls: "sm-almanac-event-editor__notice" });
        notice.createEl("h3", { text: "Coming Soon" });
        notice.createEl("p", {
          text: "The event editor is currently under development. Full event creation and editing functionality will be available in a future update."
        });
        const futureFeatures = notice.createDiv({ cls: "sm-almanac-event-editor__features" });
        futureFeatures.createEl("h4", { text: "Planned Features:" });
        const featureList = futureFeatures.createEl("ul");
        featureList.createEl("li", { text: "Event title, description, and category" });
        featureList.createEl("li", { text: "Precise timestamp selection (date and time)" });
        featureList.createEl("li", { text: "Recurrence patterns (daily, weekly, monthly, yearly)" });
        featureList.createEl("li", { text: "Tags for organization and filtering" });
        featureList.createEl("li", { text: "Integration with faction goals and calendar hooks" });
        const btnRow = contentEl.createDiv({ cls: "modal-button-container" });
        const closeBtn = btnRow.createEl("button", { text: "Close" });
        closeBtn.addEventListener("click", () => this.close());
        logger2.info("[almanac] Event editor modal opened", { isEditMode });
      }
      onClose() {
        this.contentEl.removeClass("sm-almanac-event-editor");
        this.contentEl.empty();
      }
    };
  }
});

// src/workmodes/almanac/domain/index.ts
function getTotalDaysInYear(schema2) {
  return schema2.months.reduce((sum, month) => sum + month.length, 0);
}
function getMonthById(schema2, monthId) {
  return schema2.months.find((month) => month.id === monthId) ?? null;
}
function getMonthIndex(schema2, monthId) {
  return schema2.months.findIndex((month) => month.id === monthId);
}
function getTimeDefinition(schema2) {
  return {
    ...DEFAULT_TIME_DEFINITION,
    ...schema2.hoursPerDay !== void 0 ? { hoursPerDay: schema2.hoursPerDay } : {},
    ...schema2.minutesPerHour !== void 0 ? { minutesPerHour: schema2.minutesPerHour } : {},
    ...schema2.secondsPerMinute !== void 0 ? { secondsPerMinute: schema2.secondsPerMinute } : {},
    ...schema2.minuteStep !== void 0 ? { minuteStep: schema2.minuteStep } : {}
  };
}
function createDayTimestamp(calendarId, year, monthId, day) {
  return { calendarId, year, monthId, day, precision: "day" };
}
function createHourTimestamp(calendarId, year, monthId, day, hour) {
  return { calendarId, year, monthId, day, hour, precision: "hour" };
}
function createMinuteTimestamp(calendarId, year, monthId, day, hour, minute) {
  return { calendarId, year, monthId, day, hour, minute, precision: "minute" };
}
function compareTimestampsWithSchema(schema2, a, b) {
  return compareTimestampParts(a, b, (left, right) => {
    const aIndex = getMonthIndex(schema2, left);
    const bIndex = getMonthIndex(schema2, right);
    if (aIndex === -1 || bIndex === -1) {
      return left.localeCompare(right);
    }
    return aIndex - bIndex;
  });
}
function formatTimestamp(ts, monthName) {
  const month = monthName ?? ts.monthId;
  if (ts.precision === "day") {
    return `Year ${ts.year}, Day ${ts.day} of ${month}`;
  }
  if (ts.precision === "hour") {
    const hour2 = String(ts.hour ?? 0).padStart(2, "0");
    return `Year ${ts.year}, Day ${ts.day} of ${month}, ${hour2}:00`;
  }
  const hour = String(ts.hour ?? 0).padStart(2, "0");
  const minute = String(ts.minute ?? 0).padStart(2, "0");
  return `Year ${ts.year}, Day ${ts.day} of ${month}, ${hour}:${minute}`;
}
function getMonthLength(schema2, monthId) {
  const month = getMonthById(schema2, monthId);
  return month?.length ?? null;
}
function getDayOfYear(schema2, timestamp2) {
  const monthIndex = getMonthIndex(schema2, timestamp2.monthId);
  if (monthIndex === -1) {
    throw new Error(`Month with id ${timestamp2.monthId} not found in schema ${schema2.id}`);
  }
  let days = 0;
  for (let index = 0; index < monthIndex; index++) {
    days += schema2.months[index].length;
  }
  return days + timestamp2.day;
}
function resolveMonthAndDayByDayOfYear(schema2, dayOfYear) {
  if (dayOfYear < 1 || dayOfYear > getTotalDaysInYear(schema2)) {
    throw new RangeError(`Day-of-year ${dayOfYear} is out of range for schema ${schema2.id}`);
  }
  let remaining = dayOfYear;
  for (const month of schema2.months) {
    if (remaining <= month.length) {
      return { monthId: month.id, day: remaining };
    }
    remaining -= month.length;
  }
  throw new RangeError(`Unable to resolve day-of-year ${dayOfYear} for schema ${schema2.id}`);
}
function createTimestampFromDayOfYear(schema2, calendarId, year, dayOfYear) {
  const { monthId, day } = resolveMonthAndDayByDayOfYear(schema2, dayOfYear);
  return createDayTimestamp(calendarId, year, monthId, day);
}
function timestampToAbsoluteDay(schema2, timestamp2) {
  const daysPerYear = getTotalDaysInYear(schema2);
  const dayOfYearIndex = getDayOfYear(schema2, timestamp2) - 1;
  const yearOffset = timestamp2.year - schema2.epoch.year;
  return yearOffset * daysPerYear + dayOfYearIndex;
}
function absoluteDayToTimestamp(schema2, calendarId, absoluteDay) {
  const daysPerYear = getTotalDaysInYear(schema2);
  let yearOffset = Math.floor(absoluteDay / daysPerYear);
  let dayOfYearIndex = absoluteDay - yearOffset * daysPerYear;
  if (dayOfYearIndex < 0) {
    dayOfYearIndex += daysPerYear;
    yearOffset -= 1;
  }
  const targetYear = schema2.epoch.year + yearOffset;
  return createTimestampFromDayOfYear(schema2, calendarId, targetYear, dayOfYearIndex + 1);
}
function clampDayToMonth(schema2, monthId, day) {
  const monthLength = getMonthLength(schema2, monthId);
  if (monthLength === null) {
    throw new Error(`Month with id ${monthId} not found in schema ${schema2.id}`);
  }
  if (day < 1) return 1;
  if (day > monthLength) return monthLength;
  return day;
}
function mod(value, divisor) {
  return (value % divisor + divisor) % divisor;
}
function advanceTime(schema2, current, amount, unit) {
  if (unit === "day") {
    return advanceByDays(schema2, current, amount);
  }
  if (unit === "hour") {
    return advanceByHours(schema2, current, amount);
  }
  return advanceByMinutes(schema2, current, amount);
}
function advanceByDays(schema2, current, days) {
  if (days === 0) {
    return { timestamp: current, normalized: false };
  }
  const startDay = timestampToAbsoluteDay(schema2, current);
  const targetDay = startDay + days;
  const base = absoluteDayToTimestamp(schema2, current.calendarId, targetDay);
  const timestamp2 = rebuildTimestamp(base, current);
  return { timestamp: timestamp2, normalized: base.year !== current.year };
}
function advanceByHours(schema2, current, hours) {
  if (hours === 0) {
    return { timestamp: rebuildTimestamp(current, current), normalized: false };
  }
  const { hoursPerDay } = getTimeDefinition(schema2);
  const currentHour = current.hour ?? 0;
  const totalHours = currentHour + hours;
  const wrappedHour = mod(totalHours, hoursPerDay);
  const dayShift = (totalHours - wrappedHour) / hoursPerDay;
  const baseDay = advanceByDays(schema2, current, dayShift);
  const timestamp2 = current.minute !== void 0 ? createMinuteTimestamp(
    current.calendarId,
    baseDay.timestamp.year,
    baseDay.timestamp.monthId,
    baseDay.timestamp.day,
    wrappedHour,
    current.minute
  ) : createHourTimestamp(
    current.calendarId,
    baseDay.timestamp.year,
    baseDay.timestamp.monthId,
    baseDay.timestamp.day,
    wrappedHour
  );
  const normalized = dayShift !== 0 || baseDay.normalized;
  return {
    timestamp: timestamp2,
    normalized,
    carriedDays: dayShift !== 0 ? dayShift : void 0,
    carriedHours: hours
  };
}
function advanceByMinutes(schema2, current, minutes) {
  if (minutes === 0) {
    return { timestamp: rebuildTimestamp(current, current), normalized: false };
  }
  const { hoursPerDay, minutesPerHour } = getTimeDefinition(schema2);
  const minutesPerDay = hoursPerDay * minutesPerHour;
  const startDay = timestampToAbsoluteDay(schema2, current);
  const originalHour = current.hour ?? 0;
  const startMinuteOfDay = originalHour * minutesPerHour + (current.minute ?? 0);
  let totalMinutes = startDay * minutesPerDay + startMinuteOfDay + minutes;
  let dayIndex = Math.floor(totalMinutes / minutesPerDay);
  let minuteOfDay = totalMinutes - dayIndex * minutesPerDay;
  if (minuteOfDay < 0) {
    minuteOfDay += minutesPerDay;
    dayIndex -= 1;
  }
  const hour = Math.floor(minuteOfDay / minutesPerHour);
  const minute = minuteOfDay - hour * minutesPerHour;
  const baseDay = absoluteDayToTimestamp(schema2, current.calendarId, dayIndex);
  const timestamp2 = createMinuteTimestamp(
    current.calendarId,
    baseDay.year,
    baseDay.monthId,
    baseDay.day,
    hour,
    minute
  );
  const normalized = hour !== originalHour || dayIndex !== startDay;
  return { timestamp: timestamp2, normalized };
}
function rebuildTimestamp(base, template) {
  if (template.minute !== void 0) {
    return createMinuteTimestamp(
      template.calendarId,
      base.year,
      base.monthId,
      base.day,
      template.hour ?? 0,
      template.minute
    );
  }
  if (template.hour !== void 0) {
    return createHourTimestamp(template.calendarId, base.year, base.monthId, base.day, template.hour);
  }
  return createDayTimestamp(template.calendarId, base.year, base.monthId, base.day);
}
function compareTimestampParts(a, b, compareMonth) {
  if (a.year !== b.year) {
    return a.year - b.year;
  }
  if (a.monthId !== b.monthId) {
    const monthComparison = compareMonth(a.monthId, b.monthId);
    if (monthComparison !== 0) {
      return monthComparison;
    }
  }
  if (a.day !== b.day) {
    return a.day - b.day;
  }
  const hourA = a.hour ?? 0;
  const hourB = b.hour ?? 0;
  if (hourA !== hourB) {
    return hourA - hourB;
  }
  const minuteA = a.minute ?? 0;
  const minuteB = b.minute ?? 0;
  return minuteA - minuteB;
}
function sortHooksByPriority(hooks) {
  return [...hooks].sort((a, b) => {
    const priorityA = a.priority ?? 0;
    const priorityB = b.priority ?? 0;
    if (priorityA !== priorityB) {
      return priorityB - priorityA;
    }
    return a.id.localeCompare(b.id);
  });
}
function calculateNextOccurrence(schema2, calendarId, rule, start, options = {}, services = {}) {
  const includeStart = options.includeStart ?? false;
  switch (rule.type) {
    case "annual":
    case "annual_offset":
      return resolveNextAnnualOccurrence(schema2, calendarId, rule, start, includeStart);
    case "monthly_position":
      return resolveNextMonthlyOccurrence(schema2, calendarId, rule, start, includeStart);
    case "weekly_dayIndex":
      return resolveNextWeeklyOccurrence(schema2, calendarId, rule, start, includeStart);
    case "astronomical":
      return resolveNextAstronomicalOccurrence(schema2, calendarId, rule, start, options, services);
    case "custom":
      throw new UnsupportedRepeatRuleError(rule.type);
    default: {
      const _never = rule;
      return _never;
    }
  }
}
function calculateOccurrencesInRange(schema2, calendarId, rule, rangeStart, rangeEnd, options = {}, services = {}) {
  const limit = options.limit ?? 12;
  if (limit <= 0) return [];
  const compare = compareTimestampsWithSchema(schema2, rangeStart, rangeEnd);
  const [start, end] = compare <= 0 ? [rangeStart, rangeEnd] : [rangeEnd, rangeStart];
  if (rule.type === "astronomical") {
    return resolveAstronomicalRange(schema2, calendarId, rule, start, end, options, services).slice(0, limit);
  }
  const occurrences = [];
  let cursor = calculateNextOccurrence(schema2, calendarId, rule, start, options, services);
  while (cursor && occurrences.length < limit && compareTimestampsWithSchema(schema2, cursor, end) <= 0) {
    occurrences.push(cursor);
    cursor = calculateNextOccurrence(schema2, calendarId, rule, cursor, { includeStart: false }, services);
    if (cursor && occurrences.length > 0) {
      const prev = occurrences[occurrences.length - 1];
      if (compareTimestampsWithSchema(schema2, cursor, prev) === 0) {
        break;
      }
    }
  }
  return occurrences;
}
function resolveNextAnnualOccurrence(schema2, calendarId, rule, start, includeStart) {
  const totalDays = getTotalDaysInYear(schema2);
  if (totalDays <= 0) {
    throw new InvalidRepeatRuleError(`Calendar schema ${schema2.id} has no days configured.`);
  }
  const zeroBased = ((rule.offsetDayOfYear - 1) % totalDays + totalDays) % totalDays;
  const normalisedOffset = zeroBased + 1;
  const candidateCurrentYear = createTimestampFromDayOfYear(schema2, calendarId, start.year, normalisedOffset);
  const comparison = compareTimestampsWithSchema(schema2, candidateCurrentYear, start);
  if (comparison > 0 || comparison === 0 && includeStart) {
    return candidateCurrentYear;
  }
  return createTimestampFromDayOfYear(schema2, calendarId, start.year + 1, normalisedOffset);
}
function resolveNextMonthlyOccurrence(schema2, calendarId, rule, start, includeStart) {
  const monthLength = clampDayToMonth(schema2, rule.monthId, rule.day);
  const initialCandidate = createDayTimestamp(calendarId, start.year, rule.monthId, monthLength);
  const comparison = compareTimestampsWithSchema(schema2, initialCandidate, start);
  if (comparison > 0 || comparison === 0 && includeStart) {
    return initialCandidate;
  }
  return createDayTimestamp(calendarId, start.year + 1, rule.monthId, monthLength);
}
function resolveNextWeeklyOccurrence(schema2, calendarId, rule, start, includeStart) {
  const daysPerWeek = schema2.daysPerWeek;
  if (rule.dayIndex < 0 || rule.dayIndex >= daysPerWeek) {
    throw new InvalidRepeatRuleError(`dayIndex ${rule.dayIndex} is out of range for schema ${schema2.id}`);
  }
  const interval = Math.max(1, rule.interval ?? 1);
  const absoluteStart = timestampToAbsoluteDay(schema2, start);
  const currentDayIndex = mod(absoluteStart, daysPerWeek);
  let delta = mod(rule.dayIndex - currentDayIndex, daysPerWeek);
  if (delta === 0 && !includeStart) {
    delta = daysPerWeek * interval;
  }
  const intervalDays = daysPerWeek * interval;
  if (delta % daysPerWeek !== 0 && interval > 1) {
    delta += mod(intervalDays - delta % intervalDays, intervalDays);
  }
  const candidateAbsolute = absoluteStart + delta;
  return absoluteDayToTimestamp(schema2, calendarId, candidateAbsolute);
}
function resolveNextAstronomicalOccurrence(schema2, calendarId, rule, start, options, services) {
  const calculator = services.astronomicalCalculator;
  if (!calculator) {
    throw new UnsupportedRepeatRuleError(rule.type);
  }
  return calculator.resolveNextOccurrence(schema2, calendarId, rule, start, options);
}
function resolveAstronomicalRange(schema2, calendarId, rule, rangeStart, rangeEnd, options, services) {
  const calculator = services.astronomicalCalculator;
  if (!calculator) {
    throw new UnsupportedRepeatRuleError(rule.type);
  }
  return calculator.resolveOccurrencesInRange(schema2, calendarId, rule, rangeStart, rangeEnd, options);
}
function isSingleEvent(event) {
  return event.kind === "single";
}
function getEventAnchorTimestamp(event) {
  if (isSingleEvent(event)) {
    return event.date;
  }
  return event.bounds?.start ?? event.date ?? null;
}
function computeEventOccurrencesInRange(event, schema2, calendarId, rangeStart, rangeEnd, options = {}) {
  if (isSingleEvent(event)) {
    const occurrences = [];
    const inRange = isTimestampInRange(schema2, event.date, rangeStart, rangeEnd, options.includeStart ?? false);
    if (inRange) {
      occurrences.push(buildSingleEventOccurrence(event, schema2));
    }
    return occurrences;
  }
  const effectiveStart = resolveRecurringSearchStart(event, schema2, rangeStart);
  if (!effectiveStart) {
    return [];
  }
  const { services, ...ruleOptions } = options;
  const baseOccurrences = calculateOccurrencesInRange(
    schema2,
    calendarId,
    event.rule,
    effectiveStart,
    rangeEnd,
    ruleOptions,
    services
  );
  return baseOccurrences.filter((timestamp2) => isWithinBounds(event.bounds, schema2, timestamp2)).map((timestamp2) => buildRecurringEventOccurrence(event, schema2, calendarId, timestamp2));
}
function buildSingleEventOccurrence(event, schema2) {
  const { start, end, durationMinutes } = resolveSingleEventWindow(event, schema2);
  const hooks = event.hooks ? sortHooksByPriority(event.hooks) : [];
  return {
    eventId: event.id,
    calendarId: event.calendarId,
    eventType: "single",
    title: event.title,
    category: event.category,
    start,
    end,
    durationMinutes,
    allDay: event.allDay,
    priority: event.priority ?? 0,
    hooks,
    source: event
  };
}
function buildRecurringEventOccurrence(event, schema2, calendarId, baseTimestamp) {
  const { start, end, durationMinutes } = applyRecurringTimePolicy(event, schema2, calendarId, baseTimestamp);
  const hooks = event.hooks ? sortHooksByPriority(event.hooks) : [];
  return {
    eventId: event.id,
    calendarId,
    eventType: "recurring",
    title: event.title,
    category: event.category,
    start,
    end,
    durationMinutes,
    allDay: event.timePolicy === "all_day",
    priority: event.priority ?? 0,
    hooks,
    source: event
  };
}
function resolveSingleEventWindow(event, schema2) {
  const { minutesPerHour, hoursPerDay } = getTimeDefinition(schema2);
  const minutesPerDay = hoursPerDay * minutesPerHour;
  const base = event.date;
  const start = event.allDay ? base : createMinuteTimestamp(
    base.calendarId,
    base.year,
    base.monthId,
    base.day,
    event.startTime?.hour ?? base.hour ?? 0,
    event.startTime?.minute ?? base.minute ?? 0
  );
  const requestedDuration = event.endTime ? Math.max(
    event.durationMinutes ?? 0,
    calculateDurationFromTimes(event.startTime, event.endTime, minutesPerHour, hoursPerDay)
  ) : event.durationMinutes ?? 0;
  const duration = resolveDuration(requestedDuration, event.allDay ? minutesPerDay : 0);
  return createWindow(schema2, start, duration);
}
function applyRecurringTimePolicy(event, schema2, calendarId, baseTimestamp) {
  const { minutesPerHour, hoursPerDay } = getTimeDefinition(schema2);
  const minutesPerDay = hoursPerDay * minutesPerHour;
  switch (event.timePolicy) {
    case "all_day":
      return createWindow(schema2, baseTimestamp, resolveDuration(event.durationMinutes, minutesPerDay));
    case "fixed": {
      const start = createMinuteTimestamp(
        calendarId,
        baseTimestamp.year,
        baseTimestamp.monthId,
        baseTimestamp.day,
        event.startTime?.hour ?? 0,
        event.startTime?.minute ?? 0
      );
      return createWindow(schema2, start, resolveDuration(event.durationMinutes, 0));
    }
    case "offset": {
      const start = advanceTime(schema2, baseTimestamp, event.offsetMinutes ?? 0, "minute").timestamp;
      return createWindow(schema2, start, resolveDuration(event.durationMinutes, 0));
    }
    default: {
      const _never = event.timePolicy;
      return _never;
    }
  }
}
function calculateDurationFromTimes(startTime, endTime, minutesPerHour, hoursPerDay) {
  const startMinutes = timeOfDayToMinutes(startTime ?? { hour: 0, minute: 0 }, minutesPerHour);
  const endMinutes = timeOfDayToMinutes(endTime, minutesPerHour);
  const dailyMinutes = hoursPerDay * minutesPerHour;
  const raw = endMinutes - startMinutes;
  if (raw <= 0) {
    return dailyMinutes + raw;
  }
  return raw;
}
function timeOfDayToMinutes(time, minutesPerHour) {
  return time.hour * minutesPerHour + (time.minute ?? 0);
}
function isTimestampInRange(schema2, timestamp2, start, end, includeStart) {
  const [rangeStart, rangeEnd] = compareTimestampsWithSchema(schema2, start, end) <= 0 ? [start, end] : [end, start];
  const afterStart = compareTimestampsWithSchema(schema2, timestamp2, rangeStart);
  const beforeEnd = compareTimestampsWithSchema(schema2, timestamp2, rangeEnd);
  const startOk = includeStart ? afterStart >= 0 : afterStart > 0;
  return startOk && beforeEnd <= 0;
}
function resolveRecurringSearchStart(event, schema2, start) {
  const boundsStart = event.bounds?.start;
  if (!boundsStart) {
    return start;
  }
  const comparison = compareTimestampsWithSchema(schema2, start, boundsStart);
  if (comparison >= 0) {
    return start;
  }
  return boundsStart;
}
function isWithinBounds(bounds, schema2, timestamp2) {
  if (!bounds) {
    return true;
  }
  if (bounds.start && compareTimestampsWithSchema(schema2, timestamp2, bounds.start) < 0) {
    return false;
  }
  if (bounds.end && compareTimestampsWithSchema(schema2, timestamp2, bounds.end) > 0) {
    return false;
  }
  return true;
}
function resolveDuration(durationMinutes, fallback) {
  if (durationMinutes === void 0 || durationMinutes <= 0) {
    return fallback;
  }
  return durationMinutes;
}
function createWindow(schema2, start, durationMinutes) {
  const duration = Math.max(0, durationMinutes);
  if (duration === 0) {
    return { start, end: start, durationMinutes: 0 };
  }
  const end = advanceTime(schema2, start, duration, "minute").timestamp;
  return { start, end, durationMinutes: duration };
}
var DEFAULT_TIME_DEFINITION, UnsupportedRepeatRuleError, InvalidRepeatRuleError;
var init_domain = __esm({
  "src/workmodes/almanac/domain/index.ts"() {
    "use strict";
    DEFAULT_TIME_DEFINITION = {
      hoursPerDay: 24,
      minutesPerHour: 60,
      secondsPerMinute: 60,
      minuteStep: 1
    };
    UnsupportedRepeatRuleError = class extends Error {
      constructor(ruleType) {
        super(`Repeat rule type "${ruleType}" is not supported yet.`);
        this.name = "UnsupportedRepeatRuleError";
      }
    };
    InvalidRepeatRuleError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "InvalidRepeatRuleError";
      }
    };
  }
});

// src/workmodes/almanac/view/almanac-time-display.ts
function createAlmanacTimeDisplay(options) {
  const root = document.createElement("div");
  root.classList.add("sm-almanac-time-display");
  const timeDisplay = document.createElement("div");
  timeDisplay.classList.add("sm-almanac-time-display__current");
  const timeLabel = document.createElement("div");
  timeLabel.classList.add("sm-almanac-time-display__label");
  timeLabel.textContent = "Current Time";
  timeDisplay.appendChild(timeLabel);
  const timeValue = document.createElement("div");
  timeValue.classList.add("sm-almanac-time-display__value");
  updateTimeValue(timeValue, options.currentTimestamp, options.schema);
  timeDisplay.appendChild(timeValue);
  root.appendChild(timeDisplay);
  const controls = document.createElement("div");
  controls.classList.add("sm-almanac-time-display__controls");
  const createControl = (label, onClickForward, onClickBackward) => {
    const group = document.createElement("div");
    group.classList.add("sm-almanac-time-display__control-group");
    const controlLabel = document.createElement("span");
    controlLabel.classList.add("sm-almanac-time-display__control-label");
    controlLabel.textContent = label;
    group.appendChild(controlLabel);
    const backwardBtn = document.createElement("button");
    backwardBtn.type = "button";
    backwardBtn.classList.add("sm-almanac-time-display__control-btn");
    backwardBtn.textContent = "\u2212";
    backwardBtn.addEventListener("click", onClickBackward);
    group.appendChild(backwardBtn);
    const forwardBtn = document.createElement("button");
    forwardBtn.type = "button";
    forwardBtn.classList.add("sm-almanac-time-display__control-btn");
    forwardBtn.textContent = "+";
    forwardBtn.addEventListener("click", onClickForward);
    group.appendChild(forwardBtn);
    controls.appendChild(group);
  };
  createControl(
    "Day",
    () => options.onAdvanceDay(1),
    () => options.onAdvanceDay(-1)
  );
  createControl(
    "Hour",
    () => options.onAdvanceHour(1),
    () => options.onAdvanceHour(-1)
  );
  createControl(
    "Minute (\xB11)",
    () => options.onAdvanceMinute(1),
    () => options.onAdvanceMinute(-1)
  );
  root.appendChild(controls);
  function updateTimeValue(element, timestamp2, schema2) {
    if (!timestamp2 || !schema2) {
      element.textContent = "No active calendar";
      element.classList.add("is-empty");
      return;
    }
    element.classList.remove("is-empty");
    const monthName = schema2.months.find((m) => m.id === timestamp2.monthId)?.name;
    element.textContent = formatTimestamp(timestamp2, monthName);
  }
  return {
    root,
    update(timestamp2, schema2) {
      updateTimeValue(timeValue, timestamp2, schema2);
    },
    destroy() {
      root.replaceChildren();
    }
  };
}
var init_almanac_time_display = __esm({
  "src/workmodes/almanac/view/almanac-time-display.ts"() {
    "use strict";
    init_domain();
  }
});

// src/workmodes/almanac/view/upcoming-events-list.ts
function createUpcomingEventsList(options) {
  const root = document.createElement("div");
  root.classList.add("sm-almanac-upcoming-events");
  const header = document.createElement("div");
  header.classList.add("sm-almanac-upcoming-events__header");
  header.textContent = "Upcoming Events (Next 7 Days)";
  root.appendChild(header);
  const list = document.createElement("ul");
  list.classList.add("sm-almanac-upcoming-events__list");
  root.appendChild(list);
  function updateList(events, phenomena, schema2, currentTimestamp) {
    list.replaceChildren();
    if (!schema2 || !currentTimestamp) {
      const emptyItem = document.createElement("li");
      emptyItem.classList.add("sm-almanac-upcoming-events__item", "is-empty");
      emptyItem.textContent = "No active calendar";
      list.appendChild(emptyItem);
      return;
    }
    const rangeEnd = advanceTime(schema2, currentTimestamp, 7, "day").timestamp;
    const occurrences = [];
    for (const event of events) {
      const eventOccurrences = computeEventOccurrencesInRange(
        event,
        schema2,
        event.calendarId,
        currentTimestamp,
        rangeEnd,
        { includeStart: true, limit: 10 }
      );
      for (const occurrence of eventOccurrences) {
        occurrences.push({
          type: "event",
          timestamp: occurrence.start,
          title: occurrence.title,
          category: occurrence.category,
          id: occurrence.eventId,
          source: event
        });
      }
    }
    for (const phenomenon of phenomena) {
      occurrences.push({
        type: "phenomenon",
        timestamp: phenomenon.timestamp,
        title: phenomenon.name,
        category: phenomenon.category,
        id: phenomenon.phenomenonId
      });
    }
    occurrences.sort((a, b) => {
      const timestampA = a.timestamp;
      const timestampB = b.timestamp;
      if (timestampA.year !== timestampB.year) {
        return timestampA.year - timestampB.year;
      }
      const monthA = schema2.months.findIndex((m) => m.id === timestampA.monthId);
      const monthB = schema2.months.findIndex((m) => m.id === timestampB.monthId);
      if (monthA !== monthB) {
        return monthA - monthB;
      }
      if (timestampA.day !== timestampB.day) {
        return timestampA.day - timestampB.day;
      }
      const hourA = timestampA.hour ?? 0;
      const hourB = timestampB.hour ?? 0;
      if (hourA !== hourB) {
        return hourA - hourB;
      }
      const minuteA = timestampA.minute ?? 0;
      const minuteB = timestampB.minute ?? 0;
      return minuteA - minuteB;
    });
    if (occurrences.length === 0) {
      const emptyItem = document.createElement("li");
      emptyItem.classList.add("sm-almanac-upcoming-events__item", "is-empty");
      emptyItem.textContent = "No upcoming events";
      list.appendChild(emptyItem);
      return;
    }
    for (const occurrence of occurrences) {
      const item = document.createElement("li");
      item.classList.add("sm-almanac-upcoming-events__item");
      item.dataset.type = occurrence.type;
      if (occurrence.category) {
        item.dataset.category = occurrence.category;
      }
      const monthName = schema2.months.find((m) => m.id === occurrence.timestamp.monthId)?.name;
      const timestampText = formatTimestamp(occurrence.timestamp, monthName);
      const timestampSpan = document.createElement("span");
      timestampSpan.classList.add("sm-almanac-upcoming-events__timestamp");
      timestampSpan.textContent = timestampText;
      item.appendChild(timestampSpan);
      const titleSpan = document.createElement("span");
      titleSpan.classList.add("sm-almanac-upcoming-events__title");
      titleSpan.textContent = occurrence.title;
      item.appendChild(titleSpan);
      const typeSpan = document.createElement("span");
      typeSpan.classList.add("sm-almanac-upcoming-events__type");
      typeSpan.textContent = occurrence.type === "event" ? "Event" : "Phenomenon";
      item.appendChild(typeSpan);
      if (occurrence.type === "event" && occurrence.source && options.onEventClick) {
        item.classList.add("is-clickable");
        item.addEventListener("click", () => {
          if (occurrence.source) {
            options.onEventClick?.(occurrence.source);
          }
        });
      }
      list.appendChild(item);
    }
  }
  updateList(options.events, options.phenomena, options.schema, options.currentTimestamp);
  return {
    root,
    update: updateList,
    destroy() {
      list.replaceChildren();
      root.replaceChildren();
    }
  };
}
var init_upcoming_events_list = __esm({
  "src/workmodes/almanac/view/upcoming-events-list.ts"() {
    "use strict";
    init_domain();
  }
});

// src/workmodes/almanac/view/month-view-calendar.ts
function createMonthViewCalendar(options) {
  const root = document.createElement("div");
  root.classList.add("sm-almanac-month-view");
  const header = document.createElement("div");
  header.classList.add("sm-almanac-month-view__header");
  root.appendChild(header);
  const grid = document.createElement("div");
  grid.classList.add("sm-almanac-month-view__grid");
  root.appendChild(grid);
  function updateGrid(events, phenomena, schema2, currentTimestamp) {
    header.replaceChildren();
    grid.replaceChildren();
    if (!schema2 || !currentTimestamp) {
      const emptyMessage = document.createElement("div");
      emptyMessage.classList.add("sm-almanac-month-view__empty");
      emptyMessage.textContent = "No active calendar";
      grid.appendChild(emptyMessage);
      return;
    }
    const currentMonth = schema2.months.find((m) => m.id === currentTimestamp.monthId);
    if (!currentMonth) {
      const errorMessage = document.createElement("div");
      errorMessage.classList.add("sm-almanac-month-view__error");
      errorMessage.textContent = "Invalid month ID";
      grid.appendChild(errorMessage);
      return;
    }
    const monthYearTitle = document.createElement("h3");
    monthYearTitle.classList.add("sm-almanac-month-view__month-title");
    monthYearTitle.textContent = `${currentMonth.name} ${currentTimestamp.year}`;
    header.appendChild(monthYearTitle);
    const weekdayNames = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    const weekdayHeader = document.createElement("div");
    weekdayHeader.classList.add("sm-almanac-month-view__weekday-header");
    for (const weekday of weekdayNames) {
      const weekdayCell = document.createElement("div");
      weekdayCell.classList.add("sm-almanac-month-view__weekday");
      weekdayCell.textContent = weekday;
      weekdayHeader.appendChild(weekdayCell);
    }
    grid.appendChild(weekdayHeader);
    const dayCells = [];
    const monthLength = currentMonth.length;
    const firstWeekday = 0;
    for (let i = 0; i < firstWeekday; i++) {
      dayCells.push({
        day: 0,
        isCurrentDay: false,
        isOtherMonth: true,
        events: [],
        phenomena: []
      });
    }
    for (let day = 1; day <= monthLength; day++) {
      const dayTimestamp = {
        calendarId: currentTimestamp.calendarId,
        year: currentTimestamp.year,
        monthId: currentTimestamp.monthId,
        day,
        hour: 0,
        minute: 0,
        precision: "minute"
      };
      const isCurrentDay = day === currentTimestamp.day;
      const dayStart = dayTimestamp;
      const dayEnd = advanceTime(schema2, dayTimestamp, 1, "day").timestamp;
      const dayEvents = [];
      for (const event of events) {
        const occurrences = computeEventOccurrencesInRange(
          event,
          schema2,
          event.calendarId,
          dayStart,
          dayEnd,
          { includeStart: true, limit: 10 }
        );
        if (occurrences.length > 0) {
          dayEvents.push(event);
        }
      }
      const dayPhenomena = phenomena.filter((p) => {
        const ts = p.timestamp;
        return ts.year === currentTimestamp.year && ts.monthId === currentTimestamp.monthId && ts.day === day;
      });
      dayCells.push({
        day,
        isCurrentDay,
        isOtherMonth: false,
        events: dayEvents,
        phenomena: dayPhenomena
      });
    }
    const remainingCells = 7 - dayCells.length % 7;
    if (remainingCells < 7) {
      for (let i = 0; i < remainingCells; i++) {
        dayCells.push({
          day: 0,
          isCurrentDay: false,
          isOtherMonth: true,
          events: [],
          phenomena: []
        });
      }
    }
    for (const cell of dayCells) {
      const dayCell = document.createElement("div");
      dayCell.classList.add("sm-almanac-month-view__day");
      if (cell.isOtherMonth) {
        dayCell.classList.add("is-other-month");
      } else {
        if (cell.isCurrentDay) {
          dayCell.classList.add("is-current-day");
        }
        const dayNumber = document.createElement("div");
        dayNumber.classList.add("sm-almanac-month-view__day-number");
        dayNumber.textContent = String(cell.day);
        dayCell.appendChild(dayNumber);
        if (cell.events.length > 0 || cell.phenomena.length > 0) {
          const indicators = document.createElement("div");
          indicators.classList.add("sm-almanac-month-view__event-indicators");
          const totalCount = cell.events.length + cell.phenomena.length;
          const indicator = document.createElement("div");
          indicator.classList.add("sm-almanac-month-view__event-indicator");
          indicator.textContent = String(totalCount);
          indicator.title = `${cell.events.length} event(s), ${cell.phenomena.length} phenomenon(a)`;
          indicators.appendChild(indicator);
          dayCell.appendChild(indicators);
        }
        if (options.onDayClick) {
          dayCell.classList.add("is-clickable");
          const dayTimestamp = {
            calendarId: currentTimestamp.calendarId,
            year: currentTimestamp.year,
            monthId: currentTimestamp.monthId,
            day: cell.day,
            hour: currentTimestamp.hour ?? 0,
            minute: currentTimestamp.minute ?? 0,
            precision: "minute"
          };
          dayCell.addEventListener("click", () => {
            options.onDayClick?.(dayTimestamp);
          });
        }
      }
      grid.appendChild(dayCell);
    }
  }
  updateGrid(options.events, options.phenomena, options.schema, options.currentTimestamp);
  return {
    root,
    update: updateGrid,
    destroy() {
      grid.replaceChildren();
      header.replaceChildren();
      root.replaceChildren();
    }
  };
}
var init_month_view_calendar = __esm({
  "src/workmodes/almanac/view/month-view-calendar.ts"() {
    "use strict";
    init_domain();
  }
});

// src/workmodes/almanac/view/almanac-mvp.ts
var almanac_mvp_exports = {};
__export(almanac_mvp_exports, {
  renderAlmanacMVP: () => renderAlmanacMVP
});
async function renderAlmanacMVP(app, container) {
  logger2.info("[almanac-mvp] Rendering Almanac MVP");
  const root = container.createDiv({ cls: "sm-almanac-mvp" });
  const notice = root.createDiv({ cls: "sm-almanac-mvp__notice" });
  notice.createEl("h3", { text: "Almanac MVP" });
  notice.createEl("p", {
    text: "This is a minimal viable implementation. Full calendar views (month/week/timeline) and event editor are planned for future updates."
  });
  const mockSchema = {
    id: "gregorian-standard",
    name: "Gregorian Calendar",
    description: "Standard Gregorian calendar for testing",
    daysPerWeek: 7,
    months: [
      { id: "jan", name: "January", length: 31 },
      { id: "feb", name: "February", length: 28 },
      { id: "mar", name: "March", length: 31 },
      { id: "apr", name: "April", length: 30 },
      { id: "may", name: "May", length: 31 },
      { id: "jun", name: "June", length: 30 },
      { id: "jul", name: "July", length: 31 },
      { id: "aug", name: "August", length: 31 },
      { id: "sep", name: "September", length: 30 },
      { id: "oct", name: "October", length: 31 },
      { id: "nov", name: "November", length: 30 },
      { id: "dec", name: "December", length: 31 }
    ],
    hoursPerDay: 24,
    minutesPerHour: 60,
    secondsPerMinute: 60,
    minuteStep: 1,
    epoch: {
      year: 1,
      monthId: "jan",
      day: 1
    },
    schemaVersion: "1.0.0"
  };
  let currentTimestamp = {
    calendarId: "gregorian-standard",
    year: 2025,
    monthId: "jan",
    day: 1,
    hour: 12,
    minute: 0,
    precision: "minute"
  };
  const mockEvents = [];
  const mockPhenomena = [];
  let timeDisplay = null;
  let eventsList = null;
  let monthView = null;
  let currentView = "list";
  function updateAllViews() {
    timeDisplay?.update(currentTimestamp, mockSchema);
    eventsList?.update(mockEvents, mockPhenomena, mockSchema, currentTimestamp);
    monthView?.update(mockEvents, mockPhenomena, mockSchema, currentTimestamp);
  }
  function handleAdvanceDay(amount) {
    logger2.info("[almanac-mvp] Advancing time by days", { amount });
    const result = advanceTime(mockSchema, currentTimestamp, amount, "day");
    currentTimestamp = result.timestamp;
    updateAllViews();
  }
  function handleAdvanceHour(amount) {
    logger2.info("[almanac-mvp] Advancing time by hours", { amount });
    const result = advanceTime(mockSchema, currentTimestamp, amount, "hour");
    currentTimestamp = result.timestamp;
    updateAllViews();
  }
  function handleAdvanceMinute(amount) {
    logger2.info("[almanac-mvp] Advancing time by minutes", { amount });
    const result = advanceTime(mockSchema, currentTimestamp, amount, "minute");
    currentTimestamp = result.timestamp;
    updateAllViews();
  }
  timeDisplay = createAlmanacTimeDisplay({
    currentTimestamp,
    schema: mockSchema,
    onAdvanceDay: handleAdvanceDay,
    onAdvanceHour: handleAdvanceHour,
    onAdvanceMinute: handleAdvanceMinute
  });
  root.appendChild(timeDisplay.root);
  const viewSwitcher = root.createDiv({ cls: "sm-almanac-mvp__view-switcher" });
  const listViewBtn = viewSwitcher.createEl("button", {
    text: "List View",
    cls: "sm-almanac-mvp__view-btn is-active"
  });
  const monthViewBtn = viewSwitcher.createEl("button", {
    text: "Month View",
    cls: "sm-almanac-mvp__view-btn"
  });
  const viewContainer = root.createDiv({ cls: "sm-almanac-mvp__view-container" });
  function switchView(view) {
    currentView = view;
    logger2.info("[almanac-mvp] Switching view", { view });
    listViewBtn.classList.toggle("is-active", view === "list");
    monthViewBtn.classList.toggle("is-active", view === "month");
    viewContainer.replaceChildren();
    if (view === "list") {
      if (eventsList) {
        viewContainer.appendChild(eventsList.root);
      }
    } else {
      if (monthView) {
        viewContainer.appendChild(monthView.root);
      }
    }
  }
  listViewBtn.addEventListener("click", () => switchView("list"));
  monthViewBtn.addEventListener("click", () => switchView("month"));
  eventsList = createUpcomingEventsList({
    events: mockEvents,
    phenomena: mockPhenomena,
    schema: mockSchema,
    currentTimestamp,
    onEventClick: (event) => {
      logger2.info("[almanac-mvp] Event clicked", { eventId: event.id });
      openEventEditor(app, {
        event,
        onSave: (updatedEvent) => {
          logger2.info("[almanac-mvp] Event updated", { eventId: updatedEvent.id });
          new import_obsidian37.Notice("Event updated successfully");
        }
      });
    }
  });
  monthView = createMonthViewCalendar({
    events: mockEvents,
    phenomena: mockPhenomena,
    schema: mockSchema,
    currentTimestamp,
    onDayClick: (timestamp2) => {
      logger2.info("[almanac-mvp] Day clicked", { timestamp: timestamp2 });
    },
    onEventClick: (event) => {
      logger2.info("[almanac-mvp] Event clicked in month view", { eventId: event.id });
      openEventEditor(app, {
        event,
        onSave: (updatedEvent) => {
          logger2.info("[almanac-mvp] Event updated", { eventId: updatedEvent.id });
          new import_obsidian37.Notice("Event updated successfully");
        }
      });
    }
  });
  switchView("list");
  const futureNotice = root.createDiv({ cls: "sm-almanac-mvp__future-notice" });
  futureNotice.createEl("h4", { text: "Coming Soon" });
  const featureList = futureNotice.createEl("ul");
  featureList.createEl("li", { text: "Week/Timeline calendar views" });
  featureList.createEl("li", { text: "Event and phenomenon editor" });
  featureList.createEl("li", { text: "Astronomical cycles visualization" });
  featureList.createEl("li", { text: "Event inbox with priority sorting" });
  featureList.createEl("li", { text: "Integration with vault calendar data" });
  logger2.info("[almanac-mvp] Almanac MVP rendered successfully with month view");
}
var import_obsidian37;
var init_almanac_mvp = __esm({
  "src/workmodes/almanac/view/almanac-mvp.ts"() {
    "use strict";
    import_obsidian37 = require("obsidian");
    init_almanac_time_display();
    init_upcoming_events_list();
    init_month_view_calendar();
    init_domain();
    init_plugin_logger();
    init_event_editor_modal();
  }
});

// src/workmodes/almanac/mode/travel/travel-calendar-toolbar.ts
function createModeLabel(mode) {
  switch (mode) {
    case "day":
      return "Tag";
    case "week":
      return "Woche";
    case "month":
      return "Monat";
    default:
      return "N\xE4chste";
  }
}
var MODE_ORDER, TravelCalendarToolbar;
var init_travel_calendar_toolbar = __esm({
  "src/workmodes/almanac/mode/travel/travel-calendar-toolbar.ts"() {
    "use strict";
    MODE_ORDER = ["upcoming", "day", "week", "month"];
    TravelCalendarToolbar = class {
      constructor(options) {
        this.modeButtons = /* @__PURE__ */ new Map();
        this.disabled = false;
        this.options = options;
        this.mode = options.mode;
        this.root = document.createElement("div");
        this.root.classList.add("sm-almanac-travel__toolbar");
        const modeGroup = document.createElement("div");
        modeGroup.classList.add("sm-almanac-travel__toolbar-modes");
        this.root.appendChild(modeGroup);
        for (const mode of MODE_ORDER) {
          const button = document.createElement("button");
          button.type = "button";
          button.classList.add("sm-almanac-travel__toolbar-mode");
          button.dataset.mode = mode;
          button.textContent = createModeLabel(mode);
          button.addEventListener("click", () => {
            if (this.disabled || this.mode === mode) {
              return;
            }
            this.options.onChangeMode(mode);
          });
          modeGroup.appendChild(button);
          this.modeButtons.set(mode, button);
        }
        const actions = document.createElement("div");
        actions.classList.add("sm-almanac-travel__toolbar-actions");
        this.root.appendChild(actions);
        const createStepButton = (label, onClick, shortcut, direction) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.classList.add("sm-almanac-travel__toolbar-step");
          btn.dataset.direction = direction;
          btn.textContent = label;
          if (shortcut) {
            btn.setAttribute("aria-keyshortcuts", shortcut);
          }
          btn.addEventListener("click", () => {
            if (!this.disabled && this.canUseDirection(direction)) {
              onClick();
            }
          });
          actions.appendChild(btn);
          return btn;
        };
        createStepButton("\u2212Tag", () => this.options.onStepDay("backward"), "Ctrl+Alt+,", "backward");
        createStepButton("+Tag", () => this.options.onStepDay("forward"), "Ctrl+Alt+.", "forward");
        createStepButton("\u2212Std", () => this.options.onStepHour("backward"), "Ctrl+Alt+'", "backward");
        createStepButton("+Std", () => this.options.onStepHour("forward"), "Ctrl+Alt+;", "forward");
        createStepButton("\u2212Min", () => this.options.onStepMinute("backward"), "Ctrl+Alt+[", "backward");
        createStepButton("+Min", () => this.options.onStepMinute("forward"), "Ctrl+Alt+]", "forward");
        const jumpButton = createStepButton("Sprung", () => this.options.onJump(), void 0, "forward");
        jumpButton.classList.add("sm-almanac-travel__toolbar-jump");
        const closeButton = document.createElement("button");
        closeButton.type = "button";
        closeButton.classList.add("sm-almanac-travel__toolbar-close");
        closeButton.textContent = "Schlie\xDFen";
        closeButton.addEventListener("click", () => {
          if (!this.disabled) {
            this.options.onClose();
          }
        });
        this.root.appendChild(closeButton);
        this.setMode(options.mode);
        this.updateStepAvailability();
      }
      setMode(mode) {
        this.mode = mode;
        for (const [value, button] of this.modeButtons.entries()) {
          const active = value === mode;
          button.classList.toggle("is-active", active);
          button.setAttribute("aria-pressed", active ? "true" : "false");
        }
      }
      setDisabled(disabled) {
        this.disabled = disabled;
        this.root.classList.toggle("is-disabled", disabled);
        for (const button of this.modeButtons.values()) {
          button.toggleAttribute("disabled", disabled);
        }
        this.updateStepAvailability();
        const closeButton = this.root.querySelector(".sm-almanac-travel__toolbar-close");
        closeButton?.toggleAttribute("disabled", disabled);
      }
      destroy() {
        for (const button of this.modeButtons.values()) {
          button.replaceWith();
        }
        this.modeButtons.clear();
        this.root.replaceChildren();
      }
      updateStepAvailability() {
        for (const btn of this.root.querySelectorAll(".sm-almanac-travel__toolbar-step")) {
          const direction = btn.dataset.direction ?? "forward";
          const usable = !this.disabled && this.canUseDirection(direction);
          btn.toggleAttribute("disabled", !usable);
        }
      }
      canUseDirection(direction) {
        if (direction === "backward") {
          return this.options.canStepBackward;
        }
        return this.options.canStepForward;
      }
    };
    TravelCalendarToolbar.displayName = "TravelCalendarToolbar";
  }
});

// src/workmodes/almanac/mode/travel/travel-quick-step-group.ts
function formatStepLabel(step) {
  if (!step) {
    return "\u2014";
  }
  const sign = step.delta.amount >= 0 ? "+" : "";
  const base = `${sign}${step.delta.amount}`;
  const unit = step.delta.unit === "day" ? "Tag" : step.delta.unit === "hour" ? "Std" : "Min";
  return step.label ? `${step.label} (${base} ${unit})` : `${base} ${unit}`;
}
var BUTTON_PRESETS, TravelQuickStepGroup;
var init_travel_quick_step_group = __esm({
  "src/workmodes/almanac/mode/travel/travel-quick-step-group.ts"() {
    "use strict";
    BUTTON_PRESETS = [
      { label: "\u22121 Tag", amount: -1, unit: "day" },
      { label: "\u22121 Std", amount: -1, unit: "hour" },
      { label: "\u2212", amount: -1, unit: "minute" },
      { label: "+", amount: 1, unit: "minute" },
      { label: "+1 Std", amount: 1, unit: "hour" },
      { label: "+1 Tag", amount: 1, unit: "day" }
    ];
    TravelQuickStepGroup = class {
      constructor(options) {
        this.buttons = [];
        this.minuteStep = Math.max(1, Math.floor(options.minuteStep) || 1);
        this.disabled = Boolean(options.disabled);
        this.onAdvance = options.onAdvance;
        this.root = document.createElement("div");
        this.root.classList.add("sm-almanac-travel__quick-steps");
        const buttonGroup = document.createElement("div");
        buttonGroup.classList.add("sm-almanac-travel__quick-steps-group");
        this.root.appendChild(buttonGroup);
        for (const preset of BUTTON_PRESETS) {
          const button = document.createElement("button");
          button.type = "button";
          button.classList.add("sm-almanac-travel__quick-steps-button");
          button.textContent = preset.label;
          button.addEventListener("click", () => {
            if (this.disabled) {
              return;
            }
            const amount = preset.unit === "minute" ? preset.amount * this.minuteStep : preset.amount;
            this.onAdvance({ amount, unit: preset.unit });
          });
          buttonGroup.appendChild(button);
          this.buttons.push(button);
        }
        this.lastStepLabel = document.createElement("div");
        this.lastStepLabel.classList.add("sm-almanac-travel__quick-steps-last");
        this.root.appendChild(this.lastStepLabel);
        this.lastStepLabel.textContent = formatStepLabel(options.lastStep);
        this.updateDisabledState();
      }
      update(options) {
        if (typeof options.minuteStep === "number" && options.minuteStep > 0) {
          this.minuteStep = Math.max(1, Math.floor(options.minuteStep));
        }
        if (typeof options.disabled === "boolean") {
          this.disabled = options.disabled;
          this.updateDisabledState();
        }
        if (options.lastStep !== void 0) {
          this.lastStepLabel.textContent = formatStepLabel(options.lastStep);
        }
      }
      destroy() {
        for (const button of this.buttons) {
          button.replaceWith();
        }
        this.lastStepLabel.replaceWith();
        this.root.replaceChildren();
      }
      updateDisabledState() {
        for (const button of this.buttons) {
          button.toggleAttribute("disabled", this.disabled);
          button.setAttribute("aria-disabled", this.disabled ? "true" : "false");
        }
        if (this.disabled) {
          this.root.classList.add("sm-almanac-travel__quick-steps--disabled");
        } else {
          this.root.classList.remove("sm-almanac-travel__quick-steps--disabled");
        }
      }
    };
    TravelQuickStepGroup.displayName = "TravelQuickStepGroup";
  }
});

// src/workmodes/almanac/mode/travel/travel-calendar-leaf.ts
function formatAdvanceStep(step) {
  if (!step) {
    return "\u2014";
  }
  const sign = step.amount >= 0 ? "+" : "";
  const unit = step.unit === "day" ? "Tag" : step.unit === "hour" ? "Std" : "Min";
  return `${sign}${step.amount} ${unit}`;
}
var TravelCalendarLeaf;
var init_travel_calendar_leaf = __esm({
  "src/workmodes/almanac/mode/travel/travel-calendar-leaf.ts"() {
    "use strict";
    init_domain();
    init_travel_calendar_toolbar();
    init_travel_quick_step_group();
    TravelCalendarLeaf = class {
      constructor(options) {
        this.currentMode = options.mode;
        this.onFollowUp = options.onFollowUp;
        this.root = document.createElement("div");
        this.root.classList.add("sm-almanac-travel__leaf");
        if (!options.visible) {
          this.root.classList.add("is-hidden");
        }
        options.host.appendChild(this.root);
        const toolbarOptions = {
          mode: options.mode,
          canStepBackward: true,
          canStepForward: true,
          onChangeMode: options.onModeChange,
          onStepDay: (direction) => {
            const amount = direction === "forward" ? 1 : -1;
            options.onAdvance({ amount, unit: "day" });
          },
          onStepHour: (direction) => {
            const amount = direction === "forward" ? 1 : -1;
            options.onAdvance({ amount, unit: "hour" });
          },
          onStepMinute: (direction) => {
            const amount = direction === "forward" ? options.minuteStep : -options.minuteStep;
            options.onAdvance({ amount, unit: "minute" });
          },
          onJump: options.onJump,
          onClose: options.onClose
        };
        this.toolbar = new TravelCalendarToolbar(toolbarOptions);
        this.root.appendChild(this.toolbar.root);
        this.quickSteps = new TravelQuickStepGroup({
          minuteStep: options.minuteStep,
          onAdvance: options.onAdvance,
          lastStep: void 0
        });
        this.root.appendChild(this.quickSteps.root);
        const infoSection = document.createElement("div");
        infoSection.classList.add("sm-almanac-travel__leaf-info");
        this.root.appendChild(infoSection);
        this.timestampEl = document.createElement("div");
        this.timestampEl.classList.add("sm-almanac-travel__leaf-timestamp");
        this.timestampEl.textContent = options.currentTimestamp ? formatTimestamp(options.currentTimestamp) : "\u2014";
        infoSection.appendChild(this.timestampEl);
        this.messageEl = document.createElement("div");
        this.messageEl.classList.add("sm-almanac-travel__leaf-message");
        infoSection.appendChild(this.messageEl);
        this.summaryEl = document.createElement("div");
        this.summaryEl.classList.add("sm-almanac-travel__leaf-last-step");
        infoSection.appendChild(this.summaryEl);
        const listWrapper = document.createElement("div");
        listWrapper.classList.add("sm-almanac-travel__leaf-log");
        this.root.appendChild(listWrapper);
        this.logList = document.createElement("ul");
        this.logList.classList.add("sm-almanac-travel__leaf-log-list");
        listWrapper.appendChild(this.logList);
        if (options.isLoading) {
          this.root.classList.add("is-loading");
        }
      }
      setPanel(snapshot) {
        this.timestampEl.textContent = snapshot?.timestampLabel ?? "\u2014";
        this.messageEl.textContent = snapshot?.message ?? "";
        if (snapshot?.lastAdvanceStep) {
          this.quickSteps.update({
            lastStep: {
              delta: {
                amount: snapshot.lastAdvanceStep.amount,
                unit: snapshot.lastAdvanceStep.unit
              }
            }
          });
        } else {
          this.quickSteps.update({ lastStep: void 0 });
        }
        this.summaryEl.textContent = formatAdvanceStep(snapshot?.lastAdvanceStep);
        this.logList.replaceChildren();
        const entries = snapshot?.logEntries ?? [];
        if (entries.length === 0) {
          const item = document.createElement("li");
          item.classList.add("sm-almanac-travel__leaf-log-item", "sm-almanac-travel__leaf-log-item--empty");
          item.textContent = snapshot?.reason === "jump" ? "Keine \xFCbersprungenen Ereignisse" : "Keine neuen Hooks";
          this.logList.appendChild(item);
          return;
        }
        for (const entry of entries) {
          const item = document.createElement("li");
          item.classList.add("sm-almanac-travel__leaf-log-item");
          if (entry.skipped) {
            item.classList.add("sm-almanac-travel__leaf-log-item--skipped");
          }
          const kind = entry.kind === "event" ? "Ereignis" : "Ph\xE4nomen";
          item.textContent = `${kind}: ${entry.title} \u2022 ${entry.occurrenceLabel}${entry.skipped ? " \u2022 \xFCbersprungen" : ""}`;
          item.addEventListener("click", () => {
            if (entry.kind === "event") {
              this.onFollowUp(entry.id);
            }
          });
          this.logList.appendChild(item);
        }
      }
      setMode(mode) {
        this.currentMode = mode;
        this.toolbar.setMode(mode);
      }
      setLoading(loading) {
        this.root.classList.toggle("is-loading", loading);
        this.toolbar.setDisabled(loading);
        this.quickSteps.update({ disabled: loading });
      }
      setError(message) {
        this.root.classList.toggle("has-error", Boolean(message));
        this.messageEl.textContent = message ?? "";
      }
      setQuickStep(step) {
        this.quickSteps.update({ lastStep: step ? { label: step.label ?? void 0, delta: step.delta } : void 0 });
        this.summaryEl.textContent = step ? formatAdvanceStep({ amount: step.delta.amount, unit: step.delta.unit }) : "\u2014";
      }
      setMinuteStep(step) {
        this.quickSteps.update({ minuteStep: step });
      }
      setVisible(visible) {
        this.root.classList.toggle("is-hidden", !visible);
      }
      destroy() {
        this.toolbar.destroy();
        this.quickSteps.destroy();
        this.root.replaceChildren();
        this.root.remove();
      }
    };
    TravelCalendarLeaf.displayName = "TravelCalendarLeaf";
  }
});

// src/workmodes/almanac/mode/travel/index.ts
var init_travel = __esm({
  "src/workmodes/almanac/mode/travel/index.ts"() {
    "use strict";
    init_travel_calendar_leaf();
    init_travel_calendar_toolbar();
    init_travel_quick_step_group();
  }
});

// src/features/weather/weather-icons.ts
function getWeatherIcon(weatherType) {
  return WEATHER_ICONS[weatherType];
}
function getWeatherLabel(weatherType) {
  return WEATHER_LABELS[weatherType];
}
function getSeverityLabel(severity) {
  if (severity >= 0.8) return "Extrem";
  if (severity >= 0.6) return "Stark";
  if (severity >= 0.4) return "M\xE4\xDFig";
  if (severity >= 0.2) return "Leicht";
  return "Minimal";
}
function getWeatherSpeedModifier(weatherType, severity) {
  switch (weatherType) {
    case "snow":
      return 1 - severity * 0.5;
    case "storm":
      return 1 - severity * 0.4;
    case "rain":
      return 1 - severity * 0.25;
    case "fog":
      return 1 - severity * 0.3;
    case "wind":
      return 1 - severity * 0.2;
    case "hot":
      return 1 - severity * 0.2;
    case "cold":
      return 1 - severity * 0.25;
    case "clear":
    case "cloudy":
    default:
      return 1;
  }
}
function formatTemperature(celsius) {
  return `${Math.round(celsius)}\xB0C`;
}
function formatWindSpeed(kmh) {
  return `${Math.round(kmh)} km/h`;
}
function formatPrecipitation(mmPerHour) {
  if (mmPerHour < 0.1) return "Kein Niederschlag";
  if (mmPerHour < 2.5) return "Leichter Niederschlag";
  if (mmPerHour < 10) return "M\xE4\xDFiger Niederschlag";
  return "Starker Niederschlag";
}
function formatVisibility(meters) {
  if (meters >= 1e4) return "Ausgezeichnet";
  if (meters >= 5e3) return "Gut";
  if (meters >= 1e3) return "M\xE4\xDFig";
  if (meters >= 200) return "Schlecht";
  return "Sehr schlecht";
}
var WEATHER_ICONS, WEATHER_LABELS;
var init_weather_icons = __esm({
  "src/features/weather/weather-icons.ts"() {
    "use strict";
    WEATHER_ICONS = {
      clear: "sun",
      cloudy: "cloud",
      rain: "cloud-drizzle",
      storm: "cloud-lightning",
      snow: "cloud-snow",
      fog: "cloud-fog",
      wind: "wind",
      hot: "thermometer-sun",
      cold: "thermometer-snowflake"
    };
    WEATHER_LABELS = {
      clear: "Klar",
      cloudy: "Bew\xF6lkt",
      rain: "Regen",
      storm: "Sturm",
      snow: "Schnee",
      fog: "Nebel",
      wind: "Windig",
      hot: "Hei\xDF",
      cold: "Kalt"
    };
  }
});

// src/features/weather/weather-generator.ts
function seededRandom2(seed) {
  let state = seed;
  return () => {
    state = state + 1831565813 | 0;
    let t = Math.imul(state ^ state >>> 15, 1 | state);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}
function selectWeatherType(probabilities, random) {
  const roll = random();
  let cumulative = 0;
  for (const [type2, probability] of Object.entries(probabilities)) {
    cumulative += probability;
    if (roll <= cumulative) {
      return type2;
    }
  }
  return "clear";
}
function getTransitionProbability(from, to) {
  const transitions = {
    clear: { clear: 0.5, cloudy: 0.3, hot: 0.15, wind: 0.05 },
    cloudy: { cloudy: 0.3, clear: 0.2, rain: 0.2, fog: 0.15, wind: 0.1, storm: 0.05 },
    rain: { rain: 0.4, cloudy: 0.3, storm: 0.15, clear: 0.1, fog: 0.05 },
    storm: { storm: 0.3, rain: 0.3, cloudy: 0.2, wind: 0.1, clear: 0.1 },
    snow: { snow: 0.5, cold: 0.2, cloudy: 0.15, wind: 0.1, clear: 0.05 },
    fog: { fog: 0.4, cloudy: 0.3, clear: 0.2, rain: 0.1 },
    wind: { wind: 0.4, cloudy: 0.25, clear: 0.2, storm: 0.1, fog: 0.05 },
    hot: { hot: 0.5, clear: 0.3, cloudy: 0.15, wind: 0.05 },
    cold: { cold: 0.5, snow: 0.2, cloudy: 0.15, clear: 0.1, wind: 0.05 }
  };
  return transitions[from]?.[to] ?? 0.01;
}
function applyMarkovTransition(climateProbabilities, previousWeather, transitionWeight) {
  const blended = {};
  for (const type2 of Object.keys(climateProbabilities)) {
    const climateProb = climateProbabilities[type2];
    const transitionProb = getTransitionProbability(previousWeather, type2);
    blended[type2] = climateProb * (1 - transitionWeight) + transitionProb * transitionWeight;
  }
  const total = Object.values(blended).reduce((sum, val) => sum + val, 0);
  for (const type2 of Object.keys(blended)) {
    blended[type2] /= total;
  }
  return blended;
}
function calculateTemperature(climate, season, dayOfYear, random) {
  const { baseTemperature, seasonalVariation } = climate;
  const yearProgress = dayOfYear / 365;
  const seasonalOffset = Math.sin(yearProgress * 2 * Math.PI - Math.PI / 2) * seasonalVariation;
  const baseTemp = (baseTemperature.min + baseTemperature.max) / 2;
  const dailyVariation = (random() - 0.5) * 10;
  return baseTemp + seasonalOffset + dailyVariation;
}
function calculateSeverity(weatherType, random) {
  const severityRanges = {
    clear: { min: 0, max: 0.2 },
    cloudy: { min: 0.2, max: 0.4 },
    rain: { min: 0.3, max: 0.6 },
    storm: { min: 0.7, max: 1 },
    snow: { min: 0.3, max: 0.7 },
    fog: { min: 0.3, max: 0.6 },
    wind: { min: 0.4, max: 0.8 },
    hot: { min: 0.5, max: 0.9 },
    cold: { min: 0.5, max: 0.9 }
  };
  const range = severityRanges[weatherType];
  return range.min + random() * (range.max - range.min);
}
function calculateDuration(climate, random) {
  const { transitionSpeed } = climate;
  return transitionSpeed * (0.5 + random() * 1);
}
function calculateWindSpeed(weatherType, severity, random) {
  const baseWindSpeeds = {
    clear: 5,
    cloudy: 10,
    rain: 20,
    storm: 50,
    snow: 15,
    fog: 5,
    wind: 40,
    hot: 10,
    cold: 15
  };
  const base = baseWindSpeeds[weatherType];
  const variation = base * severity * random();
  return Math.max(0, base + variation);
}
function calculatePrecipitation(weatherType, severity) {
  if (weatherType === "rain") {
    return severity * 10;
  }
  if (weatherType === "storm") {
    return 5 + severity * 20;
  }
  if (weatherType === "snow") {
    return severity * 5;
  }
  return 0;
}
function calculateVisibility(weatherType, severity) {
  const baseVisibility = 1e4;
  const visibilityMultipliers = {
    clear: 1,
    cloudy: 0.9,
    rain: 0.5,
    storm: 0.3,
    snow: 0.4,
    fog: 0.2,
    wind: 0.8,
    hot: 0.95,
    cold: 0.95
  };
  const multiplier = visibilityMultipliers[weatherType];
  return baseVisibility * multiplier * (1 - severity * 0.5);
}
function generateWeather(options) {
  const { climate, season, previousWeather, dayOfYear, seed } = options;
  const random = seededRandom2(seed ?? dayOfYear);
  const climateProbabilities = climate.weatherProbabilities[season];
  let finalProbabilities = climateProbabilities;
  if (previousWeather) {
    const transitionWeight = 0.4;
    finalProbabilities = applyMarkovTransition(
      climateProbabilities,
      previousWeather.type,
      transitionWeight
    );
  }
  const weatherType = selectWeatherType(finalProbabilities, random);
  const severity = calculateSeverity(weatherType, random);
  const duration = calculateDuration(climate, random);
  const temperature = calculateTemperature(climate, season, dayOfYear, random);
  const windSpeed = calculateWindSpeed(weatherType, severity, random);
  const precipitation = calculatePrecipitation(weatherType, severity);
  const visibility = calculateVisibility(weatherType, severity);
  const hexCoord = { q: 0, r: 0, s: 0 };
  return {
    hexCoord,
    currentWeather: {
      type: weatherType,
      severity,
      duration
    },
    temperature,
    windSpeed,
    precipitation,
    visibility,
    lastUpdate: (/* @__PURE__ */ new Date()).toISOString()
  };
}
var init_weather_generator = __esm({
  "src/features/weather/weather-generator.ts"() {
    "use strict";
  }
});

// src/features/weather/weather-forecaster.ts
function generateForecast(options) {
  const {
    hexCoord,
    climate,
    season,
    currentWeather,
    currentDate,
    daysAhead = 3
  } = options;
  const forecasts = [];
  let previousWeather = currentWeather;
  const startDate = new Date(currentDate);
  const baseSeed = hexCoord.q * 1e3 + hexCoord.r * 100 + hexCoord.s;
  for (let day = 1; day <= daysAhead; day++) {
    const forecastDate = new Date(startDate);
    forecastDate.setDate(forecastDate.getDate() + day);
    const forecastDateStr = forecastDate.toISOString();
    const dayOfYear = Math.floor(
      (forecastDate.getTime() - new Date(forecastDate.getFullYear(), 0, 0).getTime()) / (1e3 * 60 * 60 * 24)
    );
    const forecastedWeather = generateWeather({
      climate,
      season,
      previousWeather: previousWeather.currentWeather,
      dayOfYear,
      seed: baseSeed + day
    });
    forecastedWeather.hexCoord = { ...hexCoord };
    const confidence = Math.max(0.3, 1 - (day - 1) * 0.2);
    forecasts.push({
      weather: forecastedWeather,
      date: forecastDateStr,
      confidence
    });
    previousWeather = forecastedWeather;
  }
  return forecasts;
}
function getConfidenceLabel(confidence) {
  if (confidence >= 0.8) return "Sehr sicher";
  if (confidence >= 0.6) return "Wahrscheinlich";
  if (confidence >= 0.4) return "M\xF6glich";
  return "Unsicher";
}
var init_weather_forecaster = __esm({
  "src/features/weather/weather-forecaster.ts"() {
    "use strict";
    init_weather_generator();
  }
});

// src/workmodes/session-runner/travel/ui/weather-panel.ts
function createWeatherPanel(host) {
  const root = host.createDiv({ cls: "sm-weather-panel" });
  let lastModifier = 1;
  let baseSpeed;
  const header = root.createDiv({ cls: "sm-weather-panel__header" });
  header.createSpan({ cls: "sm-weather-panel__title", text: "Wetter" });
  const mainDisplay = root.createDiv({ cls: "sm-weather-panel__main" });
  const iconContainer = mainDisplay.createDiv({ cls: "sm-weather-panel__icon-container" });
  const weatherIcon = iconContainer.createDiv({ cls: "sm-weather-panel__icon" });
  const infoContainer = mainDisplay.createDiv({ cls: "sm-weather-panel__info" });
  const weatherTypeLabel = infoContainer.createDiv({ cls: "sm-weather-panel__weather-type" });
  const severityLabel = infoContainer.createDiv({ cls: "sm-weather-panel__severity" });
  const details = root.createDiv({ cls: "sm-weather-panel__details" });
  const tempRow = details.createDiv({ cls: "sm-weather-panel__detail-row" });
  tempRow.createSpan({ cls: "sm-weather-panel__detail-label", text: "Temperatur" });
  const tempValue = tempRow.createSpan({ cls: "sm-weather-panel__detail-value" });
  const windRow = details.createDiv({ cls: "sm-weather-panel__detail-row" });
  windRow.createSpan({ cls: "sm-weather-panel__detail-label", text: "Wind" });
  const windValue = windRow.createSpan({ cls: "sm-weather-panel__detail-value" });
  const precipRow = details.createDiv({ cls: "sm-weather-panel__detail-row" });
  precipRow.createSpan({ cls: "sm-weather-panel__detail-label", text: "Niederschlag" });
  const precipValue = precipRow.createSpan({ cls: "sm-weather-panel__detail-value" });
  const visRow = details.createDiv({ cls: "sm-weather-panel__detail-row" });
  visRow.createSpan({ cls: "sm-weather-panel__detail-label", text: "Sicht" });
  const visValue = visRow.createSpan({ cls: "sm-weather-panel__detail-value" });
  const effects = root.createDiv({ cls: "sm-weather-panel__effects" });
  const effectsTitle = effects.createDiv({
    cls: "sm-weather-panel__effects-title",
    text: "Reiseeffekte"
  });
  const speedModifierRow = effects.createDiv({ cls: "sm-weather-panel__effect-row" });
  speedModifierRow.createSpan({ cls: "sm-weather-panel__effect-label", text: "Geschwindigkeit" });
  const speedModifierValue = speedModifierRow.createSpan({
    cls: "sm-weather-panel__effect-value"
  });
  const speedHelperRow = effects.createDiv({ cls: "sm-weather-panel__effect-helper" });
  const speedHelperText = speedHelperRow.createSpan({
    cls: "sm-weather-panel__effect-helper-text"
  });
  const historySection = root.createDiv({ cls: "sm-weather-panel__history-section" });
  const historyHeader = historySection.createDiv({ cls: "sm-weather-panel__section-header" });
  historyHeader.createSpan({ cls: "sm-weather-panel__section-title", text: "Geschichte" });
  const historyToggle = historyHeader.createSpan({ cls: "sm-weather-panel__toggle", text: "\u25B6" });
  const historyContent = historySection.createDiv({ cls: "sm-weather-panel__history-content" });
  historyContent.style.display = "none";
  const forecastSection = root.createDiv({ cls: "sm-weather-panel__forecast-section" });
  const forecastHeader = forecastSection.createDiv({ cls: "sm-weather-panel__section-header" });
  forecastHeader.createSpan({ cls: "sm-weather-panel__section-title", text: "Vorhersage" });
  const forecastToggle = forecastHeader.createSpan({ cls: "sm-weather-panel__toggle", text: "\u25B6" });
  const forecastContent = forecastSection.createDiv({ cls: "sm-weather-panel__forecast-content" });
  forecastContent.style.display = "none";
  const placeholder = root.createDiv({
    cls: "sm-weather-panel__placeholder",
    text: "W\xE4hle ein Hex aus, um das Wetter zu sehen"
  });
  placeholder.style.display = "block";
  mainDisplay.style.display = "none";
  details.style.display = "none";
  effects.style.display = "none";
  historySection.style.display = "none";
  forecastSection.style.display = "none";
  let historyExpanded = false;
  let forecastExpanded = false;
  historyHeader.onclick = () => {
    historyExpanded = !historyExpanded;
    historyContent.style.display = historyExpanded ? "block" : "none";
    historyToggle.textContent = historyExpanded ? "\u25BC" : "\u25B6";
  };
  forecastHeader.onclick = () => {
    forecastExpanded = !forecastExpanded;
    forecastContent.style.display = forecastExpanded ? "block" : "none";
    forecastToggle.textContent = forecastExpanded ? "\u25BC" : "\u25B6";
  };
  const setWeather = (weather) => {
    if (!weather) {
      placeholder.style.display = "block";
      mainDisplay.style.display = "none";
      details.style.display = "none";
      effects.style.display = "none";
      historySection.style.display = "none";
      forecastSection.style.display = "none";
      return;
    }
    placeholder.style.display = "none";
    mainDisplay.style.display = "flex";
    details.style.display = "block";
    effects.style.display = "block";
    historySection.style.display = "block";
    forecastSection.style.display = "block";
    const { currentWeather, temperature, windSpeed, precipitation, visibility } = weather;
    weatherIcon.empty();
    const iconName = getWeatherIcon(currentWeather.type);
    (0, import_obsidian39.setIcon)(weatherIcon, iconName);
    weatherTypeLabel.textContent = getWeatherLabel(currentWeather.type);
    severityLabel.textContent = getSeverityLabel(currentWeather.severity);
    tempValue.textContent = formatTemperature(temperature);
    windValue.textContent = formatWindSpeed(windSpeed);
    precipValue.textContent = formatPrecipitation(precipitation);
    visValue.textContent = formatVisibility(visibility);
    const modifier = getWeatherSpeedModifier(currentWeather.type, currentWeather.severity);
    lastModifier = modifier;
    setSpeedModifier(modifier, baseSpeed);
  };
  const setSpeedModifier = (modifier, speed) => {
    lastModifier = modifier;
    if (speed !== void 0) {
      baseSpeed = speed;
    }
    const percentage = Math.round(modifier * 100);
    speedModifierValue.textContent = `${percentage}%`;
    speedModifierValue.classList.remove(
      "sm-weather-panel__effect-value--good",
      "sm-weather-panel__effect-value--warning",
      "sm-weather-panel__effect-value--bad"
    );
    if (modifier >= 0.9) {
      speedModifierValue.classList.add("sm-weather-panel__effect-value--good");
    } else if (modifier >= 0.7) {
      speedModifierValue.classList.add("sm-weather-panel__effect-value--warning");
    } else {
      speedModifierValue.classList.add("sm-weather-panel__effect-value--bad");
    }
    if (baseSpeed !== void 0 && baseSpeed > 0) {
      const modifiedSpeed = baseSpeed * modifier;
      speedHelperText.textContent = `Bewegung reduziert auf ${percentage}% der normalen Geschwindigkeit (${baseSpeed.toFixed(1)} \u2192 ${modifiedSpeed.toFixed(1)} mph)`;
      speedHelperRow.style.display = "block";
    } else {
      speedHelperText.textContent = `Bewegungsgeschwindigkeit auf ${percentage}% der normalen Geschwindigkeit reduziert`;
      speedHelperRow.style.display = "block";
    }
  };
  const setBaseSpeed = (speed) => {
    baseSpeed = speed;
    setSpeedModifier(lastModifier, speed);
  };
  const setHistory = (history) => {
    historyContent.empty();
    if (history.length === 0) {
      historyContent.createSpan({
        cls: "sm-weather-panel__empty-message",
        text: "Keine Verlaufsdaten verf\xFCgbar"
      });
      return;
    }
    const reversed = [...history].reverse();
    for (const entry of reversed) {
      const entryEl = historyContent.createDiv({ cls: "sm-weather-panel__history-entry" });
      const date = new Date(entry.date);
      const dateStr = date.toLocaleDateString("de-DE", {
        day: "2-digit",
        month: "2-digit",
        year: "numeric"
      });
      entryEl.createSpan({ cls: "sm-weather-panel__history-date", text: dateStr });
      const iconEl = entryEl.createSpan({ cls: "sm-weather-panel__history-icon" });
      (0, import_obsidian39.setIcon)(iconEl, getWeatherIcon(entry.weather.currentWeather.type));
      const labelEl = entryEl.createSpan({ cls: "sm-weather-panel__history-label" });
      labelEl.textContent = `${getWeatherLabel(entry.weather.currentWeather.type)} (${formatTemperature(entry.weather.temperature)})`;
    }
  };
  const setForecast = (forecast) => {
    forecastContent.empty();
    if (forecast.length === 0) {
      forecastContent.createSpan({
        cls: "sm-weather-panel__empty-message",
        text: "Keine Vorhersage verf\xFCgbar"
      });
      return;
    }
    for (const entry of forecast) {
      const entryEl = forecastContent.createDiv({ cls: "sm-weather-panel__forecast-entry" });
      const date = new Date(entry.date);
      const dateStr = date.toLocaleDateString("de-DE", {
        weekday: "short",
        day: "2-digit",
        month: "2-digit"
      });
      entryEl.createSpan({ cls: "sm-weather-panel__forecast-date", text: dateStr });
      const iconEl = entryEl.createSpan({ cls: "sm-weather-panel__forecast-icon" });
      (0, import_obsidian39.setIcon)(iconEl, getWeatherIcon(entry.weather.currentWeather.type));
      const labelEl = entryEl.createSpan({ cls: "sm-weather-panel__forecast-label" });
      labelEl.textContent = `${getWeatherLabel(entry.weather.currentWeather.type)} (${formatTemperature(entry.weather.temperature)})`;
      const confidenceEl = entryEl.createSpan({ cls: "sm-weather-panel__forecast-confidence" });
      confidenceEl.textContent = getConfidenceLabel(entry.confidence);
      if (entry.confidence >= 0.7) {
        confidenceEl.classList.add("sm-weather-panel__forecast-confidence--high");
      } else if (entry.confidence >= 0.5) {
        confidenceEl.classList.add("sm-weather-panel__forecast-confidence--medium");
      } else {
        confidenceEl.classList.add("sm-weather-panel__forecast-confidence--low");
      }
    }
  };
  const setPlaceholder = (message) => {
    placeholder.textContent = message;
  };
  const destroy = () => {
    root.remove();
  };
  return {
    root,
    setWeather,
    setSpeedModifier,
    setBaseSpeed,
    setHistory,
    setForecast,
    setPlaceholder,
    destroy
  };
}
var import_obsidian39;
var init_weather_panel = __esm({
  "src/workmodes/session-runner/travel/ui/weather-panel.ts"() {
    "use strict";
    import_obsidian39 = require("obsidian");
    init_weather_icons();
    init_weather_forecaster();
  }
});

// src/workmodes/session-runner/travel/ui/sidebar.ts
function createSidebar(host) {
  host.empty();
  host.classList.add("sm-cartographer__sidebar--travel");
  const root = host.createDiv({ cls: "sm-cartographer__travel" });
  const controlsHost = root.createDiv({ cls: "sm-cartographer__travel-controls" });
  const tileRow = root.createDiv({ cls: "sm-cartographer__travel-row" });
  tileRow.createSpan({ cls: "sm-cartographer__travel-label", text: "Aktuelles Hex" });
  const tileValue = tileRow.createSpan({
    cls: "sm-cartographer__travel-value",
    text: "\u2014"
  });
  const speedRow = root.createDiv({ cls: "sm-cartographer__travel-row" });
  speedRow.createSpan({ cls: "sm-cartographer__travel-label", text: "Party Speed (mph)" });
  const speedInput = speedRow.createEl("input", {
    type: "number",
    cls: "sm-cartographer__travel-input",
    attr: { step: "0.1", min: "0.1", value: "1" }
  });
  const weatherPanelHost = root.createDiv({ cls: "sm-cartographer__travel-weather" });
  const weatherPanel = createWeatherPanel(weatherPanelHost);
  const leafHost = root.createDiv({ cls: "sm-cartographer__travel-leaf" });
  let travelHandlers = {
    onAdvance: () => {
    },
    onModeChange: () => {
    },
    onJump: () => {
    },
    onClose: () => {
    },
    onFollowUp: () => {
    }
  };
  const travelLeaf = new TravelCalendarLeaf({
    host: leafHost,
    mode: "upcoming",
    visible: false,
    minuteStep: 1,
    currentTimestamp: null,
    isLoading: false,
    onModeChange: (mode) => travelHandlers.onModeChange(mode),
    onAdvance: (payload) => travelHandlers.onAdvance(payload),
    onJump: () => travelHandlers.onJump(),
    onClose: () => travelHandlers.onClose(),
    onFollowUp: (eventId) => travelHandlers.onFollowUp(eventId)
  });
  let onChange = () => {
  };
  speedInput.onchange = () => {
    const v = parseFloat(speedInput.value);
    const val = Number.isFinite(v) && v > 0 ? v : 1;
    speedInput.value = String(val);
    weatherPanel.setBaseSpeed(val);
    onChange(val);
  };
  const setTile = (rc) => {
    tileValue.textContent = rc ? `${rc.r},${rc.c}` : "\u2014";
  };
  const setSpeed = (v) => {
    const next = String(v);
    if (speedInput.value !== next) speedInput.value = next;
    weatherPanel.setBaseSpeed(v);
  };
  const setTravelPanel = (panel) => {
    travelLeaf.setPanel(panel);
    travelLeaf.setVisible(Boolean(panel));
    travelLeaf.setLoading(false);
  };
  const setWeather = (weather) => {
    weatherPanel.setWeather(weather);
  };
  const setWeatherHistory = (history) => {
    weatherPanel.setHistory(history);
  };
  const setWeatherForecast = (forecast) => {
    weatherPanel.setForecast(forecast);
  };
  const setTitle = (title) => {
    if (title && title.trim().length > 0) {
      host.dataset.mapTitle = title;
    } else {
      delete host.dataset.mapTitle;
    }
  };
  return {
    root,
    setTitle,
    controlsHost,
    setTile,
    setSpeed,
    setTravelPanel,
    setWeather,
    setWeatherHistory,
    setWeatherForecast,
    onSpeedChange: (fn) => onChange = fn,
    setTravelHandlers: (handlers) => {
      travelHandlers = {
        onAdvance: handlers.onAdvance ?? travelHandlers.onAdvance,
        onModeChange: handlers.onModeChange ?? travelHandlers.onModeChange,
        onJump: handlers.onJump ?? travelHandlers.onJump,
        onClose: handlers.onClose ?? travelHandlers.onClose,
        onFollowUp: handlers.onFollowUp ?? travelHandlers.onFollowUp
      };
    },
    destroy: () => {
      weatherPanel.destroy();
      travelLeaf.destroy();
      host.empty();
      host.classList.remove("sm-cartographer__sidebar--travel");
      delete host.dataset.mapTitle;
    }
  };
}
var init_sidebar = __esm({
  "src/workmodes/session-runner/travel/ui/sidebar.ts"() {
    "use strict";
    init_travel();
    init_weather_panel();
  }
});

// src/workmodes/session-runner/travel/render/draw-route.ts
function drawRoute(args) {
  const { layer, route, centerOf, highlightIndex = null, start = null } = args;
  while (layer.firstChild) layer.removeChild(layer.firstChild);
  const pts = [];
  const startCtr = start ? centerOf(start) : null;
  if (startCtr) pts.push(`${startCtr.x},${startCtr.y}`);
  const centers = route.map((n) => centerOf(n));
  for (const p of centers) if (p) pts.push(`${p.x},${p.y}`);
  if (pts.length >= 2) {
    const pl = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
    pl.setAttribute("points", pts.join(" "));
    pl.setAttribute("fill", "none");
    pl.setAttribute("stroke", "var(--interactive-accent)");
    pl.setAttribute("stroke-width", "3");
    pl.setAttribute("stroke-linejoin", "round");
    pl.setAttribute("stroke-linecap", "round");
    pl.style.pointerEvents = "none";
    layer.appendChild(pl);
  }
  route.forEach((node, i) => {
    const ctr = centers[i];
    if (!ctr) return;
    const baseRadius = node.kind === "user" ? USER_RADIUS : AUTO_RADIUS;
    const hitRadius = baseRadius + HITBOX_PADDING;
    const hit = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    hit.setAttribute("cx", String(ctr.x));
    hit.setAttribute("cy", String(ctr.y));
    hit.setAttribute("r", String(hitRadius));
    hit.setAttribute("data-idx", String(i));
    hit.classList.add("tg-route-dot-hitbox");
    hit.style.fill = "transparent";
    hit.setAttribute("stroke", "transparent");
    hit.style.pointerEvents = "all";
    hit.style.cursor = "grab";
    layer.appendChild(hit);
    const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    dot.setAttribute("cx", String(ctr.x));
    dot.setAttribute("cy", String(ctr.y));
    dot.setAttribute("r", String(baseRadius));
    dot.setAttribute("data-radius", String(baseRadius));
    dot.setAttribute("data-kind", node.kind);
    dot.setAttribute("data-idx", String(i));
    dot.classList.add("tg-route-dot");
    dot.classList.add(node.kind === "user" ? "tg-route-dot--user" : "tg-route-dot--auto");
    dot.style.pointerEvents = "auto";
    dot.style.cursor = "grab";
    layer.appendChild(dot);
  });
  updateHighlight(layer, highlightIndex);
}
function updateHighlight(layer, highlightIndex) {
  const dots = Array.from(layer.querySelectorAll(".tg-route-dot"));
  dots.forEach((el, idx) => {
    const isHi = highlightIndex != null && idx === highlightIndex;
    const baseRadius = Number(el.dataset.radius || el.getAttribute("r") || (el.dataset.kind === "user" ? USER_RADIUS : AUTO_RADIUS));
    el.classList.toggle("is-highlighted", isHi);
    el.setAttribute("stroke", isHi ? "var(--background-modifier-border)" : "none");
    el.setAttribute("stroke-width", isHi ? "2" : "0");
    el.setAttribute("r", String(isHi ? baseRadius + HIGHLIGHT_OFFSET : baseRadius));
    el.style.removeProperty("opacity");
    el.style.cursor = "grab";
  });
}
var USER_RADIUS, AUTO_RADIUS, HIGHLIGHT_OFFSET, HITBOX_PADDING;
var init_draw_route = __esm({
  "src/workmodes/session-runner/travel/render/draw-route.ts"() {
    "use strict";
    USER_RADIUS = 7;
    AUTO_RADIUS = 5;
    HIGHLIGHT_OFFSET = 2;
    HITBOX_PADDING = 6;
  }
});

// src/workmodes/session-runner/travel/ui/route-layer.ts
function createRouteLayer(contentRoot, centerOf) {
  const el = document.createElementNS("http://www.w3.org/2000/svg", "g");
  el.classList.add("tg-route-layer");
  contentRoot.appendChild(el);
  function draw(route, highlightIndex = null, start) {
    drawRoute({ layer: el, route, centerOf, highlightIndex, start });
  }
  function highlight(i) {
    updateHighlight(el, i);
  }
  function destroy() {
    el.remove();
  }
  return { el, draw, highlight, destroy };
}
var init_route_layer = __esm({
  "src/workmodes/session-runner/travel/ui/route-layer.ts"() {
    "use strict";
    init_draw_route();
  }
});

// src/workmodes/session-runner/travel/ui/token-layer.ts
function createTokenLayer(contentG) {
  const el = document.createElementNS("http://www.w3.org/2000/svg", "g");
  el.classList.add("tg-token");
  el.style.pointerEvents = "auto";
  el.style.cursor = "grab";
  contentG.appendChild(el);
  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle.setAttribute("r", "14");
  circle.classList.add("tg-token__circle");
  el.appendChild(circle);
  let vx = 0, vy = 0;
  let rafId = null;
  let pendingReject = null;
  const makeCancelError = () => {
    const err = new Error("token-move-cancelled");
    err.name = "TokenMoveCancelled";
    return err;
  };
  const cancelActiveAnimation = (reason = makeCancelError()) => {
    if (rafId != null) {
      cancelAnimationFrame(rafId);
      rafId = null;
    }
    if (pendingReject) {
      const reject = pendingReject;
      pendingReject = null;
      reject(reason);
    }
  };
  function setPos(x, y) {
    vx = x;
    vy = y;
    el.setAttribute("transform", `translate(${x},${y})`);
  }
  function moveTo(x, y, durMs) {
    cancelActiveAnimation();
    if (durMs <= 0) {
      setPos(x, y);
      return Promise.resolve();
    }
    const x0 = vx;
    const y0 = vy;
    const dx = x - x0;
    const dy = y - y0;
    const t0 = performance.now();
    return new Promise((resolve, reject) => {
      pendingReject = reject;
      const step = () => {
        const t = (performance.now() - t0) / durMs;
        if (t >= 1) {
          setPos(x, y);
          rafId = null;
          pendingReject = null;
          resolve();
          return;
        }
        const k = t < 0 ? 0 : t;
        setPos(x0 + dx * k, y0 + dy * k);
        rafId = requestAnimationFrame(step);
      };
      rafId = requestAnimationFrame(step);
    });
  }
  function show() {
    el.style.display = "";
  }
  function hide() {
    el.style.display = "none";
  }
  function stop() {
    cancelActiveAnimation();
  }
  function destroy() {
    cancelActiveAnimation();
    el.remove();
  }
  hide();
  return { el, setPos, moveTo, stop, show, hide, destroy };
}
var init_token_layer = __esm({
  "src/workmodes/session-runner/travel/ui/token-layer.ts"() {
    "use strict";
  }
});

// src/workmodes/session-runner/travel/domain/state.store.ts
function createStore() {
  let state = {
    tokenRC: { r: 0, c: 0 },
    route: [],
    editIdx: null,
    tokenSpeed: 3,
    // mph default party speed
    currentTile: null,
    playing: false,
    tempo: 1,
    clockHours: 0,
    partyLevel: 1,
    // default party level
    partySize: 4
    // default party size
  };
  const subs = /* @__PURE__ */ new Set();
  const get = () => state;
  const set2 = (patch) => {
    state = { ...state, ...patch };
    emit();
  };
  const replace = (next) => {
    state = next;
    emit();
  };
  const subscribe = (fn) => {
    subs.add(fn);
    fn(state);
    return () => subs.delete(fn);
  };
  const emit = () => {
    for (const fn of subs) fn(state);
  };
  return { get, set: set2, replace, subscribe, emit };
}
var init_state_store = __esm({
  "src/workmodes/session-runner/travel/domain/state.store.ts"() {
    "use strict";
  }
});

// src/workmodes/session-runner/travel/domain/expansion.ts
function expandCoords(a, b) {
  const seg = lineOddR(a, b);
  if (seg.length <= 1) return [];
  seg.shift();
  return seg;
}
function rebuildFromAnchors(tokenRC, anchors) {
  const route = [];
  let cur = tokenRC;
  for (let i = 0; i < anchors.length; i++) {
    const next = anchors[i];
    const seg = expandCoords(cur, next);
    const autos = seg.slice(0, Math.max(0, seg.length - 1)).map(asAutoNode);
    route.push(...autos);
    route.push(asUserNode(next));
    cur = next;
  }
  return route;
}
var asUserNode, asAutoNode;
var init_expansion = __esm({
  "src/workmodes/session-runner/travel/domain/expansion.ts"() {
    "use strict";
    init_hex_geom();
    asUserNode = (rc) => ({ ...rc, kind: "user" });
    asAutoNode = (rc) => ({ ...rc, kind: "auto" });
  }
});

// src/workmodes/session-runner/travel/domain/terrain.service.ts
async function loadTerrainSpeed(app, mapFile, rc) {
  try {
    const data = await loadTile(app, mapFile, rc);
    const t = data?.terrain ?? "";
    const s = TERRAIN_SPEEDS[t];
    return Number.isFinite(s) ? s : 1;
  } catch {
    return 1;
  }
}
var init_terrain_service = __esm({
  "src/workmodes/session-runner/travel/domain/terrain.service.ts"() {
    "use strict";
    init_terrain();
    init_tile_repository();
  }
});

// src/workmodes/session-runner/travel/domain/persistence.ts
async function loadTokenCoordFromMap(app, mapFile) {
  const tiles = await listTilesForMap(app, mapFile);
  for (const rc of tiles) {
    const data = await loadTile(app, mapFile, rc).catch(() => null);
    if (data && data[TOKEN_KEY] === true) return rc;
  }
  return null;
}
async function writeTokenToTiles(app, mapFile, rc) {
  const tiles = await listTilesForMap(app, mapFile);
  for (const t of tiles) {
    const data = await loadTile(app, mapFile, t).catch(() => null);
    if (data && data[TOKEN_KEY] === true && (t.r !== rc.r || t.c !== rc.c)) {
      await saveTile(app, mapFile, t, { ...data, [TOKEN_KEY]: false });
    }
  }
  const exists = tiles.some((t) => t.r === rc.r && t.c === rc.c);
  if (!exists) return;
  const cur = await loadTile(app, mapFile, rc).catch(() => ({}));
  await saveTile(app, mapFile, rc, { ...cur, [TOKEN_KEY]: true });
}
var TOKEN_KEY;
var init_persistence = __esm({
  "src/workmodes/session-runner/travel/domain/persistence.ts"() {
    "use strict";
    init_tile_repository();
    TOKEN_KEY = "token_travel";
  }
});

// src/workmodes/session-runner/travel/domain/playback.ts
function createPlayback(cfg) {
  const { app, getMapFile, adapter, store, minSecondsPerTile, onEncounter } = cfg;
  let playing = false;
  let currentRun = null;
  let clockTimer = null;
  let hourAcc = 0;
  function trimRoutePassed(token) {
    const cur = store.get();
    let i = 0;
    while (i < cur.route.length && cur.route[i].r === token.r && cur.route[i].c === token.c) i++;
    if (i > 0) store.set({ route: cur.route.slice(i) });
  }
  async function play() {
    if (playing) return;
    if (currentRun) {
      try {
        await currentRun;
      } catch {
      }
    }
    const mapFile = getMapFile();
    if (!mapFile) return;
    const s0 = store.get();
    if (s0.route.length === 0) return;
    const run = (async () => {
      playing = true;
      store.set({ playing: true });
      if (clockTimer == null) {
        clockTimer = window.setInterval(() => {
          const s = store.get();
          const tempo = Math.max(0.1, Math.min(10, s.tempo || 1));
          const nextHours = (s.clockHours || 0) + tempo;
          hourAcc += tempo;
          while (hourAcc >= 1) {
            hourAcc -= 1;
            void checkEncounter();
          }
          store.set({ clockHours: nextHours });
        }, 1e3);
      }
      try {
        while (playing) {
          const s = store.get();
          if (s.route.length === 0) break;
          const next = s.route[0];
          adapter.ensurePolys([{ r: next.r, c: next.c }]);
          const terr = await loadTerrainSpeed(app, mapFile, next);
          const mph = Math.max(0.1, s.tokenSpeed);
          const hoursPerTile = 3 / mph * terr;
          const tempo = Math.max(0.1, Math.min(10, s.tempo || 1));
          const seconds = Math.max(minSecondsPerTile, hoursPerTile / tempo);
          const dur = seconds * 1e3;
          const ctr = adapter.centerOf(next);
          let cancelled = false;
          if (ctr) {
            try {
              await adapter.token.moveTo(ctr.x, ctr.y, dur);
            } catch (err) {
              if (err instanceof Error && err.name === "TokenMoveCancelled") {
                cancelled = true;
              } else {
                throw err;
              }
            }
          }
          if (cancelled) break;
          const tokenRC = { r: next.r, c: next.c };
          store.set({ tokenRC, currentTile: tokenRC });
          await writeTokenToTiles(app, mapFile, tokenRC);
          trimRoutePassed(tokenRC);
          if (!playing) break;
        }
      } finally {
        playing = false;
        store.set({ playing: false });
        if (clockTimer != null) {
          clearInterval(clockTimer);
          clockTimer = null;
        }
      }
    })();
    currentRun = run;
    try {
      await run;
    } finally {
      if (currentRun === run) currentRun = null;
    }
  }
  function pause() {
    if (!playing && !currentRun) {
      adapter.token.stop?.();
      return;
    }
    playing = false;
    store.set({ playing: false });
    adapter.token.stop?.();
    if (clockTimer != null) {
      clearInterval(clockTimer);
      clockTimer = null;
    }
  }
  async function checkEncounter() {
    try {
      const mapFile = getMapFile();
      if (!mapFile) return;
      const s = store.get();
      const cur = s.currentTile || s.tokenRC;
      if (!cur) return;
      const { loadTile: loadTile2 } = await import("../../../../core/hex-mapper/hex-notes");
      const tile = await loadTile2(app, mapFile, cur).catch(() => null);
      const regionName = tile?.region;
      if (!regionName) return;
      const { loadRegions: loadRegions3 } = await import("../../../../core/regions-store");
      const regions = await loadRegions3(app);
      const region = regions.find((r) => (r.name || "").toLowerCase() === regionName.toLowerCase());
      const odds = region?.encounterOdds;
      const n = Number.isFinite(odds) && odds > 0 ? odds : void 0;
      if (!n) return;
      const roll = Math.floor(Math.random() * n) + 1;
      if (roll === 1) {
        onEncounter && await onEncounter();
      }
    } catch (err) {
      logger2.error("[travel] encounter check failed", err);
    }
  }
  return { play, pause };
}
var init_playback = __esm({
  "src/workmodes/session-runner/travel/domain/playback.ts"() {
    "use strict";
    init_terrain_service();
    init_persistence();
    init_plugin_logger();
  }
});

// src/workmodes/session-runner/travel/domain/actions.ts
function createTravelLogic(cfg) {
  const store = createStore();
  let adapter = cfg.adapter;
  const unsub = store.subscribe((s) => {
    cfg.onChange?.(s);
    adapter.draw(s.route, s.tokenRC);
  });
  const playback = createPlayback({
    app: cfg.app,
    getMapFile: cfg.getMapFile,
    store,
    adapter,
    minSecondsPerTile: cfg.minSecondsPerTile,
    onEncounter: cfg.onEncounter
  });
  const getState = () => store.get();
  const bindAdapter = (a) => {
    adapter = a;
  };
  const selectDot = (idx) => {
    const len = store.get().route.length;
    const safe = idx == null ? null : Math.max(0, Math.min(idx, len - 1));
    store.set({ editIdx: safe });
  };
  const lastUserAnchor = () => {
    const r = store.get().route;
    for (let i = r.length - 1; i >= 0; i--) {
      if (r[i].kind === "user") return r[i];
    }
    return null;
  };
  const userIndices = () => {
    const out = [];
    store.get().route.forEach((n, i) => {
      if (n.kind === "user") out.push(i);
    });
    return out;
  };
  const ensurePolys = (coords) => adapter.ensurePolys(coords);
  const handleHexClick = (rc) => {
    const s = store.get();
    const source = lastUserAnchor() ?? s.tokenRC;
    if (source.r === rc.r && source.c === rc.c) return;
    const seg = expandCoords(source, rc);
    ensurePolys(seg);
    const autos = seg.slice(0, Math.max(0, seg.length - 1)).map(asAutoNode);
    const user = asUserNode(rc);
    const route = [...s.route, ...autos, user];
    store.set({ route });
  };
  const moveSelectedTo = (rc) => {
    const s = store.get();
    const i = s.editIdx;
    if (i == null || i < 0 || i >= s.route.length) return;
    const users = userIndices();
    const prevUserIdx = [...users].reverse().find((u) => u < i) ?? -1;
    const nextUserIdx = users.find((u) => u > i) ?? -1;
    const prevAnchor = prevUserIdx >= 0 ? s.route[prevUserIdx] : s.tokenRC;
    const head = prevUserIdx >= 0 ? s.route.slice(0, prevUserIdx + 1) : [];
    const leftSeg = expandCoords(prevAnchor, rc);
    const leftAutos = leftSeg.slice(0, Math.max(0, leftSeg.length - 1)).map(asAutoNode);
    const moved = asUserNode(rc);
    let rightAutos = [];
    let tail = [];
    if (nextUserIdx >= 0) {
      const nextAnchor = s.route[nextUserIdx];
      const rightSeg = expandCoords(rc, nextAnchor);
      rightAutos = rightSeg.slice(0, Math.max(0, rightSeg.length - 1)).map(asAutoNode);
      tail = s.route.slice(nextUserIdx);
    }
    const newRoute = [...head, ...leftAutos, moved, ...rightAutos, ...tail];
    ensurePolys([rc, ...leftSeg, ...rightAutos.map(({ r, c }) => ({ r, c }))]);
    const newIdx = newRoute.findIndex((n) => n.kind === "user" && n.r === rc.r && n.c === rc.c);
    store.set({ route: newRoute, editIdx: newIdx >= 0 ? newIdx : null });
  };
  async function moveTokenTo(rc) {
    if (!adapter) return;
    const prev = store.get();
    const anchors = prev.route.filter((n) => n.kind === "user").map(({ r, c }) => ({ r, c }));
    const route = rebuildFromAnchors(rc, anchors);
    const routeCoords = route.map(({ r, c }) => ({ r, c }));
    adapter.ensurePolys([rc, ...routeCoords]);
    const ctr = adapter.centerOf(rc);
    if (ctr) {
      adapter.token.setPos(ctr.x, ctr.y);
      adapter.token.show();
    }
    let editIdx = prev.editIdx;
    if (editIdx != null) {
      const prevNode = prev.route[editIdx];
      if (!prevNode) {
        editIdx = null;
      } else {
        const matchIdx = route.findIndex(
          (n) => n.kind === prevNode.kind && n.r === prevNode.r && n.c === prevNode.c
        );
        editIdx = matchIdx >= 0 ? matchIdx : null;
      }
    }
    store.set({ tokenRC: rc, route, editIdx });
    const mapFile = cfg.getMapFile();
    if (mapFile) await writeTokenToTiles(cfg.app, mapFile, rc);
  }
  const deleteUserAt = (idx) => {
    const s = store.get();
    if (idx < 0 || idx >= s.route.length) return;
    if (s.route[idx].kind !== "user") return;
    const users = userIndices();
    const myUserPos = users.indexOf(idx);
    const prevUserIdx = myUserPos > 0 ? users[myUserPos - 1] : -1;
    const nextUserIdx = myUserPos < users.length - 1 ? users[myUserPos + 1] : -1;
    const prevAnchor = prevUserIdx >= 0 ? s.route[prevUserIdx] : s.tokenRC;
    const nextAnchor = nextUserIdx >= 0 ? s.route[nextUserIdx] : null;
    const head = prevUserIdx >= 0 ? s.route.slice(0, prevUserIdx + 1) : [];
    const tail = nextUserIdx >= 0 ? s.route.slice(nextUserIdx) : [];
    let bridge = [];
    if (nextAnchor) {
      const seg = expandCoords(prevAnchor, nextAnchor);
      const autos = seg.slice(0, Math.max(0, seg.length - 1)).map(asAutoNode);
      bridge = [...autos];
      ensurePolys(seg);
    }
    const newRoute = [...head, ...bridge, ...tail];
    const newEdit = null;
    store.set({ route: newRoute, editIdx: newEdit });
  };
  const setTokenSpeed = (v) => {
    const val = Number.isFinite(v) && v > 0 ? v : 1;
    store.set({ tokenSpeed: val });
  };
  const setTempo = (v) => {
    const val = Number.isFinite(v) ? Math.max(0.1, Math.min(10, v)) : 1;
    store.set({ tempo: val });
  };
  const play = async () => playback.play();
  const pause = () => playback.pause();
  const reset = async () => {
    playback.pause();
    store.set({
      route: [],
      editIdx: null,
      currentTile: null,
      playing: false
    });
    await initTokenFromTiles();
  };
  async function initTokenFromTiles() {
    const mapFile = cfg.getMapFile();
    if (!mapFile || !adapter) return;
    const prev = store.get();
    const found = await loadTokenCoordFromMap(cfg.app, mapFile);
    const tokenRC = found ?? prev.tokenRC ?? { r: 0, c: 0 };
    const anchors = prev.route.filter((n) => n.kind === "user").map(({ r, c }) => ({ r, c }));
    const route = rebuildFromAnchors(tokenRC, anchors);
    const routeCoords = route.map(({ r, c }) => ({ r, c }));
    adapter.ensurePolys([tokenRC, ...routeCoords]);
    const ctr = adapter.centerOf(tokenRC);
    if (ctr) {
      adapter.token.setPos(ctr.x, ctr.y);
      adapter.token.show();
    }
    let editIdx = prev.editIdx;
    if (editIdx != null) {
      const prevNode = prev.route[editIdx];
      if (!prevNode) {
        editIdx = null;
      } else {
        const matchIdx = route.findIndex(
          (n) => n.kind === prevNode.kind && n.r === prevNode.r && n.c === prevNode.c
        );
        editIdx = matchIdx >= 0 ? matchIdx : null;
      }
    }
    store.set({ tokenRC, route, editIdx });
    if (!found) await writeTokenToTiles(cfg.app, mapFile, tokenRC);
  }
  const persistTokenToTiles = async () => {
    const mf = cfg.getMapFile();
    if (!mf) return;
    await writeTokenToTiles(cfg.app, mf, store.get().tokenRC);
  };
  return {
    getState: () => store.get(),
    selectDot,
    handleHexClick,
    moveSelectedTo,
    moveTokenTo,
    deleteUserAt,
    play,
    pause,
    reset,
    setTokenSpeed,
    setTempo,
    bindAdapter,
    initTokenFromTiles,
    persistTokenToTiles
  };
}
var init_actions = __esm({
  "src/workmodes/session-runner/travel/domain/actions.ts"() {
    "use strict";
    init_state_store();
    init_expansion();
    init_playback();
    init_persistence();
  }
});

// src/workmodes/almanac/mode/cartographer-gateway.ts
function normaliseTravelKey(travelId) {
  return travelId ?? GLOBAL_TRAVEL_KEY;
}
function formatTimestampLabel(ts) {
  if (!ts) return void 0;
  const base = `${ts.year}-${ts.monthId}-${String(ts.day).padStart(2, "0")}`;
  if (typeof ts.hour === "number" && typeof ts.minute === "number") {
    const hh = String(ts.hour).padStart(2, "0");
    const mm = String(ts.minute).padStart(2, "0");
    return `${base} ${hh}:${mm}`;
  }
  return base;
}
function mapEvents(events, skipped = false) {
  if (!events || events.length === 0) {
    return [];
  }
  return events.map((event) => {
    const occurrence = getEventAnchorTimestamp(event) ?? event.date;
    return {
      kind: "event",
      id: event.id,
      title: event.title,
      occurrenceLabel: formatTimestampLabel(occurrence) ?? "\u2014",
      skipped
    };
  });
}
function mapPhenomena(phenomena, skipped = false) {
  if (!phenomena || phenomena.length === 0) {
    return [];
  }
  return phenomena.map((occurrence) => ({
    kind: "phenomenon",
    id: occurrence.phenomenonId,
    title: occurrence.title ?? occurrence.phenomenonId,
    occurrenceLabel: formatTimestampLabel(occurrence.timestamp) ?? "\u2014",
    skipped
  }));
}
var GLOBAL_TRAVEL_KEY, CartographerHookGateway, cartographerHookGateway;
var init_cartographer_gateway = __esm({
  "src/workmodes/almanac/mode/cartographer-gateway.ts"() {
    "use strict";
    init_domain();
    GLOBAL_TRAVEL_KEY = "__global__";
    CartographerHookGateway = class {
      constructor() {
        this.hookListeners = /* @__PURE__ */ new Set();
        this.panelListeners = /* @__PURE__ */ new Map();
        this.lifecycleStart = /* @__PURE__ */ new Set();
        this.lifecycleEnd = /* @__PURE__ */ new Set();
        this.latestSnapshots = /* @__PURE__ */ new Map();
      }
      onHookDispatched(listener) {
        this.hookListeners.add(listener);
        return () => this.hookListeners.delete(listener);
      }
      onTravelStart(listener) {
        this.lifecycleStart.add(listener);
        return () => this.lifecycleStart.delete(listener);
      }
      onTravelEnd(listener) {
        this.lifecycleEnd.add(listener);
        return () => this.lifecycleEnd.delete(listener);
      }
      onPanelUpdate(travelId, listener) {
        const key = normaliseTravelKey(travelId);
        if (!this.panelListeners.has(key)) {
          this.panelListeners.set(key, /* @__PURE__ */ new Set());
        }
        const listeners2 = this.panelListeners.get(key);
        listeners2.add(listener);
        const snapshot = this.latestSnapshots.get(key);
        if (snapshot) {
          void listener(snapshot);
        }
        return () => {
          const set2 = this.panelListeners.get(key);
          set2?.delete(listener);
          if (set2 && set2.size === 0) {
            this.panelListeners.delete(key);
          }
        };
      }
      emitTravelStart(travelId) {
        const key = normaliseTravelKey(travelId);
        for (const listener of this.lifecycleStart) {
          void listener(key === GLOBAL_TRAVEL_KEY ? null : travelId);
        }
      }
      emitTravelEnd(travelId) {
        const key = normaliseTravelKey(travelId);
        for (const listener of this.lifecycleEnd) {
          void listener(key === GLOBAL_TRAVEL_KEY ? null : travelId);
        }
      }
      getPanelSnapshot(travelId) {
        const key = normaliseTravelKey(travelId);
        return this.latestSnapshots.get(key) ?? null;
      }
      reset() {
        this.latestSnapshots.clear();
        this.panelListeners.clear();
        this.hookListeners.clear();
        this.lifecycleStart.clear();
        this.lifecycleEnd.clear();
      }
      async dispatchHooks(events, phenomena, context) {
        if (this.hookListeners.size === 0) {
          return;
        }
        const payload = {
          scope: context.scope,
          travelId: context.travelId ?? null,
          reason: context.reason ?? "advance",
          events: events.map((event) => ({
            eventId: event.id,
            calendarId: event.calendarId,
            occurrence: getEventAnchorTimestamp(event) ?? event.date,
            title: event.title
          })),
          phenomena: phenomena.map((occurrence) => ({
            phenomenonId: occurrence.phenomenonId,
            occurrence: occurrence.timestamp,
            effects: occurrence.effects
          }))
        };
        for (const listener of this.hookListeners) {
          await listener(payload);
        }
      }
      async notifyTravelPanel(update) {
        const key = normaliseTravelKey(update.travelId);
        const snapshot = {
          travelId: key === GLOBAL_TRAVEL_KEY ? null : update.travelId ?? null,
          timestampLabel: formatTimestampLabel(update.currentTimestamp),
          message: update.message,
          reason: update.reason ?? "advance",
          lastAdvanceStep: update.lastAdvanceStep,
          logEntries: [
            ...mapEvents(update.triggeredEvents, false),
            ...mapPhenomena(update.triggeredPhenomena, false),
            ...mapEvents(update.skippedEvents, true),
            ...mapPhenomena(update.skippedPhenomena, true)
          ]
        };
        this.latestSnapshots.set(key, snapshot);
        const listeners2 = this.panelListeners.get(key);
        if (!listeners2 || listeners2.size === 0) {
          return;
        }
        for (const listener of listeners2) {
          await listener(snapshot);
        }
      }
    };
    cartographerHookGateway = new CartographerHookGateway();
  }
});

// src/workmodes/almanac/mode/cartographer-bridge.ts
function getCartographerBridge() {
  return activeBridge;
}
var activeBridge;
var init_cartographer_bridge = __esm({
  "src/workmodes/almanac/mode/cartographer-bridge.ts"() {
    "use strict";
    init_plugin_logger();
    activeBridge = null;
  }
});

// src/workmodes/session-runner/travel/ui/controls.ts
function createPlaybackControls(host, callbacks) {
  const root = host.createDiv({ cls: "sm-cartographer__travel-buttons" });
  const clock = root.createEl("div", { cls: "sm-cartographer__travel-clock", text: "00h" });
  const playBtn = root.createEl("button", {
    cls: "sm-cartographer__travel-button sm-cartographer__travel-button--play",
    text: "Start"
  });
  (0, import_obsidian40.setIcon)(playBtn, "play");
  applyMapButtonStyle(playBtn);
  playBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    if (playBtn.disabled) return;
    void callbacks.onPlay?.();
  });
  const stopBtn = root.createEl("button", {
    cls: "sm-cartographer__travel-button sm-cartographer__travel-button--stop",
    text: "Stopp"
  });
  (0, import_obsidian40.setIcon)(stopBtn, "square");
  applyMapButtonStyle(stopBtn);
  stopBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    if (stopBtn.disabled) return;
    void callbacks.onStop?.();
  });
  const resetBtn = root.createEl("button", {
    cls: "sm-cartographer__travel-button sm-cartographer__travel-button--reset",
    text: "Reset"
  });
  (0, import_obsidian40.setIcon)(resetBtn, "rotate-ccw");
  applyMapButtonStyle(resetBtn);
  resetBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    if (resetBtn.disabled) return;
    void callbacks.onReset?.();
  });
  const encounterBtn = root.createEl("button", {
    cls: "sm-cartographer__travel-button sm-cartographer__travel-button--encounter",
    text: "Random Encounter"
  });
  (0, import_obsidian40.setIcon)(encounterBtn, "swords");
  applyMapButtonStyle(encounterBtn);
  encounterBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    if (encounterBtn.disabled) return;
    void callbacks.onRandomEncounter?.();
  });
  const tempoWrap = root.createDiv({ cls: "sm-cartographer__travel-tempo" });
  const tempoLabel = tempoWrap.createSpan({ text: "x1.0" });
  const tempoInput = tempoWrap.createEl("input", {
    type: "range",
    attr: { min: "0.1", max: "10", step: "0.1" }
  });
  tempoInput.value = "1";
  tempoInput.oninput = () => {
    const v = Math.max(0.1, Math.min(10, parseFloat(tempoInput.value) || 1));
    tempoLabel.setText(`x${v.toFixed(1)}`);
    callbacks.onTempoChange?.(v);
  };
  const setState = (state) => {
    const hasRoute = state.route.length > 0;
    playBtn.disabled = state.playing || !hasRoute;
    stopBtn.disabled = !state.playing;
    resetBtn.disabled = !hasRoute && !state.playing;
    encounterBtn.disabled = !hasRoute;
  };
  setState({ playing: false, route: [] });
  const setClock = (hours) => {
    const h = Math.floor(hours);
    clock.setText(`${h}h`);
  };
  const setTempo = (tempo) => {
    const v = Math.max(0.1, Math.min(10, tempo));
    tempoInput.value = String(v);
    tempoLabel.setText(`x${v.toFixed(1)}`);
  };
  const destroy = () => {
    playBtn.replaceWith();
    stopBtn.replaceWith();
    resetBtn.replaceWith();
    encounterBtn.replaceWith();
    root.remove();
  };
  return {
    root,
    setState,
    destroy,
    setClock,
    setTempo
  };
}
var import_obsidian40;
var init_controls = __esm({
  "src/workmodes/session-runner/travel/ui/controls.ts"() {
    "use strict";
    import_obsidian40 = require("obsidian");
    init_map_workflows();
  }
});

// src/workmodes/session-runner/view/controllers/playback-controller.ts
var TravelPlaybackController;
var init_playback_controller = __esm({
  "src/workmodes/session-runner/view/controllers/playback-controller.ts"() {
    "use strict";
    init_controls();
    TravelPlaybackController = class {
      constructor() {
        this.handle = null;
      }
      mount(host, driver) {
        this.dispose();
        this.handle = createPlaybackControls(host.controlsHost, {
          onPlay: () => void driver.play(),
          onStop: () => void driver.pause(),
          onReset: () => void driver.reset(),
          onTempoChange: (value) => driver.setTempo?.(value),
          onRandomEncounter: () => void driver.onRandomEncounter?.()
        });
        this.reset();
      }
      sync(state) {
        if (!this.handle) return;
        this.handle.setState({ playing: state.playing, route: state.route });
        this.handle?.setClock?.(state.clockHours ?? 0);
        this.handle?.setTempo?.(state.tempo ?? 1);
      }
      reset() {
        this.handle?.setState({ playing: false, route: [] });
      }
      dispose() {
        this.handle?.destroy();
        this.handle = null;
      }
    };
  }
});

// src/workmodes/session-runner/travel/ui/drag.controller.ts
function createDragController(deps) {
  const { routeLayerEl, tokenEl, token, adapter, logic, polyToCoord } = deps;
  let isDragging = false;
  let dragKind = null;
  let lastDragRC = null;
  let suppressNextHexClick = false;
  let pointerCaptureOwner = null;
  let activePointerId = null;
  function disableLayerHit(on) {
    routeLayerEl.style.pointerEvents = on ? "none" : "";
  }
  function findPolygonAt(clientX, clientY) {
    const el = document.elementFromPoint(clientX, clientY);
    if (!el) return null;
    const poly1 = el.closest?.("polygon");
    if (poly1) return poly1;
    let cur = el;
    while (cur) {
      if (cur instanceof SVGPolygonElement) return cur;
      cur = cur.parentElement;
    }
    return null;
  }
  function getDotElements(idx) {
    const dot = routeLayerEl.querySelector(`.tg-route-dot[data-idx="${idx}"]`);
    const hit = routeLayerEl.querySelector(`.tg-route-dot-hitbox[data-idx="${idx}"]`);
    return { dot, hit };
  }
  function ghostMoveSelectedDot(rc) {
    const s = logic.getState();
    const idx = s.editIdx;
    if (idx == null) return;
    const { dot, hit } = getDotElements(idx);
    if (!dot) return;
    const ctr = adapter.centerOf(rc);
    if (!ctr) return;
    dot.setAttribute("cx", String(ctr.x));
    dot.setAttribute("cy", String(ctr.y));
    if (hit) {
      hit.setAttribute("cx", String(ctr.x));
      hit.setAttribute("cy", String(ctr.y));
    }
  }
  function ghostMoveToken(rc) {
    const ctr = adapter.centerOf(rc);
    if (!ctr) return;
    token.setPos(ctr.x, ctr.y);
    token.show();
  }
  function capturePointer(el, pointerId) {
    if (!el || typeof el.setPointerCapture !== "function") {
      pointerCaptureOwner = null;
      activePointerId = null;
      return;
    }
    try {
      el.setPointerCapture(pointerId);
      pointerCaptureOwner = el;
      activePointerId = pointerId;
    } catch {
      pointerCaptureOwner = null;
      activePointerId = null;
    }
  }
  function releasePointerCapture() {
    if (!pointerCaptureOwner || activePointerId == null) {
      pointerCaptureOwner = null;
      activePointerId = null;
      return;
    }
    const el = pointerCaptureOwner;
    try {
      el.releasePointerCapture?.(activePointerId);
    } catch {
    }
    pointerCaptureOwner = null;
    activePointerId = null;
  }
  const onGlobalPointerDownCapture = (ev) => {
    if (ev.button !== 0) return;
    const check = (el) => {
      if (!(el instanceof Element)) return false;
      if (el === tokenEl || tokenEl.contains(el)) return true;
      if (el instanceof SVGCircleElement && routeLayerEl.contains(el)) return true;
      return false;
    };
    const path = typeof ev.composedPath === "function" ? ev.composedPath() : [];
    if (Array.isArray(path) && path.length > 0) {
      for (const el of path) {
        if (check(el)) {
          suppressNextHexClick = true;
          return;
        }
      }
    } else if (check(ev.target)) {
      suppressNextHexClick = true;
    }
  };
  const onDotPointerDown = (ev) => {
    if (ev.button !== 0) return;
    const t = ev.target;
    if (!(t instanceof SVGCircleElement)) return;
    if (!t.classList.contains("tg-route-dot") && !t.classList.contains("tg-route-dot-hitbox")) return;
    const idxAttr = t.getAttribute("data-idx");
    const idx = idxAttr ? Number(idxAttr) : NaN;
    if (!Number.isFinite(idx) || idx < 0) return;
    logic.selectDot(idx);
    dragKind = "dot";
    isDragging = true;
    lastDragRC = null;
    suppressNextHexClick = true;
    disableLayerHit(true);
    const { dot } = getDotElements(idx);
    capturePointer(dot ?? t, ev.pointerId);
    ev.preventDefault();
    ev.stopImmediatePropagation?.();
    ev.stopPropagation();
  };
  const onTokenPointerDown = (ev) => {
    if (ev.button !== 0) return;
    dragKind = "token";
    isDragging = true;
    lastDragRC = null;
    suppressNextHexClick = true;
    disableLayerHit(true);
    capturePointer(tokenEl, ev.pointerId);
    ev.preventDefault();
    ev.stopImmediatePropagation?.();
    ev.stopPropagation();
  };
  const onPointerMove = (ev) => {
    if (!isDragging) return;
    if ((ev.buttons & 1) === 0) {
      endDrag();
      return;
    }
    const poly = findPolygonAt(ev.clientX, ev.clientY);
    if (!poly) return;
    const rc = polyToCoord.get(poly);
    if (!rc) return;
    if (lastDragRC && rc.r === lastDragRC.r && rc.c === lastDragRC.c) return;
    lastDragRC = rc;
    if (dragKind === "dot") ghostMoveSelectedDot(rc);
    else if (dragKind === "token") ghostMoveToken(rc);
  };
  function endDrag() {
    if (!isDragging) {
      releasePointerCapture();
      return;
    }
    isDragging = false;
    if (lastDragRC) {
      adapter.ensurePolys([lastDragRC]);
      if (dragKind === "dot") logic.moveSelectedTo(lastDragRC);
      else if (dragKind === "token") logic.moveTokenTo(lastDragRC);
      suppressNextHexClick = true;
    }
    lastDragRC = null;
    dragKind = null;
    disableLayerHit(false);
    releasePointerCapture();
  }
  const onPointerUp = () => endDrag();
  const onPointerCancel = () => endDrag();
  function bind() {
    window.addEventListener("pointerdown", onGlobalPointerDownCapture, { capture: true });
    routeLayerEl.addEventListener("pointerdown", onDotPointerDown, { capture: true });
    tokenEl.addEventListener("pointerdown", onTokenPointerDown, { capture: true });
    window.addEventListener("pointermove", onPointerMove, { passive: true });
    window.addEventListener("pointerup", onPointerUp, { passive: true });
    window.addEventListener("pointercancel", onPointerCancel, { passive: true });
  }
  function unbind() {
    window.removeEventListener("pointerdown", onGlobalPointerDownCapture, { capture: true });
    routeLayerEl.removeEventListener("pointerdown", onDotPointerDown, { capture: true });
    tokenEl.removeEventListener("pointerdown", onTokenPointerDown, { capture: true });
    window.removeEventListener("pointermove", onPointerMove);
    window.removeEventListener("pointerup", onPointerUp);
    window.removeEventListener("pointercancel", onPointerCancel);
    releasePointerCapture();
  }
  function consumeClickSuppression() {
    if (isDragging) return true;
    if (!suppressNextHexClick) return false;
    suppressNextHexClick = false;
    return true;
  }
  return { bind, unbind, consumeClickSuppression };
}
var init_drag_controller = __esm({
  "src/workmodes/session-runner/travel/ui/drag.controller.ts"() {
    "use strict";
  }
});

// src/workmodes/session-runner/travel/ui/context-menu.controller.ts
function bindContextMenu(routeLayerEl, logic) {
  const onContextMenu = (ev) => {
    const target = ev.target;
    if (!(target instanceof SVGElement)) return;
    const dot = target.closest(".tg-route-dot, .tg-route-dot-hitbox");
    if (!dot) return;
    const idxAttr = dot.getAttribute("data-idx");
    if (!idxAttr) return;
    const idx = Number(idxAttr);
    if (!Number.isFinite(idx) || idx < 0) return;
    const route = logic.getState().route;
    const node = route[idx];
    if (!node) return;
    const allowDelete = node.kind === "user";
    const canTriggerEncounter = typeof logic.triggerEncounterAt === "function";
    if (!allowDelete && !canTriggerEncounter) {
      return;
    }
    ev.preventDefault();
    ev.stopPropagation();
    const menu = new import_obsidian41.Menu();
    if (allowDelete) {
      menu.addItem(
        (item) => item.setTitle("Wegpunkt entfernen").setIcon("trash").onClick(() => {
          logic.deleteUserAt(idx);
        })
      );
    }
    if (canTriggerEncounter) {
      menu.addItem(
        (item) => item.setTitle("Encounter hier starten").setIcon("sparkles").onClick(() => {
          void logic.triggerEncounterAt?.(idx);
        })
      );
    }
    menu.showAtMouseEvent(ev);
  };
  routeLayerEl.addEventListener("contextmenu", onContextMenu, { capture: true });
  return () => routeLayerEl.removeEventListener("contextmenu", onContextMenu, { capture: true });
}
var import_obsidian41;
var init_context_menu_controller = __esm({
  "src/workmodes/session-runner/travel/ui/context-menu.controller.ts"() {
    "use strict";
    import_obsidian41 = require("obsidian");
  }
});

// src/workmodes/session-runner/travel/ui/contextmenue.ts
var init_contextmenue = __esm({
  "src/workmodes/session-runner/travel/ui/contextmenue.ts"() {
    "use strict";
    init_context_menu_controller();
  }
});

// src/workmodes/session-runner/view/controllers/interaction-controller.ts
var TravelInteractionController;
var init_interaction_controller = __esm({
  "src/workmodes/session-runner/view/controllers/interaction-controller.ts"() {
    "use strict";
    init_drag_controller();
    init_contextmenue();
    TravelInteractionController = class {
      constructor() {
        this.drag = null;
        this.unbindContext = null;
      }
      bind(env, logic) {
        this.dispose();
        this.drag = createDragController({
          routeLayerEl: env.routeLayerEl,
          tokenEl: env.tokenLayerEl,
          token: env.token,
          adapter: env.adapter,
          logic: {
            getState: () => logic.getState(),
            selectDot: (idx) => logic.selectDot(idx),
            moveSelectedTo: (rc) => logic.moveSelectedTo(rc),
            moveTokenTo: (rc) => logic.moveTokenTo(rc)
          },
          polyToCoord: env.polyToCoord
        });
        this.drag.bind();
        this.unbindContext = bindContextMenu(env.routeLayerEl, {
          getState: () => logic.getState(),
          deleteUserAt: (idx) => logic.deleteUserAt(idx),
          triggerEncounterAt: (idx) => logic.triggerEncounterAt?.(idx)
        });
      }
      consumeClickSuppression() {
        return this.drag?.consumeClickSuppression() ?? false;
      }
      dispose() {
        if (this.drag) {
          this.drag.unbind();
          this.drag = null;
        }
        if (this.unbindContext) {
          this.unbindContext();
          this.unbindContext = null;
        }
      }
    };
  }
});

// src/workmodes/encounter/event-builder.ts
async function createEncounterEventFromTravel(app, ctx, options = {}) {
  const triggeredAt = options.triggeredAt ?? (/* @__PURE__ */ new Date()).toISOString();
  const coord = options.coordOverride ?? ctx?.state?.currentTile ?? ctx?.state?.tokenRC ?? null;
  const mapFile = ctx?.mapFile ?? null;
  let regionName;
  let factionName;
  let encounterOdds;
  if (mapFile && coord) {
    try {
      const { loadTile: loadTile2 } = await Promise.resolve().then(() => (init_tile_repository(), tile_repository_exports));
      const tile = await loadTile2(app, mapFile, coord).catch(() => null);
      const tileRegion = typeof tile?.region === "string" ? tile.region : void 0;
      const tileFaction = typeof tile?.faction === "string" ? tile.faction : void 0;
      if (tileRegion) {
        regionName = tileRegion;
        try {
          const { loadRegions: loadRegions3 } = await Promise.resolve().then(() => (init_region_repository(), region_repository_exports));
          const regions = await loadRegions3(app);
          const region = regions.find((r) => typeof r?.name === "string" && r.name.toLowerCase() === tileRegion.toLowerCase());
          const odds = region?.encounterOdds;
          if (typeof odds === "number" && Number.isFinite(odds) && odds > 0) {
            encounterOdds = odds;
          }
        } catch (err) {
          logger2.error("[encounter] failed to resolve region odds", err);
        }
      }
      if (tileFaction) {
        factionName = tileFaction;
      }
    } catch (err) {
      logger2.error("[encounter] failed to read tile metadata", err);
    }
  }
  const travelClock = ctx?.state?.clockHours;
  const source = options.source ?? "travel";
  const idPrefix = options.idPrefix ?? source;
  const event = {
    id: `${idPrefix}-${Date.now()}`,
    source,
    triggeredAt,
    coord,
    regionName,
    factionName,
    mapPath: mapFile?.path,
    mapName: mapFile?.basename,
    encounterOdds,
    travelClockHours: typeof travelClock === "number" && Number.isFinite(travelClock) ? travelClock : void 0
  };
  return event;
}
var init_event_builder = __esm({
  "src/workmodes/encounter/event-builder.ts"() {
    "use strict";
    init_plugin_logger();
  }
});

// src/workmodes/session-runner/view/controllers/encounter-gateway.ts
function loadEncounterModule() {
  return Promise.all([
    Promise.resolve().then(() => (init_layout(), layout_exports)),
    Promise.resolve().then(() => (init_view2(), view_exports))
  ]).then(([layout, encounter]) => ({
    getCenterLeaf: layout.getCenterLeaf,
    VIEW_ENCOUNTER: encounter.VIEW_ENCOUNTER
  })).catch((err) => {
    logger2.error("[session-runner] failed to load encounter module", err);
    new import_obsidian42.Notice("Encounter-Modul konnte nicht geladen werden.");
    return null;
  });
}
function ensureEncounterModule() {
  if (!encounterModule) {
    encounterModule = loadEncounterModule();
  }
  return encounterModule;
}
function preloadEncounterModule() {
  void ensureEncounterModule();
}
async function openEncounter2(app, context) {
  const mod2 = await ensureEncounterModule();
  if (!mod2) return false;
  const issue = describeEncounterContextIssue(context);
  if (issue) {
    logger2.warn(`[session-runner] ${issue.log}`, context);
    new import_obsidian42.Notice(issue.message);
  } else if (context) {
    try {
      const event = await createEncounterEventFromTravel(app, context);
      if (event) {
        publishEncounterEvent(event);
      }
    } catch (err) {
      logger2.error("[session-runner] failed to publish encounter payload", err);
    }
  }
  const leaf = mod2.getCenterLeaf(app);
  await leaf.setViewState({ type: mod2.VIEW_ENCOUNTER, active: true });
  app.workspace.revealLeaf(leaf);
  return true;
}
function describeEncounterContextIssue(context) {
  if (!context) {
    return {
      message: "Begegnung konnte nicht ge\xF6ffnet werden: Es liegen keine Reisedaten vor.",
      log: "missing travel context for encounter"
    };
  }
  if (!context.mapFile) {
    return {
      message: "Begegnung enth\xE4lt keine Kartendatei. \xD6ffne die Karte erneut und versuche es nochmal.",
      log: "missing map file for encounter context"
    };
  }
  if (!context.state) {
    return {
      message: "Begegnung enth\xE4lt keinen Reisezustand. Aktualisiere den Travel-Guide und versuche es erneut.",
      log: "missing travel state snapshot for encounter context"
    };
  }
  return null;
}
async function publishManualEncounter(app, context, options = {}) {
  try {
    const event = await createEncounterEventFromTravel(app, context, {
      source: "manual",
      idPrefix: options.idPrefix ?? "manual",
      coordOverride: options.coordOverride,
      triggeredAt: options.triggeredAt
    });
    if (event) {
      publishEncounterEvent(event);
    }
  } catch (err) {
    logger2.error("[session-runner] failed to publish manual encounter", err);
  }
}
var import_obsidian42, encounterModule;
var init_encounter_gateway = __esm({
  "src/workmodes/session-runner/view/controllers/encounter-gateway.ts"() {
    "use strict";
    import_obsidian42 = require("obsidian");
    init_session_store();
    init_plugin_logger();
    init_event_builder();
    encounterModule = null;
  }
});

// src/workmodes/session-runner/travel/infra/encounter-sync.ts
function createEncounterSync(cfg) {
  let disposed = false;
  let lastHandledId = peekLatestEncounterEvent()?.id ?? null;
  const unsubscribe = subscribeToEncounterEvents((event) => {
    if (disposed) return;
    if (event.id === lastHandledId) return;
    lastHandledId = event.id;
    if (event.source === "travel") {
      return;
    }
    cfg.pausePlayback();
    const shouldOpen = cfg.onExternalEncounter?.(event);
    if (shouldOpen === false) {
      return;
    }
    void cfg.openEncounter();
  });
  return {
    async handleTravelEncounter() {
      cfg.pausePlayback();
      const context = {
        mapFile: cfg.getMapFile(),
        state: cfg.getState()
      };
      const ok = await cfg.openEncounter(context);
      if (!ok) return;
      const latest = peekLatestEncounterEvent();
      if (latest) {
        lastHandledId = latest.id;
      }
    },
    dispose() {
      if (disposed) return;
      disposed = true;
      unsubscribe();
    }
  };
}
var init_encounter_sync = __esm({
  "src/workmodes/session-runner/travel/infra/encounter-sync.ts"() {
    "use strict";
    init_session_store();
  }
});

// src/features/audio/audio-player.ts
function createAudioPlayer() {
  let playlist = null;
  let currentTrackIndex = -1;
  let playbackState = "idle";
  let globalVolume = 0.7;
  let shuffle = false;
  let loop = false;
  let crossfadeDuration = 2;
  let primaryAudio = null;
  let secondaryAudio = null;
  let currentAudio = null;
  let shuffleOrder = [];
  const statusSubscribers = [];
  let crossfadeStartTime = null;
  let crossfadeInterval = null;
  function initializeAudioElements() {
    if (!primaryAudio) {
      primaryAudio = new Audio();
      primaryAudio.addEventListener("ended", handleTrackEnded);
      primaryAudio.addEventListener("timeupdate", handleTimeUpdate);
      primaryAudio.addEventListener("loadedmetadata", handleMetadataLoaded);
      primaryAudio.addEventListener("error", handleAudioError);
    }
    if (!secondaryAudio) {
      secondaryAudio = new Audio();
      secondaryAudio.addEventListener("ended", handleTrackEnded);
      secondaryAudio.addEventListener("timeupdate", handleTimeUpdate);
      secondaryAudio.addEventListener("loadedmetadata", handleMetadataLoaded);
      secondaryAudio.addEventListener("error", handleAudioError);
    }
    currentAudio = primaryAudio;
  }
  function handleTrackEnded() {
    if (playbackState === "crossfading") return;
    advanceToNextTrack().catch((error) => {
      logger2.error("[AudioPlayer] Failed to advance to next track", { error });
    });
  }
  function handleTimeUpdate() {
    if (!currentAudio || playbackState === "idle" || playbackState === "stopped") return;
    notifyStatusChange();
  }
  function handleMetadataLoaded() {
    notifyStatusChange();
  }
  function handleAudioError(event) {
    const audio = event.target;
    logger2.error("[AudioPlayer] Audio error", {
      src: audio.src,
      error: audio.error?.message
    });
    advanceToNextTrack().catch((error) => {
      logger2.error("[AudioPlayer] Failed to recover from audio error", { error });
    });
  }
  async function advanceToNextTrack() {
    if (!playlist) return;
    const nextIndex = getNextTrackIndex();
    if (nextIndex === -1) {
      stopPlayback();
      return;
    }
    await skipToTrackInternal(nextIndex);
  }
  function getNextTrackIndex() {
    if (!playlist) return -1;
    if (shuffle) {
      const currentOrderIndex = shuffleOrder.indexOf(currentTrackIndex);
      const nextOrderIndex = currentOrderIndex + 1;
      if (nextOrderIndex >= shuffleOrder.length) {
        if (loop) {
          generateShuffleOrder();
          return shuffleOrder[0];
        }
        return -1;
      }
      return shuffleOrder[nextOrderIndex];
    } else {
      const nextIndex = currentTrackIndex + 1;
      if (nextIndex >= playlist.tracks.length) {
        if (loop) {
          return 0;
        }
        return -1;
      }
      return nextIndex;
    }
  }
  function getPreviousTrackIndex() {
    if (!playlist) return -1;
    if (shuffle) {
      const currentOrderIndex = shuffleOrder.indexOf(currentTrackIndex);
      const prevOrderIndex = currentOrderIndex - 1;
      if (prevOrderIndex < 0) {
        if (loop) {
          return shuffleOrder[shuffleOrder.length - 1];
        }
        return -1;
      }
      return shuffleOrder[prevOrderIndex];
    } else {
      const prevIndex = currentTrackIndex - 1;
      if (prevIndex < 0) {
        if (loop) {
          return playlist.tracks.length - 1;
        }
        return -1;
      }
      return prevIndex;
    }
  }
  function generateShuffleOrder() {
    if (!playlist) return;
    shuffleOrder = Array.from({ length: playlist.tracks.length }, (_, i) => i);
    for (let i = shuffleOrder.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffleOrder[i], shuffleOrder[j]] = [shuffleOrder[j], shuffleOrder[i]];
    }
  }
  function loadTrack(audio, track) {
    audio.src = track.source;
    audio.load();
    const trackVolume = track.volume ?? playlist?.default_volume ?? 0.7;
    audio.volume = Math.max(0, Math.min(1, trackVolume * globalVolume));
  }
  async function startCrossfade(nextTrackIndex) {
    if (!playlist || !currentAudio) return;
    const nextTrack = playlist.tracks[nextTrackIndex];
    if (!nextTrack) return;
    const nextAudio = currentAudio === primaryAudio ? secondaryAudio : primaryAudio;
    loadTrack(nextAudio, nextTrack);
    await new Promise((resolve) => {
      const handler = () => {
        nextAudio.removeEventListener("loadedmetadata", handler);
        resolve();
      };
      nextAudio.addEventListener("loadedmetadata", handler);
    });
    nextAudio.volume = 0;
    await nextAudio.play();
    playbackState = "crossfading";
    crossfadeStartTime = Date.now();
    const fadeSteps = Math.ceil(crossfadeDuration * 60);
    const fadeInterval = crossfadeDuration * 1e3 / fadeSteps;
    crossfadeInterval = window.setInterval(() => {
      if (!crossfadeStartTime) return;
      const elapsed = (Date.now() - crossfadeStartTime) / 1e3;
      const progress = Math.min(1, elapsed / crossfadeDuration);
      const oldVolume = (1 - progress) * (currentAudio?.volume ?? 0);
      const newVolume = progress * (nextTrack.volume ?? playlist?.default_volume ?? 0.7) * globalVolume;
      if (currentAudio) currentAudio.volume = Math.max(0, Math.min(1, oldVolume));
      nextAudio.volume = Math.max(0, Math.min(1, newVolume));
      if (progress >= 1) {
        completeCrossfade(nextAudio, nextTrackIndex);
      }
    }, fadeInterval);
    notifyStatusChange();
  }
  function completeCrossfade(nextAudio, nextTrackIndex) {
    if (crossfadeInterval !== null) {
      window.clearInterval(crossfadeInterval);
      crossfadeInterval = null;
    }
    if (currentAudio) {
      currentAudio.pause();
      currentAudio.currentTime = 0;
    }
    currentAudio = nextAudio;
    currentTrackIndex = nextTrackIndex;
    playbackState = "playing";
    crossfadeStartTime = null;
    notifyStatusChange();
  }
  function getCurrentTrack() {
    if (!playlist || currentTrackIndex < 0 || !currentAudio) return null;
    const track = playlist.tracks[currentTrackIndex];
    if (!track) return null;
    const trackVolume = track.volume ?? playlist.default_volume ?? 0.7;
    return {
      track,
      index: currentTrackIndex,
      position: currentAudio.currentTime,
      duration: track.duration ?? currentAudio.duration,
      effectiveVolume: trackVolume * globalVolume
    };
  }
  function getStatus() {
    return {
      state: playbackState,
      currentTrack: getCurrentTrack(),
      playlist,
      globalVolume,
      shuffle,
      loop,
      crossfadeDuration
    };
  }
  function notifyStatusChange() {
    const status = getStatus();
    statusSubscribers.forEach((callback) => {
      try {
        callback(status);
      } catch (error) {
        logger2.error("[AudioPlayer] Status callback error", { error });
      }
    });
  }
  function stopPlayback() {
    if (crossfadeInterval !== null) {
      window.clearInterval(crossfadeInterval);
      crossfadeInterval = null;
    }
    if (primaryAudio) {
      primaryAudio.pause();
      primaryAudio.currentTime = 0;
      primaryAudio.src = "";
    }
    if (secondaryAudio) {
      secondaryAudio.pause();
      secondaryAudio.currentTime = 0;
      secondaryAudio.src = "";
    }
    currentAudio = primaryAudio;
    currentTrackIndex = -1;
    if (playlist && playlist.tracks.length > 0) {
      playbackState = "stopped";
    } else {
      playbackState = "idle";
    }
    crossfadeStartTime = null;
    notifyStatusChange();
  }
  async function skipToTrackInternal(index) {
    if (!playlist || index < 0 || index >= playlist.tracks.length) {
      logger2.error("[AudioPlayer] Invalid track index", { index });
      return;
    }
    const wasPlaying = playbackState === "playing" || playbackState === "crossfading";
    if (crossfadeInterval !== null) {
      window.clearInterval(crossfadeInterval);
      crossfadeInterval = null;
    }
    if (currentAudio) {
      currentAudio.pause();
      currentAudio.currentTime = 0;
    }
    currentTrackIndex = index;
    playbackState = wasPlaying ? "playing" : "stopped";
    if (wasPlaying) {
      initializeAudioElements();
      const track = playlist.tracks[index];
      loadTrack(currentAudio, track);
      await currentAudio.play();
    }
    notifyStatusChange();
  }
  const api = {
    loadPlaylist(newPlaylist) {
      logger2.info("[AudioPlayer] Loading playlist", { name: newPlaylist.name });
      stopPlayback();
      playlist = newPlaylist;
      shuffle = newPlaylist.shuffle ?? false;
      loop = newPlaylist.loop ?? false;
      crossfadeDuration = newPlaylist.crossfade_duration ?? 2;
      if (shuffle) {
        generateShuffleOrder();
      }
      notifyStatusChange();
    },
    async play() {
      if (!playlist || playlist.tracks.length === 0) {
        logger2.warn("[AudioPlayer] Cannot play: no playlist loaded");
        return;
      }
      initializeAudioElements();
      if (playbackState === "paused" && currentAudio) {
        await currentAudio.play();
        playbackState = "playing";
        notifyStatusChange();
        return;
      }
      if (currentTrackIndex < 0) {
        currentTrackIndex = shuffle ? shuffleOrder[0] : 0;
      }
      const track = playlist.tracks[currentTrackIndex];
      if (!track) {
        logger2.error("[AudioPlayer] Invalid track index", { currentTrackIndex });
        return;
      }
      loadTrack(currentAudio, track);
      await currentAudio.play();
      playbackState = "playing";
      notifyStatusChange();
    },
    pause() {
      if (playbackState === "playing" && currentAudio) {
        currentAudio.pause();
        playbackState = "paused";
        notifyStatusChange();
      }
    },
    stop() {
      stopPlayback();
    },
    async skipNext() {
      if (!playlist) return;
      const nextIndex = getNextTrackIndex();
      if (nextIndex === -1) {
        stopPlayback();
        return;
      }
      if (playbackState === "playing" && crossfadeDuration > 0) {
        await startCrossfade(nextIndex);
      } else {
        await skipToTrackInternal(nextIndex);
      }
    },
    async skipPrevious() {
      if (!playlist) return;
      if (currentAudio && currentAudio.currentTime > 3) {
        currentAudio.currentTime = 0;
        notifyStatusChange();
        return;
      }
      const prevIndex = getPreviousTrackIndex();
      if (prevIndex === -1) {
        if (currentAudio) {
          currentAudio.currentTime = 0;
          notifyStatusChange();
        }
        return;
      }
      await skipToTrackInternal(prevIndex);
    },
    async skipToTrack(index) {
      await skipToTrackInternal(index);
    },
    setGlobalVolume(volume) {
      globalVolume = Math.max(0, Math.min(1, volume));
      if (currentAudio && playlist && currentTrackIndex >= 0) {
        const track = playlist.tracks[currentTrackIndex];
        const trackVolume = track?.volume ?? playlist.default_volume ?? 0.7;
        currentAudio.volume = Math.max(0, Math.min(1, trackVolume * globalVolume));
      }
      notifyStatusChange();
    },
    toggleShuffle() {
      shuffle = !shuffle;
      if (shuffle) {
        generateShuffleOrder();
      }
      logger2.info("[AudioPlayer] Shuffle toggled", { shuffle });
      notifyStatusChange();
    },
    toggleLoop() {
      loop = !loop;
      logger2.info("[AudioPlayer] Loop toggled", { loop });
      notifyStatusChange();
    },
    setCrossfadeDuration(seconds) {
      crossfadeDuration = Math.max(0, Math.min(10, seconds));
      logger2.info("[AudioPlayer] Crossfade duration set", { crossfadeDuration });
      notifyStatusChange();
    },
    seek(position) {
      if (currentAudio) {
        currentAudio.currentTime = Math.max(0, Math.min(currentAudio.duration, position));
        notifyStatusChange();
      }
    },
    getStatus,
    onStatusChange(callback) {
      statusSubscribers.push(callback);
      return () => {
        const index = statusSubscribers.indexOf(callback);
        if (index >= 0) {
          statusSubscribers.splice(index, 1);
        }
      };
    },
    dispose() {
      logger2.info("[AudioPlayer] Disposing");
      stopPlayback();
      if (primaryAudio) {
        primaryAudio.removeEventListener("ended", handleTrackEnded);
        primaryAudio.removeEventListener("timeupdate", handleTimeUpdate);
        primaryAudio.removeEventListener("loadedmetadata", handleMetadataLoaded);
        primaryAudio.removeEventListener("error", handleAudioError);
        primaryAudio.src = "";
        primaryAudio = null;
      }
      if (secondaryAudio) {
        secondaryAudio.removeEventListener("ended", handleTrackEnded);
        secondaryAudio.removeEventListener("timeupdate", handleTimeUpdate);
        secondaryAudio.removeEventListener("loadedmetadata", handleMetadataLoaded);
        secondaryAudio.removeEventListener("error", handleAudioError);
        secondaryAudio.src = "";
        secondaryAudio = null;
      }
      currentAudio = null;
      playlist = null;
      statusSubscribers.length = 0;
    }
  };
  return api;
}
var init_audio_player = __esm({
  "src/features/audio/audio-player.ts"() {
    "use strict";
    init_plugin_logger();
  }
});

// src/features/audio/types.ts
var init_types6 = __esm({
  "src/features/audio/types.ts"() {
    "use strict";
  }
});

// src/features/audio/auto-selection-types.ts
var init_auto_selection_types = __esm({
  "src/features/audio/auto-selection-types.ts"() {
    "use strict";
  }
});

// src/features/audio/auto-selection.ts
function calculatePlaylistScore(playlist, context) {
  const matchedCategories = [];
  let matchedTagCount = 0;
  const hasMatchingTag = (tags, contextValue) => {
    if (!tags || !contextValue) return false;
    return tags.some((tag) => tag.value === contextValue);
  };
  const hasMatchingTagInArray = (tags, contextValues) => {
    if (!tags || !contextValues) return 0;
    let matches = 0;
    for (const tag of tags) {
      if (contextValues.includes(tag.value)) {
        matches++;
      }
    }
    return matches;
  };
  if (hasMatchingTag(playlist.terrain_tags, context.terrain)) {
    matchedCategories.push("terrain");
    matchedTagCount++;
  }
  if (hasMatchingTag(playlist.weather_tags, context.weather)) {
    matchedCategories.push("weather");
    matchedTagCount++;
  }
  if (hasMatchingTag(playlist.time_of_day_tags, context.timeOfDay)) {
    matchedCategories.push("timeOfDay");
    matchedTagCount++;
  }
  const factionMatches = hasMatchingTagInArray(playlist.faction_tags, context.factions);
  if (factionMatches > 0) {
    matchedCategories.push("faction");
    matchedTagCount += factionMatches;
  }
  if (hasMatchingTag(playlist.situation_tags, context.situation)) {
    matchedCategories.push("situation");
    matchedTagCount++;
  }
  const score = matchedCategories.length + matchedTagCount * 0.5;
  return {
    playlistName: playlist.name,
    score,
    matchedCategories,
    matchedTagCount
  };
}
function selectPlaylist(playlists, context) {
  const matches = playlists.map((playlist) => calculatePlaylistScore(playlist, context));
  matches.sort((a, b) => b.score - a.score);
  const selected = matches.length > 0 && matches[0].score > 0 ? matches[0] : null;
  const alternatives = selected ? matches.slice(1) : matches;
  return {
    selected,
    alternatives,
    context
  };
}
function filterPlaylistsByType(playlists, type2) {
  return playlists.filter((playlist) => playlist.type === type2);
}
var init_auto_selection = __esm({
  "src/features/audio/auto-selection.ts"() {
    "use strict";
  }
});

// src/features/weather/weather-store.ts
function createHexKey(mapPath, q, r, s) {
  return `${mapPath}:${q}:${r}:${s}`;
}
function parseHexKey(key) {
  const parts = key.split(":");
  if (parts.length !== 4) return null;
  const [mapPath, qStr, rStr, sStr] = parts;
  const q = parseInt(qStr, 10);
  const r = parseInt(rStr, 10);
  const s = parseInt(sStr, 10);
  if (isNaN(q) || isNaN(r) || isNaN(s)) return null;
  return { mapPath, q, r, s };
}
function createInitialState3() {
  return {
    weatherByHex: /* @__PURE__ */ new Map(),
    historyByHex: /* @__PURE__ */ new Map(),
    activeMapPath: null
  };
}
var import_store2, WeatherStore, weatherStore;
var init_weather_store = __esm({
  "src/features/weather/weather-store.ts"() {
    "use strict";
    import_store2 = require("svelte/store");
    WeatherStore = class {
      constructor() {
        this.store = (0, import_store2.writable)(createInitialState3());
      }
      /**
       * Set weather for a specific hex
       * Automatically archives previous weather to history
       */
      setWeather(mapPath, weather) {
        this.store.update((state) => {
          const key = createHexKey(mapPath, weather.hexCoord.q, weather.hexCoord.r, weather.hexCoord.s);
          const currentWeather = state.weatherByHex.get(key);
          if (currentWeather) {
            this.addToHistory(state, key, currentWeather);
          }
          state.weatherByHex.set(key, { ...weather });
          return state;
        });
      }
      /**
       * Add weather entry to history (internal helper)
       * Maintains max 7 days of history per hex
       */
      addToHistory(state, key, weather) {
        let history = state.historyByHex.get(key) ?? [];
        history.push({
          weather: { ...weather },
          date: weather.lastUpdate
        });
        if (history.length > 7) {
          history = history.slice(-7);
        }
        state.historyByHex.set(key, history);
      }
      /**
       * Get weather for a specific hex (synchronous read from store)
       */
      getWeather(mapPath, q, r, s) {
        let result = null;
        const unsubscribe = this.store.subscribe((state) => {
          const key = createHexKey(mapPath, q, r, s);
          result = state.weatherByHex.get(key) ?? null;
        });
        unsubscribe();
        return result;
      }
      /**
       * Get weather history for a specific hex (last 7 days)
       * Returns array sorted oldest to newest
       */
      getWeatherHistory(mapPath, q, r, s) {
        let result = [];
        const unsubscribe = this.store.subscribe((state) => {
          const key = createHexKey(mapPath, q, r, s);
          result = state.historyByHex.get(key) ?? [];
        });
        unsubscribe();
        return [...result];
      }
      /**
       * Set multiple weather states at once (batch update)
       */
      setWeatherBatch(mapPath, weatherStates) {
        this.store.update((state) => {
          for (const weather of weatherStates) {
            const key = createHexKey(mapPath, weather.hexCoord.q, weather.hexCoord.r, weather.hexCoord.s);
            state.weatherByHex.set(key, { ...weather });
          }
          return state;
        });
      }
      /**
       * Clear all weather for a specific map
       */
      clearMap(mapPath) {
        this.store.update((state) => {
          const keysToRemove = [];
          for (const key of state.weatherByHex.keys()) {
            const parsed = parseHexKey(key);
            if (parsed && parsed.mapPath === mapPath) {
              keysToRemove.push(key);
            }
          }
          for (const key of keysToRemove) {
            state.weatherByHex.delete(key);
            state.historyByHex.delete(key);
          }
          return state;
        });
      }
      /**
       * Clear all weather data
       */
      clearAll() {
        this.store.set(createInitialState3());
      }
      /**
       * Set active map path (for filtering)
       */
      setActiveMap(mapPath) {
        this.store.update((state) => {
          state.activeMapPath = mapPath;
          return state;
        });
      }
      /**
       * Get all weather states for the active map
       */
      getActiveMapWeather() {
        return (0, import_store2.derived)(this.store, ($state) => {
          if (!$state.activeMapPath) return [];
          const results = [];
          for (const [key, weather] of $state.weatherByHex.entries()) {
            const parsed = parseHexKey(key);
            if (parsed && parsed.mapPath === $state.activeMapPath) {
              results.push(weather);
            }
          }
          return results;
        });
      }
      /**
       * Subscribe to store updates
       */
      subscribe(callback) {
        return this.store.subscribe(callback);
      }
      /**
       * Get read-only derived store for a specific hex
       */
      getHexWeather(mapPath, q, r, s) {
        return (0, import_store2.derived)(this.store, ($state) => {
          const key = createHexKey(mapPath, q, r, s);
          return $state.weatherByHex.get(key) ?? null;
        });
      }
      /**
       * Prune old weather data (remove hexes not updated in N days)
       * Used to prevent memory bloat on large maps
       */
      pruneOldWeather(maxAgeDays = 30) {
        const cutoffDate = /* @__PURE__ */ new Date();
        cutoffDate.setDate(cutoffDate.getDate() - maxAgeDays);
        const cutoffTimestamp = cutoffDate.toISOString();
        this.store.update((state) => {
          const keysToRemove = [];
          for (const [key, weather] of state.weatherByHex.entries()) {
            if (weather.lastUpdate < cutoffTimestamp) {
              keysToRemove.push(key);
            }
          }
          for (const key of keysToRemove) {
            state.weatherByHex.delete(key);
          }
          return state;
        });
      }
    };
    weatherStore = new WeatherStore();
  }
});

// src/features/weather/weather-tag-mapper.ts
function mapWeatherTypeToTags(weatherType) {
  switch (weatherType) {
    case "clear":
      return ["clear"];
    case "cloudy":
      return ["cloudy"];
    case "rain":
      return ["rain"];
    case "storm":
      return ["storm", "rain", "wind"];
    case "snow":
      return ["snow"];
    case "fog":
      return ["fog"];
    case "wind":
      return ["wind"];
    case "hot":
      return ["hot"];
    case "cold":
      return ["cold"];
    default:
      return ["clear"];
  }
}
function getPrimaryWeatherTag(weatherType) {
  const tags = mapWeatherTypeToTags(weatherType);
  return tags[0] ?? "clear";
}
var init_weather_tag_mapper = __esm({
  "src/features/weather/weather-tag-mapper.ts"() {
    "use strict";
  }
});

// src/features/audio/context-extractor.ts
async function extractSessionContext(app, mapFile, coord, additionalContext) {
  let tileData = null;
  try {
    tileData = await loadTile(app, mapFile, coord);
  } catch (error) {
    logger2.warn(`[ContextExtractor] Failed to load tile at ${coord.r},${coord.c}:`, error);
  }
  const terrain = tileData?.terrain ? normalizeTerrain(tileData.terrain) : void 0;
  const factions = [];
  if (tileData?.faction) {
    const normalizedFaction = normalizeFaction(tileData.faction);
    if (normalizedFaction) {
      factions.push(normalizedFaction);
    }
  }
  let weather = additionalContext?.weather;
  if (!weather) {
    try {
      const cube = axialToCube(oddrToAxial({ r: coord.r, c: coord.c }));
      const weatherState = weatherStore.getWeather(mapFile.path, cube.q, cube.r, cube.s);
      if (weatherState) {
        weather = getPrimaryWeatherTag(weatherState.currentWeather.type);
      }
    } catch (error) {
      logger2.warn(`[ContextExtractor] Failed to extract weather for hex ${coord.r},${coord.c}:`, error);
    }
  }
  return {
    terrain,
    weather,
    timeOfDay: additionalContext?.timeOfDay,
    factions: factions.length > 0 ? factions : void 0,
    situation: additionalContext?.situation
  };
}
function normalizeTerrain(terrain) {
  const normalized = terrain.trim();
  const terrainTags = [
    "Forest",
    "Mountain",
    "Desert",
    "Swamp",
    "Coastal",
    "Ocean",
    "Arctic",
    "Cave",
    "Underground",
    "Urban",
    "Ruins",
    "Plains",
    "Hills",
    "Jungle",
    "Volcanic"
  ];
  const match = terrainTags.find((tag) => tag.toLowerCase() === normalized.toLowerCase());
  return match;
}
function normalizeFaction(faction) {
  const normalized = faction.trim();
  const factionTags = [
    "Friendly",
    "Neutral",
    "Hostile",
    "Undead",
    "Fey",
    "Fiend",
    "Celestial",
    "Elemental",
    "Dragon",
    "Giant",
    "Humanoid",
    "Beast"
  ];
  const match = factionTags.find((tag) => tag.toLowerCase() === normalized.toLowerCase());
  return match;
}
var init_context_extractor = __esm({
  "src/features/audio/context-extractor.ts"() {
    "use strict";
    init_tile_repository();
    init_weather_store();
    init_weather_tag_mapper();
    init_plugin_logger();
    init_hex_geom();
  }
});

// src/features/audio/index.ts
var init_audio = __esm({
  "src/features/audio/index.ts"() {
    "use strict";
    init_types6();
    init_audio_player();
    init_auto_selection_types();
    init_auto_selection();
    init_context_extractor();
  }
});

// src/workmodes/session-runner/components/audio-panel.ts
function createAudioPanel(host, callbacks) {
  const root = host.createDiv({ cls: "sm-audio-panel" });
  const header = root.createDiv({ cls: "sm-audio-panel__header" });
  header.createEl("h3", { text: "Audio", cls: "sm-audio-panel__title" });
  const contextDisplay = root.createDiv({ cls: "sm-audio-panel__context" });
  const contextTags = contextDisplay.createDiv({ cls: "sm-audio-panel__context-tags" });
  const ambienceSection = root.createDiv({ cls: "sm-audio-panel__section" });
  const ambienceState = {
    player: null,
    statusUnsubscribe: null,
    currentPlaylist: null
  };
  const ambienceControls = createPlayerPanel(
    ambienceSection,
    "Ambience",
    "ambience",
    ambienceState,
    callbacks
  );
  const musicSection = root.createDiv({ cls: "sm-audio-panel__section" });
  const musicState = {
    player: null,
    statusUnsubscribe: null,
    currentPlaylist: null
  };
  const musicControls = createPlayerPanel(musicSection, "Music", "music", musicState, callbacks);
  let availableAmbience = [];
  let availableMusic = [];
  const setPlaylists = (ambience, music) => {
    availableAmbience = ambience;
    availableMusic = music;
    ambienceControls.updatePlaylistDropdown(ambience);
    musicControls.updatePlaylistDropdown(music);
  };
  const setContext = (context) => {
    if (!context) {
      contextTags.empty();
      contextTags.createSpan({ text: "No context", cls: "sm-audio-panel__context-tag--empty" });
      return;
    }
    contextTags.empty();
    const addTag = (value, category) => {
      const tag = contextTags.createSpan({
        cls: `sm-audio-panel__context-tag sm-audio-panel__context-tag--${category}`,
        text: value
      });
      tag.title = category;
    };
    if (context.terrain) addTag(context.terrain, "terrain");
    if (context.weather) addTag(context.weather, "weather");
    if (context.timeOfDay) addTag(context.timeOfDay, "time");
    if (context.situation) addTag(context.situation, "situation");
    if (context.factions && context.factions.length > 0) {
      context.factions.forEach((f) => addTag(f, "faction"));
    }
    if (contextTags.childElementCount === 0) {
      contextTags.createSpan({ text: "No tags", cls: "sm-audio-panel__context-tag--empty" });
    }
  };
  const setAmbiencePlayer = (player) => {
    if (ambienceState.statusUnsubscribe) {
      ambienceState.statusUnsubscribe();
      ambienceState.statusUnsubscribe = null;
    }
    ambienceState.player = player;
    if (player) {
      ambienceState.statusUnsubscribe = player.onStatusChange((status) => {
        ambienceControls.updateStatus(status);
      });
      ambienceControls.updateStatus(player.getStatus());
    } else {
      ambienceControls.updateStatus(null);
    }
  };
  const setMusicPlayer = (player) => {
    if (musicState.statusUnsubscribe) {
      musicState.statusUnsubscribe();
      musicState.statusUnsubscribe = null;
    }
    musicState.player = player;
    if (player) {
      musicState.statusUnsubscribe = player.onStatusChange((status) => {
        musicControls.updateStatus(status);
      });
      musicControls.updateStatus(player.getStatus());
    } else {
      musicControls.updateStatus(null);
    }
  };
  const destroy = () => {
    if (ambienceState.statusUnsubscribe) ambienceState.statusUnsubscribe();
    if (musicState.statusUnsubscribe) musicState.statusUnsubscribe();
    ambienceControls.destroy();
    musicControls.destroy();
    root.remove();
  };
  return {
    root,
    setPlaylists,
    setContext,
    setAmbiencePlayer,
    setMusicPlayer,
    destroy
  };
}
function createPlayerPanel(host, label, type2, state, callbacks) {
  const section = host.createDiv({ cls: "sm-audio-player" });
  const sectionHeader = section.createDiv({ cls: "sm-audio-player__header" });
  sectionHeader.createEl("h4", { text: label, cls: "sm-audio-player__label" });
  const playlistRow = section.createDiv({ cls: "sm-audio-player__row" });
  playlistRow.createSpan({ text: "Playlist:", cls: "sm-audio-player__label-small" });
  const playlistSelect = playlistRow.createEl("select", {
    cls: "sm-audio-player__dropdown"
  });
  playlistSelect.createEl("option", { value: "", text: "\u2014 Select playlist \u2014" });
  playlistSelect.addEventListener("change", () => {
    const selectedId = playlistSelect.value;
    if (selectedId) {
      callbacks.onPlaylistSelect(selectedId, type2);
    }
  });
  const trackInfo = section.createDiv({ cls: "sm-audio-player__track-info" });
  const trackName = trackInfo.createDiv({ cls: "sm-audio-player__track-name", text: "\u2014" });
  const trackProgress = trackInfo.createDiv({ cls: "sm-audio-player__track-progress" });
  const progressBar = trackProgress.createDiv({ cls: "sm-audio-player__progress-bar" });
  const progressFill = progressBar.createDiv({ cls: "sm-audio-player__progress-fill" });
  const progressTime = trackProgress.createDiv({
    cls: "sm-audio-player__progress-time",
    text: "0:00 / 0:00"
  });
  const controls = section.createDiv({ cls: "sm-audio-player__controls" });
  const playBtn = controls.createEl("button", {
    cls: "sm-audio-player__button sm-audio-player__button--play",
    attr: { title: "Play" }
  });
  (0, import_obsidian43.setIcon)(playBtn, "play");
  applyMapButtonStyle(playBtn);
  playBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    if (state.player && !playBtn.disabled) {
      void state.player.play();
    }
  });
  const pauseBtn = controls.createEl("button", {
    cls: "sm-audio-player__button sm-audio-player__button--pause",
    attr: { title: "Pause" }
  });
  (0, import_obsidian43.setIcon)(pauseBtn, "pause");
  applyMapButtonStyle(pauseBtn);
  pauseBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    if (state.player && !pauseBtn.disabled) {
      state.player.pause();
    }
  });
  const prevBtn = controls.createEl("button", {
    cls: "sm-audio-player__button sm-audio-player__button--prev",
    attr: { title: "Previous" }
  });
  (0, import_obsidian43.setIcon)(prevBtn, "skip-back");
  applyMapButtonStyle(prevBtn);
  prevBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    if (state.player && !prevBtn.disabled) {
      void state.player.skipPrevious();
    }
  });
  const nextBtn = controls.createEl("button", {
    cls: "sm-audio-player__button sm-audio-player__button--next",
    attr: { title: "Next" }
  });
  (0, import_obsidian43.setIcon)(nextBtn, "skip-forward");
  applyMapButtonStyle(nextBtn);
  nextBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    if (state.player && !nextBtn.disabled) {
      void state.player.skipNext();
    }
  });
  const stopBtn = controls.createEl("button", {
    cls: "sm-audio-player__button sm-audio-player__button--stop",
    attr: { title: "Stop" }
  });
  (0, import_obsidian43.setIcon)(stopBtn, "square");
  applyMapButtonStyle(stopBtn);
  stopBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    if (state.player && !stopBtn.disabled) {
      state.player.stop();
    }
  });
  const volumeRow = section.createDiv({ cls: "sm-audio-player__row" });
  volumeRow.createSpan({ text: "Volume:", cls: "sm-audio-player__label-small" });
  const volumeInput = volumeRow.createEl("input", {
    type: "range",
    cls: "sm-audio-player__volume-slider",
    attr: { min: "0", max: "100", step: "1" }
  });
  volumeInput.value = "70";
  const volumeLabel = volumeRow.createSpan({
    text: "70%",
    cls: "sm-audio-player__volume-label"
  });
  volumeInput.addEventListener("input", () => {
    const volume = parseInt(volumeInput.value, 10) / 100;
    volumeLabel.setText(`${volumeInput.value}%`);
    if (state.player) {
      state.player.setGlobalVolume(volume);
    }
    callbacks.onVolumeChange(volume, type2);
  });
  const toggleRow = section.createDiv({ cls: "sm-audio-player__row" });
  const shuffleBtn = toggleRow.createEl("button", {
    cls: "sm-audio-player__toggle",
    text: "Shuffle"
  });
  applyMapButtonStyle(shuffleBtn);
  shuffleBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    if (state.player) {
      state.player.toggleShuffle();
    }
  });
  const loopBtn = toggleRow.createEl("button", {
    cls: "sm-audio-player__toggle",
    text: "Loop"
  });
  applyMapButtonStyle(loopBtn);
  loopBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    if (state.player) {
      state.player.toggleLoop();
    }
  });
  const updateStatus = (status) => {
    if (!status || !status.currentTrack) {
      trackName.setText("\u2014");
      progressTime.setText("0:00 / 0:00");
      progressFill.style.width = "0%";
      playBtn.disabled = true;
      pauseBtn.disabled = true;
      prevBtn.disabled = true;
      nextBtn.disabled = true;
      stopBtn.disabled = true;
      shuffleBtn.classList.remove("is-active");
      loopBtn.classList.remove("is-active");
      return;
    }
    trackName.setText(status.currentTrack.name || "Unknown Track");
    const position = status.position || 0;
    const duration = status.currentTrack.duration || 0;
    const percent = duration > 0 ? position / duration * 100 : 0;
    progressFill.style.width = `${percent}%`;
    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    };
    progressTime.setText(`${formatTime(position)} / ${formatTime(duration)}`);
    const isPlaying = status.state === "playing";
    const isStopped = status.state === "stopped" || status.state === "idle";
    const hasTrack = Boolean(status.currentTrack);
    playBtn.disabled = isPlaying || !hasTrack;
    pauseBtn.disabled = !isPlaying;
    prevBtn.disabled = isStopped || !hasTrack;
    nextBtn.disabled = isStopped || !hasTrack;
    stopBtn.disabled = isStopped;
    shuffleBtn.classList.toggle("is-active", status.shuffle);
    loopBtn.classList.toggle("is-active", status.loop);
    const vol = Math.round((status.globalVolume ?? 0.7) * 100);
    volumeInput.value = String(vol);
    volumeLabel.setText(`${vol}%`);
  };
  const updatePlaylistDropdown = (playlists) => {
    while (playlistSelect.options.length > 1) {
      playlistSelect.remove(1);
    }
    playlists.forEach((playlist) => {
      const option = playlistSelect.createEl("option", {
        value: playlist.name,
        text: playlist.display_name || playlist.name
      });
    });
  };
  const destroy = () => {
    section.remove();
  };
  updateStatus(null);
  return {
    updateStatus,
    updatePlaylistDropdown,
    destroy
  };
}
var import_obsidian43;
var init_audio_panel = __esm({
  "src/workmodes/session-runner/components/audio-panel.ts"() {
    "use strict";
    import_obsidian43 = require("obsidian");
    init_map_workflows();
  }
});

// src/workmodes/session-runner/components/audio-controller.ts
async function createAudioController(options) {
  const { app, host } = options;
  let ambiencePlayer = null;
  let musicPlayer = null;
  let availablePlaylists = [];
  let currentContext = null;
  let currentAmbiencePlaylist = null;
  let currentMusicPlaylist = null;
  let ambienceVolume = 0.7;
  let musicVolume = 0.7;
  let previousMusicPlaylist = null;
  let inCombat = false;
  const panel = createAudioPanel(host, {
    onPlaylistSelect: (playlistId, type2) => {
      const playlist = availablePlaylists.find((p) => p.name === playlistId);
      if (!playlist) {
        logger2.warn("[AudioController] Playlist not found", { playlistId });
        return;
      }
      void loadPlaylist(playlist, type2);
    },
    onVolumeChange: (volume, type2) => {
      if (type2 === "ambience") {
        ambienceVolume = volume;
      } else {
        musicVolume = volume;
      }
    }
  });
  ambiencePlayer = createAudioPlayer();
  musicPlayer = createAudioPlayer();
  ambiencePlayer.setGlobalVolume(ambienceVolume);
  musicPlayer.setGlobalVolume(musicVolume);
  panel.setAmbiencePlayer(ambiencePlayer);
  panel.setMusicPlayer(musicPlayer);
  await loadPlaylists();
  async function loadPlaylists() {
    try {
      const dataSource = LIBRARY_DATA_SOURCES.playlists;
      const files = await dataSource.list(app);
      const playlists = [];
      for (const file of files) {
        try {
          const fm2 = await readFrontmatter(app, file);
          const playlist = frontmatterToPlaylist(fm2);
          if (playlist) {
            playlists.push(playlist);
          }
        } catch (error) {
          logger2.error("[AudioController] Failed to load playlist", { file: file.path, error });
        }
      }
      availablePlaylists = playlists;
      const ambience = filterPlaylistsByType(playlists, "ambience");
      const music = filterPlaylistsByType(playlists, "music");
      panel.setPlaylists(ambience, music);
      logger2.info("[AudioController] Loaded playlists", {
        total: playlists.length,
        ambience: ambience.length,
        music: music.length
      });
    } catch (error) {
      logger2.error("[AudioController] Failed to load playlists", { error });
    }
  }
  function frontmatterToPlaylist(fm2) {
    const name = typeof fm2.name === "string" ? fm2.name : null;
    const type2 = typeof fm2.type === "string" && (fm2.type === "ambience" || fm2.type === "music") ? fm2.type : "ambience";
    const tracks = Array.isArray(fm2.tracks) ? fm2.tracks : [];
    if (!name) {
      return null;
    }
    const extractTokens = (raw) => {
      if (!Array.isArray(raw)) return [];
      return raw.map((entry) => {
        if (typeof entry === "string" && entry.trim()) {
          return { value: entry.trim() };
        }
        if (entry && typeof entry === "object") {
          const value = entry.value;
          if (typeof value === "string" && value.trim()) {
            return { value: value.trim() };
          }
        }
        return null;
      }).filter((v) => v !== null);
    };
    return {
      name,
      display_name: typeof fm2.display_name === "string" ? fm2.display_name : void 0,
      type: type2,
      description: typeof fm2.description === "string" ? fm2.description : void 0,
      terrain_tags: extractTokens(fm2.terrain_tags),
      weather_tags: extractTokens(fm2.weather_tags),
      time_of_day_tags: extractTokens(fm2.time_of_day_tags),
      faction_tags: extractTokens(fm2.faction_tags),
      situation_tags: extractTokens(fm2.situation_tags),
      shuffle: typeof fm2.shuffle === "boolean" ? fm2.shuffle : void 0,
      loop: typeof fm2.loop === "boolean" ? fm2.loop : void 0,
      crossfade_duration: typeof fm2.crossfade_duration === "number" ? fm2.crossfade_duration : void 0,
      default_volume: typeof fm2.default_volume === "number" ? fm2.default_volume : void 0,
      tracks
    };
  }
  async function loadPlaylist(playlist, type2) {
    try {
      const player = type2 === "ambience" ? ambiencePlayer : musicPlayer;
      if (!player) {
        logger2.warn("[AudioController] No player available", { type: type2 });
        return;
      }
      if (type2 === "ambience") {
        currentAmbiencePlaylist = playlist;
      } else {
        currentMusicPlaylist = playlist;
      }
      player.loadPlaylist(playlist);
      if (playlist.default_volume !== void 0) {
        player.setGlobalVolume(playlist.default_volume);
      }
      await player.play();
      logger2.info("[AudioController] Loaded playlist", {
        type: type2,
        playlist: playlist.name,
        tracks: playlist.tracks.length
      });
    } catch (error) {
      logger2.error("[AudioController] Failed to load playlist", { playlist: playlist.name, error });
    }
  }
  async function updateContext(file, coord) {
    try {
      if (!file || !coord) {
        currentContext = null;
        panel.setContext(null);
        return;
      }
      const context = await extractSessionContext(app, file, coord);
      currentContext = context;
      panel.setContext(context);
      await autoSelectPlaylists(context);
    } catch (error) {
      logger2.error("[AudioController] Failed to update context", { error });
    }
  }
  async function autoSelectPlaylists(context) {
    try {
      const ambiencePlaylists = filterPlaylistsByType(availablePlaylists, "ambience");
      const musicPlaylists = filterPlaylistsByType(availablePlaylists, "music");
      const ambienceResult = selectPlaylist(ambiencePlaylists, context);
      const musicResult = selectPlaylist(musicPlaylists, context);
      if (ambienceResult.playlist && ambienceResult.playlist.name !== currentAmbiencePlaylist?.name) {
        await loadPlaylist(ambienceResult.playlist, "ambience");
      }
      if (musicResult.playlist && musicResult.playlist.name !== currentMusicPlaylist?.name) {
        await loadPlaylist(musicResult.playlist, "music");
      }
      logger2.info("[AudioController] Auto-selected playlists", {
        ambience: ambienceResult.playlist?.name ?? "none",
        ambienceScore: ambienceResult.score,
        music: musicResult.playlist?.name ?? "none",
        musicScore: musicResult.score
      });
    } catch (error) {
      logger2.error("[AudioController] Auto-selection failed", { error });
    }
  }
  async function switchToCombatMusic() {
    if (inCombat) {
      logger2.debug("[AudioController] Already in combat, skipping music switch");
      return;
    }
    try {
      previousMusicPlaylist = currentMusicPlaylist;
      inCombat = true;
      const musicPlaylists = filterPlaylistsByType(availablePlaylists, "music");
      const combatContext = {
        ...currentContext,
        situation: ["combat"]
        // Override situation to combat
      };
      const combatResult = selectPlaylist(musicPlaylists, combatContext);
      if (combatResult.playlist) {
        await loadPlaylist(combatResult.playlist, "music");
        logger2.info("[AudioController] Switched to combat music", {
          playlist: combatResult.playlist.name,
          score: combatResult.score
        });
      } else {
        logger2.warn("[AudioController] No combat music found");
      }
    } catch (error) {
      logger2.error("[AudioController] Failed to switch to combat music", { error });
    }
  }
  async function restorePreviousMusic() {
    if (!inCombat) {
      logger2.debug("[AudioController] Not in combat, skipping restore");
      return;
    }
    try {
      inCombat = false;
      if (previousMusicPlaylist) {
        await loadPlaylist(previousMusicPlaylist, "music");
        logger2.info("[AudioController] Restored previous music", {
          playlist: previousMusicPlaylist.name
        });
      } else {
        if (currentContext) {
          const musicPlaylists = filterPlaylistsByType(availablePlaylists, "music");
          const musicResult = selectPlaylist(musicPlaylists, currentContext);
          if (musicResult.playlist) {
            await loadPlaylist(musicResult.playlist, "music");
            logger2.info("[AudioController] Auto-selected music after combat", {
              playlist: musicResult.playlist.name
            });
          }
        }
      }
      previousMusicPlaylist = null;
    } catch (error) {
      logger2.error("[AudioController] Failed to restore previous music", { error });
    }
  }
  function dispose() {
    try {
      if (ambiencePlayer) {
        ambiencePlayer.stop();
        ambiencePlayer.dispose();
        ambiencePlayer = null;
      }
      if (musicPlayer) {
        musicPlayer.stop();
        musicPlayer.dispose();
        musicPlayer = null;
      }
      panel.destroy();
      logger2.info("[AudioController] Disposed");
    } catch (error) {
      logger2.error("[AudioController] Disposal failed", { error });
    }
  }
  return {
    panel,
    updateContext,
    switchToCombatMusic,
    restorePreviousMusic,
    dispose
  };
}
var init_audio_controller = __esm({
  "src/workmodes/session-runner/components/audio-controller.ts"() {
    "use strict";
    init_audio_player();
    init_audio();
    init_data_sources();
    init_frontmatter_utils();
    init_plugin_logger();
    init_audio_panel();
  }
});

// src/features/encounters/types.ts
var CR_TO_XP, XP_THRESHOLDS_BY_LEVEL, ENCOUNTER_MULTIPLIERS;
var init_types7 = __esm({
  "src/features/encounters/types.ts"() {
    "use strict";
    CR_TO_XP = {
      0: 10,
      0.125: 25,
      0.25: 50,
      0.5: 100,
      1: 200,
      2: 450,
      3: 700,
      4: 1100,
      5: 1800,
      6: 2300,
      7: 2900,
      8: 3900,
      9: 5e3,
      10: 5900,
      11: 7200,
      12: 8400,
      13: 1e4,
      14: 11500,
      15: 13e3,
      16: 15e3,
      17: 18e3,
      18: 2e4,
      19: 22e3,
      20: 25e3,
      21: 33e3,
      22: 41e3,
      23: 5e4,
      24: 62e3,
      25: 75e3,
      26: 9e4,
      27: 105e3,
      28: 12e4,
      29: 135e3,
      30: 155e3
    };
    XP_THRESHOLDS_BY_LEVEL = {
      1: { easy: 25, medium: 50, hard: 75, deadly: 100 },
      2: { easy: 50, medium: 100, hard: 150, deadly: 200 },
      3: { easy: 75, medium: 150, hard: 225, deadly: 400 },
      4: { easy: 125, medium: 250, hard: 375, deadly: 500 },
      5: { easy: 250, medium: 500, hard: 750, deadly: 1100 },
      6: { easy: 300, medium: 600, hard: 900, deadly: 1400 },
      7: { easy: 350, medium: 750, hard: 1100, deadly: 1700 },
      8: { easy: 450, medium: 900, hard: 1400, deadly: 2100 },
      9: { easy: 550, medium: 1100, hard: 1600, deadly: 2400 },
      10: { easy: 600, medium: 1200, hard: 1900, deadly: 2800 },
      11: { easy: 800, medium: 1600, hard: 2400, deadly: 3600 },
      12: { easy: 1e3, medium: 2e3, hard: 3e3, deadly: 4500 },
      13: { easy: 1100, medium: 2200, hard: 3400, deadly: 5100 },
      14: { easy: 1250, medium: 2500, hard: 3800, deadly: 5700 },
      15: { easy: 1400, medium: 2800, hard: 4300, deadly: 6400 },
      16: { easy: 1600, medium: 3200, hard: 4800, deadly: 7200 },
      17: { easy: 2e3, medium: 3900, hard: 5900, deadly: 8800 },
      18: { easy: 2100, medium: 4200, hard: 6300, deadly: 9500 },
      19: { easy: 2400, medium: 4900, hard: 7300, deadly: 10900 },
      20: { easy: 2800, medium: 5700, hard: 8500, deadly: 12700 }
    };
    ENCOUNTER_MULTIPLIERS = [
      { minMonsters: 1, multiplier: 1 },
      { minMonsters: 2, multiplier: 1.5 },
      { minMonsters: 3, multiplier: 2 },
      { minMonsters: 7, multiplier: 2.5 },
      { minMonsters: 11, multiplier: 3 },
      { minMonsters: 15, multiplier: 4 }
    ];
  }
});

// src/features/factions/faction-simulation.ts
var init_faction_simulation = __esm({
  "src/features/factions/faction-simulation.ts"() {
    "use strict";
    init_plugin_logger();
  }
});

// src/features/factions/faction-integration.ts
async function getFactionMembersAtHex(app, hexCoord) {
  const results = [];
  try {
    const factions = await loadAllFactions(app);
    for (const faction of factions) {
      const membersAtHex = (faction.members || []).filter((member) => {
        if (!member.position || member.position.type !== "hex") return false;
        const pos = member.position.coords;
        if (!pos) return false;
        return pos.q === hexCoord.q && pos.r === hexCoord.r && pos.s === hexCoord.s;
      });
      if (membersAtHex.length > 0) {
        results.push({ faction, members: membersAtHex });
      }
    }
  } catch (error) {
    logger2.error("[faction-integration] Error loading faction members at hex", {
      hexCoord,
      error: error.message
    });
  }
  return results;
}
async function loadAllFactions(app) {
  const factions = [];
  try {
    const files = app.vault.getMarkdownFiles();
    const factionFiles = files.filter(
      (f) => f.path.startsWith("SaltMarcher/Factions/") && !f.path.includes("Presets")
    );
    for (const file of factionFiles) {
      try {
        const content = await app.vault.read(file);
        const fmMatch = content.match(/^---\n([\s\S]*?)\n---/);
        if (!fmMatch) continue;
        const fm2 = fmMatch[1];
        if (!fm2.includes("smType: faction")) continue;
        const parsed = load(fm2);
        if (!parsed || typeof parsed !== "object") continue;
        if (!parsed.name || typeof parsed.name !== "string") {
          logger2.warn("[faction-integration] Faction missing name field", {
            file: file.path
          });
          continue;
        }
        const faction = {
          name: parsed.name,
          motto: parsed.motto,
          headquarters: parsed.headquarters,
          territory: parsed.territory,
          influence_tags: parsed.influence_tags,
          culture_tags: parsed.culture_tags,
          goal_tags: parsed.goal_tags,
          summary: parsed.summary,
          resources: parsed.resources,
          faction_relationships: parsed.faction_relationships,
          members: parsed.members
        };
        factions.push(faction);
      } catch (error) {
        logger2.warn("[faction-integration] Error loading faction file", {
          file: file.path,
          error: error.message
        });
      }
    }
    try {
      logger2.debug("[faction-integration] Loaded factions", {
        count: factions.length,
        factions: factions.map((f) => f.name)
      });
    } catch {
    }
  } catch (error) {
    logger2.error("[faction-integration] Error loading factions", {
      error: error.message
    });
  }
  return factions;
}
var init_faction_integration = __esm({
  "src/features/factions/faction-integration.ts"() {
    "use strict";
    init_js_yaml();
    init_faction_simulation();
    init_serializer8();
    init_plugin_logger();
    init_hex_geom();
  }
});

// src/features/encounters/encounter-generator.ts
async function generateEncounter(app, tables, context) {
  const warnings = [];
  const selectedTable = selectEncounterTable(tables, context, warnings);
  if (!selectedTable) {
    throw new Error("No matching encounter table found");
  }
  const selectedEntry = rollOnTable(selectedTable);
  if (!selectedEntry) {
    throw new Error("No encounter entry selected (empty table)");
  }
  const creatures = await loadCreaturesFromLibrary(app, selectedEntry.creatures, warnings);
  if (creatures.length === 0) {
    throw new Error("No creatures could be loaded from Library");
  }
  const quantity = rollQuantity(selectedEntry.quantity || "1");
  const combatants = spawnCombatants(creatures, quantity, context, warnings);
  if (context.hexCoords) {
    const factionCombatants = await loadFactionMembersAtHex(app, context.hexCoords, warnings);
    combatants.push(...factionCombatants);
  }
  const { totalXp, adjustedXp, difficulty } = calculateEncounterDifficulty(
    combatants,
    context
  );
  combatants.sort((a, b) => b.initiative - a.initiative);
  const title = selectedEntry.description || `Random Encounter: ${selectedEntry.creatures.join(", ")}`;
  return {
    title,
    combatants,
    totalXp,
    adjustedXp,
    difficulty,
    warnings: warnings.length > 0 ? warnings : void 0,
    sourceTable: selectedTable.name,
    sourceEntry: selectedEntry
  };
}
function selectEncounterTable(tables, context, warnings) {
  if (tables.length === 0) {
    warnings.push("No encounter tables available");
    return null;
  }
  const crFiltered = tables.filter((table) => {
    if (!table.crRange && !context.crRange) return true;
    const tableMin = table.crRange?.min ?? 0;
    const tableMax = table.crRange?.max ?? 30;
    const contextMin = context.crRange?.min ?? 0;
    const contextMax = context.crRange?.max ?? 30;
    return !(tableMax < contextMin || tableMin > contextMax);
  });
  if (crFiltered.length === 0) {
    warnings.push("No encounter tables match CR range");
    return tables[0];
  }
  if (!context.sessionContext) {
    return crFiltered[Math.floor(Math.random() * crFiltered.length)];
  }
  const scored = crFiltered.map((table) => ({
    table,
    score: calculatePlaylistScore(table, context.sessionContext).score
  }));
  scored.sort((a, b) => b.score - a.score);
  return scored[0].table;
}
function rollOnTable(table) {
  if (table.entries.length === 0) return null;
  const totalWeight = table.entries.reduce((sum, entry) => sum + (entry.weight || 1), 0);
  let roll = Math.random() * totalWeight;
  for (const entry of table.entries) {
    const weight = entry.weight || 1;
    if (roll < weight) {
      return entry;
    }
    roll -= weight;
  }
  return table.entries[table.entries.length - 1];
}
async function loadCreaturesFromLibrary(app, creatureNames, warnings) {
  const creatures = [];
  for (const name of creatureNames) {
    try {
      const files = app.vault.getMarkdownFiles();
      const creatureFile = files.find(
        (f) => f.basename.toLowerCase() === name.toLowerCase() && f.path.includes("Creatures")
      );
      if (!creatureFile) {
        warnings.push(`Creature "${name}" not found in Library`);
        continue;
      }
      const content = await app.vault.read(creatureFile);
      const fmMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if (!fmMatch) {
        warnings.push(`Creature "${name}" has no frontmatter`);
        continue;
      }
      const fm2 = fmMatch[1];
      const crMatch = fm2.match(/cr:\s*(.+)/);
      const hpMatch = fm2.match(/hp:\s*'(.+)'/);
      const acMatch = fm2.match(/ac:\s*'(.+)'/);
      if (!crMatch || !hpMatch || !acMatch) {
        warnings.push(`Creature "${name}" missing cr, hp, or ac fields`);
        continue;
      }
      const cr = parseCR(crMatch[1].trim());
      creatures.push({
        name,
        cr,
        hp: hpMatch[1],
        ac: acMatch[1],
        file: creatureFile.path
      });
    } catch (error) {
      warnings.push(`Error loading creature "${name}": ${error.message}`);
    }
  }
  return creatures;
}
function rollQuantity(formula) {
  const trimmed = formula.trim();
  if (/^\d+$/.test(trimmed)) {
    return parseInt(trimmed, 10);
  }
  const match = trimmed.match(/^(\d+)d(\d+)([+-]\d+)?$/);
  if (!match) {
    return 1;
  }
  const count = parseInt(match[1], 10);
  const sides = parseInt(match[2], 10);
  const bonus = match[3] ? parseInt(match[3], 10) : 0;
  let total = bonus;
  for (let i = 0; i < count; i++) {
    total += Math.floor(Math.random() * sides) + 1;
  }
  return Math.max(1, total);
}
function spawnCombatants(creatures, quantity, context, warnings) {
  const combatants = [];
  const crMin = context.crRange?.min ?? 0;
  const crMax = context.crRange?.max ?? 30;
  const validCreatures = creatures.filter((c) => c.cr >= crMin && c.cr <= crMax);
  if (validCreatures.length === 0) {
    warnings.push("No creatures match CR range, using all available creatures");
    validCreatures.push(...creatures);
  }
  for (let i = 0; i < quantity; i++) {
    const creature = validCreatures[Math.floor(Math.random() * validCreatures.length)];
    const maxHp = parseInt(creature.hp, 10) || 10;
    const ac = parseInt(creature.ac, 10) || 10;
    const initiative = Math.floor(Math.random() * 20) + 1;
    combatants.push({
      name: creature.name,
      cr: creature.cr,
      initiative,
      currentHp: maxHp,
      maxHp,
      ac,
      creatureFile: creature.file,
      id: `${creature.name}-${Date.now()}-${i}`
    });
  }
  return combatants;
}
function calculateEncounterDifficulty(combatants, context) {
  const totalXp = combatants.reduce((sum, c) => sum + (CR_TO_XP[c.cr] || 0), 0);
  const multiplier = getEncounterMultiplier(combatants.length);
  const adjustedXp = totalXp * multiplier;
  const level = Math.max(1, Math.min(20, Math.floor(context.partyLevel)));
  const thresholds = XP_THRESHOLDS_BY_LEVEL[level];
  const partyXp = {
    easy: thresholds.easy * context.partySize,
    medium: thresholds.medium * context.partySize,
    hard: thresholds.hard * context.partySize,
    deadly: thresholds.deadly * context.partySize
  };
  let difficulty;
  if (adjustedXp < partyXp.easy) {
    difficulty = "trivial";
  } else if (adjustedXp < partyXp.medium) {
    difficulty = "easy";
  } else if (adjustedXp < partyXp.hard) {
    difficulty = "medium";
  } else if (adjustedXp < partyXp.deadly) {
    difficulty = "hard";
  } else {
    difficulty = "deadly";
  }
  return { totalXp, adjustedXp, difficulty };
}
function getEncounterMultiplier(monsterCount) {
  for (let i = ENCOUNTER_MULTIPLIERS.length - 1; i >= 0; i--) {
    if (monsterCount >= ENCOUNTER_MULTIPLIERS[i].minMonsters) {
      return ENCOUNTER_MULTIPLIERS[i].multiplier;
    }
  }
  return 1;
}
async function loadFactionMembersAtHex(app, hexCoords, warnings) {
  const combatants = [];
  try {
    const factionMembers = await getFactionMembersAtHex(app, hexCoords);
    for (const { faction, members } of factionMembers) {
      for (const member of members) {
        if (!member.statblock_ref) {
          warnings.push(`Faction member "${member.name}" from ${faction.name} has no statblock reference`);
          continue;
        }
        const creatureData = await loadCreaturesFromLibrary(app, [member.statblock_ref], warnings);
        if (creatureData.length === 0) {
          continue;
        }
        const creature = creatureData[0];
        const quantity = member.quantity || 1;
        for (let i = 0; i < quantity; i++) {
          const maxHp = parseInt(creature.hp, 10) || 10;
          const ac = parseInt(creature.ac, 10) || 10;
          const initiative = Math.floor(Math.random() * 20) + 1;
          combatants.push({
            name: member.is_named ? member.name : `${member.name} ${i + 1}`,
            cr: creature.cr,
            initiative,
            currentHp: maxHp,
            maxHp,
            ac,
            creatureFile: creature.file,
            id: `faction_${faction.name}_${member.name}_${Date.now()}_${i}`
          });
        }
      }
    }
  } catch (error) {
    warnings.push(`Failed to load faction members at hex: ${error.message}`);
  }
  return combatants;
}
var init_encounter_generator = __esm({
  "src/features/encounters/encounter-generator.ts"() {
    "use strict";
    init_types7();
    init_auto_selection();
    init_serializer11();
    init_faction_integration();
  }
});

// src/workmodes/session-runner/components/initiative-tracker.ts
function createInitiativeTracker(host, callbacks) {
  const root = host.createDiv({ cls: "sm-initiative-tracker" });
  const header = root.createDiv({ cls: "sm-initiative-tracker__header" });
  header.createEl("h3", { text: "Initiative", cls: "sm-initiative-tracker__title" });
  const nextTurnBtn = header.createEl("button", {
    cls: "sm-initiative-tracker__next-turn",
    text: "Next Turn"
  });
  nextTurnBtn.addEventListener("click", () => callbacks.onAdvanceTurn());
  const listContainer = root.createDiv({ cls: "sm-initiative-tracker__list" });
  let combatants = [];
  let activeTurnId = null;
  const setCombatants = (newCombatants) => {
    combatants = [...newCombatants];
    renderCombatants();
  };
  const setActiveTurn = (combatantId) => {
    activeTurnId = combatantId;
    renderCombatants();
  };
  const renderCombatants = () => {
    listContainer.empty();
    if (combatants.length === 0) {
      listContainer.createDiv({
        cls: "sm-initiative-tracker__empty",
        text: "No combatants"
      });
      return;
    }
    for (const combatant of combatants) {
      const item = listContainer.createDiv({
        cls: [
          "sm-initiative-tracker__item",
          activeTurnId === combatant.id ? "sm-initiative-tracker__item--active" : "",
          combatant.currentHp <= 0 ? "sm-initiative-tracker__item--defeated" : ""
        ].join(" ")
      });
      item.createDiv({
        cls: "sm-initiative-tracker__initiative",
        text: combatant.initiative.toString()
      });
      const info = item.createDiv({ cls: "sm-initiative-tracker__info" });
      info.createDiv({
        cls: "sm-initiative-tracker__name",
        text: combatant.name
      });
      const stats = info.createDiv({ cls: "sm-initiative-tracker__stats" });
      const hpContainer = stats.createDiv({ cls: "sm-initiative-tracker__hp-container" });
      const hpBar = hpContainer.createDiv({ cls: "sm-initiative-tracker__hp-bar" });
      const hpFill = hpBar.createDiv({ cls: "sm-initiative-tracker__hp-fill" });
      const hpPercent = combatant.maxHp > 0 ? combatant.currentHp / combatant.maxHp * 100 : 0;
      hpFill.style.width = `${Math.max(0, Math.min(100, hpPercent))}%`;
      const hpText = hpContainer.createDiv({
        cls: "sm-initiative-tracker__hp-text",
        text: `${combatant.currentHp}/${combatant.maxHp} HP`
      });
      hpText.addEventListener("click", () => {
        const newHp = prompt(`Enter new HP for ${combatant.name}:`, combatant.currentHp.toString());
        if (newHp !== null) {
          const parsed = parseInt(newHp, 10);
          if (!isNaN(parsed)) {
            callbacks.onHpChange(combatant.id, parsed);
          }
        }
      });
      stats.createDiv({
        cls: "sm-initiative-tracker__ac",
        text: `AC ${combatant.ac}`
      });
      const removeBtn = item.createDiv({ cls: "sm-initiative-tracker__remove" });
      (0, import_obsidian44.setIcon)(removeBtn, "x");
      removeBtn.addEventListener("click", () => {
        if (confirm(`Remove ${combatant.name} from encounter?`)) {
          callbacks.onRemoveCombatant(combatant.id);
        }
      });
    }
  };
  const destroy = () => {
    root.remove();
  };
  return {
    root,
    setCombatants,
    setActiveTurn,
    destroy
  };
}
var import_obsidian44;
var init_initiative_tracker = __esm({
  "src/workmodes/session-runner/components/initiative-tracker.ts"() {
    "use strict";
    import_obsidian44 = require("obsidian");
  }
});

// src/workmodes/session-runner/components/encounter-controller.ts
async function createEncounterController(options) {
  const { app, host, onLootRequested, onCombatStart, onCombatEnd } = options;
  const trackerHost = host.createDiv({ cls: "sm-encounter-controller" });
  let initiativeTracker = null;
  let currentEncounter = null;
  let encounterTables = [];
  let combatants = [];
  let activeTurnIndex = -1;
  await loadEncounterTables();
  async function loadEncounterTables() {
    try {
      const dataSource = LIBRARY_DATA_SOURCES["encounter-tables"];
      const files = await dataSource.list(app);
      const tables = [];
      for (const file of files) {
        try {
          const entry = await dataSource.load(app, file);
          if (entry) {
            tables.push(entry);
          }
        } catch (err) {
          logger2.warn("[EncounterController] Failed to load encounter table", { file: file.path, err });
        }
      }
      encounterTables = tables;
      logger2.info("[EncounterController] Loaded encounter tables", { count: tables.length });
    } catch (err) {
      logger2.error("[EncounterController] Failed to load encounter tables", err);
      new import_obsidian45.Notice("Failed to load encounter tables");
    }
  }
  async function generateRandomEncounter2(context) {
    if (encounterTables.length === 0) {
      new import_obsidian45.Notice("No encounter tables available. Create some in the Library!");
      logger2.warn("[EncounterController] Cannot generate encounter: no tables loaded");
      return;
    }
    try {
      logger2.info("[EncounterController] Generating encounter", { context });
      const encounter = await generateEncounter(app, encounterTables, context);
      logger2.info("[EncounterController] Encounter generated", {
        tableName: encounter.tableName,
        combatantCount: encounter.combatants.length,
        difficulty: encounter.difficulty,
        totalXP: encounter.totalXP,
        adjustedXP: encounter.adjustedXP
      });
      currentEncounter = encounter;
      combatants = [...encounter.combatants];
      activeTurnIndex = 0;
      if (encounter.warnings.length > 0) {
        logger2.warn("[EncounterController] Encounter generation warnings", { warnings: encounter.warnings });
        new import_obsidian45.Notice(`Encounter generated with warnings: ${encounter.warnings.join(", ")}`);
      } else {
        new import_obsidian45.Notice(`${encounter.difficulty.toUpperCase()} encounter: ${encounter.combatants.length} combatants (${encounter.adjustedXP} XP)`);
      }
      renderInitiativeTracker();
      if (onCombatStart) {
        onCombatStart();
      }
    } catch (err) {
      logger2.error("[EncounterController] Failed to generate encounter", err);
      new import_obsidian45.Notice("Failed to generate encounter. Check console for details.");
    }
  }
  function renderInitiativeTracker() {
    if (initiativeTracker) {
      initiativeTracker.destroy();
      initiativeTracker = null;
    }
    const callbacks = {
      onHpChange: handleHpChange,
      onRemoveCombatant: handleRemoveCombatant,
      onAdvanceTurn: handleAdvanceTurn
    };
    initiativeTracker = createInitiativeTracker(trackerHost, callbacks);
    initiativeTracker.setCombatants(combatants);
    if (activeTurnIndex >= 0 && activeTurnIndex < combatants.length) {
      initiativeTracker.setActiveTurn(combatants[activeTurnIndex].id);
    }
  }
  function handleHpChange(combatantId, newHp) {
    const combatant = combatants.find((c) => c.id === combatantId);
    if (!combatant) {
      logger2.warn("[EncounterController] Combatant not found for HP change", { combatantId });
      return;
    }
    combatant.currentHp = Math.max(0, newHp);
    logger2.debug("[EncounterController] HP updated", { combatantId, newHp: combatant.currentHp });
    if (initiativeTracker) {
      initiativeTracker.setCombatants(combatants);
      if (activeTurnIndex >= 0 && activeTurnIndex < combatants.length) {
        initiativeTracker.setActiveTurn(combatants[activeTurnIndex].id);
      }
    }
    checkCombatEnd();
  }
  function handleRemoveCombatant(combatantId) {
    const index = combatants.findIndex((c) => c.id === combatantId);
    if (index === -1) {
      logger2.warn("[EncounterController] Combatant not found for removal", { combatantId });
      return;
    }
    logger2.debug("[EncounterController] Removing combatant", { combatantId });
    combatants.splice(index, 1);
    if (activeTurnIndex >= combatants.length) {
      activeTurnIndex = 0;
    }
    if (initiativeTracker) {
      initiativeTracker.setCombatants(combatants);
      if (activeTurnIndex >= 0 && activeTurnIndex < combatants.length) {
        initiativeTracker.setActiveTurn(combatants[activeTurnIndex].id);
      }
    }
    checkCombatEnd();
  }
  function handleAdvanceTurn() {
    if (combatants.length === 0) return;
    activeTurnIndex = (activeTurnIndex + 1) % combatants.length;
    logger2.debug("[EncounterController] Advanced turn", {
      activeTurnIndex,
      combatantId: combatants[activeTurnIndex]?.id
    });
    if (initiativeTracker) {
      initiativeTracker.setActiveTurn(combatants[activeTurnIndex].id);
    }
  }
  function checkCombatEnd() {
    const allDefeated = combatants.every((c) => c.currentHp <= 0);
    if (allDefeated && combatants.length > 0) {
      logger2.info("[EncounterController] Combat ended - all combatants defeated");
      new import_obsidian45.Notice("Combat ended! All enemies defeated.");
      if (currentEncounter && onLootRequested) {
        void onLootRequested(currentEncounter);
      }
      if (onCombatEnd) {
        onCombatEnd();
      }
    }
  }
  function clearEncounter() {
    if (initiativeTracker) {
      initiativeTracker.destroy();
      initiativeTracker = null;
    }
    currentEncounter = null;
    combatants = [];
    activeTurnIndex = -1;
    logger2.debug("[EncounterController] Encounter cleared");
  }
  function dispose() {
    clearEncounter();
    trackerHost.remove();
    logger2.debug("[EncounterController] Disposed");
  }
  return {
    trackerHost,
    generateRandomEncounter: generateRandomEncounter2,
    clearEncounter,
    dispose
  };
}
var import_obsidian45;
var init_encounter_controller = __esm({
  "src/workmodes/session-runner/components/encounter-controller.ts"() {
    "use strict";
    import_obsidian45 = require("obsidian");
    init_plugin_logger();
    init_encounter_generator();
    init_data_sources();
    init_initiative_tracker();
  }
});

// src/workmodes/session-runner/util/encounter-context-builder.ts
async function buildEncounterContext(app, mapFile, state, partyLevel = 1, partySize = 4) {
  const currentCoord = state.currentTile ?? state.tokenRC ?? null;
  logger2.debug("[EncounterContextBuilder] Building context", {
    mapFile: mapFile?.path,
    currentCoord,
    partyLevel,
    partySize
  });
  let terrainTags = [];
  let factionTags = [];
  if (mapFile && currentCoord) {
    try {
      const tileData = await loadTile(app, mapFile, currentCoord);
      if (tileData) {
        if (tileData.terrain) {
          const terrainTag = tileData.terrain.toLowerCase().trim();
          if (terrainTag) {
            terrainTags.push(terrainTag);
          }
        }
        if (tileData.faction) {
          const factionTag = tileData.faction.toLowerCase().trim();
          if (factionTag) {
            factionTags.push(factionTag);
          }
        }
        logger2.debug("[EncounterContextBuilder] Extracted hex data", {
          terrain: tileData.terrain,
          faction: tileData.faction,
          region: tileData.region
        });
      }
    } catch (err) {
      logger2.warn("[EncounterContextBuilder] Failed to load tile data", { err });
    }
  }
  if (terrainTags.length === 0) {
    terrainTags = ["any"];
  }
  let hexCoords;
  if (currentCoord && mapFile) {
    try {
      hexCoords = axialToCube(oddrToAxial({ r: currentCoord.r, c: currentCoord.c }));
      logger2.debug("[EncounterContextBuilder] Converted hex coordinates", {
        oddr: currentCoord,
        cube: hexCoords
      });
    } catch (err) {
      logger2.warn("[EncounterContextBuilder] Failed to convert hex coordinates", { err });
    }
  }
  let weatherTags = ["clear"];
  if (hexCoords && mapFile) {
    try {
      const weatherState = weatherStore.getWeather(
        mapFile.path,
        hexCoords.q,
        hexCoords.r,
        hexCoords.s
      );
      if (weatherState) {
        weatherTags = mapWeatherTypeToTags(weatherState.currentWeather.type);
        logger2.debug("[EncounterContextBuilder] Extracted weather from store", {
          weatherType: weatherState.currentWeather.type,
          tags: weatherTags,
          temperature: weatherState.temperature,
          severity: weatherState.currentWeather.severity
        });
      } else {
        logger2.debug("[EncounterContextBuilder] No weather data for hex, using default", {
          hexCoords
        });
      }
    } catch (err) {
      logger2.warn("[EncounterContextBuilder] Failed to extract weather from store", { err });
    }
  }
  const timeTags = ["day"];
  const situationTags = ["wandering"];
  logger2.debug("[EncounterContextBuilder] Context built", {
    tags: { terrain: terrainTags, weather: weatherTags, time: timeTags, faction: factionTags, situation: situationTags },
    hexCoords
  });
  return {
    partyLevel,
    partySize,
    tags: {
      terrain: terrainTags,
      weather: weatherTags,
      time: timeTags,
      faction: factionTags,
      situation: situationTags
    },
    hexCoords
  };
}
var init_encounter_context_builder = __esm({
  "src/workmodes/session-runner/util/encounter-context-builder.ts"() {
    "use strict";
    init_plugin_logger();
    init_tile_repository();
    init_weather_store();
    init_weather_tag_mapper();
    init_hex_geom();
  }
});

// src/features/loot/item-generator.ts
function generateItems(context, config, itemBudget, lootTables) {
  if (!config.enableMagicItems || itemBudget <= 0) {
    return [];
  }
  const items = [];
  const { partyLevel, tags = [], excludeTags = [] } = context;
  const maxItems = config.maxMagicItemsPerEncounter ?? 3;
  const availableEntries = filterLootEntries(lootTables, tags, excludeTags, partyLevel, config);
  if (availableEntries.length === 0) {
    return [];
  }
  let remainingBudget = itemBudget;
  let attempts = 0;
  const maxAttempts = maxItems * 3;
  while (items.length < maxItems && remainingBudget > 0 && attempts < maxAttempts) {
    attempts++;
    const entry = selectWeightedRandom(availableEntries);
    if (!entry) {
      break;
    }
    const quantity = rollQuantity2(entry.quantityRange);
    const item = {
      type: entry.item.type,
      name: entry.item.name,
      quantity,
      value: entry.item.value,
      rarity: entry.item.rarity,
      description: entry.item.description,
      tags: entry.item.tags
    };
    items.push(item);
    if (entry.item.value) {
      remainingBudget -= entry.item.value * quantity;
    }
  }
  return items;
}
function filterLootEntries(lootTables, tags, excludeTags, partyLevel, config) {
  const rarityLimits = config.rarityLevelLimits ?? DEFAULT_RARITY_LIMITS;
  const filtered = [];
  for (const table of lootTables) {
    if (tags.length > 0 && table.tags && table.tags.length > 0) {
      const hasMatchingTag = table.tags.some((tag) => tags.includes(tag));
      if (!hasMatchingTag) {
        continue;
      }
    }
    for (const entry of table.entries) {
      if (entry.item.rarity) {
        const minLevel = rarityLimits[entry.item.rarity];
        if (partyLevel < minLevel) {
          continue;
        }
      }
      if (entry.item.tags && excludeTags.length > 0) {
        const hasExcludedTag = entry.item.tags.some((tag) => excludeTags.includes(tag));
        if (hasExcludedTag) {
          continue;
        }
      }
      filtered.push(entry);
    }
  }
  return filtered;
}
function selectWeightedRandom(entries) {
  if (entries.length === 0) {
    return null;
  }
  const totalWeight = entries.reduce((sum, entry) => sum + entry.weight, 0);
  if (totalWeight <= 0) {
    return null;
  }
  const roll = Math.random() * totalWeight;
  let accumulator = 0;
  for (const entry of entries) {
    accumulator += entry.weight;
    if (roll < accumulator) {
      return entry;
    }
  }
  return entries[entries.length - 1] ?? null;
}
function rollQuantity2(range) {
  if (range.max <= range.min) {
    return range.min;
  }
  return Math.floor(range.min + Math.random() * (range.max - range.min + 1));
}
function calculateItemValue(items) {
  return items.reduce((total, item) => {
    return total + (item.value ?? 0) * item.quantity;
  }, 0);
}
var DEFAULT_RARITY_LIMITS, EXAMPLE_LOOT_TABLES;
var init_item_generator = __esm({
  "src/features/loot/item-generator.ts"() {
    "use strict";
    DEFAULT_RARITY_LIMITS = {
      common: 1,
      uncommon: 1,
      rare: 5,
      "very-rare": 11,
      legendary: 17,
      artifact: 20
    };
    EXAMPLE_LOOT_TABLES = [
      {
        id: "potions-common",
        name: "Common Potions",
        category: "consumables",
        entries: [
          {
            weight: 10,
            item: {
              type: "consumable",
              name: "Potion of Healing",
              value: 50,
              rarity: "common",
              description: "Heals 2d4+2 HP",
              tags: ["healing", "potion"]
            },
            quantityRange: { min: 1, max: 3 }
          },
          {
            weight: 5,
            item: {
              type: "consumable",
              name: "Potion of Climbing",
              value: 50,
              rarity: "common",
              description: "Gain climbing speed for 1 hour",
              tags: ["potion", "utility"]
            },
            quantityRange: { min: 1, max: 1 }
          }
        ],
        tags: ["dungeon", "forest", "mountain"]
      },
      {
        id: "scrolls-uncommon",
        name: "Uncommon Scrolls",
        category: "consumables",
        entries: [
          {
            weight: 8,
            item: {
              type: "consumable",
              name: "Spell Scroll (Level 1)",
              value: 100,
              rarity: "common",
              description: "Contains a 1st-level spell",
              tags: ["scroll", "magic"]
            },
            quantityRange: { min: 1, max: 2 }
          },
          {
            weight: 4,
            item: {
              type: "consumable",
              name: "Spell Scroll (Level 2)",
              value: 200,
              rarity: "uncommon",
              description: "Contains a 2nd-level spell",
              tags: ["scroll", "magic"]
            },
            quantityRange: { min: 1, max: 1 }
          }
        ],
        tags: ["wizard", "library", "temple"]
      },
      {
        id: "gems-trade",
        name: "Precious Gems",
        category: "trade-goods",
        entries: [
          {
            weight: 20,
            item: {
              type: "trade-good",
              name: "Small Gem",
              value: 10,
              description: "Small semi-precious stone",
              tags: ["gem", "trade"]
            },
            quantityRange: { min: 1, max: 5 }
          },
          {
            weight: 10,
            item: {
              type: "trade-good",
              name: "Large Gem",
              value: 50,
              description: "Large precious stone",
              tags: ["gem", "trade"]
            },
            quantityRange: { min: 1, max: 3 }
          },
          {
            weight: 5,
            item: {
              type: "trade-good",
              name: "Rare Gem",
              value: 100,
              description: "Rare and valuable gemstone",
              tags: ["gem", "trade", "valuable"]
            },
            quantityRange: { min: 1, max: 2 }
          }
        ],
        tags: ["dragon", "treasure", "noble"]
      }
    ];
  }
});

// src/features/loot/loot-generator.ts
var loot_generator_exports = {};
__export(loot_generator_exports, {
  formatGold: () => formatGold,
  formatLootSummary: () => formatLootSummary,
  generateLoot: () => generateLoot
});
function generateLoot(context, config = {}, rules = [], lootTables = EXAMPLE_LOOT_TABLES) {
  const warnings = [];
  const goldResult = calculateGold(context, rules, warnings);
  const itemBudget = calculateItemBudget(context, config);
  const items = generateItems(context, config, itemBudget, lootTables);
  const itemValue = calculateItemValue(items);
  const tradeGoodsValue = items.filter((item) => item.type === "trade-good").reduce((sum, item) => sum + (item.value ?? 0) * item.quantity, 0);
  const magicItemValue = items.filter((item) => item.type === "magic-item").reduce((sum, item) => sum + (item.value ?? 0) * item.quantity, 0);
  const bundle = {
    gold: Math.round(goldResult.finalGold),
    items: Object.freeze(items),
    totalValue: Math.round(goldResult.finalGold + itemValue)
  };
  const breakdown = {
    baseGold: goldResult.baseGold,
    goldModifiers: goldResult.modifiers,
    finalGold: goldResult.finalGold,
    magicItemsGenerated: items.filter((item) => item.type === "magic-item").length,
    tradeGoodsValue,
    inherentLootValue: 0
    // Will be implemented in Phase 5.4
  };
  return {
    bundle,
    breakdown,
    warnings: warnings.length > 0 ? Object.freeze(warnings) : void 0
  };
}
function calculateGold(context, rules, warnings) {
  const { encounterXp, partyLevel, partySize, goldModifier = 1 } = context;
  const baseMultiplier = getGoldBaseMultiplier2(partyLevel);
  const baseGold = encounterXp * baseMultiplier * goldModifier;
  let runningGold = baseGold;
  let totalModifiers = 0;
  for (const rule of rules) {
    if (rule.scope !== "gold" || !rule.enabled) {
      continue;
    }
    if (partySize === 0) {
      warnings.push(`Gold rule "${rule.title}" ignored because no party members are present.`);
      continue;
    }
    const delta = applyGoldRule(rule, runningGold, context, warnings);
    totalModifiers += delta;
    runningGold += delta;
  }
  return {
    baseGold,
    modifiers: totalModifiers,
    finalGold: baseGold + totalModifiers
  };
}
function getGoldBaseMultiplier2(averageLevel) {
  if (averageLevel >= 17) {
    return 3.2;
  }
  if (averageLevel >= 11) {
    return 1.6;
  }
  if (averageLevel >= 5) {
    return 0.415;
  }
  if (averageLevel > 0) {
    return 0.475;
  }
  return 0;
}
function applyGoldRule(rule, runningGold, context, warnings) {
  const { partyLevel, partySize } = context;
  const totalLevels = partyLevel * partySize;
  switch (rule.modifierType) {
    case "flat": {
      return rule.modifierValue;
    }
    case "flatPerAverageLevel": {
      return rule.modifierValue * partyLevel;
    }
    case "flatPerTotalLevel": {
      return rule.modifierValue * totalLevels;
    }
    case "percentTotal": {
      return runningGold * (rule.modifierValue / 100);
    }
    case "percentNextLevel": {
      const xpToNext = calculateXpToNextLevel2(partyLevel);
      if (xpToNext === null) {
        warnings.push(`Party level ${partyLevel} has no next-level XP threshold; "${rule.title}" ignored.`);
        return 0;
      }
      const aggregateXpToNext = xpToNext * partySize;
      return aggregateXpToNext * rule.modifierValue / 100;
    }
    default: {
      warnings.push(`Unknown modifier type "${rule.modifierType}" in rule "${rule.title}".`);
      return 0;
    }
  }
}
function calculateXpToNextLevel2(level) {
  const sanitizedLevel = Math.max(1, Math.floor(level));
  if (sanitizedLevel >= 20) {
    return null;
  }
  const currentThreshold = DND5E_XP_THRESHOLDS[sanitizedLevel];
  const nextThreshold = DND5E_XP_THRESHOLDS[sanitizedLevel + 1];
  if (typeof currentThreshold !== "number" || typeof nextThreshold !== "number") {
    return null;
  }
  return nextThreshold - currentThreshold;
}
function calculateItemBudget(context, config) {
  if (!config.enableMagicItems) {
    return 0;
  }
  const { encounterXp, itemBudgetModifier = 1 } = context;
  return encounterXp * 0.1 * itemBudgetModifier;
}
function formatGold(gold) {
  const rounded = Math.round(gold);
  if (rounded === 0) {
    return "0 gp";
  }
  return `${rounded.toLocaleString("en-US")} gp`;
}
function formatLootSummary(bundle) {
  const parts = [];
  if (bundle.gold > 0) {
    parts.push(formatGold(bundle.gold));
  }
  if (bundle.items.length > 0) {
    const itemCount = bundle.items.reduce((sum, item) => sum + item.quantity, 0);
    parts.push(`${itemCount} item${itemCount !== 1 ? "s" : ""}`);
  }
  if (parts.length === 0) {
    return "No loot";
  }
  return parts.join(", ");
}
var init_loot_generator = __esm({
  "src/features/loot/loot-generator.ts"() {
    "use strict";
    init_session_store();
    init_item_generator();
  }
});

// src/workmodes/session-runner/view/experience.ts
var experience_exports = {};
__export(experience_exports, {
  createSessionRunnerExperience: () => createSessionRunnerExperience
});
function createSessionRunnerExperience() {
  let sidebar = null;
  const playback = new TravelPlaybackController();
  let activeTravelId = null;
  let panelUnsubscribe = null;
  let logic = null;
  const interactions = new TravelInteractionController();
  let routeLayer = null;
  let tokenLayer = null;
  let cleanupFile = null;
  let hostEl = null;
  let terrainEvent = null;
  let lifecycleSignal = null;
  let encounterSync = null;
  let bridgeTravelId = null;
  let audioController = null;
  let encounterController = null;
  let currentMapFile = null;
  const runBridge = (label, fn) => {
    const bridge = getCartographerBridge();
    if (!bridge) {
      logger2.warn(`[session-runner] skipped ${label} \u2013 no Almanac bridge available`);
      return;
    }
    void Promise.resolve(fn(bridge)).catch((error) => {
      logger2.error(`[session-runner] ${label} failed`, error);
    });
  };
  const isAborted = () => lifecycleSignal?.aborted ?? false;
  const bailIfAborted = async () => {
    if (!isAborted()) {
      return false;
    }
    await abortLifecycle();
    return true;
  };
  const handleStateChange = (state) => {
    if (routeLayer) {
      routeLayer.draw(state.route, state.editIdx ?? null, state.tokenRC ?? null);
    }
    sidebar?.setTile(state.currentTile ?? state.tokenRC ?? null);
    sidebar?.setSpeed(state.tokenSpeed);
    playback.sync(state);
    if (audioController) {
      const currentCoord = state.currentTile ?? state.tokenRC ?? null;
      void audioController.updateContext(currentMapFile, currentCoord);
    }
    if (sidebar && currentMapFile) {
      const currentCoord = state.currentTile ?? state.tokenRC ?? null;
      if (currentCoord) {
        const cube = axialToCube(oddrToAxial({ r: currentCoord.r, c: currentCoord.c }));
        const weather = weatherStore.getWeather(currentMapFile.path, cube.q, cube.r, cube.s);
        sidebar.setWeather(weather);
        const history = weatherStore.getWeatherHistory(currentMapFile.path, cube.q, cube.r, cube.s);
        sidebar.setWeatherHistory(history);
        if (weather) {
          const forecast = generateForecast({
            hexCoord: { q: cube.q, r: cube.r, s: cube.s },
            climate: weather.climate,
            season: weather.season,
            currentWeather: weather,
            currentDate: weather.lastUpdate,
            daysAhead: 3
          });
          sidebar.setWeatherForecast(forecast);
        } else {
          sidebar.setWeatherForecast([]);
        }
      } else {
        sidebar.setWeather(null);
        sidebar.setWeatherHistory([]);
        sidebar.setWeatherForecast([]);
      }
    }
  };
  const resetUi = () => {
    sidebar?.setTile(null);
    sidebar?.setSpeed(1);
    sidebar?.setTravelPanel(null);
    sidebar?.setWeather(null);
    sidebar?.setWeatherHistory([]);
    sidebar?.setWeatherForecast([]);
    playback.reset();
  };
  const detachPanelSubscription = () => {
    if (!panelUnsubscribe) return;
    try {
      panelUnsubscribe();
    } finally {
      panelUnsubscribe = null;
    }
  };
  const pushPanelSnapshot = (panel) => {
    if (sidebar) {
      sidebar.setTravelPanel(panel);
    }
  };
  const updatePanelSnapshotFromGateway = (travelId) => {
    pushPanelSnapshot(cartographerHookGateway.getPanelSnapshot(travelId));
  };
  const updateTravelContext = (file) => {
    const nextId = file ? file.path : null;
    if (activeTravelId === nextId) {
      updatePanelSnapshotFromGateway(nextId);
      return;
    }
    if (activeTravelId) {
      cartographerHookGateway.emitTravelEnd(activeTravelId);
    }
    if (bridgeTravelId) {
      runBridge("travel unmount", (bridge) => bridge.unmount());
      bridgeTravelId = null;
    }
    detachPanelSubscription();
    activeTravelId = nextId;
    if (activeTravelId) {
      cartographerHookGateway.emitTravelStart(activeTravelId);
      panelUnsubscribe = cartographerHookGateway.onPanelUpdate(activeTravelId, (panel) => {
        if (!isAborted()) {
          pushPanelSnapshot(panel);
        }
      });
      updatePanelSnapshotFromGateway(activeTravelId);
      const travelIdToMount = activeTravelId;
      runBridge("travel mount", (bridge) => bridge.mount(travelIdToMount));
      bridgeTravelId = travelIdToMount;
    } else {
      pushPanelSnapshot(null);
      runBridge("travel unmount", (bridge) => bridge.unmount());
    }
  };
  const runCleanupFile = async () => {
    if (!cleanupFile) return;
    const fn = cleanupFile;
    cleanupFile = null;
    try {
      await fn();
    } catch (err) {
      logger2.error("[session-runner] cleanupFile failed", err);
    }
  };
  const detachSidebar = () => {
    sidebar?.destroy();
    sidebar = null;
  };
  const releaseTerrainEvent = () => {
    terrainEvent?.off();
    terrainEvent = null;
  };
  const removeTravelClass = () => {
    hostEl?.classList?.remove?.("sm-cartographer--travel");
    hostEl = null;
  };
  const abortLifecycle = async () => {
    await runCleanupFile();
    disposeFile();
    resetUi();
    playback.dispose();
    if (audioController) {
      audioController.dispose();
      audioController = null;
    }
    if (encounterController) {
      encounterController.dispose();
      encounterController = null;
    }
    detachSidebar();
    releaseTerrainEvent();
    removeTravelClass();
  };
  const disposeFile = () => {
    updateTravelContext(null);
    interactions.dispose();
    encounterSync?.dispose();
    encounterSync = null;
    if (tokenLayer) {
      tokenLayer.destroy?.();
      tokenLayer = null;
    }
    if (routeLayer) {
      routeLayer.destroy();
      routeLayer = null;
    }
    if (logic) {
      try {
        logic.pause();
      } catch (err) {
        logger2.error("[session-runner] pause failed", err);
      }
      logic = null;
    }
  };
  const ensureTerrains = async (ctx) => {
    if (ctx.signal.aborted) return;
    await setTerrains(await loadTerrains2(ctx.app));
  };
  const subscribeToTerrains = (ctx) => {
    if (ctx.signal.aborted) {
      return null;
    }
    const workspace = ctx.app.workspace;
    const ref = workspace.on?.("salt:terrains-updated", () => {
      void ensureTerrains(ctx);
    });
    if (!ref) {
      return null;
    }
    return {
      off: () => {
        workspace.offref?.(ref);
      }
    };
  };
  return {
    id: "travel",
    label: "Travel",
    async onEnter(ctx) {
      lifecycleSignal = ctx.signal;
      if (await bailIfAborted()) {
        return;
      }
      hostEl = ctx.host;
      hostEl.classList.add("sm-cartographer--travel");
      await ensureTerrains(ctx);
      if (await bailIfAborted()) {
        return;
      }
      terrainEvent = subscribeToTerrains(ctx);
      if (await bailIfAborted()) {
        return;
      }
      preloadEncounterModule();
      if (await bailIfAborted()) {
        return;
      }
      ctx.sidebarHost.empty();
      if (await bailIfAborted()) {
        return;
      }
      sidebar = createSidebar(ctx.sidebarHost);
      if (await bailIfAborted()) {
        return;
      }
      sidebar.setTitle?.(ctx.getFile()?.basename ?? "");
      sidebar.setTravelHandlers({
        onAdvance: (payload) => runBridge("travel advance", (bridge) => bridge.handlers.onAdvance(payload)),
        onModeChange: (mode) => runBridge("travel mode change", (bridge) => bridge.handlers.onModeChange(mode)),
        onJump: () => runBridge("time jump", (bridge) => bridge.handlers.onJump()),
        onClose: () => runBridge("travel close", (bridge) => bridge.handlers.onClose()),
        onFollowUp: (eventId) => runBridge("event follow-up", (bridge) => bridge.handlers.onFollowUp(eventId))
      });
      sidebar.onSpeedChange((value) => {
        if (!isAborted()) {
          logic?.setTokenSpeed(value);
        }
      });
      playback.mount(sidebar, {
        play: () => isAborted() ? void 0 : logic?.play() ?? void 0,
        pause: () => isAborted() ? void 0 : logic?.pause(),
        reset: () => isAborted() ? void 0 : logic?.reset(),
        setTempo: (value) => isAborted() ? void 0 : logic?.setTempo?.(value),
        onRandomEncounter: async () => {
          if (isAborted() || !logic) return;
          try {
            const state = logic.getState();
            const context = await buildEncounterContext(
              ctx.app,
              ctx.getFile(),
              state,
              state.partyLevel ?? 1,
              state.partySize ?? 4
            );
            if (encounterController) {
              await encounterController.generateRandomEncounter(context);
            }
          } catch (err) {
            logger2.error("[session-runner] Random encounter generation failed", err);
          }
        }
      });
      if (await bailIfAborted()) {
        return;
      }
      try {
        audioController = await createAudioController({
          app: ctx.app,
          host: ctx.sidebarHost
        });
        logger2.info("[session-runner] Audio controller initialized");
      } catch (error) {
        logger2.error("[session-runner] Failed to initialize audio controller", error);
      }
      if (await bailIfAborted()) {
        return;
      }
      try {
        encounterController = await createEncounterController({
          app: ctx.app,
          host: ctx.sidebarHost,
          onCombatStart: () => {
            if (audioController) {
              void audioController.switchToCombatMusic();
              logger2.info("[session-runner] Combat started - switching to combat music");
            }
          },
          onCombatEnd: () => {
            if (audioController) {
              void audioController.restorePreviousMusic();
              logger2.info("[session-runner] Combat ended - restoring music");
            }
          },
          onLootRequested: async (encounter) => {
            if (isAborted() || !logic) return;
            try {
              const state = logic.getState();
              const currentCoord = state.currentTile ?? state.tokenRC ?? null;
              const { generateLoot: generateLoot2 } = await Promise.resolve().then(() => (init_loot_generator(), loot_generator_exports));
              let tags = [];
              if (ctx.getFile() && currentCoord) {
                try {
                  const { loadTile: loadTile2 } = await Promise.resolve().then(() => (init_tile_repository(), tile_repository_exports));
                  const tileData = await loadTile2(ctx.app, ctx.getFile(), currentCoord);
                  if (tileData) {
                    if (tileData.terrain) tags.push(tileData.terrain.toLowerCase());
                    if (tileData.faction) tags.push(tileData.faction.toLowerCase());
                  }
                } catch (err) {
                  logger2.warn("[session-runner] Failed to load tile for loot context", { err });
                }
              }
              const lootResult = generateLoot2({
                partyLevel: state.partyLevel ?? 1,
                partySize: state.partySize ?? 4,
                encounterXp: encounter.totalXP,
                tags: tags.length > 0 ? tags : void 0
              });
              logger2.info("[session-runner] Loot generated", {
                gold: lootResult.bundle.gold,
                itemCount: lootResult.bundle.items.length,
                totalValue: lootResult.bundle.totalValue,
                warnings: lootResult.warnings
              });
              const { Notice: Notice18 } = await import("obsidian");
              const itemSummary = lootResult.bundle.items.length > 0 ? `, ${lootResult.bundle.items.length} items` : "";
              new Notice18(`Loot: ${lootResult.bundle.gold} gold${itemSummary} (${lootResult.bundle.totalValue} total value)`);
            } catch (err) {
              logger2.error("[session-runner] Failed to generate loot", err);
            }
          }
        });
        logger2.info("[session-runner] Encounter controller initialized");
      } catch (error) {
        logger2.error("[session-runner] Failed to initialize encounter controller", error);
      }
      if (await bailIfAborted()) {
        return;
      }
      resetUi();
    },
    async onExit(ctx) {
      lifecycleSignal = ctx.signal;
      await abortLifecycle();
      lifecycleSignal = null;
    },
    async onFileChange(file, handles, ctx) {
      lifecycleSignal = ctx.signal;
      await runCleanupFile();
      disposeFile();
      sidebar?.setTitle?.(file?.basename ?? "");
      resetUi();
      currentMapFile = file;
      if (await bailIfAborted()) {
        return;
      }
      if (!file || !handles) {
        return;
      }
      const mapLayer = ctx.getMapLayer();
      if (!mapLayer) {
        return;
      }
      updateTravelContext(file);
      routeLayer = createRouteLayer(handles.contentG, (rc) => mapLayer.centerOf(rc));
      tokenLayer = createTokenLayer(handles.contentG);
      const adapter = {
        ensurePolys: (coords) => mapLayer.ensurePolys(coords),
        centerOf: (rc) => mapLayer.centerOf(rc),
        draw: (route, tokenRC) => {
          if (routeLayer) routeLayer.draw(route, null, tokenRC);
        },
        token: tokenLayer
      };
      if (await bailIfAborted()) {
        return;
      }
      const activeLogic = createTravelLogic({
        app: ctx.app,
        minSecondsPerTile: 0.05,
        getMapFile: () => ctx.getFile(),
        adapter,
        onChange: (state) => handleStateChange(state),
        onEncounter: async () => {
          if (isAborted()) {
            return;
          }
          if (encounterSync) {
            await encounterSync.handleTravelEncounter();
          }
        }
      });
      logic = activeLogic;
      encounterSync = createEncounterSync({
        getMapFile: () => ctx.getFile?.() ?? null,
        getState: () => activeLogic.getState(),
        pausePlayback: () => {
          try {
            activeLogic.pause();
          } catch (err) {
            logger2.error("[session-runner] pause during encounter sync failed", err);
          }
        },
        openEncounter: (context) => openEncounter2(ctx.app, context),
        onExternalEncounter: () => !isAborted()
      });
      const triggerManualEncounterAt = async (idx) => {
        if (!encounterSync || isAborted()) {
          return;
        }
        const state = activeLogic.getState();
        const node = state.route[idx];
        if (!node) {
          return;
        }
        await publishManualEncounter(
          ctx.app,
          {
            mapFile: ctx.getFile?.() ?? null,
            state
          },
          {
            coordOverride: { r: node.r, c: node.c }
          }
        );
      };
      handleStateChange(activeLogic.getState());
      await activeLogic.initTokenFromTiles();
      if (isAborted() || logic !== activeLogic) {
        await runCleanupFile();
        disposeFile();
        return;
      }
      interactions.bind(
        {
          routeLayerEl: routeLayer.el,
          tokenLayerEl: tokenLayer.el,
          token: tokenLayer,
          adapter,
          polyToCoord: mapLayer.polyToCoord
        },
        {
          getState: () => activeLogic.getState(),
          selectDot: (idx) => activeLogic.selectDot(idx),
          moveSelectedTo: (rc) => activeLogic.moveSelectedTo(rc),
          moveTokenTo: (rc) => activeLogic.moveTokenTo(rc),
          deleteUserAt: (idx) => activeLogic.deleteUserAt(idx),
          triggerEncounterAt: (idx) => triggerManualEncounterAt(idx)
        }
      );
      cleanupFile = async () => {
        interactions.dispose();
        encounterSync?.dispose();
        encounterSync = null;
        if (logic === activeLogic) {
          logic = null;
        }
        try {
          activeLogic.pause();
        } catch (err) {
          logger2.error("[session-runner] pause during cleanup failed", err);
        }
        tokenLayer?.destroy?.();
        tokenLayer = null;
        routeLayer?.destroy();
        routeLayer = null;
      };
      if (await bailIfAborted()) {
        return;
      }
    },
    async onHexClick(coord, event, ctx) {
      lifecycleSignal = ctx.signal;
      if (await bailIfAborted()) {
        return;
      }
      if (interactions.consumeClickSuppression()) {
        if (event.cancelable) event.preventDefault();
        event.stopPropagation();
        return;
      }
      const handles = ctx?.getRenderHandles?.();
      if (handles && !handles.polyByCoord?.has?.(`${coord.r},${coord.c}`)) {
        return;
      }
      if (!logic) return;
      if (event.cancelable) event.preventDefault();
      event.stopPropagation();
      logic.handleHexClick(coord);
    },
    async onSave(_mode, file, ctx) {
      lifecycleSignal = ctx.signal;
      if (await bailIfAborted()) {
        return false;
      }
      if (!logic || !file) return false;
      try {
        await logic.persistTokenToTiles();
      } catch (err) {
        logger2.error("[session-runner] persistTokenToTiles failed", err);
      }
      return false;
    }
  };
}
var init_experience = __esm({
  "src/workmodes/session-runner/view/experience.ts"() {
    "use strict";
    init_terrain_repository();
    init_terrain();
    init_sidebar();
    init_route_layer();
    init_token_layer();
    init_actions();
    init_cartographer_gateway();
    init_cartographer_bridge();
    init_playback_controller();
    init_interaction_controller();
    init_plugin_logger();
    init_encounter_gateway();
    init_encounter_sync();
    init_audio_controller();
    init_encounter_controller();
    init_encounter_context_builder();
    init_weather_store();
    init_weather_forecaster();
    init_hex_geom();
  }
});

// src/features/events/hook-executor.ts
var HookHandlerRegistry, HookExecutor, globalHookExecutor;
var init_hook_executor = __esm({
  "src/features/events/hook-executor.ts"() {
    "use strict";
    init_plugin_logger();
    HookHandlerRegistry = class {
      constructor() {
        this.handlers = /* @__PURE__ */ new Map();
      }
      register(handler) {
        this.handlers.set(handler.type, handler);
        logger2.info("[hook-executor] Registered hook handler", { type: handler.type });
      }
      get(type2) {
        return this.handlers.get(type2);
      }
      getAll() {
        return Array.from(this.handlers.values());
      }
      clear() {
        this.handlers.clear();
      }
    };
    HookExecutor = class {
      constructor() {
        this.registry = new HookHandlerRegistry();
      }
      /**
       * Register a hook handler
       */
      registerHandler(handler) {
        this.registry.register(handler);
      }
      /**
       * Execute hooks from triggered events and phenomena
       */
      async executeHooks(events, phenomena, context) {
        logger2.info("[hook-executor] Executing hooks", {
          eventCount: events.length,
          phenomenonCount: phenomena.length,
          scope: context.scope
        });
        for (const event of events) {
          if (!event.hooks || event.hooks.length === 0) continue;
          const eventContext = {
            ...context,
            event
          };
          for (const hookDesc of event.hooks) {
            await this.executeHook(hookDesc, eventContext);
          }
        }
        for (const phenomenon of phenomena) {
          const hooks = phenomenon.hooks;
          if (!hooks || hooks.length === 0) continue;
          const phenomenonContext = {
            ...context,
            phenomenon
          };
          for (const hookDesc of hooks) {
            await this.executeHook(hookDesc, phenomenonContext);
          }
        }
      }
      /**
       * Execute a single hook descriptor
       */
      async executeHook(descriptor, context) {
        const handler = this.registry.get(descriptor.type);
        if (!handler) {
          logger2.warn("[hook-executor] No handler registered for hook type", {
            type: descriptor.type,
            hookId: descriptor.id
          });
          return;
        }
        if (!handler.canHandle(descriptor)) {
          logger2.warn("[hook-executor] Handler cannot handle hook", {
            type: descriptor.type,
            hookId: descriptor.id
          });
          return;
        }
        try {
          logger2.info("[hook-executor] Executing hook", {
            type: descriptor.type,
            hookId: descriptor.id,
            config: descriptor.config
          });
          await handler.execute(descriptor, context);
          logger2.info("[hook-executor] Hook executed successfully", {
            type: descriptor.type,
            hookId: descriptor.id
          });
        } catch (error) {
          logger2.error("[hook-executor] Hook execution failed", {
            type: descriptor.type,
            hookId: descriptor.id,
            error
          });
        }
      }
      /**
       * Clear all registered handlers (for testing)
       */
      clear() {
        this.registry.clear();
      }
    };
    globalHookExecutor = new HookExecutor();
  }
});

// src/features/events/hooks/notification-handler.ts
var NotificationHandler;
var init_notification_handler = __esm({
  "src/features/events/hooks/notification-handler.ts"() {
    "use strict";
    init_plugin_logger();
    NotificationHandler = class {
      constructor() {
        this.type = "notification";
      }
      canHandle(descriptor) {
        return descriptor.type === this.type && typeof descriptor.config.message === "string";
      }
      async execute(descriptor, context) {
        const config = descriptor.config;
        const message = this.formatMessage(config.message, context);
        const level = config.level || "info";
        logger2.info("[notification-handler] Showing notification", {
          message,
          level,
          eventTitle: context.event?.title,
          phenomenonTitle: context.phenomenon?.title
        });
        console.log(`[${level.toUpperCase()}] ${message}`);
      }
      /**
       * Format message with placeholders
       * Supports: {event.title}, {phenomenon.title}, {event.category}
       */
      formatMessage(template, context) {
        let message = template;
        if (context.event) {
          message = message.replace(/{event\.title}/g, context.event.title || "");
          message = message.replace(/{event\.category}/g, context.event.category || "");
        }
        if (context.phenomenon) {
          message = message.replace(/{phenomenon\.title}/g, context.phenomenon.title || "");
        }
        return message;
      }
    };
  }
});

// src/features/events/hooks/weather-handler.ts
var WeatherHandler;
var init_weather_handler = __esm({
  "src/features/events/hooks/weather-handler.ts"() {
    "use strict";
    init_plugin_logger();
    WeatherHandler = class {
      constructor() {
        this.type = "weather_update";
      }
      canHandle(descriptor) {
        return descriptor.type === this.type;
      }
      async execute(descriptor, context) {
        const config = descriptor.config;
        logger2.info("[weather-handler] Weather update triggered", {
          weatherType: config.weatherType,
          temperature: config.temperature,
          hexCoordinates: config.hexCoordinates,
          eventTitle: context.event?.title
        });
        if (config.hexCoordinates) {
          logger2.info("[weather-handler] Would update weather at hex", config.hexCoordinates);
        } else {
          logger2.info("[weather-handler] Would update weather at current travel location");
        }
      }
    };
  }
});

// src/features/events/hooks/faction-handler.ts
var FactionHandler;
var init_faction_handler = __esm({
  "src/features/events/hooks/faction-handler.ts"() {
    "use strict";
    init_plugin_logger();
    FactionHandler = class {
      constructor() {
        this.type = "faction_update";
      }
      canHandle(descriptor) {
        const config = descriptor.config;
        return descriptor.type === this.type && typeof config.factionName === "string" && typeof config.action === "string";
      }
      async execute(descriptor, context) {
        const config = descriptor.config;
        logger2.info("[faction-handler] Faction update triggered", {
          factionName: config.factionName,
          action: config.action,
          status: config.status,
          targetFaction: config.targetFaction,
          eventTitle: context.event?.title
        });
        switch (config.action) {
          case "set_status":
            logger2.info("[faction-handler] Would set faction status", {
              faction: config.factionName,
              newStatus: config.status
            });
            break;
          case "change_relationship":
            logger2.info("[faction-handler] Would change faction relationship", {
              faction: config.factionName,
              target: config.targetFaction,
              value: config.relationshipValue
            });
            break;
          case "update_resources":
            logger2.info("[faction-handler] Would update faction resources", {
              faction: config.factionName,
              resources: config.resources
            });
            break;
          default:
            logger2.warn("[faction-handler] Unknown action type", {
              action: config.action
            });
        }
      }
    };
  }
});

// src/features/events/hooks/location-handler.ts
var LocationHandler;
var init_location_handler = __esm({
  "src/features/events/hooks/location-handler.ts"() {
    "use strict";
    init_plugin_logger();
    LocationHandler = class {
      constructor() {
        this.type = "location_update";
      }
      canHandle(descriptor) {
        const config = descriptor.config;
        return descriptor.type === this.type && typeof config.locationName === "string" && typeof config.action === "string";
      }
      async execute(descriptor, context) {
        const config = descriptor.config;
        logger2.info("[location-handler] Location update triggered", {
          locationName: config.locationName,
          action: config.action,
          state: config.state,
          ownerFaction: config.ownerFaction,
          eventTitle: context.event?.title
        });
        switch (config.action) {
          case "set_state":
            logger2.info("[location-handler] Would set location state", {
              location: config.locationName,
              newState: config.state
            });
            break;
          case "change_owner":
            logger2.info("[location-handler] Would change location owner", {
              location: config.locationName,
              newOwner: config.ownerFaction,
              ownerType: config.ownerType
            });
            break;
          case "update_description":
            logger2.info("[location-handler] Would update location description", {
              location: config.locationName,
              descriptionLength: config.description?.length
            });
            break;
          default:
            logger2.warn("[location-handler] Unknown action type", {
              action: config.action
            });
        }
      }
    };
  }
});

// src/features/events/hooks/index.ts
var init_hooks = __esm({
  "src/features/events/hooks/index.ts"() {
    "use strict";
    init_notification_handler();
    init_weather_handler();
    init_faction_handler();
    init_location_handler();
  }
});

// src/features/events/event-history-types.ts
function isTriggeredEvent(entry) {
  return "eventId" in entry;
}
function isTriggeredPhenomenon(entry) {
  return "phenomenonId" in entry;
}
function generateUniqueId(prefix) {
  return `${prefix}-${Date.now()}-${idCounter++}`;
}
function createTriggeredEventEntry(event, timestamp2, context) {
  return {
    id: generateUniqueId(`evt-${event.id}`),
    eventId: event.id,
    calendarId: event.calendarId,
    eventType: event.kind,
    title: event.title,
    category: event.category,
    timestamp: timestamp2,
    triggeredAt: /* @__PURE__ */ new Date(),
    scope: context.scope,
    travelId: context.travelId,
    reason: context.reason,
    priority: event.priority,
    hooks: event.hooks?.length
  };
}
function createTriggeredPhenomenonEntry(phenomenon, context) {
  return {
    id: generateUniqueId(`phen-${phenomenon.phenomenonId}`),
    phenomenonId: phenomenon.phenomenonId,
    title: phenomenon.title,
    timestamp: phenomenon.timestamp,
    triggeredAt: /* @__PURE__ */ new Date(),
    scope: context.scope,
    travelId: context.travelId,
    reason: context.reason,
    effects: phenomenon.effects
  };
}
function createInboxItem(entry) {
  if (isTriggeredEvent(entry)) {
    return {
      entryId: entry.id,
      type: "event",
      title: entry.title,
      timestamp: entry.timestamp,
      triggeredAt: entry.triggeredAt,
      priority: entry.priority ?? 50,
      category: entry.category,
      read: false
    };
  } else {
    return {
      entryId: entry.id,
      type: "phenomenon",
      title: entry.title ?? entry.phenomenonId,
      timestamp: entry.timestamp,
      triggeredAt: entry.triggeredAt,
      priority: 50,
      // Default priority for phenomena
      read: false
    };
  }
}
var idCounter;
var init_event_history_types = __esm({
  "src/features/events/event-history-types.ts"() {
    "use strict";
    idCounter = 0;
  }
});

// src/features/events/event-history-store.ts
var Observable, EventHistoryStore, globalEventHistoryStore;
var init_event_history_store = __esm({
  "src/features/events/event-history-store.ts"() {
    "use strict";
    init_event_history_types();
    init_plugin_logger();
    Observable = class {
      constructor(initialValue) {
        this.subscribers = /* @__PURE__ */ new Set();
        this.value = initialValue;
      }
      subscribe(subscriber) {
        this.subscribers.add(subscriber);
        subscriber(this.value);
        return () => this.subscribers.delete(subscriber);
      }
      set(newValue) {
        this.value = newValue;
        this.subscribers.forEach((subscriber) => subscriber(newValue));
      }
      update(updater) {
        this.set(updater(this.value));
      }
      getValue() {
        return this.value;
      }
    };
    EventHistoryStore = class {
      constructor(storageKey = "salt-marcher-event-history") {
        this.storageKey = storageKey;
        this.timeline = new Observable([]);
        this.readEntries = new Observable(/* @__PURE__ */ new Set());
        this.loadFromStorage();
      }
      /**
       * Add triggered event to timeline
       */
      addEvent(entry) {
        this.timeline.update((entries) => {
          const updated = [...entries, entry];
          logger2.info("[event-history-store] Event added to timeline", {
            entryId: entry.id,
            eventId: entry.eventId,
            title: entry.title,
            totalEntries: updated.length
          });
          this.saveToStorage(updated, this.getCurrentReadEntries());
          return updated;
        });
      }
      /**
       * Add triggered phenomenon to timeline
       */
      addPhenomenon(entry) {
        this.timeline.update((entries) => {
          const updated = [...entries, entry];
          logger2.info("[event-history-store] Phenomenon added to timeline", {
            entryId: entry.id,
            phenomenonId: entry.phenomenonId,
            title: entry.title,
            totalEntries: updated.length
          });
          this.saveToStorage(updated, this.getCurrentReadEntries());
          return updated;
        });
      }
      /**
       * Mark entry as read
       */
      markAsRead(entryId) {
        this.readEntries.update((entries) => {
          const updated = new Set(entries);
          updated.add(entryId);
          logger2.info("[event-history-store] Entry marked as read", { entryId });
          this.saveToStorage(this.getCurrentTimeline(), updated);
          return updated;
        });
      }
      /**
       * Mark entry as unread
       */
      markAsUnread(entryId) {
        this.readEntries.update((entries) => {
          const updated = new Set(entries);
          updated.delete(entryId);
          logger2.info("[event-history-store] Entry marked as unread", { entryId });
          this.saveToStorage(this.getCurrentTimeline(), updated);
          return updated;
        });
      }
      /**
       * Mark all entries as read
       */
      markAllAsRead() {
        const timeline = this.getCurrentTimeline();
        this.readEntries.set(new Set(timeline.map((e) => e.id)));
        logger2.info("[event-history-store] All entries marked as read", {
          count: timeline.length
        });
        this.saveToStorage(timeline, this.getCurrentReadEntries());
      }
      /**
       * Clear all timeline entries
       */
      clear() {
        this.timeline.set([]);
        this.readEntries.set(/* @__PURE__ */ new Set());
        logger2.info("[event-history-store] Timeline cleared");
        this.saveToStorage([], /* @__PURE__ */ new Set());
      }
      /**
       * Get timeline (all entries)
       */
      getTimeline() {
        return this.timeline.getValue();
      }
      /**
       * Subscribe to timeline changes
       */
      subscribeTimeline(callback) {
        return this.timeline.subscribe(callback);
      }
      /**
       * Get filtered timeline
       */
      getFilteredTimeline(filter) {
        const timeline = this.timeline.getValue();
        return timeline.filter((entry) => {
          if (filter.scope && entry.scope !== filter.scope) return false;
          if (filter.travelId !== void 0 && entry.travelId !== filter.travelId) return false;
          if (filter.category && isTriggeredEvent(entry) && entry.category !== filter.category) return false;
          if (filter.eventType && isTriggeredEvent(entry) && entry.eventType !== filter.eventType) return false;
          return true;
        });
      }
      /**
       * Get sorted timeline
       */
      getSortedTimeline(sortOptions) {
        const timeline = this.timeline.getValue();
        const sorted = [...timeline];
        sorted.sort((a, b) => {
          let compareA;
          let compareB;
          switch (sortOptions.field) {
            case "timestamp":
              compareA = a.timestamp.year * 1e4 + a.timestamp.day;
              compareB = b.timestamp.year * 1e4 + b.timestamp.day;
              break;
            case "triggeredAt":
              compareA = a.triggeredAt.getTime();
              compareB = b.triggeredAt.getTime();
              break;
            case "priority":
              compareA = isTriggeredEvent(a) ? a.priority ?? 50 : 50;
              compareB = isTriggeredEvent(b) ? b.priority ?? 50 : 50;
              break;
            case "title":
              compareA = isTriggeredEvent(a) ? a.title : a.title ?? "";
              compareB = isTriggeredEvent(b) ? b.title : b.title ?? "";
              break;
            default:
              return 0;
          }
          if (compareA < compareB) return sortOptions.order === "asc" ? -1 : 1;
          if (compareA > compareB) return sortOptions.order === "asc" ? 1 : -1;
          return 0;
        });
        return sorted;
      }
      /**
       * Get inbox (unread items sorted by priority)
       */
      getInbox() {
        const timeline = this.timeline.getValue();
        const readEntries = this.readEntries.getValue();
        const unreadEntries = timeline.filter((entry) => !readEntries.has(entry.id));
        const inboxItems = unreadEntries.map((entry) => createInboxItem(entry));
        inboxItems.sort((a, b) => {
          if (b.priority !== a.priority) return b.priority - a.priority;
          return b.triggeredAt.getTime() - a.triggeredAt.getTime();
        });
        return inboxItems;
      }
      /**
       * Subscribe to inbox changes
       */
      subscribeInbox(callback) {
        const updateInbox = () => callback(this.getInbox());
        const unsubTimeline = this.timeline.subscribe(updateInbox);
        const unsubRead = this.readEntries.subscribe(updateInbox);
        return () => {
          unsubTimeline();
          unsubRead();
        };
      }
      /**
       * Get inbox count
       */
      getInboxCount() {
        return this.getInbox().length;
      }
      /**
       * Subscribe to inbox count changes
       */
      subscribeInboxCount(callback) {
        return this.subscribeInbox((inbox) => callback(inbox.length));
      }
      /**
       * Get read status for an entry
       */
      isRead(entryId) {
        return this.readEntries.getValue().has(entryId);
      }
      /**
       * Subscribe to read status changes
       */
      subscribeReadStatus(entryId, callback) {
        return this.readEntries.subscribe((readEntries) => callback(readEntries.has(entryId)));
      }
      // Private helper methods
      getCurrentTimeline() {
        return this.timeline.getValue();
      }
      getCurrentReadEntries() {
        return this.readEntries.getValue();
      }
      saveToStorage(timeline, readEntries) {
        try {
          const data = {
            timeline,
            readEntries: Array.from(readEntries),
            version: 1
          };
          localStorage.setItem(this.storageKey, JSON.stringify(data));
        } catch (error) {
          logger2.error("[event-history-store] Failed to save to storage", error);
        }
      }
      loadFromStorage() {
        try {
          const stored = localStorage.getItem(this.storageKey);
          if (!stored) return;
          const data = JSON.parse(stored);
          if (data.version === 1) {
            this.timeline.set(data.timeline || []);
            this.readEntries.set(new Set(data.readEntries || []));
            logger2.info("[event-history-store] Loaded from storage", {
              timelineCount: data.timeline?.length || 0,
              readCount: data.readEntries?.length || 0
            });
          }
        } catch (error) {
          logger2.error("[event-history-store] Failed to load from storage", error);
        }
      }
    };
    globalEventHistoryStore = new EventHistoryStore();
  }
});

// src/features/events/executing-hook-gateway.ts
var ExecutingHookGateway;
var init_executing_hook_gateway = __esm({
  "src/features/events/executing-hook-gateway.ts"() {
    "use strict";
    init_hook_executor();
    init_hooks();
    init_event_history_store();
    init_event_history_types();
    init_domain();
    init_plugin_logger();
    ExecutingHookGateway = class {
      constructor(executor, historyStore) {
        this.executor = executor || new HookExecutor();
        this.historyStore = historyStore || new EventHistoryStore();
        this.registerDefaultHandlers();
      }
      /**
       * Register default hook handlers
       */
      registerDefaultHandlers() {
        this.executor.registerHandler(new NotificationHandler());
        this.executor.registerHandler(new WeatherHandler());
        this.executor.registerHandler(new FactionHandler());
        this.executor.registerHandler(new LocationHandler());
      }
      /**
       * Dispatch hooks from triggered events and phenomena
       */
      async dispatchHooks(events, phenomena, context) {
        logger2.info("[executing-hook-gateway] Dispatching hooks", {
          eventCount: events.length,
          phenomenonCount: phenomena.length,
          scope: context.scope,
          reason: context.reason
        });
        for (const event of events) {
          const timestamp2 = getEventAnchorTimestamp(event) ?? event.date;
          const entry = createTriggeredEventEntry(event, timestamp2, {
            scope: context.scope,
            travelId: context.travelId,
            reason: context.reason
          });
          this.historyStore.addEvent(entry);
        }
        for (const phenomenon of phenomena) {
          const entry = createTriggeredPhenomenonEntry(phenomenon, {
            scope: context.scope,
            travelId: context.travelId,
            reason: context.reason
          });
          this.historyStore.addPhenomenon(entry);
        }
        await this.executor.executeHooks(events, phenomena, {
          scope: context.scope,
          travelId: context.travelId,
          reason: context.reason
        });
      }
      /**
       * Get the underlying executor (for testing/extension)
       */
      getExecutor() {
        return this.executor;
      }
      /**
       * Get the event history store (for testing/UI access)
       */
      getHistoryStore() {
        return this.historyStore;
      }
    };
  }
});

// src/features/events/timeline-view.ts
function formatTimestamp3(timestamp2) {
  return `${timestamp2.year}-${timestamp2.monthId}-${String(timestamp2.day).padStart(2, "0")}`;
}
function formatDate(date) {
  return date.toLocaleString();
}
async function openTimelineView(app, store) {
  const { workspace } = app;
  const existingLeaves = workspace.getLeavesOfType(VIEW_TYPE_TIMELINE);
  if (existingLeaves.length > 0) {
    workspace.revealLeaf(existingLeaves[0]);
    return;
  }
  const leaf = workspace.getLeaf(true);
  await leaf.setViewState({
    type: VIEW_TYPE_TIMELINE,
    active: true
  });
  workspace.revealLeaf(leaf);
}
var import_obsidian50, VIEW_TYPE_TIMELINE, TimelineView;
var init_timeline_view = __esm({
  "src/features/events/timeline-view.ts"() {
    "use strict";
    import_obsidian50 = require("obsidian");
    init_event_history_types();
    init_ui();
    init_plugin_logger();
    VIEW_TYPE_TIMELINE = "event-timeline-view";
    TimelineView = class extends import_obsidian50.ItemView {
      constructor(leaf, store) {
        super(leaf);
        // Current filter/sort state
        this.currentFilter = {};
        this.currentSort = {
          field: "triggeredAt",
          order: "desc"
        };
        this.store = store;
      }
      getViewType() {
        return VIEW_TYPE_TIMELINE;
      }
      getDisplayText() {
        return "Event Timeline";
      }
      getIcon() {
        return "clock";
      }
      async onOpen() {
        const content = this.contentEl;
        content.empty();
        content.addClass("sm-timeline-view");
        this.header = createWorkmodeHeader(content, {
          title: "Event Timeline",
          search: {
            placeholder: "Search events\u2026",
            disabled: true
            // TODO: Enable search in future iteration
          },
          action: {
            label: "Clear timeline",
            onClick: () => this.handleClearTimeline()
          }
        });
        this.rootEl = content.createDiv({ cls: "sm-timeline-container" });
        this.renderFilterBar();
        this.renderSortBar();
        this.timelineListEl = this.rootEl.createDiv({ cls: "sm-timeline-list" });
        this.emptyStateEl = this.rootEl.createDiv({
          cls: "sm-timeline-empty",
          text: "No events have been triggered yet. Travel mode and calendar advances will populate this timeline."
        });
        this.unsubscribeTimeline = this.store.subscribeTimeline(() => {
          this.renderTimeline();
        });
        this.renderTimeline();
        logger2.info("[timeline-view] View opened");
      }
      async onClose() {
        this.unsubscribeTimeline?.();
        this.unsubscribeTimeline = void 0;
        this.header?.destroy();
        this.header = void 0;
        this.contentEl.removeClass("sm-timeline-view");
        logger2.info("[timeline-view] View closed");
      }
      /**
       * Render filter controls
       */
      renderFilterBar() {
        if (!this.rootEl) return;
        this.filterBarEl = this.rootEl.createDiv({ cls: "sm-timeline-filters" });
        const scopeLabel = this.filterBarEl.createEl("label", {
          cls: "sm-timeline-filter-label",
          text: "Scope:"
        });
        const scopeSelect = this.filterBarEl.createEl("select", {
          cls: "sm-timeline-filter-select"
        });
        scopeSelect.createEl("option", { value: "", text: "All" });
        scopeSelect.createEl("option", { value: "global", text: "Global" });
        scopeSelect.createEl("option", { value: "travel", text: "Travel" });
        scopeSelect.addEventListener("change", () => {
          this.currentFilter.scope = scopeSelect.value === "" ? void 0 : scopeSelect.value;
          this.renderTimeline();
        });
        const categoryLabel = this.filterBarEl.createEl("label", {
          cls: "sm-timeline-filter-label",
          text: "Category:"
        });
        const categoryInput = this.filterBarEl.createEl("input", {
          cls: "sm-timeline-filter-input",
          attr: { type: "text", placeholder: "e.g., festival" }
        });
        categoryInput.addEventListener("input", () => {
          this.currentFilter.category = categoryInput.value.trim() || void 0;
          this.renderTimeline();
        });
        const clearButton = this.filterBarEl.createEl("button", {
          cls: "sm-timeline-filter-clear",
          text: "Clear filters"
        });
        clearButton.addEventListener("click", () => {
          scopeSelect.value = "";
          categoryInput.value = "";
          this.currentFilter = {};
          this.renderTimeline();
        });
      }
      /**
       * Render sort controls
       */
      renderSortBar() {
        if (!this.rootEl) return;
        this.sortBarEl = this.rootEl.createDiv({ cls: "sm-timeline-sort" });
        const sortLabel = this.sortBarEl.createEl("label", {
          cls: "sm-timeline-sort-label",
          text: "Sort by:"
        });
        const sortFieldSelect = this.sortBarEl.createEl("select", {
          cls: "sm-timeline-sort-select"
        });
        sortFieldSelect.createEl("option", { value: "triggeredAt", text: "Triggered time" });
        sortFieldSelect.createEl("option", { value: "timestamp", text: "Event date" });
        sortFieldSelect.createEl("option", { value: "priority", text: "Priority" });
        sortFieldSelect.createEl("option", { value: "title", text: "Title" });
        sortFieldSelect.value = this.currentSort.field;
        sortFieldSelect.addEventListener("change", () => {
          this.currentSort.field = sortFieldSelect.value;
          this.renderTimeline();
        });
        const sortOrderSelect = this.sortBarEl.createEl("select", {
          cls: "sm-timeline-sort-select"
        });
        sortOrderSelect.createEl("option", { value: "desc", text: "Newest first" });
        sortOrderSelect.createEl("option", { value: "asc", text: "Oldest first" });
        sortOrderSelect.value = this.currentSort.order;
        sortOrderSelect.addEventListener("change", () => {
          this.currentSort.order = sortOrderSelect.value;
          this.renderTimeline();
        });
      }
      /**
       * Render timeline entries
       */
      renderTimeline() {
        if (!this.timelineListEl || !this.emptyStateEl) return;
        const filteredEntries = this.store.getFilteredTimeline(this.currentFilter);
        const sortedEntries = this.sortEntries(filteredEntries, this.currentSort);
        this.timelineListEl.empty();
        if (sortedEntries.length === 0) {
          this.emptyStateEl.removeClass("sm-timeline-hidden");
          return;
        }
        this.emptyStateEl.addClass("sm-timeline-hidden");
        for (const entry of sortedEntries) {
          this.renderEntry(entry);
        }
        logger2.info("[timeline-view] Rendered timeline", {
          total: sortedEntries.length,
          filter: this.currentFilter,
          sort: this.currentSort
        });
      }
      /**
       * Sort timeline entries (helper because we need to handle both timestamp and triggeredAt)
       */
      sortEntries(entries, sortOptions) {
        const sorted = [...entries];
        sorted.sort((a, b) => {
          let compareA;
          let compareB;
          switch (sortOptions.field) {
            case "timestamp":
              compareA = a.timestamp.year * 1e4 + a.timestamp.day;
              compareB = b.timestamp.year * 1e4 + b.timestamp.day;
              break;
            case "triggeredAt":
              compareA = a.triggeredAt.getTime();
              compareB = b.triggeredAt.getTime();
              break;
            case "priority":
              compareA = isTriggeredEvent(a) ? a.priority ?? 50 : 50;
              compareB = isTriggeredEvent(b) ? b.priority ?? 50 : 50;
              break;
            case "title":
              compareA = isTriggeredEvent(a) ? a.title : a.title ?? "";
              compareB = isTriggeredEvent(b) ? b.title : b.title ?? "";
              break;
            default:
              return 0;
          }
          if (compareA < compareB) return sortOptions.order === "asc" ? -1 : 1;
          if (compareA > compareB) return sortOptions.order === "asc" ? 1 : -1;
          return 0;
        });
        return sorted;
      }
      /**
       * Render a single timeline entry
       */
      renderEntry(entry) {
        if (!this.timelineListEl) return;
        const entryEl = this.timelineListEl.createDiv({ cls: "sm-timeline-entry" });
        const isRead = this.store.isRead(entry.id);
        if (!isRead) {
          entryEl.addClass("sm-timeline-entry--unread");
        }
        const headerEl = entryEl.createDiv({ cls: "sm-timeline-entry-header" });
        const typeEl = headerEl.createDiv({ cls: "sm-timeline-entry-type" });
        if (isTriggeredEvent(entry)) {
          typeEl.setText("Event");
          typeEl.addClass("sm-timeline-entry-type--event");
        } else {
          typeEl.setText("Phenomenon");
          typeEl.addClass("sm-timeline-entry-type--phenomenon");
        }
        const titleEl = headerEl.createDiv({ cls: "sm-timeline-entry-title" });
        const title = isTriggeredEvent(entry) ? entry.title : entry.title ?? entry.phenomenonId;
        titleEl.setText(title);
        if (isTriggeredEvent(entry) && entry.category) {
          const categoryEl = headerEl.createDiv({ cls: "sm-timeline-entry-category" });
          categoryEl.setText(entry.category);
        }
        if (isTriggeredEvent(entry) && entry.priority !== void 0) {
          const priorityEl = headerEl.createDiv({ cls: "sm-timeline-entry-priority" });
          priorityEl.setText(`Priority: ${entry.priority}`);
        }
        const metaEl = entryEl.createDiv({ cls: "sm-timeline-entry-meta" });
        const timestampEl = metaEl.createDiv({ cls: "sm-timeline-entry-meta-item" });
        timestampEl.createSpan({ cls: "label", text: "Event date: " });
        timestampEl.createSpan({ cls: "value", text: formatTimestamp3(entry.timestamp) });
        const triggeredAtEl = metaEl.createDiv({ cls: "sm-timeline-entry-meta-item" });
        triggeredAtEl.createSpan({ cls: "label", text: "Triggered: " });
        triggeredAtEl.createSpan({ cls: "value", text: formatDate(entry.triggeredAt) });
        const scopeEl = metaEl.createDiv({ cls: "sm-timeline-entry-meta-item" });
        scopeEl.createSpan({ cls: "label", text: "Scope: " });
        scopeEl.createSpan({ cls: "value", text: entry.scope });
        const reasonEl = metaEl.createDiv({ cls: "sm-timeline-entry-meta-item" });
        reasonEl.createSpan({ cls: "label", text: "Reason: " });
        reasonEl.createSpan({ cls: "value", text: entry.reason });
        const actionsEl = entryEl.createDiv({ cls: "sm-timeline-entry-actions" });
        if (!isRead) {
          const markReadBtn = actionsEl.createEl("button", {
            cls: "sm-timeline-btn sm-timeline-btn-primary",
            text: "Mark as read"
          });
          markReadBtn.addEventListener("click", () => {
            this.store.markAsRead(entry.id);
            this.renderTimeline();
          });
        } else {
          const markUnreadBtn = actionsEl.createEl("button", {
            cls: "sm-timeline-btn",
            text: "Mark as unread"
          });
          markUnreadBtn.addEventListener("click", () => {
            this.store.markAsUnread(entry.id);
            this.renderTimeline();
          });
        }
      }
      /**
       * Handle clear timeline button
       */
      handleClearTimeline() {
        const confirmed = window.confirm("Clear entire timeline? This cannot be undone.");
        if (!confirmed) return;
        this.store.clear();
        logger2.info("[timeline-view] Timeline cleared by user");
      }
    };
  }
});

// src/features/events/inbox-status-bar.ts
function createInboxStatusBar(app, store, statusBarItem) {
  return new InboxStatusBar(app, store, statusBarItem);
}
var InboxStatusBar;
var init_inbox_status_bar = __esm({
  "src/features/events/inbox-status-bar.ts"() {
    "use strict";
    init_plugin_logger();
    InboxStatusBar = class {
      constructor(app, store, statusBarItem) {
        this.currentCount = 0;
        this.app = app;
        this.store = store;
        this.statusBarItem = statusBarItem;
        this.setupStatusBarItem();
        this.subscribeToInbox();
      }
      /**
       * Setup the statusbar item appearance and click handler
       */
      setupStatusBarItem() {
        this.statusBarItem.addClass("sm-inbox-statusbar");
        this.statusBarItem.setAttribute("aria-label", "Event Inbox");
        this.statusBarItem.addEventListener("click", (event) => {
          this.openInboxMenu(event);
        });
      }
      /**
       * Subscribe to inbox changes and update display
       */
      subscribeToInbox() {
        this.unsubscribe = this.store.subscribeInboxCount((count) => {
          this.currentCount = count;
          this.updateDisplay(count);
        });
        logger2.info("[inbox-status-bar] Subscribed to inbox updates");
      }
      /**
       * Update the statusbar display with current count
       */
      updateDisplay(count) {
        if (count === 0) {
          this.statusBarItem.setText("\u{1F4EC} Inbox");
          this.statusBarItem.removeClass("sm-inbox-statusbar--has-unread");
        } else {
          this.statusBarItem.setText(`\u{1F4EC} Inbox (${count})`);
          this.statusBarItem.addClass("sm-inbox-statusbar--has-unread");
        }
        logger2.info("[inbox-status-bar] Display updated", { count });
      }
      /**
       * Open the inbox menu at cursor position
       */
      openInboxMenu(event) {
        const inbox = this.store.getInbox();
        const { Menu: Menu2 } = require("obsidian");
        const menu = new Menu2();
        if (inbox.length === 0) {
          menu.addItem((item) => {
            item.setTitle("No unread events").setDisabled(true);
          });
        } else {
          for (const item of inbox.slice(0, 10)) {
            menu.addItem((menuItem) => {
              const title = this.formatInboxItemTitle(item);
              menuItem.setTitle(title).onClick(() => {
                this.handleInboxItemClick(item);
              });
            });
          }
          menu.addSeparator();
          menu.addItem((item) => {
            item.setTitle("Mark all as read").setIcon("check-check").onClick(() => {
              this.handleMarkAllAsRead();
            });
          });
        }
        menu.addSeparator();
        menu.addItem((item) => {
          item.setTitle("Open Timeline").setIcon("clock").onClick(() => {
            this.handleOpenTimeline();
          });
        });
        menu.showAtMouseEvent(event);
        logger2.info("[inbox-status-bar] Menu opened", { itemCount: inbox.length });
      }
      /**
       * Format an inbox item for display in menu
       */
      formatInboxItemTitle(item) {
        const priorityIndicator = item.priority >= 80 ? "\u2757" : item.priority >= 50 ? "\u2022" : "\u25E6";
        const typeIndicator = item.type === "event" ? "\u{1F4C5}" : "\u{1F319}";
        return `${priorityIndicator} ${typeIndicator} ${item.title}`;
      }
      /**
       * Handle click on an inbox item
       */
      handleInboxItemClick(item) {
        this.store.markAsRead(item.entryId);
        logger2.info("[inbox-status-bar] Item clicked and marked as read", {
          entryId: item.entryId,
          title: item.title
        });
      }
      /**
       * Handle "Mark all as read" action
       */
      handleMarkAllAsRead() {
        this.store.markAllAsRead();
        logger2.info("[inbox-status-bar] All inbox items marked as read");
      }
      /**
       * Handle "Open Timeline" action
       */
      async handleOpenTimeline() {
        try {
          const { openTimelineView: openTimelineView2, globalEventHistoryStore: globalEventHistoryStore2 } = await Promise.resolve().then(() => (init_events(), events_exports));
          await openTimelineView2(this.app, globalEventHistoryStore2);
          logger2.info("[inbox-status-bar] Timeline view opened");
        } catch (error) {
          logger2.error("[inbox-status-bar] Failed to open Timeline view", error);
        }
      }
      /**
       * Cleanup and unsubscribe
       */
      destroy() {
        this.unsubscribe?.();
        this.unsubscribe = void 0;
        this.statusBarItem.empty();
        logger2.info("[inbox-status-bar] Destroyed");
      }
    };
  }
});

// src/features/events/index.ts
var events_exports = {};
__export(events_exports, {
  EventHistoryStore: () => EventHistoryStore,
  ExecutingHookGateway: () => ExecutingHookGateway,
  FactionHandler: () => FactionHandler,
  HookExecutor: () => HookExecutor,
  InboxStatusBar: () => InboxStatusBar,
  LocationHandler: () => LocationHandler,
  NotificationHandler: () => NotificationHandler,
  TimelineView: () => TimelineView,
  VIEW_TYPE_TIMELINE: () => VIEW_TYPE_TIMELINE,
  WeatherHandler: () => WeatherHandler,
  createInboxItem: () => createInboxItem,
  createInboxStatusBar: () => createInboxStatusBar,
  createTriggeredEventEntry: () => createTriggeredEventEntry,
  createTriggeredPhenomenonEntry: () => createTriggeredPhenomenonEntry,
  globalEventHistoryStore: () => globalEventHistoryStore,
  isTriggeredEvent: () => isTriggeredEvent,
  isTriggeredPhenomenon: () => isTriggeredPhenomenon,
  openTimelineView: () => openTimelineView
});
var init_events = __esm({
  "src/features/events/index.ts"() {
    "use strict";
    init_hook_executor();
    init_executing_hook_gateway();
    init_event_history_store();
    init_event_history_types();
    init_timeline_view();
    init_inbox_status_bar();
    init_hooks();
  }
});

// src/workmodes/library/core/library-mode-service-port.ts
var library_mode_service_port_exports = {};
__export(library_mode_service_port_exports, {
  openLibraryModal: () => openLibraryModal
});
async function openLibraryModal(app, kind, entityName) {
  const spec = getCreateSpec(kind);
  if (!spec) {
    throw new Error(`No create spec found for entity kind: ${kind}`);
  }
  let preset = void 0;
  if (entityName) {
    const files = await listVaultPresets(app, kind);
    logger2.log(`[LibraryModal] Found ${files.length} files for ${kind}`);
    logger2.log(`[LibraryModal] Looking for entity: ${entityName}`);
    const normalizeForMatch = (str2) => str2.toLowerCase().replace(/[-\s]/g, "");
    const normalizedSearchName = normalizeForMatch(entityName);
    for (const file of files) {
      const cache = app.metadataCache.getFileCache(file);
      const fm2 = cache?.frontmatter;
      logger2.log(`[LibraryModal] Checking file: ${file.path}, hasCache: ${!!cache}, hasFrontmatter: ${!!fm2}, name: ${fm2?.name}`);
      if (fm2?.name && normalizeForMatch(fm2.name) === normalizedSearchName) {
        logger2.log(`[LibraryModal] Found match: ${fm2.name}`);
        preset = await spec.loader?.fromFrontmatter?.(fm2, file) ?? fm2;
        break;
      }
    }
    if (!preset) {
      logger2.error(`[LibraryModal] Entity not found: ${entityName} (checked ${files.length} files)`);
      throw new Error(`Entity not found: ${entityName}`);
    }
  }
  await openCreateModal(spec, {
    app,
    preset
  });
}
var init_library_mode_service_port = __esm({
  "src/workmodes/library/core/library-mode-service-port.ts"() {
    "use strict";
    init_open_create_modal();
    init_registry();
    init_vault_preset_loader();
    init_plugin_logger();
  }
});

// Presets/lib/preset-data.ts
var preset_data_exports = {};
__export(preset_data_exports, {
  PRESET_CALENDARS: () => PRESET_CALENDARS,
  PRESET_CREATURES: () => PRESET_CREATURES,
  PRESET_EQUIPMENT: () => PRESET_EQUIPMENT,
  PRESET_ITEMS: () => PRESET_ITEMS,
  PRESET_PLAYLISTS: () => PRESET_PLAYLISTS,
  PRESET_REGIONS: () => PRESET_REGIONS,
  PRESET_SPELLS: () => PRESET_SPELLS,
  PRESET_TERRAINS: () => PRESET_TERRAINS
});
var PRESET_CREATURES, PRESET_SPELLS, PRESET_ITEMS, PRESET_EQUIPMENT, PRESET_TERRAINS, PRESET_REGIONS, PRESET_CALENDARS, PRESET_PLAYLISTS;
var init_preset_data = __esm({
  "Presets/lib/preset-data.ts"() {
    "use strict";
    PRESET_CREATURES = {
      "Animals/allosaurus.md": `---
smType: creature
name: Allosaurus
size: Large
type: Beast
typeTags:
  - value: Dinosaur
alignmentOverride: Unaligned
ac: '13'
initiative: +1 (11)
hp: '51'
hitDice: 6d10 + 18
speeds:
  walk:
    distance: 60 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
passivesList:
  - skill: Perception
    value: '15'
cr: '2'
xp: '450'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 15 (2d10 + 4) Piercing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d10
          bonus: 4
          type: Piercing
          average: 15
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Claws
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 8 (1d8 + 4) Slashing damage. If the target is a Large or smaller creature and the allosaurus moved 30+ feet straight toward it immediately before the hit, the target has the Prone condition, and the allosaurus can make one Bite attack against it.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d8
          bonus: 4
          type: Slashing
          average: 8
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
        other: If the target is a Large or smaller creature and the allosaurus moved 30+ feet straight toward it immediately before the hit, the target has the Prone condition, and the allosaurus can make one Bite attack against it.
      additionalEffects: If the target is a Large or smaller creature and the allosaurus moved 30+ feet straight toward it immediately before the hit, the target has the Prone condition, and the allosaurus can make one Bite attack against it.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Allosaurus
*Large, Beast, Unaligned*

**AC** 13
**HP** 51 (6d10 + 18)
**Initiative** +1 (11)
**Speed** 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 2, PB +2, XP 450

## Actions

**Bite**
*Melee Attack Roll:* +6, reach 5 ft. 15 (2d10 + 4) Piercing damage.

**Claws**
*Melee Attack Roll:* +6, reach 5 ft. 8 (1d8 + 4) Slashing damage. If the target is a Large or smaller creature and the allosaurus moved 30+ feet straight toward it immediately before the hit, the target has the Prone condition, and the allosaurus can make one Bite attack against it.
`,
      "Animals/ankylosaurus.md": `---
smType: creature
name: Ankylosaurus
size: Huge
type: Beast
typeTags:
  - value: Dinosaur
alignmentOverride: Unaligned
ac: '15'
initiative: +0 (10)
hp: '68'
hitDice: 8d12 + 16
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 19
    saveProf: true
    saveMod: 6
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '11'
cr: '3'
xp: '700'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The ankylosaurus makes two Tail attacks.
    multiattack:
      attacks:
        - name: Tail
          count: 2
        - name: Tail
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Tail
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 10 ft. 9 (1d10 + 4) Bludgeoning damage. If the target is a Huge or smaller creature, it has the Prone condition.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d10
          bonus: 4
          type: Bludgeoning
          average: 9
      reach: 10 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Huge or smaller
        other: If the target is a Huge or smaller creature, it has the Prone condition.
      additionalEffects: If the target is a Huge or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Ankylosaurus
*Huge, Beast, Unaligned*

**AC** 15
**HP** 68 (8d12 + 16)
**Initiative** +0 (10)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 3, PB +2, XP 700

## Actions

**Multiattack**
The ankylosaurus makes two Tail attacks.

**Tail**
*Melee Attack Roll:* +6, reach 10 ft. 9 (1d10 + 4) Bludgeoning damage. If the target is a Huge or smaller creature, it has the Prone condition.
`,
      "Animals/ape.md": `---
smType: creature
name: Ape
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '19'
hitDice: 3d8 + 6
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
skills:
  - skill: Athletics
    value: '5'
  - skill: Perception
    value: '3'
passivesList:
  - skill: Perception
    value: '13'
cr: 1/2
xp: '100'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The ape makes two Fist attacks.
    multiattack:
      attacks:
        - name: Fist
          count: 2
        - name: Fist
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Fist
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d4
          bonus: 3
          type: Bludgeoning
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Rock
    entryType: attack
    text: '*Ranged Attack Roll:* +5, range 25/50 ft. 10 (2d6 + 3) Bludgeoning damage.'
    attack:
      type: ranged
      bonus: 5
      damage:
        - dice: 2d6
          bonus: 3
          type: Bludgeoning
          average: 10
      range: 25/50 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Ape
*Medium, Beast, Unaligned*

**AC** 12
**HP** 19 (3d8 + 6)
**Initiative** +2 (12)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 1/2, PB +2, XP 100

## Actions

**Multiattack**
The ape makes two Fist attacks.

**Fist**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Bludgeoning damage.

**Rock (Recharge 6)**
*Ranged Attack Roll:* +5, range 25/50 ft. 10 (2d6 + 3) Bludgeoning damage.
`,
      "Animals/archelon.md": `---
smType: creature
name: Archelon
size: Huge
type: Beast
typeTags:
  - value: Dinosaur
alignmentOverride: Unaligned
ac: '17'
initiative: +3 (13)
hp: '90'
hitDice: 12d12 + 12
speeds:
  walk:
    distance: 20 ft.
  swim:
    distance: 80 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 4
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '5'
passivesList:
  - skill: Perception
    value: '12'
cr: '4'
xp: '1100'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The archelon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The archelon makes two Bite attacks.
    multiattack:
      attacks:
        - name: Bite
          count: 2
        - name: Bite
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 14 (3d6 + 4) Piercing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 3d6
          bonus: 4
          type: Piercing
          average: 14
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Archelon
*Huge, Beast, Unaligned*

**AC** 17
**HP** 90 (12d12 + 12)
**Initiative** +3 (13)
**Speed** 20 ft., swim 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 4, PB +2, XP 1100

## Traits

**Amphibious**
The archelon can breathe air and water.

## Actions

**Multiattack**
The archelon makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +6, reach 5 ft. 14 (3d6 + 4) Piercing damage.
`,
      "Animals/baboon.md": `---
smType: creature
name: Baboon
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '3'
hitDice: 1d6
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 8
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 4
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '11'
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The baboon has Advantage on an attack roll against a creature if at least one of the baboon's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +1, reach 5 ft. 1 (1d4 - 1) Piercing damage.'
    attack:
      type: melee
      bonus: 1
      damage:
        - dice: 1d4
          bonus: 0
          type: Piercing
          average: 1
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Baboon
*Small, Beast, Unaligned*

**AC** 12
**HP** 3 (1d6)
**Initiative** +2 (12)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 0, PB +2, XP 0

## Traits

**Pack Tactics**
The baboon has Advantage on an attack roll against a creature if at least one of the baboon's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Bite**
*Melee Attack Roll:* +1, reach 5 ft. 1 (1d4 - 1) Piercing damage.
`,
      "Animals/badger.md": `---
smType: creature
name: Badger
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '11'
initiative: +0 (10)
hp: '5'
hitDice: 1d4 + 3
speeds:
  walk:
    distance: 20 ft.
  burrow:
    distance: 5 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
sensesList:
  - type: darkvision
    range: '30'
passivesList:
  - skill: Perception
    value: '13'
damageResistancesList:
  - value: Poison
cr: '0'
xp: '0'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +2, reach 5 ft. 1 Piercing damage.'
    attack:
      type: melee
      bonus: 2
      damage: []
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Badger
*Small, Beast, Unaligned*

**AC** 11
**HP** 5 (1d4 + 3)
**Initiative** +0 (10)
**Speed** 20 ft., burrow 5 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 30 ft.; Passive Perception 13
CR 0, PB +2, XP 0

## Actions

**Bite**
*Melee Attack Roll:* +2, reach 5 ft. 1 Piercing damage.
`,
      "Animals/bat.md": `---
smType: creature
name: Bat
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '1'
hitDice: 1d4 - 1
speeds:
  walk:
    distance: 5 ft.
  fly:
    distance: 30 ft.
abilities:
  - key: str
    score: 2
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 8
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 4
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '60'
passivesList:
  - skill: Perception
    value: '11'
cr: '0'
xp: '0'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4 to hit, reach 5 ft. 1 Piercing damage.'
    attack:
      type: melee
      bonus: 4
      damage: []
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Bat
*Small, Beast, Unaligned*

**AC** 12
**HP** 1 (1d4 - 1)
**Initiative** +2 (12)
**Speed** 5 ft., fly 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft.; Passive Perception 11
CR 0, PB +2, XP 0

## Actions

**Bite**
*Melee Attack Roll:* +4 to hit, reach 5 ft. 1 Piercing damage.
`,
      "Animals/black-bear.md": `---
smType: creature
name: Black Bear
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '11'
initiative: +1 (11)
hp: '19'
hitDice: 3d8 + 6
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '15'
cr: 1/2
xp: '100'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The bear makes two Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 2
        - name: Rend
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Slashing
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Black Bear
*Medium, Beast, Unaligned*

**AC** 11
**HP** 19 (3d8 + 6)
**Initiative** +1 (11)
**Speed** 30 ft., climb 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 15
CR 1/2, PB +2, XP 100

## Actions

**Multiattack**
The bear makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage.
`,
      "Animals/blood-hawk.md": `---
smType: creature
name: Blood Hawk
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '7'
hitDice: 2d6
speeds:
  walk:
    distance: 10 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 6
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '6'
passivesList:
  - skill: Perception
    value: '16'
cr: 1/8
xp: '25'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The hawk has Advantage on an attack roll against a creature if at least one of the hawk's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Beak
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage, or 6 (1d8 + 2) Piercing damage if the target is Bloodied.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d4
          bonus: 2
          type: Piercing
          average: 4
        - dice: 1d8
          bonus: 2
          type: Piercing
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Blood Hawk
*Small, Beast, Unaligned*

**AC** 12
**HP** 7 (2d6)
**Initiative** +2 (12)
**Speed** 10 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 1/8, PB +2, XP 25

## Traits

**Pack Tactics**
The hawk has Advantage on an attack roll against a creature if at least one of the hawk's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Beak**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage, or 6 (1d8 + 2) Piercing damage if the target is Bloodied.
`,
      "Animals/boar.md": `---
smType: creature
name: Boar
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '11'
initiative: +0 (10)
hp: '13'
hitDice: 2d8 + 4
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 13
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 9
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '9'
cr: 1/4
xp: '50'
entries:
  - category: trait
    name: Bloodied Fury
    entryType: special
    text: While Bloodied, the boar has Advantage on attack rolls.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Gore
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Piercing damage. If the target is a Medium or smaller creature and the boar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 3 (1d6) Piercing damage and has the Prone condition.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 1d6
          bonus: 1
          type: Piercing
          average: 4
        - dice: 1d6
          bonus: 0
          type: Piercing
          average: 3
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Medium or smaller
        other: If the target is a Medium or smaller creature and the boar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 3 (1d6) Piercing damage and has the Prone condition.
      additionalEffects: If the target is a Medium or smaller creature and the boar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 3 (1d6) Piercing damage and has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Boar
*Medium, Beast, Unaligned*

**AC** 11
**HP** 13 (2d8 + 4)
**Initiative** +0 (10)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 1/4, PB +2, XP 50

## Traits

**Bloodied Fury**
While Bloodied, the boar has Advantage on attack rolls.

## Actions

**Gore**
*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Piercing damage. If the target is a Medium or smaller creature and the boar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 3 (1d6) Piercing damage and has the Prone condition.
`,
      "Animals/brown-bear.md": `---
smType: creature
name: Brown Bear
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '11'
initiative: +1 (11)
hp: '22'
hitDice: 3d10 + 6
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
cr: '1'
xp: '200'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The bear makes one Bite attack and one Claw attack.
    multiattack:
      attacks:
        - name: Bite
          count: 1
        - name: Bite
          count: 1
        - name: Claw
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d8
          bonus: 3
          type: Piercing
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Slashing damage. If the target is a Large or smaller creature, it has the Prone condition.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d4
          bonus: 3
          type: Slashing
          average: 5
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
        other: If the target is a Large or smaller creature, it has the Prone condition.
      additionalEffects: If the target is a Large or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Brown Bear
*Large, Beast, Unaligned*

**AC** 11
**HP** 22 (3d10 + 6)
**Initiative** +1 (11)
**Speed** 40 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 13
CR 1, PB +2, XP 200

## Actions

**Multiattack**
The bear makes one Bite attack and one Claw attack.

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage.

**Claw**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Slashing damage. If the target is a Large or smaller creature, it has the Prone condition.
`,
      "Animals/camel.md": `---
smType: creature
name: Camel
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '10'
initiative: '-1 (9)'
hp: '17'
hitDice: 2d10 + 6
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 8
    saveProf: false
  - key: con
    score: 17
    saveProf: true
    saveMod: 5
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
cr: 1/8
xp: '25'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d4
          bonus: 2
          type: Bludgeoning
          average: 4
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Camel
*Large, Beast, Unaligned*

**AC** 10
**HP** 17 (2d10 + 6)
**Initiative** -1 (9)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
CR 1/8, PB +2, XP 25

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Bludgeoning damage.
`,
      "Animals/cat.md": `---
smType: creature
name: Cat
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '2'
hitDice: 1d4
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 40 ft.
abilities:
  - key: str
    score: 3
    saveProf: false
  - key: dex
    score: 15
    saveProf: true
    saveMod: 4
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
  - skill: Stealth
    value: '4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Jumper
    entryType: special
    text: The cat's jump distance is determined using its Dexterity rather than its Strength.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Scratch
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 1 Slashing damage.'
    attack:
      type: melee
      bonus: 4
      damage: []
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Cat
*Small, Beast, Unaligned*

**AC** 12
**HP** 2 (1d4)
**Initiative** +2 (12)
**Speed** 40 ft., climb 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 13
CR 0, PB +2, XP 0

## Traits

**Jumper**
The cat's jump distance is determined using its Dexterity rather than its Strength.

## Actions

**Scratch**
*Melee Attack Roll:* +4, reach 5 ft. 1 Slashing damage.
`,
      "Animals/constrictor-snake.md": `---
smType: creature
name: Constrictor Snake
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +2 (12)
hp: '13'
hitDice: 2d10 + 2
speeds:
  walk:
    distance: 30 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '2'
  - skill: Stealth
    value: '4'
sensesList:
  - type: blindsight
    range: '10'
passivesList:
  - skill: Perception
    value: '12'
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Piercing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d8
          bonus: 2
          type: Piercing
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Constrict
    entryType: save
    text: '*Strength Saving Throw*: DC 12, one Medium or smaller creature the snake can see within 5 feet. *Failure:*  7 (3d4) Bludgeoning damage, and the target has the Grappled condition (escape DC 12).'
    save:
      ability: str
      dc: 12
      targeting:
        type: single
        range: 5 ft.
        restrictions:
          size:
            - Medium
            - smaller
          visibility: true
      area: one Medium or smaller creature the snake can see within 5 feet
      onFail:
        damage:
          - dice: 3d4
            bonus: 0
            type: Bludgeoning
            average: 7
        effects:
          conditions:
            - condition: Grappled
              escape:
                type: dc
                dc: 12
          other: 7 (3d4) Bludgeoning damage, and the target has the Grappled condition (escape DC 12).
        legacyEffects: 7 (3d4) Bludgeoning damage, and the target has the Grappled condition (escape DC 12).
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Constrictor Snake
*Large, Beast, Unaligned*

**AC** 13
**HP** 13 (2d10 + 2)
**Initiative** +2 (12)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft.; Passive Perception 12
CR 1/4, PB +2, XP 50

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Piercing damage.

**Constrict**
*Strength Saving Throw*: DC 12, one Medium or smaller creature the snake can see within 5 feet. *Failure:*  7 (3d4) Bludgeoning damage, and the target has the Grappled condition (escape DC 12).
`,
      "Animals/crab.md": `---
smType: creature
name: Crab
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '11'
initiative: +0 (10)
hp: '3'
hitDice: 1d4 + 1
speeds:
  walk:
    distance: 20 ft.
  swim:
    distance: 20 ft.
abilities:
  - key: str
    score: 6
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 8
    saveProf: false
  - key: cha
    score: 2
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '2'
sensesList:
  - type: blindsight
    range: '30'
passivesList:
  - skill: Perception
    value: '9'
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The crab can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +2, reach 5 ft. 1 Bludgeoning damage.'
    attack:
      type: melee
      bonus: 2
      damage: []
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Crab
*Small, Beast, Unaligned*

**AC** 11
**HP** 3 (1d4 + 1)
**Initiative** +0 (10)
**Speed** 20 ft., swim 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft.; Passive Perception 9
CR 0, PB +2, XP 0

## Traits

**Amphibious**
The crab can breathe air and water.

## Actions

**Claw**
*Melee Attack Roll:* +2, reach 5 ft. 1 Bludgeoning damage.
`,
      "Animals/crocodile.md": `---
smType: creature
name: Crocodile
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +0 (10)
hp: '13'
hitDice: 2d10 + 2
speeds:
  walk:
    distance: 20 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 13
    saveProf: true
    saveMod: 3
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '2'
passivesList:
  - skill: Perception
    value: '10'
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Hold Breath
    entryType: special
    text: The crocodile can hold its breath for 1 hour.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Piercing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12). While Grappled, the target has the Restrained condition.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d8
          bonus: 2
          type: Piercing
          average: 6
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 12
            restrictions:
              size: Medium or smaller
              while: While Grappled, the target has the Restrained condition
          - condition: Restrained
            escape:
              type: dc
              dc: 12
            restrictions:
              size: Medium or smaller
              while: While Grappled, the target has the Restrained condition
        other: If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12). While Grappled, the target has the Restrained condition.
      additionalEffects: If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12). While Grappled, the target has the Restrained condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Crocodile
*Large, Beast, Unaligned*

**AC** 12
**HP** 13 (2d10 + 2)
**Initiative** +0 (10)
**Speed** 20 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 1/2, PB +2, XP 100

## Traits

**Hold Breath**
The crocodile can hold its breath for 1 hour.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Piercing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12). While Grappled, the target has the Restrained condition.
`,
      "Animals/deer.md": `---
smType: creature
name: Deer
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +3 (13)
hp: '4'
hitDice: 1d8
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 11
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Agile
    entryType: special
    text: The deer doesn't provoke an Opportunity Attack when it moves out of an enemy's reach.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Ram
    entryType: attack
    text: '*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 2
      damage:
        - dice: 1d4
          bonus: 0
          type: Bludgeoning
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Deer
*Medium, Beast, Unaligned*

**AC** 13
**HP** 4 (1d8)
**Initiative** +3 (13)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 14
CR 0, PB +2, XP 0

## Traits

**Agile**
The deer doesn't provoke an Opportunity Attack when it moves out of an enemy's reach.

## Actions

**Ram**
*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Bludgeoning damage.
`,
      "Animals/dire-wolf.md": `---
smType: creature
name: Dire Wolf
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '14'
initiative: +2 (12)
hp: '22'
hitDice: 3d10 + 6
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
  - skill: Stealth
    value: '4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '15'
cr: '1'
xp: '200'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The wolf has Advantage on an attack roll against a creature if at least one of the wolf's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Piercing damage. If the target is a Large or smaller creature, it has the Prone condition.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d10
          bonus: 3
          type: Piercing
          average: 8
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
        other: If the target is a Large or smaller creature, it has the Prone condition.
      additionalEffects: If the target is a Large or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Dire Wolf
*Large, Beast, Unaligned*

**AC** 14
**HP** 22 (3d10 + 6)
**Initiative** +2 (12)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 15
CR 1, PB +2, XP 200

## Traits

**Pack Tactics**
The wolf has Advantage on an attack roll against a creature if at least one of the wolf's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Piercing damage. If the target is a Large or smaller creature, it has the Prone condition.
`,
      "Animals/draft-horse.md": `---
smType: creature
name: Draft Horse
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '10'
initiative: +0 (10)
hp: '15'
hitDice: 2d10 + 4
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Hooves
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 6 (1d4 + 4) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d4
          bonus: 4
          type: Bludgeoning
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Draft Horse
*Large, Beast, Unaligned*

**AC** 10
**HP** 15 (2d10 + 4)
**Initiative** +0 (10)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 1/4, PB +2, XP 50

## Actions

**Hooves**
*Melee Attack Roll:* +6, reach 5 ft. 6 (1d4 + 4) Bludgeoning damage.
`,
      "Animals/eagle.md": `---
smType: creature
name: Eagle
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '4'
hitDice: 1d6 + 1
speeds:
  walk:
    distance: 10 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 6
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '6'
passivesList:
  - skill: Perception
    value: '16'
cr: '0'
xp: '0'
entries:
  - category: action
    name: Talons
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 feet. 4 (1d4 + 2) Slashing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d4
          bonus: 2
          type: Slashing
          average: 4
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Eagle
*Small, Beast, Unaligned*

**AC** 12
**HP** 4 (1d6 + 1)
**Initiative** +2 (12)
**Speed** 10 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 0, PB +2, XP 0

## Actions

**Talons**
*Melee Attack Roll:* +4, reach 5 feet. 4 (1d4 + 2) Slashing damage.
`,
      "Animals/elephant.md": `---
smType: creature
name: Elephant
size: Huge
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: '-1 (9)'
hp: '76'
hitDice: 8d12 + 24
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 22
    saveProf: false
  - key: dex
    score: 9
    saveProf: false
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
cr: '4'
xp: '1100'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The elephant makes two Gore attacks.
    multiattack:
      attacks:
        - name: Gore
          count: 2
        - name: Gore
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Gore
    entryType: attack
    text: '*Melee Attack Roll:* +8, reach 5 ft. 15 (2d8 + 6) Piercing damage. If the target is a Huge or smaller creature and the elephant moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.'
    attack:
      type: melee
      bonus: 8
      damage:
        - dice: 2d8
          bonus: 6
          type: Piercing
          average: 15
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Huge or smaller
        other: If the target is a Huge or smaller creature and the elephant moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.
      additionalEffects: If the target is a Huge or smaller creature and the elephant moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Trample
    entryType: save
    text: '*Dexterity Saving Throw*: DC 16, one creature within 5 feet that has the Prone condition. *Failure:*  17 (2d10 + 6) Bludgeoning damage. *Success:*  Half damage.'
    save:
      ability: dex
      dc: 16
      targeting:
        type: single
        range: 5 ft.
        restrictions:
          conditions:
            - Prone
      area: one creature within 5 feet that has the Prone condition
      onFail:
        damage:
          - dice: 2d10
            bonus: 6
            type: Bludgeoning
            average: 17
        effects:
          other: 17 (2d10 + 6) Bludgeoning damage.
        legacyEffects: 17 (2d10 + 6) Bludgeoning damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Elephant
*Huge, Beast, Unaligned*

**AC** 12
**HP** 76 (8d12 + 24)
**Initiative** -1 (9)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 4, PB +2, XP 1100

## Actions

**Multiattack**
The elephant makes two Gore attacks.

**Gore**
*Melee Attack Roll:* +8, reach 5 ft. 15 (2d8 + 6) Piercing damage. If the target is a Huge or smaller creature and the elephant moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.

## Bonus Actions

**Trample**
*Dexterity Saving Throw*: DC 16, one creature within 5 feet that has the Prone condition. *Failure:*  17 (2d10 + 6) Bludgeoning damage. *Success:*  Half damage.
`,
      "Animals/elk.md": `---
smType: creature
name: Elk
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '10'
initiative: +0 (10)
hp: '11'
hitDice: 2d10
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '12'
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Ram
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage. If the target is a Large or smaller creature and the elk moved 20+ feet straight toward it immediately before the hit, the target takes an extra 3 (1d6) Bludgeoning damage and has the Prone condition.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d6
          bonus: 3
          type: Bludgeoning
          average: 6
        - dice: 1d6
          bonus: 0
          type: Bludgeoning
          average: 3
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
        other: If the target is a Large or smaller creature and the elk moved 20+ feet straight toward it immediately before the hit, the target takes an extra 3 (1d6) Bludgeoning damage and has the Prone condition.
      additionalEffects: If the target is a Large or smaller creature and the elk moved 20+ feet straight toward it immediately before the hit, the target takes an extra 3 (1d6) Bludgeoning damage and has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Elk
*Large, Beast, Unaligned*

**AC** 10
**HP** 11 (2d10)
**Initiative** +0 (10)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 12
CR 1/4, PB +2, XP 50

## Actions

**Ram**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage. If the target is a Large or smaller creature and the elk moved 20+ feet straight toward it immediately before the hit, the target takes an extra 3 (1d6) Bludgeoning damage and has the Prone condition.
`,
      "Animals/flying-snake.md": `---
smType: creature
name: Flying Snake
size: Small
type: Monstrosity
alignmentOverride: Unaligned
ac: '14'
initiative: +2 (12)
hp: '5'
hitDice: 2d4
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 60 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 4
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '10'
passivesList:
  - skill: Perception
    value: '11'
cr: 1/8
xp: '25'
entries:
  - category: trait
    name: Flyby
    entryType: special
    text: The snake doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 1 Piercing damage plus 5 (2d4) Poison damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 2d4
          bonus: 0
          type: Poison
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Flying Snake
*Small, Monstrosity, Unaligned*

**AC** 14
**HP** 5 (2d4)
**Initiative** +2 (12)
**Speed** 30 ft., swim 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft.; Passive Perception 11
CR 1/8, PB +2, XP 25

## Traits

**Flyby**
The snake doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 1 Piercing damage plus 5 (2d4) Poison damage.
`,
      "Animals/frog.md": `---
smType: creature
name: Frog
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '11'
initiative: +1 (11)
hp: '1'
hitDice: 1d4 - 1
speeds:
  walk:
    distance: 20 ft.
  swim:
    distance: 20 ft.
abilities:
  - key: str
    score: 1
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 8
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 8
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '1'
  - skill: Stealth
    value: '3'
sensesList:
  - type: darkvision
    range: '30'
passivesList:
  - skill: Perception
    value: '11'
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The frog can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Standing Leap
    entryType: special
    text: The frog's Long Jump is up to 10 feet and its High Jump is up to 5 feet with or without a running start.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 1 Piercing damage.'
    attack:
      type: melee
      bonus: 3
      damage: []
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Frog
*Small, Beast, Unaligned*

**AC** 11
**HP** 1 (1d4 - 1)
**Initiative** +1 (11)
**Speed** 20 ft., swim 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 30 ft.; Passive Perception 11
CR 0, PB +2, XP 0

## Traits

**Amphibious**
The frog can breathe air and water.

**Standing Leap**
The frog's Long Jump is up to 10 feet and its High Jump is up to 5 feet with or without a running start.

## Actions

**Bite**
*Melee Attack Roll:* +3, reach 5 ft. 1 Piercing damage.
`,
      "Animals/giant-ape.md": `---
smType: creature
name: Giant Ape
size: Huge
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +5 (15)
hp: '168'
hitDice: 16d12 + 64
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 40 ft.
abilities:
  - key: str
    score: 23
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 18
    saveProf: false
  - key: int
    score: 5
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+3'
skills:
  - skill: Athletics
    value: '9'
  - skill: Perception
    value: '4'
  - skill: Survival
    value: '4'
passivesList:
  - skill: Perception
    value: '14'
cr: '7'
xp: '2900'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The ape makes two Fist attacks.
    multiattack:
      attacks:
        - name: Fist
          count: 2
        - name: Fist
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Fist
    entryType: attack
    text: '*Melee Attack Roll:* +9, reach 10 ft. 22 (3d10 + 6) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 9
      damage:
        - dice: 3d10
          bonus: 6
          type: Bludgeoning
          average: 22
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Boulder Toss
    entryType: save
    text: 'The ape hurls a boulder at a point it can see within 90 feet. *Dexterity Saving Throw*: DC 17, each creature in a 5-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on that point. *Failure:*  24 (7d6) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition. *Success:*  Half damage only.'
    save:
      ability: dex
      dc: 17
      targeting:
        shape: sphere
        size: 5 ft.
        description: each creature in a 5-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on that point
      area: each creature in a 5-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on that point
      onFail:
        damage:
          - dice: 7d6
            bonus: 0
            type: Bludgeoning
            average: 24
        effects:
          conditions:
            - condition: Prone
              restrictions:
                size: Large or smaller
          other: 24 (7d6) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.
        legacyEffects: 24 (7d6) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.
      onSuccess:
        damage: half
        legacyText: Half damage only.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Leap
    entryType: special
    text: The ape jumps up to 30 feet by spending 10 feet of movement.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Giant Ape
*Huge, Beast, Unaligned*

**AC** 12
**HP** 168 (16d12 + 64)
**Initiative** +5 (15)
**Speed** 40 ft., climb 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 7, PB +3, XP 2900

## Actions

**Multiattack**
The ape makes two Fist attacks.

**Fist**
*Melee Attack Roll:* +9, reach 10 ft. 22 (3d10 + 6) Bludgeoning damage.

**Boulder Toss (Recharge 6)**
The ape hurls a boulder at a point it can see within 90 feet. *Dexterity Saving Throw*: DC 17, each creature in a 5-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on that point. *Failure:*  24 (7d6) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition. *Success:*  Half damage only.

## Bonus Actions

**Leap**
The ape jumps up to 30 feet by spending 10 feet of movement.
`,
      "Animals/giant-badger.md": `---
smType: creature
name: Giant Badger
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +0 (10)
hp: '15'
hitDice: 2d8 + 6
speeds:
  walk:
    distance: 30 ft.
  burrow:
    distance: 10 ft.
abilities:
  - key: str
    score: 13
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
damageResistancesList:
  - value: Poison
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 6 (2d4 + 1) Piercing damage.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 2d4
          bonus: 1
          type: Piercing
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Badger
*Medium, Beast, Unaligned*

**AC** 13
**HP** 15 (2d8 + 6)
**Initiative** +0 (10)
**Speed** 30 ft., burrow 10 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 13
CR 1/4, PB +2, XP 50

## Actions

**Bite**
*Melee Attack Roll:* +3, reach 5 ft. 6 (2d4 + 1) Piercing damage.
`,
      "Animals/giant-bat.md": `---
smType: creature
name: Giant Bat
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +3 (13)
hp: '22'
hitDice: 4d10
speeds:
  walk:
    distance: 10 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '120'
passivesList:
  - skill: Perception
    value: '11'
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Piercing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d6
          bonus: 3
          type: Piercing
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Bat
*Large, Beast, Unaligned*

**AC** 13
**HP** 22 (4d10)
**Initiative** +3 (13)
**Speed** 10 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 120 ft.; Passive Perception 11
CR 1/4, PB +2, XP 50

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Piercing damage.
`,
      "Animals/giant-boar.md": `---
smType: creature
name: Giant Boar
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +0 (10)
hp: '42'
hitDice: 5d10 + 15
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 17
    saveProf: true
    saveMod: 5
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 7
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '8'
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Bloodied Fury
    entryType: special
    text: The boar has Advantage on melee attack rolls while it is Bloodied.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Gore
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Piercing damage. If the target is a Large or smaller creature and the boar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 7 (2d6) Piercing damage and has the Prone condition.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d6
          bonus: 3
          type: Piercing
          average: 10
        - dice: 2d6
          bonus: 0
          type: Piercing
          average: 7
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
        other: If the target is a Large or smaller creature and the boar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 7 (2d6) Piercing damage and has the Prone condition.
      additionalEffects: If the target is a Large or smaller creature and the boar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 7 (2d6) Piercing damage and has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Boar
*Large, Beast, Unaligned*

**AC** 13
**HP** 42 (5d10 + 15)
**Initiative** +0 (10)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 2, PB +2, XP 450

## Traits

**Bloodied Fury**
The boar has Advantage on melee attack rolls while it is Bloodied.

## Actions

**Gore**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Piercing damage. If the target is a Large or smaller creature and the boar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 7 (2d6) Piercing damage and has the Prone condition.
`,
      "Animals/giant-centipede.md": `---
smType: creature
name: Giant Centipede
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '14'
initiative: +2 (12)
hp: '9'
hitDice: 2d6 + 2
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 5
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 7
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '30'
passivesList:
  - skill: Perception
    value: '8'
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage, and the target has the Poisoned condition until the start of the centipede''s next turn.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d4
          bonus: 2
          type: Piercing
          average: 4
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Centipede
*Small, Beast, Unaligned*

**AC** 14
**HP** 9 (2d6 + 2)
**Initiative** +2 (12)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft.; Passive Perception 8
CR 1/4, PB +2, XP 50

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage, and the target has the Poisoned condition until the start of the centipede's next turn.
`,
      "Animals/giant-constrictor-snake.md": `---
smType: creature
name: Giant Constrictor Snake
size: Huge
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '60'
hitDice: 8d12 + 8
speeds:
  walk:
    distance: 30 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '2'
sensesList:
  - type: blindsight
    range: '10'
passivesList:
  - skill: Perception
    value: '12'
cr: '2'
xp: '450'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The snake makes one Bite attack and uses Constrict.
    multiattack:
      attacks:
        - name: Bite
          count: 1
        - name: Bite
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 10 ft. 11 (2d6 + 4) Piercing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d6
          bonus: 4
          type: Piercing
          average: 11
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Constrict
    entryType: save
    text: '*Strength Saving Throw*: DC 14, one Large or smaller creature the snake can see within 10 feet. *Failure:*  13 (2d8 + 4) Bludgeoning damage, and the target has the Grappled condition (escape DC 14).'
    save:
      ability: str
      dc: 14
      targeting:
        type: single
        range: 10 ft.
        restrictions:
          size:
            - Large
            - smaller
          visibility: true
      area: one Large or smaller creature the snake can see within 10 feet
      onFail:
        damage:
          - dice: 2d8
            bonus: 4
            type: Bludgeoning
            average: 13
        effects:
          conditions:
            - condition: Grappled
              escape:
                type: dc
                dc: 14
          other: 13 (2d8 + 4) Bludgeoning damage, and the target has the Grappled condition (escape DC 14).
        legacyEffects: 13 (2d8 + 4) Bludgeoning damage, and the target has the Grappled condition (escape DC 14).
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Constrictor Snake
*Huge, Beast, Unaligned*

**AC** 12
**HP** 60 (8d12 + 8)
**Initiative** +2 (12)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft.; Passive Perception 12
CR 2, PB +2, XP 450

## Actions

**Multiattack**
The snake makes one Bite attack and uses Constrict.

**Bite**
*Melee Attack Roll:* +6, reach 10 ft. 11 (2d6 + 4) Piercing damage.

**Constrict**
*Strength Saving Throw*: DC 14, one Large or smaller creature the snake can see within 10 feet. *Failure:*  13 (2d8 + 4) Bludgeoning damage, and the target has the Grappled condition (escape DC 14).
`,
      "Animals/giant-crab.md": `---
smType: creature
name: Giant Crab
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '15'
initiative: +1 (11)
hp: '13'
hitDice: 3d8
speeds:
  walk:
    distance: 30 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 13
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 9
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '3'
sensesList:
  - type: blindsight
    range: '30'
passivesList:
  - skill: Perception
    value: '9'
cr: 1/8
xp: '25'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The crab can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 11) from one of two claws.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 1d6
          bonus: 1
          type: Bludgeoning
          average: 4
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 11
            restrictions:
              size: Medium or smaller
        other: If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 11) from one of two claws.
      additionalEffects: If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 11) from one of two claws.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Crab
*Medium, Beast, Unaligned*

**AC** 15
**HP** 13 (3d8)
**Initiative** +1 (11)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft.; Passive Perception 9
CR 1/8, PB +2, XP 25

## Traits

**Amphibious**
The crab can breathe air and water.

## Actions

**Claw**
*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 11) from one of two claws.
`,
      "Animals/giant-crocodile.md": `---
smType: creature
name: Giant Crocodile
size: Huge
type: Beast
alignmentOverride: Unaligned
ac: '14'
initiative: '-1 (9)'
hp: '85'
hitDice: 9d12 + 27
speeds:
  walk:
    distance: 30 ft.
  swim:
    distance: 50 ft.
abilities:
  - key: str
    score: 21
    saveProf: false
  - key: dex
    score: 9
    saveProf: false
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+3'
skills:
  - skill: Stealth
    value: '5'
passivesList:
  - skill: Perception
    value: '10'
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Hold Breath
    entryType: special
    text: The crocodile can hold its breath for 1 hour.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The crocodile makes one Bite attack and one Tail attack.
    multiattack:
      attacks:
        - name: Bite
          count: 1
        - name: Bite
          count: 1
        - name: Tail
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +8, reach 5 ft. 21 (3d10 + 5) Piercing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 15). While Grappled, the target has the Restrained condition and can''t be targeted by the crocodile''s Tail.'
    attack:
      type: melee
      bonus: 8
      damage:
        - dice: 3d10
          bonus: 5
          type: Piercing
          average: 21
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 15
            restrictions:
              size: Large or smaller
              while: While Grappled, the target has the Restrained condition
          - condition: Restrained
            escape:
              type: dc
              dc: 15
            restrictions:
              size: Large or smaller
              while: While Grappled, the target has the Restrained condition
        other: If the target is a Large or smaller creature, it has the Grappled condition (escape DC 15). While Grappled, the target has the Restrained condition and can't be targeted by the crocodile's Tail.
      additionalEffects: If the target is a Large or smaller creature, it has the Grappled condition (escape DC 15). While Grappled, the target has the Restrained condition and can't be targeted by the crocodile's Tail.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Tail
    entryType: attack
    text: '*Melee Attack Roll:* +8, reach 10 ft. 18 (3d8 + 5) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.'
    attack:
      type: melee
      bonus: 8
      damage:
        - dice: 3d8
          bonus: 5
          type: Bludgeoning
          average: 18
      reach: 10 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
        other: If the target is a Large or smaller creature, it has the Prone condition.
      additionalEffects: If the target is a Large or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Crocodile
*Huge, Beast, Unaligned*

**AC** 14
**HP** 85 (9d12 + 27)
**Initiative** -1 (9)
**Speed** 30 ft., swim 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 5, PB +3, XP 1800

## Traits

**Hold Breath**
The crocodile can hold its breath for 1 hour.

## Actions

**Multiattack**
The crocodile makes one Bite attack and one Tail attack.

**Bite**
*Melee Attack Roll:* +8, reach 5 ft. 21 (3d10 + 5) Piercing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 15). While Grappled, the target has the Restrained condition and can't be targeted by the crocodile's Tail.

**Tail**
*Melee Attack Roll:* +8, reach 10 ft. 18 (3d8 + 5) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.
`,
      "Animals/giant-eagle.md": `---
smType: creature
name: Giant Eagle
size: Large
type: Celestial
alignmentLawChaos: Neutral
alignmentGoodEvil: Good
ac: '13'
initiative: +3 (13)
hp: '26'
hitDice: 4d10 + 4
speeds:
  walk:
    distance: 10 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 17
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 8
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 10
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '6'
passivesList:
  - skill: Perception
    value: '16'
languagesList:
  - value: Celestial
  - value: understands Common and Primordial (Auran) but can't speak them
damageResistancesList:
  - value: Necrotic
  - value: Radiant
cr: '1'
xp: '200'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The eagle makes two Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 2
        - name: Rend
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Slashing damage plus 3 (1d6) Radiant damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d4
          bonus: 3
          type: Slashing
          average: 5
        - dice: 1d6
          bonus: 0
          type: Radiant
          average: 3
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Eagle
*Large, Celestial, Neutral Good*

**AC** 13
**HP** 26 (4d10 + 4)
**Initiative** +3 (13)
**Speed** 10 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Celestial, understands Common and Primordial (Auran) but can't speak them
CR 1, PB +2, XP 200

## Actions

**Multiattack**
The eagle makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Slashing damage plus 3 (1d6) Radiant damage.
`,
      "Animals/giant-elk.md": `---
smType: creature
name: Giant Elk
size: Huge
type: Celestial
alignmentLawChaos: Neutral
alignmentGoodEvil: Good
ac: '14'
initiative: +6 (16)
hp: '42'
hitDice: 5d12 + 10
speeds:
  walk:
    distance: 60 ft.
abilities:
  - key: str
    score: 19
    saveProf: true
    saveMod: 6
  - key: dex
    score: 18
    saveProf: true
    saveMod: 6
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 7
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 10
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
sensesList:
  - type: darkvision
    range: '90'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Celestial
  - value: understands Common
  - value: Elvish
  - value: And Sylvan but can't speak them
damageResistancesList:
  - value: Necrotic
  - value: Radiant
cr: '2'
xp: '450'
entries:
  - category: action
    name: Ram
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 10 ft. 11 (2d6 + 4) Bludgeoning damage plus 5 (2d4) Radiant damage. If the target is a Huge or smaller creature and the elk moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d6
          bonus: 4
          type: Bludgeoning
          average: 11
        - dice: 2d4
          bonus: 0
          type: Radiant
          average: 5
        - dice: 2d4
          bonus: 0
          type: Bludgeoning
          average: 5
      reach: 10 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Huge or smaller
        other: If the target is a Huge or smaller creature and the elk moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.
      additionalEffects: If the target is a Huge or smaller creature and the elk moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Elk
*Huge, Celestial, Neutral Good*

**AC** 14
**HP** 42 (5d12 + 10)
**Initiative** +6 (16)
**Speed** 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 90 ft.; Passive Perception 14
**Languages** Celestial, understands Common, Elvish, And Sylvan but can't speak them
CR 2, PB +2, XP 450

## Actions

**Ram**
*Melee Attack Roll:* +6, reach 10 ft. 11 (2d6 + 4) Bludgeoning damage plus 5 (2d4) Radiant damage. If the target is a Huge or smaller creature and the elk moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.
`,
      "Animals/giant-fire-beetle.md": `---
smType: creature
name: Giant Fire Beetle
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +0 (10)
hp: '4'
hitDice: 1d6 + 1
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 8
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 7
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '30'
passivesList:
  - skill: Perception
    value: '8'
damageResistancesList:
  - value: Fire
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Illumination
    entryType: special
    text: The beetle sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +1, reach 5 ft. 1 Fire damage.'
    attack:
      type: melee
      bonus: 1
      damage: []
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Fire Beetle
*Small, Beast, Unaligned*

**AC** 13
**HP** 4 (1d6 + 1)
**Initiative** +0 (10)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft.; Passive Perception 8
CR 0, PB +2, XP 0

## Traits

**Illumination**
The beetle sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.

## Actions

**Bite**
*Melee Attack Roll:* +1, reach 5 ft. 1 Fire damage.
`,
      "Animals/giant-frog.md": `---
smType: creature
name: Giant Frog
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '11'
initiative: +1 (11)
hp: '18'
hitDice: 4d8
speeds:
  walk:
    distance: 30 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 12
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '2'
  - skill: Stealth
    value: '4'
sensesList:
  - type: darkvision
    range: '30'
passivesList:
  - skill: Perception
    value: '12'
cr: 1/4
xp: '50'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The frog can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Standing Leap
    entryType: special
    text: The frog's Long Jump is up to 20 feet and its High Jump is up to 10 feet with or without a running start.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 5 (1d6 + 2) Piercing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 11).'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 1d6
          bonus: 2
          type: Piercing
          average: 5
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 11
            restrictions:
              size: Medium or smaller
        other: If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 11).
      additionalEffects: If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 11).
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Swallow
    entryType: special
    text: The frog swallows a Small or smaller target it is grappling. While swallowed, the target isn't Grappled but has the Blinded and Restrained conditions, and it has Cover|XPHB|Total Cover against attacks and other effects outside the frog. While swallowing the target, the frog can't use Bite, and if the frog dies, the swallowed target is no longer Restrained and can escape from the corpse using 5 feet of movement, exiting with the Prone condition. At the end of the frog's next turn, the swallowed target takes 5 (2d4) Acid damage. If that damage doesn't kill it, the frog disgorges it, causing it to exit Prone.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Frog
*Medium, Beast, Unaligned*

**AC** 11
**HP** 18 (4d8)
**Initiative** +1 (11)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 30 ft.; Passive Perception 12
CR 1/4, PB +2, XP 50

## Traits

**Amphibious**
The frog can breathe air and water.

**Standing Leap**
The frog's Long Jump is up to 20 feet and its High Jump is up to 10 feet with or without a running start.

## Actions

**Bite**
*Melee Attack Roll:* +3, reach 5 ft. 5 (1d6 + 2) Piercing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 11).

**Swallow**
The frog swallows a Small or smaller target it is grappling. While swallowed, the target isn't Grappled but has the Blinded and Restrained conditions, and it has Cover|XPHB|Total Cover against attacks and other effects outside the frog. While swallowing the target, the frog can't use Bite, and if the frog dies, the swallowed target is no longer Restrained and can escape from the corpse using 5 feet of movement, exiting with the Prone condition. At the end of the frog's next turn, the swallowed target takes 5 (2d4) Acid damage. If that damage doesn't kill it, the frog disgorges it, causing it to exit Prone.
`,
      "Animals/giant-goat.md": `---
smType: creature
name: Giant Goat
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '11'
initiative: +1 (11)
hp: '19'
hitDice: 3d10 + 3
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 17
    saveProf: true
    saveMod: 5
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
cr: 1/2
xp: '100'
entries:
  - category: action
    name: Ram
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage. If the target is a Large or smaller creature and the goat moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d6
          bonus: 3
          type: Bludgeoning
          average: 6
        - dice: 2d4
          bonus: 0
          type: Bludgeoning
          average: 5
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
        other: If the target is a Large or smaller creature and the goat moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.
      additionalEffects: If the target is a Large or smaller creature and the goat moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Goat
*Large, Beast, Unaligned*

**AC** 11
**HP** 19 (3d10 + 3)
**Initiative** +1 (11)
**Speed** 40 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 13
CR 1/2, PB +2, XP 100

## Actions

**Ram**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage. If the target is a Large or smaller creature and the goat moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.
`,
      "Animals/giant-hyena.md": `---
smType: creature
name: Giant Hyena
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '45'
hitDice: 6d10 + 12
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
cr: '1'
xp: '200'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Piercing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d6
          bonus: 3
          type: Piercing
          average: 10
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Rampage (1/Day)
    entryType: multiattack
    text: Immediately after dealing damage to a creature that was already Bloodied, the hyena can move up to half its Speed, and it makes one Bite attack.
    limitedUse:
      count: 1
      reset: day
    multiattack:
      attacks:
        - name: Bite
          count: 1
        - name: Bite
          count: 1
      substitutions: []
    trigger.activation: bonus
    trigger.targeting:
      type: self
---

# Giant Hyena
*Large, Beast, Unaligned*

**AC** 12
**HP** 45 (6d10 + 12)
**Initiative** +2 (12)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 13
CR 1, PB +2, XP 200

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Piercing damage.

## Bonus Actions

**Rampage (1/Day)**
Immediately after dealing damage to a creature that was already Bloodied, the hyena can move up to half its Speed, and it makes one Bite attack.
`,
      "Animals/giant-lizard.md": `---
smType: creature
name: Giant Lizard
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +1 (11)
hp: '19'
hitDice: 3d10 + 3
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 40 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 12
    saveProf: true
    saveMod: 3
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
cr: 1/4
xp: '50'
entries:
  - category: trait
    name: Spider Climb
    entryType: special
    text: The lizard can climb difficult surfaces, including along ceilings, without needing to make an ability check.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Piercing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d8
          bonus: 2
          type: Piercing
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Lizard
*Large, Beast, Unaligned*

**AC** 12
**HP** 19 (3d10 + 3)
**Initiative** +1 (11)
**Speed** 40 ft., climb 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
CR 1/4, PB +2, XP 50

## Traits

**Spider Climb**
The lizard can climb difficult surfaces, including along ceilings, without needing to make an ability check.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Piercing damage.
`,
      "Animals/giant-octopus.md": `---
smType: creature
name: Giant Octopus
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '11'
initiative: +1 (11)
hp: '45'
hitDice: 7d10 + 7
speeds:
  walk:
    distance: 10 ft.
  swim:
    distance: 60 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 5
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 4
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
cr: '1'
xp: '200'
entries:
  - category: trait
    name: Water Breathing
    entryType: special
    text: The octopus can breathe only underwater. It can hold its breath for 1 hour outside water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Tentacles
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 10 ft. 10 (2d6 + 3) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 13) from all eight tentacles. While Grappled, the target has the Restrained condition.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d6
          bonus: 3
          type: Bludgeoning
          average: 10
      reach: 10 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 13
            restrictions:
              size: Medium or smaller
              while: While Grappled, the target has the Restrained condition
          - condition: Restrained
            escape:
              type: dc
              dc: 13
            restrictions:
              size: Medium or smaller
              while: While Grappled, the target has the Restrained condition
        other: If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 13) from all eight tentacles. While Grappled, the target has the Restrained condition.
      additionalEffects: If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 13) from all eight tentacles. While Grappled, the target has the Restrained condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Octopus
*Large, Beast, Unaligned*

**AC** 11
**HP** 45 (7d10 + 7)
**Initiative** +1 (11)
**Speed** 10 ft., swim 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 14
CR 1, PB +2, XP 200

## Traits

**Water Breathing**
The octopus can breathe only underwater. It can hold its breath for 1 hour outside water.

## Actions

**Tentacles**
*Melee Attack Roll:* +5, reach 10 ft. 10 (2d6 + 3) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 13) from all eight tentacles. While Grappled, the target has the Restrained condition.
`,
      "Animals/giant-owl.md": `---
smType: creature
name: Giant Owl
size: Large
type: Celestial
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '12'
initiative: +2 (12)
hp: '19'
hitDice: 3d10 + 3
speeds:
  walk:
    distance: 5 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 13
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 14
    saveProf: true
    saveMod: 4
  - key: cha
    score: 10
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '6'
  - skill: Stealth
    value: '6'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '16'
languagesList:
  - value: Celestial
  - value: understands Common
  - value: Elvish
  - value: And Sylvan but can't speak them
damageResistancesList:
  - value: Necrotic
  - value: Radiant
cr: 1/4
xp: '50'
entries:
  - category: trait
    name: Flyby
    entryType: special
    text: The owl doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Talons
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d10
          bonus: 2
          type: Slashing
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The owl casts one of the following spells, requiring no spell components and using Wisdom as the spellcasting ability: - **At Will:** *Detect Evil and Good*, *Detect Magic* - **1/Day Each:** *Clairvoyance*'
    spellcasting:
      ability: wis
      spellLists:
        - frequency: at-will
          spells:
            - Detect Evil and Good
            - Detect Magic
        - frequency: 1/day
          spells:
            - Clairvoyance
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Owl
*Large, Celestial, Neutral Neutral*

**AC** 12
**HP** 19 (3d10 + 3)
**Initiative** +2 (12)
**Speed** 5 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 16
**Languages** Celestial, understands Common, Elvish, And Sylvan but can't speak them
CR 1/4, PB +2, XP 50

## Traits

**Flyby**
The owl doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.

## Actions

**Talons**
*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage.

**Spellcasting**
The owl casts one of the following spells, requiring no spell components and using Wisdom as the spellcasting ability: - **At Will:** *Detect Evil and Good*, *Detect Magic* - **1/Day Each:** *Clairvoyance*
`,
      "Animals/giant-rat.md": `---
smType: creature
name: Giant Rat
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +3 (13)
hp: '7'
hitDice: 2d6
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 7
    saveProf: false
  - key: dex
    score: 16
    saveProf: true
    saveMod: 5
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 4
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '12'
cr: 1/8
xp: '25'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The rat has Advantage on an attack roll against a creature if at least one of the rat's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 feet. 5 (1d4 + 3) Piercing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d4
          bonus: 3
          type: Piercing
          average: 5
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Rat
*Small, Beast, Unaligned*

**AC** 13
**HP** 7 (2d6)
**Initiative** +3 (13)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 12
CR 1/8, PB +2, XP 25

## Traits

**Pack Tactics**
The rat has Advantage on an attack roll against a creature if at least one of the rat's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 feet. 5 (1d4 + 3) Piercing damage.
`,
      "Animals/giant-scorpion.md": `---
smType: creature
name: Giant Scorpion
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '15'
initiative: +1 (11)
hp: '52'
hitDice: 7d10 + 14
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 9
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '60'
passivesList:
  - skill: Perception
    value: '9'
cr: '3'
xp: '700'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The scorpion makes two Claw attacks and one Sting attack.
    multiattack:
      attacks:
        - name: Claw
          count: 2
        - name: Claw
          count: 2
        - name: Sting
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13) from one of two claws.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d6
          bonus: 3
          type: Bludgeoning
          average: 6
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 13
            restrictions:
              size: Large or smaller
        other: If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13) from one of two claws.
      additionalEffects: If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13) from one of two claws.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Sting
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage plus 11 (2d10) Poison damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d8
          bonus: 3
          type: Piercing
          average: 7
        - dice: 2d10
          bonus: 0
          type: Poison
          average: 11
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Scorpion
*Large, Beast, Unaligned*

**AC** 15
**HP** 52 (7d10 + 14)
**Initiative** +1 (11)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft.; Passive Perception 9
CR 3, PB +2, XP 700

## Actions

**Multiattack**
The scorpion makes two Claw attacks and one Sting attack.

**Claw**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13) from one of two claws.

**Sting**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage plus 11 (2d10) Poison damage.
`,
      "Animals/giant-seahorse.md": `---
smType: creature
name: Giant Seahorse
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '14'
initiative: +1 (11)
hp: '16'
hitDice: 3d10
speeds:
  walk:
    distance: 5 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '11'
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Water Breathing
    entryType: special
    text: The seahorse can breathe only underwater.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Ram
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 9 (2d6 + 2) Bludgeoning damage, or 11 (2d8 + 2) Bludgeoning damage if the seahorse moved 20+ feet straight toward the target immediately before the hit.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 2d6
          bonus: 2
          type: Bludgeoning
          average: 9
        - dice: 2d8
          bonus: 2
          type: Bludgeoning
          average: 11
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Bubble Dash
    entryType: special
    text: While underwater, the seahorse moves up to half its Swim Speed without provoking Opportunity Attacks.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Giant Seahorse
*Large, Beast, Unaligned*

**AC** 14
**HP** 16 (3d10)
**Initiative** +1 (11)
**Speed** 5 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 1/2, PB +2, XP 100

## Traits

**Water Breathing**
The seahorse can breathe only underwater.

## Actions

**Ram**
*Melee Attack Roll:* +4, reach 5 ft. 9 (2d6 + 2) Bludgeoning damage, or 11 (2d8 + 2) Bludgeoning damage if the seahorse moved 20+ feet straight toward the target immediately before the hit.

## Bonus Actions

**Bubble Dash**
While underwater, the seahorse moves up to half its Swim Speed without provoking Opportunity Attacks.
`,
      "Animals/giant-shark.md": `---
smType: creature
name: Giant Shark
size: Huge
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +3 (13)
hp: '92'
hitDice: 8d12 + 40
speeds:
  walk:
    distance: 5 ft.
  swim:
    distance: 60 ft.
abilities:
  - key: str
    score: 23
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 21
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '3'
sensesList:
  - type: blindsight
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Water Breathing
    entryType: special
    text: The shark can breathe only underwater.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The shark makes two Bite attacks.
    multiattack:
      attacks:
        - name: Bite
          count: 2
        - name: Bite
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +9 (with Advantage if the target doesn''t have all its Hit Points), reach 5 ft. 22 (3d10 + 6) Piercing damage.'
    attack:
      type: melee
      bonus: 9
      damage:
        - dice: 3d10
          bonus: 6
          type: Piercing
          average: 22
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Shark
*Huge, Beast, Unaligned*

**AC** 13
**HP** 92 (8d12 + 40)
**Initiative** +3 (13)
**Speed** 5 ft., swim 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft.; Passive Perception 13
CR 5, PB +3, XP 1800

## Traits

**Water Breathing**
The shark can breathe only underwater.

## Actions

**Multiattack**
The shark makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +9 (with Advantage if the target doesn't have all its Hit Points), reach 5 ft. 22 (3d10 + 6) Piercing damage.
`,
      "Animals/giant-spider.md": `---
smType: creature
name: Giant Spider
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '14'
initiative: +3 (13)
hp: '26'
hitDice: 4d10 + 4
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 14
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 4
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '7'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
cr: '1'
xp: '200'
entries:
  - category: trait
    name: Spider Climb
    entryType: special
    text: The spider can climb difficult surfaces, including along ceilings, without needing to make an ability check.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Web Walker
    entryType: special
    text: The spider ignores movement restrictions caused by webs, and it knows the location of any other creature in contact with the same web.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage plus 7 (2d6) Poison damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d8
          bonus: 3
          type: Piercing
          average: 7
        - dice: 2d6
          bonus: 0
          type: Poison
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Web (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 13, one creature the spider can see within 60 feet. *Failure:*  The target has the Restrained condition until the web is destroyed (AC 10; HP 5; Vulnerability to Fire damage; Immunity to Poison and Psychic damage).'
    recharge: 5-6
    save:
      ability: dex
      dc: 13
      targeting:
        type: single
        range: 60 ft.
        restrictions:
          visibility: true
      area: one creature the spider can see within 60 feet
      onFail:
        effects:
          conditions:
            - condition: Restrained
              duration:
                type: until
                trigger: the web is destroyed (AC 10; HP 5; Vulnerability to Fire damage; Immunity to Poison and Psychic damage)
          other: The target has the Restrained condition until the web is destroyed (AC 10; HP 5; Vulnerability to Fire damage; Immunity to Poison and Psychic damage).
        legacyEffects: The target has the Restrained condition until the web is destroyed (AC 10; HP 5; Vulnerability to Fire damage; Immunity to Poison and Psychic damage).
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Spider
*Large, Beast, Unaligned*

**AC** 14
**HP** 26 (4d10 + 4)
**Initiative** +3 (13)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 14
CR 1, PB +2, XP 200

## Traits

**Spider Climb**
The spider can climb difficult surfaces, including along ceilings, without needing to make an ability check.

**Web Walker**
The spider ignores movement restrictions caused by webs, and it knows the location of any other creature in contact with the same web.

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage plus 7 (2d6) Poison damage.

**Web (Recharge 5-6)**
*Dexterity Saving Throw*: DC 13, one creature the spider can see within 60 feet. *Failure:*  The target has the Restrained condition until the web is destroyed (AC 10; HP 5; Vulnerability to Fire damage; Immunity to Poison and Psychic damage).
`,
      "Animals/giant-toad.md": `---
smType: creature
name: Giant Toad
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '11'
initiative: +1 (11)
hp: '39'
hitDice: 6d10 + 6
speeds:
  walk:
    distance: 30 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
cr: '1'
xp: '200'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The toad can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Standing Leap
    entryType: special
    text: The toad's Long Jump is up to 20 feet and its High Jump is up to 10 feet with or without a running start.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 5 (2d4) Poison damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12).'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Piercing
          average: 5
        - dice: 2d4
          bonus: 0
          type: Poison
          average: 5
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 12
            restrictions:
              size: Medium or smaller
        other: If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12).
      additionalEffects: If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12).
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Swallow
    entryType: special
    text: The toad swallows a Medium or smaller target it is grappling. While swallowed, the target isn't Grappled but has the Blinded and Restrained conditions, and it has Cover|XPHB|Total Cover against attacks and other effects outside the toad. In addition, the target takes 10 (3d6) Acid damage at the end of each of the toad's turns. The toad can have only one target swallowed at a time, and it can't use Bite while it has a swallowed target. If the toad dies, a swallowed creature is no longer Restrained and can escape from the corpse using 5 feet of movement, exiting with the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Toad
*Large, Beast, Unaligned*

**AC** 11
**HP** 39 (6d10 + 6)
**Initiative** +1 (11)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
CR 1, PB +2, XP 200

## Traits

**Amphibious**
The toad can breathe air and water.

**Standing Leap**
The toad's Long Jump is up to 20 feet and its High Jump is up to 10 feet with or without a running start.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 5 (2d4) Poison damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12).

**Swallow**
The toad swallows a Medium or smaller target it is grappling. While swallowed, the target isn't Grappled but has the Blinded and Restrained conditions, and it has Cover|XPHB|Total Cover against attacks and other effects outside the toad. In addition, the target takes 10 (3d6) Acid damage at the end of each of the toad's turns. The toad can have only one target swallowed at a time, and it can't use Bite while it has a swallowed target. If the toad dies, a swallowed creature is no longer Restrained and can escape from the corpse using 5 feet of movement, exiting with the Prone condition.
`,
      "Animals/giant-venomous-snake.md": `---
smType: creature
name: Giant Venomous Snake
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '14'
initiative: +4 (14)
hp: '11'
hitDice: 2d8 + 2
speeds:
  walk:
    distance: 40 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 18
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '2'
sensesList:
  - type: blindsight
    range: '10'
passivesList:
  - skill: Perception
    value: '12'
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 10 ft. 6 (1d4 + 4) Piercing damage plus 4 (1d8) Poison damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d4
          bonus: 4
          type: Piercing
          average: 6
        - dice: 1d8
          bonus: 0
          type: Poison
          average: 4
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Venomous Snake
*Medium, Beast, Unaligned*

**AC** 14
**HP** 11 (2d8 + 2)
**Initiative** +4 (14)
**Speed** 40 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft.; Passive Perception 12
CR 1/4, PB +2, XP 50

## Actions

**Bite**
*Melee Attack Roll:* +6, reach 10 ft. 6 (1d4 + 4) Piercing damage plus 4 (1d8) Poison damage.
`,
      "Animals/giant-vulture.md": `---
smType: creature
name: Giant Vulture
size: Large
type: Monstrosity
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '10'
initiative: +0 (10)
hp: '25'
hitDice: 3d10 + 9
speeds:
  walk:
    distance: 10 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
languagesList:
  - value: Understands Common but can't speak
damageResistancesList:
  - value: Necrotic
cr: '1'
xp: '200'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The vulture has Advantage on an attack roll against a creature if at least one of the vulture's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Gouge
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 9 (2d6 + 2) Piercing damage, and the target has the Poisoned condition until the end of its next turn.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 2d6
          bonus: 2
          type: Piercing
          average: 9
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Vulture
*Large, Monstrosity, Neutral Evil*

**AC** 10
**HP** 25 (3d10 + 9)
**Initiative** +0 (10)
**Speed** 10 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 13
**Languages** Understands Common but can't speak
CR 1, PB +2, XP 200

## Traits

**Pack Tactics**
The vulture has Advantage on an attack roll against a creature if at least one of the vulture's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Gouge**
*Melee Attack Roll:* +4, reach 5 ft. 9 (2d6 + 2) Piercing damage, and the target has the Poisoned condition until the end of its next turn.
`,
      "Animals/giant-wasp.md": `---
smType: creature
name: Giant Wasp
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +2 (12)
hp: '22'
hitDice: 5d8
speeds:
  walk:
    distance: 10 ft.
  fly:
    distance: 50 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Flyby
    entryType: special
    text: The wasp doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Sting
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 5 (2d4) Poison damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Piercing
          average: 5
        - dice: 2d4
          bonus: 0
          type: Poison
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Wasp
*Medium, Beast, Unaligned*

**AC** 13
**HP** 22 (5d8)
**Initiative** +2 (12)
**Speed** 10 ft., fly 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 1/2, PB +2, XP 100

## Traits

**Flyby**
The wasp doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.

## Actions

**Sting**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 5 (2d4) Poison damage.
`,
      "Animals/giant-weasel.md": `---
smType: creature
name: Giant Weasel
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +3 (13)
hp: '9'
hitDice: 2d8
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 11
    saveProf: false
  - key: dex
    score: 17
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 4
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
skills:
  - skill: Acrobatics
    value: '5'
  - skill: Perception
    value: '3'
  - skill: Stealth
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
cr: 1/8
xp: '25'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Piercing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d4
          bonus: 3
          type: Piercing
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Weasel
*Medium, Beast, Unaligned*

**AC** 13
**HP** 9 (2d8)
**Initiative** +3 (13)
**Speed** 40 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 13
CR 1/8, PB +2, XP 25

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Piercing damage.
`,
      "Animals/giant-wolf-spider.md": `---
smType: creature
name: Giant Wolf Spider
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +3 (13)
hp: '11'
hitDice: 2d8 + 2
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 40 ft.
abilities:
  - key: str
    score: 12
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 4
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
  - skill: Stealth
    value: '7'
sensesList:
  - type: blindsight
    range: '10'
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
cr: 1/4
xp: '50'
entries:
  - category: trait
    name: Spider Climb
    entryType: special
    text: The spider can climb difficult surfaces, including along ceilings, without needing to make an ability check.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Piercing damage plus 5 (2d4) Poison damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d4
          bonus: 3
          type: Piercing
          average: 5
        - dice: 2d4
          bonus: 0
          type: Poison
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Giant Wolf Spider
*Medium, Beast, Unaligned*

**AC** 13
**HP** 11 (2d8 + 2)
**Initiative** +3 (13)
**Speed** 40 ft., climb 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft., darkvision 60 ft.; Passive Perception 13
CR 1/4, PB +2, XP 50

## Traits

**Spider Climb**
The spider can climb difficult surfaces, including along ceilings, without needing to make an ability check.

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Piercing damage plus 5 (2d4) Poison damage.
`,
      "Animals/goat.md": `---
smType: creature
name: Goat
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '10'
initiative: +0 (10)
hp: '4'
hitDice: 1d8
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 11
    saveProf: true
    saveMod: 2
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '12'
cr: '0'
xp: '0'
entries:
  - category: action
    name: Ram
    entryType: attack
    text: '*Melee Attack Roll:* +2, reach 5 ft. 1 Bludgeoning damage, or 2 (1d4) Bludgeoning damage if the goat moved 20+ feet straight toward the target immediately before the hit.'
    attack:
      type: melee
      bonus: 2
      damage:
        - dice: 1d4
          bonus: 0
          type: Bludgeoning
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Goat
*Medium, Beast, Unaligned*

**AC** 10
**HP** 4 (1d8)
**Initiative** +0 (10)
**Speed** 40 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 12
CR 0, PB +2, XP 0

## Actions

**Ram**
*Melee Attack Roll:* +2, reach 5 ft. 1 Bludgeoning damage, or 2 (1d4) Bludgeoning damage if the goat moved 20+ feet straight toward the target immediately before the hit.
`,
      "Animals/hawk.md": `---
smType: creature
name: Hawk
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +3 (13)
hp: '1'
hitDice: 1d4 - 1
speeds:
  walk:
    distance: 10 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 5
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 8
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '6'
passivesList:
  - skill: Perception
    value: '16'
cr: '0'
xp: '0'
entries:
  - category: action
    name: Talons
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 1 Slashing damage.'
    attack:
      type: melee
      bonus: 5
      damage: []
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Hawk
*Small, Beast, Unaligned*

**AC** 13
**HP** 1 (1d4 - 1)
**Initiative** +3 (13)
**Speed** 10 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 0, PB +2, XP 0

## Actions

**Talons**
*Melee Attack Roll:* +5, reach 5 ft. 1 Slashing damage.
`,
      "Animals/hippopotamus.md": `---
smType: creature
name: Hippopotamus
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '14'
initiative: '-2 (8)'
hp: '82'
hitDice: 11d10 + 22
speeds:
  walk:
    distance: 30 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 21
    saveProf: true
    saveMod: 7
  - key: dex
    score: 7
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 4
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
passivesList:
  - skill: Perception
    value: '13'
cr: '4'
xp: '1100'
entries:
  - category: trait
    name: Hold Breath
    entryType: special
    text: The hippopotamus can hold its breath for 10 minutes.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The hippopotamus makes two Bite attacks.
    multiattack:
      attacks:
        - name: Bite
          count: 2
        - name: Bite
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 16 (2d10 + 5) Piercing damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d10
          bonus: 5
          type: Piercing
          average: 16
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Hippopotamus
*Large, Beast, Unaligned*

**AC** 14
**HP** 82 (11d10 + 22)
**Initiative** -2 (8)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 4, PB +2, XP 1100

## Traits

**Hold Breath**
The hippopotamus can hold its breath for 10 minutes.

## Actions

**Multiattack**
The hippopotamus makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +7, reach 5 ft. 16 (2d10 + 5) Piercing damage.
`,
      "Animals/hunter-shark.md": `---
smType: creature
name: Hunter Shark
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '45'
hitDice: 6d10 + 12
speeds:
  walk:
    distance: 5 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 4
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '2'
sensesList:
  - type: blindsight
    range: '60'
passivesList:
  - skill: Perception
    value: '12'
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Water Breathing
    entryType: special
    text: The shark can breathe only underwater.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +6 (with Advantage if the target doesn''t have all its Hit Points), reach 5 ft. 14 (3d6 + 4) Piercing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 3d6
          bonus: 4
          type: Piercing
          average: 14
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Hunter Shark
*Large, Beast, Unaligned*

**AC** 12
**HP** 45 (6d10 + 12)
**Initiative** +2 (12)
**Speed** 5 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft.; Passive Perception 12
CR 2, PB +2, XP 450

## Traits

**Water Breathing**
The shark can breathe only underwater.

## Actions

**Bite**
*Melee Attack Roll:* +6 (with Advantage if the target doesn't have all its Hit Points), reach 5 ft. 14 (3d6 + 4) Piercing damage.
`,
      "Animals/hyena.md": `---
smType: creature
name: Hyena
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '11'
initiative: +1 (11)
hp: '5'
hitDice: 1d8 + 1
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 11
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The hyena has Advantage on an attack roll against a creature if at least one of the hyena's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +2, reach 5 ft. 3 (1d6) Piercing damage.'
    attack:
      type: melee
      bonus: 2
      damage:
        - dice: 1d6
          bonus: 0
          type: Piercing
          average: 3
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Hyena
*Medium, Beast, Unaligned*

**AC** 11
**HP** 5 (1d8 + 1)
**Initiative** +1 (11)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 13
CR 0, PB +2, XP 0

## Traits

**Pack Tactics**
The hyena has Advantage on an attack roll against a creature if at least one of the hyena's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Bite**
*Melee Attack Roll:* +2, reach 5 ft. 3 (1d6) Piercing damage.
`,
      "Animals/jackal.md": `---
smType: creature
name: Jackal
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '3'
hitDice: 1d6
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 8
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
  - skill: Stealth
    value: '4'
sensesList:
  - type: darkvision
    range: '90'
passivesList:
  - skill: Perception
    value: '15'
cr: '0'
xp: '0'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +1, reach 5 ft. 1 (1d4 - 1) Piercing damage.'
    attack:
      type: melee
      bonus: 1
      damage:
        - dice: 1d4
          bonus: 0
          type: Piercing
          average: 1
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Jackal
*Small, Beast, Unaligned*

**AC** 12
**HP** 3 (1d6)
**Initiative** +2 (12)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 90 ft.; Passive Perception 15
CR 0, PB +2, XP 0

## Actions

**Bite**
*Melee Attack Roll:* +1, reach 5 ft. 1 (1d4 - 1) Piercing damage.
`,
      "Animals/killer-whale.md": `---
smType: creature
name: Killer Whale
size: Huge
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '90'
hitDice: 12d12 + 12
speeds:
  walk:
    distance: 5 ft.
  swim:
    distance: 60 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
  - skill: Stealth
    value: '4'
sensesList:
  - type: blindsight
    range: '120'
passivesList:
  - skill: Perception
    value: '13'
cr: '3'
xp: '700'
entries:
  - category: trait
    name: Hold Breath
    entryType: special
    text: The whale can hold its breath for 30 minutes.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 21 (5d6 + 4) Piercing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 5d6
          bonus: 4
          type: Piercing
          average: 21
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Killer Whale
*Huge, Beast, Unaligned*

**AC** 12
**HP** 90 (12d12 + 12)
**Initiative** +2 (12)
**Speed** 5 ft., swim 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 120 ft.; Passive Perception 13
CR 3, PB +2, XP 700

## Traits

**Hold Breath**
The whale can hold its breath for 30 minutes.

## Actions

**Bite**
*Melee Attack Roll:* +6, reach 5 ft. 21 (5d6 + 4) Piercing damage.
`,
      "Animals/lion.md": `---
smType: creature
name: Lion
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '22'
hitDice: 4d10
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
  - skill: Stealth
    value: '4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
cr: '1'
xp: '200'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The lion has Advantage on an attack roll against a creature if at least one of the lion's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Running Leap
    entryType: special
    text: With a 10-foot running start, the lion can Long Jump up to 25 feet.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The lion makes two Rend attacks. It can replace one attack with a use of Roar.
    multiattack:
      attacks:
        - name: Rend
          count: 2
        - name: Rend
          count: 2
        - name: one
          count: 1
      substitutions:
        - replace: attack
          with:
            type: attack
            name: Roar
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Slashing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d8
          bonus: 3
          type: Slashing
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Roar
    entryType: save
    text: '*Wisdom Saving Throw*: DC 11, one creature within 15 feet. *Failure:*  The target has the Frightened condition until the start of the lion''s next turn.'
    save:
      ability: wis
      dc: 11
      targeting:
        type: single
        range: 15 ft.
      area: one creature within 15 feet
      onFail:
        effects:
          conditions:
            - condition: Frightened
              duration:
                type: until
                trigger: the start of the lion's next turn
          other: The target has the Frightened condition until the start of the lion's next turn.
        legacyEffects: The target has the Frightened condition until the start of the lion's next turn.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Lion
*Large, Beast, Unaligned*

**AC** 12
**HP** 22 (4d10)
**Initiative** +2 (12)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 13
CR 1, PB +2, XP 200

## Traits

**Pack Tactics**
The lion has Advantage on an attack roll against a creature if at least one of the lion's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

**Running Leap**
With a 10-foot running start, the lion can Long Jump up to 25 feet.

## Actions

**Multiattack**
The lion makes two Rend attacks. It can replace one attack with a use of Roar.

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Slashing damage.

**Roar**
*Wisdom Saving Throw*: DC 11, one creature within 15 feet. *Failure:*  The target has the Frightened condition until the start of the lion's next turn.
`,
      "Animals/lizard.md": `---
smType: creature
name: Lizard
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '10'
initiative: +0 (10)
hp: '2'
hitDice: 1d4
speeds:
  walk:
    distance: 20 ft.
  climb:
    distance: 20 ft.
abilities:
  - key: str
    score: 2
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 8
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '30'
passivesList:
  - skill: Perception
    value: '9'
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Spider Climb
    entryType: special
    text: The lizard can climb difficult surfaces, including along ceilings, without needing to make an ability check.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +2, reach 5 ft. 1 Piercing damage.'
    attack:
      type: melee
      bonus: 2
      damage: []
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Lizard
*Small, Beast, Unaligned*

**AC** 10
**HP** 2 (1d4)
**Initiative** +0 (10)
**Speed** 20 ft., climb 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 30 ft.; Passive Perception 9
CR 0, PB +2, XP 0

## Traits

**Spider Climb**
The lizard can climb difficult surfaces, including along ceilings, without needing to make an ability check.

## Actions

**Bite**
*Melee Attack Roll:* +2, reach 5 ft. 1 Piercing damage.
`,
      "Animals/mammoth.md": `---
smType: creature
name: Mammoth
size: Huge
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +2 (12)
hp: '126'
hitDice: 11d12 + 55
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 24
    saveProf: true
    saveMod: 10
  - key: dex
    score: 9
    saveProf: false
  - key: con
    score: 21
    saveProf: true
    saveMod: 8
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+3'
passivesList:
  - skill: Perception
    value: '10'
cr: '6'
xp: '2300'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The mammoth makes two Gore attacks.
    multiattack:
      attacks:
        - name: Gore
          count: 2
        - name: Gore
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Gore
    entryType: attack
    text: '*Melee Attack Roll:* +10, reach 10 ft. 18 (2d10 + 7) Piercing damage. If the target is a Huge or smaller creature and the mammoth moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.'
    attack:
      type: melee
      bonus: 10
      damage:
        - dice: 2d10
          bonus: 7
          type: Piercing
          average: 18
      reach: 10 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Huge or smaller
        other: If the target is a Huge or smaller creature and the mammoth moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.
      additionalEffects: If the target is a Huge or smaller creature and the mammoth moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Trample
    entryType: save
    text: '*Dexterity Saving Throw*: DC 18, one creature within 5 feet that has the Prone condition. *Failure:*  29 (4d10 + 7) Bludgeoning damage. *Success:*  Half damage.'
    save:
      ability: dex
      dc: 18
      targeting:
        type: single
        range: 5 ft.
        restrictions:
          conditions:
            - Prone
      area: one creature within 5 feet that has the Prone condition
      onFail:
        damage:
          - dice: 4d10
            bonus: 7
            type: Bludgeoning
            average: 29
        effects:
          other: 29 (4d10 + 7) Bludgeoning damage.
        legacyEffects: 29 (4d10 + 7) Bludgeoning damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Mammoth
*Huge, Beast, Unaligned*

**AC** 13
**HP** 126 (11d12 + 55)
**Initiative** +2 (12)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 6, PB +3, XP 2300

## Actions

**Multiattack**
The mammoth makes two Gore attacks.

**Gore**
*Melee Attack Roll:* +10, reach 10 ft. 18 (2d10 + 7) Piercing damage. If the target is a Huge or smaller creature and the mammoth moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.

## Bonus Actions

**Trample**
*Dexterity Saving Throw*: DC 18, one creature within 5 feet that has the Prone condition. *Failure:*  29 (4d10 + 7) Bludgeoning damage. *Success:*  Half damage.
`,
      "Animals/mastiff.md": `---
smType: creature
name: Mastiff
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '5'
hitDice: 1d8 + 1
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 13
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '15'
cr: 1/8
xp: '25'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Piercing damage. If the target is a Medium or smaller creature, it has the Prone condition.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 1d6
          bonus: 1
          type: Piercing
          average: 4
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Medium or smaller
        other: If the target is a Medium or smaller creature, it has the Prone condition.
      additionalEffects: If the target is a Medium or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Mastiff
*Medium, Beast, Unaligned*

**AC** 12
**HP** 5 (1d8 + 1)
**Initiative** +2 (12)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 15
CR 1/8, PB +2, XP 25

## Actions

**Bite**
*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Piercing damage. If the target is a Medium or smaller creature, it has the Prone condition.
`,
      "Animals/mule.md": `---
smType: creature
name: Mule
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '10'
initiative: +0 (10)
hp: '11'
hitDice: 2d8 + 2
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 14
    saveProf: true
    saveMod: 4
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
cr: 1/8
xp: '25'
entries:
  - category: trait
    name: Beast of Burden
    entryType: special
    text: The mule counts as one size larger for the purpose of determining its carrying capacity.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Hooves
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d4
          bonus: 2
          type: Bludgeoning
          average: 4
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Mule
*Medium, Beast, Unaligned*

**AC** 10
**HP** 11 (2d8 + 2)
**Initiative** +0 (10)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 1/8, PB +2, XP 25

## Traits

**Beast of Burden**
The mule counts as one size larger for the purpose of determining its carrying capacity.

## Actions

**Hooves**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Bludgeoning damage.
`,
      "Animals/owl.md": `---
smType: creature
name: Owl
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '11'
initiative: +1 (11)
hp: '1'
hitDice: 1d4 - 1
speeds:
  walk:
    distance: 5 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 3
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 8
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
  - skill: Stealth
    value: '5'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '15'
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Flyby
    entryType: special
    text: The owl doesn't provoke Opportunity Attacks when it flies out of an enemy's reach.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Talons
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 1 Slashing damage.'
    attack:
      type: melee
      bonus: 3
      damage: []
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Owl
*Small, Beast, Unaligned*

**AC** 11
**HP** 1 (1d4 - 1)
**Initiative** +1 (11)
**Speed** 5 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 15
CR 0, PB +2, XP 0

## Traits

**Flyby**
The owl doesn't provoke Opportunity Attacks when it flies out of an enemy's reach.

## Actions

**Talons**
*Melee Attack Roll:* +3, reach 5 ft. 1 Slashing damage.
`,
      "Animals/panther.md": `---
smType: creature
name: Panther
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +3 (13)
hp: '13'
hitDice: 3d8
speeds:
  walk:
    distance: 50 ft.
  climb:
    distance: 40 ft.
abilities:
  - key: str
    score: 14
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '6'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Slashing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d6
          bonus: 3
          type: Slashing
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Nimble Escape
    entryType: special
    text: The panther takes the Disengage or Hide action.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Panther
*Medium, Beast, Unaligned*

**AC** 13
**HP** 13 (3d8)
**Initiative** +3 (13)
**Speed** 50 ft., climb 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 14
CR 1/4, PB +2, XP 50

## Actions

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Slashing damage.

## Bonus Actions

**Nimble Escape**
The panther takes the Disengage or Hide action.
`,
      "Animals/piranha.md": `---
smType: creature
name: Piranha
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +3 (13)
hp: '1'
hitDice: 1d4 - 1
speeds:
  walk:
    distance: 5 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 2
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 9
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 7
    saveProf: false
  - key: cha
    score: 2
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '8'
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Water Breathing
    entryType: special
    text: The piranha can breathe only underwater.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5 (with Advantage if the target doesn''t have all its Hit Points), reach 5 ft. 1 Piercing damage.'
    attack:
      type: melee
      bonus: 5
      damage: []
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Piranha
*Small, Beast, Unaligned*

**AC** 13
**HP** 1 (1d4 - 1)
**Initiative** +3 (13)
**Speed** 5 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 8
CR 0, PB +2, XP 0

## Traits

**Water Breathing**
The piranha can breathe only underwater.

## Actions

**Bite**
*Melee Attack Roll:* +5 (with Advantage if the target doesn't have all its Hit Points), reach 5 ft. 1 Piercing damage.
`,
      "Animals/plesiosaurus.md": `---
smType: creature
name: Plesiosaurus
size: Large
type: Beast
typeTags:
  - value: Dinosaur
alignmentOverride: Unaligned
ac: '13'
initiative: +2 (12)
hp: '68'
hitDice: 8d10 + 24
speeds:
  walk:
    distance: 20 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
  - skill: Stealth
    value: '4'
passivesList:
  - skill: Perception
    value: '13'
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Hold Breath
    entryType: special
    text: The plesiosaurus can hold its breath for 1 hour.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 10 ft. 11 (2d6 + 4) Piercing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d6
          bonus: 4
          type: Piercing
          average: 11
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Plesiosaurus
*Large, Beast, Unaligned*

**AC** 13
**HP** 68 (8d10 + 24)
**Initiative** +2 (12)
**Speed** 20 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 2, PB +2, XP 450

## Traits

**Hold Breath**
The plesiosaurus can hold its breath for 1 hour.

## Actions

**Bite**
*Melee Attack Roll:* +6, reach 10 ft. 11 (2d6 + 4) Piercing damage.
`,
      "Animals/polar-bear.md": `---
smType: creature
name: Polar Bear
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '42'
hitDice: 5d10 + 15
speeds:
  walk:
    distance: 40 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 20
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
  - skill: Stealth
    value: '4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '15'
damageResistancesList:
  - value: Cold
cr: '2'
xp: '450'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The bear makes two Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 2
        - name: Rend
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 9 (1d8 + 5) Slashing damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 1d8
          bonus: 5
          type: Slashing
          average: 9
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Polar Bear
*Large, Beast, Unaligned*

**AC** 12
**HP** 42 (5d10 + 15)
**Initiative** +2 (12)
**Speed** 40 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 15
CR 2, PB +2, XP 450

## Actions

**Multiattack**
The bear makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +7, reach 5 ft. 9 (1d8 + 5) Slashing damage.
`,
      "Animals/pony.md": `---
smType: creature
name: Pony
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '10'
initiative: +0 (10)
hp: '11'
hitDice: 2d8 + 2
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 15
    saveProf: true
    saveMod: 4
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
cr: 1/8
xp: '25'
entries:
  - category: action
    name: Hooves
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d4
          bonus: 2
          type: Bludgeoning
          average: 4
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Pony
*Medium, Beast, Unaligned*

**AC** 10
**HP** 11 (2d8 + 2)
**Initiative** +0 (10)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 1/8, PB +2, XP 25

## Actions

**Hooves**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Bludgeoning damage.
`,
      "Animals/pteranodon.md": `---
smType: creature
name: Pteranodon
size: Medium
type: Beast
typeTags:
  - value: Dinosaur
alignmentOverride: Unaligned
ac: '13'
initiative: +2 (12)
hp: '13'
hitDice: 3d8
speeds:
  walk:
    distance: 10 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 12
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 9
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '1'
passivesList:
  - skill: Perception
    value: '11'
cr: 1/4
xp: '50'
entries:
  - category: trait
    name: Flyby
    entryType: special
    text: The pteranodon doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Piercing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d8
          bonus: 2
          type: Piercing
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Pteranodon
*Medium, Beast, Unaligned*

**AC** 13
**HP** 13 (3d8)
**Initiative** +2 (12)
**Speed** 10 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 1/4, PB +2, XP 50

## Traits

**Flyby**
The pteranodon doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Piercing damage.
`,
      "Animals/rat.md": `---
smType: creature
name: Rat
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '10'
initiative: +0 (10)
hp: '1'
hitDice: 1d4 - 1
speeds:
  walk:
    distance: 20 ft.
  climb:
    distance: 20 ft.
abilities:
  - key: str
    score: 2
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 9
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 4
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '2'
sensesList:
  - type: darkvision
    range: '30'
passivesList:
  - skill: Perception
    value: '12'
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Agile
    entryType: special
    text: The rat doesn't provoke Opportunity Attacks when it moves out of an enemy's reach.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +2, reach 5 ft. 1 Piercing damage.'
    attack:
      type: melee
      bonus: 2
      damage: []
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Rat
*Small, Beast, Unaligned*

**AC** 10
**HP** 1 (1d4 - 1)
**Initiative** +0 (10)
**Speed** 20 ft., climb 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 30 ft.; Passive Perception 12
CR 0, PB +2, XP 0

## Traits

**Agile**
The rat doesn't provoke Opportunity Attacks when it moves out of an enemy's reach.

## Actions

**Bite**
*Melee Attack Roll:* +2, reach 5 ft. 1 Piercing damage.
`,
      "Animals/raven.md": `---
smType: creature
name: Raven
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '2'
hitDice: 1d4
speeds:
  walk:
    distance: 10 ft.
  fly:
    distance: 50 ft.
abilities:
  - key: str
    score: 2
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 5
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
passivesList:
  - skill: Perception
    value: '13'
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Mimicry
    entryType: special
    text: The raven can mimic simple sounds it has heard, such as a whisper or chitter. A hearer can discern the sounds are imitations with a successful DC 10 Wisdom (Insight) check.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Beak
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 1 Piercing damage.'
    attack:
      type: melee
      bonus: 4
      damage: []
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Raven
*Small, Beast, Unaligned*

**AC** 12
**HP** 2 (1d4)
**Initiative** +2 (12)
**Speed** 10 ft., fly 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 0, PB +2, XP 0

## Traits

**Mimicry**
The raven can mimic simple sounds it has heard, such as a whisper or chitter. A hearer can discern the sounds are imitations with a successful DC 10 Wisdom (Insight) check.

## Actions

**Beak**
*Melee Attack Roll:* +4, reach 5 ft. 1 Piercing damage.
`,
      "Animals/reef-shark.md": `---
smType: creature
name: Reef Shark
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '22'
hitDice: 4d8 + 4
speeds:
  walk:
    distance: 5 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 14
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 4
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '2'
sensesList:
  - type: blindsight
    range: '30'
passivesList:
  - skill: Perception
    value: '12'
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The shark has Advantage on an attack roll against a creature if at least one of the shark's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Water Breathing
    entryType: special
    text: The shark can breathe only underwater.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 7 (2d4 + 2) Piercing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 2d4
          bonus: 2
          type: Piercing
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Reef Shark
*Medium, Beast, Unaligned*

**AC** 12
**HP** 22 (4d8 + 4)
**Initiative** +2 (12)
**Speed** 5 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft.; Passive Perception 12
CR 1/2, PB +2, XP 100

## Traits

**Pack Tactics**
The shark has Advantage on an attack roll against a creature if at least one of the shark's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

**Water Breathing**
The shark can breathe only underwater.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 7 (2d4 + 2) Piercing damage.
`,
      "Animals/rhinoceros.md": `---
smType: creature
name: Rhinoceros
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: '-1 (9)'
hp: '45'
hitDice: 6d10 + 12
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 21
    saveProf: false
  - key: dex
    score: 8
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '11'
cr: '2'
xp: '450'
entries:
  - category: action
    name: Gore
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 14 (2d8 + 5) Piercing damage. If target is a Large or smaller creature and the rhinoceros moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d8
          bonus: 5
          type: Piercing
          average: 14
        - dice: 2d8
          bonus: 0
          type: Piercing
          average: 9
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
        other: If target is a Large or smaller creature and the rhinoceros moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.
      additionalEffects: If target is a Large or smaller creature and the rhinoceros moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Rhinoceros
*Large, Beast, Unaligned*

**AC** 13
**HP** 45 (6d10 + 12)
**Initiative** -1 (9)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 2, PB +2, XP 450

## Actions

**Gore**
*Melee Attack Roll:* +7, reach 5 ft. 14 (2d8 + 5) Piercing damage. If target is a Large or smaller creature and the rhinoceros moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.
`,
      "Animals/riding-horse.md": `---
smType: creature
name: Riding Horse
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '11'
initiative: +1 (11)
hp: '13'
hitDice: 2d10 + 2
speeds:
  walk:
    distance: 60 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Hooves
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d8
          bonus: 3
          type: Bludgeoning
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Riding Horse
*Large, Beast, Unaligned*

**AC** 11
**HP** 13 (2d10 + 2)
**Initiative** +1 (11)
**Speed** 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 1/4, PB +2, XP 50

## Actions

**Hooves**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Bludgeoning damage.
`,
      "Animals/saber-toothed-tiger.md": `---
smType: creature
name: Saber-Toothed Tiger
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +3 (13)
hp: '52'
hitDice: 7d10 + 14
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 18
    saveProf: true
    saveMod: 6
  - key: dex
    score: 17
    saveProf: true
    saveMod: 5
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
  - skill: Stealth
    value: '7'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '15'
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Running Leap
    entryType: special
    text: With a 10-foot running start, the tiger can Long Jump up to 25 feet.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The tiger makes two Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 2
        - name: Rend
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 11 (2d6 + 4) Slashing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d6
          bonus: 4
          type: Slashing
          average: 11
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Nimble Escape
    entryType: special
    text: The tiger takes the Disengage or Hide action.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Saber-Toothed Tiger
*Large, Beast, Unaligned*

**AC** 13
**HP** 52 (7d10 + 14)
**Initiative** +3 (13)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 15
CR 2, PB +2, XP 450

## Traits

**Running Leap**
With a 10-foot running start, the tiger can Long Jump up to 25 feet.

## Actions

**Multiattack**
The tiger makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +6, reach 5 ft. 11 (2d6 + 4) Slashing damage.

## Bonus Actions

**Nimble Escape**
The tiger takes the Disengage or Hide action.
`,
      "Animals/scorpion.md": `---
smType: creature
name: Scorpion
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '11'
initiative: +0 (10)
hp: '1'
hitDice: 1d4 - 1
speeds:
  walk:
    distance: 10 ft.
abilities:
  - key: str
    score: 2
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 8
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 8
    saveProf: false
  - key: cha
    score: 2
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '10'
passivesList:
  - skill: Perception
    value: '9'
cr: '0'
xp: '0'
entries:
  - category: action
    name: Sting
    entryType: attack
    text: '*Melee Attack Roll:* +2, reach 5 ft. 1 Piercing damage plus 3 (1d6) Poison damage.'
    attack:
      type: melee
      bonus: 2
      damage:
        - dice: 1d6
          bonus: 0
          type: Poison
          average: 3
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Scorpion
*Small, Beast, Unaligned*

**AC** 11
**HP** 1 (1d4 - 1)
**Initiative** +0 (10)
**Speed** 10 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft.; Passive Perception 9
CR 0, PB +2, XP 0

## Actions

**Sting**
*Melee Attack Roll:* +2, reach 5 ft. 1 Piercing damage plus 3 (1d6) Poison damage.
`,
      "Animals/seahorse.md": `---
smType: creature
name: Seahorse
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +1 (11)
hp: '1'
hitDice: 1d4 - 1
speeds:
  walk:
    distance: 5 ft.
  swim:
    distance: 20 ft.
abilities:
  - key: str
    score: 1
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 8
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 2
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '2'
  - skill: Stealth
    value: '5'
passivesList:
  - skill: Perception
    value: '12'
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Water Breathing
    entryType: special
    text: The seahorse can breathe only underwater.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bubble Dash
    entryType: special
    text: While underwater, the seahorse moves up to its Swim Speed without provoking Opportunity Attacks.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Seahorse
*Small, Beast, Unaligned*

**AC** 12
**HP** 1 (1d4 - 1)
**Initiative** +1 (11)
**Speed** 5 ft., swim 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 0, PB +2, XP 0

## Traits

**Water Breathing**
The seahorse can breathe only underwater.

## Actions

**Bubble Dash**
While underwater, the seahorse moves up to its Swim Speed without provoking Opportunity Attacks.
`,
      "Animals/spider.md": `---
smType: creature
name: Spider
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '1'
hitDice: 1d4 - 1
speeds:
  walk:
    distance: 20 ft.
  climb:
    distance: 20 ft.
abilities:
  - key: str
    score: 2
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 8
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 2
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '4'
sensesList:
  - type: darkvision
    range: '30'
passivesList:
  - skill: Perception
    value: '10'
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Spider Climb
    entryType: special
    text: The spider can climb difficult surfaces, including along ceilings, without needing to make an ability check.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Web Walker
    entryType: special
    text: The spider ignores movement restrictions caused by webs, and the spider knows the location of any other creature in contact with the same web.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 1 Piercing damage plus 2 (1d4) Poison damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d4
          bonus: 0
          type: Poison
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Spider
*Small, Beast, Unaligned*

**AC** 12
**HP** 1 (1d4 - 1)
**Initiative** +2 (12)
**Speed** 20 ft., climb 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 30 ft.; Passive Perception 10
CR 0, PB +2, XP 0

## Traits

**Spider Climb**
The spider can climb difficult surfaces, including along ceilings, without needing to make an ability check.

**Web Walker**
The spider ignores movement restrictions caused by webs, and the spider knows the location of any other creature in contact with the same web.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 1 Piercing damage plus 2 (1d4) Poison damage.
`,
      "Animals/swarm-of-bats.md": `---
smType: creature
name: Swarm of Bats
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '11'
hitDice: 2d10
speeds:
  walk:
    distance: 5 ft.
  fly:
    distance: 30 ft.
abilities:
  - key: str
    score: 5
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 4
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '60'
passivesList:
  - skill: Perception
    value: '11'
damageResistancesList:
  - value: Bludgeoning
  - value: Piercing
  - value: Slashing
conditionImmunitiesList:
  - value: Charmed
  - value: Frightened
  - value: Grappled
  - value: Paralyzed
  - value: Petrified
  - value: Prone
  - value: Restrained
  - value: Stunned
cr: 1/4
xp: '50'
entries:
  - category: trait
    name: Swarm
    entryType: special
    text: The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny bat. The swarm can't regain Hit Points or gain Temporary Hit Points.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bites
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (2d4) Piercing damage, or 2 (1d4) Piercing damage if the swarm is Bloodied.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 2d4
          bonus: 0
          type: Piercing
          average: 5
        - dice: 1d4
          bonus: 0
          type: Piercing
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Swarm of Bats
*Large, Beast, Unaligned*

**AC** 12
**HP** 11 (2d10)
**Initiative** +2 (12)
**Speed** 5 ft., fly 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft.; Passive Perception 11
CR 1/4, PB +2, XP 50

## Traits

**Swarm**
The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny bat. The swarm can't regain Hit Points or gain Temporary Hit Points.

## Actions

**Bites**
*Melee Attack Roll:* +4, reach 5 ft. 5 (2d4) Piercing damage, or 2 (1d4) Piercing damage if the swarm is Bloodied.
`,
      "Animals/swarm-of-insects.md": `---
smType: creature
name: Swarm of Insects
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '11'
initiative: +1 (11)
hp: '19'
hitDice: 3d8 + 6
speeds:
  walk:
    distance: 20 ft.
abilities:
  - key: str
    score: 3
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 7
    saveProf: false
  - key: cha
    score: 1
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '30'
passivesList:
  - skill: Perception
    value: '8'
damageResistancesList:
  - value: Bludgeoning
  - value: Piercing
  - value: Slashing
conditionImmunitiesList:
  - value: Charmed
  - value: Frightened
  - value: Grappled
  - value: Paralyzed
  - value: Petrified
  - value: Prone
  - value: Restrained
  - value: Stunned
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Spider Climb
    entryType: special
    text: If the swarm has a Climb Speed, the swarm can climb difficult surfaces, including along ceilings, without needing to make an ability check.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Swarm
    entryType: special
    text: The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny insect. The swarm can't regain Hit Points or gain Temporary Hit Points.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bites
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 6 (2d4 + 1) Poison damage, or 3 (1d4 + 1) Poison damage if the swarm is Bloodied.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 2d4
          bonus: 1
          type: Poison
          average: 6
        - dice: 1d4
          bonus: 1
          type: Poison
          average: 3
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Swarm of Insects
*Medium, Beast, Unaligned*

**AC** 11
**HP** 19 (3d8 + 6)
**Initiative** +1 (11)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft.; Passive Perception 8
CR 1/2, PB +2, XP 100

## Traits

**Spider Climb**
If the swarm has a Climb Speed, the swarm can climb difficult surfaces, including along ceilings, without needing to make an ability check.

**Swarm**
The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny insect. The swarm can't regain Hit Points or gain Temporary Hit Points.

## Actions

**Bites**
*Melee Attack Roll:* +3, reach 5 ft. 6 (2d4 + 1) Poison damage, or 3 (1d4 + 1) Poison damage if the swarm is Bloodied.
`,
      "Animals/swarm-of-piranhas.md": `---
smType: creature
name: Swarm of Piranhas
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +3 (13)
hp: '28'
hitDice: 8d8 - 8
speeds:
  walk:
    distance: 5 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 13
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 9
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 7
    saveProf: false
  - key: cha
    score: 2
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '8'
damageResistancesList:
  - value: Bludgeoning
  - value: Piercing
  - value: Slashing
conditionImmunitiesList:
  - value: Charmed
  - value: Frightened
  - value: Grappled
  - value: Paralyzed
  - value: Petrified
  - value: Prone
  - value: Restrained
  - value: Stunned
cr: '1'
xp: '200'
entries:
  - category: trait
    name: Swarm
    entryType: special
    text: The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny piranha. The swarm can't regain Hit Points or gain Temporary Hit Points.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Water Breathing
    entryType: special
    text: The swarm can breathe only underwater.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bites
    entryType: attack
    text: '*Melee Attack Roll:* +5 (with Advantage if the target doesn''t have all its Hit Points), reach 5 ft. 8 (2d4 + 3) Piercing damage, or 5 (1d4 + 3) Piercing damage if the swarm is Bloodied.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d4
          bonus: 3
          type: Piercing
          average: 8
        - dice: 1d4
          bonus: 3
          type: Piercing
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Swarm of Piranhas
*Medium, Beast, Unaligned*

**AC** 13
**HP** 28 (8d8 - 8)
**Initiative** +3 (13)
**Speed** 5 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 8
CR 1, PB +2, XP 200

## Traits

**Swarm**
The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny piranha. The swarm can't regain Hit Points or gain Temporary Hit Points.

**Water Breathing**
The swarm can breathe only underwater.

## Actions

**Bites**
*Melee Attack Roll:* +5 (with Advantage if the target doesn't have all its Hit Points), reach 5 ft. 8 (2d4 + 3) Piercing damage, or 5 (1d4 + 3) Piercing damage if the swarm is Bloodied.
`,
      "Animals/swarm-of-rats.md": `---
smType: creature
name: Swarm of Rats
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '10'
initiative: +0 (10)
hp: '14'
hitDice: 4d8 - 4
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 9
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 9
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '30'
passivesList:
  - skill: Perception
    value: '10'
damageResistancesList:
  - value: Bludgeoning
  - value: Piercing
  - value: Slashing
conditionImmunitiesList:
  - value: Charmed
  - value: Frightened
  - value: Grappled
  - value: Paralyzed
  - value: Petrified
  - value: Prone
  - value: Restrained
  - value: Stunned
cr: 1/4
xp: '50'
entries:
  - category: trait
    name: Swarm
    entryType: special
    text: The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny rat. The swarm can't regain Hit Points or gain Temporary Hit Points.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bites
    entryType: attack
    text: '*Melee Attack Roll:* +2, reach 5 ft. 5 (2d4) Piercing damage, or 2 (1d4) Piercing damage if the swarm is Bloodied.'
    attack:
      type: melee
      bonus: 2
      damage:
        - dice: 2d4
          bonus: 0
          type: Piercing
          average: 5
        - dice: 1d4
          bonus: 0
          type: Piercing
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Swarm of Rats
*Medium, Beast, Unaligned*

**AC** 10
**HP** 14 (4d8 - 4)
**Initiative** +0 (10)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 30 ft.; Passive Perception 10
CR 1/4, PB +2, XP 50

## Traits

**Swarm**
The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny rat. The swarm can't regain Hit Points or gain Temporary Hit Points.

## Actions

**Bites**
*Melee Attack Roll:* +2, reach 5 ft. 5 (2d4) Piercing damage, or 2 (1d4) Piercing damage if the swarm is Bloodied.
`,
      "Animals/swarm-of-ravens.md": `---
smType: creature
name: Swarm of Ravens
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '11'
hitDice: 2d8 + 2
speeds:
  walk:
    distance: 10 ft.
  fly:
    distance: 50 ft.
abilities:
  - key: str
    score: 6
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 5
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
passivesList:
  - skill: Perception
    value: '15'
damageResistancesList:
  - value: Bludgeoning
  - value: Piercing
  - value: Slashing
conditionImmunitiesList:
  - value: Charmed
  - value: Frightened
  - value: Grappled
  - value: Paralyzed
  - value: Petrified
  - value: Prone
  - value: Restrained
  - value: Stunned
cr: 1/4
xp: '50'
entries:
  - category: trait
    name: Swarm
    entryType: special
    text: The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny raven. The swarm can't regain Hit Points or gain Temporary Hit Points.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Beaks
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage, or 2 (1d4) Piercing damage if the swarm is Bloodied.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Piercing
          average: 5
        - dice: 1d4
          bonus: 0
          type: Piercing
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Cacophony
    entryType: save
    text: '*Wisdom Saving Throw*: DC 10, one creature in the swarm''s space. *Failure:*  The target has the Deafened condition until the start of the swarm''s next turn. While Deafened, the target also has Disadvantage on ability checks and attack rolls.'
    save:
      ability: wis
      dc: 10
      targeting:
        type: single
      area: one creature in the swarm's space
      onFail:
        effects:
          conditions:
            - condition: Deafened
              duration:
                type: until
                trigger: the start of the swarm's next turn
          mechanical:
            - type: disadvantage
              target: ability checks
              description: has Disadvantage on ability checks and
            - type: advantage
              target: ability checks
              description: advantage on ability checks and
          other: The target has the Deafened condition until the start of the swarm's next turn. While Deafened, the target also has Disadvantage on ability checks and attack rolls.
        legacyEffects: The target has the Deafened condition until the start of the swarm's next turn. While Deafened, the target also has Disadvantage on ability checks and attack rolls.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Swarm of Ravens
*Medium, Beast, Unaligned*

**AC** 12
**HP** 11 (2d8 + 2)
**Initiative** +2 (12)
**Speed** 10 ft., fly 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 1/4, PB +2, XP 50

## Traits

**Swarm**
The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny raven. The swarm can't regain Hit Points or gain Temporary Hit Points.

## Actions

**Beaks**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage, or 2 (1d4) Piercing damage if the swarm is Bloodied.

**Cacophony (Recharge 6)**
*Wisdom Saving Throw*: DC 10, one creature in the swarm's space. *Failure:*  The target has the Deafened condition until the start of the swarm's next turn. While Deafened, the target also has Disadvantage on ability checks and attack rolls.
`,
      "Animals/swarm-of-venomous-snakes.md": `---
smType: creature
name: Swarm of Venomous Snakes
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '14'
initiative: +4 (14)
hp: '36'
hitDice: 8d8
speeds:
  walk:
    distance: 30 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 8
    saveProf: false
  - key: dex
    score: 18
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '10'
passivesList:
  - skill: Perception
    value: '10'
damageResistancesList:
  - value: Bludgeoning
  - value: Piercing
  - value: Slashing
conditionImmunitiesList:
  - value: Charmed
  - value: Frightened
  - value: Grappled
  - value: Paralyzed
  - value: Petrified
  - value: Prone
  - value: Restrained
  - value: Stunned
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Swarm
    entryType: special
    text: The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny snake. The swarm can't regain Hit Points or gain Temporary Hit Points.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bites
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 8 (1d8 + 4) Piercing damage\u2014or 6 (1d4 + 4) Piercing damage if the swarm is Bloodied\u2014plus 10 (3d6) Poison damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d8
          bonus: 4
          type: Piercing
          average: 8
        - dice: 1d4
          bonus: 4
          type: Piercing
          average: 6
        - dice: 3d6
          bonus: 0
          type: Poison
          average: 10
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Swarm of Venomous Snakes
*Medium, Beast, Unaligned*

**AC** 14
**HP** 36 (8d8)
**Initiative** +4 (14)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft.; Passive Perception 10
CR 2, PB +2, XP 450

## Traits

**Swarm**
The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny snake. The swarm can't regain Hit Points or gain Temporary Hit Points.

## Actions

**Bites**
*Melee Attack Roll:* +6, reach 5 ft. 8 (1d8 + 4) Piercing damage\u2014or 6 (1d4 + 4) Piercing damage if the swarm is Bloodied\u2014plus 10 (3d6) Poison damage.
`,
      "Animals/tiger.md": `---
smType: creature
name: Tiger
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +3 (13)
hp: '30'
hitDice: 4d10 + 8
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
  - skill: Stealth
    value: '7'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
cr: '1'
xp: '200'
entries:
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage. If the target is a Large or smaller creature, it has the Prone condition.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d6
          bonus: 3
          type: Slashing
          average: 10
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
        other: If the target is a Large or smaller creature, it has the Prone condition.
      additionalEffects: If the target is a Large or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Nimble Escape
    entryType: special
    text: The tiger takes the Disengage or Hide action.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Tiger
*Large, Beast, Unaligned*

**AC** 13
**HP** 30 (4d10 + 8)
**Initiative** +3 (13)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 13
CR 1, PB +2, XP 200

## Actions

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage. If the target is a Large or smaller creature, it has the Prone condition.

## Bonus Actions

**Nimble Escape**
The tiger takes the Disengage or Hide action.
`,
      "Animals/triceratops.md": `---
smType: creature
name: Triceratops
size: Huge
type: Beast
typeTags:
  - value: Dinosaur
alignmentOverride: Unaligned
ac: '14'
initiative: '-1 (9)'
hp: '114'
hitDice: 12d12 + 36
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 22
    saveProf: false
  - key: dex
    score: 9
    saveProf: false
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+3'
passivesList:
  - skill: Perception
    value: '10'
cr: '5'
xp: '1800'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The triceratops makes two Gore attacks.
    multiattack:
      attacks:
        - name: Gore
          count: 2
        - name: Gore
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Gore
    entryType: attack
    text: '*Melee Attack Roll:* +9, reach 5 ft. 19 (2d12 + 6) Piercing damage. If the target is Huge or smaller and the triceratops moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.'
    attack:
      type: melee
      bonus: 9
      damage:
        - dice: 2d12
          bonus: 6
          type: Piercing
          average: 19
        - dice: 2d8
          bonus: 0
          type: Piercing
          average: 9
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Huge or smaller
        other: If the target is Huge or smaller and the triceratops moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.
      additionalEffects: If the target is Huge or smaller and the triceratops moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Triceratops
*Huge, Beast, Unaligned*

**AC** 14
**HP** 114 (12d12 + 36)
**Initiative** -1 (9)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 5, PB +3, XP 1800

## Actions

**Multiattack**
The triceratops makes two Gore attacks.

**Gore**
*Melee Attack Roll:* +9, reach 5 ft. 19 (2d12 + 6) Piercing damage. If the target is Huge or smaller and the triceratops moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.
`,
      "Animals/tyrannosaurus-rex.md": `---
smType: creature
name: Tyrannosaurus Rex
size: Huge
type: Beast
typeTags:
  - value: Dinosaur
alignmentOverride: Unaligned
ac: '13'
initiative: +3 (13)
hp: '136'
hitDice: 13d12 + 52
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 25
    saveProf: true
    saveMod: 10
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 19
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: true
    saveMod: 4
  - key: cha
    score: 9
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '4'
passivesList:
  - skill: Perception
    value: '14'
cr: '8'
xp: '3900'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The tyrannosaurus makes one Bite attack and one Tail attack.
    multiattack:
      attacks:
        - name: Bite
          count: 1
        - name: Bite
          count: 1
        - name: Tail
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +10, reach 10 ft. 33 (4d12 + 7) Piercing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 17). While Grappled, the target has the Restrained condition and can''t be targeted by the tyrannosaurus''s Tail.'
    attack:
      type: melee
      bonus: 10
      damage:
        - dice: 4d12
          bonus: 7
          type: Piercing
          average: 33
      reach: 10 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 17
            restrictions:
              size: Large or smaller
              while: While Grappled, the target has the Restrained condition
          - condition: Restrained
            escape:
              type: dc
              dc: 17
            restrictions:
              size: Large or smaller
              while: While Grappled, the target has the Restrained condition
        other: If the target is a Large or smaller creature, it has the Grappled condition (escape DC 17). While Grappled, the target has the Restrained condition and can't be targeted by the tyrannosaurus's Tail.
      additionalEffects: If the target is a Large or smaller creature, it has the Grappled condition (escape DC 17). While Grappled, the target has the Restrained condition and can't be targeted by the tyrannosaurus's Tail.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Tail
    entryType: attack
    text: '*Melee Attack Roll:* +10, reach 15 ft. 25 (4d8 + 7) Bludgeoning damage. If the target is a Huge or smaller creature, it has the Prone condition.'
    attack:
      type: melee
      bonus: 10
      damage:
        - dice: 4d8
          bonus: 7
          type: Bludgeoning
          average: 25
      reach: 15 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Huge or smaller
        other: If the target is a Huge or smaller creature, it has the Prone condition.
      additionalEffects: If the target is a Huge or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Tyrannosaurus Rex
*Huge, Beast, Unaligned*

**AC** 13
**HP** 136 (13d12 + 52)
**Initiative** +3 (13)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 8, PB +3, XP 3900

## Actions

**Multiattack**
The tyrannosaurus makes one Bite attack and one Tail attack.

**Bite**
*Melee Attack Roll:* +10, reach 10 ft. 33 (4d12 + 7) Piercing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 17). While Grappled, the target has the Restrained condition and can't be targeted by the tyrannosaurus's Tail.

**Tail**
*Melee Attack Roll:* +10, reach 15 ft. 25 (4d8 + 7) Bludgeoning damage. If the target is a Huge or smaller creature, it has the Prone condition.
`,
      "Animals/venomous-snake.md": `---
smType: creature
name: Venomous Snake
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '5'
hitDice: 2d4
speeds:
  walk:
    distance: 30 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 2
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '10'
passivesList:
  - skill: Perception
    value: '10'
cr: 1/8
xp: '25'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage plus 3 (1d6) Poison damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d4
          bonus: 2
          type: Piercing
          average: 4
        - dice: 1d6
          bonus: 0
          type: Poison
          average: 3
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Venomous Snake
*Small, Beast, Unaligned*

**AC** 12
**HP** 5 (2d4)
**Initiative** +2 (12)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft.; Passive Perception 10
CR 1/8, PB +2, XP 25

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage plus 3 (1d6) Poison damage.
`,
      "Animals/vulture.md": `---
smType: creature
name: Vulture
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '10'
initiative: +0 (10)
hp: '5'
hitDice: 1d8 + 1
speeds:
  walk:
    distance: 10 ft.
  fly:
    distance: 50 ft.
abilities:
  - key: str
    score: 7
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 4
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
passivesList:
  - skill: Perception
    value: '13'
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The vulture has Advantage on an attack roll against a creature if at least one of the vulture's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Beak
    entryType: attack
    text: '*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Piercing damage.'
    attack:
      type: melee
      bonus: 2
      damage:
        - dice: 1d4
          bonus: 0
          type: Piercing
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Vulture
*Medium, Beast, Unaligned*

**AC** 10
**HP** 5 (1d8 + 1)
**Initiative** +0 (10)
**Speed** 10 ft., fly 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 0, PB +2, XP 0

## Traits

**Pack Tactics**
The vulture has Advantage on an attack roll against a creature if at least one of the vulture's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Beak**
*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Piercing damage.
`,
      "Animals/warhorse.md": `---
smType: creature
name: Warhorse
size: Large
type: Beast
alignmentOverride: Unaligned
ac: '11'
initiative: +1 (11)
hp: '19'
hitDice: 3d10 + 3
speeds:
  walk:
    distance: 60 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: true
    saveMod: 3
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '11'
cr: 1/2
xp: '100'
entries:
  - category: action
    name: Hooves
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 9 (2d4 + 4) Bludgeoning damage. If the target is a Large or smaller creature and the horse moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d4
          bonus: 4
          type: Bludgeoning
          average: 9
        - dice: 2d4
          bonus: 0
          type: Bludgeoning
          average: 5
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
        other: If the target is a Large or smaller creature and the horse moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.
      additionalEffects: If the target is a Large or smaller creature and the horse moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Warhorse
*Large, Beast, Unaligned*

**AC** 11
**HP** 19 (3d10 + 3)
**Initiative** +1 (11)
**Speed** 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 1/2, PB +2, XP 100

## Actions

**Hooves**
*Melee Attack Roll:* +6, reach 5 ft. 9 (2d4 + 4) Bludgeoning damage. If the target is a Large or smaller creature and the horse moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.
`,
      "Animals/weasel.md": `---
smType: creature
name: Weasel
size: Small
type: Beast
alignmentOverride: Unaligned
ac: '13'
initiative: +3 (13)
hp: '1'
hitDice: 1d4 - 1
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 3
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 8
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
skills:
  - skill: Acrobatics
    value: '5'
  - skill: Perception
    value: '3'
  - skill: Stealth
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
cr: '0'
xp: '0'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 1 Piercing damage.'
    attack:
      type: melee
      bonus: 5
      damage: []
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Weasel
*Small, Beast, Unaligned*

**AC** 13
**HP** 1 (1d4 - 1)
**Initiative** +3 (13)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 13
CR 0, PB +2, XP 0

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 1 Piercing damage.
`,
      "Animals/wolf.md": `---
smType: creature
name: Wolf
size: Medium
type: Beast
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '11'
hitDice: 2d8 + 2
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 14
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
  - skill: Stealth
    value: '4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '15'
cr: 1/4
xp: '50'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The wolf has Advantage on attack rolls against a creature if at least one of the wolf's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage. If the target is a Medium or smaller creature, it has the Prone condition.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Piercing
          average: 5
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Medium or smaller
        other: If the target is a Medium or smaller creature, it has the Prone condition.
      additionalEffects: If the target is a Medium or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Wolf
*Medium, Beast, Unaligned*

**AC** 12
**HP** 11 (2d8 + 2)
**Initiative** +2 (12)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 15
CR 1/4, PB +2, XP 50

## Traits

**Pack Tactics**
The wolf has Advantage on attack rolls against a creature if at least one of the wolf's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage. If the target is a Medium or smaller creature, it has the Prone condition.
`,
      "Monsters/aboleth.md": `---
smType: creature
name: Aboleth
size: Large
type: Aberration
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '17'
initiative: +3 (13)
hp: '150'
hitDice: 20d10 + 40
speeds:
  walk:
    distance: 10 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 21
    saveProf: false
  - key: dex
    score: 9
    saveProf: true
    saveMod: 3
  - key: con
    score: 15
    saveProf: true
    saveMod: 6
  - key: int
    score: 18
    saveProf: true
    saveMod: 8
  - key: wis
    score: 15
    saveProf: true
    saveMod: 6
  - key: cha
    score: 18
    saveProf: false
pb: '+4'
skills:
  - skill: History
    value: '12'
  - skill: Perception
    value: '10'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '20'
languagesList:
  - value: Deep Speech
  - value: telepathy 120 ft.
cr: '10'
xp: '5900'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The aboleth can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Eldritch Restoration
    entryType: special
    text: If destroyed, the aboleth gains a new body in 5d10 days, reviving with all its Hit Points in the Far Realm or another location chosen by the DM.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (3/Day, or 4/Day in Lair)
    entryType: special
    text: If the aboleth fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Mucus Cloud
    entryType: save
    text: 'While underwater, the aboleth is surrounded by mucus. *Constitution Saving Throw*: DC 14, each creature in a 5-foot Emanation originating from the aboleth at the end of the aboleth''s turn. *Failure:*  The target is cursed. Until the curse ends, the target''s skin becomes slimy, the target can breathe air and water, and it can''t regain Hit Points unless it is underwater. While the cursed creature is outside a body of water, the creature takes 6 (1d12) Acid damage at the end of every 10 minutes unless moisture is applied to its skin before those minutes have passed.'
    save:
      ability: con
      dc: 14
      targeting:
        shape: emanation
        size: 5 ft.
        origin: self
      onFail:
        effects:
          conditions:
            - condition: Cursed
              additionalText: the target's skin becomes slimy; the target can breathe air and water; it can't regain Hit Points unless it is underwater
              duration:
                type: until
                trigger: the curse ends
          damageOverTime:
            damage:
              - dice: 1d12
                bonus: 0
                type: Acid
                average: 6
            timing:
              type: minutes
              count: 10
            condition: it is underwater
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Probing Telepathy
    entryType: special
    text: If a creature the aboleth can see communicates telepathically with the aboleth, the aboleth learns the creature's greatest desires.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The aboleth makes two Tentacle attacks and uses either Consume Memories or Dominate Mind if available.
    multiattack:
      attacks:
        - name: Tentacle
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Tentacle
    entryType: attack
    text: '*Melee Attack Roll:* +9, reach 15 ft. 12 (2d6 + 5) Bludgeoning damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of four tentacles.'
    attack:
      type: melee
      bonus: 9
      damage:
        - dice: 2d6
          bonus: 5
          type: Bludgeoning
          average: 12
      reach: 15 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 14
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of four tentacles.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Consume Memories
    entryType: save
    text: '*Intelligence Saving Throw*: DC 16, one creature within 30 feet that is Charmed or Grappled by the aboleth. *Failure:*  10 (3d6) Psychic damage. *Success:*  Half damage. *Failure or Success*:  The aboleth gains the target''s memories if the target is a Humanoid and is reduced to 0 Hit Points by this action.'
    save:
      ability: int
      dc: 16
      targeting:
        type: single
        range: 30 ft.
        restrictions:
          conditions:
            - Charmed
          other:
            - grappled by source
      onFail:
        effects:
          other: 10 (3d6) Psychic damage.
        damage:
          - dice: 3d6
            bonus: 0
            type: Psychic
            average: 10
        legacyEffects: 10 (3d6) Psychic damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Dominate Mind (2/Day)
    entryType: save
    text: '*Wisdom Saving Throw*: DC 16, one creature the aboleth can see within 30 feet. *Failure:*  The target has the Charmed condition until the aboleth dies or is on a different plane of existence from the target. While Charmed, the target acts as an ally to the aboleth and is under its control while within 60 feet of it. In addition, the aboleth and the target can communicate telepathically with each other over any distance. The target repeats the save whenever it takes damage as well as after every 24 hours it spends at least 1 mile away from the aboleth, ending the effect on itself on a success.'
    limitedUse:
      count: 2
      reset: day
    save:
      ability: wis
      dc: 16
      targeting:
        type: single
        range: 30 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Charmed
              duration:
                type: until
                trigger: the aboleth dies or is on a different plane of existence from the target
              saveToEnd:
                timing: when-damage
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Lash
    entryType: multiattack
    text: The aboleth makes one Tentacle attack.
    multiattack:
      attacks:
        - name: Tentacle
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
  - category: legendary
    name: Psychic Drain
    entryType: special
    text: If the aboleth has at least one creature Charmed or Grappled, it uses Consume Memories and regains 5 (1d10) Hit Points.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Aboleth
*Large, Aberration, Lawful Evil*

**AC** 17
**HP** 150 (20d10 + 40)
**Initiative** +3 (13)
**Speed** 10 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 20
**Languages** Deep Speech, telepathy 120 ft.
CR 10, PB +4, XP 5900

## Traits

**Amphibious**
The aboleth can breathe air and water.

**Eldritch Restoration**
If destroyed, the aboleth gains a new body in 5d10 days, reviving with all its Hit Points in the Far Realm or another location chosen by the DM.

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the aboleth fails a saving throw, it can choose to succeed instead.

**Mucus Cloud**
While underwater, the aboleth is surrounded by mucus. *Constitution Saving Throw*: DC 14, each creature in a 5-foot Emanation originating from the aboleth at the end of the aboleth's turn. *Failure:*  The target is cursed. Until the curse ends, the target's skin becomes slimy, the target can breathe air and water, and it can't regain Hit Points unless it is underwater. While the cursed creature is outside a body of water, the creature takes 6 (1d12) Acid damage at the end of every 10 minutes unless moisture is applied to its skin before those minutes have passed.

**Probing Telepathy**
If a creature the aboleth can see communicates telepathically with the aboleth, the aboleth learns the creature's greatest desires.

## Actions

**Multiattack**
The aboleth makes two Tentacle attacks and uses either Consume Memories or Dominate Mind if available.

**Tentacle**
*Melee Attack Roll:* +9, reach 15 ft. 12 (2d6 + 5) Bludgeoning damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of four tentacles.

**Consume Memories**
*Intelligence Saving Throw*: DC 16, one creature within 30 feet that is Charmed or Grappled by the aboleth. *Failure:*  10 (3d6) Psychic damage. *Success:*  Half damage. *Failure or Success*:  The aboleth gains the target's memories if the target is a Humanoid and is reduced to 0 Hit Points by this action.

**Dominate Mind (2/Day)**
*Wisdom Saving Throw*: DC 16, one creature the aboleth can see within 30 feet. *Failure:*  The target has the Charmed condition until the aboleth dies or is on a different plane of existence from the target. While Charmed, the target acts as an ally to the aboleth and is under its control while within 60 feet of it. In addition, the aboleth and the target can communicate telepathically with each other over any distance. The target repeats the save whenever it takes damage as well as after every 24 hours it spends at least 1 mile away from the aboleth, ending the effect on itself on a success.

## Legendary Actions

**Lash**
The aboleth makes one Tentacle attack.

**Psychic Drain**
If the aboleth has at least one creature Charmed or Grappled, it uses Consume Memories and regains 5 (1d10) Hit Points.
`,
      "Monsters/adult-black-dragon.md": `---
smType: creature
name: Adult Black Dragon
size: Huge
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '19'
initiative: +6 (16)
hp: '195'
hitDice: 17d12 + 85
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 80 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 23
    saveProf: false
  - key: dex
    score: 14
    saveProf: true
    saveMod: 7
  - key: con
    score: 21
    saveProf: false
  - key: int
    score: 14
    saveProf: false
  - key: wis
    score: 13
    saveProf: true
    saveMod: 6
  - key: cha
    score: 19
    saveProf: false
pb: '+5'
skills:
  - skill: Perception
    value: '11'
  - skill: Stealth
    value: '7'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '21'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Acid
cr: '14'
xp: '11500'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (3/Day, or 4/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Acid Arrow* (level 3 version).
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Acid Arrow
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +11, reach 10 ft. 13 (2d6 + 6) Slashing damage plus 4 (1d8) Acid damage.'
    attack:
      type: melee
      bonus: 11
      damage:
        - dice: 2d6
          bonus: 6
          type: Slashing
          average: 13
        - dice: 1d8
          bonus: 0
          type: Acid
          average: 4
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Acid Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 18, each creature in a 60-foot-long, 5-foot-wide Line. *Failure:*  54 (12d8) Acid damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 18
      targeting:
        shape: line
        size: 60 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 54 (12d8) Acid damage.
        damage:
          - dice: 12d8
            bonus: 0
            type: Acid
            average: 54
        legacyEffects: 54 (12d8) Acid damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Cloud of Insects
    entryType: save
    text: '*Dexterity Saving Throw*: DC 17, one creature the dragon can see within 120 feet. *Failure:*  22 (4d10) Poison damage, and the target has Disadvantage on saving throws to maintain  Concentration until the end of its next turn. *Failure or Success*:  The dragon can''t take this action again until the start of its next turn.'
    save:
      ability: dex
      dc: 17
      targeting:
        type: single
        range: 120 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          mechanical:
            - type: disadvantage
              target: saving throws to maintain  Concentration until the end of its next turn
              description: has Disadvantage on saving throws to maintain  Concentration until the end of its next turn.
            - type: advantage
              target: saving throws to maintain  Concentration until the end of its next turn
              description: advantage on saving throws to maintain  Concentration until the end of its next turn.
        damage:
          - dice: 4d10
            bonus: 0
            type: Poison
            average: 22
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon can move up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17, +9 to hit with spell attacks): - **At Will:** *Detect Magic*, *Fear*, *Acid Arrow* - **1e/Day Each:** *Speak with Dead*, *Vitriolic Sphere*'
    spellcasting:
      ability: cha
      saveDC: 17
      attackBonus: 9
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Fear
            - Acid Arrow
        - frequency: 1/day
          spells:
            - Speak with Dead
            - Vitriolic Sphere
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Frightful Presence
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Fear*. The dragon can't take this action again until the start of its next turn.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Adult Black Dragon
*Huge, Dragon, Chaotic Evil*

**AC** 19
**HP** 195 (17d12 + 85)
**Initiative** +6 (16)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 21
**Languages** Common, Draconic
CR 14, PB +5, XP 11500

## Traits

**Amphibious**
The dragon can breathe air and water.

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Acid Arrow* (level 3 version).

**Rend**
*Melee Attack Roll:* +11, reach 10 ft. 13 (2d6 + 6) Slashing damage plus 4 (1d8) Acid damage.

**Acid Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 18, each creature in a 60-foot-long, 5-foot-wide Line. *Failure:*  54 (12d8) Acid damage. *Success:*  Half damage.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17, +9 to hit with spell attacks): - **At Will:** *Detect Magic*, *Fear*, *Acid Arrow* - **1e/Day Each:** *Speak with Dead*, *Vitriolic Sphere*

## Legendary Actions

**Cloud of Insects**
*Dexterity Saving Throw*: DC 17, one creature the dragon can see within 120 feet. *Failure:*  22 (4d10) Poison damage, and the target has Disadvantage on saving throws to maintain  Concentration until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Frightful Presence**
The dragon uses Spellcasting to cast *Fear*. The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon can move up to half its Speed, and it makes one Rend attack.
`,
      "Monsters/adult-blue-dragon.md": `---
smType: creature
name: Adult Blue Dragon
size: Huge
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '19'
initiative: +4 (14)
hp: '212'
hitDice: 17d12 + 102
speeds:
  walk:
    distance: 40 ft.
  burrow:
    distance: 30 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 25
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 5
  - key: con
    score: 23
    saveProf: false
  - key: int
    score: 16
    saveProf: false
  - key: wis
    score: 15
    saveProf: true
    saveMod: 7
  - key: cha
    score: 20
    saveProf: false
pb: '+5'
skills:
  - skill: Perception
    value: '12'
  - skill: Stealth
    value: '5'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '22'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Lightning
cr: '16'
xp: '15000'
entries:
  - category: trait
    name: Legendary Resistance (3/Day, or 4/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Shatter*.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Shatter
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +12, reach 10 ft. 16 (2d8 + 7) Slashing damage plus 5 (1d10) Lightning damage.'
    attack:
      type: melee
      bonus: 12
      damage:
        - dice: 2d8
          bonus: 7
          type: Slashing
          average: 16
        - dice: 1d10
          bonus: 0
          type: Lightning
          average: 5
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Lightning Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 19, each creature in a 90-foot-long, 5-foot-wide Line. *Failure:*  60 (11d10) Lightning damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 19
      targeting:
        shape: line
        size: 90 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 60 (11d10) Lightning damage.
        damage:
          - dice: 11d10
            bonus: 0
            type: Lightning
            average: 60
        legacyEffects: 60 (11d10) Lightning damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Tail Swipe
    entryType: multiattack
    text: The dragon makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 18): - **At Will:** *Detect Magic*, *Invisibility*, *Mage Hand*, *Shatter* - **1e/Day Each:** *Scrying*, *Sending*'
    spellcasting:
      ability: cha
      saveDC: 18
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Invisibility
            - Mage Hand
            - Shatter
        - frequency: 1/day
          spells:
            - Scrying
            - Sending
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Cloaked Flight
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Invisibility* on itself, and it can fly up to half its Fly Speed. The dragon can't take this action again until the start of its next turn.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Sonic Boom
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Shatter*. The dragon can't take this action again until the start of its next turn.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Adult Blue Dragon
*Huge, Dragon, Lawful Evil*

**AC** 19
**HP** 212 (17d12 + 102)
**Initiative** +4 (14)
**Speed** 40 ft., fly 80 ft., burrow 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 22
**Languages** Common, Draconic
CR 16, PB +5, XP 15000

## Traits

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Shatter*.

**Rend**
*Melee Attack Roll:* +12, reach 10 ft. 16 (2d8 + 7) Slashing damage plus 5 (1d10) Lightning damage.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 19, each creature in a 90-foot-long, 5-foot-wide Line. *Failure:*  60 (11d10) Lightning damage. *Success:*  Half damage.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 18): - **At Will:** *Detect Magic*, *Invisibility*, *Mage Hand*, *Shatter* - **1e/Day Each:** *Scrying*, *Sending*

## Legendary Actions

**Cloaked Flight**
The dragon uses Spellcasting to cast *Invisibility* on itself, and it can fly up to half its Fly Speed. The dragon can't take this action again until the start of its next turn.

**Sonic Boom**
The dragon uses Spellcasting to cast *Shatter*. The dragon can't take this action again until the start of its next turn.

**Tail Swipe**
The dragon makes one Rend attack.
`,
      "Monsters/adult-brass-dragon.md": `---
smType: creature
name: Adult Brass Dragon
size: Huge
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Good
ac: '18'
initiative: +4 (14)
hp: '172'
hitDice: 15d12 + 75
speeds:
  walk:
    distance: 40 ft.
  burrow:
    distance: 30 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 23
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 5
  - key: con
    score: 21
    saveProf: false
  - key: int
    score: 14
    saveProf: false
  - key: wis
    score: 13
    saveProf: true
    saveMod: 6
  - key: cha
    score: 17
    saveProf: false
pb: '+5'
skills:
  - skill: History
    value: '7'
  - skill: Perception
    value: '11'
  - skill: Persuasion
    value: '8'
  - skill: Stealth
    value: '5'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '21'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Fire
cr: '13'
xp: '10000'
entries:
  - category: trait
    name: Legendary Resistance (3/Day, or 4/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of (A) Sleep Breath or (B) Spellcasting to cast *Scorching Ray*.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Scorching Ray
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +11, reach 10 ft. 17 (2d10 + 6) Slashing damage plus 4 (1d8) Fire damage.'
    attack:
      type: melee
      bonus: 11
      damage:
        - dice: 2d10
          bonus: 6
          type: Slashing
          average: 17
        - dice: 1d8
          bonus: 0
          type: Fire
          average: 4
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fire Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 18, each creature in a 60-foot-long, 5-foot-wide Line. *Failure:*  45 (10d8) Fire damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 18
      targeting:
        shape: line
        size: 60 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 45 (10d8) Fire damage.
        damage:
          - dice: 10d8
            bonus: 0
            type: Fire
            average: 45
        legacyEffects: 45 (10d8) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Sleep Breath
    entryType: save
    text: '*Constitution Saving Throw*: DC 18, each creature in a 60-foot Cone. *Failure:*  The target has the Incapacitated condition until the end of its next turn, at which point it repeats the save. *Second Failure* The target has the Unconscious condition for 10 minutes. This effect ends for the target if it takes damage or a creature within 5 feet of it takes an action to wake it.'
    save:
      ability: con
      dc: 18
      targeting:
        shape: cone
        size: 60 ft.
      onFail:
        effects:
          conditions:
            - condition: Incapacitated
              duration:
                type: until
                trigger: the end of its next turn
              saveToEnd:
                timing: custom
            - condition: Unconscious
              duration:
                type: until
                trigger: the end of its next turn
              saveToEnd:
                timing: custom
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
  - category: legendary
    name: Scorching Sands
    entryType: save
    text: '*Dexterity Saving Throw*: DC 16, one creature the dragon can see within 120 feet. *Failure:*  27 (6d8) Fire damage, and the target''s Speed is halved until the end of its next turn. *Failure or Success*:  The dragon can''t take this action again until the start of its next turn.'
    save:
      ability: dex
      dc: 16
      targeting:
        type: single
        range: 120 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          mechanical:
            - type: penalty
              modifier: half
              target: Speed
              description: Speed is halved
        damage:
          - dice: 6d8
            bonus: 0
            type: Fire
            average: 27
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 16): - **At Will:** *Detect Magic*, *Minor Illusion*, *Scorching Ray*, *Shapechange*, *Speak with Animals* - **1e/Day Each:** *Detect Thoughts*, *Control Weather*'
    spellcasting:
      ability: cha
      saveDC: 16
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Minor Illusion
            - Scorching Ray
            - Shapechange
            - Speak with Animals
        - frequency: 1/day
          spells:
            - Detect Thoughts
            - Control Weather
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Blazing Light
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Scorching Ray*.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Adult Brass Dragon
*Huge, Dragon, Chaotic Good*

**AC** 18
**HP** 172 (15d12 + 75)
**Initiative** +4 (14)
**Speed** 40 ft., fly 80 ft., burrow 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 21
**Languages** Common, Draconic
CR 13, PB +5, XP 10000

## Traits

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Sleep Breath or (B) Spellcasting to cast *Scorching Ray*.

**Rend**
*Melee Attack Roll:* +11, reach 10 ft. 17 (2d10 + 6) Slashing damage plus 4 (1d8) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 18, each creature in a 60-foot-long, 5-foot-wide Line. *Failure:*  45 (10d8) Fire damage. *Success:*  Half damage.

**Sleep Breath**
*Constitution Saving Throw*: DC 18, each creature in a 60-foot Cone. *Failure:*  The target has the Incapacitated condition until the end of its next turn, at which point it repeats the save. *Second Failure* The target has the Unconscious condition for 10 minutes. This effect ends for the target if it takes damage or a creature within 5 feet of it takes an action to wake it.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 16): - **At Will:** *Detect Magic*, *Minor Illusion*, *Scorching Ray*, *Shapechange*, *Speak with Animals* - **1e/Day Each:** *Detect Thoughts*, *Control Weather*

## Legendary Actions

**Blazing Light**
The dragon uses Spellcasting to cast *Scorching Ray*.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.

**Scorching Sands**
*Dexterity Saving Throw*: DC 16, one creature the dragon can see within 120 feet. *Failure:*  27 (6d8) Fire damage, and the target's Speed is halved until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.
`,
      "Monsters/adult-bronze-dragon.md": `---
smType: creature
name: Adult Bronze Dragon
size: Huge
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '18'
initiative: +4 (14)
hp: '212'
hitDice: 17d12 + 102
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 80 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 25
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 5
  - key: con
    score: 23
    saveProf: false
  - key: int
    score: 16
    saveProf: false
  - key: wis
    score: 15
    saveProf: true
    saveMod: 7
  - key: cha
    score: 20
    saveProf: false
pb: '+5'
skills:
  - skill: Insight
    value: '7'
  - skill: Perception
    value: '12'
  - skill: Stealth
    value: '5'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '22'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Lightning
cr: '15'
xp: '13000'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (3/Day, or 4/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of (A) Repulsion Breath or (B) Spellcasting to cast *Guiding Bolt* (level 2 version).
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Guiding Bolt
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +12, reach 10 ft. 16 (2d8 + 7) Slashing damage plus 5 (1d10) Lightning damage.'
    attack:
      type: melee
      bonus: 12
      damage:
        - dice: 2d8
          bonus: 7
          type: Slashing
          average: 16
        - dice: 1d10
          bonus: 0
          type: Lightning
          average: 5
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Lightning Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 19, each creature in a 90-foot-long, 5-foot-wide Line. *Failure:*  55 (10d10) Lightning damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 19
      targeting:
        shape: line
        size: 90 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 55 (10d10) Lightning damage.
        damage:
          - dice: 10d10
            bonus: 0
            type: Lightning
            average: 55
        legacyEffects: 55 (10d10) Lightning damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Repulsion Breath
    entryType: save
    text: '*Strength Saving Throw*: DC 19, each creature in a 30-foot Cone. *Failure:*  The target is pushed up to 60 feet straight away from the dragon and has the Prone condition.'
    save:
      ability: str
      dc: 19
      targeting:
        shape: cone
        size: 30 ft.
      onFail:
        effects:
          conditions:
            - condition: Prone
          movement:
            type: push
            distance: 60 feet
            direction: straight away from the dragon
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
  - category: legendary
    name: Thunderclap
    entryType: save
    text: '*Constitution Saving Throw*: DC 17, each creature in a 20-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 90 feet. *Failure:*  10 (3d6) Thunder damage, and the target has the Deafened condition until the end of its next turn.'
    save:
      ability: con
      dc: 17
      targeting:
        shape: sphere
        size: 20 ft.
      onFail:
        effects:
          conditions:
            - condition: Deafened
              duration:
                type: until
                trigger: the end of its next turn
        damage:
          - dice: 3d6
            bonus: 0
            type: Thunder
            average: 10
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17, +10 to hit with spell attacks): - **At Will:** *Detect Magic*, *Guiding Bolt*, *Shapechange*, *Speak with Animals*, *Thaumaturgy* - **1e/Day Each:** *Detect Thoughts*, *Water Breathing*'
    spellcasting:
      ability: cha
      saveDC: 17
      attackBonus: 10
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Guiding Bolt
            - Shapechange
            - Speak with Animals
            - Thaumaturgy
        - frequency: 1/day
          spells:
            - Detect Thoughts
            - Water Breathing
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Guiding Light
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Guiding Bolt* (level 2 version).
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Adult Bronze Dragon
*Huge, Dragon, Lawful Good*

**AC** 18
**HP** 212 (17d12 + 102)
**Initiative** +4 (14)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 22
**Languages** Common, Draconic
CR 15, PB +5, XP 13000

## Traits

**Amphibious**
The dragon can breathe air and water.

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Repulsion Breath or (B) Spellcasting to cast *Guiding Bolt* (level 2 version).

**Rend**
*Melee Attack Roll:* +12, reach 10 ft. 16 (2d8 + 7) Slashing damage plus 5 (1d10) Lightning damage.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 19, each creature in a 90-foot-long, 5-foot-wide Line. *Failure:*  55 (10d10) Lightning damage. *Success:*  Half damage.

**Repulsion Breath**
*Strength Saving Throw*: DC 19, each creature in a 30-foot Cone. *Failure:*  The target is pushed up to 60 feet straight away from the dragon and has the Prone condition.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17, +10 to hit with spell attacks): - **At Will:** *Detect Magic*, *Guiding Bolt*, *Shapechange*, *Speak with Animals*, *Thaumaturgy* - **1e/Day Each:** *Detect Thoughts*, *Water Breathing*

## Legendary Actions

**Guiding Light**
The dragon uses Spellcasting to cast *Guiding Bolt* (level 2 version).

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.

**Thunderclap**
*Constitution Saving Throw*: DC 17, each creature in a 20-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 90 feet. *Failure:*  10 (3d6) Thunder damage, and the target has the Deafened condition until the end of its next turn.
`,
      "Monsters/adult-copper-dragon.md": `---
smType: creature
name: Adult Copper Dragon
size: Huge
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Good
ac: '18'
initiative: +5 (15)
hp: '184'
hitDice: 16d12 + 80
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 40 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 23
    saveProf: false
  - key: dex
    score: 12
    saveProf: true
    saveMod: 6
  - key: con
    score: 21
    saveProf: false
  - key: int
    score: 18
    saveProf: false
  - key: wis
    score: 15
    saveProf: true
    saveMod: 7
  - key: cha
    score: 18
    saveProf: false
pb: '+5'
skills:
  - skill: Deception
    value: '9'
  - skill: Perception
    value: '12'
  - skill: Stealth
    value: '6'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '22'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Acid
cr: '14'
xp: '11500'
entries:
  - category: trait
    name: Legendary Resistance (3/Day, or 4/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of (A) Slowing Breath or (B) Spellcasting to cast *Mind Spike* (level 4 version).
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Mind Spike
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +11, reach 10 ft. 17 (2d10 + 6) Slashing damage plus 4 (1d8) Acid damage.'
    attack:
      type: melee
      bonus: 11
      damage:
        - dice: 2d10
          bonus: 6
          type: Slashing
          average: 17
        - dice: 1d8
          bonus: 0
          type: Acid
          average: 4
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Acid Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 18, each creature in an 60-foot-long, 5-foot-wide Line. *Failure:*  54 (12d8) Acid damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 18
      targeting:
        shape: line
        size: 60 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 54 (12d8) Acid damage.
        damage:
          - dice: 12d8
            bonus: 0
            type: Acid
            average: 54
        legacyEffects: 54 (12d8) Acid damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Slowing Breath
    entryType: save
    text: '*Constitution Saving Throw*: DC 18, each creature in a 60-foot Cone. *Failure:*  The target can''t take Reactions; its Speed is halved; and it can take either an action or a Bonus Action on its turn, not both. This effect lasts until the end of its next turn.'
    save:
      ability: con
      dc: 18
      targeting:
        shape: cone
        size: 60 ft.
      onFail:
        effects:
          mechanical:
            - type: penalty
              modifier: half
              target: Speed
              description: Speed is halved
            - type: other
              target: Reactions
              description: can't take Reactions
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Giggling Magic
    entryType: save
    text: '*Charisma Saving Throw*: DC 17, one creature the dragon can see within 90 feet. *Failure:*  24 (7d6) Psychic damage. Until the end of its next turn, the target rolls 1d6 whenever it makes an ability check or attack roll and subtracts the number rolled from the D20 Test. *Failure or Success*:  The dragon can''t take this action again until the start of its next turn.'
    save:
      ability: cha
      dc: 17
      targeting:
        type: single
        range: 90 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          other: 24 (7d6) Psychic damage. Until the end of its next turn, the target rolls 1d6 whenever it makes an ability check or attack roll and subtracts the number rolled from the D20 Test.
        damage:
          - dice: 7d6
            bonus: 0
            type: Psychic
            average: 24
        legacyEffects: 24 (7d6) Psychic damage. Until the end of its next turn, the target rolls 1d6 whenever it makes an ability check or attack roll and subtracts the number rolled from the D20 Test.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Magic*, *Mind Spike*, *Minor Illusion*, *Shapechange* - **1e/Day Each:** *Greater Restoration*, *Major Image*'
    spellcasting:
      ability: cha
      saveDC: 17
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Mind Spike
            - Minor Illusion
            - Shapechange
        - frequency: 1/day
          spells:
            - Greater Restoration
            - Major Image
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Mind Jolt
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Mind Spike* (level 4 version). The dragon can't take this action again until the start of its next turn.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Adult Copper Dragon
*Huge, Dragon, Chaotic Good*

**AC** 18
**HP** 184 (16d12 + 80)
**Initiative** +5 (15)
**Speed** 40 ft., climb 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 22
**Languages** Common, Draconic
CR 14, PB +5, XP 11500

## Traits

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Slowing Breath or (B) Spellcasting to cast *Mind Spike* (level 4 version).

**Rend**
*Melee Attack Roll:* +11, reach 10 ft. 17 (2d10 + 6) Slashing damage plus 4 (1d8) Acid damage.

**Acid Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 18, each creature in an 60-foot-long, 5-foot-wide Line. *Failure:*  54 (12d8) Acid damage. *Success:*  Half damage.

**Slowing Breath**
*Constitution Saving Throw*: DC 18, each creature in a 60-foot Cone. *Failure:*  The target can't take Reactions; its Speed is halved; and it can take either an action or a Bonus Action on its turn, not both. This effect lasts until the end of its next turn.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Magic*, *Mind Spike*, *Minor Illusion*, *Shapechange* - **1e/Day Each:** *Greater Restoration*, *Major Image*

## Legendary Actions

**Giggling Magic**
*Charisma Saving Throw*: DC 17, one creature the dragon can see within 90 feet. *Failure:*  24 (7d6) Psychic damage. Until the end of its next turn, the target rolls 1d6 whenever it makes an ability check or attack roll and subtracts the number rolled from the D20 Test. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Mind Jolt**
The dragon uses Spellcasting to cast *Mind Spike* (level 4 version). The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "Monsters/adult-gold-dragon.md": `---
smType: creature
name: Adult Gold Dragon
size: Huge
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '19'
initiative: +6 (16)
hp: '243'
hitDice: 18d12 + 126
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 80 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 27
    saveProf: false
  - key: dex
    score: 14
    saveProf: true
    saveMod: 8
  - key: con
    score: 25
    saveProf: false
  - key: int
    score: 16
    saveProf: false
  - key: wis
    score: 15
    saveProf: true
    saveMod: 8
  - key: cha
    score: 24
    saveProf: false
pb: '+6'
skills:
  - skill: Insight
    value: '8'
  - skill: Perception
    value: '14'
  - skill: Persuasion
    value: '13'
  - skill: Stealth
    value: '8'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '24'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Fire
cr: '17'
xp: '18000'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (3/Day, or 4/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of (A) Spellcasting to cast *Guiding Bolt* (level 2 version) or (B) Weakening Breath.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Guiding Bolt
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +14, reach 10 ft. 17 (2d8 + 8) Slashing damage plus 4 (1d8) Fire damage.'
    attack:
      type: melee
      bonus: 14
      damage:
        - dice: 2d8
          bonus: 8
          type: Slashing
          average: 17
        - dice: 1d8
          bonus: 0
          type: Fire
          average: 4
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fire Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 21, each creature in a 60-foot Cone. *Failure:*  66 (12d10) Fire damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 21
      targeting:
        shape: cone
        size: 60 ft.
      onFail:
        effects:
          other: 66 (12d10) Fire damage.
        damage:
          - dice: 12d10
            bonus: 0
            type: Fire
            average: 66
        legacyEffects: 66 (12d10) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Weakening Breath
    entryType: save
    text: '*Strength Saving Throw*: DC 21, each creature that isn''t currently affected by this breath in a 60-foot Cone. *Failure:*  The target has Disadvantage on Strength-based D20 Test and subtracts 3 (1d6) from its damage rolls. It repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.'
    save:
      ability: str
      dc: 21
      targeting:
        shape: cone
        size: 60 ft.
      onFail:
        effects:
          mechanical:
            - type: disadvantage
              target: Strength-based D20 Test
              description: has Disadvantage on Strength-based D20 Test and
            - type: advantage
              target: Strength-based D20 Test
              description: advantage on Strength-based D20 Test and
            - type: penalty
              modifier: -3
              target: damage rolls
              description: subtracts 3 (1d6) from its damage rolls.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Banish
    entryType: save
    text: '*Charisma Saving Throw*: DC 21, one creature the dragon can see within 120 feet. *Failure:*  10 (3d6) Force damage, and the target has the Incapacitated condition and is transported to a harmless demiplane until the start of the dragon''s next turn, at which point it reappears in an unoccupied space of the dragon''s choice within 120 feet of the dragon. *Failure or Success*:  The dragon can''t take this action again until the start of its next turn.'
    save:
      ability: cha
      dc: 21
      targeting:
        type: single
        range: 120 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Incapacitated
              duration:
                type: until
                trigger: the start of the dragon's next turn
        damage:
          - dice: 3d6
            bonus: 0
            type: Force
            average: 10
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21, +13 to hit with spell attacks): - **At Will:** *Detect Magic*, *Guiding Bolt*, *Shapechange* - **1e/Day Each:** *Flame Strike*, *Zone of Truth*'
    spellcasting:
      ability: cha
      saveDC: 21
      attackBonus: 13
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Guiding Bolt
            - Shapechange
        - frequency: 1/day
          spells:
            - Flame Strike
            - Zone of Truth
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Guiding Light
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Guiding Bolt* (level 2 version).
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Adult Gold Dragon
*Huge, Dragon, Lawful Good*

**AC** 19
**HP** 243 (18d12 + 126)
**Initiative** +6 (16)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 24
**Languages** Common, Draconic
CR 17, PB +6, XP 18000

## Traits

**Amphibious**
The dragon can breathe air and water.

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Spellcasting to cast *Guiding Bolt* (level 2 version) or (B) Weakening Breath.

**Rend**
*Melee Attack Roll:* +14, reach 10 ft. 17 (2d8 + 8) Slashing damage plus 4 (1d8) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 21, each creature in a 60-foot Cone. *Failure:*  66 (12d10) Fire damage. *Success:*  Half damage.

**Weakening Breath**
*Strength Saving Throw*: DC 21, each creature that isn't currently affected by this breath in a 60-foot Cone. *Failure:*  The target has Disadvantage on Strength-based D20 Test and subtracts 3 (1d6) from its damage rolls. It repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21, +13 to hit with spell attacks): - **At Will:** *Detect Magic*, *Guiding Bolt*, *Shapechange* - **1e/Day Each:** *Flame Strike*, *Zone of Truth*

## Legendary Actions

**Banish**
*Charisma Saving Throw*: DC 21, one creature the dragon can see within 120 feet. *Failure:*  10 (3d6) Force damage, and the target has the Incapacitated condition and is transported to a harmless demiplane until the start of the dragon's next turn, at which point it reappears in an unoccupied space of the dragon's choice within 120 feet of the dragon. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Guiding Light**
The dragon uses Spellcasting to cast *Guiding Bolt* (level 2 version).

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "Monsters/adult-green-dragon.md": `---
smType: creature
name: Adult Green Dragon
size: Huge
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '19'
initiative: +5 (15)
hp: '207'
hitDice: 18d12 + 90
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 80 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 23
    saveProf: false
  - key: dex
    score: 12
    saveProf: true
    saveMod: 6
  - key: con
    score: 21
    saveProf: false
  - key: int
    score: 18
    saveProf: false
  - key: wis
    score: 15
    saveProf: true
    saveMod: 7
  - key: cha
    score: 18
    saveProf: false
pb: '+5'
skills:
  - skill: Deception
    value: '9'
  - skill: Perception
    value: '12'
  - skill: Persuasion
    value: '9'
  - skill: Stealth
    value: '6'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '22'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Poison; Poisoned
cr: '15'
xp: '13000'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (3/Day, or 4/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Mind Spike* (level 3 version).
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Mind Spike
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +11, reach 10 ft. 15 (2d8 + 6) Slashing damage plus 7 (2d6) Poison damage.'
    attack:
      type: melee
      bonus: 11
      damage:
        - dice: 2d8
          bonus: 6
          type: Slashing
          average: 15
        - dice: 2d6
          bonus: 0
          type: Poison
          average: 7
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Poison Breath (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 18, each creature in a 60-foot Cone. *Failure:*  56 (16d6) Poison damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: con
      dc: 18
      targeting:
        shape: cone
        size: 60 ft.
      onFail:
        effects:
          other: 56 (16d6) Poison damage.
        damage:
          - dice: 16d6
            bonus: 0
            type: Poison
            average: 56
        legacyEffects: 56 (16d6) Poison damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Noxious Miasma
    entryType: save
    text: '*Constitution Saving Throw*: DC 17, each creature in a 20-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 90 feet. *Failure:*  7 (2d6) Poison damage, and the target takes a -2 penalty to AC until the end of its next turn. *Failure or Success*:  The dragon can''t take this action again until the start of its next turn.'
    save:
      ability: con
      dc: 17
      targeting:
        shape: sphere
        size: 20 ft.
      onFail:
        effects:
          other: 7 (2d6) Poison damage, and the target takes a -2 penalty to AC until the end of its next turn.
        damage:
          - dice: 2d6
            bonus: 0
            type: Poison
            average: 7
        legacyEffects: 7 (2d6) Poison damage, and the target takes a -2 penalty to AC until the end of its next turn.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Magic*, *Mind Spike* - **1/Day Each:** *Geas*'
    spellcasting:
      ability: cha
      saveDC: 17
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Mind Spike
        - frequency: 1/day
          spells:
            - Geas
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Mind Invasion
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Mind Spike* (level 3 version).
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Adult Green Dragon
*Huge, Dragon, Lawful Evil*

**AC** 19
**HP** 207 (18d12 + 90)
**Initiative** +5 (15)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 22
**Languages** Common, Draconic
CR 15, PB +5, XP 13000

## Traits

**Amphibious**
The dragon can breathe air and water.

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Mind Spike* (level 3 version).

**Rend**
*Melee Attack Roll:* +11, reach 10 ft. 15 (2d8 + 6) Slashing damage plus 7 (2d6) Poison damage.

**Poison Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 18, each creature in a 60-foot Cone. *Failure:*  56 (16d6) Poison damage. *Success:*  Half damage.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Magic*, *Mind Spike* - **1/Day Each:** *Geas*

## Legendary Actions

**Mind Invasion**
The dragon uses Spellcasting to cast *Mind Spike* (level 3 version).

**Noxious Miasma**
*Constitution Saving Throw*: DC 17, each creature in a 20-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 90 feet. *Failure:*  7 (2d6) Poison damage, and the target takes a -2 penalty to AC until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "Monsters/adult-red-dragon.md": `---
smType: creature
name: Adult Red Dragon
size: Huge
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '19'
initiative: +4 (14)
hp: '256'
hitDice: 19d12 + 133
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 40 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 27
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 6
  - key: con
    score: 25
    saveProf: false
  - key: int
    score: 16
    saveProf: false
  - key: wis
    score: 13
    saveProf: true
    saveMod: 7
  - key: cha
    score: 23
    saveProf: false
pb: '+6'
skills:
  - skill: Perception
    value: '13'
  - skill: Stealth
    value: '6'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '23'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Fire
cr: '17'
xp: '18000'
entries:
  - category: trait
    name: Legendary Resistance (3/Day, or 4/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Scorching Ray*.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Scorching Ray
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +14, reach 10 ft. 13 (1d10 + 8) Slashing damage plus 5 (2d4) Fire damage.'
    attack:
      type: melee
      bonus: 14
      damage:
        - dice: 1d10
          bonus: 8
          type: Slashing
          average: 13
        - dice: 2d4
          bonus: 0
          type: Fire
          average: 5
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fire Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 21, each creature in a 60-foot Cone. *Failure:*  59 (17d6) Fire damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 21
      targeting:
        shape: cone
        size: 60 ft.
      onFail:
        effects:
          other: 59 (17d6) Fire damage.
        damage:
          - dice: 17d6
            bonus: 0
            type: Fire
            average: 59
        legacyEffects: 59 (17d6) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 20, +12 to hit with spell attacks): - **At Will:** *Command*, *Detect Magic*, *Scorching Ray* - **1/Day Each:** *Fireball*'
    spellcasting:
      ability: cha
      saveDC: 20
      attackBonus: 12
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Command
            - Detect Magic
            - Scorching Ray
        - frequency: 1/day
          spells:
            - Fireball
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Commanding Presence
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Command* (level 2 version). The dragon can't take this action again until the start of its next turn.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Fiery Rays
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Scorching Ray*. The dragon can't take this action again until the start of its next turn.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Adult Red Dragon
*Huge, Dragon, Chaotic Evil*

**AC** 19
**HP** 256 (19d12 + 133)
**Initiative** +4 (14)
**Speed** 40 ft., climb 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 23
**Languages** Common, Draconic
CR 17, PB +6, XP 18000

## Traits

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Scorching Ray*.

**Rend**
*Melee Attack Roll:* +14, reach 10 ft. 13 (1d10 + 8) Slashing damage plus 5 (2d4) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 21, each creature in a 60-foot Cone. *Failure:*  59 (17d6) Fire damage. *Success:*  Half damage.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 20, +12 to hit with spell attacks): - **At Will:** *Command*, *Detect Magic*, *Scorching Ray* - **1/Day Each:** *Fireball*

## Legendary Actions

**Commanding Presence**
The dragon uses Spellcasting to cast *Command* (level 2 version). The dragon can't take this action again until the start of its next turn.

**Fiery Rays**
The dragon uses Spellcasting to cast *Scorching Ray*. The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "Monsters/adult-silver-dragon.md": `---
smType: creature
name: Adult Silver Dragon
size: Huge
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '19'
initiative: +4 (14)
hp: '216'
hitDice: 16d12 + 112
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 27
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 5
  - key: con
    score: 25
    saveProf: false
  - key: int
    score: 16
    saveProf: false
  - key: wis
    score: 13
    saveProf: true
    saveMod: 6
  - key: cha
    score: 22
    saveProf: false
pb: '+5'
skills:
  - skill: History
    value: '8'
  - skill: Perception
    value: '11'
  - skill: Stealth
    value: '5'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '21'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Cold
cr: '16'
xp: '15000'
entries:
  - category: trait
    name: Legendary Resistance (3/Day, or 4/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of (A) Paralyzing Breath or (B) Spellcasting to cast *Ice Knife*.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Ice Knife
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +13, reach 10 ft. 17 (2d8 + 8) Slashing damage plus 4 (1d8) Cold damage.'
    attack:
      type: melee
      bonus: 13
      damage:
        - dice: 2d8
          bonus: 8
          type: Slashing
          average: 17
        - dice: 1d8
          bonus: 0
          type: Cold
          average: 4
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Cold Breath (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 20, each creature in a 60-foot Cone. *Failure:*  54 (12d8) Cold damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: con
      dc: 20
      targeting:
        shape: cone
        size: 60 ft.
      onFail:
        effects:
          other: 54 (12d8) Cold damage.
        damage:
          - dice: 12d8
            bonus: 0
            type: Cold
            average: 54
        legacyEffects: 54 (12d8) Cold damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Paralyzing Breath
    entryType: save
    text: '*Constitution Saving Throw*: DC 20, each creature in a 60-foot Cone. *First Failure* The target has the Incapacitated condition until the end of its next turn, when it repeats the save. *Second Failure* The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.'
    save:
      ability: con
      dc: 20
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Cold Gale
    entryType: save
    text: '*Dexterity Saving Throw*: DC 19, each creature in a 60-foot-long, 10-foot-wide Line. *Failure:*  14 (4d6) Cold damage, and the target is pushed up to 30 feet straight away from the dragon. *Success:*  Half damage only. *Failure or Success*:  The dragon can''t take this action again until the start of its next turn.'
    save:
      ability: dex
      dc: 19
      targeting:
        shape: line
        size: 60 ft.
        width: 10 ft.
      onFail:
        effects:
          movement:
            type: push
            distance: 30 feet
            direction: straight away from the dragon
        damage:
          - dice: 4d6
            bonus: 0
            type: Cold
            average: 14
      onSuccess:
        damage: half
        legacyText: Half damage only.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 19, +11 to hit with spell attacks): - **At Will:** *Detect Magic*, *Hold Monster*, *Ice Knife*, *Shapechange* - **1e/Day Each:** *Ice Storm*, *Zone of Truth*'
    spellcasting:
      ability: cha
      saveDC: 19
      attackBonus: 11
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Hold Monster
            - Ice Knife
            - Shapechange
        - frequency: 1/day
          spells:
            - Ice Storm
            - Zone of Truth
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Chill
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Hold Monster*. The dragon can't take this action again until the start of its next turn.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Adult Silver Dragon
*Huge, Dragon, Lawful Good*

**AC** 19
**HP** 216 (16d12 + 112)
**Initiative** +4 (14)
**Speed** 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 21
**Languages** Common, Draconic
CR 16, PB +5, XP 15000

## Traits

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Paralyzing Breath or (B) Spellcasting to cast *Ice Knife*.

**Rend**
*Melee Attack Roll:* +13, reach 10 ft. 17 (2d8 + 8) Slashing damage plus 4 (1d8) Cold damage.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 20, each creature in a 60-foot Cone. *Failure:*  54 (12d8) Cold damage. *Success:*  Half damage.

**Paralyzing Breath**
*Constitution Saving Throw*: DC 20, each creature in a 60-foot Cone. *First Failure* The target has the Incapacitated condition until the end of its next turn, when it repeats the save. *Second Failure* The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 19, +11 to hit with spell attacks): - **At Will:** *Detect Magic*, *Hold Monster*, *Ice Knife*, *Shapechange* - **1e/Day Each:** *Ice Storm*, *Zone of Truth*

## Legendary Actions

**Chill**
The dragon uses Spellcasting to cast *Hold Monster*. The dragon can't take this action again until the start of its next turn.

**Cold Gale**
*Dexterity Saving Throw*: DC 19, each creature in a 60-foot-long, 10-foot-wide Line. *Failure:*  14 (4d6) Cold damage, and the target is pushed up to 30 feet straight away from the dragon. *Success:*  Half damage only. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "Monsters/adult-white-dragon.md": `---
smType: creature
name: Adult White Dragon
size: Huge
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '18'
initiative: +4 (14)
hp: '200'
hitDice: 16d12 + 96
speeds:
  walk:
    distance: 40 ft.
  burrow:
    distance: 30 ft.
  fly:
    distance: 80 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 22
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 5
  - key: con
    score: 22
    saveProf: false
  - key: int
    score: 8
    saveProf: false
  - key: wis
    score: 12
    saveProf: true
    saveMod: 6
  - key: cha
    score: 12
    saveProf: false
pb: '+5'
skills:
  - skill: Perception
    value: '11'
  - skill: Stealth
    value: '5'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '21'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Cold
cr: '13'
xp: '10000'
entries:
  - category: trait
    name: Ice Walk
    entryType: special
    text: The dragon can move across and climb icy surfaces without needing to make an ability check. Additionally, Difficult Terrain composed of ice or snow doesn't cost it extra movement.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (3/Day, or 4/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +11, reach 10 ft. 13 (2d6 + 6) Slashing damage plus 4 (1d8) Cold damage.'
    attack:
      type: melee
      bonus: 11
      damage:
        - dice: 2d6
          bonus: 6
          type: Slashing
          average: 13
        - dice: 1d8
          bonus: 0
          type: Cold
          average: 4
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Cold Breath (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 19, each creature in a 60-foot Cone. *Failure:*  54 (12d8) Cold damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: con
      dc: 19
      targeting:
        shape: cone
        size: 60 ft.
      onFail:
        effects:
          other: 54 (12d8) Cold damage.
        damage:
          - dice: 12d8
            bonus: 0
            type: Cold
            average: 54
        legacyEffects: 54 (12d8) Cold damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Freezing Burst
    entryType: save
    text: '*Constitution Saving Throw*: DC 14, each creature in a 30-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 120 feet. *Failure:*  7 (2d6) Cold damage, and the target''s Speed is 0 until the end of the target''s next turn. *Failure or Success*:  The dragon can''t take this action again until the start of its next turn.'
    save:
      ability: con
      dc: 14
      targeting:
        shape: sphere
        size: 30 ft.
      onFail:
        effects:
          other: 7 (2d6) Cold damage, and the target's Speed is 0 until the end of the target's next turn.
        damage:
          - dice: 2d6
            bonus: 0
            type: Cold
            average: 7
        legacyEffects: 7 (2d6) Cold damage, and the target's Speed is 0 until the end of the target's next turn.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: legendary
    name: Frightful Presence
    entryType: spellcasting
    text: The dragon casts *Fear*, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 14). The dragon can't take this action again until the start of its next turn.
    spellcasting:
      ability: cha
      saveDC: 14
      excludeComponents:
        - M
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Adult White Dragon
*Huge, Dragon, Chaotic Evil*

**AC** 18
**HP** 200 (16d12 + 96)
**Initiative** +4 (14)
**Speed** 40 ft., swim 40 ft., fly 80 ft., burrow 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 21
**Languages** Common, Draconic
CR 13, PB +5, XP 10000

## Traits

**Ice Walk**
The dragon can move across and climb icy surfaces without needing to make an ability check. Additionally, Difficult Terrain composed of ice or snow doesn't cost it extra movement.

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +11, reach 10 ft. 13 (2d6 + 6) Slashing damage plus 4 (1d8) Cold damage.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 19, each creature in a 60-foot Cone. *Failure:*  54 (12d8) Cold damage. *Success:*  Half damage.

## Legendary Actions

**Freezing Burst**
*Constitution Saving Throw*: DC 14, each creature in a 30-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 120 feet. *Failure:*  7 (2d6) Cold damage, and the target's Speed is 0 until the end of the target's next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.

**Frightful Presence**
The dragon casts *Fear*, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 14). The dragon can't take this action again until the start of its next turn.
`,
      "Monsters/air-elemental.md": `---
smType: creature
name: Air Elemental
size: Large
type: Elemental
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '15'
initiative: +5 (15)
hp: '90'
hitDice: 12d10 + 24
speeds:
  walk:
    distance: 10 ft.
  fly:
    distance: 90 ft.
    hover: true
abilities:
  - key: str
    score: 14
    saveProf: false
  - key: dex
    score: 20
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Primordial (Auran)
damageResistancesList:
  - value: Bludgeoning
  - value: Lightning
  - value: Piercing
  - value: Slashing
damageImmunitiesList:
  - value: Poison
  - value: Thunder; Exhaustion
conditionImmunitiesList:
  - value: Grappled
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
  - value: Prone
  - value: Restrained
  - value: Unconscious
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Air Form
    entryType: special
    text: The elemental can enter a creature's space and stop there. It can move through a space as narrow as 1 inch without expending extra movement to do so.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The elemental makes two Thunderous Slam attacks.
    multiattack:
      attacks:
        - name: Slam
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Thunderous Slam
    entryType: attack
    text: '*Melee Attack Roll:* +8, reach 10 ft. 14 (2d8 + 5) Thunder damage.'
    attack:
      type: melee
      bonus: 8
      damage:
        - dice: 2d8
          bonus: 5
          type: Thunder
          average: 14
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Whirlwind (Recharge 4-6)
    entryType: save
    text: '*Strength Saving Throw*: DC 13, one Medium or smaller creature in the elemental''s space. *Failure:*  24 (4d10 + 2) Thunder damage, and the target is pushed up to 20 feet straight away from the elemental and has the Prone condition. *Success:*  Half damage only.'
    recharge: 4-6
    save:
      ability: str
      dc: 13
      targeting:
        type: single
        restrictions:
          size:
            - Medium
            - smaller
      onFail:
        effects:
          conditions:
            - condition: Prone
          movement:
            type: push
            distance: 20 feet
            direction: straight away from the elemental
        damage:
          - dice: 4d10
            bonus: 2
            type: Thunder
            average: 24
      onSuccess:
        damage: half
        legacyText: Half damage only.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Air Elemental
*Large, Elemental, Neutral Neutral*

**AC** 15
**HP** 90 (12d10 + 24)
**Initiative** +5 (15)
**Speed** 10 ft., fly 90 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Primordial (Auran)
CR 5, PB +3, XP 1800

## Traits

**Air Form**
The elemental can enter a creature's space and stop there. It can move through a space as narrow as 1 inch without expending extra movement to do so.

## Actions

**Multiattack**
The elemental makes two Thunderous Slam attacks.

**Thunderous Slam**
*Melee Attack Roll:* +8, reach 10 ft. 14 (2d8 + 5) Thunder damage.

**Whirlwind (Recharge 4-6)**
*Strength Saving Throw*: DC 13, one Medium or smaller creature in the elemental's space. *Failure:*  24 (4d10 + 2) Thunder damage, and the target is pushed up to 20 feet straight away from the elemental and has the Prone condition. *Success:*  Half damage only.
`,
      "Monsters/ancient-black-dragon.md": `---
smType: creature
name: Ancient Black Dragon
size: Gargantuan
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '22'
initiative: +6 (16)
hp: '367'
hitDice: 21d20 + 147
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 80 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 27
    saveProf: false
  - key: dex
    score: 14
    saveProf: true
    saveMod: 9
  - key: con
    score: 25
    saveProf: false
  - key: int
    score: 16
    saveProf: false
  - key: wis
    score: 15
    saveProf: true
    saveMod: 9
  - key: cha
    score: 22
    saveProf: false
pb: '+7'
skills:
  - skill: Perception
    value: '16'
  - skill: Stealth
    value: '9'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '26'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Acid
cr: '21'
xp: '33000'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (4/Day, or 5/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 4
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Acid Arrow* (level 4 version).
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Acid Arrow
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +15, reach 15 ft. 17 (2d8 + 8) Slashing damage plus 9 (2d8) Acid damage.'
    attack:
      type: melee
      bonus: 15
      damage:
        - dice: 2d8
          bonus: 8
          type: Slashing
          average: 17
        - dice: 2d8
          bonus: 0
          type: Acid
          average: 9
      reach: 15 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Acid Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 22, each creature in a 90-foot-long, 10-foot-wide Line. *Failure:*  67 (15d8) Acid damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 22
      targeting:
        shape: line
        size: 90 ft.
        width: 10 ft.
      onFail:
        effects:
          other: 67 (15d8) Acid damage.
        damage:
          - dice: 15d8
            bonus: 0
            type: Acid
            average: 67
        legacyEffects: 67 (15d8) Acid damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Cloud of Insects
    entryType: save
    text: '*Dexterity Saving Throw*: DC 21, one creature the dragon can see within 120 feet. *Failure:*  33 (6d10) Poison damage, and the target has Disadvantage on saving throws to maintain  Concentration until the end of its next turn. *Failure or Success*:  The dragon can''t take this action again until the start of its next turn.'
    save:
      ability: dex
      dc: 21
      targeting:
        type: single
        range: 120 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          mechanical:
            - type: disadvantage
              target: saving throws to maintain  Concentration until the end of its next turn
              description: has Disadvantage on saving throws to maintain  Concentration until the end of its next turn.
            - type: advantage
              target: saving throws to maintain  Concentration until the end of its next turn
              description: advantage on saving throws to maintain  Concentration until the end of its next turn.
        damage:
          - dice: 6d10
            bonus: 0
            type: Poison
            average: 33
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21, +13 to hit with spell attacks): - **At Will:** *Detect Magic*, *Fear*, *Acid Arrow* - **1e/Day Each:** *Create Undead*, *Speak with Dead*, *Vitriolic Sphere*'
    spellcasting:
      ability: cha
      saveDC: 21
      attackBonus: 13
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Fear
            - Acid Arrow
        - frequency: 1/day
          spells:
            - Create Undead
            - Speak with Dead
            - Vitriolic Sphere
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Frightful Presence
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Fear*. The dragon can't take this action again until the start of its next turn.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Ancient Black Dragon
*Gargantuan, Dragon, Chaotic Evil*

**AC** 22
**HP** 367 (21d20 + 147)
**Initiative** +6 (16)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 26
**Languages** Common, Draconic
CR 21, PB +7, XP 33000

## Traits

**Amphibious**
The dragon can breathe air and water.

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Acid Arrow* (level 4 version).

**Rend**
*Melee Attack Roll:* +15, reach 15 ft. 17 (2d8 + 8) Slashing damage plus 9 (2d8) Acid damage.

**Acid Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 22, each creature in a 90-foot-long, 10-foot-wide Line. *Failure:*  67 (15d8) Acid damage. *Success:*  Half damage.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21, +13 to hit with spell attacks): - **At Will:** *Detect Magic*, *Fear*, *Acid Arrow* - **1e/Day Each:** *Create Undead*, *Speak with Dead*, *Vitriolic Sphere*

## Legendary Actions

**Cloud of Insects**
*Dexterity Saving Throw*: DC 21, one creature the dragon can see within 120 feet. *Failure:*  33 (6d10) Poison damage, and the target has Disadvantage on saving throws to maintain  Concentration until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Frightful Presence**
The dragon uses Spellcasting to cast *Fear*. The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "Monsters/ancient-blue-dragon.md": `---
smType: creature
name: Ancient Blue Dragon
size: Gargantuan
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '22'
initiative: +4 (14)
hp: '481'
hitDice: 26d20 + 208
speeds:
  walk:
    distance: 40 ft.
  burrow:
    distance: 40 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 29
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 7
  - key: con
    score: 27
    saveProf: false
  - key: int
    score: 18
    saveProf: false
  - key: wis
    score: 17
    saveProf: true
    saveMod: 10
  - key: cha
    score: 25
    saveProf: false
pb: '+7'
skills:
  - skill: Perception
    value: '17'
  - skill: Stealth
    value: '7'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '27'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Lightning
cr: '23'
xp: '50000'
entries:
  - category: trait
    name: Legendary Resistance (4/Day, or 5/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 4
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Shatter* (level 3 version).
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Shatter
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +16, reach 15 ft. 18 (2d8 + 9) Slashing damage plus 11 (2d10) Lightning damage.'
    attack:
      type: melee
      bonus: 16
      damage:
        - dice: 2d8
          bonus: 9
          type: Slashing
          average: 18
        - dice: 2d10
          bonus: 0
          type: Lightning
          average: 11
      reach: 15 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Lightning Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 23, each creature in a 120-foot-long, 10-foot-wide Line. *Failure:*  88 (16d10) Lightning damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 23
      targeting:
        shape: line
        size: 120 ft.
        width: 10 ft.
      onFail:
        effects:
          other: 88 (16d10) Lightning damage.
        damage:
          - dice: 16d10
            bonus: 0
            type: Lightning
            average: 88
        legacyEffects: 88 (16d10) Lightning damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Tail Swipe
    entryType: multiattack
    text: The dragon makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 22): - **At Will:** *Detect Magic*, *Invisibility*, *Mage Hand*, *Shatter* - **1e/Day Each:** *Scrying*, *Sending*'
    spellcasting:
      ability: cha
      saveDC: 22
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Invisibility
            - Mage Hand
            - Shatter
        - frequency: 1/day
          spells:
            - Scrying
            - Sending
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Cloaked Flight
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Invisibility* on itself, and it can fly up to half its Fly Speed. The dragon can't take this action again until the start of its next turn.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Sonic Boom
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Shatter* (level 3 version). The dragon can't take this action again until the start of its next turn.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Ancient Blue Dragon
*Gargantuan, Dragon, Lawful Evil*

**AC** 22
**HP** 481 (26d20 + 208)
**Initiative** +4 (14)
**Speed** 40 ft., fly 80 ft., burrow 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 27
**Languages** Common, Draconic
CR 23, PB +7, XP 50000

## Traits

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Shatter* (level 3 version).

**Rend**
*Melee Attack Roll:* +16, reach 15 ft. 18 (2d8 + 9) Slashing damage plus 11 (2d10) Lightning damage.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 23, each creature in a 120-foot-long, 10-foot-wide Line. *Failure:*  88 (16d10) Lightning damage. *Success:*  Half damage.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 22): - **At Will:** *Detect Magic*, *Invisibility*, *Mage Hand*, *Shatter* - **1e/Day Each:** *Scrying*, *Sending*

## Legendary Actions

**Cloaked Flight**
The dragon uses Spellcasting to cast *Invisibility* on itself, and it can fly up to half its Fly Speed. The dragon can't take this action again until the start of its next turn.

**Sonic Boom**
The dragon uses Spellcasting to cast *Shatter* (level 3 version). The dragon can't take this action again until the start of its next turn.

**Tail Swipe**
The dragon makes one Rend attack.
`,
      "Monsters/ancient-brass-dragon.md": `---
smType: creature
name: Ancient Brass Dragon
size: Gargantuan
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Good
ac: '20'
initiative: +4 (14)
hp: '332'
hitDice: 19d20 + 133
speeds:
  walk:
    distance: 40 ft.
  burrow:
    distance: 40 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 27
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 6
  - key: con
    score: 25
    saveProf: false
  - key: int
    score: 16
    saveProf: false
  - key: wis
    score: 15
    saveProf: true
    saveMod: 8
  - key: cha
    score: 22
    saveProf: false
pb: '+6'
skills:
  - skill: History
    value: '9'
  - skill: Perception
    value: '14'
  - skill: Persuasion
    value: '12'
  - skill: Stealth
    value: '6'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '24'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Fire
cr: '20'
xp: '25000'
entries:
  - category: trait
    name: Legendary Resistance (4/Day, or 5/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 4
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of (A) Sleep Breath or (B) Spellcasting to cast *Scorching Ray* (level 3 version).
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Scorching Ray
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +14, reach 15 ft. 19 (2d10 + 8) Slashing damage plus 7 (2d6) Fire damage.'
    attack:
      type: melee
      bonus: 14
      damage:
        - dice: 2d10
          bonus: 8
          type: Slashing
          average: 19
        - dice: 2d6
          bonus: 0
          type: Fire
          average: 7
      reach: 15 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fire Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 21, each creature in a 90-foot-long, 5-foot-wide Line. *Failure:*  58 (13d8) Fire damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 21
      targeting:
        shape: line
        size: 90 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 58 (13d8) Fire damage.
        damage:
          - dice: 13d8
            bonus: 0
            type: Fire
            average: 58
        legacyEffects: 58 (13d8) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Sleep Breath
    entryType: save
    text: '*Constitution Saving Throw*: DC 21, each creature in a 90-foot Cone. *Failure:*  The target has the Incapacitated condition until the end of its next turn, at which point it repeats the save. *Second Failure* The target has the Unconscious condition for 10 minutes. This effect ends for the target if it takes damage or a creature within 5 feet of it takes an action to wake it.'
    save:
      ability: con
      dc: 21
      targeting:
        shape: cone
        size: 90 ft.
      onFail:
        effects:
          conditions:
            - condition: Incapacitated
              duration:
                type: until
                trigger: the end of its next turn
              saveToEnd:
                timing: custom
            - condition: Unconscious
              duration:
                type: until
                trigger: the end of its next turn
              saveToEnd:
                timing: custom
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
  - category: legendary
    name: Scorching Sands
    entryType: save
    text: '*Dexterity Saving Throw*: DC 20, one creature the dragon can see within 120 feet. *Failure:*  36 (8d8) Fire damage, and the target''s Speed is halved until the end of its next turn. *Failure or Success*:  The dragon can''t take this action again until the start of its next turn.'
    save:
      ability: dex
      dc: 20
      targeting:
        type: single
        range: 120 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          mechanical:
            - type: penalty
              modifier: half
              target: Speed
              description: Speed is halved
        damage:
          - dice: 8d8
            bonus: 0
            type: Fire
            average: 36
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 20): - **At Will:** *Detect Magic*, *Minor Illusion*, *Scorching Ray*, *Shapechange*, *Speak with Animals* - **1e/Day Each:** *Control Weather*, *Detect Thoughts*'
    spellcasting:
      ability: cha
      saveDC: 20
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Minor Illusion
            - Scorching Ray
            - Shapechange
            - Speak with Animals
        - frequency: 1/day
          spells:
            - Control Weather
            - Detect Thoughts
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Blazing Light
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Scorching Ray* (level 3 version).
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Ancient Brass Dragon
*Gargantuan, Dragon, Chaotic Good*

**AC** 20
**HP** 332 (19d20 + 133)
**Initiative** +4 (14)
**Speed** 40 ft., fly 80 ft., burrow 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 24
**Languages** Common, Draconic
CR 20, PB +6, XP 25000

## Traits

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Sleep Breath or (B) Spellcasting to cast *Scorching Ray* (level 3 version).

**Rend**
*Melee Attack Roll:* +14, reach 15 ft. 19 (2d10 + 8) Slashing damage plus 7 (2d6) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 21, each creature in a 90-foot-long, 5-foot-wide Line. *Failure:*  58 (13d8) Fire damage. *Success:*  Half damage.

**Sleep Breath**
*Constitution Saving Throw*: DC 21, each creature in a 90-foot Cone. *Failure:*  The target has the Incapacitated condition until the end of its next turn, at which point it repeats the save. *Second Failure* The target has the Unconscious condition for 10 minutes. This effect ends for the target if it takes damage or a creature within 5 feet of it takes an action to wake it.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 20): - **At Will:** *Detect Magic*, *Minor Illusion*, *Scorching Ray*, *Shapechange*, *Speak with Animals* - **1e/Day Each:** *Control Weather*, *Detect Thoughts*

## Legendary Actions

**Blazing Light**
The dragon uses Spellcasting to cast *Scorching Ray* (level 3 version).

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.

**Scorching Sands**
*Dexterity Saving Throw*: DC 20, one creature the dragon can see within 120 feet. *Failure:*  36 (8d8) Fire damage, and the target's Speed is halved until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.
`,
      "Monsters/ancient-bronze-dragon.md": `---
smType: creature
name: Ancient Bronze Dragon
size: Gargantuan
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '22'
initiative: +4 (14)
hp: '444'
hitDice: 24d20 + 192
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 80 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 29
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 7
  - key: con
    score: 27
    saveProf: false
  - key: int
    score: 18
    saveProf: false
  - key: wis
    score: 17
    saveProf: true
    saveMod: 10
  - key: cha
    score: 25
    saveProf: false
pb: '+7'
skills:
  - skill: Insight
    value: '10'
  - skill: Perception
    value: '17'
  - skill: Stealth
    value: '7'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '27'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Lightning
cr: '22'
xp: '41000'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (4/Day, or 5/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 4
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of (A) Repulsion Breath or (B) Spellcasting to cast *Guiding Bolt* (level 2 version).
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Guiding Bolt
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +16, reach 15 ft. 18 (2d8 + 9) Slashing damage plus 9 (2d8) Lightning damage.'
    attack:
      type: melee
      bonus: 16
      damage:
        - dice: 2d8
          bonus: 9
          type: Slashing
          average: 18
        - dice: 2d8
          bonus: 0
          type: Lightning
          average: 9
      reach: 15 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Lightning Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 23, each creature in a 120-foot-long, 10-foot-wide Line. *Failure:*  82 (15d10) Lightning damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 23
      targeting:
        shape: line
        size: 120 ft.
        width: 10 ft.
      onFail:
        effects:
          other: 82 (15d10) Lightning damage.
        damage:
          - dice: 15d10
            bonus: 0
            type: Lightning
            average: 82
        legacyEffects: 82 (15d10) Lightning damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Repulsion Breath
    entryType: save
    text: '*Strength Saving Throw*: DC 23, each creature in a 30-foot Cone. *Failure:*  The target is pushed up to 60 feet straight away from the dragon and has the Prone condition.'
    save:
      ability: str
      dc: 23
      targeting:
        shape: cone
        size: 30 ft.
      onFail:
        effects:
          conditions:
            - condition: Prone
          movement:
            type: push
            distance: 60 feet
            direction: straight away from the dragon
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
  - category: legendary
    name: Thunderclap
    entryType: save
    text: '*Constitution Saving Throw*: DC 22, each creature in a 20-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 120 feet. *Failure:*  13 (3d8) Thunder damage, and the target has the Deafened condition until the end of its next turn.'
    save:
      ability: con
      dc: 22
      targeting:
        shape: sphere
        size: 20 ft.
      onFail:
        effects:
          conditions:
            - condition: Deafened
              duration:
                type: until
                trigger: the end of its next turn
        damage:
          - dice: 3d8
            bonus: 0
            type: Thunder
            average: 13
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 22, +14 to hit with spell attacks): - **At Will:** *Detect Magic*, *Guiding Bolt*, *Shapechange*, *Speak with Animals*, *Thaumaturgy* - **1e/Day Each:** *Detect Thoughts*, *Control Water*, *Scrying*, *Water Breathing*'
    spellcasting:
      ability: cha
      saveDC: 22
      attackBonus: 14
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Guiding Bolt
            - Shapechange
            - Speak with Animals
            - Thaumaturgy
        - frequency: 1/day
          spells:
            - Detect Thoughts
            - Control Water
            - Scrying
            - Water Breathing
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Guiding Light
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Guiding Bolt* (level 2 version).
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Ancient Bronze Dragon
*Gargantuan, Dragon, Lawful Good*

**AC** 22
**HP** 444 (24d20 + 192)
**Initiative** +4 (14)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 27
**Languages** Common, Draconic
CR 22, PB +7, XP 41000

## Traits

**Amphibious**
The dragon can breathe air and water.

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Repulsion Breath or (B) Spellcasting to cast *Guiding Bolt* (level 2 version).

**Rend**
*Melee Attack Roll:* +16, reach 15 ft. 18 (2d8 + 9) Slashing damage plus 9 (2d8) Lightning damage.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 23, each creature in a 120-foot-long, 10-foot-wide Line. *Failure:*  82 (15d10) Lightning damage. *Success:*  Half damage.

**Repulsion Breath**
*Strength Saving Throw*: DC 23, each creature in a 30-foot Cone. *Failure:*  The target is pushed up to 60 feet straight away from the dragon and has the Prone condition.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 22, +14 to hit with spell attacks): - **At Will:** *Detect Magic*, *Guiding Bolt*, *Shapechange*, *Speak with Animals*, *Thaumaturgy* - **1e/Day Each:** *Detect Thoughts*, *Control Water*, *Scrying*, *Water Breathing*

## Legendary Actions

**Guiding Light**
The dragon uses Spellcasting to cast *Guiding Bolt* (level 2 version).

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.

**Thunderclap**
*Constitution Saving Throw*: DC 22, each creature in a 20-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 120 feet. *Failure:*  13 (3d8) Thunder damage, and the target has the Deafened condition until the end of its next turn.
`,
      "Monsters/ancient-copper-dragon.md": `---
smType: creature
name: Ancient Copper Dragon
size: Gargantuan
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Good
ac: '21'
initiative: +5 (15)
hp: '367'
hitDice: 21d20 + 147
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 40 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 27
    saveProf: false
  - key: dex
    score: 12
    saveProf: true
    saveMod: 8
  - key: con
    score: 25
    saveProf: false
  - key: int
    score: 20
    saveProf: false
  - key: wis
    score: 17
    saveProf: true
    saveMod: 10
  - key: cha
    score: 22
    saveProf: false
pb: '+7'
skills:
  - skill: Deception
    value: '13'
  - skill: Perception
    value: '17'
  - skill: Stealth
    value: '8'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '27'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Acid
cr: '21'
xp: '33000'
entries:
  - category: trait
    name: Legendary Resistance (4/Day, or 5/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 4
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of (A) Slowing Breath or (B) Spellcasting to cast *Mind Spike* (level 5 version).
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Mind Spike
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +15, reach 15 ft. 19 (2d10 + 8) Slashing damage plus 9 (2d8) Acid damage.'
    attack:
      type: melee
      bonus: 15
      damage:
        - dice: 2d10
          bonus: 8
          type: Slashing
          average: 19
        - dice: 2d8
          bonus: 0
          type: Acid
          average: 9
      reach: 15 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Acid Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 22, each creature in an 90-foot-long, 10-foot-wide Line. *Failure:*  63 (14d8) Acid damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 22
      targeting:
        shape: line
        size: 90 ft.
        width: 10 ft.
      onFail:
        effects:
          other: 63 (14d8) Acid damage.
        damage:
          - dice: 14d8
            bonus: 0
            type: Acid
            average: 63
        legacyEffects: 63 (14d8) Acid damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Slowing Breath
    entryType: save
    text: '*Constitution Saving Throw*: DC 22, each creature in a 90-foot Cone. *Failure:*  The target can''t take Reactions; its Speed is halved; and it can take either an action or a Bonus Action on its turn, not both. This effect lasts until the end of its next turn.'
    save:
      ability: con
      dc: 22
      targeting:
        shape: cone
        size: 90 ft.
      onFail:
        effects:
          mechanical:
            - type: penalty
              modifier: half
              target: Speed
              description: Speed is halved
            - type: other
              target: Reactions
              description: can't take Reactions
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Giggling Magic
    entryType: save
    text: '*Charisma Saving Throw*: DC 21, one creature the dragon can see within 120 feet. *Failure:*  31 (9d6) Psychic damage. Until the end of its next turn, the target rolls 1d8 whenever it makes an ability check or attack roll and subtracts the number rolled from the D20 Test. *Failure or Success*:  The dragon can''t take this action again until the start of its next turn.'
    save:
      ability: cha
      dc: 21
      targeting:
        type: single
        range: 120 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          other: 31 (9d6) Psychic damage. Until the end of its next turn, the target rolls 1d8 whenever it makes an ability check or attack roll and subtracts the number rolled from the D20 Test.
        damage:
          - dice: 9d6
            bonus: 0
            type: Psychic
            average: 31
        legacyEffects: 31 (9d6) Psychic damage. Until the end of its next turn, the target rolls 1d8 whenever it makes an ability check or attack roll and subtracts the number rolled from the D20 Test.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21): - **At Will:** *Detect Magic*, *Mind Spike*, *Minor Illusion*, *Shapechange* - **1e/Day Each:** *Greater Restoration*, *Major Image*, *Project Image*'
    spellcasting:
      ability: cha
      saveDC: 21
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Mind Spike
            - Minor Illusion
            - Shapechange
        - frequency: 1/day
          spells:
            - Greater Restoration
            - Major Image
            - Project Image
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Mind Jolt
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Mind Spike* (level 5 version). The dragon can't take this action again until the start of its next turn.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Ancient Copper Dragon
*Gargantuan, Dragon, Chaotic Good*

**AC** 21
**HP** 367 (21d20 + 147)
**Initiative** +5 (15)
**Speed** 40 ft., climb 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 27
**Languages** Common, Draconic
CR 21, PB +7, XP 33000

## Traits

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Slowing Breath or (B) Spellcasting to cast *Mind Spike* (level 5 version).

**Rend**
*Melee Attack Roll:* +15, reach 15 ft. 19 (2d10 + 8) Slashing damage plus 9 (2d8) Acid damage.

**Acid Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 22, each creature in an 90-foot-long, 10-foot-wide Line. *Failure:*  63 (14d8) Acid damage. *Success:*  Half damage.

**Slowing Breath**
*Constitution Saving Throw*: DC 22, each creature in a 90-foot Cone. *Failure:*  The target can't take Reactions; its Speed is halved; and it can take either an action or a Bonus Action on its turn, not both. This effect lasts until the end of its next turn.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21): - **At Will:** *Detect Magic*, *Mind Spike*, *Minor Illusion*, *Shapechange* - **1e/Day Each:** *Greater Restoration*, *Major Image*, *Project Image*

## Legendary Actions

**Giggling Magic**
*Charisma Saving Throw*: DC 21, one creature the dragon can see within 120 feet. *Failure:*  31 (9d6) Psychic damage. Until the end of its next turn, the target rolls 1d8 whenever it makes an ability check or attack roll and subtracts the number rolled from the D20 Test. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Mind Jolt**
The dragon uses Spellcasting to cast *Mind Spike* (level 5 version). The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "Monsters/ancient-gold-dragon.md": `---
smType: creature
name: Ancient Gold Dragon
size: Gargantuan
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '22'
initiative: +6 (16)
hp: '546'
hitDice: 28d20 + 252
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 80 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 30
    saveProf: false
  - key: dex
    score: 14
    saveProf: true
    saveMod: 9
  - key: con
    score: 29
    saveProf: false
  - key: int
    score: 18
    saveProf: false
  - key: wis
    score: 17
    saveProf: true
    saveMod: 10
  - key: cha
    score: 28
    saveProf: false
pb: '+7'
skills:
  - skill: Insight
    value: '10'
  - skill: Perception
    value: '17'
  - skill: Persuasion
    value: '16'
  - skill: Stealth
    value: '9'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '27'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Fire
cr: '24'
xp: '62000'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (4/Day, or 5/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 4
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of (A) Spellcasting to cast *Guiding Bolt* (level 4 version) or (B) Weakening Breath.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Guiding Bolt
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +17 to hit, reach 15 ft. 19 (2d8 + 10) Slashing damage plus 9 (2d8) Fire damage.'
    attack:
      type: melee
      bonus: 17
      damage:
        - dice: 2d8
          bonus: 10
          type: Slashing
          average: 19
        - dice: 2d8
          bonus: 0
          type: Fire
          average: 9
      reach: 15 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fire Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 24, each creature in a 90-foot Cone. *Failure:*  71 (13d10) Fire damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 24
      targeting:
        shape: cone
        size: 90 ft.
      onFail:
        effects:
          other: 71 (13d10) Fire damage.
        damage:
          - dice: 13d10
            bonus: 0
            type: Fire
            average: 71
        legacyEffects: 71 (13d10) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Weakening Breath
    entryType: save
    text: '*Strength Saving Throw*: DC 24, each creature that isn''t currently affected by this breath in a 90-foot Cone. *Failure:*  The target has Disadvantage on Strength-based D20 Test and subtracts 5 (1d10) from its damage rolls. It repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.'
    save:
      ability: str
      dc: 24
      targeting:
        shape: cone
        size: 90 ft.
      onFail:
        effects:
          mechanical:
            - type: disadvantage
              target: Strength-based D20 Test
              description: has Disadvantage on Strength-based D20 Test and
            - type: advantage
              target: Strength-based D20 Test
              description: advantage on Strength-based D20 Test and
            - type: penalty
              modifier: -5
              target: damage rolls
              description: subtracts 5 (1d10) from its damage rolls.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Banish
    entryType: save
    text: '*Charisma Saving Throw*: DC 24, one creature the dragon can see within 120 feet. *Failure:*  24 (7d6) Force damage, and the target has the Incapacitated condition and is transported to a harmless demiplane until the start of the dragon''s next turn, at which point it reappears in an unoccupied space of the dragon''s choice within 120 feet of the dragon. *Failure or Success*:  The dragon can''t take this action again until the start of its next turn.'
    save:
      ability: cha
      dc: 24
      targeting:
        type: single
        range: 120 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Incapacitated
              duration:
                type: until
                trigger: the start of the dragon's next turn
        damage:
          - dice: 7d6
            bonus: 0
            type: Force
            average: 24
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 24, +16 to hit with spell attacks): - **At Will:** *Detect Magic*, *Guiding Bolt*, *Shapechange* - **1e/Day Each:** *Flame Strike*, *Word of Recall*, *Zone of Truth*'
    spellcasting:
      ability: cha
      saveDC: 24
      attackBonus: 16
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Guiding Bolt
            - Shapechange
        - frequency: 1/day
          spells:
            - Flame Strike
            - Word of Recall
            - Zone of Truth
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Guiding Light
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Guiding Bolt* (level 4 version).
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Ancient Gold Dragon
*Gargantuan, Dragon, Lawful Good*

**AC** 22
**HP** 546 (28d20 + 252)
**Initiative** +6 (16)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 27
**Languages** Common, Draconic
CR 24, PB +7, XP 62000

## Traits

**Amphibious**
The dragon can breathe air and water.

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Spellcasting to cast *Guiding Bolt* (level 4 version) or (B) Weakening Breath.

**Rend**
*Melee Attack Roll:* +17 to hit, reach 15 ft. 19 (2d8 + 10) Slashing damage plus 9 (2d8) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 24, each creature in a 90-foot Cone. *Failure:*  71 (13d10) Fire damage. *Success:*  Half damage.

**Weakening Breath**
*Strength Saving Throw*: DC 24, each creature that isn't currently affected by this breath in a 90-foot Cone. *Failure:*  The target has Disadvantage on Strength-based D20 Test and subtracts 5 (1d10) from its damage rolls. It repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 24, +16 to hit with spell attacks): - **At Will:** *Detect Magic*, *Guiding Bolt*, *Shapechange* - **1e/Day Each:** *Flame Strike*, *Word of Recall*, *Zone of Truth*

## Legendary Actions

**Banish**
*Charisma Saving Throw*: DC 24, one creature the dragon can see within 120 feet. *Failure:*  24 (7d6) Force damage, and the target has the Incapacitated condition and is transported to a harmless demiplane until the start of the dragon's next turn, at which point it reappears in an unoccupied space of the dragon's choice within 120 feet of the dragon. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Guiding Light**
The dragon uses Spellcasting to cast *Guiding Bolt* (level 4 version).

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "Monsters/ancient-green-dragon.md": `---
smType: creature
name: Ancient Green Dragon
size: Gargantuan
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '21'
initiative: +5 (15)
hp: '402'
hitDice: 23d20 + 161
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 80 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 27
    saveProf: false
  - key: dex
    score: 12
    saveProf: true
    saveMod: 8
  - key: con
    score: 25
    saveProf: false
  - key: int
    score: 20
    saveProf: false
  - key: wis
    score: 17
    saveProf: true
    saveMod: 10
  - key: cha
    score: 22
    saveProf: false
pb: '+7'
skills:
  - skill: Deception
    value: '13'
  - skill: Perception
    value: '17'
  - skill: Persuasion
    value: '13'
  - skill: Stealth
    value: '8'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '27'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Poison; Poisoned
cr: '22'
xp: '41000'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (4/Day, or 5/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 4
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Mind Spike* (level 5 version).
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Mind Spike
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +15, reach 15 ft. 17 (2d8 + 8) Slashing damage plus 10 (3d6) Poison damage.'
    attack:
      type: melee
      bonus: 15
      damage:
        - dice: 2d8
          bonus: 8
          type: Slashing
          average: 17
        - dice: 3d6
          bonus: 0
          type: Poison
          average: 10
      reach: 15 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Poison Breath (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 22, each creature in a 90-foot Cone. *Failure:*  77 (22d6) Poison damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: con
      dc: 22
      targeting:
        shape: cone
        size: 90 ft.
      onFail:
        effects:
          other: 77 (22d6) Poison damage.
        damage:
          - dice: 22d6
            bonus: 0
            type: Poison
            average: 77
        legacyEffects: 77 (22d6) Poison damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Noxious Miasma
    entryType: save
    text: '*Constitution Saving Throw*: DC 21, each creature in a 30-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 90 feet. *Failure:*  17 (5d6) Poison damage, and the target takes a -2 penalty to AC until the end of its next turn. *Failure or Success*:  The dragon can''t take this action again until the start of its next turn.'
    save:
      ability: con
      dc: 21
      targeting:
        shape: sphere
        size: 30 ft.
      onFail:
        effects:
          other: 17 (5d6) Poison damage, and the target takes a -2 penalty to AC until the end of its next turn.
        damage:
          - dice: 5d6
            bonus: 0
            type: Poison
            average: 17
        legacyEffects: 17 (5d6) Poison damage, and the target takes a -2 penalty to AC until the end of its next turn.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21): - **At Will:** *Detect Magic*, *Mind Spike* - **1e/Day Each:** *Geas*, *Modify Memory*'
    spellcasting:
      ability: cha
      saveDC: 21
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Mind Spike
        - frequency: 1/day
          spells:
            - Geas
            - Modify Memory
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Mind Invasion
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Mind Spike* (level 5 version).
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Ancient Green Dragon
*Gargantuan, Dragon, Lawful Evil*

**AC** 21
**HP** 402 (23d20 + 161)
**Initiative** +5 (15)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 27
**Languages** Common, Draconic
CR 22, PB +7, XP 41000

## Traits

**Amphibious**
The dragon can breathe air and water.

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Mind Spike* (level 5 version).

**Rend**
*Melee Attack Roll:* +15, reach 15 ft. 17 (2d8 + 8) Slashing damage plus 10 (3d6) Poison damage.

**Poison Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 22, each creature in a 90-foot Cone. *Failure:*  77 (22d6) Poison damage. *Success:*  Half damage.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21): - **At Will:** *Detect Magic*, *Mind Spike* - **1e/Day Each:** *Geas*, *Modify Memory*

## Legendary Actions

**Mind Invasion**
The dragon uses Spellcasting to cast *Mind Spike* (level 5 version).

**Noxious Miasma**
*Constitution Saving Throw*: DC 21, each creature in a 30-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 90 feet. *Failure:*  17 (5d6) Poison damage, and the target takes a -2 penalty to AC until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "Monsters/ancient-red-dragon.md": `---
smType: creature
name: Ancient Red Dragon
size: Gargantuan
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '22'
initiative: +4 (14)
hp: '507'
hitDice: 26d20 + 234
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 40 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 30
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 7
  - key: con
    score: 29
    saveProf: false
  - key: int
    score: 18
    saveProf: false
  - key: wis
    score: 15
    saveProf: true
    saveMod: 9
  - key: cha
    score: 27
    saveProf: false
pb: '+7'
skills:
  - skill: Perception
    value: '16'
  - skill: Stealth
    value: '7'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '26'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Fire
cr: '24'
xp: '62000'
entries:
  - category: trait
    name: Legendary Resistance (4/Day, or 5/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 4
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Scorching Ray* (level 3 version).
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Scorching Ray
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +17, reach 15 ft. 19 (2d8 + 10) Slashing damage plus 10 (3d6) Fire damage.'
    attack:
      type: melee
      bonus: 17
      damage:
        - dice: 2d8
          bonus: 10
          type: Slashing
          average: 19
        - dice: 3d6
          bonus: 0
          type: Fire
          average: 10
      reach: 15 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fire Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 24, each creature in a 90-foot Cone. *Failure:*  91 (26d6) Fire damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 24
      targeting:
        shape: cone
        size: 90 ft.
      onFail:
        effects:
          other: 91 (26d6) Fire damage.
        damage:
          - dice: 26d6
            bonus: 0
            type: Fire
            average: 91
        legacyEffects: 91 (26d6) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 23, +15 to hit with spell attacks): - **At Will:** *Command*, *Detect Magic*, *Scorching Ray* - **1e/Day Each:** *Fireball*, *Scrying*'
    spellcasting:
      ability: cha
      saveDC: 23
      attackBonus: 15
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Command
            - Detect Magic
            - Scorching Ray
        - frequency: 1/day
          spells:
            - Fireball
            - Scrying
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Commanding Presence
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Command* (level 2 version). The dragon can't take this action again until the start of its next turn.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Fiery Rays
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Scorching Ray* (level 3 version). The dragon can't take this action again until the start of its next turn.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Ancient Red Dragon
*Gargantuan, Dragon, Chaotic Evil*

**AC** 22
**HP** 507 (26d20 + 234)
**Initiative** +4 (14)
**Speed** 40 ft., climb 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 26
**Languages** Common, Draconic
CR 24, PB +7, XP 62000

## Traits

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Scorching Ray* (level 3 version).

**Rend**
*Melee Attack Roll:* +17, reach 15 ft. 19 (2d8 + 10) Slashing damage plus 10 (3d6) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 24, each creature in a 90-foot Cone. *Failure:*  91 (26d6) Fire damage. *Success:*  Half damage.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 23, +15 to hit with spell attacks): - **At Will:** *Command*, *Detect Magic*, *Scorching Ray* - **1e/Day Each:** *Fireball*, *Scrying*

## Legendary Actions

**Commanding Presence**
The dragon uses Spellcasting to cast *Command* (level 2 version). The dragon can't take this action again until the start of its next turn.

**Fiery Rays**
The dragon uses Spellcasting to cast *Scorching Ray* (level 3 version). The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "Monsters/ancient-silver-dragon.md": `---
smType: creature
name: Ancient Silver Dragon
size: Gargantuan
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '22'
initiative: +4 (14)
hp: '468'
hitDice: 24d20 + 216
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 30
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 7
  - key: con
    score: 29
    saveProf: false
  - key: int
    score: 18
    saveProf: false
  - key: wis
    score: 15
    saveProf: true
    saveMod: 9
  - key: cha
    score: 26
    saveProf: false
pb: '+7'
skills:
  - skill: History
    value: '11'
  - skill: Perception
    value: '16'
  - skill: Stealth
    value: '7'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '26'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Cold
cr: '23'
xp: '50000'
entries:
  - category: trait
    name: Legendary Resistance (4/Day, or 5/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 4
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of (A) Paralyzing Breath or (B) Spellcasting to cast *Ice Knife* (level 2 version).
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Ice Knife
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +17, reach 15 ft. 19 (2d8 + 10) Slashing damage plus 9 (2d8) Cold damage.'
    attack:
      type: melee
      bonus: 17
      damage:
        - dice: 2d8
          bonus: 10
          type: Slashing
          average: 19
        - dice: 2d8
          bonus: 0
          type: Cold
          average: 9
      reach: 15 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Cold Breath (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 24, each creature in a 90-foot Cone. *Failure:*  67 (15d8) Cold damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: con
      dc: 24
      targeting:
        shape: cone
        size: 90 ft.
      onFail:
        effects:
          other: 67 (15d8) Cold damage.
        damage:
          - dice: 15d8
            bonus: 0
            type: Cold
            average: 67
        legacyEffects: 67 (15d8) Cold damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Paralyzing Breath
    entryType: save
    text: '*Constitution Saving Throw*: DC 24, each creature in a 90-foot Cone. *First Failure* The target has the Incapacitated condition until the end of its next turn, when it repeats the save. *Second Failure* The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.'
    save:
      ability: con
      dc: 24
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Cold Gale
    entryType: save
    text: '*Dexterity Saving Throw*: DC 23, each creature in a 60-foot-long, 10-foot-wide Line. *Failure:*  14 (4d6) Cold damage, and the target is pushed up to 30 feet straight away from the dragon. *Success:*  Half damage only. *Failure or Success*:  The dragon can''t take this action again until the start of its next turn.'
    save:
      ability: dex
      dc: 23
      targeting:
        shape: line
        size: 60 ft.
        width: 10 ft.
      onFail:
        effects:
          movement:
            type: push
            distance: 30 feet
            direction: straight away from the dragon
        damage:
          - dice: 4d6
            bonus: 0
            type: Cold
            average: 14
      onSuccess:
        damage: half
        legacyText: Half damage only.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 23, +15 to hit with spell attacks): - **At Will:** *Detect Magic*, *Hold Monster*, *Ice Knife*, *Shapechange* - **1e/Day Each:** *Control Weather*, *Ice Storm*, *Teleport*, *Zone of Truth*'
    spellcasting:
      ability: cha
      saveDC: 23
      attackBonus: 15
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Hold Monster
            - Ice Knife
            - Shapechange
        - frequency: 1/day
          spells:
            - Control Weather
            - Ice Storm
            - Teleport
            - Zone of Truth
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Chill
    entryType: spellcasting
    text: The dragon uses Spellcasting to cast *Hold Monster*. The dragon can't take this action again until the start of its next turn.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Ancient Silver Dragon
*Gargantuan, Dragon, Lawful Good*

**AC** 22
**HP** 468 (24d20 + 216)
**Initiative** +4 (14)
**Speed** 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 26
**Languages** Common, Draconic
CR 23, PB +7, XP 50000

## Traits

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Paralyzing Breath or (B) Spellcasting to cast *Ice Knife* (level 2 version).

**Rend**
*Melee Attack Roll:* +17, reach 15 ft. 19 (2d8 + 10) Slashing damage plus 9 (2d8) Cold damage.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 24, each creature in a 90-foot Cone. *Failure:*  67 (15d8) Cold damage. *Success:*  Half damage.

**Paralyzing Breath**
*Constitution Saving Throw*: DC 24, each creature in a 90-foot Cone. *First Failure* The target has the Incapacitated condition until the end of its next turn, when it repeats the save. *Second Failure* The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 23, +15 to hit with spell attacks): - **At Will:** *Detect Magic*, *Hold Monster*, *Ice Knife*, *Shapechange* - **1e/Day Each:** *Control Weather*, *Ice Storm*, *Teleport*, *Zone of Truth*

## Legendary Actions

**Chill**
The dragon uses Spellcasting to cast *Hold Monster*. The dragon can't take this action again until the start of its next turn.

**Cold Gale**
*Dexterity Saving Throw*: DC 23, each creature in a 60-foot-long, 10-foot-wide Line. *Failure:*  14 (4d6) Cold damage, and the target is pushed up to 30 feet straight away from the dragon. *Success:*  Half damage only. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "Monsters/ancient-white-dragon.md": `---
smType: creature
name: Ancient White Dragon
size: Gargantuan
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '20'
initiative: +4 (14)
hp: '333'
hitDice: 18d20 + 144
speeds:
  walk:
    distance: 40 ft.
  burrow:
    distance: 40 ft.
  fly:
    distance: 80 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 26
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 6
  - key: con
    score: 26
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 13
    saveProf: true
    saveMod: 7
  - key: cha
    score: 18
    saveProf: false
pb: '+6'
skills:
  - skill: Perception
    value: '13'
  - skill: Stealth
    value: '6'
sensesList:
  - type: blindsight
    range: '60'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '23'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Cold
cr: '20'
xp: '25000'
entries:
  - category: trait
    name: Ice Walk
    entryType: special
    text: The dragon can move across and climb icy surfaces without needing to make an ability check. Additionally, Difficult Terrain composed of ice or snow doesn't cost it extra movement.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (4/Day, or 5/Day in Lair)
    entryType: special
    text: If the dragon fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 4
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +14, reach 15 ft. 17 (2d8 + 8) Slashing damage plus 7 (2d6) Cold damage.'
    attack:
      type: melee
      bonus: 14
      damage:
        - dice: 2d8
          bonus: 8
          type: Slashing
          average: 17
        - dice: 2d6
          bonus: 0
          type: Cold
          average: 7
      reach: 15 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Cold Breath (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 22, each creature in a 90-foot Cone. *Failure:*  63 (14d8) Cold damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: con
      dc: 22
      targeting:
        shape: cone
        size: 90 ft.
      onFail:
        effects:
          other: 63 (14d8) Cold damage.
        damage:
          - dice: 14d8
            bonus: 0
            type: Cold
            average: 63
        legacyEffects: 63 (14d8) Cold damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Freezing Burst
    entryType: save
    text: '*Constitution Saving Throw*: DC 20, each creature in a 30-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 120 feet. *Failure:*  14 (4d6) Cold damage, and the target''s Speed is 0 until the end of the target''s next turn. *Failure or Success*:  The dragon can''t take this action again until the start of its next turn.'
    save:
      ability: con
      dc: 20
      targeting:
        shape: sphere
        size: 30 ft.
      onFail:
        effects:
          other: 14 (4d6) Cold damage, and the target's Speed is 0 until the end of the target's next turn.
        damage:
          - dice: 4d6
            bonus: 0
            type: Cold
            average: 14
        legacyEffects: 14 (4d6) Cold damage, and the target's Speed is 0 until the end of the target's next turn.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Pounce
    entryType: multiattack
    text: The dragon moves up to half its Speed, and it makes one Rend attack.
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: legendary
    name: Frightful Presence
    entryType: spellcasting
    text: The dragon casts *Fear*, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 18). The dragon can't take this action again until the start of its next turn.
    spellcasting:
      ability: cha
      saveDC: 18
      excludeComponents:
        - M
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Ancient White Dragon
*Gargantuan, Dragon, Chaotic Evil*

**AC** 20
**HP** 333 (18d20 + 144)
**Initiative** +4 (14)
**Speed** 40 ft., swim 40 ft., fly 80 ft., burrow 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft., darkvision 120 ft.; Passive Perception 23
**Languages** Common, Draconic
CR 20, PB +6, XP 25000

## Traits

**Ice Walk**
The dragon can move across and climb icy surfaces without needing to make an ability check. Additionally, Difficult Terrain composed of ice or snow doesn't cost it extra movement.

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +14, reach 15 ft. 17 (2d8 + 8) Slashing damage plus 7 (2d6) Cold damage.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 22, each creature in a 90-foot Cone. *Failure:*  63 (14d8) Cold damage. *Success:*  Half damage.

## Legendary Actions

**Freezing Burst**
*Constitution Saving Throw*: DC 20, each creature in a 30-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 120 feet. *Failure:*  14 (4d6) Cold damage, and the target's Speed is 0 until the end of the target's next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.

**Frightful Presence**
The dragon casts *Fear*, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 18). The dragon can't take this action again until the start of its next turn.
`,
      "Monsters/animated-armor.md": `---
smType: creature
name: Animated Armor
size: Medium
type: Construct
alignmentOverride: Unaligned
ac: '18'
initiative: +2 (12)
hp: '33'
hitDice: 6d8 + 6
speeds:
  walk:
    distance: 25 ft.
abilities:
  - key: str
    score: 14
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 3
    saveProf: false
  - key: cha
    score: 1
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '60'
passivesList:
  - skill: Perception
    value: '6'
damageImmunitiesList:
  - value: Poison
  - value: Psychic; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Deafened
  - value: Frightened
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
cr: '1'
xp: '200'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The armor makes two Slam attacks.
    multiattack:
      attacks:
        - name: Slam
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Slam
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Bludgeoning
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Animated Armor
*Medium, Construct, Unaligned*

**AC** 18
**HP** 33 (6d8 + 6)
**Initiative** +2 (12)
**Speed** 25 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft.; Passive Perception 6
CR 1, PB +2, XP 200

## Actions

**Multiattack**
The armor makes two Slam attacks.

**Slam**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Bludgeoning damage.
`,
      "Monsters/animated-flying-sword.md": `---
smType: creature
name: Animated Flying Sword
size: Small
type: Construct
alignmentOverride: Unaligned
ac: '17'
initiative: +4 (14)
hp: '14'
hitDice: 4d6
speeds:
  walk:
    distance: 5 ft.
  fly:
    distance: 50 ft.
    hover: true
abilities:
  - key: str
    score: 12
    saveProf: false
  - key: dex
    score: 15
    saveProf: true
    saveMod: 4
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 5
    saveProf: false
  - key: cha
    score: 1
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '60'
passivesList:
  - skill: Perception
    value: '7'
damageImmunitiesList:
  - value: Poison
  - value: Psychic; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Deafened
  - value: Frightened
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Slash
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Slashing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d8
          bonus: 2
          type: Slashing
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Animated Flying Sword
*Small, Construct, Unaligned*

**AC** 17
**HP** 14 (4d6)
**Initiative** +4 (14)
**Speed** 5 ft., fly 50 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft.; Passive Perception 7
CR 1/4, PB +2, XP 50

## Actions

**Slash**
*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Slashing damage.
`,
      "Monsters/animated-rug-of-smothering.md": `---
smType: creature
name: Animated Rug of Smothering
size: Large
type: Construct
alignmentOverride: Unaligned
ac: '12'
initiative: +4 (14)
hp: '27'
hitDice: 5d10
speeds:
  walk:
    distance: 10 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 3
    saveProf: false
  - key: cha
    score: 1
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '60'
passivesList:
  - skill: Perception
    value: '6'
damageImmunitiesList:
  - value: Poison
  - value: Psychic; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Deafened
  - value: Frightened
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
cr: '2'
xp: '450'
entries:
  - category: action
    name: Smother
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Bludgeoning damage. If the target is a Medium or smaller creature, the rug can give it the Grappled condition (escape DC 13) instead of dealing damage. Until the grapple ends, the target has the Blinded and Restrained conditions, is suffocating, and takes 10 (2d6 + 3) Bludgeoning damage at the start of each of its turns. The rug can smother only one creature at a time. While grappling the target, the rug can''t take this action, the rug halves the damage it takes (round down), and the target takes the same amount of damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d6
          bonus: 3
          type: Bludgeoning
          average: 10
        - dice: 2d6
          bonus: 3
          type: Bludgeoning
          average: 10
      reach: 5 ft.
      onHit:
        other: If the target is a Medium or smaller creature, the rug can give it the Grappled condition (escape DC 13) instead of dealing damage. Until the grapple ends, the target has the Blinded and Restrained conditions, is suffocating, and takes 10 (2d6 + 3) Bludgeoning damage at the start of each of its turns. The rug can smother only one creature at a time. While grappling the target, the rug can't take this action, the rug halves the damage it takes (round down), and the target takes the same amount of damage.
      additionalEffects: If the target is a Medium or smaller creature, the rug can give it the Grappled condition (escape DC 13) instead of dealing damage. Until the grapple ends, the target has the Blinded and Restrained conditions, is suffocating, and takes 10 (2d6 + 3) Bludgeoning damage at the start of each of its turns. The rug can smother only one creature at a time. While grappling the target, the rug can't take this action, the rug halves the damage it takes (round down), and the target takes the same amount of damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Animated Rug of Smothering
*Large, Construct, Unaligned*

**AC** 12
**HP** 27 (5d10)
**Initiative** +4 (14)
**Speed** 10 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft.; Passive Perception 6
CR 2, PB +2, XP 450

## Actions

**Smother**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Bludgeoning damage. If the target is a Medium or smaller creature, the rug can give it the Grappled condition (escape DC 13) instead of dealing damage. Until the grapple ends, the target has the Blinded and Restrained conditions, is suffocating, and takes 10 (2d6 + 3) Bludgeoning damage at the start of each of its turns. The rug can smother only one creature at a time. While grappling the target, the rug can't take this action, the rug halves the damage it takes (round down), and the target takes the same amount of damage.
`,
      "Monsters/ankheg.md": `---
smType: creature
name: Ankheg
size: Large
type: Monstrosity
alignmentOverride: Unaligned
ac: '14'
initiative: +0 (10)
hp: '45'
hitDice: 6d10 + 12
speeds:
  walk:
    distance: 30 ft.
  burrow:
    distance: 10 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
  - type: tremorsense
    range: '60'
passivesList:
  - skill: Perception
    value: '11'
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Tunneler
    entryType: special
    text: The ankheg can burrow through solid rock at half its Burrow Speed and leaves a 10-foot-diameter tunnel in its wake.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5 (with Advantage if the target is Grappled by the ankheg), reach 5 ft. 10 (2d6 + 3) Slashing damage plus 3 (1d6) Acid damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13).'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d6
          bonus: 3
          type: Slashing
          average: 10
        - dice: 1d6
          bonus: 0
          type: Acid
          average: 3
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 13
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13).
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Acid Spray
    entryType: save
    text: '*Dexterity Saving Throw*: DC 12, each creature in a 30-foot-long, 5-foot-wide Line. *Failure:*  14 (4d6) Acid damage. *Success:*  Half damage.'
    save:
      ability: dex
      dc: 12
      targeting:
        shape: line
        size: 30 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 14 (4d6) Acid damage.
        damage:
          - dice: 4d6
            bonus: 0
            type: Acid
            average: 14
        legacyEffects: 14 (4d6) Acid damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Ankheg
*Large, Monstrosity, Unaligned*

**AC** 14
**HP** 45 (6d10 + 12)
**Initiative** +0 (10)
**Speed** 30 ft., burrow 10 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft., tremorsense 60 ft.; Passive Perception 11
CR 2, PB +2, XP 450

## Traits

**Tunneler**
The ankheg can burrow through solid rock at half its Burrow Speed and leaves a 10-foot-diameter tunnel in its wake.

## Actions

**Bite**
*Melee Attack Roll:* +5 (with Advantage if the target is Grappled by the ankheg), reach 5 ft. 10 (2d6 + 3) Slashing damage plus 3 (1d6) Acid damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13).

**Acid Spray (Recharge 6)**
*Dexterity Saving Throw*: DC 12, each creature in a 30-foot-long, 5-foot-wide Line. *Failure:*  14 (4d6) Acid damage. *Success:*  Half damage.
`,
      "Monsters/archmage.md": `---
smType: creature
name: Archmage
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '17'
initiative: +6 (16)
hp: '170'
hitDice: 31d8 + 31
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 20
    saveProf: true
    saveMod: 9
  - key: wis
    score: 15
    saveProf: true
    saveMod: 6
  - key: cha
    score: 16
    saveProf: false
pb: '+4'
skills:
  - skill: Arcana
    value: '13'
  - skill: History
    value: '9'
  - skill: Perception
    value: '6'
passivesList:
  - skill: Perception
    value: '16'
languagesList:
  - value: Common plus five other languages
damageImmunitiesList:
  - value: Psychic; Charmed ((with Mind Blank))
cr: '12'
xp: '8400'
entries:
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The archmage has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The archmage makes four Arcane Burst attacks.
    multiattack:
      attacks:
        - name: Burst
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Arcane Burst
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +9, reach 5 ft. or range 150 ft. 27 (4d10 + 5) Force damage.'
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The archmage casts one of the following spells, using Intelligence as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Magic*, *Detect Thoughts*, *Disguise Self*, *Invisibility*, *Light*, *Mage Armor*, *Mage Hand*, *Prestidigitation* - **2e/Day Each:** *Fly*, *Lightning Bolt* - **1e/Day Each:** *Cone of Cold*, *Mind Blank*, *Scrying*, *Teleport*'
    spellcasting:
      ability: int
      saveDC: 17
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Detect Thoughts
            - Disguise Self
            - Invisibility
            - Light
            - Mage Armor
            - Mage Hand
            - Prestidigitation
        - frequency: 2/day
          spells:
            - Fly
            - Lightning Bolt
        - frequency: 1/day
          spells:
            - Cone of Cold
            - Mind Blank
            - Scrying
            - Teleport
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Misty Step (3/Day)
    entryType: spellcasting
    text: The mage casts *Misty Step*, using the same spellcasting ability as Spellcasting.
    limitedUse:
      count: 3
      reset: day
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: bonus
    trigger.targeting:
      type: single
  - category: reaction
    name: Protective Magic (3/Day)
    entryType: spellcasting
    text: The archmage casts *Counterspell* or *Shield* in response to the spell's trigger, using the same spellcasting ability as Spellcasting.
    limitedUse:
      count: 3
      reset: day
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: reaction
    trigger.targeting:
      type: single
    trigger.reactionTrigger: the spell's trigger
---

# Archmage
*Small, Humanoid, Neutral Neutral*

**AC** 17
**HP** 170 (31d8 + 31)
**Initiative** +6 (16)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common plus five other languages
CR 12, PB +4, XP 8400

## Traits

**Magic Resistance**
The archmage has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The archmage makes four Arcane Burst attacks.

**Arcane Burst**
*Melee or Ranged Attack Roll:* +9, reach 5 ft. or range 150 ft. 27 (4d10 + 5) Force damage.

**Spellcasting**
The archmage casts one of the following spells, using Intelligence as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Magic*, *Detect Thoughts*, *Disguise Self*, *Invisibility*, *Light*, *Mage Armor*, *Mage Hand*, *Prestidigitation* - **2e/Day Each:** *Fly*, *Lightning Bolt* - **1e/Day Each:** *Cone of Cold*, *Mind Blank*, *Scrying*, *Teleport*

## Bonus Actions

**Misty Step (3/Day)**
The mage casts *Misty Step*, using the same spellcasting ability as Spellcasting.

## Reactions

**Protective Magic (3/Day)**
The archmage casts *Counterspell* or *Shield* in response to the spell's trigger, using the same spellcasting ability as Spellcasting.
`,
      "Monsters/assassin.md": `---
smType: creature
name: Assassin
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '16'
initiative: +10 (20)
hp: '97'
hitDice: 15d8 + 30
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 11
    saveProf: false
  - key: dex
    score: 18
    saveProf: true
    saveMod: 7
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 16
    saveProf: true
    saveMod: 6
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 10
    saveProf: false
pb: '+3'
skills:
  - skill: Acrobatics
    value: '7'
  - skill: Perception
    value: '6'
  - skill: Stealth
    value: '10'
passivesList:
  - skill: Perception
    value: '16'
languagesList:
  - value: Common
  - value: Thieves' cant
damageResistancesList:
  - value: Poison
cr: '8'
xp: '3900'
entries:
  - category: trait
    name: Evasion
    entryType: special
    text: If the assassin is subjected to an effect that allows it to make a Dexterity saving throw to take only half damage, the assassin instead takes no damage if it succeeds on the save and only half damage if it fails. It can't use this trait if it has the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: special
    text: The assassin makes three attacks, using Shortsword or Light Crossbow in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Shortsword
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 7 (1d6 + 4) Piercing damage plus 17 (5d6) Poison damage, and the target has the Poisoned condition until the start of the assassin''s next turn.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 1d6
          bonus: 4
          type: Piercing
          average: 7
        - dice: 5d6
          bonus: 0
          type: Poison
          average: 17
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Light Crossbow
    entryType: attack
    text: '*Ranged Attack Roll:* +7, range 80/320 ft. 8 (1d8 + 4) Piercing damage plus 21 (6d6) Poison damage.'
    attack:
      type: ranged
      bonus: 7
      damage:
        - dice: 1d8
          bonus: 4
          type: Piercing
          average: 8
        - dice: 6d6
          bonus: 0
          type: Poison
          average: 21
      range: 80/320 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Cunning Action
    entryType: special
    text: The assassin takes the Dash, Disengage, or Hide action.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Assassin
*Small, Humanoid, Neutral Neutral*

**AC** 16
**HP** 97 (15d8 + 30)
**Initiative** +10 (20)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common, Thieves' cant
CR 8, PB +3, XP 3900

## Traits

**Evasion**
If the assassin is subjected to an effect that allows it to make a Dexterity saving throw to take only half damage, the assassin instead takes no damage if it succeeds on the save and only half damage if it fails. It can't use this trait if it has the Incapacitated condition.

## Actions

**Multiattack**
The assassin makes three attacks, using Shortsword or Light Crossbow in any combination.

**Shortsword**
*Melee Attack Roll:* +7, reach 5 ft. 7 (1d6 + 4) Piercing damage plus 17 (5d6) Poison damage, and the target has the Poisoned condition until the start of the assassin's next turn.

**Light Crossbow**
*Ranged Attack Roll:* +7, range 80/320 ft. 8 (1d8 + 4) Piercing damage plus 21 (6d6) Poison damage.

## Bonus Actions

**Cunning Action**
The assassin takes the Dash, Disengage, or Hide action.
`,
      "Monsters/awakened-shrub.md": `---
smType: creature
name: Awakened Shrub
size: Small
type: Plant
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '9'
initiative: '-1 (9)'
hp: '10'
hitDice: 3d6
speeds:
  walk:
    distance: 20 ft.
abilities:
  - key: str
    score: 3
    saveProf: false
  - key: dex
    score: 8
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common plus one other language
damageVulnerabilitiesList:
  - value: Fire
damageResistancesList:
  - value: Piercing
cr: '0'
xp: '0'
entries:
  - category: action
    name: Rake
    entryType: attack
    text: '*Melee Attack Roll:* +1, reach 5 ft. 1 Slashing damage.'
    attack:
      type: melee
      bonus: 1
      damage: []
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Awakened Shrub
*Small, Plant, Neutral Neutral*

**AC** 9
**HP** 10 (3d6)
**Initiative** -1 (9)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common plus one other language
CR 0, PB +2, XP 0

## Actions

**Rake**
*Melee Attack Roll:* +1, reach 5 ft. 1 Slashing damage.
`,
      "Monsters/awakened-tree.md": `---
smType: creature
name: Awakened Tree
size: Huge
type: Plant
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '13'
initiative: '-2 (8)'
hp: '59'
hitDice: 7d12 + 14
speeds:
  walk:
    distance: 20 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 6
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common plus one other language
damageVulnerabilitiesList:
  - value: Fire
damageResistancesList:
  - value: Bludgeoning
  - value: Piercing
cr: '2'
xp: '450'
entries:
  - category: action
    name: Slam
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 10 ft. 13 (2d8 + 4) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d8
          bonus: 4
          type: Bludgeoning
          average: 13
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Awakened Tree
*Huge, Plant, Neutral Neutral*

**AC** 13
**HP** 59 (7d12 + 14)
**Initiative** -2 (8)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common plus one other language
CR 2, PB +2, XP 450

## Actions

**Slam**
*Melee Attack Roll:* +6, reach 10 ft. 13 (2d8 + 4) Bludgeoning damage.
`,
      "Monsters/axe-beak.md": `---
smType: creature
name: Axe Beak
size: Large
type: Monstrosity
alignmentOverride: Unaligned
ac: '11'
initiative: +1 (11)
hp: '19'
hitDice: 3d10 + 3
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 14
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Beak
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Slashing
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Axe Beak
*Large, Monstrosity, Unaligned*

**AC** 11
**HP** 19 (3d10 + 3)
**Initiative** +1 (11)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 1/4, PB +2, XP 50

## Actions

**Beak**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage.
`,
      "Monsters/azer-sentinel.md": `---
smType: creature
name: Azer Sentinel
size: Medium
type: Elemental
alignmentLawChaos: Lawful
alignmentGoodEvil: Neutral
ac: '17'
initiative: +1 (11)
hp: '39'
hitDice: 6d8 + 12
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 15
    saveProf: true
    saveMod: 4
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 10
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Primordial (Ignan)
damageImmunitiesList:
  - value: Fire
  - value: Poison; Poisoned
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Fire Aura
    entryType: special
    text: At the end of each of the azer's turns, each creature of the azer's choice in a 5-foot Emanation originating from the azer takes 5 (1d10) Fire damage unless the azer has the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Illumination
    entryType: special
    text: The azer sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Burning Hammer
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Bludgeoning damage plus 3 (1d6) Fire damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d10
          bonus: 3
          type: Bludgeoning
          average: 8
        - dice: 1d6
          bonus: 0
          type: Fire
          average: 3
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Azer Sentinel
*Medium, Elemental, Lawful Neutral*

**AC** 17
**HP** 39 (6d8 + 12)
**Initiative** +1 (11)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Primordial (Ignan)
CR 2, PB +2, XP 450

## Traits

**Fire Aura**
At the end of each of the azer's turns, each creature of the azer's choice in a 5-foot Emanation originating from the azer takes 5 (1d10) Fire damage unless the azer has the Incapacitated condition.

**Illumination**
The azer sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.

## Actions

**Burning Hammer**
*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Bludgeoning damage plus 3 (1d6) Fire damage.
`,
      "Monsters/balor.md": `---
smType: creature
name: Balor
size: Huge
type: Fiend
typeTags:
  - value: Demon
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '19'
initiative: +14 (24)
hp: '287'
hitDice: 23d12 + 138
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 26
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 22
    saveProf: true
    saveMod: 12
  - key: int
    score: 20
    saveProf: false
  - key: wis
    score: 16
    saveProf: true
    saveMod: 9
  - key: cha
    score: 22
    saveProf: false
pb: '+6'
skills:
  - skill: Perception
    value: '9'
sensesList:
  - type: truesight
    range: '120'
passivesList:
  - skill: Perception
    value: '19'
languagesList:
  - value: Abyssal
  - value: telepathy 120 ft.
damageResistancesList:
  - value: Cold
  - value: Lightning
damageImmunitiesList:
  - value: Fire
  - value: Poison; Charmed
conditionImmunitiesList:
  - value: Frightened
  - value: Poisoned
cr: '19'
xp: '22000'
entries:
  - category: trait
    name: Death Throes
    entryType: save
    text: 'The balor explodes when it dies. *Dexterity Saving Throw*: DC 20, each creature in a 30-foot Emanation originating from the balor. *Failure:*  31 (9d6) Fire damage plus 31 (9d6) Force damage. *Success:*  Half damage. *Failure or Success*:  If the balor dies outside the Abyss, it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.'
    save:
      ability: dex
      dc: 20
      targeting:
        shape: emanation
        size: 30 ft.
        origin: self
      onFail:
        effects:
          other: 31 (9d6) Fire damage plus 31 (9d6) Force damage.
        damage:
          - dice: 9d6
            bonus: 0
            type: Fire
            average: 31
          - dice: 9d6
            bonus: 0
            type: Force
            average: 31
        legacyEffects: 31 (9d6) Fire damage plus 31 (9d6) Force damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Fire Aura
    entryType: special
    text: At the end of each of the balor's turns, each creature in a 5-foot Emanation originating from the balor takes 13 (3d8) Fire damage.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (3/Day)
    entryType: special
    text: If the balor fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The balor has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The balor makes one Flame Whip attack and one Lightning Blade attack.
    multiattack:
      attacks:
        - name: Whip
          count: 1
        - name: Blade
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Flame Whip
    entryType: attack
    text: '*Melee Attack Roll:* +14, reach 30 ft. 18 (3d6 + 8) Force damage plus 17 (5d6) Fire damage. If the target is a Huge or smaller creature, the balor pulls the target up to 25 feet straight toward itself, and the target has the Prone condition.'
    attack:
      type: melee
      bonus: 14
      damage:
        - dice: 3d6
          bonus: 8
          type: Force
          average: 18
        - dice: 5d6
          bonus: 0
          type: Fire
          average: 17
      reach: 30 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Huge or smaller
      additionalEffects: If the target is a Huge or smaller creature, the balor pulls the target up to 25 feet straight toward itself, and the target has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Lightning Blade
    entryType: attack
    text: '*Melee Attack Roll:* +14, reach 10 ft. 21 (3d8 + 8) Force damage plus 22 (4d10) Lightning damage, and the target can''t take Reactions until the start of the balor''s next turn.'
    attack:
      type: melee
      bonus: 14
      damage:
        - dice: 3d8
          bonus: 8
          type: Force
          average: 21
        - dice: 4d10
          bonus: 0
          type: Lightning
          average: 22
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Teleport
    entryType: special
    text: The balor teleports itself or a willing demon within 10 feet of itself up to 60 feet to an unoccupied space the balor can see.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Balor
*Huge, Fiend, Chaotic Evil*

**AC** 19
**HP** 287 (23d12 + 138)
**Initiative** +14 (24)
**Speed** 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** truesight 120 ft.; Passive Perception 19
**Languages** Abyssal, telepathy 120 ft.
CR 19, PB +6, XP 22000

## Traits

**Death Throes**
The balor explodes when it dies. *Dexterity Saving Throw*: DC 20, each creature in a 30-foot Emanation originating from the balor. *Failure:*  31 (9d6) Fire damage plus 31 (9d6) Force damage. *Success:*  Half damage. *Failure or Success*:  If the balor dies outside the Abyss, it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.

**Fire Aura**
At the end of each of the balor's turns, each creature in a 5-foot Emanation originating from the balor takes 13 (3d8) Fire damage.

**Legendary Resistance (3/Day)**
If the balor fails a saving throw, it can choose to succeed instead.

**Magic Resistance**
The balor has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The balor makes one Flame Whip attack and one Lightning Blade attack.

**Flame Whip**
*Melee Attack Roll:* +14, reach 30 ft. 18 (3d6 + 8) Force damage plus 17 (5d6) Fire damage. If the target is a Huge or smaller creature, the balor pulls the target up to 25 feet straight toward itself, and the target has the Prone condition.

**Lightning Blade**
*Melee Attack Roll:* +14, reach 10 ft. 21 (3d8 + 8) Force damage plus 22 (4d10) Lightning damage, and the target can't take Reactions until the start of the balor's next turn.

## Bonus Actions

**Teleport**
The balor teleports itself or a willing demon within 10 feet of itself up to 60 feet to an unoccupied space the balor can see.
`,
      "Monsters/bandit-captain.md": `---
smType: creature
name: Bandit Captain
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '15'
initiative: +3 (13)
hp: '52'
hitDice: 8d8 + 16
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 15
    saveProf: true
    saveMod: 4
  - key: dex
    score: 16
    saveProf: true
    saveMod: 5
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 14
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 2
  - key: cha
    score: 14
    saveProf: false
pb: '+2'
skills:
  - skill: Athletics
    value: '4'
  - skill: Deception
    value: '4'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common
  - value: Thieves' cant
cr: '2'
xp: '450'
entries:
  - category: action
    name: Multiattack
    entryType: special
    text: The bandit makes two attacks, using Scimitar and Pistol in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Scimitar
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Slashing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d6
          bonus: 3
          type: Slashing
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Pistol
    entryType: attack
    text: '*Ranged Attack Roll:* +5, range 30/90 ft. 8 (1d10 + 3) Piercing damage.'
    attack:
      type: ranged
      bonus: 5
      damage:
        - dice: 1d10
          bonus: 3
          type: Piercing
          average: 8
      range: 30/90 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Bandit Captain
*Small, Humanoid, Neutral Neutral*

**AC** 15
**HP** 52 (8d8 + 16)
**Initiative** +3 (13)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common, Thieves' cant
CR 2, PB +2, XP 450

## Actions

**Multiattack**
The bandit makes two attacks, using Scimitar and Pistol in any combination.

**Scimitar**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Slashing damage.

**Pistol**
*Ranged Attack Roll:* +5, range 30/90 ft. 8 (1d10 + 3) Piercing damage.
`,
      "Monsters/bandit.md": `---
smType: creature
name: Bandit
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '12'
initiative: +1 (11)
hp: '11'
hitDice: 2d8 + 2
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 11
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 10
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common
  - value: Thieves' cant
cr: 1/8
xp: '25'
entries:
  - category: action
    name: Scimitar
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Slashing damage.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 1d6
          bonus: 1
          type: Slashing
          average: 4
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Light Crossbow
    entryType: attack
    text: '*Ranged Attack Roll:* +3, range 80/320 ft. 5 (1d8 + 1) Piercing damage.'
    attack:
      type: ranged
      bonus: 3
      damage:
        - dice: 1d8
          bonus: 1
          type: Piercing
          average: 5
      range: 80/320 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Bandit
*Small, Humanoid, Neutral Neutral*

**AC** 12
**HP** 11 (2d8 + 2)
**Initiative** +1 (11)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common, Thieves' cant
CR 1/8, PB +2, XP 25

## Actions

**Scimitar**
*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Slashing damage.

**Light Crossbow**
*Ranged Attack Roll:* +3, range 80/320 ft. 5 (1d8 + 1) Piercing damage.
`,
      "Monsters/barbed-devil.md": `---
smType: creature
name: Barbed Devil
size: Medium
type: Fiend
typeTags:
  - value: Devil
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '15'
initiative: +3 (13)
hp: '110'
hitDice: 13d8 + 52
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 16
    saveProf: true
    saveMod: 6
  - key: dex
    score: 17
    saveProf: false
  - key: con
    score: 18
    saveProf: true
    saveMod: 7
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 14
    saveProf: true
    saveMod: 5
  - key: cha
    score: 14
    saveProf: true
    saveMod: 5
pb: '+3'
skills:
  - skill: Deception
    value: '5'
  - skill: Insight
    value: '5'
  - skill: Perception
    value: '8'
sensesList:
  - type: darkvision 120 ft. (unimpeded by magical darkness)
passivesList:
  - skill: Perception
    value: '18'
languagesList:
  - value: Infernal
  - value: telepathy 120 ft.
damageResistancesList:
  - value: Cold
damageImmunitiesList:
  - value: Fire
  - value: Poison; Poisoned
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Barbed Hide
    entryType: special
    text: At the start of each of its turns, the devil deals 5 (1d10) Piercing damage to any creature it is grappling or any creature grappling it.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Diabolical Restoration
    entryType: special
    text: If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The devil has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The devil makes one Claws attack and one Tail attack, or it makes two Hurl Flame attacks.
    multiattack:
      attacks:
        - name: Claws
          count: 1
        - name: Tail
          count: 1
        - name: Flame
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Claws
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 10 (2d6 + 3) Piercing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13) from both claws.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d6
          bonus: 3
          type: Piercing
          average: 10
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 13
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13) from both claws.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Tail
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 10 ft. 14 (2d10 + 3) Slashing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d10
          bonus: 3
          type: Slashing
          average: 14
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Hurl Flame
    entryType: attack
    text: '*Ranged Attack Roll:* +5, range 150 ft. 17 (5d6) Fire damage. If the target is a flammable object that isn''t being worn or carried, it starts burning.'
    attack:
      type: ranged
      bonus: 5
      damage:
        - dice: 5d6
          bonus: 0
          type: Fire
          average: 17
      range: 150 ft.
      onHit:
        other: If the target is a flammable object that isn't being worn or carried, it starts burning.
      additionalEffects: If the target is a flammable object that isn't being worn or carried, it starts burning.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Barbed Devil
*Medium, Fiend, Lawful Evil*

**AC** 15
**HP** 110 (13d8 + 52)
**Initiative** +3 (13)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft. (unimpeded by magical darkness); Passive Perception 18
**Languages** Infernal, telepathy 120 ft.
CR 5, PB +3, XP 1800

## Traits

**Barbed Hide**
At the start of each of its turns, the devil deals 5 (1d10) Piercing damage to any creature it is grappling or any creature grappling it.

**Diabolical Restoration**
If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.

**Magic Resistance**
The devil has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The devil makes one Claws attack and one Tail attack, or it makes two Hurl Flame attacks.

**Claws**
*Melee Attack Roll:* +6, reach 5 ft. 10 (2d6 + 3) Piercing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13) from both claws.

**Tail**
*Melee Attack Roll:* +6, reach 10 ft. 14 (2d10 + 3) Slashing damage.

**Hurl Flame**
*Ranged Attack Roll:* +5, range 150 ft. 17 (5d6) Fire damage. If the target is a flammable object that isn't being worn or carried, it starts burning.
`,
      "Monsters/basilisk.md": `---
smType: creature
name: Basilisk
size: Medium
type: Monstrosity
alignmentOverride: Unaligned
ac: '15'
initiative: '-1 (9)'
hp: '52'
hitDice: 8d8 + 16
speeds:
  walk:
    distance: 20 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 8
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 8
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '9'
cr: '3'
xp: '700'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Piercing damage plus 7 (2d6) Poison damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d6
          bonus: 3
          type: Piercing
          average: 10
        - dice: 2d6
          bonus: 0
          type: Poison
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Petrifying Gaze (Recharge 4-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 12, each creature in a 30-foot Cone. If the basilisk sees its reflection within the Cone, the basilisk must make this save. *First Failure* The target has the Restrained condition and repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition instead of the Restrained condition.'
    recharge: 4-6
    save:
      ability: con
      dc: 12
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Basilisk
*Medium, Monstrosity, Unaligned*

**AC** 15
**HP** 52 (8d8 + 16)
**Initiative** -1 (9)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 9
CR 3, PB +2, XP 700

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Piercing damage plus 7 (2d6) Poison damage.

## Bonus Actions

**Petrifying Gaze (Recharge 4-6)**
*Constitution Saving Throw*: DC 12, each creature in a 30-foot Cone. If the basilisk sees its reflection within the Cone, the basilisk must make this save. *First Failure* The target has the Restrained condition and repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition instead of the Restrained condition.
`,
      "Monsters/bearded-devil.md": `---
smType: creature
name: Bearded Devil
size: Medium
type: Fiend
typeTags:
  - value: Devil
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '13'
initiative: +2 (12)
hp: '58'
hitDice: 9d8 + 18
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 16
    saveProf: true
    saveMod: 5
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 15
    saveProf: true
    saveMod: 4
  - key: int
    score: 9
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 14
    saveProf: true
    saveMod: 4
pb: '+2'
sensesList:
  - type: darkvision 120 ft. (unimpeded by magical darkness)
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Infernal
  - value: telepathy 120 ft.
damageResistancesList:
  - value: Cold
damageImmunitiesList:
  - value: Fire
  - value: Poison; Frightened
conditionImmunitiesList:
  - value: Poisoned
cr: '3'
xp: '700'
entries:
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The devil has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The devil makes one Beard attack and one Infernal Glaive attack.
    multiattack:
      attacks:
        - name: Beard
          count: 1
        - name: Glaive
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Beard
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage, and the target has the Poisoned condition until the start of the devil''s next turn. Until this poison ends, the target can''t regain Hit Points.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d8
          bonus: 3
          type: Piercing
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Infernal Glaive
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 10 ft. 8 (1d10 + 3) Slashing damage. If the target is a creature and doesn''t already have an infernal wound, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target receives an infernal wound. While wounded, the target loses 5 (1d10) Hit Points at the start of each of its turns. The wound closes after 1 minute, after a spell restores Hit Points to the target, or after the target or a creature within 5 feet of it takes an action to stanch the wound, doing so by succeeding on a DC 12 Wisdom (Medicine) check.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d10
          bonus: 3
          type: Slashing
          average: 8
      reach: 10 ft.
      onHit:
        other: 'If the target is a creature and doesn''t already have an infernal wound, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target receives an infernal wound. While wounded, the target loses 5 (1d10) Hit Points at the start of each of its turns. The wound closes after 1 minute, after a spell restores Hit Points to the target, or after the target or a creature within 5 feet of it takes an action to stanch the wound, doing so by succeeding on a DC 12 Wisdom (Medicine) check.'
      additionalEffects: 'If the target is a creature and doesn''t already have an infernal wound, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target receives an infernal wound. While wounded, the target loses 5 (1d10) Hit Points at the start of each of its turns. The wound closes after 1 minute, after a spell restores Hit Points to the target, or after the target or a creature within 5 feet of it takes an action to stanch the wound, doing so by succeeding on a DC 12 Wisdom (Medicine) check.'
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Bearded Devil
*Medium, Fiend, Lawful Evil*

**AC** 13
**HP** 58 (9d8 + 18)
**Initiative** +2 (12)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft. (unimpeded by magical darkness); Passive Perception 10
**Languages** Infernal, telepathy 120 ft.
CR 3, PB +2, XP 700

## Traits

**Magic Resistance**
The devil has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The devil makes one Beard attack and one Infernal Glaive attack.

**Beard**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage, and the target has the Poisoned condition until the start of the devil's next turn. Until this poison ends, the target can't regain Hit Points.

**Infernal Glaive**
*Melee Attack Roll:* +5, reach 10 ft. 8 (1d10 + 3) Slashing damage. If the target is a creature and doesn't already have an infernal wound, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target receives an infernal wound. While wounded, the target loses 5 (1d10) Hit Points at the start of each of its turns. The wound closes after 1 minute, after a spell restores Hit Points to the target, or after the target or a creature within 5 feet of it takes an action to stanch the wound, doing so by succeeding on a DC 12 Wisdom (Medicine) check.
`,
      "Monsters/behir.md": `---
smType: creature
name: Behir
size: Huge
type: Monstrosity
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '17'
initiative: +3 (13)
hp: '168'
hitDice: 16d12 + 64
speeds:
  walk:
    distance: 50 ft.
  climb:
    distance: 50 ft.
abilities:
  - key: str
    score: 23
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 18
    saveProf: false
  - key: int
    score: 7
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 12
    saveProf: false
pb: '+4'
skills:
  - skill: Perception
    value: '6'
  - skill: Stealth
    value: '7'
sensesList:
  - type: darkvision
    range: '90'
passivesList:
  - skill: Perception
    value: '16'
languagesList:
  - value: Draconic
damageImmunitiesList:
  - value: Lightning
cr: '11'
xp: '7200'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The behir makes one Bite attack and uses Constrict.
    multiattack:
      attacks:
        - name: Bite
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +10, reach 10 ft. 19 (2d12 + 6) Piercing damage plus 11 (2d10) Lightning damage.'
    attack:
      type: melee
      bonus: 10
      damage:
        - dice: 2d12
          bonus: 6
          type: Piercing
          average: 19
        - dice: 2d10
          bonus: 0
          type: Lightning
          average: 11
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Constrict
    entryType: save
    text: '*Strength Saving Throw*: DC 18, one Large or smaller creature the behir can see within 5 feet. *Failure:*  28 (5d8 + 6) Bludgeoning damage. The target has the Grappled condition (escape DC 16), and it has the Restrained condition until the grapple ends.'
    save:
      ability: str
      dc: 18
      targeting:
        type: single
        range: 5 ft.
        restrictions:
          size:
            - Large
            - smaller
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Grappled
              escape:
                type: dc
                dc: 16
              duration:
                type: until
                trigger: the grapple ends
            - condition: Restrained
              escape:
                type: dc
                dc: 16
              duration:
                type: until
                trigger: the grapple ends
        damage:
          - dice: 5d8
            bonus: 6
            type: Bludgeoning
            average: 28
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Lightning Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 16, each creature in a 90-foot-long, 5-foot-wide Line. *Failure:*  66 (12d10) Lightning damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 16
      targeting:
        shape: line
        size: 90 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 66 (12d10) Lightning damage.
        damage:
          - dice: 12d10
            bonus: 0
            type: Lightning
            average: 66
        legacyEffects: 66 (12d10) Lightning damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Swallow
    entryType: save
    text: '*Dexterity Saving Throw*: DC 18, one Large or smaller creature Grappled by the behir (the behir can have only one creature swallowed at a time). *Failure:*  The behir swallows the target, which is no longer Grappled. While swallowed, a creature has the Blinded and Restrained conditions, has Cover|XPHB|Total Cover against attacks and other effects outside the behir, and takes 21 (6d6) Acid damage at the start of each of the behir''s turns. If the behir takes 30 damage or more on a single turn from the swallowed creature, the behir must succeed on a DC 14 Constitution saving throw at the end of that turn or regurgitate the creature, which falls in a space within 10 feet of the behir and has the Prone condition. If the behir dies, a swallowed creature is no longer Restrained and can escape from the corpse by using 15 feet of movement, exiting Prone.'
    save:
      ability: dex
      dc: 18
      targeting:
        type: single
        restrictions:
          size:
            - Large
            - smaller
          other:
            - grappled by source
      onFail:
        effects:
          conditions:
            - condition: Prone
              restrictions:
                while: While swallowed, a creature has the Blinded and Restrained conditions, has Cover|XPHB|Total Cover against attacks and other effects outside the behir, and takes 21 (6d6) Acid damage at the start of each of the behir's turns. If the behir takes 30 damage or more on a single turn from the swallowed creature, the behir must succeed on a DC 14 Constitution saving throw at the end of that turn or regurgitate the creature, which falls in a space within 10 feet of the behir and has the Prone condition
        damage:
          - dice: 6d6
            bonus: 0
            type: Acid
            average: 21
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Behir
*Huge, Monstrosity, Neutral Evil*

**AC** 17
**HP** 168 (16d12 + 64)
**Initiative** +3 (13)
**Speed** 50 ft., climb 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 90 ft.; Passive Perception 16
**Languages** Draconic
CR 11, PB +4, XP 7200

## Actions

**Multiattack**
The behir makes one Bite attack and uses Constrict.

**Bite**
*Melee Attack Roll:* +10, reach 10 ft. 19 (2d12 + 6) Piercing damage plus 11 (2d10) Lightning damage.

**Constrict**
*Strength Saving Throw*: DC 18, one Large or smaller creature the behir can see within 5 feet. *Failure:*  28 (5d8 + 6) Bludgeoning damage. The target has the Grappled condition (escape DC 16), and it has the Restrained condition until the grapple ends.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 16, each creature in a 90-foot-long, 5-foot-wide Line. *Failure:*  66 (12d10) Lightning damage. *Success:*  Half damage.

## Bonus Actions

**Swallow**
*Dexterity Saving Throw*: DC 18, one Large or smaller creature Grappled by the behir (the behir can have only one creature swallowed at a time). *Failure:*  The behir swallows the target, which is no longer Grappled. While swallowed, a creature has the Blinded and Restrained conditions, has Cover|XPHB|Total Cover against attacks and other effects outside the behir, and takes 21 (6d6) Acid damage at the start of each of the behir's turns. If the behir takes 30 damage or more on a single turn from the swallowed creature, the behir must succeed on a DC 14 Constitution saving throw at the end of that turn or regurgitate the creature, which falls in a space within 10 feet of the behir and has the Prone condition. If the behir dies, a swallowed creature is no longer Restrained and can escape from the corpse by using 15 feet of movement, exiting Prone.
`,
      "Monsters/berserker.md": `---
smType: creature
name: Berserker
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '13'
initiative: +1 (11)
hp: '67'
hitDice: 9d8 + 27
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 9
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 9
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Bloodied Frenzy
    entryType: special
    text: While Bloodied, the berserker has Advantage on attack rolls and saving throws.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Greataxe
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 9 (1d12 + 3) Slashing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d12
          bonus: 3
          type: Slashing
          average: 9
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Berserker
*Small, Humanoid, Neutral Neutral*

**AC** 13
**HP** 67 (9d8 + 27)
**Initiative** +1 (11)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common
CR 2, PB +2, XP 450

## Traits

**Bloodied Frenzy**
While Bloodied, the berserker has Advantage on attack rolls and saving throws.

## Actions

**Greataxe**
*Melee Attack Roll:* +5, reach 5 ft. 9 (1d12 + 3) Slashing damage.
`,
      "Monsters/black-dragon-wyrmling.md": `---
smType: creature
name: Black Dragon Wyrmling
size: Medium
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '17'
initiative: +4 (14)
hp: '33'
hitDice: 6d8 + 6
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 60 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 14
    saveProf: true
    saveMod: 4
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 2
  - key: cha
    score: 13
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '4'
sensesList:
  - type: blindsight
    range: '10'
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Draconic
damageImmunitiesList:
  - value: Acid
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes two Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage plus 2 (1d4) Acid damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Slashing
          average: 5
        - dice: 1d4
          bonus: 0
          type: Acid
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Acid Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 11, each creature in a 15-foot-long, 5-foot-wide Line. *Failure:*  22 (5d8) Acid damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 11
      targeting:
        shape: line
        size: 15 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 22 (5d8) Acid damage.
        damage:
          - dice: 5d8
            bonus: 0
            type: Acid
            average: 22
        legacyEffects: 22 (5d8) Acid damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Black Dragon Wyrmling
*Medium, Dragon, Chaotic Evil*

**AC** 17
**HP** 33 (6d8 + 6)
**Initiative** +4 (14)
**Speed** 30 ft., swim 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft., darkvision 60 ft.; Passive Perception 14
**Languages** Draconic
CR 2, PB +2, XP 450

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage plus 2 (1d4) Acid damage.

**Acid Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 11, each creature in a 15-foot-long, 5-foot-wide Line. *Failure:*  22 (5d8) Acid damage. *Success:*  Half damage.
`,
      "Monsters/black-pudding.md": `---
smType: creature
name: Black Pudding
size: Large
type: Ooze
alignmentOverride: Unaligned
ac: '7'
initiative: '-3 (7)'
hp: '68'
hitDice: 8d10 + 24
speeds:
  walk:
    distance: 20 ft.
  climb:
    distance: 20 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 5
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 6
    saveProf: false
  - key: cha
    score: 1
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '60'
passivesList:
  - skill: Perception
    value: '8'
damageImmunitiesList:
  - value: Acid
  - value: Cold
  - value: Lightning
  - value: Slashing; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Deafened
  - value: Frightened
  - value: Grappled
  - value: Prone
  - value: Restrained
cr: '4'
xp: '1100'
entries:
  - category: trait
    name: Amorphous
    entryType: special
    text: The pudding can move through a space as narrow as 1 inch without expending extra movement to do so.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Corrosive Form
    entryType: special
    text: A creature that hits the pudding with a melee attack roll takes 4 (1d8) Acid damage. Nonmagical ammunition is destroyed immediately after hitting the pudding and dealing any damage. Any nonmagical weapon takes a cumulative -1 penalty to attack rolls immediately after dealing damage to the pudding and coming into contact with it. The weapon is destroyed if the penalty reaches -5. The penalty can be removed by casting the *Mending* spell on the weapon. In 1 minute, the pudding can eat through 2 feet of nonmagical wood or metal.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Spider Climb
    entryType: special
    text: The pudding can climb difficult surfaces, including along ceilings, without needing to make an ability check.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Dissolving Pseudopod
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 10 ft. 17 (4d6 + 3) Acid damage. Nonmagical armor worn by the target takes a -1 penalty to the AC it offers. The armor is destroyed if the penalty reduces its AC to 10. The penalty can be removed by casting the *Mending* spell on the armor.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 4d6
          bonus: 3
          type: Acid
          average: 17
      reach: 10 ft.
      onHit:
        other: Nonmagical armor worn by the target takes a -1 penalty to the AC it offers. The armor is destroyed if the penalty reduces its AC to 10. The penalty can be removed by casting the *Mending* spell on the armor.
      additionalEffects: Nonmagical armor worn by the target takes a -1 penalty to the AC it offers. The armor is destroyed if the penalty reduces its AC to 10. The penalty can be removed by casting the *Mending* spell on the armor.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Black Pudding
*Large, Ooze, Unaligned*

**AC** 7
**HP** 68 (8d10 + 24)
**Initiative** -3 (7)
**Speed** 20 ft., climb 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft.; Passive Perception 8
CR 4, PB +2, XP 1100

## Traits

**Amorphous**
The pudding can move through a space as narrow as 1 inch without expending extra movement to do so.

**Corrosive Form**
A creature that hits the pudding with a melee attack roll takes 4 (1d8) Acid damage. Nonmagical ammunition is destroyed immediately after hitting the pudding and dealing any damage. Any nonmagical weapon takes a cumulative -1 penalty to attack rolls immediately after dealing damage to the pudding and coming into contact with it. The weapon is destroyed if the penalty reaches -5. The penalty can be removed by casting the *Mending* spell on the weapon. In 1 minute, the pudding can eat through 2 feet of nonmagical wood or metal.

**Spider Climb**
The pudding can climb difficult surfaces, including along ceilings, without needing to make an ability check.

## Actions

**Dissolving Pseudopod**
*Melee Attack Roll:* +5, reach 10 ft. 17 (4d6 + 3) Acid damage. Nonmagical armor worn by the target takes a -1 penalty to the AC it offers. The armor is destroyed if the penalty reduces its AC to 10. The penalty can be removed by casting the *Mending* spell on the armor.
`,
      "Monsters/blink-dog.md": `---
smType: creature
name: Blink Dog
size: Medium
type: Fey
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '13'
initiative: +3 (13)
hp: '22'
hitDice: 4d8 + 4
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 12
    saveProf: false
  - key: dex
    score: 17
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 11
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
  - skill: Stealth
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '15'
languagesList:
  - value: Understands Elvish and Sylvan but can't speak them
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Piercing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d4
          bonus: 3
          type: Piercing
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Teleport (Recharge 4-6)
    entryType: special
    text: The dog teleports up to 40 feet to an unoccupied space it can see.
    recharge: 4-6
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Blink Dog
*Medium, Fey, Lawful Good*

**AC** 13
**HP** 22 (4d8 + 4)
**Initiative** +3 (13)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 15
**Languages** Understands Elvish and Sylvan but can't speak them
CR 1/4, PB +2, XP 50

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Piercing damage.

## Bonus Actions

**Teleport (Recharge 4-6)**
The dog teleports up to 40 feet to an unoccupied space it can see.
`,
      "Monsters/blue-dragon-wyrmling.md": `---
smType: creature
name: Blue Dragon Wyrmling
size: Medium
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '17'
initiative: +2 (12)
hp: '65'
hitDice: 10d8 + 20
speeds:
  walk:
    distance: 30 ft.
  burrow:
    distance: 15 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 2
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 2
  - key: cha
    score: 15
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '2'
sensesList:
  - type: blindsight
    range: '10'
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Draconic
damageImmunitiesList:
  - value: Lightning
cr: '3'
xp: '700'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes two Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Slashing damage plus 3 (1d6) Lightning damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d10
          bonus: 3
          type: Slashing
          average: 8
        - dice: 1d6
          bonus: 0
          type: Lightning
          average: 3
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Lightning Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 12, each creature in a 30-foot-long, 5-foot-wide Line. *Failure:*  21 (6d6) Lightning damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 12
      targeting:
        shape: line
        size: 30 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 21 (6d6) Lightning damage.
        damage:
          - dice: 6d6
            bonus: 0
            type: Lightning
            average: 21
        legacyEffects: 21 (6d6) Lightning damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Blue Dragon Wyrmling
*Medium, Dragon, Lawful Evil*

**AC** 17
**HP** 65 (10d8 + 20)
**Initiative** +2 (12)
**Speed** 30 ft., fly 60 ft., burrow 15 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft., darkvision 60 ft.; Passive Perception 14
**Languages** Draconic
CR 3, PB +2, XP 700

## Actions

**Multiattack**
The dragon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Slashing damage plus 3 (1d6) Lightning damage.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 12, each creature in a 30-foot-long, 5-foot-wide Line. *Failure:*  21 (6d6) Lightning damage. *Success:*  Half damage.
`,
      "Monsters/bone-devil.md": `---
smType: creature
name: Bone Devil
size: Large
type: Fiend
typeTags:
  - value: Devil
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '16'
initiative: +7 (17)
hp: '161'
hitDice: 17d10 + 68
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 40 ft.
abilities:
  - key: str
    score: 18
    saveProf: true
    saveMod: 8
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 18
    saveProf: false
  - key: int
    score: 13
    saveProf: true
    saveMod: 5
  - key: wis
    score: 14
    saveProf: true
    saveMod: 6
  - key: cha
    score: 16
    saveProf: true
    saveMod: 7
pb: '+4'
skills:
  - skill: Deception
    value: '7'
  - skill: Insight
    value: '6'
sensesList:
  - type: darkvision 120 ft. (unimpeded by magical darkness)
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Infernal
  - value: telepathy 120 ft.
damageResistancesList:
  - value: Cold
damageImmunitiesList:
  - value: Fire
  - value: Poison; Poisoned
cr: '9'
xp: '5000'
entries:
  - category: trait
    name: Diabolical Restoration
    entryType: special
    text: If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The devil has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The devil makes two Claw attacks and one Infernal Sting attack.
    multiattack:
      attacks:
        - name: Claw
          count: 2
        - name: Sting
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +8, reach 10 ft. 13 (2d8 + 4) Slashing damage.'
    attack:
      type: melee
      bonus: 8
      damage:
        - dice: 2d8
          bonus: 4
          type: Slashing
          average: 13
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Infernal Sting
    entryType: attack
    text: '*Melee Attack Roll:* +8, reach 10 ft. 15 (2d10 + 4) Piercing damage plus 18 (4d8) Poison damage, and the target has the Poisoned condition until the start of the devil''s next turn. While Poisoned, the target can''t regain Hit Points.'
    attack:
      type: melee
      bonus: 8
      damage:
        - dice: 2d10
          bonus: 4
          type: Piercing
          average: 15
        - dice: 4d8
          bonus: 0
          type: Poison
          average: 18
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Bone Devil
*Large, Fiend, Lawful Evil*

**AC** 16
**HP** 161 (17d10 + 68)
**Initiative** +7 (17)
**Speed** 40 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft. (unimpeded by magical darkness); Passive Perception 12
**Languages** Infernal, telepathy 120 ft.
CR 9, PB +4, XP 5000

## Traits

**Diabolical Restoration**
If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.

**Magic Resistance**
The devil has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The devil makes two Claw attacks and one Infernal Sting attack.

**Claw**
*Melee Attack Roll:* +8, reach 10 ft. 13 (2d8 + 4) Slashing damage.

**Infernal Sting**
*Melee Attack Roll:* +8, reach 10 ft. 15 (2d10 + 4) Piercing damage plus 18 (4d8) Poison damage, and the target has the Poisoned condition until the start of the devil's next turn. While Poisoned, the target can't regain Hit Points.
`,
      "Monsters/brass-dragon-wyrmling.md": `---
smType: creature
name: Brass Dragon Wyrmling
size: Medium
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Good
ac: '15'
initiative: +2 (12)
hp: '22'
hitDice: 4d8 + 4
speeds:
  walk:
    distance: 30 ft.
  burrow:
    distance: 15 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 2
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 2
  - key: cha
    score: 13
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '2'
sensesList:
  - type: blindsight
    range: '10'
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Draconic
damageImmunitiesList:
  - value: Fire
cr: '1'
xp: '200'
entries:
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d10
          bonus: 2
          type: Slashing
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fire Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 11, each creature in a 20-foot-long, 5-foot-wide Line. *Failure:*  14 (4d6) Fire damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 11
      targeting:
        shape: line
        size: 20 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 14 (4d6) Fire damage.
        damage:
          - dice: 4d6
            bonus: 0
            type: Fire
            average: 14
        legacyEffects: 14 (4d6) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Sleep Breath
    entryType: save
    text: '*Constitution Saving Throw*: DC 11, each creature in a 15-foot Cone. *Failure:*  The target has the Incapacitated condition until the end of its next turn, at which point it repeats the save. *Second Failure* The target has the Unconscious condition for 1 minute. This effect ends for the target if it takes damage or a creature within 5 feet of it takes an action to wake it.'
    save:
      ability: con
      dc: 11
      targeting:
        shape: cone
        size: 15 ft.
      onFail:
        effects:
          conditions:
            - condition: Incapacitated
              duration:
                type: until
                trigger: the end of its next turn
              saveToEnd:
                timing: custom
            - condition: Unconscious
              duration:
                type: until
                trigger: the end of its next turn
              saveToEnd:
                timing: custom
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Brass Dragon Wyrmling
*Medium, Dragon, Chaotic Good*

**AC** 15
**HP** 22 (4d8 + 4)
**Initiative** +2 (12)
**Speed** 30 ft., fly 60 ft., burrow 15 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft., darkvision 60 ft.; Passive Perception 14
**Languages** Draconic
CR 1, PB +2, XP 200

## Actions

**Rend**
*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 11, each creature in a 20-foot-long, 5-foot-wide Line. *Failure:*  14 (4d6) Fire damage. *Success:*  Half damage.

**Sleep Breath**
*Constitution Saving Throw*: DC 11, each creature in a 15-foot Cone. *Failure:*  The target has the Incapacitated condition until the end of its next turn, at which point it repeats the save. *Second Failure* The target has the Unconscious condition for 1 minute. This effect ends for the target if it takes damage or a creature within 5 feet of it takes an action to wake it.
`,
      "Monsters/bronze-dragon-wyrmling.md": `---
smType: creature
name: Bronze Dragon Wyrmling
size: Medium
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '15'
initiative: +2 (12)
hp: '39'
hitDice: 6d8 + 12
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 60 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 2
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 2
  - key: cha
    score: 15
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '2'
sensesList:
  - type: blindsight
    range: '10'
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Draconic
damageImmunitiesList:
  - value: Lightning
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes two Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Slashing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d10
          bonus: 3
          type: Slashing
          average: 8
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Lightning Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 12, each creature in a 40-foot-long, 5-foot-wide Line. *Failure:*  16 (3d10) Lightning damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 12
      targeting:
        shape: line
        size: 40 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 16 (3d10) Lightning damage.
        damage:
          - dice: 3d10
            bonus: 0
            type: Lightning
            average: 16
        legacyEffects: 16 (3d10) Lightning damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Repulsion Breath
    entryType: save
    text: '*Strength Saving Throw*: DC 12, each creature in a 30-foot Cone. *Failure:*  The target is pushed up to 30 feet straight away from the dragon and has the Prone condition.'
    save:
      ability: str
      dc: 12
      targeting:
        shape: cone
        size: 30 ft.
      onFail:
        effects:
          conditions:
            - condition: Prone
          movement:
            type: push
            distance: 30 feet
            direction: straight away from the dragon
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Bronze Dragon Wyrmling
*Medium, Dragon, Lawful Good*

**AC** 15
**HP** 39 (6d8 + 12)
**Initiative** +2 (12)
**Speed** 30 ft., swim 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft., darkvision 60 ft.; Passive Perception 14
**Languages** Draconic
CR 2, PB +2, XP 450

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Slashing damage.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 12, each creature in a 40-foot-long, 5-foot-wide Line. *Failure:*  16 (3d10) Lightning damage. *Success:*  Half damage.

**Repulsion Breath**
*Strength Saving Throw*: DC 12, each creature in a 30-foot Cone. *Failure:*  The target is pushed up to 30 feet straight away from the dragon and has the Prone condition.
`,
      "Monsters/bugbear-stalker.md": `---
smType: creature
name: Bugbear Stalker
size: Medium
type: Fey
typeTags:
  - value: Goblinoid
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '15'
initiative: +2 (12)
hp: '65'
hitDice: 10d8 + 20
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 14
    saveProf: true
    saveMod: 4
  - key: int
    score: 11
    saveProf: false
  - key: wis
    score: 12
    saveProf: true
    saveMod: 3
  - key: cha
    score: 11
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '6'
  - skill: Survival
    value: '3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Common
  - value: Goblin
cr: '3'
xp: '700'
entries:
  - category: trait
    name: Abduct
    entryType: special
    text: The bugbear needn't spend extra movement to move a creature it is grappling.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The bugbear makes two Javelin or Morningstar attacks.
    multiattack:
      attacks:
        - name: Morningstar
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Javelin
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +5, reach 10 ft. or range 30/120 ft. 13 (3d6 + 3) Piercing damage.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Morningstar
    entryType: attack
    text: '*Melee Attack Roll:* +5 (with Advantage if the target is Grappled by the bugbear), reach 10 ft. 12 (2d8 + 3) Piercing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d8
          bonus: 3
          type: Piercing
          average: 12
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Quick Grapple
    entryType: save
    text: '*Dexterity Saving Throw*: DC 13, one Medium or smaller creature the bugbear can see within 10 feet. *Failure:*  The target has the Grappled condition (escape DC 13).'
    save:
      ability: dex
      dc: 13
      targeting:
        type: single
        range: 10 ft.
        restrictions:
          size:
            - Medium
            - smaller
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Grappled
              escape:
                type: dc
                dc: 13
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Bugbear Stalker
*Medium, Fey, Chaotic Evil*

**AC** 15
**HP** 65 (10d8 + 20)
**Initiative** +2 (12)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 11
**Languages** Common, Goblin
CR 3, PB +2, XP 700

## Traits

**Abduct**
The bugbear needn't spend extra movement to move a creature it is grappling.

## Actions

**Multiattack**
The bugbear makes two Javelin or Morningstar attacks.

**Javelin**
*Melee or Ranged Attack Roll:* +5, reach 10 ft. or range 30/120 ft. 13 (3d6 + 3) Piercing damage.

**Morningstar**
*Melee Attack Roll:* +5 (with Advantage if the target is Grappled by the bugbear), reach 10 ft. 12 (2d8 + 3) Piercing damage.

## Bonus Actions

**Quick Grapple**
*Dexterity Saving Throw*: DC 13, one Medium or smaller creature the bugbear can see within 10 feet. *Failure:*  The target has the Grappled condition (escape DC 13).
`,
      "Monsters/bugbear-warrior.md": `---
smType: creature
name: Bugbear Warrior
size: Medium
type: Fey
typeTags:
  - value: Goblinoid
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '14'
initiative: +2 (12)
hp: '33'
hitDice: 6d8 + 6
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 8
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 9
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '6'
  - skill: Survival
    value: '2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common
  - value: Goblin
cr: '1'
xp: '200'
entries:
  - category: trait
    name: Abduct
    entryType: special
    text: The bugbear needn't spend extra movement to move a creature it is grappling.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Grab
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 10 ft. 9 (2d6 + 2) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12).'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 2d6
          bonus: 2
          type: Bludgeoning
          average: 9
      reach: 10 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 12
            restrictions:
              size: Medium or smaller
      additionalEffects: If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12).
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Light Hammer
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +4 (with Advantage if the target is Grappled by the bugbear), reach 10 ft. or range 20/60 ft. 9 (3d4 + 2) Bludgeoning damage.'
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Bugbear Warrior
*Medium, Fey, Chaotic Evil*

**AC** 14
**HP** 33 (6d8 + 6)
**Initiative** +2 (12)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Common, Goblin
CR 1, PB +2, XP 200

## Traits

**Abduct**
The bugbear needn't spend extra movement to move a creature it is grappling.

## Actions

**Grab**
*Melee Attack Roll:* +4, reach 10 ft. 9 (2d6 + 2) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12).

**Light Hammer**
*Melee or Ranged Attack Roll:* +4 (with Advantage if the target is Grappled by the bugbear), reach 10 ft. or range 20/60 ft. 9 (3d4 + 2) Bludgeoning damage.
`,
      "Monsters/bulette.md": `---
smType: creature
name: Bulette
size: Large
type: Monstrosity
alignmentOverride: Unaligned
ac: '17'
initiative: +0 (10)
hp: '94'
hitDice: 9d10 + 45
speeds:
  walk:
    distance: 40 ft.
  burrow:
    distance: 40 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 21
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '6'
sensesList:
  - type: darkvision
    range: '60'
  - type: tremorsense
    range: '120'
passivesList:
  - skill: Perception
    value: '16'
cr: '5'
xp: '1800'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The bulette makes two Bite attacks.
    multiattack:
      attacks:
        - name: Bite
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 17 (2d12 + 4) Piercing damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d12
          bonus: 4
          type: Piercing
          average: 17
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Deadly Leap
    entryType: save
    text: 'The bulette spends 5 feet of movement to jump to a space within 15 feet that contains one or more Large or smaller creatures. *Dexterity Saving Throw*: DC 15, each creature in the bulette''s destination space. *Failure:*  19 (3d12) Bludgeoning damage, and the target has the Prone condition. *Success:*  Half damage, and the target is pushed 5 feet straight away from the bulette.'
    save:
      ability: dex
      dc: 15
      targeting:
        type: single
        restrictions:
          creatureTypes:
            - creature
      onFail:
        effects:
          conditions:
            - condition: Prone
        damage:
          - dice: 3d12
            bonus: 0
            type: Bludgeoning
            average: 19
      onSuccess:
        damage: half
        legacyText: Half damage, and the target is pushed 5 feet straight away from the bulette.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Leap
    entryType: special
    text: The bulette jumps up to 30 feet by spending 10 feet of movement.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Bulette
*Large, Monstrosity, Unaligned*

**AC** 17
**HP** 94 (9d10 + 45)
**Initiative** +0 (10)
**Speed** 40 ft., burrow 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft., tremorsense 120 ft.; Passive Perception 16
CR 5, PB +3, XP 1800

## Actions

**Multiattack**
The bulette makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +7, reach 5 ft. 17 (2d12 + 4) Piercing damage.

**Deadly Leap**
The bulette spends 5 feet of movement to jump to a space within 15 feet that contains one or more Large or smaller creatures. *Dexterity Saving Throw*: DC 15, each creature in the bulette's destination space. *Failure:*  19 (3d12) Bludgeoning damage, and the target has the Prone condition. *Success:*  Half damage, and the target is pushed 5 feet straight away from the bulette.

## Bonus Actions

**Leap**
The bulette jumps up to 30 feet by spending 10 feet of movement.
`,
      "Monsters/centaur-trooper.md": `---
smType: creature
name: Centaur Trooper
size: Large
type: Fey
alignmentLawChaos: Neutral
alignmentGoodEvil: Good
ac: '16'
initiative: +2 (12)
hp: '45'
hitDice: 6d10 + 12
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 9
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 11
    saveProf: false
pb: '+2'
skills:
  - skill: Athletics
    value: '6'
  - skill: Perception
    value: '3'
passivesList:
  - skill: Perception
    value: '13'
languagesList:
  - value: Elvish
  - value: Sylvan
cr: '2'
xp: '450'
entries:
  - category: action
    name: Multiattack
    entryType: special
    text: The centaur makes two attacks, using Pike or Longbow in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Pike
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 10 ft. 9 (1d10 + 4) Piercing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d10
          bonus: 4
          type: Piercing
          average: 9
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Longbow
    entryType: attack
    text: '*Ranged Attack Roll:* +4, range 150/600 ft. 6 (1d8 + 2) Piercing damage.'
    attack:
      type: ranged
      bonus: 4
      damage:
        - dice: 1d8
          bonus: 2
          type: Piercing
          average: 6
      range: 150/600 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Trampling Charge (Recharge 5-6)
    entryType: save
    text: 'The centaur moves up to its Speed without provoking Opportunity Attacks and can move through the spaces of Medium or smaller creatures. Each creature whose space the centaur enters is targeted once by the following effect. *Strength Saving Throw*: DC 14. *Failure:*  7 (1d6 + 4) Bludgeoning damage, and the target has the Prone condition.'
    recharge: 5-6
    save:
      ability: str
      dc: 14
      onFail:
        effects:
          conditions:
            - condition: Prone
        damage:
          - dice: 1d6
            bonus: 4
            type: Bludgeoning
            average: 7
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Centaur Trooper
*Large, Fey, Neutral Good*

**AC** 16
**HP** 45 (6d10 + 12)
**Initiative** +2 (12)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Elvish, Sylvan
CR 2, PB +2, XP 450

## Actions

**Multiattack**
The centaur makes two attacks, using Pike or Longbow in any combination.

**Pike**
*Melee Attack Roll:* +6, reach 10 ft. 9 (1d10 + 4) Piercing damage.

**Longbow**
*Ranged Attack Roll:* +4, range 150/600 ft. 6 (1d8 + 2) Piercing damage.

## Bonus Actions

**Trampling Charge (Recharge 5-6)**
The centaur moves up to its Speed without provoking Opportunity Attacks and can move through the spaces of Medium or smaller creatures. Each creature whose space the centaur enters is targeted once by the following effect. *Strength Saving Throw*: DC 14. *Failure:*  7 (1d6 + 4) Bludgeoning damage, and the target has the Prone condition.
`,
      "Monsters/chain-devil.md": `---
smType: creature
name: Chain Devil
size: Medium
type: Fiend
typeTags:
  - value: Devil
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '15'
initiative: +5 (15)
hp: '85'
hitDice: 10d8 + 40
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 18
    saveProf: true
    saveMod: 7
  - key: int
    score: 11
    saveProf: false
  - key: wis
    score: 12
    saveProf: true
    saveMod: 4
  - key: cha
    score: 14
    saveProf: false
pb: '+3'
sensesList:
  - type: darkvision 120 ft. (unimpeded by magical darkness)
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Infernal
  - value: telepathy 120 ft.
damageResistancesList:
  - value: Bludgeoning
  - value: Cold
  - value: Piercing
  - value: Slashing
damageImmunitiesList:
  - value: Fire
  - value: Poison; Poisoned
cr: '8'
xp: '3900'
entries:
  - category: trait
    name: Diabolical Restoration
    entryType: special
    text: If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The devil has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The devil makes two Chain attacks and uses Conjure Infernal Chain.
    multiattack:
      attacks:
        - name: Chain
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Chain
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Slashing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of two chains, and it has the Restrained condition until the grapple ends.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d6
          bonus: 4
          type: Slashing
          average: 11
      reach: 10 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 14
            restrictions:
              size: Large or smaller
            duration:
              type: until
              trigger: the grapple ends
          - condition: Restrained
            escape:
              type: dc
              dc: 14
            restrictions:
              size: Large or smaller
            duration:
              type: until
              trigger: the grapple ends
      additionalEffects: If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of two chains, and it has the Restrained condition until the grapple ends.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Conjure Infernal Chain
    entryType: save
    text: 'The devil conjures a fiery chain to bind a creature. *Dexterity Saving Throw*: DC 15, one creature the devil can see within 60 feet. *Failure:*  9 (2d4 + 4) Fire damage, and the target has the Restrained condition until the end of the devil''s next turn, at which point the chain disappears. If the target is Large or smaller, the devil moves the target up to 30 feet straight toward itself. *Success:*  The chain disappears.'
    save:
      ability: dex
      dc: 15
      targeting:
        type: single
        range: 60 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Restrained
              restrictions:
                size: Large or smaller
              duration:
                type: until
                trigger: the end of the devil's next turn
        damage:
          - dice: 2d4
            bonus: 4
            type: Fire
            average: 9
      onSuccess: The chain disappears.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Chain Devil
*Medium, Fiend, Lawful Evil*

**AC** 15
**HP** 85 (10d8 + 40)
**Initiative** +5 (15)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft. (unimpeded by magical darkness); Passive Perception 11
**Languages** Infernal, telepathy 120 ft.
CR 8, PB +3, XP 3900

## Traits

**Diabolical Restoration**
If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.

**Magic Resistance**
The devil has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The devil makes two Chain attacks and uses Conjure Infernal Chain.

**Chain**
*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Slashing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of two chains, and it has the Restrained condition until the grapple ends.

**Conjure Infernal Chain**
The devil conjures a fiery chain to bind a creature. *Dexterity Saving Throw*: DC 15, one creature the devil can see within 60 feet. *Failure:*  9 (2d4 + 4) Fire damage, and the target has the Restrained condition until the end of the devil's next turn, at which point the chain disappears. If the target is Large or smaller, the devil moves the target up to 30 feet straight toward itself. *Success:*  The chain disappears.
`,
      "Monsters/chimera.md": `---
smType: creature
name: Chimera
size: Large
type: Monstrosity
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '14'
initiative: +0 (10)
hp: '114'
hitDice: 12d10 + 48
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 19
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 10
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '8'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '18'
languagesList:
  - value: Understands Draconic but can't speak
cr: '6'
xp: '2300'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The chimera makes one Ram attack, one Bite attack, and one Claw attack. It can replace the Claw attack with a use of Fire Breath if available.
    multiattack:
      attacks:
        - name: Ram
          count: 1
        - name: Bite
          count: 1
        - name: Claw
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 11 (2d6 + 4) Piercing damage, or 18 (4d6 + 4) Piercing damage if the chimera had Advantage on the attack roll.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d6
          bonus: 4
          type: Piercing
          average: 11
        - dice: 4d6
          bonus: 4
          type: Piercing
          average: 18
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 7 (1d6 + 4) Slashing damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 1d6
          bonus: 4
          type: Slashing
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Ram
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 10 (1d12 + 4) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Prone condition.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 1d12
          bonus: 4
          type: Bludgeoning
          average: 10
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Medium or smaller
      additionalEffects: If the target is a Medium or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fire Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 15, each creature in a 15-foot Cone. *Failure:*  31 (7d8) Fire damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 15
      targeting:
        shape: cone
        size: 15 ft.
      onFail:
        effects:
          other: 31 (7d8) Fire damage.
        damage:
          - dice: 7d8
            bonus: 0
            type: Fire
            average: 31
        legacyEffects: 31 (7d8) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Chimera
*Large, Monstrosity, Chaotic Evil*

**AC** 14
**HP** 114 (12d10 + 48)
**Initiative** +0 (10)
**Speed** 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 18
**Languages** Understands Draconic but can't speak
CR 6, PB +3, XP 2300

## Actions

**Multiattack**
The chimera makes one Ram attack, one Bite attack, and one Claw attack. It can replace the Claw attack with a use of Fire Breath if available.

**Bite**
*Melee Attack Roll:* +7, reach 5 ft. 11 (2d6 + 4) Piercing damage, or 18 (4d6 + 4) Piercing damage if the chimera had Advantage on the attack roll.

**Claw**
*Melee Attack Roll:* +7, reach 5 ft. 7 (1d6 + 4) Slashing damage.

**Ram**
*Melee Attack Roll:* +7, reach 5 ft. 10 (1d12 + 4) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Prone condition.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 15, each creature in a 15-foot Cone. *Failure:*  31 (7d8) Fire damage. *Success:*  Half damage.
`,
      "Monsters/chuul.md": `---
smType: creature
name: Chuul
size: Large
type: Aberration
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '16'
initiative: +0 (10)
hp: '76'
hitDice: 9d10 + 27
speeds:
  walk:
    distance: 30 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 5
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Understands Deep Speech but can't speak
damageImmunitiesList:
  - value: Poison; Poisoned
cr: '4'
xp: '1100'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The chuul can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Sense Magic
    entryType: special
    text: The chuul senses magic within 120 feet of itself. This trait otherwise works like the *Detect Magic* spell but isn't itself magical.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The chuul makes two Pincer attacks and uses Paralyzing Tentacles.
    multiattack:
      attacks:
        - name: Pincer
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Pincer
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 10 ft. 9 (1d10 + 4) Bludgeoning damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of two pincers.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d10
          bonus: 4
          type: Bludgeoning
          average: 9
      reach: 10 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 14
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of two pincers.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Paralyzing Tentacles
    entryType: save
    text: '*Constitution Saving Throw*: DC 13, one creature Grappled by the chuul. *Failure:*  The target has the Poisoned condition and repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically. While Poisoned, the target has the Paralyzed condition.'
    save:
      ability: con
      dc: 13
      targeting:
        type: single
        restrictions:
          other:
            - grappled by source
      onFail:
        effects:
          conditions:
            - condition: Poisoned
              saveToEnd:
                timing: end-of-turn
              restrictions:
                while: While Poisoned, the target has the Paralyzed condition
            - condition: Paralyzed
              saveToEnd:
                timing: end-of-turn
              restrictions:
                while: While Poisoned, the target has the Paralyzed condition
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Chuul
*Large, Aberration, Chaotic Evil*

**AC** 16
**HP** 76 (9d10 + 27)
**Initiative** +0 (10)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 14
**Languages** Understands Deep Speech but can't speak
CR 4, PB +2, XP 1100

## Traits

**Amphibious**
The chuul can breathe air and water.

**Sense Magic**
The chuul senses magic within 120 feet of itself. This trait otherwise works like the *Detect Magic* spell but isn't itself magical.

## Actions

**Multiattack**
The chuul makes two Pincer attacks and uses Paralyzing Tentacles.

**Pincer**
*Melee Attack Roll:* +6, reach 10 ft. 9 (1d10 + 4) Bludgeoning damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of two pincers.

**Paralyzing Tentacles**
*Constitution Saving Throw*: DC 13, one creature Grappled by the chuul. *Failure:*  The target has the Poisoned condition and repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically. While Poisoned, the target has the Paralyzed condition.
`,
      "Monsters/clay-golem.md": `---
smType: creature
name: Clay Golem
size: Large
type: Construct
alignmentOverride: Unaligned
ac: '14'
initiative: +3 (13)
hp: '123'
hitDice: 13d10 + 52
speeds:
  walk:
    distance: 20 ft.
abilities:
  - key: str
    score: 20
    saveProf: false
  - key: dex
    score: 9
    saveProf: false
  - key: con
    score: 18
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 8
    saveProf: false
  - key: cha
    score: 1
    saveProf: false
pb: '+4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '9'
languagesList:
  - value: Common plus one other language
damageResistancesList:
  - value: Bludgeoning
  - value: Piercing
  - value: Slashing
damageImmunitiesList:
  - value: Acid
  - value: Poison
  - value: Psychic; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Frightened
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
cr: '9'
xp: '5000'
entries:
  - category: trait
    name: Acid Absorption
    entryType: special
    text: Whenever the golem is subjected to Acid damage, it takes no damage and instead regains a number of Hit Points equal to the Acid damage dealt.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Berserk
    entryType: special
    text: Whenever the golem starts its turn Bloodied, roll 1d6. On a 6, the golem goes berserk. On each of its turns while berserk, the golem attacks the nearest creature it can see. If no creature is near enough to move to and attack, the golem attacks an object. Once the golem goes berserk, it continues to be berserk until it is destroyed or it is no longer Bloodied.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Immutable Form
    entryType: special
    text: The golem can't shape-shift.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The golem has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The golem makes two Slam attacks, or it makes three Slam attacks if it used Hasten this turn.
    multiattack:
      attacks:
        - name: Slam
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Slam
    entryType: attack
    text: '*Melee Attack Roll:* +9, reach 5 ft. 10 (1d10 + 5) Bludgeoning damage plus 6 (1d12) Acid damage, and the target''s Hit Point maximum decreases by an amount equal to the Acid damage taken.'
    attack:
      type: melee
      bonus: 9
      damage:
        - dice: 1d10
          bonus: 5
          type: Bludgeoning
          average: 10
        - dice: 1d12
          bonus: 0
          type: Acid
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Hasten (Recharge 5-6)
    entryType: special
    text: The golem takes the Dash and Disengage actions.
    recharge: 5-6
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Clay Golem
*Large, Construct, Unaligned*

**AC** 14
**HP** 123 (13d10 + 52)
**Initiative** +3 (13)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 9
**Languages** Common plus one other language
CR 9, PB +4, XP 5000

## Traits

**Acid Absorption**
Whenever the golem is subjected to Acid damage, it takes no damage and instead regains a number of Hit Points equal to the Acid damage dealt.

**Berserk**
Whenever the golem starts its turn Bloodied, roll 1d6. On a 6, the golem goes berserk. On each of its turns while berserk, the golem attacks the nearest creature it can see. If no creature is near enough to move to and attack, the golem attacks an object. Once the golem goes berserk, it continues to be berserk until it is destroyed or it is no longer Bloodied.

**Immutable Form**
The golem can't shape-shift.

**Magic Resistance**
The golem has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The golem makes two Slam attacks, or it makes three Slam attacks if it used Hasten this turn.

**Slam**
*Melee Attack Roll:* +9, reach 5 ft. 10 (1d10 + 5) Bludgeoning damage plus 6 (1d12) Acid damage, and the target's Hit Point maximum decreases by an amount equal to the Acid damage taken.

## Bonus Actions

**Hasten (Recharge 5-6)**
The golem takes the Dash and Disengage actions.
`,
      "Monsters/cloaker.md": `---
smType: creature
name: Cloaker
size: Large
type: Aberration
alignmentLawChaos: Chaotic
alignmentGoodEvil: Neutral
ac: '14'
initiative: +5 (15)
hp: '91'
hitDice: 14d10 + 14
speeds:
  walk:
    distance: 10 ft.
  fly:
    distance: 40 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 13
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+3'
skills:
  - skill: Stealth
    value: '5'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Deep Speech
  - value: Undercommon
conditionImmunitiesList:
  - value: Frightened
cr: '8'
xp: '3900'
entries:
  - category: trait
    name: Light Sensitivity
    entryType: special
    text: While in Bright Light, the cloaker has Disadvantage on attack rolls.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The cloaker makes one Attach attack and two Tail attacks.
    multiattack:
      attacks:
        - name: Attach
          count: 1
        - name: Tail
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Attach
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 13 (3d6 + 3) Piercing damage. If the target is a Large or smaller creature, the cloaker attaches to it. While the cloaker is attached, the target has the Blinded condition, and the cloaker can''t make Attach attacks against other targets. In addition, the cloaker halves the damage it takes (round down), and the target takes the same amount of damage. The cloaker can detach itself by spending 5 feet of movement. The target or a creature within 5 feet of it can take an action to try to detach the cloaker, doing so by succeeding on a DC 14 Strength (Athletics) check.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 3d6
          bonus: 3
          type: Piercing
          average: 13
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Blinded
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature, the cloaker attaches to it. While the cloaker is attached, the target has the Blinded condition, and the cloaker can't make Attach attacks against other targets. In addition, the cloaker halves the damage it takes (round down), and the target takes the same amount of damage. The cloaker can detach itself by spending 5 feet of movement. The target or a creature within 5 feet of it can take an action to try to detach the cloaker, doing so by succeeding on a DC 14 Strength (Athletics) check.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Tail
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 10 ft. 8 (1d10 + 3) Slashing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d10
          bonus: 3
          type: Slashing
          average: 8
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Moan
    entryType: save
    text: '*Wisdom Saving Throw*: DC 13, each creature in a 60-foot Emanation originating from the cloaker. *Failure:*  The target has the Frightened condition until the end of the cloaker''s next turn. *Success:*  The target is immune to this cloaker''s Moan for the next 24 hours.'
    save:
      ability: wis
      dc: 13
      targeting:
        shape: emanation
        size: 60 ft.
        origin: self
      onFail:
        effects:
          conditions:
            - condition: Frightened
              duration:
                type: until
                trigger: the end of the cloaker's next turn
      onSuccess: The target is immune to this cloaker's Moan for the next 24 hours.
    trigger.activation: bonus
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: bonus
    name: Phantasms (Recharge after a Short or Long Rest)
    entryType: spellcasting
    text: The cloaker casts the *Mirror Image* spell, requiring no spell components and using Wisdom as the spellcasting ability. The spell ends early if the cloaker starts or ends its turn in Bright Light.
    spellcasting:
      ability: wis
      spellLists: []
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Cloaker
*Large, Aberration, Chaotic Neutral*

**AC** 14
**HP** 91 (14d10 + 14)
**Initiative** +5 (15)
**Speed** 10 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 12
**Languages** Deep Speech, Undercommon
CR 8, PB +3, XP 3900

## Traits

**Light Sensitivity**
While in Bright Light, the cloaker has Disadvantage on attack rolls.

## Actions

**Multiattack**
The cloaker makes one Attach attack and two Tail attacks.

**Attach**
*Melee Attack Roll:* +6, reach 5 ft. 13 (3d6 + 3) Piercing damage. If the target is a Large or smaller creature, the cloaker attaches to it. While the cloaker is attached, the target has the Blinded condition, and the cloaker can't make Attach attacks against other targets. In addition, the cloaker halves the damage it takes (round down), and the target takes the same amount of damage. The cloaker can detach itself by spending 5 feet of movement. The target or a creature within 5 feet of it can take an action to try to detach the cloaker, doing so by succeeding on a DC 14 Strength (Athletics) check.

**Tail**
*Melee Attack Roll:* +6, reach 10 ft. 8 (1d10 + 3) Slashing damage.

## Bonus Actions

**Moan**
*Wisdom Saving Throw*: DC 13, each creature in a 60-foot Emanation originating from the cloaker. *Failure:*  The target has the Frightened condition until the end of the cloaker's next turn. *Success:*  The target is immune to this cloaker's Moan for the next 24 hours.

**Phantasms (Recharge after a Short or Long Rest)**
The cloaker casts the *Mirror Image* spell, requiring no spell components and using Wisdom as the spellcasting ability. The spell ends early if the cloaker starts or ends its turn in Bright Light.
`,
      "Monsters/cloud-giant.md": `---
smType: creature
name: Cloud Giant
size: Huge
type: Giant
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '14'
initiative: +4 (14)
hp: '200'
hitDice: 16d12 + 96
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 20 ft.
    hover: true
abilities:
  - key: str
    score: 27
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 22
    saveProf: true
    saveMod: 10
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 16
    saveProf: true
    saveMod: 7
  - key: cha
    score: 16
    saveProf: false
pb: '+4'
skills:
  - skill: Insight
    value: '7'
  - skill: Perception
    value: '11'
passivesList:
  - skill: Perception
    value: '21'
languagesList:
  - value: Common
  - value: Giant
cr: '9'
xp: '5000'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The giant makes two attacks, using Thunderous Mace or Thundercloud in any combination. It can replace one attack with a use of Spellcasting to cast *Fog Cloud*.
    multiattack:
      attacks:
        - name: two
          count: 1
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            spell: Fog Cloud
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Thunderous Mace
    entryType: attack
    text: '*Melee Attack Roll:* +12, reach 10 ft. 21 (3d8 + 8) Bludgeoning damage plus 7 (2d6) Thunder damage.'
    attack:
      type: melee
      bonus: 12
      damage:
        - dice: 3d8
          bonus: 8
          type: Bludgeoning
          average: 21
        - dice: 2d6
          bonus: 0
          type: Thunder
          average: 7
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Thundercloud
    entryType: attack
    text: '*Ranged Attack Roll:* +12, range 240 ft. 18 (3d6 + 8) Thunder damage, and the target has the Incapacitated condition until the end of its next turn.'
    attack:
      type: ranged
      bonus: 12
      damage:
        - dice: 3d6
          bonus: 8
          type: Thunder
          average: 18
      range: 240 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The giant casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 15): - **At Will:** *Detect Magic*, *Fog Cloud*, *Light* - **1e/Day Each:** *Control Weather*, *Gaseous Form*, *Telekinesis*'
    spellcasting:
      ability: cha
      saveDC: 15
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Fog Cloud
            - Light
        - frequency: 1/day
          spells:
            - Control Weather
            - Gaseous Form
            - Telekinesis
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Misty Step
    entryType: spellcasting
    text: The giant casts the *Misty Step* spell, using the same spellcasting ability as Spellcasting.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Cloud Giant
*Huge, Giant, Neutral Neutral*

**AC** 14
**HP** 200 (16d12 + 96)
**Initiative** +4 (14)
**Speed** 40 ft., fly 20 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common, Giant
CR 9, PB +4, XP 5000

## Actions

**Multiattack**
The giant makes two attacks, using Thunderous Mace or Thundercloud in any combination. It can replace one attack with a use of Spellcasting to cast *Fog Cloud*.

**Thunderous Mace**
*Melee Attack Roll:* +12, reach 10 ft. 21 (3d8 + 8) Bludgeoning damage plus 7 (2d6) Thunder damage.

**Thundercloud**
*Ranged Attack Roll:* +12, range 240 ft. 18 (3d6 + 8) Thunder damage, and the target has the Incapacitated condition until the end of its next turn.

**Spellcasting**
The giant casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 15): - **At Will:** *Detect Magic*, *Fog Cloud*, *Light* - **1e/Day Each:** *Control Weather*, *Gaseous Form*, *Telekinesis*

## Bonus Actions

**Misty Step**
The giant casts the *Misty Step* spell, using the same spellcasting ability as Spellcasting.
`,
      "Monsters/cockatrice.md": `---
smType: creature
name: Cockatrice
size: Small
type: Monstrosity
alignmentOverride: Unaligned
ac: '11'
initiative: +1 (11)
hp: '22'
hitDice: 5d6 + 5
speeds:
  walk:
    distance: 20 ft.
  fly:
    distance: 40 ft.
abilities:
  - key: str
    score: 6
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '11'
conditionImmunitiesList:
  - value: Petrified
cr: 1/2
xp: '100'
entries:
  - category: action
    name: Petrifying Bite
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 3 (1d4 + 1) Piercing damage. If the target is a creature, it is subjected to the following effect. *Constitution Saving Throw*: DC 11. *First Failure* The target has the Restrained condition. The target repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition, instead of the Restrained condition, for 24 hours.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 1d4
          bonus: 1
          type: Piercing
          average: 3
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Restrained
            duration:
              type: hours
              count: 24
            saveToEnd:
              timing: custom
              description: at the end of its next turn if it is still Restrained
          - condition: Petrified
            duration:
              type: hours
              count: 24
            saveToEnd:
              timing: custom
              description: at the end of its next turn if it is still Restrained
      additionalEffects: 'If the target is a creature, it is subjected to the following effect. *Constitution Saving Throw*: DC 11. *First Failure* The target has the Restrained condition. The target repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition, instead of the Restrained condition, for 24 hours.'
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Cockatrice
*Small, Monstrosity, Unaligned*

**AC** 11
**HP** 22 (5d6 + 5)
**Initiative** +1 (11)
**Speed** 20 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 11
CR 1/2, PB +2, XP 100

## Actions

**Petrifying Bite**
*Melee Attack Roll:* +3, reach 5 ft. 3 (1d4 + 1) Piercing damage. If the target is a creature, it is subjected to the following effect. *Constitution Saving Throw*: DC 11. *First Failure* The target has the Restrained condition. The target repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition, instead of the Restrained condition, for 24 hours.
`,
      "Monsters/commoner.md": `---
smType: creature
name: Commoner
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '10'
initiative: +0 (10)
hp: '4'
hitDice: 1d8
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 10
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Training
    entryType: special
    text: The commoner has proficiency in one skill of the DM's choice and has Advantage whenever it makes an ability check using that skill.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Club
    entryType: attack
    text: '*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 2
      damage:
        - dice: 1d4
          bonus: 0
          type: Bludgeoning
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Commoner
*Small, Humanoid, Neutral Neutral*

**AC** 10
**HP** 4 (1d8)
**Initiative** +0 (10)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common
CR 0, PB +2, XP 0

## Traits

**Training**
The commoner has proficiency in one skill of the DM's choice and has Advantage whenever it makes an ability check using that skill.

## Actions

**Club**
*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Bludgeoning damage.
`,
      "Monsters/copper-dragon-wyrmling.md": `---
smType: creature
name: Copper Dragon Wyrmling
size: Medium
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Good
ac: '16'
initiative: +3 (13)
hp: '22'
hitDice: 4d8 + 4
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 12
    saveProf: true
    saveMod: 3
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 14
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 2
  - key: cha
    score: 13
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '3'
sensesList:
  - type: blindsight
    range: '10'
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Draconic
damageImmunitiesList:
  - value: Acid
cr: '1'
xp: '200'
entries:
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d10
          bonus: 2
          type: Slashing
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Acid Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 11, each creature in a 20-foot-long, 5-foot-wide Line. *Failure:*  18 (4d8) Acid damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 11
      targeting:
        shape: line
        size: 20 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 18 (4d8) Acid damage.
        damage:
          - dice: 4d8
            bonus: 0
            type: Acid
            average: 18
        legacyEffects: 18 (4d8) Acid damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Slowing Breath
    entryType: save
    text: '*Constitution Saving Throw*: DC 11, each creature in a 15-foot Cone. *Failure:*  The target can''t take Reactions; its Speed is halved; and it can take either an action or a Bonus Action on its turn, not both. This effect lasts until the end of its next turn.'
    save:
      ability: con
      dc: 11
      targeting:
        shape: cone
        size: 15 ft.
      onFail:
        effects:
          mechanical:
            - type: penalty
              modifier: half
              target: Speed
              description: Speed is halved
            - type: other
              target: Reactions
              description: can't take Reactions
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Copper Dragon Wyrmling
*Medium, Dragon, Chaotic Good*

**AC** 16
**HP** 22 (4d8 + 4)
**Initiative** +3 (13)
**Speed** 30 ft., climb 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft., darkvision 60 ft.; Passive Perception 14
**Languages** Draconic
CR 1, PB +2, XP 200

## Actions

**Rend**
*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage.

**Acid Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 11, each creature in a 20-foot-long, 5-foot-wide Line. *Failure:*  18 (4d8) Acid damage. *Success:*  Half damage.

**Slowing Breath**
*Constitution Saving Throw*: DC 11, each creature in a 15-foot Cone. *Failure:*  The target can't take Reactions; its Speed is halved; and it can take either an action or a Bonus Action on its turn, not both. This effect lasts until the end of its next turn.
`,
      "Monsters/couatl.md": `---
smType: creature
name: Couatl
size: Medium
type: Celestial
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '19'
initiative: +5 (15)
hp: '60'
hitDice: 8d8 + 24
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 90 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 20
    saveProf: false
  - key: con
    score: 17
    saveProf: true
    saveMod: 5
  - key: int
    score: 18
    saveProf: false
  - key: wis
    score: 20
    saveProf: true
    saveMod: 7
  - key: cha
    score: 18
    saveProf: false
pb: '+2'
sensesList:
  - type: truesight
    range: '120'
passivesList:
  - skill: Perception
    value: '15'
languagesList:
  - value: All
  - value: telepathy 120 ft.
damageResistancesList:
  - value: Bludgeoning
  - value: Piercing
  - value: Slashing
damageImmunitiesList:
  - value: Psychic
  - value: Radiant
cr: '4'
xp: '1100'
entries:
  - category: trait
    name: Shielded Mind
    entryType: special
    text: The couatl's thoughts can't be read by any means, and other creatures can communicate with it telepathically only if it allows them.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 11 (1d12 + 5) Piercing damage, and the target has the Poisoned condition until the end of the couatl''s next turn.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 1d12
          bonus: 5
          type: Piercing
          average: 11
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Constrict
    entryType: save
    text: '*Strength Saving Throw*: DC 15, one Medium or smaller creature the couatl can see within 5 feet. *Failure:*  8 (1d6 + 5) Bludgeoning damage. The target has the Grappled condition (escape DC 13), and it has the Restrained condition until the grapple ends.'
    save:
      ability: str
      dc: 15
      targeting:
        type: single
        range: 5 ft.
        restrictions:
          size:
            - Medium
            - smaller
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Grappled
              escape:
                type: dc
                dc: 13
              duration:
                type: until
                trigger: the grapple ends
            - condition: Restrained
              escape:
                type: dc
                dc: 13
              duration:
                type: until
                trigger: the grapple ends
        damage:
          - dice: 1d6
            bonus: 5
            type: Bludgeoning
            average: 8
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The couatl casts one of the following spells, requiring no spell components and using Wisdom as the spellcasting ability (spell save DC 15): - **At Will:** *Detect Evil and Good*, *Detect Magic*, *Detect Thoughts*, *Shapechange* - **1e/Day Each:** *Create Food and Water*, *Dream*, *Greater Restoration*, *Scrying*, *Sleep*'
    spellcasting:
      ability: wis
      saveDC: 15
      spellLists:
        - frequency: at-will
          spells:
            - Detect Evil and Good
            - Detect Magic
            - Detect Thoughts
            - Shapechange
        - frequency: 1/day
          spells:
            - Create Food and Water
            - Dream
            - Greater Restoration
            - Scrying
            - Sleep
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Divine Aid (2/Day)
    entryType: spellcasting
    text: The couatl casts *Bless*, *Lesser Restoration*, or *Sanctuary*, requiring no spell components and using the same spellcasting ability as Spellcasting.
    limitedUse:
      count: 2
      reset: day
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Couatl
*Medium, Celestial, Lawful Good*

**AC** 19
**HP** 60 (8d8 + 24)
**Initiative** +5 (15)
**Speed** 30 ft., fly 90 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** truesight 120 ft.; Passive Perception 15
**Languages** All, telepathy 120 ft.
CR 4, PB +2, XP 1100

## Traits

**Shielded Mind**
The couatl's thoughts can't be read by any means, and other creatures can communicate with it telepathically only if it allows them.

## Actions

**Bite**
*Melee Attack Roll:* +7, reach 5 ft. 11 (1d12 + 5) Piercing damage, and the target has the Poisoned condition until the end of the couatl's next turn.

**Constrict**
*Strength Saving Throw*: DC 15, one Medium or smaller creature the couatl can see within 5 feet. *Failure:*  8 (1d6 + 5) Bludgeoning damage. The target has the Grappled condition (escape DC 13), and it has the Restrained condition until the grapple ends.

**Spellcasting**
The couatl casts one of the following spells, requiring no spell components and using Wisdom as the spellcasting ability (spell save DC 15): - **At Will:** *Detect Evil and Good*, *Detect Magic*, *Detect Thoughts*, *Shapechange* - **1e/Day Each:** *Create Food and Water*, *Dream*, *Greater Restoration*, *Scrying*, *Sleep*

## Bonus Actions

**Divine Aid (2/Day)**
The couatl casts *Bless*, *Lesser Restoration*, or *Sanctuary*, requiring no spell components and using the same spellcasting ability as Spellcasting.
`,
      "Monsters/cultist-fanatic.md": `---
smType: creature
name: Cultist Fanatic
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '13'
initiative: +2 (12)
hp: '44'
hitDice: 8d8 + 8
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 11
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 14
    saveProf: true
    saveMod: 4
  - key: cha
    score: 13
    saveProf: false
pb: '+2'
skills:
  - skill: Deception
    value: '3'
  - skill: Persuasion
    value: '3'
  - skill: Religion
    value: '2'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Common
cr: '2'
xp: '450'
entries:
  - category: action
    name: Pact Blade
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Slashing damage plus 7 (2d6) Necrotic damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d8
          bonus: 2
          type: Slashing
          average: 6
        - dice: 2d6
          bonus: 0
          type: Necrotic
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The cultist casts one of the following spells, using Wisdom as the spellcasting ability (spell save DC 12, +4 to hit with spell attacks): - **At Will:** *Light*, *Thaumaturgy* - **1/Day Each:** *Hold Person* - **2/Day Each:** *Command*'
    spellcasting:
      ability: wis
      saveDC: 12
      attackBonus: 4
      spellLists:
        - frequency: at-will
          spells:
            - Light
            - Thaumaturgy
        - frequency: 1/day
          spells:
            - Hold Person
        - frequency: 2/day
          spells:
            - Command
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Spiritual Weapon (2/Day)
    entryType: spellcasting
    text: The cultist casts the *Spiritual Weapon* spell, using the same spellcasting ability as Spellcasting.
    limitedUse:
      count: 2
      reset: day
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Cultist Fanatic
*Small, Humanoid, Neutral Neutral*

**AC** 13
**HP** 44 (8d8 + 8)
**Initiative** +2 (12)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common
CR 2, PB +2, XP 450

## Actions

**Pact Blade**
*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Slashing damage plus 7 (2d6) Necrotic damage.

**Spellcasting**
The cultist casts one of the following spells, using Wisdom as the spellcasting ability (spell save DC 12, +4 to hit with spell attacks): - **At Will:** *Light*, *Thaumaturgy* - **1/Day Each:** *Hold Person* - **2/Day Each:** *Command*

## Bonus Actions

**Spiritual Weapon (2/Day)**
The cultist casts the *Spiritual Weapon* spell, using the same spellcasting ability as Spellcasting.
`,
      "Monsters/cultist.md": `---
smType: creature
name: Cultist
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '12'
initiative: +1 (11)
hp: '9'
hitDice: 2d8
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 11
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 2
  - key: cha
    score: 10
    saveProf: false
pb: '+2'
skills:
  - skill: Deception
    value: '2'
  - skill: Religion
    value: '2'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common
cr: 1/8
xp: '25'
entries:
  - category: action
    name: Ritual Sickle
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 3 (1d4 + 1) Slashing damage plus 1 Necrotic damage.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 1d4
          bonus: 1
          type: Slashing
          average: 3
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Cultist
*Small, Humanoid, Neutral Neutral*

**AC** 12
**HP** 9 (2d8)
**Initiative** +1 (11)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common
CR 1/8, PB +2, XP 25

## Actions

**Ritual Sickle**
*Melee Attack Roll:* +3, reach 5 ft. 3 (1d4 + 1) Slashing damage plus 1 Necrotic damage.
`,
      "Monsters/darkmantle.md": `---
smType: creature
name: Darkmantle
size: Small
type: Aberration
alignmentOverride: Unaligned
ac: '11'
initiative: +3 (13)
hp: '22'
hitDice: 5d6 + 5
speeds:
  walk:
    distance: 10 ft.
  fly:
    distance: 30 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '3'
sensesList:
  - type: blindsight
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
cr: 1/2
xp: '100'
entries:
  - category: action
    name: Crush
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage, and the darkmantle attaches to the target. If the target is a Medium or smaller creature and the darkmantle had Advantage on the attack roll, it covers the target, which has the Blinded condition and is suffocating while the darkmantle is attached in this way. While attached to a target, the darkmantle can attack only the target but has Advantage on its attack rolls. Its Speed becomes 0, it can''t benefit from any bonus to its Speed, and it moves with the target. A creature can take an action to try to detach the darkmantle from itself, doing so with a successful DC 13 Strength (Athletics) check. On its turn, the darkmantle can detach itself by using 5 feet of movement.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d6
          bonus: 3
          type: Bludgeoning
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Darkness Aura (1/Day)
    entryType: special
    text: Magical darkness fills a 15-foot Emanation originating from the darkmantle. This effect lasts while the darkmantle maintains  Concentration on it, up to 10 minutes. Darkvision can't penetrate this area, and no light can illuminate it.
    limitedUse:
      count: 1
      reset: day
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Darkmantle
*Small, Aberration, Unaligned*

**AC** 11
**HP** 22 (5d6 + 5)
**Initiative** +3 (13)
**Speed** 10 ft., fly 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft.; Passive Perception 10
CR 1/2, PB +2, XP 100

## Actions

**Crush**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage, and the darkmantle attaches to the target. If the target is a Medium or smaller creature and the darkmantle had Advantage on the attack roll, it covers the target, which has the Blinded condition and is suffocating while the darkmantle is attached in this way. While attached to a target, the darkmantle can attack only the target but has Advantage on its attack rolls. Its Speed becomes 0, it can't benefit from any bonus to its Speed, and it moves with the target. A creature can take an action to try to detach the darkmantle from itself, doing so with a successful DC 13 Strength (Athletics) check. On its turn, the darkmantle can detach itself by using 5 feet of movement.

**Darkness Aura (1/Day)**
Magical darkness fills a 15-foot Emanation originating from the darkmantle. This effect lasts while the darkmantle maintains  Concentration on it, up to 10 minutes. Darkvision can't penetrate this area, and no light can illuminate it.
`,
      "Monsters/death-dog.md": `---
smType: creature
name: Death Dog
size: Medium
type: Monstrosity
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '12'
initiative: +2 (12)
hp: '39'
hitDice: 6d8 + 12
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
  - skill: Stealth
    value: '4'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '15'
conditionImmunitiesList:
  - value: Blinded
  - value: Charmed
  - value: Deafened
  - value: Frightened
  - value: Stunned
  - value: Unconscious
cr: '1'
xp: '200'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The death dog makes two Bite attacks.
    multiattack:
      attacks:
        - name: Bite
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage. If the target is a creature, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *First Failure* The target has the Poisoned condition. While Poisoned, the target''s Hit Point maximum doesn''t return to normal when finishing a Long Rest, and it repeats the save every 24 hours that elapse, ending the effect on itself on a success. Subsequent Failures: The Poisoned target''s Hit Point maximum decreases by 5 (1d10).'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d4
          bonus: 2
          type: Piercing
          average: 4
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Poisoned
            saveToEnd:
              timing: when-damage
      additionalEffects: 'If the target is a creature, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *First Failure* The target has the Poisoned condition. While Poisoned, the target''s Hit Point maximum doesn''t return to normal when finishing a Long Rest, and it repeats the save every 24 hours that elapse, ending the effect on itself on a success. Subsequent Failures: The Poisoned target''s Hit Point maximum decreases by 5 (1d10).'
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Death Dog
*Medium, Monstrosity, Neutral Evil*

**AC** 12
**HP** 39 (6d8 + 12)
**Initiative** +2 (12)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 15
CR 1, PB +2, XP 200

## Actions

**Multiattack**
The death dog makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage. If the target is a creature, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *First Failure* The target has the Poisoned condition. While Poisoned, the target's Hit Point maximum doesn't return to normal when finishing a Long Rest, and it repeats the save every 24 hours that elapse, ending the effect on itself on a success. Subsequent Failures: The Poisoned target's Hit Point maximum decreases by 5 (1d10).
`,
      "Monsters/deva.md": `---
smType: creature
name: Deva
size: Medium
type: Celestial
typeTags:
  - value: Angel
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '17'
initiative: +4 (14)
hp: '229'
hitDice: 27d8 + 108
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 90 ft.
    hover: true
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 18
    saveProf: false
  - key: con
    score: 18
    saveProf: false
  - key: int
    score: 17
    saveProf: false
  - key: wis
    score: 20
    saveProf: true
    saveMod: 9
  - key: cha
    score: 20
    saveProf: true
    saveMod: 9
pb: '+4'
skills:
  - skill: Insight
    value: '9'
  - skill: Perception
    value: '9'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '19'
languagesList:
  - value: All
  - value: telepathy 120 ft.
damageResistancesList:
  - value: Radiant
damageImmunitiesList:
  - value: Exhaustion
conditionImmunitiesList:
  - value: Charmed
  - value: Frightened
cr: '10'
xp: '5900'
entries:
  - category: trait
    name: Exalted Restoration
    entryType: special
    text: If the deva dies outside Mount Celestia, its body disappears, and it gains a new body instantly, reviving with all its Hit Points somewhere in Mount Celestia.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The deva has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The deva makes two Holy Mace attacks.
    multiattack:
      attacks:
        - name: Mace
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Holy Mace
    entryType: attack
    text: '*Melee Attack Roll:* +8, reach 5 ft. 7 (1d6 + 4) Bludgeoning damage plus 18 (4d8) Radiant damage.'
    attack:
      type: melee
      bonus: 8
      damage:
        - dice: 1d6
          bonus: 4
          type: Bludgeoning
          average: 7
        - dice: 4d8
          bonus: 0
          type: Radiant
          average: 18
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The deva casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Evil and Good*, *Shapechange* - **1e/Day Each:** *Commune*, *Raise Dead*'
    spellcasting:
      ability: cha
      saveDC: 17
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Evil and Good
            - Shapechange
        - frequency: 1/day
          spells:
            - Commune
            - Raise Dead
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Divine Aid (2/Day)
    entryType: spellcasting
    text: The deva casts *Cure Wounds*, *Lesser Restoration*, or *Remove Curse*, using the same spellcasting ability as Spellcasting.
    limitedUse:
      count: 2
      reset: day
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Deva
*Medium, Celestial, Lawful Good*

**AC** 17
**HP** 229 (27d8 + 108)
**Initiative** +4 (14)
**Speed** 30 ft., fly 90 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 19
**Languages** All, telepathy 120 ft.
CR 10, PB +4, XP 5900

## Traits

**Exalted Restoration**
If the deva dies outside Mount Celestia, its body disappears, and it gains a new body instantly, reviving with all its Hit Points somewhere in Mount Celestia.

**Magic Resistance**
The deva has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The deva makes two Holy Mace attacks.

**Holy Mace**
*Melee Attack Roll:* +8, reach 5 ft. 7 (1d6 + 4) Bludgeoning damage plus 18 (4d8) Radiant damage.

**Spellcasting**
The deva casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Evil and Good*, *Shapechange* - **1e/Day Each:** *Commune*, *Raise Dead*

## Bonus Actions

**Divine Aid (2/Day)**
The deva casts *Cure Wounds*, *Lesser Restoration*, or *Remove Curse*, using the same spellcasting ability as Spellcasting.
`,
      "Monsters/djinni.md": `---
smType: creature
name: Djinni
size: Large
type: Elemental
typeTags:
  - value: Genie
alignmentLawChaos: Chaotic
alignmentGoodEvil: Good
ac: '17'
initiative: +2 (12)
hp: '218'
hitDice: 19d10 + 114
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 90 ft.
    hover: true
abilities:
  - key: str
    score: 21
    saveProf: false
  - key: dex
    score: 15
    saveProf: true
    saveMod: 6
  - key: con
    score: 22
    saveProf: false
  - key: int
    score: 15
    saveProf: false
  - key: wis
    score: 16
    saveProf: true
    saveMod: 7
  - key: cha
    score: 20
    saveProf: false
pb: '+4'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '13'
languagesList:
  - value: Primordial (Auran)
damageImmunitiesList:
  - value: Lightning
  - value: Thunder
cr: '11'
xp: '7200'
entries:
  - category: trait
    name: Elemental Restoration
    entryType: special
    text: If the djinni dies outside the Elemental Plane of Air, its body dissolves into mist, and it gains a new body in 1d4 days, reviving with all its Hit Points somewhere on the Plane of Air.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The djinni has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Wishes
    entryType: special
    text: The djinni has a 30 percent chance of knowing the *Wish* spell. If the djinni knows it, the djinni can cast it only on behalf of a non-genie creature who communicates a wish in a way the djinni can understand. If the djinni casts the spell for the creature, the djinni suffers none of the spell's stress. Once the djinni has cast it three times, the djinni can't do so again for 365 days.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: special
    text: The djinni makes three attacks, using Storm Blade or Storm Bolt in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Storm Blade
    entryType: attack
    text: '*Melee Attack Roll:* +9, reach 5 feet. 12 (2d6 + 5) Slashing damage plus 7 (2d6) Lightning damage.'
    attack:
      type: melee
      bonus: 9
      damage:
        - dice: 2d6
          bonus: 5
          type: Slashing
          average: 12
        - dice: 2d6
          bonus: 0
          type: Lightning
          average: 7
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Storm Bolt
    entryType: attack
    text: '*Ranged Attack Roll:* +9, range 120 feet. 13 (3d8) Thunder damage. If the target is a Large or smaller creature, it has the Prone condition.'
    attack:
      type: ranged
      bonus: 9
      damage:
        - dice: 3d8
          bonus: 0
          type: Thunder
          average: 13
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Create Whirlwind
    entryType: save
    text: 'The djinni conjures a whirlwind at a point it can see within 120 feet. The whirlwind fills a 20-foot-radius, 60-foot-high Cylinder [Area of Effect]|XPHB|Cylinder centered on that point. The whirlwind lasts until the djinni''s  Concentration on it ends. The djinni can move the whirlwind up to 20 feet at the start of each of its turns. Whenever the whirlwind enters a creature''s space or a creature enters the whirlwind, that creature is subjected to the following effect. *Strength Saving Throw*: DC 17 (a creature makes this save only once per turn, and the djinni is unaffected). *Failure:*  While in the whirlwind, the target has the Restrained condition and moves with the whirlwind. At the start of each of its turns, the Restrained target takes 21 (6d6) Thunder damage. At the end of each of its turns, the target repeats the save, ending the effect on itself on a success.'
    save:
      ability: str
      dc: 17
      onFail:
        effects:
          conditions:
            - condition: Restrained
              saveToEnd:
                timing: end-of-turn
        damage:
          - dice: 6d6
            bonus: 0
            type: Thunder
            average: 21
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The djinni casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Evil and Good*, *Detect Magic* - **2e/Day Each:** *Create Food and Water*, *Tongues*, *Wind Walk* - **1e/Day Each:** *Creation*, *Gaseous Form*, *Invisibility*, *Major Image*, *Plane Shift*'
    spellcasting:
      ability: cha
      saveDC: 17
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Evil and Good
            - Detect Magic
        - frequency: 2/day
          spells:
            - Create Food and Water
            - Tongues
            - Wind Walk
        - frequency: 1/day
          spells:
            - Creation
            - Gaseous Form
            - Invisibility
            - Major Image
            - Plane Shift
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Djinni
*Large, Elemental, Chaotic Good*

**AC** 17
**HP** 218 (19d10 + 114)
**Initiative** +2 (12)
**Speed** 30 ft., fly 90 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 13
**Languages** Primordial (Auran)
CR 11, PB +4, XP 7200

## Traits

**Elemental Restoration**
If the djinni dies outside the Elemental Plane of Air, its body dissolves into mist, and it gains a new body in 1d4 days, reviving with all its Hit Points somewhere on the Plane of Air.

**Magic Resistance**
The djinni has Advantage on saving throws against spells and other magical effects.

**Wishes**
The djinni has a 30 percent chance of knowing the *Wish* spell. If the djinni knows it, the djinni can cast it only on behalf of a non-genie creature who communicates a wish in a way the djinni can understand. If the djinni casts the spell for the creature, the djinni suffers none of the spell's stress. Once the djinni has cast it three times, the djinni can't do so again for 365 days.

## Actions

**Multiattack**
The djinni makes three attacks, using Storm Blade or Storm Bolt in any combination.

**Storm Blade**
*Melee Attack Roll:* +9, reach 5 feet. 12 (2d6 + 5) Slashing damage plus 7 (2d6) Lightning damage.

**Storm Bolt**
*Ranged Attack Roll:* +9, range 120 feet. 13 (3d8) Thunder damage. If the target is a Large or smaller creature, it has the Prone condition.

**Create Whirlwind**
The djinni conjures a whirlwind at a point it can see within 120 feet. The whirlwind fills a 20-foot-radius, 60-foot-high Cylinder [Area of Effect]|XPHB|Cylinder centered on that point. The whirlwind lasts until the djinni's  Concentration on it ends. The djinni can move the whirlwind up to 20 feet at the start of each of its turns. Whenever the whirlwind enters a creature's space or a creature enters the whirlwind, that creature is subjected to the following effect. *Strength Saving Throw*: DC 17 (a creature makes this save only once per turn, and the djinni is unaffected). *Failure:*  While in the whirlwind, the target has the Restrained condition and moves with the whirlwind. At the start of each of its turns, the Restrained target takes 21 (6d6) Thunder damage. At the end of each of its turns, the target repeats the save, ending the effect on itself on a success.

**Spellcasting**
The djinni casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Evil and Good*, *Detect Magic* - **2e/Day Each:** *Create Food and Water*, *Tongues*, *Wind Walk* - **1e/Day Each:** *Creation*, *Gaseous Form*, *Invisibility*, *Major Image*, *Plane Shift*
`,
      "Monsters/doppelganger.md": `---
smType: creature
name: Doppelganger
size: Medium
type: Monstrosity
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '14'
initiative: +4 (14)
hp: '52'
hitDice: 8d8 + 16
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 11
    saveProf: false
  - key: dex
    score: 18
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 11
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 14
    saveProf: false
pb: '+2'
skills:
  - skill: Deception
    value: '6'
  - skill: Insight
    value: '3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Common plus three other languages
conditionImmunitiesList:
  - value: Charmed
cr: '3'
xp: '700'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The doppelganger makes two Slam attacks and uses Unsettling Visage if available.
    multiattack:
      attacks:
        - name: Slam
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Slam
    entryType: attack
    text: '*Melee Attack Roll:* +6 (with Advantage during the first round of each combat), reach 5 ft. 11 (2d6 + 4) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d6
          bonus: 4
          type: Bludgeoning
          average: 11
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Unsettling Visage
    entryType: save
    text: '*Wisdom Saving Throw*: DC 12, each creature in a 15-foot Emanation originating from the doppelganger that can see the doppelganger. *Failure:*  The target has the Frightened condition and repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.'
    save:
      ability: wis
      dc: 12
      targeting:
        shape: emanation
        size: 15 ft.
        origin: self
      onFail:
        effects:
          conditions:
            - condition: Frightened
              saveToEnd:
                timing: end-of-turn
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Shape-Shift
    entryType: special
    text: The doppelganger shape-shifts into a Medium or Small Humanoid, or it returns to its true form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
    trigger.activation: bonus
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Read Thoughts
    entryType: spellcasting
    text: The doppelganger casts *Detect Thoughts*, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 12). - **At Will:** *Detect Thoughts*
    spellcasting:
      ability: cha
      saveDC: 12
      spellLists:
        - frequency: at-will
          spells:
            - Detect Thoughts
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Doppelganger
*Medium, Monstrosity, Neutral Neutral*

**AC** 14
**HP** 52 (8d8 + 16)
**Initiative** +4 (14)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 11
**Languages** Common plus three other languages
CR 3, PB +2, XP 700

## Actions

**Multiattack**
The doppelganger makes two Slam attacks and uses Unsettling Visage if available.

**Slam**
*Melee Attack Roll:* +6 (with Advantage during the first round of each combat), reach 5 ft. 11 (2d6 + 4) Bludgeoning damage.

**Unsettling Visage (Recharge 6)**
*Wisdom Saving Throw*: DC 12, each creature in a 15-foot Emanation originating from the doppelganger that can see the doppelganger. *Failure:*  The target has the Frightened condition and repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.

**Read Thoughts**
The doppelganger casts *Detect Thoughts*, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 12). - **At Will:** *Detect Thoughts*

## Bonus Actions

**Shape-Shift**
The doppelganger shape-shifts into a Medium or Small Humanoid, or it returns to its true form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
`,
      "Monsters/dragon-turtle.md": `---
smType: creature
name: Dragon Turtle
size: Gargantuan
type: Dragon
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '20'
initiative: +6 (16)
hp: '356'
hitDice: 23d20 + 115
speeds:
  walk:
    distance: 20 ft.
  swim:
    distance: 50 ft.
abilities:
  - key: str
    score: 25
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 20
    saveProf: true
    saveMod: 11
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 12
    saveProf: true
    saveMod: 7
  - key: cha
    score: 12
    saveProf: false
pb: '+6'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Draconic
  - value: Primordial (Aquan)
damageResistancesList:
  - value: Fire
cr: '17'
xp: '18000'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Bite attacks. It can replace one attack with a Tail attack.
    multiattack:
      attacks:
        - name: Bite
          count: 3
      substitutions:
        - replace: attack
          with:
            type: attack
            name: a Tail attack
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +13, reach 15 ft. 23 (3d10 + 7) Piercing damage plus 7 (2d6) Fire damage. Being underwater doesn''t grant Resistance to this Fire damage.'
    attack:
      type: melee
      bonus: 13
      damage:
        - dice: 3d10
          bonus: 7
          type: Piercing
          average: 23
        - dice: 2d6
          bonus: 0
          type: Fire
          average: 7
      reach: 15 ft.
      onHit:
        other: Being underwater doesn't grant Resistance to this Fire damage.
      additionalEffects: Being underwater doesn't grant Resistance to this Fire damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Tail
    entryType: attack
    text: '*Melee Attack Roll:* +13, reach 15 ft. 18 (2d10 + 7) Bludgeoning damage. If the target is a Huge or smaller creature, it has the Prone condition.'
    attack:
      type: melee
      bonus: 13
      damage:
        - dice: 2d10
          bonus: 7
          type: Bludgeoning
          average: 18
      reach: 15 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Huge or smaller
      additionalEffects: If the target is a Huge or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Steam Breath (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 19, each creature in a 60-foot Cone. *Failure:*  56 (16d6) Fire damage. *Success:*  Half damage. *Failure or Success*:  Being underwater doesn''t grant Resistance to this Fire damage.'
    recharge: 5-6
    save:
      ability: con
      dc: 19
      targeting:
        shape: cone
        size: 60 ft.
      onFail:
        effects:
          other: 56 (16d6) Fire damage.
        damage:
          - dice: 16d6
            bonus: 0
            type: Fire
            average: 56
        legacyEffects: 56 (16d6) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Dragon Turtle
*Gargantuan, Dragon, Neutral Neutral*

**AC** 20
**HP** 356 (23d20 + 115)
**Initiative** +6 (16)
**Speed** 20 ft., swim 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 11
**Languages** Draconic, Primordial (Aquan)
CR 17, PB +6, XP 18000

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes three Bite attacks. It can replace one attack with a Tail attack.

**Bite**
*Melee Attack Roll:* +13, reach 15 ft. 23 (3d10 + 7) Piercing damage plus 7 (2d6) Fire damage. Being underwater doesn't grant Resistance to this Fire damage.

**Tail**
*Melee Attack Roll:* +13, reach 15 ft. 18 (2d10 + 7) Bludgeoning damage. If the target is a Huge or smaller creature, it has the Prone condition.

**Steam Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 19, each creature in a 60-foot Cone. *Failure:*  56 (16d6) Fire damage. *Success:*  Half damage. *Failure or Success*:  Being underwater doesn't grant Resistance to this Fire damage.
`,
      "Monsters/dretch.md": `---
smType: creature
name: Dretch
size: Small
type: Fiend
typeTags:
  - value: Demon
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '11'
initiative: +0 (10)
hp: '18'
hitDice: 4d6 + 4
speeds:
  walk:
    distance: 20 ft.
abilities:
  - key: str
    score: 12
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 5
    saveProf: false
  - key: wis
    score: 8
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '9'
languagesList:
  - value: Abyssal
  - value: telepathy 60 ft. (works only with creatures that understand Abyssal)
damageResistancesList:
  - value: Cold
  - value: Fire
  - value: Lightning
damageImmunitiesList:
  - value: Poison; Poisoned
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Slashing damage.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 1d6
          bonus: 1
          type: Slashing
          average: 4
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fetid Cloud (1/Day)
    entryType: save
    text: '*Constitution Saving Throw*: DC 11, each creature in a 10-foot Emanation originating from the dretch. *Failure:*  The target has the Poisoned condition until the end of its next turn. While Poisoned, the creature can take either an action or a Bonus Action on its turn, not both, and it can''t take Reactions.'
    limitedUse:
      count: 1
      reset: day
    save:
      ability: con
      dc: 11
      targeting:
        shape: emanation
        size: 10 ft.
        origin: self
      onFail:
        effects:
          conditions:
            - condition: Poisoned
              duration:
                type: until
                trigger: the end of its next turn
          mechanical:
            - type: other
              target: Reactions
              description: can't take Reactions
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Dretch
*Small, Fiend, Chaotic Evil*

**AC** 11
**HP** 18 (4d6 + 4)
**Initiative** +0 (10)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 9
**Languages** Abyssal, telepathy 60 ft. (works only with creatures that understand Abyssal)
CR 1/4, PB +2, XP 50

## Actions

**Rend**
*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Slashing damage.

**Fetid Cloud (1/Day)**
*Constitution Saving Throw*: DC 11, each creature in a 10-foot Emanation originating from the dretch. *Failure:*  The target has the Poisoned condition until the end of its next turn. While Poisoned, the creature can take either an action or a Bonus Action on its turn, not both, and it can't take Reactions.
`,
      "Monsters/drider.md": `---
smType: creature
name: Drider
size: Large
type: Monstrosity
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '19'
initiative: +4 (14)
hp: '123'
hitDice: 13d10 + 52
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 19
    saveProf: false
  - key: con
    score: 18
    saveProf: false
  - key: int
    score: 13
    saveProf: false
  - key: wis
    score: 16
    saveProf: false
  - key: cha
    score: 12
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '6'
  - skill: Stealth
    value: '10'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '16'
languagesList:
  - value: Elvish
  - value: Undercommon
cr: '6'
xp: '2300'
entries:
  - category: trait
    name: Spider Climb
    entryType: special
    text: The drider can climb difficult surfaces, including along ceilings, without needing to make an ability check.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Sunlight Sensitivity
    entryType: special
    text: While in sunlight, the drider has Disadvantage on ability checks and attack rolls.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Web Walker
    entryType: special
    text: The drider ignores movement restrictions caused by webs, and the drider knows the location of any other creature in contact with the same web.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: special
    text: The drider makes three attacks, using Foreleg or Poison Burst in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Foreleg
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 10 ft. 13 (2d8 + 4) Piercing damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d8
          bonus: 4
          type: Piercing
          average: 13
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Poison Burst
    entryType: attack
    text: '*Ranged Attack Roll:* +6, range 120 ft. 13 (3d6 + 3) Poison damage.'
    attack:
      type: ranged
      bonus: 6
      damage:
        - dice: 3d6
          bonus: 3
          type: Poison
          average: 13
      range: 120 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: bonus
    name: Magic of the Spider Queen (Recharge 5-6)
    entryType: spellcasting
    text: The drider casts *Darkness*, *Faerie Fire*, or *Web*, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 14).
    recharge: 5-6
    spellcasting:
      ability: wis
      saveDC: 14
      excludeComponents:
        - M
      spellLists: []
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Drider
*Large, Monstrosity, Chaotic Evil*

**AC** 19
**HP** 123 (13d10 + 52)
**Initiative** +4 (14)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 16
**Languages** Elvish, Undercommon
CR 6, PB +3, XP 2300

## Traits

**Spider Climb**
The drider can climb difficult surfaces, including along ceilings, without needing to make an ability check.

**Sunlight Sensitivity**
While in sunlight, the drider has Disadvantage on ability checks and attack rolls.

**Web Walker**
The drider ignores movement restrictions caused by webs, and the drider knows the location of any other creature in contact with the same web.

## Actions

**Multiattack**
The drider makes three attacks, using Foreleg or Poison Burst in any combination.

**Foreleg**
*Melee Attack Roll:* +7, reach 10 ft. 13 (2d8 + 4) Piercing damage.

**Poison Burst**
*Ranged Attack Roll:* +6, range 120 ft. 13 (3d6 + 3) Poison damage.

## Bonus Actions

**Magic of the Spider Queen (Recharge 5-6)**
The drider casts *Darkness*, *Faerie Fire*, or *Web*, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 14).
`,
      "Monsters/druid.md": `---
smType: creature
name: Druid
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '13'
initiative: +1 (11)
hp: '44'
hitDice: 8d8 + 8
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 16
    saveProf: false
  - key: cha
    score: 11
    saveProf: false
pb: '+2'
skills:
  - skill: Medicine
    value: '5'
  - skill: Nature
    value: '3'
  - skill: Perception
    value: '5'
passivesList:
  - skill: Perception
    value: '15'
languagesList:
  - value: Common
  - value: Druidic
  - value: Sylvan
cr: '2'
xp: '450'
entries:
  - category: action
    name: Multiattack
    entryType: special
    text: The druid makes two attacks, using Vine Staff or Verdant Wisp in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Vine Staff
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Bludgeoning damage plus 2 (1d4) Poison damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d8
          bonus: 3
          type: Bludgeoning
          average: 7
        - dice: 1d4
          bonus: 0
          type: Poison
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Verdant Wisp
    entryType: attack
    text: '*Ranged Attack Roll:* +5, range 90 ft. 10 (3d6) Radiant damage.'
    attack:
      type: ranged
      bonus: 5
      damage:
        - dice: 3d6
          bonus: 0
          type: Radiant
          average: 10
      range: 90 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The druid casts one of the following spells, using Wisdom as the spellcasting ability (spell save DC 13): - **At Will:** *Druidcraft*, *Speak with Animals* - **2e/Day Each:** *Entangle*, *Thunderwave* - **1e/Day Each:** *Animal Messenger*, *Longstrider*, *Moonbeam*'
    spellcasting:
      ability: wis
      saveDC: 13
      spellLists:
        - frequency: at-will
          spells:
            - Druidcraft
            - Speak with Animals
        - frequency: 2/day
          spells:
            - Entangle
            - Thunderwave
        - frequency: 1/day
          spells:
            - Animal Messenger
            - Longstrider
            - Moonbeam
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Druid
*Small, Humanoid, Neutral Neutral*

**AC** 13
**HP** 44 (8d8 + 8)
**Initiative** +1 (11)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common, Druidic, Sylvan
CR 2, PB +2, XP 450

## Actions

**Multiattack**
The druid makes two attacks, using Vine Staff or Verdant Wisp in any combination.

**Vine Staff**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Bludgeoning damage plus 2 (1d4) Poison damage.

**Verdant Wisp**
*Ranged Attack Roll:* +5, range 90 ft. 10 (3d6) Radiant damage.

**Spellcasting**
The druid casts one of the following spells, using Wisdom as the spellcasting ability (spell save DC 13): - **At Will:** *Druidcraft*, *Speak with Animals* - **2e/Day Each:** *Entangle*, *Thunderwave* - **1e/Day Each:** *Animal Messenger*, *Longstrider*, *Moonbeam*
`,
      "Monsters/dryad.md": `---
smType: creature
name: Dryad
size: Medium
type: Fey
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '16'
initiative: +1 (11)
hp: '22'
hitDice: 5d8
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 14
    saveProf: false
  - key: wis
    score: 15
    saveProf: false
  - key: cha
    score: 18
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Elvish
  - value: Sylvan
cr: '1'
xp: '200'
entries:
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The dryad has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Speak with Beasts and Plants
    entryType: special
    text: The dryad can communicate with Beasts and Plants as if they shared a language.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dryad makes one Vine Lash or Thorn Burst attack, and it can use Spellcasting to cast *Charm Monster*.
    multiattack:
      attacks:
        - name: Burst
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Vine Lash
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 10 ft. 8 (1d8 + 4) Slashing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d8
          bonus: 4
          type: Slashing
          average: 8
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Thorn Burst
    entryType: attack
    text: '*Ranged Attack Roll:* +6, range 60 ft. 7 (1d6 + 4) Piercing damage.'
    attack:
      type: ranged
      bonus: 6
      damage:
        - dice: 1d6
          bonus: 4
          type: Piercing
          average: 7
      range: 60 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Tree Stride
    entryType: special
    text: If within 5 feet of a Large or bigger tree, the dryad teleports to an unoccupied space within 5 feet of a second Large or bigger tree that is within 60 feet of the previous tree.
    trigger.activation: bonus
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The dryad casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 14): - **At Will:** *Animal Friendship*, *Charm Monster*, *Druidcraft* - **1e/Day Each:** *Entangle*, *Pass without Trace*'
    spellcasting:
      ability: cha
      saveDC: 14
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Animal Friendship
            - Charm Monster
            - Druidcraft
        - frequency: 1/day
          spells:
            - Entangle
            - Pass without Trace
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Dryad
*Medium, Fey, Neutral Neutral*

**AC** 16
**HP** 22 (5d8)
**Initiative** +1 (11)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 14
**Languages** Elvish, Sylvan
CR 1, PB +2, XP 200

## Traits

**Magic Resistance**
The dryad has Advantage on saving throws against spells and other magical effects.

**Speak with Beasts and Plants**
The dryad can communicate with Beasts and Plants as if they shared a language.

## Actions

**Multiattack**
The dryad makes one Vine Lash or Thorn Burst attack, and it can use Spellcasting to cast *Charm Monster*.

**Vine Lash**
*Melee Attack Roll:* +6, reach 10 ft. 8 (1d8 + 4) Slashing damage.

**Thorn Burst**
*Ranged Attack Roll:* +6, range 60 ft. 7 (1d6 + 4) Piercing damage.

**Spellcasting**
The dryad casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 14): - **At Will:** *Animal Friendship*, *Charm Monster*, *Druidcraft* - **1e/Day Each:** *Entangle*, *Pass without Trace*

## Bonus Actions

**Tree Stride**
If within 5 feet of a Large or bigger tree, the dryad teleports to an unoccupied space within 5 feet of a second Large or bigger tree that is within 60 feet of the previous tree.
`,
      "Monsters/dust-mephit.md": `---
smType: creature
name: Dust Mephit
size: Small
type: Elemental
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '12'
initiative: +2 (12)
hp: '17'
hitDice: 5d6
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 30 ft.
abilities:
  - key: str
    score: 5
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 9
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 10
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '2'
  - skill: Stealth
    value: '4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Primordial (Auran
  - value: Terran)
damageVulnerabilitiesList:
  - value: Fire
damageImmunitiesList:
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Poisoned
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Death Burst
    entryType: save
    text: 'The mephit explodes when it dies. *Dexterity Saving Throw*: DC 10, each creature in a 5-foot Emanation originating from the mephit. *Failure:*  5 (2d4) Bludgeoning damage. *Success:*  Half damage.'
    save:
      ability: dex
      dc: 10
      targeting:
        shape: emanation
        size: 5 ft.
        origin: self
      onFail:
        effects:
          other: 5 (2d4) Bludgeoning damage.
        damage:
          - dice: 2d4
            bonus: 0
            type: Bludgeoning
            average: 5
        legacyEffects: 5 (2d4) Bludgeoning damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Slashing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d4
          bonus: 2
          type: Slashing
          average: 4
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Blinding Breath
    entryType: save
    text: '*Dexterity Saving Throw*: DC 10, each creature in a 15-foot Cone. *Failure:*  The target has the Blinded condition until the end of the mephit''s next turn.'
    save:
      ability: dex
      dc: 10
      targeting:
        shape: cone
        size: 15 ft.
      onFail:
        effects:
          conditions:
            - condition: Blinded
              duration:
                type: until
                trigger: the end of the mephit's next turn
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Sleep (1/Day)
    entryType: spellcasting
    text: The mephit casts the *Sleep* spell, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 10). - **At Will:** - **1/Day Each:** *Sleep*
    limitedUse:
      count: 1
      reset: day
    spellcasting:
      ability: cha
      saveDC: 10
      spellLists:
        - frequency: at-will
          spells:
            - '- 1/Day Each: Sleep'
        - frequency: 1/day
          spells:
            - Sleep
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Dust Mephit
*Small, Elemental, Neutral Evil*

**AC** 12
**HP** 17 (5d6)
**Initiative** +2 (12)
**Speed** 30 ft., fly 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 12
**Languages** Primordial (Auran, Terran)
CR 1/2, PB +2, XP 100

## Traits

**Death Burst**
The mephit explodes when it dies. *Dexterity Saving Throw*: DC 10, each creature in a 5-foot Emanation originating from the mephit. *Failure:*  5 (2d4) Bludgeoning damage. *Success:*  Half damage.

## Actions

**Claw**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Slashing damage.

**Blinding Breath (Recharge 6)**
*Dexterity Saving Throw*: DC 10, each creature in a 15-foot Cone. *Failure:*  The target has the Blinded condition until the end of the mephit's next turn.

**Sleep (1/Day)**
The mephit casts the *Sleep* spell, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 10). - **At Will:** - **1/Day Each:** *Sleep*
`,
      "Monsters/earth-elemental.md": `---
smType: creature
name: Earth Elemental
size: Large
type: Elemental
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '17'
initiative: '-1 (9)'
hp: '147'
hitDice: 14d10 + 70
speeds:
  walk:
    distance: 30 ft.
  burrow:
    distance: 30 ft.
abilities:
  - key: str
    score: 20
    saveProf: false
  - key: dex
    score: 8
    saveProf: false
  - key: con
    score: 20
    saveProf: false
  - key: int
    score: 5
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+3'
sensesList:
  - type: darkvision
    range: '60'
  - type: tremorsense
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Primordial (Terran)
damageVulnerabilitiesList:
  - value: Thunder
damageImmunitiesList:
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
  - value: Unconscious
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Earth Glide
    entryType: special
    text: The elemental can burrow through nonmagical, unworked earth and stone. While doing so, the elemental doesn't disturb the material it moves through.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Siege Monster
    entryType: special
    text: The elemental deals double damage to objects and structures.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: special
    text: The elemental makes two attacks, using Slam or Rock Launch in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Slam
    entryType: attack
    text: '*Melee Attack Roll:* +8, reach 10 ft. 14 (2d8 + 5) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 8
      damage:
        - dice: 2d8
          bonus: 5
          type: Bludgeoning
          average: 14
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Rock Launch
    entryType: attack
    text: '*Ranged Attack Roll:* +8, range 60 ft. 8 (1d6 + 5) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.'
    attack:
      type: ranged
      bonus: 8
      damage:
        - dice: 1d6
          bonus: 5
          type: Bludgeoning
          average: 8
      range: 60 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Earth Elemental
*Large, Elemental, Neutral Neutral*

**AC** 17
**HP** 147 (14d10 + 70)
**Initiative** -1 (9)
**Speed** 30 ft., burrow 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft., tremorsense 60 ft.; Passive Perception 10
**Languages** Primordial (Terran)
CR 5, PB +3, XP 1800

## Traits

**Earth Glide**
The elemental can burrow through nonmagical, unworked earth and stone. While doing so, the elemental doesn't disturb the material it moves through.

**Siege Monster**
The elemental deals double damage to objects and structures.

## Actions

**Multiattack**
The elemental makes two attacks, using Slam or Rock Launch in any combination.

**Slam**
*Melee Attack Roll:* +8, reach 10 ft. 14 (2d8 + 5) Bludgeoning damage.

**Rock Launch**
*Ranged Attack Roll:* +8, range 60 ft. 8 (1d6 + 5) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.
`,
      "Monsters/efreeti.md": `---
smType: creature
name: Efreeti
size: Large
type: Elemental
typeTags:
  - value: Genie
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '17'
initiative: +1 (11)
hp: '212'
hitDice: 17d10 + 119
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 60 ft.
    hover: true
abilities:
  - key: str
    score: 22
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 24
    saveProf: false
  - key: int
    score: 16
    saveProf: false
  - key: wis
    score: 15
    saveProf: true
    saveMod: 6
  - key: cha
    score: 19
    saveProf: true
    saveMod: 8
pb: '+4'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Primordial (Ignan)
damageImmunitiesList:
  - value: Fire
cr: '11'
xp: '7200'
entries:
  - category: trait
    name: Elemental Restoration
    entryType: special
    text: If the efreeti dies outside the Elemental Plane of Fire, its body dissolves into ash, and it gains a new body in 1d4 days, reviving with all its Hit Points somewhere on the Plane of Fire.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The efreeti has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Wishes
    entryType: special
    text: The efreeti has a 30 percent chance of knowing the *Wish* spell. If the efreeti knows it, the efreeti can cast it only on behalf of a non-genie creature who communicates a wish in a way the efreeti can understand. If the efreeti casts the spell for the creature, the efreeti suffers none of the spell's stress. Once the efreeti has cast it three times, the efreeti can't do so again for 365 days.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: special
    text: The efreeti makes three attacks, using Heated Blade or Hurl Flame in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Heated Blade
    entryType: attack
    text: '*Melee Attack Roll:* +10, reach 5 ft. 13 (2d6 + 6) Slashing damage plus 13 (2d12) Fire damage.'
    attack:
      type: melee
      bonus: 10
      damage:
        - dice: 2d6
          bonus: 6
          type: Slashing
          average: 13
        - dice: 2d12
          bonus: 0
          type: Fire
          average: 13
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Hurl Flame
    entryType: attack
    text: '*Ranged Attack Roll:* +8, range 120 ft. 24 (7d6) Fire damage.'
    attack:
      type: ranged
      bonus: 8
      damage:
        - dice: 7d6
          bonus: 0
          type: Fire
          average: 24
      range: 120 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The efreeti casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 16): - **At Will:** *Detect Magic*, *Elementalism* - **1e/Day Each:** *Gaseous Form*, *Invisibility*, *Major Image*, *Plane Shift*, *Tongues*, *Wall of Fire*'
    spellcasting:
      ability: cha
      saveDC: 16
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Elementalism
        - frequency: 1/day
          spells:
            - Gaseous Form
            - Invisibility
            - Major Image
            - Plane Shift
            - Tongues
            - Wall of Fire
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Efreeti
*Large, Elemental, Neutral Neutral*

**AC** 17
**HP** 212 (17d10 + 119)
**Initiative** +1 (11)
**Speed** 40 ft., fly 60 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 12
**Languages** Primordial (Ignan)
CR 11, PB +4, XP 7200

## Traits

**Elemental Restoration**
If the efreeti dies outside the Elemental Plane of Fire, its body dissolves into ash, and it gains a new body in 1d4 days, reviving with all its Hit Points somewhere on the Plane of Fire.

**Magic Resistance**
The efreeti has Advantage on saving throws against spells and other magical effects.

**Wishes**
The efreeti has a 30 percent chance of knowing the *Wish* spell. If the efreeti knows it, the efreeti can cast it only on behalf of a non-genie creature who communicates a wish in a way the efreeti can understand. If the efreeti casts the spell for the creature, the efreeti suffers none of the spell's stress. Once the efreeti has cast it three times, the efreeti can't do so again for 365 days.

## Actions

**Multiattack**
The efreeti makes three attacks, using Heated Blade or Hurl Flame in any combination.

**Heated Blade**
*Melee Attack Roll:* +10, reach 5 ft. 13 (2d6 + 6) Slashing damage plus 13 (2d12) Fire damage.

**Hurl Flame**
*Ranged Attack Roll:* +8, range 120 ft. 24 (7d6) Fire damage.

**Spellcasting**
The efreeti casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 16): - **At Will:** *Detect Magic*, *Elementalism* - **1e/Day Each:** *Gaseous Form*, *Invisibility*, *Major Image*, *Plane Shift*, *Tongues*, *Wall of Fire*
`,
      "Monsters/erinyes.md": `---
smType: creature
name: Erinyes
size: Medium
type: Fiend
typeTags:
  - value: Devil
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '18'
initiative: +7 (17)
hp: '178'
hitDice: 21d8 + 84
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 16
    saveProf: true
    saveMod: 7
  - key: con
    score: 18
    saveProf: true
    saveMod: 8
  - key: int
    score: 14
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 18
    saveProf: true
    saveMod: 8
pb: '+4'
skills:
  - skill: Perception
    value: '6'
  - skill: Persuasion
    value: '8'
sensesList:
  - type: truesight
    range: '120'
passivesList:
  - skill: Perception
    value: '16'
languagesList:
  - value: Infernal
  - value: telepathy 120 ft.
damageResistancesList:
  - value: Cold
damageImmunitiesList:
  - value: Fire
  - value: Poison; Poisoned
cr: '12'
xp: '8400'
entries:
  - category: trait
    name: Diabolical Restoration
    entryType: special
    text: If the erinyes dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The erinyes has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Rope
    entryType: special
    text: The erinyes has a magic rope. While bearing it, the erinyes can use the Entangling Rope action. The rope has AC 20, HP 90, and Immunity to Poison and Psychic damage. The rope turns to dust if reduced to 0 Hit Points, if it is 5+ feet away from the erinyes for 1 hour or more, or if the erinyes dies. If the rope is damaged or destroyed, the erinyes can fully restore it when finishing a Short Rest|XPHB|Short or Long Rest.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The erinyes makes three Withering Sword attacks and can use Entangling Rope.
    multiattack:
      attacks:
        - name: Sword
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Withering Sword
    entryType: attack
    text: '*Melee Attack Roll:* +8, reach 5 ft. 13 (2d8 + 4) Slashing damage plus 11 (2d10) Necrotic damage.'
    attack:
      type: melee
      bonus: 8
      damage:
        - dice: 2d8
          bonus: 4
          type: Slashing
          average: 13
        - dice: 2d10
          bonus: 0
          type: Necrotic
          average: 11
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Entangling Rope (Requires Magic Rope)
    entryType: save
    text: '*Strength Saving Throw*: DC 16, one creature the erinyes can see within 120 feet. *Failure:*  14 (4d6) Force damage, and the target has the Restrained condition until the rope is destroyed, the erinyes uses a Bonus Action to release the target, or the erinyes uses Entangling Rope again.'
    save:
      ability: str
      dc: 16
      targeting:
        type: single
        range: 120 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Restrained
              duration:
                type: until
                trigger: the rope is destroyed
        damage:
          - dice: 4d6
            bonus: 0
            type: Force
            average: 14
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Erinyes
*Medium, Fiend, Lawful Evil*

**AC** 18
**HP** 178 (21d8 + 84)
**Initiative** +7 (17)
**Speed** 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** truesight 120 ft.; Passive Perception 16
**Languages** Infernal, telepathy 120 ft.
CR 12, PB +4, XP 8400

## Traits

**Diabolical Restoration**
If the erinyes dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.

**Magic Resistance**
The erinyes has Advantage on saving throws against spells and other magical effects.

**Magic Rope**
The erinyes has a magic rope. While bearing it, the erinyes can use the Entangling Rope action. The rope has AC 20, HP 90, and Immunity to Poison and Psychic damage. The rope turns to dust if reduced to 0 Hit Points, if it is 5+ feet away from the erinyes for 1 hour or more, or if the erinyes dies. If the rope is damaged or destroyed, the erinyes can fully restore it when finishing a Short Rest|XPHB|Short or Long Rest.

## Actions

**Multiattack**
The erinyes makes three Withering Sword attacks and can use Entangling Rope.

**Withering Sword**
*Melee Attack Roll:* +8, reach 5 ft. 13 (2d8 + 4) Slashing damage plus 11 (2d10) Necrotic damage.

**Entangling Rope (Requires Magic Rope)**
*Strength Saving Throw*: DC 16, one creature the erinyes can see within 120 feet. *Failure:*  14 (4d6) Force damage, and the target has the Restrained condition until the rope is destroyed, the erinyes uses a Bonus Action to release the target, or the erinyes uses Entangling Rope again.
`,
      "Monsters/ettercap.md": `---
smType: creature
name: Ettercap
size: Medium
type: Monstrosity
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '13'
initiative: +2 (12)
hp: '44'
hitDice: 8d8 + 8
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 14
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 7
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
  - skill: Stealth
    value: '4'
  - skill: Survival
    value: '3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Spider Climb
    entryType: special
    text: The ettercap can climb difficult surfaces, including along ceilings, without needing to make an ability check.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Web Walker
    entryType: special
    text: The ettercap ignores movement restrictions caused by webs, and the ettercap knows the location of any other creature in contact with the same web.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The ettercap makes one Bite attack and one Claw attack.
    multiattack:
      attacks:
        - name: Bite
          count: 1
        - name: Claw
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 2 (1d4) Poison damage, and the target has the Poisoned condition until the start of the ettercap''s next turn.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Piercing
          average: 5
        - dice: 1d4
          bonus: 0
          type: Poison
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 7 (2d4 + 2) Slashing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 2d4
          bonus: 2
          type: Slashing
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Web Strand (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 12, one Large or smaller creature the ettercap can see within 30 feet. *Failure:*  The target has the Restrained condition until the web is destroyed (AC 10; HP 5; Vulnerability to Fire damage; Immunity to Bludgeoning, Poison, and Psychic damage).'
    recharge: 5-6
    save:
      ability: dex
      dc: 12
      targeting:
        type: single
        range: 30 ft.
        restrictions:
          size:
            - Large
            - smaller
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Restrained
              duration:
                type: until
                trigger: the web is destroyed (AC 10; HP 5; Vulnerability to Fire damage; Immunity to Bludgeoning
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Reel
    entryType: special
    text: The ettercap pulls one creature within 30 feet of itself that is Restrained by its Web Strand up to 25 feet straight toward itself.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Ettercap
*Medium, Monstrosity, Neutral Evil*

**AC** 13
**HP** 44 (8d8 + 8)
**Initiative** +2 (12)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 13
CR 2, PB +2, XP 450

## Traits

**Spider Climb**
The ettercap can climb difficult surfaces, including along ceilings, without needing to make an ability check.

**Web Walker**
The ettercap ignores movement restrictions caused by webs, and the ettercap knows the location of any other creature in contact with the same web.

## Actions

**Multiattack**
The ettercap makes one Bite attack and one Claw attack.

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 2 (1d4) Poison damage, and the target has the Poisoned condition until the start of the ettercap's next turn.

**Claw**
*Melee Attack Roll:* +4, reach 5 ft. 7 (2d4 + 2) Slashing damage.

**Web Strand (Recharge 5-6)**
*Dexterity Saving Throw*: DC 12, one Large or smaller creature the ettercap can see within 30 feet. *Failure:*  The target has the Restrained condition until the web is destroyed (AC 10; HP 5; Vulnerability to Fire damage; Immunity to Bludgeoning, Poison, and Psychic damage).

## Bonus Actions

**Reel**
The ettercap pulls one creature within 30 feet of itself that is Restrained by its Web Strand up to 25 feet straight toward itself.
`,
      "Monsters/ettin.md": `---
smType: creature
name: Ettin
size: Large
type: Giant
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '12'
initiative: '-1 (9)'
hp: '85'
hitDice: 10d10 + 30
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 21
    saveProf: false
  - key: dex
    score: 8
    saveProf: false
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Giant
conditionImmunitiesList:
  - value: Blinded
  - value: Charmed
  - value: Deafened
  - value: Frightened
  - value: Stunned
  - value: Unconscious
cr: '4'
xp: '1100'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The ettin makes one Battleaxe attack and one Morningstar attack.
    multiattack:
      attacks:
        - name: Battleaxe
          count: 1
        - name: Morningstar
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Battleaxe
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 14 (2d8 + 5) Slashing damage. If the target is a Large or smaller creature, it has the Prone condition.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d8
          bonus: 5
          type: Slashing
          average: 14
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Morningstar
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 14 (2d8 + 5) Piercing damage, and the target has Disadvantage on the next attack roll it makes before the end of its next turn.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d8
          bonus: 5
          type: Piercing
          average: 14
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Ettin
*Large, Giant, Chaotic Evil*

**AC** 12
**HP** 85 (10d10 + 30)
**Initiative** -1 (9)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 14
**Languages** Giant
CR 4, PB +2, XP 1100

## Actions

**Multiattack**
The ettin makes one Battleaxe attack and one Morningstar attack.

**Battleaxe**
*Melee Attack Roll:* +7, reach 5 ft. 14 (2d8 + 5) Slashing damage. If the target is a Large or smaller creature, it has the Prone condition.

**Morningstar**
*Melee Attack Roll:* +7, reach 5 ft. 14 (2d8 + 5) Piercing damage, and the target has Disadvantage on the next attack roll it makes before the end of its next turn.
`,
      "Monsters/fire-elemental.md": `---
smType: creature
name: Fire Elemental
size: Large
type: Elemental
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '13'
initiative: +3 (13)
hp: '93'
hitDice: 11d10 + 33
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 17
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Primordial (Ignan)
damageResistancesList:
  - value: Bludgeoning
  - value: Piercing
  - value: Slashing
damageImmunitiesList:
  - value: Fire
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Grappled
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
  - value: Prone
  - value: Restrained
  - value: Unconscious
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Fire Aura
    entryType: special
    text: At the end of each of the elemental's turns, each creature in a 10-foot Emanation originating from the elemental takes 5 (1d10) Fire damage. Creatures and flammable objects in the Emanation start Hitazard burning.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Fire Form
    entryType: special
    text: The elemental can move through a space as narrow as 1 inch without expending extra movement to do so, and it can enter a creature's space and stop there. The first time it enters a creature's space on a turn, that creature takes 5 (1d10) Fire damage.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Illumination
    entryType: special
    text: The elemental sheds Bright Light in a 30-foot radius and Dim Light for an additional 30 feet.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Water Susceptibility
    entryType: special
    text: The elemental takes 3 (1d6) Cold damage for every 5 feet the elemental moves in water or for every gallon of water splashed on it.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The elemental makes two Burn attacks.
    multiattack:
      attacks:
        - name: Burn
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Burn
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 10 (2d6 + 3) Fire damage. If the target is a creature or a flammable object, it starts burning.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d6
          bonus: 3
          type: Fire
          average: 10
      reach: 5 ft.
      onHit:
        other: If the target is a creature or a flammable object, it starts burning.
      additionalEffects: If the target is a creature or a flammable object, it starts burning.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Fire Elemental
*Large, Elemental, Neutral Neutral*

**AC** 13
**HP** 93 (11d10 + 33)
**Initiative** +3 (13)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Primordial (Ignan)
CR 5, PB +3, XP 1800

## Traits

**Fire Aura**
At the end of each of the elemental's turns, each creature in a 10-foot Emanation originating from the elemental takes 5 (1d10) Fire damage. Creatures and flammable objects in the Emanation start Hitazard burning.

**Fire Form**
The elemental can move through a space as narrow as 1 inch without expending extra movement to do so, and it can enter a creature's space and stop there. The first time it enters a creature's space on a turn, that creature takes 5 (1d10) Fire damage.

**Illumination**
The elemental sheds Bright Light in a 30-foot radius and Dim Light for an additional 30 feet.

**Water Susceptibility**
The elemental takes 3 (1d6) Cold damage for every 5 feet the elemental moves in water or for every gallon of water splashed on it.

## Actions

**Multiattack**
The elemental makes two Burn attacks.

**Burn**
*Melee Attack Roll:* +6, reach 5 ft. 10 (2d6 + 3) Fire damage. If the target is a creature or a flammable object, it starts burning.
`,
      "Monsters/fire-giant.md": `---
smType: creature
name: Fire Giant
size: Huge
type: Giant
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '18'
initiative: +3 (13)
hp: '162'
hitDice: 13d12 + 78
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 25
    saveProf: false
  - key: dex
    score: 9
    saveProf: true
    saveMod: 3
  - key: con
    score: 23
    saveProf: true
    saveMod: 10
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 13
    saveProf: true
    saveMod: 5
pb: '+4'
skills:
  - skill: Athletics
    value: '11'
  - skill: Perception
    value: '6'
passivesList:
  - skill: Perception
    value: '16'
languagesList:
  - value: Giant
damageImmunitiesList:
  - value: Fire
cr: '9'
xp: '5000'
entries:
  - category: action
    name: Multiattack
    entryType: special
    text: The giant makes two attacks, using Flame Sword or Hammer Throw in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Flame Sword
    entryType: attack
    text: '*Melee Attack Roll:* +11, reach 10 ft. 21 (4d6 + 7) Slashing damage plus 10 (3d6) Fire damage.'
    attack:
      type: melee
      bonus: 11
      damage:
        - dice: 4d6
          bonus: 7
          type: Slashing
          average: 21
        - dice: 3d6
          bonus: 0
          type: Fire
          average: 10
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Hammer Throw
    entryType: attack
    text: '*Ranged Attack Roll:* +11, range 60/240 ft. 23 (3d10 + 7) Bludgeoning damage plus 4 (1d8) Fire damage, and the target is pushed up to 15 feet straight away from the giant and has Disadvantage on the next attack roll it makes before the end of its next turn.'
    attack:
      type: ranged
      bonus: 11
      damage:
        - dice: 3d10
          bonus: 7
          type: Bludgeoning
          average: 23
        - dice: 1d8
          bonus: 0
          type: Fire
          average: 4
      range: 60/240 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Fire Giant
*Huge, Giant, Lawful Evil*

**AC** 18
**HP** 162 (13d12 + 78)
**Initiative** +3 (13)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Giant
CR 9, PB +4, XP 5000

## Actions

**Multiattack**
The giant makes two attacks, using Flame Sword or Hammer Throw in any combination.

**Flame Sword**
*Melee Attack Roll:* +11, reach 10 ft. 21 (4d6 + 7) Slashing damage plus 10 (3d6) Fire damage.

**Hammer Throw**
*Ranged Attack Roll:* +11, range 60/240 ft. 23 (3d10 + 7) Bludgeoning damage plus 4 (1d8) Fire damage, and the target is pushed up to 15 feet straight away from the giant and has Disadvantage on the next attack roll it makes before the end of its next turn.
`,
      "Monsters/flesh-golem.md": `---
smType: creature
name: Flesh Golem
size: Medium
type: Construct
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '9'
initiative: '-1 (9)'
hp: '127'
hitDice: 15d8 + 60
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 9
    saveProf: false
  - key: con
    score: 18
    saveProf: false
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Understands Common plus one other language but can't speak
damageImmunitiesList:
  - value: Lightning
  - value: Poison; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Frightened
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Aversion to Fire
    entryType: special
    text: If the golem takes Fire damage, it has Disadvantage on attack rolls and ability checks until the end of its next turn.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Berserk
    entryType: special
    text: Whenever the golem starts its turn Bloodied, roll 1d6. On a 6, the golem goes berserk. On each of its turns while berserk, the golem attacks the nearest creature it can see. If no creature is near enough to move to and attack, the golem attacks an object. Once the golem goes berserk, it remains so until it is destroyed or it is no longer Bloodied. The golem's creator, if within 60 feet of the berserk golem, can try to calm it by taking an action to make a DC 15 Charisma (Persuasion) check; the golem must be able to hear its creator. If this check succeeds, the golem ceases being berserk until the start of its next turn, at which point it resumes rolling for the Berserk trait again if it is still Bloodied.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Immutable Form
    entryType: special
    text: The golem can't shape-shift.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Lightning Absorption
    entryType: special
    text: Whenever the golem is subjected to Lightning damage, it regains a number of Hit Points equal to the Lightning damage dealt.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The golem has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The golem makes two Slam attacks.
    multiattack:
      attacks:
        - name: Slam
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Slam
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage plus 4 (1d8) Lightning damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d8
          bonus: 4
          type: Bludgeoning
          average: 13
        - dice: 1d8
          bonus: 0
          type: Lightning
          average: 4
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Flesh Golem
*Medium, Construct, Neutral Neutral*

**AC** 9
**HP** 127 (15d8 + 60)
**Initiative** -1 (9)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Understands Common plus one other language but can't speak
CR 5, PB +3, XP 1800

## Traits

**Aversion to Fire**
If the golem takes Fire damage, it has Disadvantage on attack rolls and ability checks until the end of its next turn.

**Berserk**
Whenever the golem starts its turn Bloodied, roll 1d6. On a 6, the golem goes berserk. On each of its turns while berserk, the golem attacks the nearest creature it can see. If no creature is near enough to move to and attack, the golem attacks an object. Once the golem goes berserk, it remains so until it is destroyed or it is no longer Bloodied. The golem's creator, if within 60 feet of the berserk golem, can try to calm it by taking an action to make a DC 15 Charisma (Persuasion) check; the golem must be able to hear its creator. If this check succeeds, the golem ceases being berserk until the start of its next turn, at which point it resumes rolling for the Berserk trait again if it is still Bloodied.

**Immutable Form**
The golem can't shape-shift.

**Lightning Absorption**
Whenever the golem is subjected to Lightning damage, it regains a number of Hit Points equal to the Lightning damage dealt.

**Magic Resistance**
The golem has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The golem makes two Slam attacks.

**Slam**
*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage plus 4 (1d8) Lightning damage.
`,
      "Monsters/frost-giant.md": `---
smType: creature
name: Frost Giant
size: Huge
type: Giant
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '15'
initiative: +2 (12)
hp: '149'
hitDice: 13d12 + 65
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 23
    saveProf: false
  - key: dex
    score: 9
    saveProf: false
  - key: con
    score: 21
    saveProf: true
    saveMod: 8
  - key: int
    score: 9
    saveProf: false
  - key: wis
    score: 10
    saveProf: true
    saveMod: 3
  - key: cha
    score: 12
    saveProf: true
    saveMod: 4
pb: '+3'
skills:
  - skill: Athletics
    value: '9'
  - skill: Perception
    value: '3'
passivesList:
  - skill: Perception
    value: '13'
languagesList:
  - value: Giant
damageImmunitiesList:
  - value: Cold
cr: '8'
xp: '3900'
entries:
  - category: action
    name: Multiattack
    entryType: special
    text: The giant makes two attacks, using Frost Axe or Great Bow in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Frost Axe
    entryType: attack
    text: '*Melee Attack Roll:* +9, reach 10 ft. 19 (2d12 + 6) Slashing damage plus 9 (2d8) Cold damage.'
    attack:
      type: melee
      bonus: 9
      damage:
        - dice: 2d12
          bonus: 6
          type: Slashing
          average: 19
        - dice: 2d8
          bonus: 0
          type: Cold
          average: 9
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Great Bow
    entryType: attack
    text: '*Ranged Attack Roll:* +9, range 150/600 ft. 17 (2d10 + 6) Piercing damage plus 7 (2d6) Cold damage, and the target''s Speed decreases by 10 feet until the end of its next turn.'
    attack:
      type: ranged
      bonus: 9
      damage:
        - dice: 2d10
          bonus: 6
          type: Piercing
          average: 17
        - dice: 2d6
          bonus: 0
          type: Cold
          average: 7
      range: 150/600 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: War Cry (Recharge 5-6)
    entryType: special
    text: The giant or one creature of its choice that can see or hear it gains 16 (2d10 + 5) Temporary Hit Points and has Advantage on attack rolls until the start of the giant's next turn.
    recharge: 5-6
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Frost Giant
*Huge, Giant, Neutral Evil*

**AC** 15
**HP** 149 (13d12 + 65)
**Initiative** +2 (12)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Giant
CR 8, PB +3, XP 3900

## Actions

**Multiattack**
The giant makes two attacks, using Frost Axe or Great Bow in any combination.

**Frost Axe**
*Melee Attack Roll:* +9, reach 10 ft. 19 (2d12 + 6) Slashing damage plus 9 (2d8) Cold damage.

**Great Bow**
*Ranged Attack Roll:* +9, range 150/600 ft. 17 (2d10 + 6) Piercing damage plus 7 (2d6) Cold damage, and the target's Speed decreases by 10 feet until the end of its next turn.

## Bonus Actions

**War Cry (Recharge 5-6)**
The giant or one creature of its choice that can see or hear it gains 16 (2d10 + 5) Temporary Hit Points and has Advantage on attack rolls until the start of the giant's next turn.
`,
      "Monsters/gargoyle.md": `---
smType: creature
name: Gargoyle
size: Medium
type: Elemental
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '15'
initiative: +2 (12)
hp: '67'
hitDice: 9d8 + 27
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Primordial (Terran)
damageImmunitiesList:
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Petrified
  - value: Poisoned
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Flyby
    entryType: special
    text: The gargoyle doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The gargoyle makes two Claw attacks.
    multiattack:
      attacks:
        - name: Claw
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 7 (2d4 + 2) Slashing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 2d4
          bonus: 2
          type: Slashing
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Gargoyle
*Medium, Elemental, Chaotic Evil*

**AC** 15
**HP** 67 (9d8 + 27)
**Initiative** +2 (12)
**Speed** 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Primordial (Terran)
CR 2, PB +2, XP 450

## Traits

**Flyby**
The gargoyle doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.

## Actions

**Multiattack**
The gargoyle makes two Claw attacks.

**Claw**
*Melee Attack Roll:* +4, reach 5 ft. 7 (2d4 + 2) Slashing damage.
`,
      "Monsters/gelatinous-cube.md": `---
smType: creature
name: Gelatinous Cube
size: Large
type: Ooze
alignmentOverride: Unaligned
ac: '6'
initiative: '-4 (6)'
hp: '63'
hitDice: 6d10 + 30
speeds:
  walk:
    distance: 15 ft.
abilities:
  - key: str
    score: 14
    saveProf: false
  - key: dex
    score: 3
    saveProf: false
  - key: con
    score: 20
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 6
    saveProf: false
  - key: cha
    score: 1
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '60'
passivesList:
  - skill: Perception
    value: '8'
damageImmunitiesList:
  - value: Acid; Blinded
  - value: Exhaustion
conditionImmunitiesList:
  - value: Charmed
  - value: Deafened
  - value: Frightened
  - value: Prone
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Ooze Cube
    entryType: special
    text: The cube fills its entire space and is transparent. Other creatures can enter that space, but a creature that does so is subjected to the cube's Engulf and has Disadvantage on the saving throw. Creatures inside the cube have Cover|XPHB|Total Cover, and the cube can hold one Large creature or up to four Medium or Small creatures inside itself at a time. As an action, a creature within 5 feet of the cube can pull a creature or an object out of the cube by succeeding on a DC 12 Strength (Athletics) check, and the puller takes 10 (3d6) Acid damage.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Transparent
    entryType: special
    text: Even when the cube is in plain sight, a creature must succeed on a DC 15 Wisdom (Perception) check to notice the cube if the creature hasn't witnessed the cube move or otherwise act.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Pseudopod
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 12 (3d6 + 2) Acid damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 3d6
          bonus: 2
          type: Acid
          average: 12
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Engulf
    entryType: save
    text: 'The cube moves up to its Speed without provoking Opportunity Attacks. The cube can move through the spaces of Large or smaller creatures if it has room inside itself to contain them (see the Ooze Cube [Area of Effect]|XPHB|Cube trait). *Dexterity Saving Throw*: DC 12, each creature whose space the cube enters for the first time during this move. *Failure:*  10 (3d6) Acid damage, and the target is engulfed. An engulfed target is suffocating, can''t cast spells with a Verbal component, has the Restrained condition, and takes 10 (3d6) Acid damage at the start of each of the cube''s turns. When the cube moves, the engulfed target moves with it. An engulfed target can try to escape by taking an action to make a DC 12 Strength (Athletics) check. On a successful check, the target escapes and enters the nearest unoccupied space. *Success:*  Half damage, and the target moves to an unoccupied space within 5 feet of the cube. If there is no unoccupied space, the target fails the save instead.'
    save:
      ability: dex
      dc: 12
      targeting:
        type: single
      onFail:
        effects:
          conditions:
            - condition: Restrained
        damage:
          - dice: 3d6
            bonus: 0
            type: Acid
            average: 10
          - dice: 3d6
            bonus: 0
            type: Acid
            average: 10
      onSuccess:
        damage: half
        legacyText: Half damage, and the target moves to an unoccupied space within 5 feet of the cube. If there is no unoccupied space, the target fails the save instead.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Gelatinous Cube
*Large, Ooze, Unaligned*

**AC** 6
**HP** 63 (6d10 + 30)
**Initiative** -4 (6)
**Speed** 15 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft.; Passive Perception 8
CR 2, PB +2, XP 450

## Traits

**Ooze Cube**
The cube fills its entire space and is transparent. Other creatures can enter that space, but a creature that does so is subjected to the cube's Engulf and has Disadvantage on the saving throw. Creatures inside the cube have Cover|XPHB|Total Cover, and the cube can hold one Large creature or up to four Medium or Small creatures inside itself at a time. As an action, a creature within 5 feet of the cube can pull a creature or an object out of the cube by succeeding on a DC 12 Strength (Athletics) check, and the puller takes 10 (3d6) Acid damage.

**Transparent**
Even when the cube is in plain sight, a creature must succeed on a DC 15 Wisdom (Perception) check to notice the cube if the creature hasn't witnessed the cube move or otherwise act.

## Actions

**Pseudopod**
*Melee Attack Roll:* +4, reach 5 ft. 12 (3d6 + 2) Acid damage.

**Engulf**
The cube moves up to its Speed without provoking Opportunity Attacks. The cube can move through the spaces of Large or smaller creatures if it has room inside itself to contain them (see the Ooze Cube [Area of Effect]|XPHB|Cube trait). *Dexterity Saving Throw*: DC 12, each creature whose space the cube enters for the first time during this move. *Failure:*  10 (3d6) Acid damage, and the target is engulfed. An engulfed target is suffocating, can't cast spells with a Verbal component, has the Restrained condition, and takes 10 (3d6) Acid damage at the start of each of the cube's turns. When the cube moves, the engulfed target moves with it. An engulfed target can try to escape by taking an action to make a DC 12 Strength (Athletics) check. On a successful check, the target escapes and enters the nearest unoccupied space. *Success:*  Half damage, and the target moves to an unoccupied space within 5 feet of the cube. If there is no unoccupied space, the target fails the save instead.
`,
      "Monsters/ghast.md": `---
smType: creature
name: Ghast
size: Medium
type: Undead
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '13'
initiative: +3 (13)
hp: '36'
hitDice: 8d8
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 17
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 11
    saveProf: false
  - key: wis
    score: 10
    saveProf: true
    saveMod: 2
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common
damageResistancesList:
  - value: Necrotic
damageImmunitiesList:
  - value: Poison; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Poisoned
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Stench
    entryType: save
    text: '*Constitution Saving Throw*: DC 10, any creature that starts its turn in a 5-foot Emanation originating from the ghast. *Failure:*  The target has the Poisoned condition until the start of its next turn. *Success:*  The target is immune to this ghast''s Stench for 24 hours.'
    save:
      ability: con
      dc: 10
      targeting:
        shape: emanation
        size: 5 ft.
        origin: self
      onFail:
        effects:
          conditions:
            - condition: Poisoned
              duration:
                type: until
                trigger: the start of its next turn
      onSuccess: The target is immune to this ghast's Stench for 24 hours.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage plus 9 (2d8) Necrotic damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d8
          bonus: 3
          type: Piercing
          average: 7
        - dice: 2d8
          bonus: 0
          type: Necrotic
          average: 9
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage. If the target is a non-Undead creature, it is subjected to the following effect. *Constitution Saving Throw*: DC 10. *Failure:*  The target has the Paralyzed condition until the end of its next turn.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d6
          bonus: 3
          type: Slashing
          average: 10
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Paralyzed
            duration:
              type: until
              trigger: the end of its next turn
      additionalEffects: 'If the target is a non-Undead creature, it is subjected to the following effect. *Constitution Saving Throw*: DC 10. *Failure:*  The target has the Paralyzed condition until the end of its next turn.'
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Ghast
*Medium, Undead, Chaotic Evil*

**AC** 13
**HP** 36 (8d8)
**Initiative** +3 (13)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Common
CR 2, PB +2, XP 450

## Traits

**Stench**
*Constitution Saving Throw*: DC 10, any creature that starts its turn in a 5-foot Emanation originating from the ghast. *Failure:*  The target has the Poisoned condition until the start of its next turn. *Success:*  The target is immune to this ghast's Stench for 24 hours.

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage plus 9 (2d8) Necrotic damage.

**Claw**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage. If the target is a non-Undead creature, it is subjected to the following effect. *Constitution Saving Throw*: DC 10. *Failure:*  The target has the Paralyzed condition until the end of its next turn.
`,
      "Monsters/ghost.md": `---
smType: creature
name: Ghost
size: Medium
type: Undead
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '11'
initiative: +1 (11)
hp: '45'
hitDice: 10d8
speeds:
  walk:
    distance: 5 ft.
  fly:
    distance: 40 ft.
    hover: true
abilities:
  - key: str
    score: 7
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 17
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Common plus one other language
damageResistancesList:
  - value: Acid
  - value: Bludgeoning
  - value: Cold
  - value: Fire
  - value: Lightning
  - value: Piercing
  - value: Slashing
  - value: Thunder
damageImmunitiesList:
  - value: Necrotic
  - value: Poison; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Frightened
  - value: Grappled
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
  - value: Prone
  - value: Restrained
cr: '4'
xp: '1100'
entries:
  - category: trait
    name: Ethereal Sight
    entryType: special
    text: The ghost can see 60 feet into the Ethereal Plane when it is on the Material Plane.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Incorporeal Movement
    entryType: special
    text: The ghost can move through other creatures and objects as if they were Difficult Terrain. It takes 5 (1d10) Force damage if it ends its turn inside an object.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The ghost makes two Withering Touch attacks.
    multiattack:
      attacks:
        - name: Touch
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Withering Touch
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 19 (3d10 + 3) Necrotic damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 3d10
          bonus: 3
          type: Necrotic
          average: 19
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Horrific Visage
    entryType: save
    text: '*Wisdom Saving Throw*: DC 13, each creature in a 60-foot Cone that can see the ghost and isn''t an Undead. *Failure:*  10 (2d6 + 3) Psychic damage, and the target has the Frightened condition until the start of the ghost''s next turn. *Success:*  The target is immune to this ghost''s Horrific Visage for 24 hours.'
    save:
      ability: wis
      dc: 13
      targeting:
        shape: cone
        size: 60 ft.
      onFail:
        effects:
          conditions:
            - condition: Frightened
              duration:
                type: until
                trigger: the start of the ghost's next turn
        damage:
          - dice: 2d6
            bonus: 3
            type: Psychic
            average: 10
      onSuccess: The target is immune to this ghost's Horrific Visage for 24 hours.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Possession
    entryType: save
    text: '*Charisma Saving Throw*: DC 13, one Humanoid the ghost can see within 5 feet. *Failure:*  The target is possessed by the ghost; the ghost disappears, and the target has the Incapacitated condition and loses control of its body. The ghost now controls the body, but the target retains awareness. The ghost can''t be targeted by any attack, spell, or other effect, except ones that specifically target Undead. The ghost''s game statistics are the same, except it uses the possessed target''s Speed, as well as the target''s Strength, Dexterity, and Constitution modifiers. The possession lasts until the body drops to 0 Hit Points or the ghost leaves as a Bonus Action. When the possession ends, the ghost appears in an unoccupied space within 5 feet of the target, and the target is immune to this ghost''s Possession for 24 hours. *Success:*  The target is immune to this ghost''s Possession for 24 hours.'
    save:
      ability: cha
      dc: 13
      targeting:
        type: single
        range: 5 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Incapacitated
              duration:
                type: until
                trigger: the body drops to 0 Hit Points or the ghost leaves as a Bonus Action
      onSuccess: The target is immune to this ghost's Possession for 24 hours.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Etherealness
    entryType: spellcasting
    text: The ghost casts the *Etherealness* spell, requiring no spell components and using Charisma as the spellcasting ability. The ghost is visible on the Material Plane while on the Border Ethereal and vice versa, but it can't affect or be affected by anything on the other plane. - **At Will:** *Etherealness*
    spellcasting:
      ability: cha
      spellLists:
        - frequency: at-will
          spells:
            - Etherealness
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Ghost
*Medium, Undead, Neutral Neutral*

**AC** 11
**HP** 45 (10d8)
**Initiative** +1 (11)
**Speed** 5 ft., fly 40 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 11
**Languages** Common plus one other language
CR 4, PB +2, XP 1100

## Traits

**Ethereal Sight**
The ghost can see 60 feet into the Ethereal Plane when it is on the Material Plane.

**Incorporeal Movement**
The ghost can move through other creatures and objects as if they were Difficult Terrain. It takes 5 (1d10) Force damage if it ends its turn inside an object.

## Actions

**Multiattack**
The ghost makes two Withering Touch attacks.

**Withering Touch**
*Melee Attack Roll:* +5, reach 5 ft. 19 (3d10 + 3) Necrotic damage.

**Horrific Visage**
*Wisdom Saving Throw*: DC 13, each creature in a 60-foot Cone that can see the ghost and isn't an Undead. *Failure:*  10 (2d6 + 3) Psychic damage, and the target has the Frightened condition until the start of the ghost's next turn. *Success:*  The target is immune to this ghost's Horrific Visage for 24 hours.

**Possession (Recharge 6)**
*Charisma Saving Throw*: DC 13, one Humanoid the ghost can see within 5 feet. *Failure:*  The target is possessed by the ghost; the ghost disappears, and the target has the Incapacitated condition and loses control of its body. The ghost now controls the body, but the target retains awareness. The ghost can't be targeted by any attack, spell, or other effect, except ones that specifically target Undead. The ghost's game statistics are the same, except it uses the possessed target's Speed, as well as the target's Strength, Dexterity, and Constitution modifiers. The possession lasts until the body drops to 0 Hit Points or the ghost leaves as a Bonus Action. When the possession ends, the ghost appears in an unoccupied space within 5 feet of the target, and the target is immune to this ghost's Possession for 24 hours. *Success:*  The target is immune to this ghost's Possession for 24 hours.

**Etherealness**
The ghost casts the *Etherealness* spell, requiring no spell components and using Charisma as the spellcasting ability. The ghost is visible on the Material Plane while on the Border Ethereal and vice versa, but it can't affect or be affected by anything on the other plane. - **At Will:** *Etherealness*
`,
      "Monsters/ghoul.md": `---
smType: creature
name: Ghoul
size: Medium
type: Undead
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '12'
initiative: +2 (12)
hp: '22'
hitDice: 5d8
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 13
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 7
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common
damageImmunitiesList:
  - value: Poison; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Poisoned
cr: '1'
xp: '200'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The ghoul makes two Bite attacks.
    multiattack:
      attacks:
        - name: Bite
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 3 (1d6) Necrotic damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Piercing
          average: 5
        - dice: 1d6
          bonus: 0
          type: Necrotic
          average: 3
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Slashing damage. If the target is a creature that isn''t an Undead or elf, it is subjected to the following effect. *Constitution Saving Throw*: DC 10. *Failure:*  The target has the Paralyzed condition until the end of its next turn.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d4
          bonus: 2
          type: Slashing
          average: 4
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Paralyzed
            duration:
              type: until
              trigger: the end of its next turn
      additionalEffects: 'If the target is a creature that isn''t an Undead or elf, it is subjected to the following effect. *Constitution Saving Throw*: DC 10. *Failure:*  The target has the Paralyzed condition until the end of its next turn.'
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Ghoul
*Medium, Undead, Chaotic Evil*

**AC** 12
**HP** 22 (5d8)
**Initiative** +2 (12)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Common
CR 1, PB +2, XP 200

## Actions

**Multiattack**
The ghoul makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 3 (1d6) Necrotic damage.

**Claw**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Slashing damage. If the target is a creature that isn't an Undead or elf, it is subjected to the following effect. *Constitution Saving Throw*: DC 10. *Failure:*  The target has the Paralyzed condition until the end of its next turn.
`,
      "Monsters/gibbering-mouther.md": `---
smType: creature
name: Gibbering Mouther
size: Medium
type: Aberration
alignmentLawChaos: Chaotic
alignmentGoodEvil: Neutral
ac: '9'
initiative: '-1 (9)'
hp: '52'
hitDice: 7d8 + 21
speeds:
  walk:
    distance: 20 ft.
  swim:
    distance: 20 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 8
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
conditionImmunitiesList:
  - value: Prone
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Aberrant Ground
    entryType: special
    text: The ground in a 10-foot Emanation originating from the mouther is Difficult Terrain.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Gibbering
    entryType: save
    text: 'The mouther babbles incoherently while it doesn''t have the Incapacitated condition. *Wisdom Saving Throw*: DC 10, any creature that starts its turn within 20 feet of the mouther while it is babbling. *Failure:*  The target rolls 1d8 to determine what it does during the current turn: - **1-4**: The target does nothing. - **5-6**: The target takes no action or Bonus Action and uses all its movement to move in a random direction. - **7-8**: The target makes a melee attack against a randomly determined creature within its reach or does nothing if it can''t make such an attack.'
    save:
      ability: wis
      dc: 10
      targeting:
        type: single
        range: 20 ft.
      onFail:
        effects:
          other: 'The target rolls 1d8 to determine what it does during the current turn: - **1-4**: The target does nothing. - **5-6**: The target takes no action or Bonus Action and uses all its movement to move in a random direction. - **7-8**: The target makes a melee attack against a randomly determined creature within its reach or does nothing if it can''t make such an attack.'
        legacyEffects: 'The target rolls 1d8 to determine what it does during the current turn: - **1-4**: The target does nothing. - **5-6**: The target takes no action or Bonus Action and uses all its movement to move in a random direction. - **7-8**: The target makes a melee attack against a randomly determined creature within its reach or does nothing if it can''t make such an attack.'
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +2, reach 5 ft. 7 (2d6) Piercing damage. If the target is a Medium or smaller creature, it has the Prone condition. The target dies if it is reduced to 0 Hit Points by this attack. Its body is then absorbed into the mouther, leaving only equipment behind.'
    attack:
      type: melee
      bonus: 2
      damage:
        - dice: 2d6
          bonus: 0
          type: Piercing
          average: 7
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Medium or smaller
      additionalEffects: If the target is a Medium or smaller creature, it has the Prone condition. The target dies if it is reduced to 0 Hit Points by this attack. Its body is then absorbed into the mouther, leaving only equipment behind.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Blinding Spittle (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 10, each creature in a 10-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point within 30 feet. *Failure:*  7 (2d6) Radiant damage, and the target has the Blinded condition until the end of the mouther''s next turn.'
    recharge: 5-6
    save:
      ability: dex
      dc: 10
      targeting:
        shape: sphere
        size: 10 ft.
      onFail:
        effects:
          conditions:
            - condition: Blinded
              duration:
                type: until
                trigger: the end of the mouther's next turn
        damage:
          - dice: 2d6
            bonus: 0
            type: Radiant
            average: 7
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Gibbering Mouther
*Medium, Aberration, Chaotic Neutral*

**AC** 9
**HP** 52 (7d8 + 21)
**Initiative** -1 (9)
**Speed** 20 ft., swim 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
CR 2, PB +2, XP 450

## Traits

**Aberrant Ground**
The ground in a 10-foot Emanation originating from the mouther is Difficult Terrain.

**Gibbering**
The mouther babbles incoherently while it doesn't have the Incapacitated condition. *Wisdom Saving Throw*: DC 10, any creature that starts its turn within 20 feet of the mouther while it is babbling. *Failure:*  The target rolls 1d8 to determine what it does during the current turn: - **1-4**: The target does nothing. - **5-6**: The target takes no action or Bonus Action and uses all its movement to move in a random direction. - **7-8**: The target makes a melee attack against a randomly determined creature within its reach or does nothing if it can't make such an attack.

## Actions

**Bite**
*Melee Attack Roll:* +2, reach 5 ft. 7 (2d6) Piercing damage. If the target is a Medium or smaller creature, it has the Prone condition. The target dies if it is reduced to 0 Hit Points by this attack. Its body is then absorbed into the mouther, leaving only equipment behind.

**Blinding Spittle (Recharge 5-6)**
*Dexterity Saving Throw*: DC 10, each creature in a 10-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point within 30 feet. *Failure:*  7 (2d6) Radiant damage, and the target has the Blinded condition until the end of the mouther's next turn.
`,
      "Monsters/glabrezu.md": `---
smType: creature
name: Glabrezu
size: Large
type: Fiend
typeTags:
  - value: Demon
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '17'
initiative: +6 (16)
hp: '189'
hitDice: 18d10 + 90
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 20
    saveProf: true
    saveMod: 9
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 21
    saveProf: true
    saveMod: 9
  - key: int
    score: 19
    saveProf: false
  - key: wis
    score: 17
    saveProf: true
    saveMod: 7
  - key: cha
    score: 16
    saveProf: true
    saveMod: 7
pb: '+4'
skills:
  - skill: Deception
    value: '7'
  - skill: Perception
    value: '7'
sensesList:
  - type: truesight
    range: '120'
passivesList:
  - skill: Perception
    value: '17'
languagesList:
  - value: Abyssal
  - value: telepathy 120 ft.
damageResistancesList:
  - value: Cold
  - value: Fire
  - value: Lightning
damageImmunitiesList:
  - value: Poison; Poisoned
cr: '9'
xp: '5000'
entries:
  - category: trait
    name: Demonic Restoration
    entryType: special
    text: If the glabrezu dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The glabrezu has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The glabrezu makes two Pincer attacks and uses Pummel or Spellcasting.
    multiattack:
      attacks:
        - name: Pincer
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Pincer
    entryType: attack
    text: '*Melee Attack Roll:* +9, reach 10 ft. 16 (2d10 + 5) Slashing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 15) from one of two pincers.'
    attack:
      type: melee
      bonus: 9
      damage:
        - dice: 2d10
          bonus: 5
          type: Slashing
          average: 16
      reach: 10 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 15
            restrictions:
              size: Medium or smaller
      additionalEffects: If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 15) from one of two pincers.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Pummel
    entryType: save
    text: '*Dexterity Saving Throw*: DC 17, one creature Grappled by the glabrezu. *Failure:*  15 (3d6 + 5) Bludgeoning damage. *Success:*  Half damage.'
    save:
      ability: dex
      dc: 17
      targeting:
        type: single
        restrictions:
          other:
            - grappled by source
      onFail:
        effects:
          other: 15 (3d6 + 5) Bludgeoning damage.
        damage:
          - dice: 3d6
            bonus: 5
            type: Bludgeoning
            average: 15
        legacyEffects: 15 (3d6 + 5) Bludgeoning damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The glabrezu casts one of the following spells, requiring no Material components and using Intelligence as the spellcasting ability (spell save DC 16): - **At Will:** *Darkness*, *Detect Magic*, *Dispel Magic* - **1e/Day Each:** *Confusion*, *Fly*, *Power Word Stun*'
    spellcasting:
      ability: int
      saveDC: 16
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Darkness
            - Detect Magic
            - Dispel Magic
        - frequency: 1/day
          spells:
            - Confusion
            - Fly
            - Power Word Stun
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Glabrezu
*Large, Fiend, Chaotic Evil*

**AC** 17
**HP** 189 (18d10 + 90)
**Initiative** +6 (16)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** truesight 120 ft.; Passive Perception 17
**Languages** Abyssal, telepathy 120 ft.
CR 9, PB +4, XP 5000

## Traits

**Demonic Restoration**
If the glabrezu dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.

**Magic Resistance**
The glabrezu has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The glabrezu makes two Pincer attacks and uses Pummel or Spellcasting.

**Pincer**
*Melee Attack Roll:* +9, reach 10 ft. 16 (2d10 + 5) Slashing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 15) from one of two pincers.

**Pummel**
*Dexterity Saving Throw*: DC 17, one creature Grappled by the glabrezu. *Failure:*  15 (3d6 + 5) Bludgeoning damage. *Success:*  Half damage.

**Spellcasting**
The glabrezu casts one of the following spells, requiring no Material components and using Intelligence as the spellcasting ability (spell save DC 16): - **At Will:** *Darkness*, *Detect Magic*, *Dispel Magic* - **1e/Day Each:** *Confusion*, *Fly*, *Power Word Stun*
`,
      "Monsters/gladiator.md": `---
smType: creature
name: Gladiator
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '16'
initiative: +5 (15)
hp: '112'
hitDice: 15d8 + 45
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 18
    saveProf: true
    saveMod: 7
  - key: dex
    score: 15
    saveProf: true
    saveMod: 5
  - key: con
    score: 16
    saveProf: true
    saveMod: 6
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 12
    saveProf: true
    saveMod: 4
  - key: cha
    score: 15
    saveProf: false
pb: '+3'
skills:
  - skill: Athletics
    value: '10'
  - skill: Performance
    value: '5'
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Common
cr: '5'
xp: '1800'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The gladiator makes three Spear attacks. It can replace one attack with a use of Shield Bash.
    multiattack:
      attacks:
        - name: Spear
          count: 3
      substitutions:
        - replace: attack
          with:
            type: attack
            name: Shield Bash
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Spear
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +7, reach 5 ft. or range 20/60 ft. 11 (2d6 + 4) Piercing damage.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Shield Bash
    entryType: save
    text: '*Strength Saving Throw*: DC 15, one creature within 5 feet that the gladiator can see. *Failure:*  9 (2d4 + 4) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Prone condition.'
    save:
      ability: str
      dc: 15
      targeting:
        type: single
        range: 5 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Prone
              restrictions:
                size: Medium or smaller
        damage:
          - dice: 2d4
            bonus: 4
            type: Bludgeoning
            average: 9
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Gladiator
*Small, Humanoid, Neutral Neutral*

**AC** 16
**HP** 112 (15d8 + 45)
**Initiative** +5 (15)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common
CR 5, PB +3, XP 1800

## Actions

**Multiattack**
The gladiator makes three Spear attacks. It can replace one attack with a use of Shield Bash.

**Spear**
*Melee or Ranged Attack Roll:* +7, reach 5 ft. or range 20/60 ft. 11 (2d6 + 4) Piercing damage.

**Shield Bash**
*Strength Saving Throw*: DC 15, one creature within 5 feet that the gladiator can see. *Failure:*  9 (2d4 + 4) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Prone condition.
`,
      "Monsters/gnoll-warrior.md": `---
smType: creature
name: Gnoll Warrior
size: Medium
type: Fiend
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '15'
initiative: +1 (11)
hp: '27'
hitDice: 6d8
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 14
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Gnoll
cr: 1/2
xp: '100'
entries:
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Piercing
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Bone Bow
    entryType: attack
    text: '*Ranged Attack Roll:* +3, range 150/600 ft. 6 (1d10 + 1) Piercing damage.'
    attack:
      type: ranged
      bonus: 3
      damage:
        - dice: 1d10
          bonus: 1
          type: Piercing
          average: 6
      range: 150/600 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Rampage (1/Day)
    entryType: multiattack
    text: Immediately after dealing damage to a creature that is already Bloodied, the gnoll moves up to half its Speed, and it makes one Rend attack.
    limitedUse:
      count: 1
      reset: day
    multiattack:
      attacks:
        - name: Rend
          count: 1
      substitutions: []
    trigger.activation: bonus
    trigger.targeting:
      type: self
---

# Gnoll Warrior
*Medium, Fiend, Chaotic Evil*

**AC** 15
**HP** 27 (6d8)
**Initiative** +1 (11)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Gnoll
CR 1/2, PB +2, XP 100

## Actions

**Rend**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage.

**Bone Bow**
*Ranged Attack Roll:* +3, range 150/600 ft. 6 (1d10 + 1) Piercing damage.

## Bonus Actions

**Rampage (1/Day)**
Immediately after dealing damage to a creature that is already Bloodied, the gnoll moves up to half its Speed, and it makes one Rend attack.
`,
      "Monsters/goblin-boss.md": `---
smType: creature
name: Goblin Boss
size: Small
type: Fey
typeTags:
  - value: Goblinoid
alignmentLawChaos: Chaotic
alignmentGoodEvil: Neutral
ac: '17'
initiative: +2 (12)
hp: '21'
hitDice: 6d6
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 8
    saveProf: false
  - key: cha
    score: 10
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '6'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '9'
languagesList:
  - value: Common
  - value: Goblin
cr: '1'
xp: '200'
entries:
  - category: action
    name: Multiattack
    entryType: special
    text: The goblin makes two attacks, using Scimitar or Shortbow in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Scimitar
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage, plus 2 (1d4) Slashing damage if the attack roll had Advantage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Slashing
          average: 5
        - dice: 1d4
          bonus: 0
          type: Slashing
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Shortbow
    entryType: attack
    text: '*Ranged Attack Roll:* +4, range 80/320 ft. 5 (1d6 + 2) Piercing damage, plus 2 (1d4) Piercing damage if the attack roll had Advantage.'
    attack:
      type: ranged
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Piercing
          average: 5
        - dice: 1d4
          bonus: 0
          type: Piercing
          average: 2
      range: 80/320 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Nimble Escape
    entryType: special
    text: The goblin takes the Disengage or Hide action.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Goblin Boss
*Small, Fey, Chaotic Neutral*

**AC** 17
**HP** 21 (6d6)
**Initiative** +2 (12)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 9
**Languages** Common, Goblin
CR 1, PB +2, XP 200

## Actions

**Multiattack**
The goblin makes two attacks, using Scimitar or Shortbow in any combination.

**Scimitar**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage, plus 2 (1d4) Slashing damage if the attack roll had Advantage.

**Shortbow**
*Ranged Attack Roll:* +4, range 80/320 ft. 5 (1d6 + 2) Piercing damage, plus 2 (1d4) Piercing damage if the attack roll had Advantage.

## Bonus Actions

**Nimble Escape**
The goblin takes the Disengage or Hide action.
`,
      "Monsters/goblin-minion.md": `---
smType: creature
name: Goblin Minion
size: Small
type: Fey
typeTags:
  - value: Goblinoid
alignmentLawChaos: Chaotic
alignmentGoodEvil: Neutral
ac: '12'
initiative: +2 (12)
hp: '7'
hitDice: 2d6
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 8
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 8
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '6'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '9'
languagesList:
  - value: Common
  - value: Goblin
cr: 1/8
xp: '25'
entries:
  - category: action
    name: Dagger
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +4, reach 5 ft. or range 20/60 ft. 4 (1d4 + 2) Piercing damage.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Nimble Escape
    entryType: special
    text: The goblin takes the Disengage or Hide action.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Goblin Minion
*Small, Fey, Chaotic Neutral*

**AC** 12
**HP** 7 (2d6)
**Initiative** +2 (12)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 9
**Languages** Common, Goblin
CR 1/8, PB +2, XP 25

## Actions

**Dagger**
*Melee or Ranged Attack Roll:* +4, reach 5 ft. or range 20/60 ft. 4 (1d4 + 2) Piercing damage.

## Bonus Actions

**Nimble Escape**
The goblin takes the Disengage or Hide action.
`,
      "Monsters/goblin-warrior.md": `---
smType: creature
name: Goblin Warrior
size: Small
type: Fey
typeTags:
  - value: Goblinoid
alignmentLawChaos: Chaotic
alignmentGoodEvil: Neutral
ac: '15'
initiative: +2 (12)
hp: '10'
hitDice: 3d6
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 8
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 8
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '6'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '9'
languagesList:
  - value: Common
  - value: Goblin
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Scimitar
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage, plus 2 (1d4) Slashing damage if the attack roll had Advantage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Slashing
          average: 5
        - dice: 1d4
          bonus: 0
          type: Slashing
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Shortbow
    entryType: attack
    text: '*Ranged Attack Roll:* +4, range 80/320 ft. 5 (1d6 + 2) Piercing damage, plus 2 (1d4) Piercing damage if the attack roll had Advantage.'
    attack:
      type: ranged
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Piercing
          average: 5
        - dice: 1d4
          bonus: 0
          type: Piercing
          average: 2
      range: 80/320 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Nimble Escape
    entryType: special
    text: The goblin takes the Disengage or Hide action.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Goblin Warrior
*Small, Fey, Chaotic Neutral*

**AC** 15
**HP** 10 (3d6)
**Initiative** +2 (12)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 9
**Languages** Common, Goblin
CR 1/4, PB +2, XP 50

## Actions

**Scimitar**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage, plus 2 (1d4) Slashing damage if the attack roll had Advantage.

**Shortbow**
*Ranged Attack Roll:* +4, range 80/320 ft. 5 (1d6 + 2) Piercing damage, plus 2 (1d4) Piercing damage if the attack roll had Advantage.

## Bonus Actions

**Nimble Escape**
The goblin takes the Disengage or Hide action.
`,
      "Monsters/gold-dragon-wyrmling.md": `---
smType: creature
name: Gold Dragon Wyrmling
size: Medium
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '17'
initiative: +4 (14)
hp: '60'
hitDice: 8d8 + 24
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 60 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 14
    saveProf: true
    saveMod: 4
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 14
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 2
  - key: cha
    score: 16
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '4'
sensesList:
  - type: blindsight
    range: '10'
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Draconic
damageImmunitiesList:
  - value: Fire
cr: '3'
xp: '700'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes two Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 9 (1d10 + 4) Slashing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d10
          bonus: 4
          type: Slashing
          average: 9
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fire Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 13, each creature in a 15-foot Cone. *Failure:*  22 (4d10) Fire damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 13
      targeting:
        shape: cone
        size: 15 ft.
      onFail:
        effects:
          other: 22 (4d10) Fire damage.
        damage:
          - dice: 4d10
            bonus: 0
            type: Fire
            average: 22
        legacyEffects: 22 (4d10) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Weakening Breath
    entryType: save
    text: '*Strength Saving Throw*: DC 13, each creature that isn''t currently affected by this breath in a 15-foot Cone. *Failure:*  The target has Disadvantage on Strength-based D20 Test and subtracts 2 (1d4) from its damage rolls. It repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.'
    save:
      ability: str
      dc: 13
      targeting:
        shape: cone
        size: 15 ft.
      onFail:
        effects:
          mechanical:
            - type: disadvantage
              target: Strength-based D20 Test
              description: has Disadvantage on Strength-based D20 Test and
            - type: advantage
              target: Strength-based D20 Test
              description: advantage on Strength-based D20 Test and
            - type: penalty
              modifier: -2
              target: damage rolls
              description: subtracts 2 (1d4) from its damage rolls.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Gold Dragon Wyrmling
*Medium, Dragon, Lawful Good*

**AC** 17
**HP** 60 (8d8 + 24)
**Initiative** +4 (14)
**Speed** 30 ft., swim 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft., darkvision 60 ft.; Passive Perception 14
**Languages** Draconic
CR 3, PB +2, XP 700

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +6, reach 5 ft. 9 (1d10 + 4) Slashing damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 13, each creature in a 15-foot Cone. *Failure:*  22 (4d10) Fire damage. *Success:*  Half damage.

**Weakening Breath**
*Strength Saving Throw*: DC 13, each creature that isn't currently affected by this breath in a 15-foot Cone. *Failure:*  The target has Disadvantage on Strength-based D20 Test and subtracts 2 (1d4) from its damage rolls. It repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.
`,
      "Monsters/gorgon.md": `---
smType: creature
name: Gorgon
size: Large
type: Construct
alignmentOverride: Unaligned
ac: '19'
initiative: +0 (10)
hp: '114'
hitDice: 12d10 + 48
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 20
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 18
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '7'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '17'
damageImmunitiesList:
  - value: Exhaustion
conditionImmunitiesList:
  - value: Petrified
cr: '5'
xp: '1800'
entries:
  - category: action
    name: Gore
    entryType: attack
    text: '*Melee Attack Roll:* +8, reach 5 ft. 18 (2d12 + 5) Piercing damage. If the target is a Large or smaller creature and the gorgon moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.'
    attack:
      type: melee
      bonus: 8
      damage:
        - dice: 2d12
          bonus: 5
          type: Piercing
          average: 18
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature and the gorgon moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Petrifying Breath (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 15, each creature in a 30-foot Cone. *First Failure* The target has the Restrained condition and repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition instead of the Restrained condition.'
    recharge: 5-6
    save:
      ability: con
      dc: 15
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Trample
    entryType: save
    text: '*Dexterity Saving Throw*: DC 16, one creature within 5 feet that has the Prone condition. *Failure:*  16 (2d10 + 5) Bludgeoning damage. *Success:*  Half damage.'
    save:
      ability: dex
      dc: 16
      targeting:
        type: single
        range: 5 ft.
        restrictions:
          conditions:
            - Prone
      onFail:
        effects:
          other: 16 (2d10 + 5) Bludgeoning damage.
        damage:
          - dice: 2d10
            bonus: 5
            type: Bludgeoning
            average: 16
        legacyEffects: 16 (2d10 + 5) Bludgeoning damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Gorgon
*Large, Construct, Unaligned*

**AC** 19
**HP** 114 (12d10 + 48)
**Initiative** +0 (10)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 17
CR 5, PB +3, XP 1800

## Actions

**Gore**
*Melee Attack Roll:* +8, reach 5 ft. 18 (2d12 + 5) Piercing damage. If the target is a Large or smaller creature and the gorgon moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.

**Petrifying Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 15, each creature in a 30-foot Cone. *First Failure* The target has the Restrained condition and repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition instead of the Restrained condition.

## Bonus Actions

**Trample**
*Dexterity Saving Throw*: DC 16, one creature within 5 feet that has the Prone condition. *Failure:*  16 (2d10 + 5) Bludgeoning damage. *Success:*  Half damage.
`,
      "Monsters/gray-ooze.md": `---
smType: creature
name: Gray Ooze
size: Medium
type: Ooze
alignmentOverride: Unaligned
ac: '9'
initiative: '-2 (8)'
hp: '22'
hitDice: 3d8 + 9
speeds:
  walk:
    distance: 10 ft.
  climb:
    distance: 10 ft.
abilities:
  - key: str
    score: 12
    saveProf: false
  - key: dex
    score: 6
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 6
    saveProf: false
  - key: cha
    score: 2
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '2'
sensesList:
  - type: blindsight
    range: '60'
passivesList:
  - skill: Perception
    value: '8'
damageResistancesList:
  - value: Acid
  - value: Cold
  - value: Fire
damageImmunitiesList:
  - value: Exhaustion
conditionImmunitiesList:
  - value: Blinded
  - value: Charmed
  - value: Deafened
  - value: Frightened
  - value: Grappled
  - value: Prone
  - value: Restrained
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Amorphous
    entryType: special
    text: The ooze can move through a space as narrow as 1 inch without expending extra movement to do so.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Corrosive Form
    entryType: special
    text: Nonmagical ammunition is destroyed immediately after hitting the ooze and dealing any damage. Any nonmagical weapon takes a cumulative -1 penalty to attack rolls immediately after dealing damage to the ooze and coming into contact with it. The weapon is destroyed if the penalty reaches -5. The penalty can be removed by casting the *Mending* spell on the weapon. The ooze can eat through 2-inch-thick, nonmagical metal or wood in 1 round.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Pseudopod
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 10 (2d8 + 1) Acid damage. Nonmagical armor worn by the target takes a -1 penalty to the AC it offers. The armor is destroyed if the penalty reduces its AC to 10. The penalty can be removed by casting the *Mending* spell on the armor.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 2d8
          bonus: 1
          type: Acid
          average: 10
      reach: 5 ft.
      onHit:
        other: Nonmagical armor worn by the target takes a -1 penalty to the AC it offers. The armor is destroyed if the penalty reduces its AC to 10. The penalty can be removed by casting the *Mending* spell on the armor.
      additionalEffects: Nonmagical armor worn by the target takes a -1 penalty to the AC it offers. The armor is destroyed if the penalty reduces its AC to 10. The penalty can be removed by casting the *Mending* spell on the armor.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Gray Ooze
*Medium, Ooze, Unaligned*

**AC** 9
**HP** 22 (3d8 + 9)
**Initiative** -2 (8)
**Speed** 10 ft., climb 10 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft.; Passive Perception 8
CR 1/2, PB +2, XP 100

## Traits

**Amorphous**
The ooze can move through a space as narrow as 1 inch without expending extra movement to do so.

**Corrosive Form**
Nonmagical ammunition is destroyed immediately after hitting the ooze and dealing any damage. Any nonmagical weapon takes a cumulative -1 penalty to attack rolls immediately after dealing damage to the ooze and coming into contact with it. The weapon is destroyed if the penalty reaches -5. The penalty can be removed by casting the *Mending* spell on the weapon. The ooze can eat through 2-inch-thick, nonmagical metal or wood in 1 round.

## Actions

**Pseudopod**
*Melee Attack Roll:* +3, reach 5 ft. 10 (2d8 + 1) Acid damage. Nonmagical armor worn by the target takes a -1 penalty to the AC it offers. The armor is destroyed if the penalty reduces its AC to 10. The penalty can be removed by casting the *Mending* spell on the armor.
`,
      "Monsters/green-dragon-wyrmling.md": `---
smType: creature
name: Green Dragon Wyrmling
size: Medium
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '17'
initiative: +3 (13)
hp: '38'
hitDice: 7d8 + 7
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 60 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 12
    saveProf: true
    saveMod: 3
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 14
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 2
  - key: cha
    score: 13
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '3'
sensesList:
  - type: blindsight
    range: '10'
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Draconic
damageImmunitiesList:
  - value: Poison; Poisoned
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes two Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage plus 3 (1d6) Poison damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d10
          bonus: 2
          type: Slashing
          average: 7
        - dice: 1d6
          bonus: 0
          type: Poison
          average: 3
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Poison Breath (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 11, each creature in a 15-foot Cone. *Failure:*  21 (6d6) Poison damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: con
      dc: 11
      targeting:
        shape: cone
        size: 15 ft.
      onFail:
        effects:
          other: 21 (6d6) Poison damage.
        damage:
          - dice: 6d6
            bonus: 0
            type: Poison
            average: 21
        legacyEffects: 21 (6d6) Poison damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Green Dragon Wyrmling
*Medium, Dragon, Lawful Evil*

**AC** 17
**HP** 38 (7d8 + 7)
**Initiative** +3 (13)
**Speed** 30 ft., swim 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft., darkvision 60 ft.; Passive Perception 14
**Languages** Draconic
CR 2, PB +2, XP 450

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage plus 3 (1d6) Poison damage.

**Poison Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 11, each creature in a 15-foot Cone. *Failure:*  21 (6d6) Poison damage. *Success:*  Half damage.
`,
      "Monsters/green-hag.md": `---
smType: creature
name: Green Hag
size: Medium
type: Fey
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '17'
initiative: +1 (11)
hp: '82'
hitDice: 11d8 + 33
speeds:
  walk:
    distance: 30 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 13
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 14
    saveProf: false
pb: '+2'
skills:
  - skill: Arcana
    value: '5'
  - skill: Deception
    value: '4'
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Common
  - value: Elvish
  - value: Sylvan
cr: '3'
xp: '700'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The hag can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Mimicry
    entryType: special
    text: The hag can mimic animal sounds and humanoid voices. A creature that hears the sounds can tell they are imitations only with a successful DC 14 Wisdom (Insight) check.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The hag makes two Claw attacks.
    multiattack:
      attacks:
        - name: Claw
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 8 (1d8 + 4) Slashing damage plus 3 (1d6) Poison damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d8
          bonus: 4
          type: Slashing
          average: 8
        - dice: 1d6
          bonus: 0
          type: Poison
          average: 3
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The hag casts one of the following spells, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 12, +4 to hit with spell attacks): - **At Will:** *Dancing Lights*, *Disguise Self*, *Invisibility*, *Minor Illusion*, *Ray of Sickness*'
    spellcasting:
      ability: wis
      saveDC: 12
      attackBonus: 4
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Dancing Lights
            - Disguise Self
            - Invisibility
            - Minor Illusion
            - Ray of Sickness
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Green Hag
*Medium, Fey, Neutral Evil*

**AC** 17
**HP** 82 (11d8 + 33)
**Initiative** +1 (11)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 14
**Languages** Common, Elvish, Sylvan
CR 3, PB +2, XP 700

## Traits

**Amphibious**
The hag can breathe air and water.

**Mimicry**
The hag can mimic animal sounds and humanoid voices. A creature that hears the sounds can tell they are imitations only with a successful DC 14 Wisdom (Insight) check.

## Actions

**Multiattack**
The hag makes two Claw attacks.

**Claw**
*Melee Attack Roll:* +6, reach 5 ft. 8 (1d8 + 4) Slashing damage plus 3 (1d6) Poison damage.

**Spellcasting**
The hag casts one of the following spells, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 12, +4 to hit with spell attacks): - **At Will:** *Dancing Lights*, *Disguise Self*, *Invisibility*, *Minor Illusion*, *Ray of Sickness*
`,
      "Monsters/grick.md": `---
smType: creature
name: Grick
size: Medium
type: Aberration
alignmentOverride: Unaligned
ac: '14'
initiative: +2 (12)
hp: '54'
hitDice: 12d8
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 14
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '12'
cr: '2'
xp: '450'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The grick makes one Beak attack and one Tentacles attack.
    multiattack:
      attacks:
        - name: Beak
          count: 1
        - name: Tentacles
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Beak
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 9 (2d6 + 2) Piercing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 2d6
          bonus: 2
          type: Piercing
          average: 9
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Tentacles
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12) from all four tentacles.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d10
          bonus: 2
          type: Slashing
          average: 7
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 12
            restrictions:
              size: Medium or smaller
      additionalEffects: If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12) from all four tentacles.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Grick
*Medium, Aberration, Unaligned*

**AC** 14
**HP** 54 (12d8)
**Initiative** +2 (12)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 12
CR 2, PB +2, XP 450

## Actions

**Multiattack**
The grick makes one Beak attack and one Tentacles attack.

**Beak**
*Melee Attack Roll:* +4, reach 5 ft. 9 (2d6 + 2) Piercing damage.

**Tentacles**
*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12) from all four tentacles.
`,
      "Monsters/griffon.md": `---
smType: creature
name: Griffon
size: Large
type: Monstrosity
alignmentOverride: Unaligned
ac: '12'
initiative: +2 (12)
hp: '59'
hitDice: 7d10 + 21
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '15'
cr: '2'
xp: '450'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The griffon makes two Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 8 (1d8 + 4) Piercing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 14) from both of the griffon''s front claws.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d8
          bonus: 4
          type: Piercing
          average: 8
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 14
            restrictions:
              size: Medium or smaller
      additionalEffects: If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 14) from both of the griffon's front claws.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Griffon
*Large, Monstrosity, Unaligned*

**AC** 12
**HP** 59 (7d10 + 21)
**Initiative** +2 (12)
**Speed** 30 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 15
CR 2, PB +2, XP 450

## Actions

**Multiattack**
The griffon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +6, reach 5 ft. 8 (1d8 + 4) Piercing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 14) from both of the griffon's front claws.
`,
      "Monsters/grimlock.md": `---
smType: creature
name: Grimlock
size: Medium
type: Aberration
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '11'
initiative: +1 (11)
hp: '11'
hitDice: 2d8 + 2
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 9
    saveProf: false
  - key: wis
    score: 8
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
skills:
  - skill: Athletics
    value: '5'
  - skill: Perception
    value: '3'
  - skill: Stealth
    value: '5'
sensesList:
  - type: blindsight
    range: '30'
passivesList:
  - skill: Perception
    value: '13'
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Bone Cudgel
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage plus 2 (1d4) Psychic damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d6
          bonus: 3
          type: Bludgeoning
          average: 6
        - dice: 1d4
          bonus: 0
          type: Psychic
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Grimlock
*Medium, Aberration, Neutral Evil*

**AC** 11
**HP** 11 (2d8 + 2)
**Initiative** +1 (11)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft.; Passive Perception 13
CR 1/4, PB +2, XP 50

## Actions

**Bone Cudgel**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage plus 2 (1d4) Psychic damage.
`,
      "Monsters/guard-captain.md": `---
smType: creature
name: Guard Captain
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '18'
initiative: +4 (14)
hp: '75'
hitDice: 10d8 + 30
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 13
    saveProf: false
pb: '+2'
skills:
  - skill: Athletics
    value: '6'
  - skill: Perception
    value: '4'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Common
cr: '4'
xp: '1100'
entries:
  - category: action
    name: Multiattack
    entryType: special
    text: The guard makes two attacks, using Javelin or Longsword in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Javelin
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +6, reach 5 ft. or range 30/120 ft. 14 (3d6 + 4) Piercing damage.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Longsword
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 15 (2d10 + 4) Slashing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d10
          bonus: 4
          type: Slashing
          average: 15
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Guard Captain
*Small, Humanoid, Neutral Neutral*

**AC** 18
**HP** 75 (10d8 + 30)
**Initiative** +4 (14)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common
CR 4, PB +2, XP 1100

## Actions

**Multiattack**
The guard makes two attacks, using Javelin or Longsword in any combination.

**Javelin**
*Melee or Ranged Attack Roll:* +6, reach 5 ft. or range 30/120 ft. 14 (3d6 + 4) Piercing damage.

**Longsword**
*Melee Attack Roll:* +6, reach 5 ft. 15 (2d10 + 4) Slashing damage.
`,
      "Monsters/guard.md": `---
smType: creature
name: Guard
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '16'
initiative: +1 (11)
hp: '11'
hitDice: 2d8 + 2
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 13
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 10
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '2'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Common
cr: 1/8
xp: '25'
entries:
  - category: action
    name: Spear
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +3, reach 5 ft. or range 20/60 ft. 4 (1d6 + 1) Piercing damage.'
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Guard
*Small, Humanoid, Neutral Neutral*

**AC** 16
**HP** 11 (2d8 + 2)
**Initiative** +1 (11)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common
CR 1/8, PB +2, XP 25

## Actions

**Spear**
*Melee or Ranged Attack Roll:* +3, reach 5 ft. or range 20/60 ft. 4 (1d6 + 1) Piercing damage.
`,
      "Monsters/guardian-naga.md": `---
smType: creature
name: Guardian Naga
size: Large
type: Celestial
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '18'
initiative: +4 (14)
hp: '136'
hitDice: 16d10 + 48
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 40 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 18
    saveProf: true
    saveMod: 8
  - key: con
    score: 16
    saveProf: true
    saveMod: 7
  - key: int
    score: 16
    saveProf: true
    saveMod: 7
  - key: wis
    score: 19
    saveProf: true
    saveMod: 8
  - key: cha
    score: 18
    saveProf: true
    saveMod: 8
pb: '+4'
skills:
  - skill: Arcana
    value: '11'
  - skill: History
    value: '11'
  - skill: Religion
    value: '11'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Celestial
  - value: Common
damageImmunitiesList:
  - value: Poison; Charmed
conditionImmunitiesList:
  - value: Paralyzed
  - value: Poisoned
  - value: Restrained
cr: '10'
xp: '5900'
entries:
  - category: trait
    name: Celestial Restoration
    entryType: special
    text: If the naga dies, it returns to life in 1d6 days and regains all its Hit Points unless *Dispel Evil and Good* is cast on its remains.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The naga makes two Bite attacks. It can replace any attack with a use of Poisonous Spittle.
    multiattack:
      attacks:
        - name: Bite
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +8, reach 10 ft. 17 (2d12 + 4) Piercing damage plus 22 (4d10) Poison damage.'
    attack:
      type: melee
      bonus: 8
      damage:
        - dice: 2d12
          bonus: 4
          type: Piercing
          average: 17
        - dice: 4d10
          bonus: 0
          type: Poison
          average: 22
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Poisonous Spittle
    entryType: save
    text: '*Constitution Saving Throw*: DC 16, one creature the naga can see within 60 feet. *Failure:*  31 (7d8) Poison damage, and the target has the Blinded condition until the start of the naga''s next turn. *Success:*  Half damage only.'
    save:
      ability: con
      dc: 16
      targeting:
        type: single
        range: 60 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Blinded
              duration:
                type: until
                trigger: the start of the naga's next turn
        damage:
          - dice: 7d8
            bonus: 0
            type: Poison
            average: 31
      onSuccess:
        damage: half
        legacyText: Half damage only.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The naga casts one of the following spells, requiring no Somatic or Material components and using Wisdom as the spellcasting ability (spell save DC 16): - **At Will:** *Thaumaturgy* - **1e/Day Each:** *Clairvoyance*, *Cure Wounds*, *Flame Strike*, *Geas*, *True Seeing*'
    spellcasting:
      ability: wis
      saveDC: 16
      spellLists:
        - frequency: at-will
          spells:
            - Thaumaturgy
        - frequency: 1/day
          spells:
            - Clairvoyance
            - Cure Wounds
            - Flame Strike
            - Geas
            - True Seeing
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Guardian Naga
*Large, Celestial, Lawful Good*

**AC** 18
**HP** 136 (16d10 + 48)
**Initiative** +4 (14)
**Speed** 40 ft., climb 40 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 14
**Languages** Celestial, Common
CR 10, PB +4, XP 5900

## Traits

**Celestial Restoration**
If the naga dies, it returns to life in 1d6 days and regains all its Hit Points unless *Dispel Evil and Good* is cast on its remains.

## Actions

**Multiattack**
The naga makes two Bite attacks. It can replace any attack with a use of Poisonous Spittle.

**Bite**
*Melee Attack Roll:* +8, reach 10 ft. 17 (2d12 + 4) Piercing damage plus 22 (4d10) Poison damage.

**Poisonous Spittle**
*Constitution Saving Throw*: DC 16, one creature the naga can see within 60 feet. *Failure:*  31 (7d8) Poison damage, and the target has the Blinded condition until the start of the naga's next turn. *Success:*  Half damage only.

**Spellcasting**
The naga casts one of the following spells, requiring no Somatic or Material components and using Wisdom as the spellcasting ability (spell save DC 16): - **At Will:** *Thaumaturgy* - **1e/Day Each:** *Clairvoyance*, *Cure Wounds*, *Flame Strike*, *Geas*, *True Seeing*
`,
      "Monsters/half-dragon.md": `---
smType: creature
name: Half-Dragon
size: Medium
type: Dragon
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '18'
initiative: +5 (15)
hp: '105'
hitDice: 14d8 + 42
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 14
    saveProf: true
    saveMod: 5
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 15
    saveProf: true
    saveMod: 5
  - key: cha
    score: 14
    saveProf: false
pb: '+3'
skills:
  - skill: Athletics
    value: '7'
  - skill: Perception
    value: '5'
  - skill: Stealth
    value: '5'
sensesList:
  - type: blindsight
    range: '10'
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '15'
languagesList:
  - value: Common
  - value: Draconic
damageResistancesList:
  - value: Damage type chosen for the Draconic Origin trait below
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Draconic Origin
    entryType: special
    text: 'The half-dragon is related to a type of dragon associated with one of the following damage types (DM''s choice): Acid, Cold, Fire, Lightning, or Poison. This choice affects other aspects of the stat block.'
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The half-dragon makes two Claw attacks.
    multiattack:
      attacks:
        - name: Claw
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 10 ft. 6 (1d4 + 4) Slashing damage plus 7 (2d6) damage of the type chosen for the Draconic Origin trait.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 1d4
          bonus: 4
          type: Slashing
          average: 6
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Dragon's Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 14, each creature in a 30-foot Cone. *Failure:*  28 (8d6) damage of the type chosen for the Draconic Origin trait. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 14
      targeting:
        shape: cone
        size: 30 ft.
      onFail:
        effects:
          other: 28 (8d6) damage of the type chosen for the Draconic Origin trait.
        legacyEffects: 28 (8d6) damage of the type chosen for the Draconic Origin trait.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Leap
    entryType: special
    text: The half-dragon jumps up to 30 feet by spending 10 feet of movement.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Half-Dragon
*Medium, Dragon, Neutral Neutral*

**AC** 18
**HP** 105 (14d8 + 42)
**Initiative** +5 (15)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft., darkvision 60 ft.; Passive Perception 15
**Languages** Common, Draconic
CR 5, PB +3, XP 1800

## Traits

**Draconic Origin**
The half-dragon is related to a type of dragon associated with one of the following damage types (DM's choice): Acid, Cold, Fire, Lightning, or Poison. This choice affects other aspects of the stat block.

## Actions

**Multiattack**
The half-dragon makes two Claw attacks.

**Claw**
*Melee Attack Roll:* +7, reach 10 ft. 6 (1d4 + 4) Slashing damage plus 7 (2d6) damage of the type chosen for the Draconic Origin trait.

**Dragon's Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 14, each creature in a 30-foot Cone. *Failure:*  28 (8d6) damage of the type chosen for the Draconic Origin trait. *Success:*  Half damage.

## Bonus Actions

**Leap**
The half-dragon jumps up to 30 feet by spending 10 feet of movement.
`,
      "Monsters/harpy.md": `---
smType: creature
name: Harpy
size: Medium
type: Monstrosity
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '11'
initiative: +1 (11)
hp: '38'
hitDice: 7d8 + 7
speeds:
  walk:
    distance: 20 ft.
  fly:
    distance: 40 ft.
abilities:
  - key: str
    score: 12
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 7
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 13
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common
cr: '1'
xp: '200'
entries:
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 6 (2d4 + 1) Slashing damage.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 2d4
          bonus: 1
          type: Slashing
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Luring Song
    entryType: save
    text: 'The harpy sings a magical melody, which lasts until the harpy''s  Concentration ends on it. *Wisdom Saving Throw*: DC 11, each Humanoid and Giant in a 300-foot Emanation originating from the harpy when the song starts. *Failure:*  The target has the Charmed condition until the song ends and repeats the save at the end of each of its turns. While Charmed, the target has the Incapacitated condition and ignores the Luring Song of other harpies. If the target is more than 5 feet from the harpy, the target moves on its turn toward the harpy by the most direct route, trying to get within 5 feet of the harpy. It doesn''t avoid Opportunity Attacks; however, before moving into damaging terrain (such as lava or a pit) and whenever it takes damage from a source other than the harpy, the target repeats the save. *Success:*  The target is immune to this harpy''s Luring Song for 24 hours.'
    save:
      ability: wis
      dc: 11
      targeting:
        shape: emanation
        size: 300 ft.
        origin: self
      onFail:
        effects:
          conditions:
            - condition: Charmed
              duration:
                type: until
                trigger: the song ends and repeats the save at the end of each of its turns
              saveToEnd:
                timing: end-of-turn
              restrictions:
                while: While Charmed, the target has the Incapacitated condition
            - condition: Incapacitated
              duration:
                type: until
                trigger: the song ends and repeats the save at the end of each of its turns
              saveToEnd:
                timing: end-of-turn
              restrictions:
                while: While Charmed, the target has the Incapacitated condition
          movement:
            type: compelled
            description: moves on its turn toward the harpy by
      onSuccess: The target is immune to this harpy's Luring Song for 24 hours.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Harpy
*Medium, Monstrosity, Chaotic Evil*

**AC** 11
**HP** 38 (7d8 + 7)
**Initiative** +1 (11)
**Speed** 20 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common
CR 1, PB +2, XP 200

## Actions

**Claw**
*Melee Attack Roll:* +3, reach 5 ft. 6 (2d4 + 1) Slashing damage.

**Luring Song**
The harpy sings a magical melody, which lasts until the harpy's  Concentration ends on it. *Wisdom Saving Throw*: DC 11, each Humanoid and Giant in a 300-foot Emanation originating from the harpy when the song starts. *Failure:*  The target has the Charmed condition until the song ends and repeats the save at the end of each of its turns. While Charmed, the target has the Incapacitated condition and ignores the Luring Song of other harpies. If the target is more than 5 feet from the harpy, the target moves on its turn toward the harpy by the most direct route, trying to get within 5 feet of the harpy. It doesn't avoid Opportunity Attacks; however, before moving into damaging terrain (such as lava or a pit) and whenever it takes damage from a source other than the harpy, the target repeats the save. *Success:*  The target is immune to this harpy's Luring Song for 24 hours.
`,
      "Monsters/hell-hound.md": `---
smType: creature
name: Hell Hound
size: Medium
type: Fiend
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '15'
initiative: +1 (11)
hp: '58'
hitDice: 9d8 + 18
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '15'
languagesList:
  - value: Understands Infernal but can't speak
damageImmunitiesList:
  - value: Fire
cr: '3'
xp: '700'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The hound has Advantage on an attack roll against a creature if at least one of the hound's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The hound makes two Bite attacks.
    multiattack:
      attacks:
        - name: Bite
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage plus 3 (1d6) Fire damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d8
          bonus: 3
          type: Piercing
          average: 7
        - dice: 1d6
          bonus: 0
          type: Fire
          average: 3
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fire Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 12, each creature in a 15-foot Cone. *Failure:*  17 (5d6) Fire damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 12
      targeting:
        shape: cone
        size: 15 ft.
      onFail:
        effects:
          other: 17 (5d6) Fire damage.
        damage:
          - dice: 5d6
            bonus: 0
            type: Fire
            average: 17
        legacyEffects: 17 (5d6) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Hell Hound
*Medium, Fiend, Lawful Evil*

**AC** 15
**HP** 58 (9d8 + 18)
**Initiative** +1 (11)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 15
**Languages** Understands Infernal but can't speak
CR 3, PB +2, XP 700

## Traits

**Pack Tactics**
The hound has Advantage on an attack roll against a creature if at least one of the hound's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Multiattack**
The hound makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage plus 3 (1d6) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 12, each creature in a 15-foot Cone. *Failure:*  17 (5d6) Fire damage. *Success:*  Half damage.
`,
      "Monsters/hezrou.md": `---
smType: creature
name: Hezrou
size: Large
type: Fiend
typeTags:
  - value: Demon
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '18'
initiative: +6 (16)
hp: '157'
hitDice: 15d10 + 75
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 19
    saveProf: true
    saveMod: 7
  - key: dex
    score: 17
    saveProf: false
  - key: con
    score: 20
    saveProf: true
    saveMod: 8
  - key: int
    score: 5
    saveProf: false
  - key: wis
    score: 12
    saveProf: true
    saveMod: 4
  - key: cha
    score: 13
    saveProf: false
pb: '+3'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Abyssal
  - value: telepathy 120 ft.
damageResistancesList:
  - value: Cold
  - value: Fire
  - value: Lightning
damageImmunitiesList:
  - value: Poison; Poisoned
cr: '8'
xp: '3900'
entries:
  - category: trait
    name: Demonic Restoration
    entryType: special
    text: If the hezrou dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The hezrou has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Stench
    entryType: save
    text: '*Constitution Saving Throw*: DC 16, any creature that starts its turn in a 10-foot Emanation originating from the hezrou. *Failure:*  The target has the Poisoned condition until the start of its next turn.'
    save:
      ability: con
      dc: 16
      targeting:
        shape: emanation
        size: 10 ft.
        origin: self
      onFail:
        effects:
          conditions:
            - condition: Poisoned
              duration:
                type: until
                trigger: the start of its next turn
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The hezrou makes three Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 6 (1d4 + 4) Slashing damage plus 9 (2d8) Poison damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 1d4
          bonus: 4
          type: Slashing
          average: 6
        - dice: 2d8
          bonus: 0
          type: Poison
          average: 9
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Leap
    entryType: special
    text: The hezrou jumps up to 30 feet by spending 10 feet of movement.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Hezrou
*Large, Fiend, Chaotic Evil*

**AC** 18
**HP** 157 (15d10 + 75)
**Initiative** +6 (16)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 11
**Languages** Abyssal, telepathy 120 ft.
CR 8, PB +3, XP 3900

## Traits

**Demonic Restoration**
If the hezrou dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.

**Magic Resistance**
The hezrou has Advantage on saving throws against spells and other magical effects.

**Stench**
*Constitution Saving Throw*: DC 16, any creature that starts its turn in a 10-foot Emanation originating from the hezrou. *Failure:*  The target has the Poisoned condition until the start of its next turn.

## Actions

**Multiattack**
The hezrou makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +7, reach 5 ft. 6 (1d4 + 4) Slashing damage plus 9 (2d8) Poison damage.

## Bonus Actions

**Leap**
The hezrou jumps up to 30 feet by spending 10 feet of movement.
`,
      "Monsters/hill-giant.md": `---
smType: creature
name: Hill Giant
size: Huge
type: Giant
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '13'
initiative: +2 (12)
hp: '105'
hitDice: 10d12 + 40
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 21
    saveProf: false
  - key: dex
    score: 8
    saveProf: false
  - key: con
    score: 19
    saveProf: false
  - key: int
    score: 5
    saveProf: false
  - key: wis
    score: 9
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '2'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Giant
cr: '5'
xp: '1800'
entries:
  - category: action
    name: Multiattack
    entryType: special
    text: The giant makes two attacks, using Tree Club or Trash Lob in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Tree Club
    entryType: attack
    text: '*Melee Attack Roll:* +8, reach 10 ft. 18 (3d8 + 5) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.'
    attack:
      type: melee
      bonus: 8
      damage:
        - dice: 3d8
          bonus: 5
          type: Bludgeoning
          average: 18
      reach: 10 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Trash Lob
    entryType: attack
    text: '*Ranged Attack Roll:* +8, range 60/240 ft. 16 (2d10 + 5) Bludgeoning damage, and the target has the Poisoned condition until the end of its next turn.'
    attack:
      type: ranged
      bonus: 8
      damage:
        - dice: 2d10
          bonus: 5
          type: Bludgeoning
          average: 16
      range: 60/240 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Hill Giant
*Huge, Giant, Chaotic Evil*

**AC** 13
**HP** 105 (10d12 + 40)
**Initiative** +2 (12)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Giant
CR 5, PB +3, XP 1800

## Actions

**Multiattack**
The giant makes two attacks, using Tree Club or Trash Lob in any combination.

**Tree Club**
*Melee Attack Roll:* +8, reach 10 ft. 18 (3d8 + 5) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.

**Trash Lob**
*Ranged Attack Roll:* +8, range 60/240 ft. 16 (2d10 + 5) Bludgeoning damage, and the target has the Poisoned condition until the end of its next turn.
`,
      "Monsters/hippogriff.md": `---
smType: creature
name: Hippogriff
size: Large
type: Monstrosity
alignmentOverride: Unaligned
ac: '11'
initiative: +1 (11)
hp: '26'
hitDice: 4d10 + 4
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
passivesList:
  - skill: Perception
    value: '15'
cr: '1'
xp: '200'
entries:
  - category: trait
    name: Flyby
    entryType: special
    text: The hippogriff doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The hippogriff makes two Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Slashing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d8
          bonus: 3
          type: Slashing
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Hippogriff
*Large, Monstrosity, Unaligned*

**AC** 11
**HP** 26 (4d10 + 4)
**Initiative** +1 (11)
**Speed** 40 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 1, PB +2, XP 200

## Traits

**Flyby**
The hippogriff doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.

## Actions

**Multiattack**
The hippogriff makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Slashing damage.
`,
      "Monsters/hobgoblin-captain.md": `---
smType: creature
name: Hobgoblin Captain
size: Medium
type: Fey
typeTags:
  - value: Goblinoid
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '17'
initiative: +4 (14)
hp: '58'
hitDice: 9d8 + 18
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 13
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common
  - value: Goblin
cr: '3'
xp: '700'
entries:
  - category: trait
    name: Aura of Authority
    entryType: special
    text: While in a 10-foot Emanation originating from the hobgoblin, the hobgoblin and its allies have Advantage on attack rolls and saving throws, provided the hobgoblin doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: special
    text: The hobgoblin makes two attacks, using Greatsword or Longbow in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Greatsword
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 9 (2d6 + 2) Slashing damage plus 3 (1d6) Poison damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 2d6
          bonus: 2
          type: Slashing
          average: 9
        - dice: 1d6
          bonus: 0
          type: Poison
          average: 3
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Longbow
    entryType: attack
    text: '*Ranged Attack Roll:* +4, range 150/600 ft. 6 (1d8 + 2) Piercing damage plus 5 (2d4) Poison damage.'
    attack:
      type: ranged
      bonus: 4
      damage:
        - dice: 1d8
          bonus: 2
          type: Piercing
          average: 6
        - dice: 2d4
          bonus: 0
          type: Poison
          average: 5
      range: 150/600 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Hobgoblin Captain
*Medium, Fey, Lawful Evil*

**AC** 17
**HP** 58 (9d8 + 18)
**Initiative** +4 (14)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Common, Goblin
CR 3, PB +2, XP 700

## Traits

**Aura of Authority**
While in a 10-foot Emanation originating from the hobgoblin, the hobgoblin and its allies have Advantage on attack rolls and saving throws, provided the hobgoblin doesn't have the Incapacitated condition.

## Actions

**Multiattack**
The hobgoblin makes two attacks, using Greatsword or Longbow in any combination.

**Greatsword**
*Melee Attack Roll:* +4, reach 5 ft. 9 (2d6 + 2) Slashing damage plus 3 (1d6) Poison damage.

**Longbow**
*Ranged Attack Roll:* +4, range 150/600 ft. 6 (1d8 + 2) Piercing damage plus 5 (2d4) Poison damage.
`,
      "Monsters/hobgoblin-warrior.md": `---
smType: creature
name: Hobgoblin Warrior
size: Medium
type: Fey
typeTags:
  - value: Goblinoid
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '18'
initiative: +3 (13)
hp: '11'
hitDice: 2d8 + 2
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 13
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 9
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common
  - value: Goblin
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The hobgoblin has Advantage on an attack roll against a creature if at least one of the hobgoblin's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Longsword
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 12 (2d10 + 1) Slashing damage.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 2d10
          bonus: 1
          type: Slashing
          average: 12
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Longbow
    entryType: attack
    text: '*Ranged Attack Roll:* +3, range 150/600 ft. 5 (1d8 + 1) Piercing damage plus 7 (3d4) Poison damage.'
    attack:
      type: ranged
      bonus: 3
      damage:
        - dice: 1d8
          bonus: 1
          type: Piercing
          average: 5
        - dice: 3d4
          bonus: 0
          type: Poison
          average: 7
      range: 150/600 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Hobgoblin Warrior
*Medium, Fey, Lawful Evil*

**AC** 18
**HP** 11 (2d8 + 2)
**Initiative** +3 (13)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Common, Goblin
CR 1/2, PB +2, XP 100

## Traits

**Pack Tactics**
The hobgoblin has Advantage on an attack roll against a creature if at least one of the hobgoblin's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Longsword**
*Melee Attack Roll:* +3, reach 5 ft. 12 (2d10 + 1) Slashing damage.

**Longbow**
*Ranged Attack Roll:* +3, range 150/600 ft. 5 (1d8 + 1) Piercing damage plus 7 (3d4) Poison damage.
`,
      "Monsters/homunculus.md": `---
smType: creature
name: Homunculus
size: Small
type: Construct
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '13'
initiative: +2 (12)
hp: '4'
hitDice: 1d4 + 2
speeds:
  walk:
    distance: 20 ft.
  fly:
    distance: 40 ft.
abilities:
  - key: str
    score: 4
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 10
    saveProf: true
    saveMod: 2
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Understands Common plus one other language but can't speak
damageImmunitiesList:
  - value: Poison; Charmed
conditionImmunitiesList:
  - value: Poisoned
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Telepathic Bond
    entryType: special
    text: While the homunculus is on the same plane of existence as its master, the two of them can communicate telepathically with each other.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 1 Piercing damage, and the target is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target has the Poisoned condition until the end of the homunculus''s next turn. *Failure by 5 or More:* The target has the Poisoned condition for 1 minute. While Poisoned, the target has the Unconscious condition, which ends early if the target takes any damage.'
    attack:
      type: melee
      bonus: 4
      damage: []
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Homunculus
*Small, Construct, Neutral Neutral*

**AC** 13
**HP** 4 (1d4 + 2)
**Initiative** +2 (12)
**Speed** 20 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Understands Common plus one other language but can't speak
CR 0, PB +2, XP 0

## Traits

**Telepathic Bond**
While the homunculus is on the same plane of existence as its master, the two of them can communicate telepathically with each other.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 1 Piercing damage, and the target is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target has the Poisoned condition until the end of the homunculus's next turn. *Failure by 5 or More:* The target has the Poisoned condition for 1 minute. While Poisoned, the target has the Unconscious condition, which ends early if the target takes any damage.
`,
      "Monsters/horned-devil.md": `---
smType: creature
name: Horned Devil
size: Large
type: Fiend
typeTags:
  - value: Devil
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '18'
initiative: +7 (17)
hp: '199'
hitDice: 19d10 + 95
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 22
    saveProf: true
    saveMod: 10
  - key: dex
    score: 17
    saveProf: true
    saveMod: 7
  - key: con
    score: 21
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 16
    saveProf: true
    saveMod: 7
  - key: cha
    score: 18
    saveProf: true
    saveMod: 8
pb: '+4'
sensesList:
  - type: darkvision 150 ft. (unimpeded by magical darkness)
passivesList:
  - skill: Perception
    value: '13'
languagesList:
  - value: Infernal
  - value: telepathy 120 ft.
damageImmunitiesList:
  - value: Fire
  - value: Poison; Poisoned
cr: '11'
xp: '7200'
entries:
  - category: trait
    name: Diabolical Restoration
    entryType: special
    text: If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The devil has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The devil makes three attacks, using Searing Fork or Hurl Flame in any combination. It can replace one attack with a use of Infernal Tail.
    multiattack:
      attacks:
        - name: three
          count: 1
      substitutions:
        - replace: attack
          with:
            type: attack
            name: Infernal Tail
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Searing Fork
    entryType: attack
    text: '*Melee Attack Roll:* +10, reach 10 ft. 15 (2d8 + 6) Piercing damage plus 9 (2d8) Fire damage.'
    attack:
      type: melee
      bonus: 10
      damage:
        - dice: 2d8
          bonus: 6
          type: Piercing
          average: 15
        - dice: 2d8
          bonus: 0
          type: Fire
          average: 9
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Hurl Flame
    entryType: attack
    text: '*Ranged Attack Roll:* +8, range 150 ft. 26 (5d8 + 4) Fire damage. If the target is a flammable object that isn''t being worn or carried, it starts burning.'
    attack:
      type: ranged
      bonus: 8
      damage:
        - dice: 5d8
          bonus: 4
          type: Fire
          average: 26
      range: 150 ft.
      onHit:
        other: If the target is a flammable object that isn't being worn or carried, it starts burning.
      additionalEffects: If the target is a flammable object that isn't being worn or carried, it starts burning.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Infernal Tail
    entryType: save
    text: '*Dexterity Saving Throw*: DC 17, one creature the devil can see within 10 feet. *Failure:*  10 (1d8 + 6) Necrotic damage, and the target receives an infernal wound if it doesn''t have one. While wounded, the target loses 10 (3d6) Hit Points at the start of each of its turns. The wound closes after 1 minute, after a spell restores Hit Points to the target, or after the target or a creature within 5 feet of it takes an action to stanch the wound, doing so by succeeding on a DC 17 Wisdom (Medicine) check.'
    save:
      ability: dex
      dc: 17
      targeting:
        type: single
        range: 10 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          other: 10 (1d8 + 6) Necrotic damage, and the target receives an infernal wound if it doesn't have one. While wounded, the target loses 10 (3d6) Hit Points at the start of each of its turns. The wound closes after 1 minute, after a spell restores Hit Points to the target, or after the target or a creature within 5 feet of it takes an action to stanch the wound, doing so by succeeding on a DC 17 Wisdom (Medicine) check.
        damage:
          - dice: 1d8
            bonus: 6
            type: Necrotic
            average: 10
        legacyEffects: 10 (1d8 + 6) Necrotic damage, and the target receives an infernal wound if it doesn't have one. While wounded, the target loses 10 (3d6) Hit Points at the start of each of its turns. The wound closes after 1 minute, after a spell restores Hit Points to the target, or after the target or a creature within 5 feet of it takes an action to stanch the wound, doing so by succeeding on a DC 17 Wisdom (Medicine) check.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Horned Devil
*Large, Fiend, Lawful Evil*

**AC** 18
**HP** 199 (19d10 + 95)
**Initiative** +7 (17)
**Speed** 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 150 ft. (unimpeded by magical darkness); Passive Perception 13
**Languages** Infernal, telepathy 120 ft.
CR 11, PB +4, XP 7200

## Traits

**Diabolical Restoration**
If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.

**Magic Resistance**
The devil has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The devil makes three attacks, using Searing Fork or Hurl Flame in any combination. It can replace one attack with a use of Infernal Tail.

**Searing Fork**
*Melee Attack Roll:* +10, reach 10 ft. 15 (2d8 + 6) Piercing damage plus 9 (2d8) Fire damage.

**Hurl Flame**
*Ranged Attack Roll:* +8, range 150 ft. 26 (5d8 + 4) Fire damage. If the target is a flammable object that isn't being worn or carried, it starts burning.

**Infernal Tail**
*Dexterity Saving Throw*: DC 17, one creature the devil can see within 10 feet. *Failure:*  10 (1d8 + 6) Necrotic damage, and the target receives an infernal wound if it doesn't have one. While wounded, the target loses 10 (3d6) Hit Points at the start of each of its turns. The wound closes after 1 minute, after a spell restores Hit Points to the target, or after the target or a creature within 5 feet of it takes an action to stanch the wound, doing so by succeeding on a DC 17 Wisdom (Medicine) check.
`,
      "Monsters/hydra.md": `---
smType: creature
name: Hydra
size: Huge
type: Monstrosity
alignmentOverride: Unaligned
ac: '15'
initiative: +4 (14)
hp: '184'
hitDice: 16d12 + 80
speeds:
  walk:
    distance: 40 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 20
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 20
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '6'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '16'
conditionImmunitiesList:
  - value: Blinded
  - value: Charmed
  - value: Deafened
  - value: Frightened
  - value: Stunned
  - value: Unconscious
cr: '8'
xp: '3900'
entries:
  - category: trait
    name: Hold Breath
    entryType: special
    text: The hydra can hold its breath for 1 hour.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Multiple Heads
    entryType: special
    text: The hydra has five heads. Whenever the hydra takes 25 damage or more on a single turn, one of its heads dies. The hydra dies if all its heads are dead. At the end of each of its turns when it has at least one living head, the hydra grows two heads for each of its heads that died since its last turn, unless it has taken Fire damage since its last turn. The hydra regains 20 Hit Points when it grows new heads.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Reactive Heads
    entryType: special
    text: For each head the hydra has beyond one, it gets an extra Reaction that can be used only for Opportunity Attacks.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The hydra makes as many Bite attacks as it has heads.
    multiattack:
      attacks:
        - name: Bite
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +8, reach 10 ft. 10 (1d10 + 5) Piercing damage.'
    attack:
      type: melee
      bonus: 8
      damage:
        - dice: 1d10
          bonus: 5
          type: Piercing
          average: 10
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Hydra
*Huge, Monstrosity, Unaligned*

**AC** 15
**HP** 184 (16d12 + 80)
**Initiative** +4 (14)
**Speed** 40 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 16
CR 8, PB +3, XP 3900

## Traits

**Hold Breath**
The hydra can hold its breath for 1 hour.

**Multiple Heads**
The hydra has five heads. Whenever the hydra takes 25 damage or more on a single turn, one of its heads dies. The hydra dies if all its heads are dead. At the end of each of its turns when it has at least one living head, the hydra grows two heads for each of its heads that died since its last turn, unless it has taken Fire damage since its last turn. The hydra regains 20 Hit Points when it grows new heads.

**Reactive Heads**
For each head the hydra has beyond one, it gets an extra Reaction that can be used only for Opportunity Attacks.

## Actions

**Multiattack**
The hydra makes as many Bite attacks as it has heads.

**Bite**
*Melee Attack Roll:* +8, reach 10 ft. 10 (1d10 + 5) Piercing damage.
`,
      "Monsters/ice-devil.md": `---
smType: creature
name: Ice Devil
size: Large
type: Fiend
typeTags:
  - value: Devil
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '18'
initiative: +7 (17)
hp: '228'
hitDice: 24d10 + 96
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 21
    saveProf: false
  - key: dex
    score: 14
    saveProf: true
    saveMod: 7
  - key: con
    score: 18
    saveProf: true
    saveMod: 9
  - key: int
    score: 18
    saveProf: false
  - key: wis
    score: 15
    saveProf: true
    saveMod: 7
  - key: cha
    score: 18
    saveProf: true
    saveMod: 9
pb: '+5'
skills:
  - skill: Insight
    value: '7'
  - skill: Perception
    value: '7'
  - skill: Persuasion
    value: '9'
sensesList:
  - type: blindsight
    range: '120'
passivesList:
  - skill: Perception
    value: '17'
languagesList:
  - value: Infernal
  - value: telepathy 120 ft.
damageImmunitiesList:
  - value: Cold
  - value: Fire
  - value: Poison; Poisoned
cr: '14'
xp: '11500'
entries:
  - category: trait
    name: Diabolical Restoration
    entryType: special
    text: If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The devil has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The devil makes three Ice Spear attacks. It can replace one attack with a Tail attack.
    multiattack:
      attacks:
        - name: Spear
          count: 1
      substitutions:
        - replace: attack
          with:
            type: attack
            name: a Tail attack
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Ice Spear
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +10, reach 5 ft. or range 30/120 ft. 14 (2d8 + 5) Piercing damage plus 10 (3d6) Cold damage. Until the end of its next turn, the target can''t take a Bonus Action or Reaction, its Speed decreases by 10 feet, and it can move or take one action on its turn, not both. HitomThe spear magically returns to the devil''s hand immediately after a ranged attack.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Tail
    entryType: attack
    text: '*Melee Attack Roll:* +10, reach 10 ft. 15 (3d6 + 5) Bludgeoning damage plus 18 (4d8) Cold damage.'
    attack:
      type: melee
      bonus: 10
      damage:
        - dice: 3d6
          bonus: 5
          type: Bludgeoning
          average: 15
        - dice: 4d8
          bonus: 0
          type: Cold
          average: 18
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Ice Wall
    entryType: spellcasting
    text: The devil casts *Wall of Ice* (level 8 version), requiring no spell components and using Intelligence as the spellcasting ability (spell save DC 17). - **At Will:**
    spellcasting:
      ability: int
      saveDC: 17
      spellLists: []
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Ice Devil
*Large, Fiend, Lawful Evil*

**AC** 18
**HP** 228 (24d10 + 96)
**Initiative** +7 (17)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 120 ft.; Passive Perception 17
**Languages** Infernal, telepathy 120 ft.
CR 14, PB +5, XP 11500

## Traits

**Diabolical Restoration**
If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.

**Magic Resistance**
The devil has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The devil makes three Ice Spear attacks. It can replace one attack with a Tail attack.

**Ice Spear**
*Melee or Ranged Attack Roll:* +10, reach 5 ft. or range 30/120 ft. 14 (2d8 + 5) Piercing damage plus 10 (3d6) Cold damage. Until the end of its next turn, the target can't take a Bonus Action or Reaction, its Speed decreases by 10 feet, and it can move or take one action on its turn, not both. HitomThe spear magically returns to the devil's hand immediately after a ranged attack.

**Tail**
*Melee Attack Roll:* +10, reach 10 ft. 15 (3d6 + 5) Bludgeoning damage plus 18 (4d8) Cold damage.

**Ice Wall (Recharge 6)**
The devil casts *Wall of Ice* (level 8 version), requiring no spell components and using Intelligence as the spellcasting ability (spell save DC 17). - **At Will:**
`,
      "Monsters/ice-mephit.md": `---
smType: creature
name: Ice Mephit
size: Small
type: Elemental
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '11'
initiative: +1 (11)
hp: '21'
hitDice: 6d6
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 30 ft.
abilities:
  - key: str
    score: 7
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 9
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 12
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '2'
  - skill: Stealth
    value: '3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Primordial (Aquan
  - value: Auran)
damageVulnerabilitiesList:
  - value: Fire
damageImmunitiesList:
  - value: Cold
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Poisoned
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Death Burst
    entryType: save
    text: 'The mephit explodes when it dies. *Constitution Saving Throw*: DC 10, each creature in a 5-foot Emanation originating from the mephit. *Failure:*  5 (2d4) Cold damage. *Success:*  Half damage.'
    save:
      ability: con
      dc: 10
      targeting:
        shape: emanation
        size: 5 ft.
        origin: self
      onFail:
        effects:
          other: 5 (2d4) Cold damage.
        damage:
          - dice: 2d4
            bonus: 0
            type: Cold
            average: 5
        legacyEffects: 5 (2d4) Cold damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 3 (1d4 + 1) Slashing damage plus 2 (1d4) Cold damage.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 1d4
          bonus: 1
          type: Slashing
          average: 3
        - dice: 1d4
          bonus: 0
          type: Cold
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Frost Breath
    entryType: save
    text: '*Constitution Saving Throw*: DC 10, each creature in a 15-foot Cone. *Failure:*  7 (3d4) Cold damage. *Success:*  Half damage.'
    save:
      ability: con
      dc: 10
      targeting:
        shape: cone
        size: 15 ft.
      onFail:
        effects:
          other: 7 (3d4) Cold damage.
        damage:
          - dice: 3d4
            bonus: 0
            type: Cold
            average: 7
        legacyEffects: 7 (3d4) Cold damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Fog Cloud (1/Day)
    entryType: spellcasting
    text: The mephit casts *Fog Cloud*, requiring no spell components and using Charisma as the spellcasting ability. - **At Will:** - **1/Day Each:** *Fog Cloud*
    limitedUse:
      count: 1
      reset: day
    spellcasting:
      ability: cha
      spellLists:
        - frequency: at-will
          spells:
            - '- 1/Day Each: Fog Cloud'
        - frequency: 1/day
          spells:
            - Fog Cloud
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Ice Mephit
*Small, Elemental, Neutral Evil*

**AC** 11
**HP** 21 (6d6)
**Initiative** +1 (11)
**Speed** 30 ft., fly 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 12
**Languages** Primordial (Aquan, Auran)
CR 1/2, PB +2, XP 100

## Traits

**Death Burst**
The mephit explodes when it dies. *Constitution Saving Throw*: DC 10, each creature in a 5-foot Emanation originating from the mephit. *Failure:*  5 (2d4) Cold damage. *Success:*  Half damage.

## Actions

**Claw**
*Melee Attack Roll:* +3, reach 5 ft. 3 (1d4 + 1) Slashing damage plus 2 (1d4) Cold damage.

**Frost Breath (Recharge 6)**
*Constitution Saving Throw*: DC 10, each creature in a 15-foot Cone. *Failure:*  7 (3d4) Cold damage. *Success:*  Half damage.

**Fog Cloud (1/Day)**
The mephit casts *Fog Cloud*, requiring no spell components and using Charisma as the spellcasting ability. - **At Will:** - **1/Day Each:** *Fog Cloud*
`,
      "Monsters/imp.md": `---
smType: creature
name: Imp
size: Small
type: Fiend
typeTags:
  - value: Devil
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '13'
initiative: +3 (13)
hp: '21'
hitDice: 6d4 + 6
speeds:
  walk:
    distance: 20 ft.
  fly:
    distance: 40 ft.
abilities:
  - key: str
    score: 6
    saveProf: false
  - key: dex
    score: 17
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 11
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 14
    saveProf: false
pb: '+2'
skills:
  - skill: Deception
    value: '4'
  - skill: Insight
    value: '3'
  - skill: Stealth
    value: '5'
sensesList:
  - type: darkvision 120 ft. (unimpeded by magical darkness)
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Common
  - value: Infernal
damageResistancesList:
  - value: Cold
damageImmunitiesList:
  - value: Fire
  - value: Poison; Poisoned
cr: '1'
xp: '200'
entries:
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The imp has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Sting
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Piercing damage plus 7 (2d6) Poison damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d6
          bonus: 3
          type: Piercing
          average: 6
        - dice: 2d6
          bonus: 0
          type: Poison
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Shape-Shift
    entryType: special
    text: The imp shape-shifts to resemble a rat (Speed 20 ft.), a raven (20 ft., Fly 60 ft.), or a spider (20 ft., Climb 20 ft.), or it returns to its true form. Its statistics are the same in each form, except for its Speed. Any equipment it is wearing or carrying isn't transformed.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Invisibility
    entryType: spellcasting
    text: The imp casts *Invisibility* on itself, requiring no spell components and using Charisma as the spellcasting ability. - **At Will:** *Invisibility*
    spellcasting:
      ability: cha
      spellLists:
        - frequency: at-will
          spells:
            - Invisibility
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Imp
*Small, Fiend, Lawful Evil*

**AC** 13
**HP** 21 (6d4 + 6)
**Initiative** +3 (13)
**Speed** 20 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft. (unimpeded by magical darkness); Passive Perception 11
**Languages** Common, Infernal
CR 1, PB +2, XP 200

## Traits

**Magic Resistance**
The imp has Advantage on saving throws against spells and other magical effects.

## Actions

**Sting**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Piercing damage plus 7 (2d6) Poison damage.

**Shape-Shift**
The imp shape-shifts to resemble a rat (Speed 20 ft.), a raven (20 ft., Fly 60 ft.), or a spider (20 ft., Climb 20 ft.), or it returns to its true form. Its statistics are the same in each form, except for its Speed. Any equipment it is wearing or carrying isn't transformed.

**Invisibility**
The imp casts *Invisibility* on itself, requiring no spell components and using Charisma as the spellcasting ability. - **At Will:** *Invisibility*
`,
      "Monsters/incubus.md": `---
smType: creature
name: Incubus
size: Medium
type: Fiend
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '15'
initiative: +3 (13)
hp: '66'
hitDice: 12d8 + 12
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 8
    saveProf: false
  - key: dex
    score: 17
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 15
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 20
    saveProf: false
pb: '+2'
skills:
  - skill: Deception
    value: '9'
  - skill: Insight
    value: '5'
  - skill: Perception
    value: '5'
  - skill: Persuasion
    value: '9'
  - skill: Stealth
    value: '7'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '15'
languagesList:
  - value: Abyssal
  - value: Common
  - value: Infernal
  - value: telepathy 60 ft.
damageResistancesList:
  - value: Cold
  - value: Fire
  - value: Poison
  - value: Psychic
cr: '4'
xp: '1100'
entries:
  - category: trait
    name: Succubus Form
    entryType: special
    text: When the incubus finishes a Long Rest, it can shape-shift into a Succubus, using that stat block instead of this one. Any equipment it's wearing or carrying isn't transformed.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The incubus makes two Restless Touch attacks.
    multiattack:
      attacks:
        - name: Touch
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Restless Touch
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 15 (3d6 + 5) Psychic damage, and the target is cursed for 24 hours or until the incubus dies. Until the curse ends, the target gains no benefit from finishing Short Rests.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 3d6
          bonus: 5
          type: Psychic
          average: 15
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Nightmare
    entryType: save
    text: '*Wisdom Saving Throw*: DC 15, one creature the incubus can see within 60 feet. *Failure:*  If the target has 20 Hit Points or fewer, it has the Unconscious condition for 1 hour, until it takes damage, or until a creature within 5 feet of it takes an action to wake it. Otherwise, the target takes 18 (4d8) Psychic damage.'
    save:
      ability: wis
      dc: 15
      targeting:
        type: single
        range: 60 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Unconscious
              duration:
                type: until
                trigger: it takes damage
        damage:
          - dice: 4d8
            bonus: 0
            type: Psychic
            average: 18
    trigger.activation: bonus
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The incubus casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 15): - **At Will:** *Disguise Self*, *Etherealness* - **1e/Day Each:** *Dream*, *Hypnotic Pattern*'
    spellcasting:
      ability: cha
      saveDC: 15
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Disguise Self
            - Etherealness
        - frequency: 1/day
          spells:
            - Dream
            - Hypnotic Pattern
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Incubus
*Medium, Fiend, Neutral Evil*

**AC** 15
**HP** 66 (12d8 + 12)
**Initiative** +3 (13)
**Speed** 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 15
**Languages** Abyssal, Common, Infernal, telepathy 60 ft.
CR 4, PB +2, XP 1100

## Traits

**Succubus Form**
When the incubus finishes a Long Rest, it can shape-shift into a Succubus, using that stat block instead of this one. Any equipment it's wearing or carrying isn't transformed.

## Actions

**Multiattack**
The incubus makes two Restless Touch attacks.

**Restless Touch**
*Melee Attack Roll:* +7, reach 5 ft. 15 (3d6 + 5) Psychic damage, and the target is cursed for 24 hours or until the incubus dies. Until the curse ends, the target gains no benefit from finishing Short Rests.

**Spellcasting**
The incubus casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 15): - **At Will:** *Disguise Self*, *Etherealness* - **1e/Day Each:** *Dream*, *Hypnotic Pattern*

## Bonus Actions

**Nightmare (Recharge 6)**
*Wisdom Saving Throw*: DC 15, one creature the incubus can see within 60 feet. *Failure:*  If the target has 20 Hit Points or fewer, it has the Unconscious condition for 1 hour, until it takes damage, or until a creature within 5 feet of it takes an action to wake it. Otherwise, the target takes 18 (4d8) Psychic damage.
`,
      "Monsters/invisible-stalker.md": `---
smType: creature
name: Invisible Stalker
size: Large
type: Elemental
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '14'
initiative: +7 (17)
hp: '97'
hitDice: 13d10 + 26
speeds:
  walk:
    distance: 50 ft.
  fly:
    distance: 50 ft.
    hover: true
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 19
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 15
    saveProf: false
  - key: cha
    score: 11
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '8'
  - skill: Stealth
    value: '10'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '18'
languagesList:
  - value: Common
  - value: Primordial (Auran)
damageResistancesList:
  - value: Bludgeoning
  - value: Piercing
  - value: Slashing
damageImmunitiesList:
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Grappled
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
  - value: Prone
  - value: Restrained
  - value: Unconscious
cr: '6'
xp: '2300'
entries:
  - category: trait
    name: Air Form
    entryType: special
    text: The stalker can enter an enemy's space and stop there. It can move through a space as narrow as 1 inch without expending extra movement to do so.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Invisibility
    entryType: special
    text: The stalker has the Invisible condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The stalker makes three Wind Swipe attacks. It can replace one attack with a use of Vortex.
    multiattack:
      attacks:
        - name: Swipe
          count: 1
      substitutions:
        - replace: attack
          with:
            type: attack
            name: Vortex
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Wind Swipe
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 11 (2d6 + 4) Force damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d6
          bonus: 4
          type: Force
          average: 11
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Vortex
    entryType: save
    text: '*Constitution Saving Throw*: DC 14, one Large or smaller creature in the stalker''s space. *Failure:*  7 (1d8 + 3) Thunder damage, and the target has the Grappled condition (escape DC 13). Until the grapple ends, the target can''t cast spells with a Verbal component and takes 7 (2d6) Thunder damage at the start of each of the stalker''s turns.'
    save:
      ability: con
      dc: 14
      targeting:
        type: single
        restrictions:
          size:
            - Large
            - smaller
      onFail:
        effects:
          conditions:
            - condition: Grappled
              escape:
                type: dc
                dc: 13
              duration:
                type: until
                trigger: the grapple ends
        damage:
          - dice: 1d8
            bonus: 3
            type: Thunder
            average: 7
          - dice: 2d6
            bonus: 0
            type: Thunder
            average: 7
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Invisible Stalker
*Large, Elemental, Neutral Neutral*

**AC** 14
**HP** 97 (13d10 + 26)
**Initiative** +7 (17)
**Speed** 50 ft., fly 50 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 18
**Languages** Common, Primordial (Auran)
CR 6, PB +3, XP 2300

## Traits

**Air Form**
The stalker can enter an enemy's space and stop there. It can move through a space as narrow as 1 inch without expending extra movement to do so.

**Invisibility**
The stalker has the Invisible condition.

## Actions

**Multiattack**
The stalker makes three Wind Swipe attacks. It can replace one attack with a use of Vortex.

**Wind Swipe**
*Melee Attack Roll:* +7, reach 5 ft. 11 (2d6 + 4) Force damage.

**Vortex**
*Constitution Saving Throw*: DC 14, one Large or smaller creature in the stalker's space. *Failure:*  7 (1d8 + 3) Thunder damage, and the target has the Grappled condition (escape DC 13). Until the grapple ends, the target can't cast spells with a Verbal component and takes 7 (2d6) Thunder damage at the start of each of the stalker's turns.
`,
      "Monsters/iron-golem.md": `---
smType: creature
name: Iron Golem
size: Large
type: Construct
alignmentOverride: Unaligned
ac: '20'
initiative: +9 (19)
hp: '252'
hitDice: 24d10 + 120
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 24
    saveProf: false
  - key: dex
    score: 9
    saveProf: false
  - key: con
    score: 20
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 1
    saveProf: false
pb: '+5'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Understands Common plus two other languages but can't speak
damageImmunitiesList:
  - value: Fire
  - value: Poison
  - value: Psychic; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Frightened
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
cr: '16'
xp: '15000'
entries:
  - category: trait
    name: Fire Absorption
    entryType: special
    text: Whenever the golem is subjected to Fire damage, it regains a number of Hit Points equal to the Fire damage dealt.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Immutable Form
    entryType: special
    text: The golem can't shape-shift.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The golem has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: special
    text: The golem makes two attacks, using Bladed Arm or Fiery Bolt in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Bladed Arm
    entryType: attack
    text: '*Melee Attack Roll:* +12, reach 10 ft. 20 (3d8 + 7) Slashing damage plus 10 (3d6) Fire damage.'
    attack:
      type: melee
      bonus: 12
      damage:
        - dice: 3d8
          bonus: 7
          type: Slashing
          average: 20
        - dice: 3d6
          bonus: 0
          type: Fire
          average: 10
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fiery Bolt
    entryType: attack
    text: '*Ranged Attack Roll:* +10, range 120 ft. 36 (8d8) Fire damage.'
    attack:
      type: ranged
      bonus: 10
      damage:
        - dice: 8d8
          bonus: 0
          type: Fire
          average: 36
      range: 120 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Poison Breath
    entryType: save
    text: '*Constitution Saving Throw*: DC 18, each creature in a 60-foot Cone. *Failure:*  55 (10d10) Poison damage. *Success:*  Half damage.'
    save:
      ability: con
      dc: 18
      targeting:
        shape: cone
        size: 60 ft.
      onFail:
        effects:
          other: 55 (10d10) Poison damage.
        damage:
          - dice: 10d10
            bonus: 0
            type: Poison
            average: 55
        legacyEffects: 55 (10d10) Poison damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Iron Golem
*Large, Construct, Unaligned*

**AC** 20
**HP** 252 (24d10 + 120)
**Initiative** +9 (19)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 10
**Languages** Understands Common plus two other languages but can't speak
CR 16, PB +5, XP 15000

## Traits

**Fire Absorption**
Whenever the golem is subjected to Fire damage, it regains a number of Hit Points equal to the Fire damage dealt.

**Immutable Form**
The golem can't shape-shift.

**Magic Resistance**
The golem has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The golem makes two attacks, using Bladed Arm or Fiery Bolt in any combination.

**Bladed Arm**
*Melee Attack Roll:* +12, reach 10 ft. 20 (3d8 + 7) Slashing damage plus 10 (3d6) Fire damage.

**Fiery Bolt**
*Ranged Attack Roll:* +10, range 120 ft. 36 (8d8) Fire damage.

**Poison Breath (Recharge 6)**
*Constitution Saving Throw*: DC 18, each creature in a 60-foot Cone. *Failure:*  55 (10d10) Poison damage. *Success:*  Half damage.
`,
      "Monsters/knight.md": `---
smType: creature
name: Knight
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '18'
initiative: +0 (10)
hp: '52'
hitDice: 8d8 + 16
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 14
    saveProf: true
    saveMod: 4
  - key: int
    score: 11
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 2
  - key: cha
    score: 15
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common plus one other language
conditionImmunitiesList:
  - value: Frightened
cr: '3'
xp: '700'
entries:
  - category: action
    name: Multiattack
    entryType: special
    text: The knight makes two attacks, using Greatsword or Heavy Crossbow in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Greatsword
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage plus 4 (1d8) Radiant damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d6
          bonus: 3
          type: Slashing
          average: 10
        - dice: 1d8
          bonus: 0
          type: Radiant
          average: 4
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Heavy Crossbow
    entryType: attack
    text: '*Ranged Attack Roll:* +2, range 100/400 ft. 11 (2d10) Piercing damage plus 4 (1d8) Radiant damage.'
    attack:
      type: ranged
      bonus: 2
      damage:
        - dice: 2d10
          bonus: 0
          type: Piercing
          average: 11
        - dice: 1d8
          bonus: 0
          type: Radiant
          average: 4
      range: 100/400 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Knight
*Small, Humanoid, Neutral Neutral*

**AC** 18
**HP** 52 (8d8 + 16)
**Initiative** +0 (10)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common plus one other language
CR 3, PB +2, XP 700

## Actions

**Multiattack**
The knight makes two attacks, using Greatsword or Heavy Crossbow in any combination.

**Greatsword**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage plus 4 (1d8) Radiant damage.

**Heavy Crossbow**
*Ranged Attack Roll:* +2, range 100/400 ft. 11 (2d10) Piercing damage plus 4 (1d8) Radiant damage.
`,
      "Monsters/kobold-warrior.md": `---
smType: creature
name: Kobold Warrior
size: Small
type: Dragon
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '14'
initiative: +2 (12)
hp: '7'
hitDice: 3d6 - 3
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 7
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 9
    saveProf: false
  - key: int
    score: 8
    saveProf: false
  - key: wis
    score: 7
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '8'
languagesList:
  - value: Common
  - value: Draconic
cr: 1/8
xp: '25'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The kobold has Advantage on an attack roll against a creature if at least one of the kobold's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Sunlight Sensitivity
    entryType: special
    text: While in sunlight, the kobold has Disadvantage on ability checks and attack rolls.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Dagger
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +4, reach 5 ft. or range 20/60 ft. 4 (1d4 + 2) Piercing damage.'
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Kobold Warrior
*Small, Dragon, Neutral Neutral*

**AC** 14
**HP** 7 (3d6 - 3)
**Initiative** +2 (12)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 8
**Languages** Common, Draconic
CR 1/8, PB +2, XP 25

## Traits

**Pack Tactics**
The kobold has Advantage on an attack roll against a creature if at least one of the kobold's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

**Sunlight Sensitivity**
While in sunlight, the kobold has Disadvantage on ability checks and attack rolls.

## Actions

**Dagger**
*Melee or Ranged Attack Roll:* +4, reach 5 ft. or range 20/60 ft. 4 (1d4 + 2) Piercing damage.
`,
      "Monsters/kraken.md": `---
smType: creature
name: Kraken
size: Gargantuan
type: Monstrosity
typeTags:
  - value: Titan
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '18'
initiative: +4 (14)
hp: '481'
hitDice: 26d20 + 208
speeds:
  walk:
    distance: 30 ft.
  swim:
    distance: 120 ft.
abilities:
  - key: str
    score: 30
    saveProf: true
    saveMod: 17
  - key: dex
    score: 11
    saveProf: true
    saveMod: 7
  - key: con
    score: 26
    saveProf: true
    saveMod: 15
  - key: int
    score: 22
    saveProf: false
  - key: wis
    score: 18
    saveProf: true
    saveMod: 11
  - key: cha
    score: 20
    saveProf: false
pb: '+7'
skills:
  - skill: History
    value: '13'
  - skill: Perception
    value: '11'
sensesList:
  - type: truesight
    range: '120'
passivesList:
  - skill: Perception
    value: '21'
languagesList:
  - value: Understands Abyssal
  - value: Celestial
  - value: Infernal
  - value: And Primordial but can't speak
  - value: telepathy 120 ft.
damageImmunitiesList:
  - value: Cold
  - value: Lightning; Frightened
conditionImmunitiesList:
  - value: Grappled
  - value: Paralyzed
  - value: Restrained
cr: '23'
xp: '50000'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The kraken can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (4/Day, or 5/Day in Lair)
    entryType: special
    text: If the kraken fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 4
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Siege Monster
    entryType: special
    text: The kraken deals double damage to objects and structures.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The kraken makes two Tentacle attacks and uses Fling, Lightning Strike, or Swallow.
    multiattack:
      attacks:
        - name: Tentacle
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Tentacle
    entryType: attack
    text: '*Melee Attack Roll:* +17, reach 30 ft. 24 (4d6 + 10) Bludgeoning damage. The target has the Grappled condition (escape DC 20) from one of ten tentacles, and it has the Restrained condition until the grapple ends.'
    attack:
      type: melee
      bonus: 17
      damage:
        - dice: 4d6
          bonus: 10
          type: Bludgeoning
          average: 24
      reach: 30 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 20
            duration:
              type: until
              trigger: the grapple ends
          - condition: Restrained
            escape:
              type: dc
              dc: 20
            duration:
              type: until
              trigger: the grapple ends
      additionalEffects: The target has the Grappled condition (escape DC 20) from one of ten tentacles, and it has the Restrained condition until the grapple ends.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fling
    entryType: save
    text: 'The kraken throws a Large or smaller creature Grappled by it to a space it can see within 60 feet of itself that isn''t in the air. *Dexterity Saving Throw*: DC 25, the creature thrown and each creature in the destination space. *Failure:*  18 (4d8) Bludgeoning damage, and the target has the Prone condition. *Success:*  Half damage only.'
    save:
      ability: dex
      dc: 25
      targeting:
        type: single
        restrictions:
          creatureTypes:
            - creature
      onFail:
        effects:
          conditions:
            - condition: Prone
        damage:
          - dice: 4d8
            bonus: 0
            type: Bludgeoning
            average: 18
      onSuccess:
        damage: half
        legacyText: Half damage only.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Lightning Strike
    entryType: save
    text: '*Dexterity Saving Throw*: DC 23, one creature the kraken can see within 120 feet. *Failure:*  33 (6d10) Lightning damage. *Success:*  Half damage.'
    save:
      ability: dex
      dc: 23
      targeting:
        type: single
        range: 120 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          other: 33 (6d10) Lightning damage.
        damage:
          - dice: 6d10
            bonus: 0
            type: Lightning
            average: 33
        legacyEffects: 33 (6d10) Lightning damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Swallow
    entryType: save
    text: '*Dexterity Saving Throw*: DC 25, one creature Grappled by the kraken (it can have up to four creatures swallowed at a time). *Failure:*  23 (3d8 + 10) Piercing damage. If the target is Large or smaller, it is swallowed and no longer Grappled. A swallowed creature has the Restrained condition, has Cover|XPHB|Total Cover against attacks and other effects outside the kraken, and takes 24 (7d6) Acid damage at the start of each of its turns. If the kraken takes 50 damage or more on a single turn from a creature inside it, the kraken must succeed on a DC 25 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, each of which falls in a space within 10 feet of the kraken with the Prone condition. If the kraken dies, any swallowed creature no longer has the Restrained condition and can escape from the corpse using 15 feet of movement, exiting Prone.'
    save:
      ability: dex
      dc: 25
      targeting:
        type: single
        count: 4
        restrictions:
          other:
            - grappled by source
      onFail:
        effects:
          conditions:
            - condition: Restrained
              restrictions:
                size: Large or smaller
            - condition: Restrained
              restrictions:
                size: Large or smaller
        damage:
          - dice: 3d8
            bonus: 10
            type: Piercing
            average: 23
          - dice: 7d6
            bonus: 0
            type: Acid
            average: 24
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Storm Bolt
    entryType: special
    text: The kraken uses Lightning Strike.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Toxic Ink
    entryType: save
    text: '*Constitution Saving Throw*: DC 23, each creature in a 15-foot Emanation originating from the kraken while it is underwater. *Failure:*  The target has the Blinded and Poisoned conditions until the end of the kraken''s next turn. The kraken then moves up to its Speed. *Failure or Success*:  The kraken can''t take this action again until the start of its next turn.'
    save:
      ability: con
      dc: 23
      targeting:
        shape: emanation
        size: 15 ft.
        origin: self
      onFail:
        effects:
          other: The target has the Blinded and Poisoned conditions until the end of the kraken's next turn. The kraken then moves up to its Speed.
        legacyEffects: The target has the Blinded and Poisoned conditions until the end of the kraken's next turn. The kraken then moves up to its Speed.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Kraken
*Gargantuan, Monstrosity, Chaotic Evil*

**AC** 18
**HP** 481 (26d20 + 208)
**Initiative** +4 (14)
**Speed** 30 ft., swim 120 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** truesight 120 ft.; Passive Perception 21
**Languages** Understands Abyssal, Celestial, Infernal, And Primordial but can't speak, telepathy 120 ft.
CR 23, PB +7, XP 50000

## Traits

**Amphibious**
The kraken can breathe air and water.

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the kraken fails a saving throw, it can choose to succeed instead.

**Siege Monster**
The kraken deals double damage to objects and structures.

## Actions

**Multiattack**
The kraken makes two Tentacle attacks and uses Fling, Lightning Strike, or Swallow.

**Tentacle**
*Melee Attack Roll:* +17, reach 30 ft. 24 (4d6 + 10) Bludgeoning damage. The target has the Grappled condition (escape DC 20) from one of ten tentacles, and it has the Restrained condition until the grapple ends.

**Fling**
The kraken throws a Large or smaller creature Grappled by it to a space it can see within 60 feet of itself that isn't in the air. *Dexterity Saving Throw*: DC 25, the creature thrown and each creature in the destination space. *Failure:*  18 (4d8) Bludgeoning damage, and the target has the Prone condition. *Success:*  Half damage only.

**Lightning Strike**
*Dexterity Saving Throw*: DC 23, one creature the kraken can see within 120 feet. *Failure:*  33 (6d10) Lightning damage. *Success:*  Half damage.

**Swallow**
*Dexterity Saving Throw*: DC 25, one creature Grappled by the kraken (it can have up to four creatures swallowed at a time). *Failure:*  23 (3d8 + 10) Piercing damage. If the target is Large or smaller, it is swallowed and no longer Grappled. A swallowed creature has the Restrained condition, has Cover|XPHB|Total Cover against attacks and other effects outside the kraken, and takes 24 (7d6) Acid damage at the start of each of its turns. If the kraken takes 50 damage or more on a single turn from a creature inside it, the kraken must succeed on a DC 25 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, each of which falls in a space within 10 feet of the kraken with the Prone condition. If the kraken dies, any swallowed creature no longer has the Restrained condition and can escape from the corpse using 15 feet of movement, exiting Prone.

## Legendary Actions

**Storm Bolt**
The kraken uses Lightning Strike.

**Toxic Ink**
*Constitution Saving Throw*: DC 23, each creature in a 15-foot Emanation originating from the kraken while it is underwater. *Failure:*  The target has the Blinded and Poisoned conditions until the end of the kraken's next turn. The kraken then moves up to its Speed. *Failure or Success*:  The kraken can't take this action again until the start of its next turn.
`,
      "Monsters/lamia.md": `---
smType: creature
name: Lamia
size: Large
type: Fiend
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '13'
initiative: +1 (11)
hp: '97'
hitDice: 13d10 + 26
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 14
    saveProf: false
  - key: wis
    score: 15
    saveProf: false
  - key: cha
    score: 16
    saveProf: false
pb: '+2'
skills:
  - skill: Deception
    value: '7'
  - skill: Insight
    value: '4'
  - skill: Stealth
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Abyssal
  - value: Common
cr: '4'
xp: '1100'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The lamia makes two Claw attacks. It can replace one attack with a use of Corrupting Touch.
    multiattack:
      attacks:
        - name: Claw
          count: 2
      substitutions:
        - replace: attack
          with:
            type: attack
            name: Corrupting Touch
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Slashing damage plus 7 (2d6) Psychic damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d8
          bonus: 3
          type: Slashing
          average: 7
        - dice: 2d6
          bonus: 0
          type: Psychic
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Corrupting Touch
    entryType: save
    text: '*Wisdom Saving Throw*: DC 13, one creature the lamia can see within 5 feet. *Failure:*  13 (3d8) Psychic damage, and the target is cursed for 1 hour. Until the curse ends, the target has the Charmed and Poisoned conditions.'
    save:
      ability: wis
      dc: 13
      targeting:
        type: single
        range: 5 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Cursed
              additionalText: the target has the Charmed and Poisoned conditions
              duration:
                type: until
                trigger: the curse ends
        damage:
          - dice: 3d8
            bonus: 0
            type: Psychic
            average: 13
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Leap
    entryType: special
    text: The lamia jumps up to 30 feet by spending 10 feet of movement.
    trigger.activation: bonus
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The lamia casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 13): - **At Will:** *Disguise Self*, *Minor Illusion* - **1e/Day Each:** *Geas*, *Major Image*, *Scrying*'
    spellcasting:
      ability: cha
      saveDC: 13
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Disguise Self
            - Minor Illusion
        - frequency: 1/day
          spells:
            - Geas
            - Major Image
            - Scrying
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Lamia
*Large, Fiend, Chaotic Evil*

**AC** 13
**HP** 97 (13d10 + 26)
**Initiative** +1 (11)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 12
**Languages** Abyssal, Common
CR 4, PB +2, XP 1100

## Actions

**Multiattack**
The lamia makes two Claw attacks. It can replace one attack with a use of Corrupting Touch.

**Claw**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Slashing damage plus 7 (2d6) Psychic damage.

**Corrupting Touch**
*Wisdom Saving Throw*: DC 13, one creature the lamia can see within 5 feet. *Failure:*  13 (3d8) Psychic damage, and the target is cursed for 1 hour. Until the curse ends, the target has the Charmed and Poisoned conditions.

**Spellcasting**
The lamia casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 13): - **At Will:** *Disguise Self*, *Minor Illusion* - **1e/Day Each:** *Geas*, *Major Image*, *Scrying*

## Bonus Actions

**Leap**
The lamia jumps up to 30 feet by spending 10 feet of movement.
`,
      "Monsters/lemure.md": `---
smType: creature
name: Lemure
size: Medium
type: Fiend
typeTags:
  - value: Devil
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '9'
initiative: '-3 (7)'
hp: '9'
hitDice: 2d8
speeds:
  walk:
    distance: 20 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 5
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision 120 ft. (unimpeded by magical darkness)
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Understands Infernal but can't speak
damageResistancesList:
  - value: Cold
damageImmunitiesList:
  - value: Fire
  - value: Poison; Charmed
conditionImmunitiesList:
  - value: Frightened
  - value: Poisoned
cr: '0'
xp: '0'
entries:
  - category: trait
    name: Hellish Restoration
    entryType: special
    text: If the lemure dies in the Nine Hells, it revives with all its Hit Points in 1d10 days unless it is killed by a creature under the effects of a *Bless* spell or its remains are sprinkled with Holy Water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Vile Slime
    entryType: attack
    text: '*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Poison damage.'
    attack:
      type: melee
      bonus: 2
      damage:
        - dice: 1d4
          bonus: 0
          type: Poison
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Lemure
*Medium, Fiend, Lawful Evil*

**AC** 9
**HP** 9 (2d8)
**Initiative** -3 (7)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft. (unimpeded by magical darkness); Passive Perception 10
**Languages** Understands Infernal but can't speak
CR 0, PB +2, XP 0

## Traits

**Hellish Restoration**
If the lemure dies in the Nine Hells, it revives with all its Hit Points in 1d10 days unless it is killed by a creature under the effects of a *Bless* spell or its remains are sprinkled with Holy Water.

## Actions

**Vile Slime**
*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Poison damage.
`,
      "Monsters/lich.md": `---
smType: creature
name: Lich
size: Medium
type: Undead
typeTags:
  - value: Wizard
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '20'
initiative: +7 (17)
hp: '315'
hitDice: 42d8 + 126
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 11
    saveProf: false
  - key: dex
    score: 16
    saveProf: true
    saveMod: 10
  - key: con
    score: 16
    saveProf: true
    saveMod: 10
  - key: int
    score: 21
    saveProf: true
    saveMod: 12
  - key: wis
    score: 14
    saveProf: true
    saveMod: 9
  - key: cha
    score: 16
    saveProf: false
pb: '+7'
skills:
  - skill: Arcana
    value: '19'
  - skill: History
    value: '12'
  - skill: Insight
    value: '9'
  - skill: Perception
    value: '9'
sensesList:
  - type: truesight
    range: '120'
passivesList:
  - skill: Perception
    value: '19'
languagesList:
  - value: All
damageResistancesList:
  - value: Cold
  - value: Lightning
damageImmunitiesList:
  - value: Necrotic
  - value: Poison; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Frightened
  - value: Paralyzed
  - value: Poisoned
cr: '21'
xp: '33000'
entries:
  - category: trait
    name: Legendary Resistance (4/Day, or 5/Day in Lair)
    entryType: special
    text: If the lich fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 4
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Spirit Jar
    entryType: special
    text: If destroyed, the lich reforms in 1d10 days if it has a spirit jar, reviving with all its Hit Points. The new body appears in an unoccupied space within the lich's lair.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: special
    text: The lich makes three attacks, using Eldritch Burst or Paralyzing Touch in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Eldritch Burst
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +12, reach 5 ft. or range 120 ft. 31 (4d12 + 5) Force damage.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Paralyzing Touch
    entryType: attack
    text: '*Melee Attack Roll:* +12, reach 5 ft. 15 (3d6 + 5) Cold damage, and the target has the Paralyzed condition until the start of the lich''s next turn.'
    attack:
      type: melee
      bonus: 12
      damage:
        - dice: 3d6
          bonus: 5
          type: Cold
          average: 15
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Deathly Teleport
    entryType: special
    text: The lich teleports up to 60 feet to an unoccupied space it can see, and each creature within 10 feet of the space it left takes 11 (2d10) Necrotic damage.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Disrupt Life
    entryType: save
    text: '*Constitution Saving Throw*: DC 20, each creature that isn''t an Undead in a 20-foot Emanation originating from the lich. *Failure:*  31 (9d6) Necrotic damage. *Success:*  Half damage. *Failure or Success*:  The lich can''t take this action again until the start of its next turn.'
    save:
      ability: con
      dc: 20
      targeting:
        shape: emanation
        size: 20 ft.
        origin: self
      onFail:
        effects:
          other: 31 (9d6) Necrotic damage.
        damage:
          - dice: 9d6
            bonus: 0
            type: Necrotic
            average: 31
        legacyEffects: 31 (9d6) Necrotic damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The lich casts one of the following spells, using Intelligence as the spellcasting ability (spell save DC 20): - **At Will:** *Detect Magic*, *Detect Thoughts*, *Dispel Magic*, *Fireball*, *Invisibility*, *Lightning Bolt*, *Mage Hand*, *Prestidigitation* - **2e/Day Each:** *Animate Dead*, *Dimension Door*, *Plane Shift* - **1e/Day Each:** *Chain Lightning*, *Finger of Death*, *Power Word Kill*, *Scrying*'
    spellcasting:
      ability: int
      saveDC: 20
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Detect Thoughts
            - Dispel Magic
            - Fireball
            - Invisibility
            - Lightning Bolt
            - Mage Hand
            - Prestidigitation
        - frequency: 2/day
          spells:
            - Animate Dead
            - Dimension Door
            - Plane Shift
        - frequency: 1/day
          spells:
            - Chain Lightning
            - Finger of Death
            - Power Word Kill
            - Scrying
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: reaction
    name: Protective Magic
    entryType: spellcasting
    text: The lich casts *Counterspell* or *Shield* in response to the spell's trigger, using the same spellcasting ability as Spellcasting.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: reaction
    trigger.targeting:
      type: single
    trigger.reactionTrigger: the spell's trigger
  - category: legendary
    name: Frightening Gaze
    entryType: spellcasting
    text: The lich casts *Fear*, using the same spellcasting ability as Spellcasting. The lich can't take this action again until the start of its next turn.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Lich
*Medium, Undead, Neutral Evil*

**AC** 20
**HP** 315 (42d8 + 126)
**Initiative** +7 (17)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** truesight 120 ft.; Passive Perception 19
**Languages** All
CR 21, PB +7, XP 33000

## Traits

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the lich fails a saving throw, it can choose to succeed instead.

**Spirit Jar**
If destroyed, the lich reforms in 1d10 days if it has a spirit jar, reviving with all its Hit Points. The new body appears in an unoccupied space within the lich's lair.

## Actions

**Multiattack**
The lich makes three attacks, using Eldritch Burst or Paralyzing Touch in any combination.

**Eldritch Burst**
*Melee or Ranged Attack Roll:* +12, reach 5 ft. or range 120 ft. 31 (4d12 + 5) Force damage.

**Paralyzing Touch**
*Melee Attack Roll:* +12, reach 5 ft. 15 (3d6 + 5) Cold damage, and the target has the Paralyzed condition until the start of the lich's next turn.

**Spellcasting**
The lich casts one of the following spells, using Intelligence as the spellcasting ability (spell save DC 20): - **At Will:** *Detect Magic*, *Detect Thoughts*, *Dispel Magic*, *Fireball*, *Invisibility*, *Lightning Bolt*, *Mage Hand*, *Prestidigitation* - **2e/Day Each:** *Animate Dead*, *Dimension Door*, *Plane Shift* - **1e/Day Each:** *Chain Lightning*, *Finger of Death*, *Power Word Kill*, *Scrying*

## Reactions

**Protective Magic**
The lich casts *Counterspell* or *Shield* in response to the spell's trigger, using the same spellcasting ability as Spellcasting.

## Legendary Actions

**Deathly Teleport**
The lich teleports up to 60 feet to an unoccupied space it can see, and each creature within 10 feet of the space it left takes 11 (2d10) Necrotic damage.

**Disrupt Life**
*Constitution Saving Throw*: DC 20, each creature that isn't an Undead in a 20-foot Emanation originating from the lich. *Failure:*  31 (9d6) Necrotic damage. *Success:*  Half damage. *Failure or Success*:  The lich can't take this action again until the start of its next turn.

**Frightening Gaze**
The lich casts *Fear*, using the same spellcasting ability as Spellcasting. The lich can't take this action again until the start of its next turn.
`,
      "Monsters/mage.md": `---
smType: creature
name: Mage
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '15'
initiative: +2 (12)
hp: '81'
hitDice: 18d8
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 9
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 17
    saveProf: true
    saveMod: 6
  - key: wis
    score: 12
    saveProf: true
    saveMod: 4
  - key: cha
    score: 11
    saveProf: false
pb: '+3'
skills:
  - skill: Arcana
    value: '6'
  - skill: History
    value: '6'
  - skill: Perception
    value: '4'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Common and any three languages
cr: '6'
xp: '2300'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The mage makes three Arcane Burst attacks.
    multiattack:
      attacks:
        - name: Burst
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Arcane Burst
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +6, reach 5 ft. or range 120 ft. 16 (3d8 + 3) Force damage.'
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The mage casts one of the following spells, using Intelligence as the spellcasting ability (spell save DC 14): - **At Will:** *Detect Magic*, *Light*, *Mage Armor*, *Mage Hand*, *Prestidigitation* - **2e/Day Each:** *Fireball*, *Invisibility* - **1e/Day Each:** *Cone of Cold*, *Fly*'
    spellcasting:
      ability: int
      saveDC: 14
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Light
            - Mage Armor
            - Mage Hand
            - Prestidigitation
        - frequency: 2/day
          spells:
            - Fireball
            - Invisibility
        - frequency: 1/day
          spells:
            - Cone of Cold
            - Fly
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Misty Step (3/Day)
    entryType: spellcasting
    text: The mage casts *Misty Step*, using the same spellcasting ability as Spellcasting.
    limitedUse:
      count: 3
      reset: day
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: bonus
    trigger.targeting:
      type: single
  - category: reaction
    name: Protective Magic (3/Day)
    entryType: spellcasting
    text: The mage casts *Counterspell* or *Shield* in response to the spell's trigger, using the same spellcasting ability as Spellcasting.
    limitedUse:
      count: 3
      reset: day
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: reaction
    trigger.targeting:
      type: single
    trigger.reactionTrigger: the spell's trigger
---

# Mage
*Small, Humanoid, Neutral Neutral*

**AC** 15
**HP** 81 (18d8)
**Initiative** +2 (12)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common and any three languages
CR 6, PB +3, XP 2300

## Actions

**Multiattack**
The mage makes three Arcane Burst attacks.

**Arcane Burst**
*Melee or Ranged Attack Roll:* +6, reach 5 ft. or range 120 ft. 16 (3d8 + 3) Force damage.

**Spellcasting**
The mage casts one of the following spells, using Intelligence as the spellcasting ability (spell save DC 14): - **At Will:** *Detect Magic*, *Light*, *Mage Armor*, *Mage Hand*, *Prestidigitation* - **2e/Day Each:** *Fireball*, *Invisibility* - **1e/Day Each:** *Cone of Cold*, *Fly*

## Bonus Actions

**Misty Step (3/Day)**
The mage casts *Misty Step*, using the same spellcasting ability as Spellcasting.

## Reactions

**Protective Magic (3/Day)**
The mage casts *Counterspell* or *Shield* in response to the spell's trigger, using the same spellcasting ability as Spellcasting.
`,
      "Monsters/magma-mephit.md": `---
smType: creature
name: Magma Mephit
size: Small
type: Elemental
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '11'
initiative: +1 (11)
hp: '18'
hitDice: 4d6 + 4
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 30 ft.
abilities:
  - key: str
    score: 8
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 7
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 10
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Primordial (Ignan
  - value: Terran)
damageVulnerabilitiesList:
  - value: Cold
damageImmunitiesList:
  - value: Fire
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Poisoned
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Death Burst
    entryType: save
    text: 'The mephit explodes when it dies. *Dexterity Saving Throw*: DC 11, each creature in a 5-foot Emanation originating from the mephit. *Failure:*  7 (2d6) Fire damage. *Success:*  Half damage.'
    save:
      ability: dex
      dc: 11
      targeting:
        shape: emanation
        size: 5 ft.
        origin: self
      onFail:
        effects:
          other: 7 (2d6) Fire damage.
        damage:
          - dice: 2d6
            bonus: 0
            type: Fire
            average: 7
        legacyEffects: 7 (2d6) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 3 (1d4 + 1) Slashing damage plus 3 (1d6) Fire damage.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 1d4
          bonus: 1
          type: Slashing
          average: 3
        - dice: 1d6
          bonus: 0
          type: Fire
          average: 3
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fire Breath
    entryType: save
    text: '*Dexterity Saving Throw*: DC 11, each creature in a 15-foot Cone. *Failure:*  7 (2d6) Fire damage. *Success:*  Half damage.'
    save:
      ability: dex
      dc: 11
      targeting:
        shape: cone
        size: 15 ft.
      onFail:
        effects:
          other: 7 (2d6) Fire damage.
        damage:
          - dice: 2d6
            bonus: 0
            type: Fire
            average: 7
        legacyEffects: 7 (2d6) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Magma Mephit
*Small, Elemental, Neutral Evil*

**AC** 11
**HP** 18 (4d6 + 4)
**Initiative** +1 (11)
**Speed** 30 ft., fly 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Primordial (Ignan, Terran)
CR 1/2, PB +2, XP 100

## Traits

**Death Burst**
The mephit explodes when it dies. *Dexterity Saving Throw*: DC 11, each creature in a 5-foot Emanation originating from the mephit. *Failure:*  7 (2d6) Fire damage. *Success:*  Half damage.

## Actions

**Claw**
*Melee Attack Roll:* +3, reach 5 ft. 3 (1d4 + 1) Slashing damage plus 3 (1d6) Fire damage.

**Fire Breath (Recharge 6)**
*Dexterity Saving Throw*: DC 11, each creature in a 15-foot Cone. *Failure:*  7 (2d6) Fire damage. *Success:*  Half damage.
`,
      "Monsters/magmin.md": `---
smType: creature
name: Magmin
size: Small
type: Elemental
alignmentLawChaos: Chaotic
alignmentGoodEvil: Neutral
ac: '14'
initiative: +2 (12)
hp: '13'
hitDice: 3d6 + 3
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 7
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 8
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 10
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Primordial (Ignan)
damageImmunitiesList:
  - value: Fire
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Death Burst
    entryType: save
    text: 'The magmin explodes when it dies. *Dexterity Saving Throw*: DC 11, each creature in a 10-foot Emanation originating from the magmin. *Failure:*  7 (2d6) Fire damage. *Success:*  Half damage.'
    save:
      ability: dex
      dc: 11
      targeting:
        shape: emanation
        size: 10 ft.
        origin: self
      onFail:
        effects:
          other: 7 (2d6) Fire damage.
        damage:
          - dice: 2d6
            bonus: 0
            type: Fire
            average: 7
        legacyEffects: 7 (2d6) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Touch
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 7 (2d4 + 2) Fire damage. If the target is a creature or a flammable object that isn''t being worn or carried, it starts burning.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 2d4
          bonus: 2
          type: Fire
          average: 7
      reach: 5 ft.
      onHit:
        other: If the target is a creature or a flammable object that isn't being worn or carried, it starts burning.
      additionalEffects: If the target is a creature or a flammable object that isn't being worn or carried, it starts burning.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Ignited Illumination
    entryType: special
    text: The magmin sets itself ablaze or extinguishes its flames. While ablaze, the magmin sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Magmin
*Small, Elemental, Chaotic Neutral*

**AC** 14
**HP** 13 (3d6 + 3)
**Initiative** +2 (12)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Primordial (Ignan)
CR 1/2, PB +2, XP 100

## Traits

**Death Burst**
The magmin explodes when it dies. *Dexterity Saving Throw*: DC 11, each creature in a 10-foot Emanation originating from the magmin. *Failure:*  7 (2d6) Fire damage. *Success:*  Half damage.

## Actions

**Touch**
*Melee Attack Roll:* +4, reach 5 ft. 7 (2d4 + 2) Fire damage. If the target is a creature or a flammable object that isn't being worn or carried, it starts burning.

## Bonus Actions

**Ignited Illumination**
The magmin sets itself ablaze or extinguishes its flames. While ablaze, the magmin sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.
`,
      "Monsters/manticore.md": `---
smType: creature
name: Manticore
size: Large
type: Monstrosity
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '14'
initiative: +3 (13)
hp: '68'
hitDice: 8d10 + 24
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 50 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 7
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Common
cr: '3'
xp: '700'
entries:
  - category: action
    name: Multiattack
    entryType: special
    text: The manticore makes three attacks, using Rend or Tail Spike in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Slashing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d8
          bonus: 3
          type: Slashing
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Tail Spike
    entryType: attack
    text: '*Ranged Attack Roll:* +5, range 100/200 ft. 7 (1d8 + 3) Piercing damage.'
    attack:
      type: ranged
      bonus: 5
      damage:
        - dice: 1d8
          bonus: 3
          type: Piercing
          average: 7
      range: 100/200 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Manticore
*Large, Monstrosity, Lawful Evil*

**AC** 14
**HP** 68 (8d10 + 24)
**Initiative** +3 (13)
**Speed** 30 ft., fly 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 11
**Languages** Common
CR 3, PB +2, XP 700

## Actions

**Multiattack**
The manticore makes three attacks, using Rend or Tail Spike in any combination.

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Slashing damage.

**Tail Spike**
*Ranged Attack Roll:* +5, range 100/200 ft. 7 (1d8 + 3) Piercing damage.
`,
      "Monsters/marilith.md": `---
smType: creature
name: Marilith
size: Large
type: Fiend
typeTags:
  - value: Demon
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '16'
initiative: +10 (20)
hp: '220'
hitDice: 21d10 + 105
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 40 ft.
abilities:
  - key: str
    score: 18
    saveProf: true
    saveMod: 9
  - key: dex
    score: 20
    saveProf: false
  - key: con
    score: 20
    saveProf: true
    saveMod: 10
  - key: int
    score: 18
    saveProf: false
  - key: wis
    score: 16
    saveProf: true
    saveMod: 8
  - key: cha
    score: 20
    saveProf: true
    saveMod: 10
pb: '+5'
skills:
  - skill: Perception
    value: '8'
sensesList:
  - type: truesight
    range: '120'
passivesList:
  - skill: Perception
    value: '18'
languagesList:
  - value: Abyssal
  - value: telepathy 120 ft.
damageResistancesList:
  - value: Cold
  - value: Fire
  - value: Lightning
damageImmunitiesList:
  - value: Poison; Poisoned
cr: '16'
xp: '15000'
entries:
  - category: trait
    name: Demonic Restoration
    entryType: special
    text: If the marilith dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The marilith has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Reactive
    entryType: special
    text: The marilith can take one Reaction on every turn of combat.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The marilith makes six Pact Blade attacks and uses Constrict.
    multiattack:
      attacks:
        - name: Blade
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Pact Blade
    entryType: attack
    text: '*Melee Attack Roll:* +10, reach 5 ft. 10 (1d10 + 5) Slashing damage plus 7 (2d6) Necrotic damage.'
    attack:
      type: melee
      bonus: 10
      damage:
        - dice: 1d10
          bonus: 5
          type: Slashing
          average: 10
        - dice: 2d6
          bonus: 0
          type: Necrotic
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Constrict
    entryType: save
    text: '*Strength Saving Throw*: DC 17, one Medium or smaller creature the marilith can see within 5 feet. *Failure:*  15 (2d10 + 4) Bludgeoning damage. The target has the Grappled condition (escape DC 14), and it has the Restrained condition until the grapple ends.'
    save:
      ability: str
      dc: 17
      targeting:
        type: single
        range: 5 ft.
        restrictions:
          size:
            - Medium
            - smaller
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Grappled
              escape:
                type: dc
                dc: 14
              duration:
                type: until
                trigger: the grapple ends
            - condition: Restrained
              escape:
                type: dc
                dc: 14
              duration:
                type: until
                trigger: the grapple ends
        damage:
          - dice: 2d10
            bonus: 4
            type: Bludgeoning
            average: 15
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Teleport (Recharge 5-6)
    entryType: special
    text: The marilith teleports up to 120 feet to an unoccupied space it can see.
    recharge: 5-6
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Marilith
*Large, Fiend, Chaotic Evil*

**AC** 16
**HP** 220 (21d10 + 105)
**Initiative** +10 (20)
**Speed** 40 ft., climb 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** truesight 120 ft.; Passive Perception 18
**Languages** Abyssal, telepathy 120 ft.
CR 16, PB +5, XP 15000

## Traits

**Demonic Restoration**
If the marilith dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.

**Magic Resistance**
The marilith has Advantage on saving throws against spells and other magical effects.

**Reactive**
The marilith can take one Reaction on every turn of combat.

## Actions

**Multiattack**
The marilith makes six Pact Blade attacks and uses Constrict.

**Pact Blade**
*Melee Attack Roll:* +10, reach 5 ft. 10 (1d10 + 5) Slashing damage plus 7 (2d6) Necrotic damage.

**Constrict**
*Strength Saving Throw*: DC 17, one Medium or smaller creature the marilith can see within 5 feet. *Failure:*  15 (2d10 + 4) Bludgeoning damage. The target has the Grappled condition (escape DC 14), and it has the Restrained condition until the grapple ends.

## Bonus Actions

**Teleport (Recharge 5-6)**
The marilith teleports up to 120 feet to an unoccupied space it can see.
`,
      "Monsters/medusa.md": `---
smType: creature
name: Medusa
size: Medium
type: Monstrosity
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '15'
initiative: +6 (16)
hp: '127'
hitDice: 17d8 + 51
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 17
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 13
    saveProf: true
    saveMod: 4
  - key: cha
    score: 15
    saveProf: false
pb: '+3'
skills:
  - skill: Deception
    value: '5'
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '6'
sensesList:
  - type: darkvision
    range: '150'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Common plus one other language
cr: '6'
xp: '2300'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The medusa makes two Claw attacks and one Snake Hair attack, or it makes three Poison Ray attacks.
    multiattack:
      attacks:
        - name: Claw
          count: 2
        - name: Hair
          count: 1
        - name: Ray
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 10 (2d6 + 3) Slashing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d6
          bonus: 3
          type: Slashing
          average: 10
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Snake Hair
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 5 (1d4 + 3) Piercing damage plus 14 (4d6) Poison damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d4
          bonus: 3
          type: Piercing
          average: 5
        - dice: 4d6
          bonus: 0
          type: Poison
          average: 14
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Poison Ray
    entryType: attack
    text: '*Ranged Attack Roll:* +5, range 150 ft. 11 (2d8 + 2) Poison damage.'
    attack:
      type: ranged
      bonus: 5
      damage:
        - dice: 2d8
          bonus: 2
          type: Poison
          average: 11
      range: 150 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Petrifying Gaze (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 13, each creature in a 30-foot Cone. If the medusa sees its reflection in the Cone, the medusa must make this save. *First Failure* The target has the Restrained condition and repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition instead of the Restrained condition.'
    recharge: 5-6
    save:
      ability: con
      dc: 13
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Medusa
*Medium, Monstrosity, Lawful Evil*

**AC** 15
**HP** 127 (17d8 + 51)
**Initiative** +6 (16)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 150 ft.; Passive Perception 14
**Languages** Common plus one other language
CR 6, PB +3, XP 2300

## Actions

**Multiattack**
The medusa makes two Claw attacks and one Snake Hair attack, or it makes three Poison Ray attacks.

**Claw**
*Melee Attack Roll:* +6, reach 5 ft. 10 (2d6 + 3) Slashing damage.

**Snake Hair**
*Melee Attack Roll:* +6, reach 5 ft. 5 (1d4 + 3) Piercing damage plus 14 (4d6) Poison damage.

**Poison Ray**
*Ranged Attack Roll:* +5, range 150 ft. 11 (2d8 + 2) Poison damage.

## Bonus Actions

**Petrifying Gaze (Recharge 5-6)**
*Constitution Saving Throw*: DC 13, each creature in a 30-foot Cone. If the medusa sees its reflection in the Cone, the medusa must make this save. *First Failure* The target has the Restrained condition and repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition instead of the Restrained condition.
`,
      "Monsters/merfolk-skirmisher.md": `---
smType: creature
name: Merfolk Skirmisher
size: Medium
type: Elemental
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '11'
initiative: +1 (11)
hp: '11'
hitDice: 2d8 + 2
speeds:
  walk:
    distance: 10 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 11
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 12
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Common
  - value: Primordial (Aquan)
cr: 1/8
xp: '25'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The merfolk can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Ocean Spear
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +2, reach 5 ft. or range 20/60 ft. 3 (1d6) Piercing damage plus 2 (1d4) Cold damage. If the target is a creature, its Speed decreases by 10 feet until the end of its next turn. HitomThe spear magically returns to the merfolk''s hand immediately after a ranged attack.'
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Merfolk Skirmisher
*Medium, Elemental, Neutral Neutral*

**AC** 11
**HP** 11 (2d8 + 2)
**Initiative** +1 (11)
**Speed** 10 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common, Primordial (Aquan)
CR 1/8, PB +2, XP 25

## Traits

**Amphibious**
The merfolk can breathe air and water.

## Actions

**Ocean Spear**
*Melee or Ranged Attack Roll:* +2, reach 5 ft. or range 20/60 ft. 3 (1d6) Piercing damage plus 2 (1d4) Cold damage. If the target is a creature, its Speed decreases by 10 feet until the end of its next turn. HitomThe spear magically returns to the merfolk's hand immediately after a ranged attack.
`,
      "Monsters/merrow.md": `---
smType: creature
name: Merrow
size: Large
type: Monstrosity
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '13'
initiative: +2 (12)
hp: '45'
hitDice: 6d10 + 12
speeds:
  walk:
    distance: 10 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 8
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 9
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Abyssal
  - value: Primordial (Aquan)
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The merrow can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: special
    text: The merrow makes two attacks, using Bite, Claw, or Harpoon in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 6 (1d4 + 4) Piercing damage, and the target has the Poisoned condition until the end of the merrow''s next turn.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d4
          bonus: 4
          type: Piercing
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 9 (2d4 + 4) Slashing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d4
          bonus: 4
          type: Slashing
          average: 9
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Harpoon
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +6, reach 5 ft. or range 20/60 ft. 11 (2d6 + 4) Piercing damage. If the target is a Large or smaller creature, the merrow pulls the target up to 15 feet straight toward itself.'
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Merrow
*Large, Monstrosity, Chaotic Evil*

**AC** 13
**HP** 45 (6d10 + 12)
**Initiative** +2 (12)
**Speed** 10 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Abyssal, Primordial (Aquan)
CR 2, PB +2, XP 450

## Traits

**Amphibious**
The merrow can breathe air and water.

## Actions

**Multiattack**
The merrow makes two attacks, using Bite, Claw, or Harpoon in any combination.

**Bite**
*Melee Attack Roll:* +6, reach 5 ft. 6 (1d4 + 4) Piercing damage, and the target has the Poisoned condition until the end of the merrow's next turn.

**Claw**
*Melee Attack Roll:* +6, reach 5 ft. 9 (2d4 + 4) Slashing damage.

**Harpoon**
*Melee or Ranged Attack Roll:* +6, reach 5 ft. or range 20/60 ft. 11 (2d6 + 4) Piercing damage. If the target is a Large or smaller creature, the merrow pulls the target up to 15 feet straight toward itself.
`,
      "Monsters/mimic.md": `---
smType: creature
name: Mimic
size: Medium
type: Monstrosity
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '12'
initiative: +3 (13)
hp: '58'
hitDice: 9d8 + 18
speeds:
  walk:
    distance: 20 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 5
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '11'
damageImmunitiesList:
  - value: Acid; Prone
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Adhesive (Object Form Only)
    entryType: special
    text: The mimic adheres to anything that touches it. A Huge or smaller creature adhered to the mimic has the Grappled condition (escape DC 13). Ability checks made to escape this grapple have Disadvantage.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5 (with Advantage if the target is Grappled by the mimic), reach 5 ft. 7 (1d8 + 3) Piercing damage\u2014or 12 (2d8 + 3) Piercing damage if the target is Grappled by the mimic\u2014plus 4 (1d8) Acid damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d8
          bonus: 3
          type: Piercing
          average: 7
        - dice: 2d8
          bonus: 3
          type: Piercing
          average: 12
        - dice: 1d8
          bonus: 0
          type: Acid
          average: 4
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Pseudopod
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Bludgeoning damage plus 4 (1d8) Acid damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13). Ability checks made to escape this grapple have Disadvantage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d8
          bonus: 3
          type: Bludgeoning
          average: 7
        - dice: 1d8
          bonus: 0
          type: Acid
          average: 4
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 13
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13). Ability checks made to escape this grapple have Disadvantage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Shape-Shift
    entryType: special
    text: The mimic shape-shifts to resemble a Medium or Small object while retaining its game statistics, or it returns to its true blob form. Any equipment it is wearing or carrying isn't transformed.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Mimic
*Medium, Monstrosity, Neutral Neutral*

**AC** 12
**HP** 58 (9d8 + 18)
**Initiative** +3 (13)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 11
CR 2, PB +2, XP 450

## Traits

**Adhesive (Object Form Only)**
The mimic adheres to anything that touches it. A Huge or smaller creature adhered to the mimic has the Grappled condition (escape DC 13). Ability checks made to escape this grapple have Disadvantage.

## Actions

**Bite**
*Melee Attack Roll:* +5 (with Advantage if the target is Grappled by the mimic), reach 5 ft. 7 (1d8 + 3) Piercing damage\u2014or 12 (2d8 + 3) Piercing damage if the target is Grappled by the mimic\u2014plus 4 (1d8) Acid damage.

**Pseudopod**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Bludgeoning damage plus 4 (1d8) Acid damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13). Ability checks made to escape this grapple have Disadvantage.

## Bonus Actions

**Shape-Shift**
The mimic shape-shifts to resemble a Medium or Small object while retaining its game statistics, or it returns to its true blob form. Any equipment it is wearing or carrying isn't transformed.
`,
      "Monsters/minotaur-of-baphomet.md": `---
smType: creature
name: Minotaur of Baphomet
size: Large
type: Monstrosity
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '14'
initiative: +0 (10)
hp: '85'
hitDice: 10d10 + 30
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 16
    saveProf: false
  - key: cha
    score: 9
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '7'
  - skill: Survival
    value: '7'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '17'
languagesList:
  - value: Abyssal
cr: '3'
xp: '700'
entries:
  - category: action
    name: Abyssal Glaive
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 10 ft. 10 (1d12 + 4) Slashing damage plus 10 (3d6) Necrotic damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d12
          bonus: 4
          type: Slashing
          average: 10
        - dice: 3d6
          bonus: 0
          type: Necrotic
          average: 10
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Gore (Recharge 5-6)
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 18 (4d6 + 4) Piercing damage. If the target is a Large or smaller creature and the minotaur moved 10+ feet straight toward it immediately before the hit, the target takes an extra 10 (3d6) Piercing damage and has the Prone condition.'
    recharge: 5-6
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 4d6
          bonus: 4
          type: Piercing
          average: 18
        - dice: 3d6
          bonus: 0
          type: Piercing
          average: 10
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature and the minotaur moved 10+ feet straight toward it immediately before the hit, the target takes an extra 10 (3d6) Piercing damage and has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Minotaur of Baphomet
*Large, Monstrosity, Chaotic Evil*

**AC** 14
**HP** 85 (10d10 + 30)
**Initiative** +0 (10)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 17
**Languages** Abyssal
CR 3, PB +2, XP 700

## Actions

**Abyssal Glaive**
*Melee Attack Roll:* +6, reach 10 ft. 10 (1d12 + 4) Slashing damage plus 10 (3d6) Necrotic damage.

**Gore (Recharge 5-6)**
*Melee Attack Roll:* +6, reach 5 ft. 18 (4d6 + 4) Piercing damage. If the target is a Large or smaller creature and the minotaur moved 10+ feet straight toward it immediately before the hit, the target takes an extra 10 (3d6) Piercing damage and has the Prone condition.
`,
      "Monsters/minotaur-skeleton.md": `---
smType: creature
name: Minotaur Skeleton
size: Large
type: Undead
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '12'
initiative: +0 (10)
hp: '45'
hitDice: 6d10 + 12
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 8
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '9'
languagesList:
  - value: Understands Abyssal but can't speak
damageVulnerabilitiesList:
  - value: Bludgeoning
damageImmunitiesList:
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Poisoned
cr: '2'
xp: '450'
entries:
  - category: action
    name: Gore
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 11 (2d6 + 4) Piercing damage. If the target is a Large or smaller creature and the skeleton moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d6
          bonus: 4
          type: Piercing
          average: 11
        - dice: 2d8
          bonus: 0
          type: Piercing
          average: 9
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature and the skeleton moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Slam
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 15 (2d10 + 4) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d10
          bonus: 4
          type: Bludgeoning
          average: 15
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Minotaur Skeleton
*Large, Undead, Lawful Evil*

**AC** 12
**HP** 45 (6d10 + 12)
**Initiative** +0 (10)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 9
**Languages** Understands Abyssal but can't speak
CR 2, PB +2, XP 450

## Actions

**Gore**
*Melee Attack Roll:* +6, reach 5 ft. 11 (2d6 + 4) Piercing damage. If the target is a Large or smaller creature and the skeleton moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.

**Slam**
*Melee Attack Roll:* +6, reach 5 ft. 15 (2d10 + 4) Bludgeoning damage.
`,
      "Monsters/mummy-lord.md": `---
smType: creature
name: Mummy Lord
size: Small
type: Undead
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '17'
initiative: +4 (14)
hp: '187'
hitDice: 25d8 + 75
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 11
    saveProf: true
    saveMod: 5
  - key: wis
    score: 19
    saveProf: true
    saveMod: 9
  - key: cha
    score: 16
    saveProf: false
pb: '+5'
skills:
  - skill: History
    value: '5'
  - skill: Perception
    value: '9'
  - skill: Religion
    value: '5'
sensesList:
  - type: truesight
    range: '60'
passivesList:
  - skill: Perception
    value: '19'
languagesList:
  - value: Common plus three other languages
damageVulnerabilitiesList:
  - value: Fire
damageImmunitiesList:
  - value: Necrotic
  - value: Poison; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Frightened
  - value: Paralyzed
  - value: Poisoned
cr: '15'
xp: '13000'
entries:
  - category: trait
    name: Legendary Resistance (3/Day, or 4/Day in Lair)
    entryType: special
    text: If the mummy fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The mummy has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Undead Restoration
    entryType: special
    text: If destroyed, the mummy gains a new body in 24 hours if its heart is intact, reviving with all its Hit Points. The new body appears in an unoccupied space within the mummy's lair. The heart is a Tiny object that has AC 17, HP 10, and Immunity to all damage except Fire.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The mummy makes one Rotting Fist or Channel Negative Energy attack, and it uses Dreadful Glare.
    multiattack:
      attacks:
        - name: Energy
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rotting Fist
    entryType: attack
    text: '*Melee Attack Roll:* +9, reach 5 ft. 15 (2d10 + 4) Bludgeoning damage plus 10 (3d6) Necrotic damage. If the target is a creature, it is cursed. While cursed, the target can''t regain Hit Points, it gains no benefit from finishing a Long Rest, and its Hit Point maximum decreases by 10 (3d6) every 24 hours that elapse. A creature dies and turns to dust if reduced to 0 Hit Points by this attack.'
    attack:
      type: melee
      bonus: 9
      damage:
        - dice: 2d10
          bonus: 4
          type: Bludgeoning
          average: 15
        - dice: 3d6
          bonus: 0
          type: Necrotic
          average: 10
      reach: 5 ft.
      onHit:
        other: If the target is a creature, it is cursed. While cursed, the target can't regain Hit Points, it gains no benefit from finishing a Long Rest, and its Hit Point maximum decreases by 10 (3d6) every 24 hours that elapse. A creature dies and turns to dust if reduced to 0 Hit Points by this attack.
      additionalEffects: If the target is a creature, it is cursed. While cursed, the target can't regain Hit Points, it gains no benefit from finishing a Long Rest, and its Hit Point maximum decreases by 10 (3d6) every 24 hours that elapse. A creature dies and turns to dust if reduced to 0 Hit Points by this attack.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Channel Negative Energy
    entryType: attack
    text: '*Ranged Attack Roll:* +9, range 60 ft. 25 (6d6 + 4) Necrotic damage.'
    attack:
      type: ranged
      bonus: 9
      damage:
        - dice: 6d6
          bonus: 4
          type: Necrotic
          average: 25
      range: 60 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Dreadful Glare
    entryType: save
    text: '*Wisdom Saving Throw*: DC 17, one creature the mummy can see within 60 feet. *Failure:*  25 (6d6 + 4) Psychic damage, and the target has the Paralyzed condition until the end of the mummy''s next turn.'
    save:
      ability: wis
      dc: 17
      targeting:
        type: single
        range: 60 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Paralyzed
              duration:
                type: until
                trigger: the end of the mummy's next turn
        damage:
          - dice: 6d6
            bonus: 4
            type: Psychic
            average: 25
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Glare
    entryType: special
    text: The mummy uses Dreadful Glare. The mummy can't take this action again until the start of its next turn.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Necrotic Strike
    entryType: multiattack
    text: The mummy makes one Rotting Fist or Channel Negative Energy attack.
    multiattack:
      attacks:
        - name: Energy
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The mummy casts one of the following spells, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 17, +9 to hit with spell attacks): - **At Will:** *Dispel Magic*, *Thaumaturgy* - **1e/Day Each:** *Animate Dead*, *Harm*, *Insect Plague*'
    spellcasting:
      ability: wis
      saveDC: 17
      attackBonus: 9
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Dispel Magic
            - Thaumaturgy
        - frequency: 1/day
          spells:
            - Animate Dead
            - Harm
            - Insect Plague
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Dread Command
    entryType: spellcasting
    text: The mummy casts *Command* (level 2 version), using the same spellcasting ability as Spellcasting. The mummy can't take this action again until the start of its next turn.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Mummy Lord
*Small, Undead, Lawful Evil*

**AC** 17
**HP** 187 (25d8 + 75)
**Initiative** +4 (14)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** truesight 60 ft.; Passive Perception 19
**Languages** Common plus three other languages
CR 15, PB +5, XP 13000

## Traits

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the mummy fails a saving throw, it can choose to succeed instead.

**Magic Resistance**
The mummy has Advantage on saving throws against spells and other magical effects.

**Undead Restoration**
If destroyed, the mummy gains a new body in 24 hours if its heart is intact, reviving with all its Hit Points. The new body appears in an unoccupied space within the mummy's lair. The heart is a Tiny object that has AC 17, HP 10, and Immunity to all damage except Fire.

## Actions

**Multiattack**
The mummy makes one Rotting Fist or Channel Negative Energy attack, and it uses Dreadful Glare.

**Rotting Fist**
*Melee Attack Roll:* +9, reach 5 ft. 15 (2d10 + 4) Bludgeoning damage plus 10 (3d6) Necrotic damage. If the target is a creature, it is cursed. While cursed, the target can't regain Hit Points, it gains no benefit from finishing a Long Rest, and its Hit Point maximum decreases by 10 (3d6) every 24 hours that elapse. A creature dies and turns to dust if reduced to 0 Hit Points by this attack.

**Channel Negative Energy**
*Ranged Attack Roll:* +9, range 60 ft. 25 (6d6 + 4) Necrotic damage.

**Dreadful Glare**
*Wisdom Saving Throw*: DC 17, one creature the mummy can see within 60 feet. *Failure:*  25 (6d6 + 4) Psychic damage, and the target has the Paralyzed condition until the end of the mummy's next turn.

**Spellcasting**
The mummy casts one of the following spells, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 17, +9 to hit with spell attacks): - **At Will:** *Dispel Magic*, *Thaumaturgy* - **1e/Day Each:** *Animate Dead*, *Harm*, *Insect Plague*

## Legendary Actions

**Glare**
The mummy uses Dreadful Glare. The mummy can't take this action again until the start of its next turn.

**Necrotic Strike**
The mummy makes one Rotting Fist or Channel Negative Energy attack.

**Dread Command**
The mummy casts *Command* (level 2 version), using the same spellcasting ability as Spellcasting. The mummy can't take this action again until the start of its next turn.
`,
      "Monsters/mummy.md": `---
smType: creature
name: Mummy
size: Small
type: Undead
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '11'
initiative: '-1 (9)'
hp: '58'
hitDice: 9d8 + 18
speeds:
  walk:
    distance: 20 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 8
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 12
    saveProf: true
    saveMod: 3
  - key: cha
    score: 12
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Common plus two other languages
damageVulnerabilitiesList:
  - value: Fire
damageImmunitiesList:
  - value: Necrotic
  - value: Poison; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Frightened
  - value: Paralyzed
  - value: Poisoned
cr: '3'
xp: '700'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The mummy makes two Rotting Fist attacks and uses Dreadful Glare.
    multiattack:
      attacks:
        - name: Fist
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rotting Fist
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Bludgeoning damage plus 10 (3d6) Necrotic damage. If the target is a creature, it is cursed. While cursed, the target can''t regain Hit Points, its Hit Point maximum doesn''t return to normal when finishing a Long Rest, and its Hit Point maximum decreases by 10 (3d6) every 24 hours that elapse. A creature dies and turns to dust if reduced to 0 Hit Points by this attack.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d10
          bonus: 3
          type: Bludgeoning
          average: 8
        - dice: 3d6
          bonus: 0
          type: Necrotic
          average: 10
      reach: 5 ft.
      onHit:
        other: If the target is a creature, it is cursed. While cursed, the target can't regain Hit Points, its Hit Point maximum doesn't return to normal when finishing a Long Rest, and its Hit Point maximum decreases by 10 (3d6) every 24 hours that elapse. A creature dies and turns to dust if reduced to 0 Hit Points by this attack.
      additionalEffects: If the target is a creature, it is cursed. While cursed, the target can't regain Hit Points, its Hit Point maximum doesn't return to normal when finishing a Long Rest, and its Hit Point maximum decreases by 10 (3d6) every 24 hours that elapse. A creature dies and turns to dust if reduced to 0 Hit Points by this attack.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Dreadful Glare
    entryType: save
    text: '*Wisdom Saving Throw*: DC 11, one creature the mummy can see within 60 feet. *Failure:*  The target has the Frightened condition until the end of the mummy''s next turn. *Success:*  The target is immune to this mummy''s Dreadful Glare for 24 hours.'
    save:
      ability: wis
      dc: 11
      targeting:
        type: single
        range: 60 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Frightened
              duration:
                type: until
                trigger: the end of the mummy's next turn
      onSuccess: The target is immune to this mummy's Dreadful Glare for 24 hours.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Mummy
*Small, Undead, Lawful Evil*

**AC** 11
**HP** 58 (9d8 + 18)
**Initiative** -1 (9)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 11
**Languages** Common plus two other languages
CR 3, PB +2, XP 700

## Actions

**Multiattack**
The mummy makes two Rotting Fist attacks and uses Dreadful Glare.

**Rotting Fist**
*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Bludgeoning damage plus 10 (3d6) Necrotic damage. If the target is a creature, it is cursed. While cursed, the target can't regain Hit Points, its Hit Point maximum doesn't return to normal when finishing a Long Rest, and its Hit Point maximum decreases by 10 (3d6) every 24 hours that elapse. A creature dies and turns to dust if reduced to 0 Hit Points by this attack.

**Dreadful Glare**
*Wisdom Saving Throw*: DC 11, one creature the mummy can see within 60 feet. *Failure:*  The target has the Frightened condition until the end of the mummy's next turn. *Success:*  The target is immune to this mummy's Dreadful Glare for 24 hours.
`,
      "Monsters/nalfeshnee.md": `---
smType: creature
name: Nalfeshnee
size: Large
type: Fiend
typeTags:
  - value: Demon
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '18'
initiative: +5 (15)
hp: '184'
hitDice: 16d10 + 96
speeds:
  walk:
    distance: 20 ft.
  fly:
    distance: 30 ft.
abilities:
  - key: str
    score: 21
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 22
    saveProf: true
    saveMod: 11
  - key: int
    score: 19
    saveProf: true
    saveMod: 9
  - key: wis
    score: 12
    saveProf: true
    saveMod: 6
  - key: cha
    score: 15
    saveProf: true
    saveMod: 7
pb: '+5'
sensesList:
  - type: truesight
    range: '120'
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Abyssal
  - value: telepathy 120 ft.
damageResistancesList:
  - value: Cold
  - value: Fire
  - value: Lightning
damageImmunitiesList:
  - value: Poison; Frightened
conditionImmunitiesList:
  - value: Poisoned
cr: '13'
xp: '10000'
entries:
  - category: trait
    name: Demonic Restoration
    entryType: special
    text: If the nalfeshnee dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The nalfeshnee has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The nalfeshnee makes three Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +10, reach 10 ft. 16 (2d10 + 5) Slashing damage plus 11 (2d10) Force damage.'
    attack:
      type: melee
      bonus: 10
      damage:
        - dice: 2d10
          bonus: 5
          type: Slashing
          average: 16
        - dice: 2d10
          bonus: 0
          type: Force
          average: 11
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Teleport
    entryType: special
    text: The nalfeshnee teleports up to 120 feet to an unoccupied space it can see.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Horror Nimbus (Recharge 5-6)
    entryType: save
    text: '*Wisdom Saving Throw*: DC 15, each creature in a 15-foot Emanation originating from the nalfeshnee. *Failure:*  28 (8d6) Psychic damage, and the target has the Frightened condition for 1 minute, until it takes damage, or until it ends its turn with the nalfeshnee out of line of sight. *Success:*  The target is immune to this nalfeshnee''s Horror Nimbus for 24 hours.'
    recharge: 5-6
    save:
      ability: wis
      dc: 15
      targeting:
        shape: emanation
        size: 15 ft.
        origin: self
      onFail:
        effects:
          conditions:
            - condition: Frightened
              duration:
                type: until
                trigger: it takes damage
        damage:
          - dice: 8d6
            bonus: 0
            type: Psychic
            average: 28
      onSuccess: The target is immune to this nalfeshnee's Horror Nimbus for 24 hours.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Nalfeshnee
*Large, Fiend, Chaotic Evil*

**AC** 18
**HP** 184 (16d10 + 96)
**Initiative** +5 (15)
**Speed** 20 ft., fly 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** truesight 120 ft.; Passive Perception 11
**Languages** Abyssal, telepathy 120 ft.
CR 13, PB +5, XP 10000

## Traits

**Demonic Restoration**
If the nalfeshnee dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.

**Magic Resistance**
The nalfeshnee has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The nalfeshnee makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +10, reach 10 ft. 16 (2d10 + 5) Slashing damage plus 11 (2d10) Force damage.

**Teleport**
The nalfeshnee teleports up to 120 feet to an unoccupied space it can see.

## Bonus Actions

**Horror Nimbus (Recharge 5-6)**
*Wisdom Saving Throw*: DC 15, each creature in a 15-foot Emanation originating from the nalfeshnee. *Failure:*  28 (8d6) Psychic damage, and the target has the Frightened condition for 1 minute, until it takes damage, or until it ends its turn with the nalfeshnee out of line of sight. *Success:*  The target is immune to this nalfeshnee's Horror Nimbus for 24 hours.
`,
      "Monsters/night-hag.md": `---
smType: creature
name: Night Hag
size: Medium
type: Fiend
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '17'
initiative: +5 (15)
hp: '112'
hitDice: 15d8 + 45
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 16
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 16
    saveProf: false
pb: '+3'
skills:
  - skill: Deception
    value: '6'
  - skill: Insight
    value: '5'
  - skill: Perception
    value: '5'
  - skill: Stealth
    value: '5'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '15'
languagesList:
  - value: Abyssal
  - value: Common
  - value: Infernal
  - value: Primordial
damageResistancesList:
  - value: Cold
  - value: Fire
conditionImmunitiesList:
  - value: Charmed
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The hag has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Soul Bag
    entryType: special
    text: The hag has a soul bag. While holding or carrying the bag, the hag can use its Nightmare Haunting action. The bag has AC 15, HP 20, and Resistance to all damage. The bag turns to dust if reduced to 0 Hit Points. If the bag is destroyed, any souls the bag is holding are released. The hag can create a new bag after 7 days.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The hag makes two Claw attacks.
    multiattack:
      attacks:
        - name: Claw
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Slashing damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d8
          bonus: 4
          type: Slashing
          average: 13
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Shape-Shift
    entryType: special
    text: The hag shape-shifts into a Small or Medium Humanoid, or it returns to its true form. Other than its size, its game statistics are the same in each form. Any equipment it is wearing or carrying isn't transformed.
    trigger.activation: bonus
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The hag casts one of the following spells, requiring no Material components and using Intelligence as the spellcasting ability (spell save DC 14): - **At Will:** *Detect Magic*, *Etherealness*, *Magic Missile* - **2e/Day Each:** *Phantasmal Killer*, *Plane Shift*'
    spellcasting:
      ability: int
      saveDC: 14
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Etherealness
            - Magic Missile
        - frequency: 2/day
          spells:
            - Phantasmal Killer
            - Plane Shift
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Nightmare Haunting (1/Day; Requires Soul Bag)
    entryType: spellcasting
    text: While on the Ethereal Plane, the hag casts *Dream*, using the same spellcasting ability as Spellcasting. Only the hag can serve as the spell's messenger, and the target must be a creature the hag can see on the Material Plane. The spell fails and is wasted if the target is under the effect of the *Protection from Evil and Good* spell or within a *Magic Circle* spell. If the target takes damage from the *Dream* spell, the target's Hit Point maximum decreases by an amount equal to that damage. If the spell kills the target, its soul is trapped in the hag's soul bag, and the target can't be raised from the dead until its soul is released. - **At Will:** - **1/Day Each:** *Dream*, *Protection from Evil and Good*, *Magic Circle*
    limitedUse:
      count: 1
      reset: day
    spellcasting:
      ability: int
      spellLists:
        - frequency: at-will
          spells:
            - '- 1/Day Each: Dream'
            - Protection from Evil and Good
            - Magic Circle
        - frequency: 1/day
          spells:
            - Dream
            - Protection from Evil and Good
            - Magic Circle
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Night Hag
*Medium, Fiend, Neutral Evil*

**AC** 17
**HP** 112 (15d8 + 45)
**Initiative** +5 (15)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 15
**Languages** Abyssal, Common, Infernal, Primordial
CR 5, PB +3, XP 1800

## Traits

**Magic Resistance**
The hag has Advantage on saving throws against spells and other magical effects.

**Soul Bag**
The hag has a soul bag. While holding or carrying the bag, the hag can use its Nightmare Haunting action. The bag has AC 15, HP 20, and Resistance to all damage. The bag turns to dust if reduced to 0 Hit Points. If the bag is destroyed, any souls the bag is holding are released. The hag can create a new bag after 7 days.

## Actions

**Multiattack**
The hag makes two Claw attacks.

**Claw**
*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Slashing damage.

**Spellcasting**
The hag casts one of the following spells, requiring no Material components and using Intelligence as the spellcasting ability (spell save DC 14): - **At Will:** *Detect Magic*, *Etherealness*, *Magic Missile* - **2e/Day Each:** *Phantasmal Killer*, *Plane Shift*

**Nightmare Haunting (1/Day; Requires Soul Bag)**
While on the Ethereal Plane, the hag casts *Dream*, using the same spellcasting ability as Spellcasting. Only the hag can serve as the spell's messenger, and the target must be a creature the hag can see on the Material Plane. The spell fails and is wasted if the target is under the effect of the *Protection from Evil and Good* spell or within a *Magic Circle* spell. If the target takes damage from the *Dream* spell, the target's Hit Point maximum decreases by an amount equal to that damage. If the spell kills the target, its soul is trapped in the hag's soul bag, and the target can't be raised from the dead until its soul is released. - **At Will:** - **1/Day Each:** *Dream*, *Protection from Evil and Good*, *Magic Circle*

## Bonus Actions

**Shape-Shift**
The hag shape-shifts into a Small or Medium Humanoid, or it returns to its true form. Other than its size, its game statistics are the same in each form. Any equipment it is wearing or carrying isn't transformed.
`,
      "Monsters/nightmare.md": `---
smType: creature
name: Nightmare
size: Large
type: Fiend
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '13'
initiative: +2 (12)
hp: '68'
hitDice: 8d10 + 24
speeds:
  walk:
    distance: 60 ft.
  fly:
    distance: 90 ft.
    hover: true
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 15
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Understands Abyssal
  - value: Common
  - value: And Infernal but can't speak
damageImmunitiesList:
  - value: Fire
cr: '3'
xp: '700'
entries:
  - category: trait
    name: Confer Fire Resistance
    entryType: special
    text: The nightmare can grant Resistance to Fire damage to a rider while it is on the nightmare.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Illumination
    entryType: special
    text: The nightmare sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Hooves
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage plus 10 (3d6) Fire damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d8
          bonus: 4
          type: Bludgeoning
          average: 13
        - dice: 3d6
          bonus: 0
          type: Fire
          average: 10
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Ethereal Stride
    entryType: special
    text: The nightmare and up to three willing creatures within 5 feet of it teleport to the Ethereal Plane from the Material Plane or vice versa.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Nightmare
*Large, Fiend, Neutral Evil*

**AC** 13
**HP** 68 (8d10 + 24)
**Initiative** +2 (12)
**Speed** 60 ft., fly 90 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Understands Abyssal, Common, And Infernal but can't speak
CR 3, PB +2, XP 700

## Traits

**Confer Fire Resistance**
The nightmare can grant Resistance to Fire damage to a rider while it is on the nightmare.

**Illumination**
The nightmare sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.

## Actions

**Hooves**
*Melee Attack Roll:* +6, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage plus 10 (3d6) Fire damage.

**Ethereal Stride**
The nightmare and up to three willing creatures within 5 feet of it teleport to the Ethereal Plane from the Material Plane or vice versa.
`,
      "Monsters/noble.md": `---
smType: creature
name: Noble
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '15'
initiative: +1 (11)
hp: '9'
hitDice: 2d8
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 11
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 16
    saveProf: false
pb: '+2'
skills:
  - skill: Deception
    value: '5'
  - skill: Insight
    value: '4'
  - skill: Persuasion
    value: '5'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Common plus two other languages
cr: 1/8
xp: '25'
entries:
  - category: action
    name: Rapier
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 5 (1d8 + 1) Piercing damage.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 1d8
          bonus: 1
          type: Piercing
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Noble
*Small, Humanoid, Neutral Neutral*

**AC** 15
**HP** 9 (2d8)
**Initiative** +1 (11)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common plus two other languages
CR 1/8, PB +2, XP 25

## Actions

**Rapier**
*Melee Attack Roll:* +3, reach 5 ft. 5 (1d8 + 1) Piercing damage.
`,
      "Monsters/ochre-jelly.md": `---
smType: creature
name: Ochre Jelly
size: Large
type: Ooze
alignmentOverride: Unaligned
ac: '8'
initiative: '-2 (8)'
hp: '52'
hitDice: 7d10 + 14
speeds:
  walk:
    distance: 20 ft.
  climb:
    distance: 20 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 6
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 6
    saveProf: false
  - key: cha
    score: 1
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '60'
passivesList:
  - skill: Perception
    value: '8'
damageResistancesList:
  - value: Acid
damageImmunitiesList:
  - value: Lightning
  - value: Slashing; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Deafened
  - value: Frightened
  - value: Grappled
  - value: Prone
  - value: Restrained
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Amorphous
    entryType: special
    text: The jelly can move through a space as narrow as 1 inch without expending extra movement to do so.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Spider Climb
    entryType: special
    text: The jelly can climb difficult surfaces, including along ceilings, without needing to make an ability check.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Pseudopod
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 12 (3d6 + 2) Acid damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 3d6
          bonus: 2
          type: Acid
          average: 12
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Ochre Jelly
*Large, Ooze, Unaligned*

**AC** 8
**HP** 52 (7d10 + 14)
**Initiative** -2 (8)
**Speed** 20 ft., climb 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft.; Passive Perception 8
CR 2, PB +2, XP 450

## Traits

**Amorphous**
The jelly can move through a space as narrow as 1 inch without expending extra movement to do so.

**Spider Climb**
The jelly can climb difficult surfaces, including along ceilings, without needing to make an ability check.

## Actions

**Pseudopod**
*Melee Attack Roll:* +4, reach 5 ft. 12 (3d6 + 2) Acid damage.
`,
      "Monsters/ogre-zombie.md": `---
smType: creature
name: Ogre Zombie
size: Large
type: Undead
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '8'
initiative: '-2 (8)'
hp: '85'
hitDice: 9d10 + 36
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 6
    saveProf: false
  - key: con
    score: 18
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 6
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '8'
languagesList:
  - value: Understands Common and Giant but can't speak
damageImmunitiesList:
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Poisoned
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Undead Fortitude
    entryType: special
    text: If damage reduces the zombie to 0 Hit Points, it makes a Constitution saving throw (DC 5 plus the damage taken) unless the damage is Radiant or from a Critical Hit. On a successful save, the zombie drops to 1 Hit Point instead.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Slam
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d8
          bonus: 4
          type: Bludgeoning
          average: 13
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Ogre Zombie
*Large, Undead, Neutral Evil*

**AC** 8
**HP** 85 (9d10 + 36)
**Initiative** -2 (8)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 8
**Languages** Understands Common and Giant but can't speak
CR 2, PB +2, XP 450

## Traits

**Undead Fortitude**
If damage reduces the zombie to 0 Hit Points, it makes a Constitution saving throw (DC 5 plus the damage taken) unless the damage is Radiant or from a Critical Hit. On a successful save, the zombie drops to 1 Hit Point instead.

## Actions

**Slam**
*Melee Attack Roll:* +6, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage.
`,
      "Monsters/ogre.md": `---
smType: creature
name: Ogre
size: Large
type: Giant
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '11'
initiative: '-1 (9)'
hp: '68'
hitDice: 8d10 + 24
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 8
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 5
    saveProf: false
  - key: wis
    score: 7
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '8'
languagesList:
  - value: Common
  - value: Giant
cr: '2'
xp: '450'
entries:
  - category: action
    name: Greatclub
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d8
          bonus: 4
          type: Bludgeoning
          average: 13
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Javelin
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +6, reach 5 ft. or range 30/120 ft. 11 (2d6 + 4) Piercing damage.'
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Ogre
*Large, Giant, Chaotic Evil*

**AC** 11
**HP** 68 (8d10 + 24)
**Initiative** -1 (9)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 8
**Languages** Common, Giant
CR 2, PB +2, XP 450

## Actions

**Greatclub**
*Melee Attack Roll:* +6, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage.

**Javelin**
*Melee or Ranged Attack Roll:* +6, reach 5 ft. or range 30/120 ft. 11 (2d6 + 4) Piercing damage.
`,
      "Monsters/oni.md": `---
smType: creature
name: Oni
size: Large
type: Fiend
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '17'
initiative: +0 (10)
hp: '119'
hitDice: 14d10 + 42
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 30 ft.
    hover: true
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 11
    saveProf: true
    saveMod: 3
  - key: con
    score: 16
    saveProf: true
    saveMod: 6
  - key: int
    score: 14
    saveProf: false
  - key: wis
    score: 12
    saveProf: true
    saveMod: 4
  - key: cha
    score: 15
    saveProf: true
    saveMod: 5
pb: '+3'
skills:
  - skill: Arcana
    value: '5'
  - skill: Deception
    value: '8'
  - skill: Perception
    value: '4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Common
  - value: Giant
damageResistancesList:
  - value: Cold
cr: '7'
xp: '2900'
entries:
  - category: trait
    name: Regeneration
    entryType: special
    text: The oni regains 10 Hit Points at the start of each of its turns if it has at least 1 Hit Point.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The oni makes two Claw or Nightmare Ray attacks. It can replace one attack with a use of Spellcasting.
    multiattack:
      attacks:
        - name: Ray
          count: 1
      substitutions:
        - replace: attack
          with:
            type: spellcasting
            text: Spellcasting
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 10 ft. 10 (1d12 + 4) Slashing damage plus 9 (2d8) Necrotic damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 1d12
          bonus: 4
          type: Slashing
          average: 10
        - dice: 2d8
          bonus: 0
          type: Necrotic
          average: 9
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Nightmare Ray
    entryType: attack
    text: '*Ranged Attack Roll:* +5, range 60 ft. 9 (2d6 + 2) Psychic damage, and the target has the Frightened condition until the start of the oni''s next turn.'
    attack:
      type: ranged
      bonus: 5
      damage:
        - dice: 2d6
          bonus: 2
          type: Psychic
          average: 9
      range: 60 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Shape-Shift
    entryType: special
    text: The oni shape-shifts into a Small or Medium Humanoid or a Large Giant, or it returns to its true form. Other than its size, its game statistics are the same in each form. Any equipment it is wearing or carrying isn't transformed.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The oni casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 13): - **At Will:** - **1e/Day Each:** *Charm Person*, *Darkness*, *Gaseous Form*, *Sleep*'
    spellcasting:
      ability: cha
      saveDC: 13
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - '- 1e/Day Each: Charm Person'
            - Darkness
            - Gaseous Form
            - Sleep
        - frequency: 1/day
          spells:
            - Charm Person
            - Darkness
            - Gaseous Form
            - Sleep
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Invisibility
    entryType: spellcasting
    text: The oni casts *Invisibility* on itself, requiring no spell components and using the same spellcasting ability as Spellcasting.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Oni
*Large, Fiend, Lawful Evil*

**AC** 17
**HP** 119 (14d10 + 42)
**Initiative** +0 (10)
**Speed** 30 ft., fly 30 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 14
**Languages** Common, Giant
CR 7, PB +3, XP 2900

## Traits

**Regeneration**
The oni regains 10 Hit Points at the start of each of its turns if it has at least 1 Hit Point.

## Actions

**Multiattack**
The oni makes two Claw or Nightmare Ray attacks. It can replace one attack with a use of Spellcasting.

**Claw**
*Melee Attack Roll:* +7, reach 10 ft. 10 (1d12 + 4) Slashing damage plus 9 (2d8) Necrotic damage.

**Nightmare Ray**
*Ranged Attack Roll:* +5, range 60 ft. 9 (2d6 + 2) Psychic damage, and the target has the Frightened condition until the start of the oni's next turn.

**Shape-Shift**
The oni shape-shifts into a Small or Medium Humanoid or a Large Giant, or it returns to its true form. Other than its size, its game statistics are the same in each form. Any equipment it is wearing or carrying isn't transformed.

**Spellcasting**
The oni casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 13): - **At Will:** - **1e/Day Each:** *Charm Person*, *Darkness*, *Gaseous Form*, *Sleep*

## Bonus Actions

**Invisibility**
The oni casts *Invisibility* on itself, requiring no spell components and using the same spellcasting ability as Spellcasting.
`,
      "Monsters/otyugh.md": `---
smType: creature
name: Otyugh
size: Large
type: Aberration
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '14'
initiative: +0 (10)
hp: '104'
hitDice: 11d10 + 44
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 19
    saveProf: true
    saveMod: 7
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+3'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Otyugh
  - value: telepathy 120 ft. (doesn't allow the receiving creature to respond telepathically)
cr: '5'
xp: '1800'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The otyugh makes one Bite attack and two Tentacle attacks.
    multiattack:
      attacks:
        - name: Bite
          count: 1
        - name: Tentacle
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 12 (2d8 + 3) Piercing damage, and the target has the Poisoned condition. Whenever the Poisoned target finishes a Long Rest, it is subjected to the following effect. *Constitution Saving Throw*: DC 15. *Failure:*  The target''s Hit Point maximum decreases by 5 (1d10) and doesn''t return to normal until the Poisoned condition ends on the target. *Success:*  The Poisoned condition ends.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d8
          bonus: 3
          type: Piercing
          average: 12
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Tentacle
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 10 ft. 12 (2d8 + 3) Piercing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 13) from one of two tentacles.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d8
          bonus: 3
          type: Piercing
          average: 12
      reach: 10 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 13
            restrictions:
              size: Medium or smaller
      additionalEffects: If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 13) from one of two tentacles.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Tentacle Slam
    entryType: save
    text: '*Constitution Saving Throw*: DC 14, each creature Grappled by the otyugh. *Failure:*  16 (3d8 + 3) Bludgeoning damage, and the target has the Stunned condition until the start of the otyugh''s next turn. *Success:*  Half damage only.'
    save:
      ability: con
      dc: 14
      targeting:
        type: single
        restrictions:
          other:
            - grappled by source
      onFail:
        effects:
          conditions:
            - condition: Stunned
              duration:
                type: until
                trigger: the start of the otyugh's next turn
        damage:
          - dice: 3d8
            bonus: 3
            type: Bludgeoning
            average: 16
      onSuccess:
        damage: half
        legacyText: Half damage only.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Otyugh
*Large, Aberration, Neutral Neutral*

**AC** 14
**HP** 104 (11d10 + 44)
**Initiative** +0 (10)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 11
**Languages** Otyugh, telepathy 120 ft. (doesn't allow the receiving creature to respond telepathically)
CR 5, PB +3, XP 1800

## Actions

**Multiattack**
The otyugh makes one Bite attack and two Tentacle attacks.

**Bite**
*Melee Attack Roll:* +6, reach 5 ft. 12 (2d8 + 3) Piercing damage, and the target has the Poisoned condition. Whenever the Poisoned target finishes a Long Rest, it is subjected to the following effect. *Constitution Saving Throw*: DC 15. *Failure:*  The target's Hit Point maximum decreases by 5 (1d10) and doesn't return to normal until the Poisoned condition ends on the target. *Success:*  The Poisoned condition ends.

**Tentacle**
*Melee Attack Roll:* +6, reach 10 ft. 12 (2d8 + 3) Piercing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 13) from one of two tentacles.

**Tentacle Slam**
*Constitution Saving Throw*: DC 14, each creature Grappled by the otyugh. *Failure:*  16 (3d8 + 3) Bludgeoning damage, and the target has the Stunned condition until the start of the otyugh's next turn. *Success:*  Half damage only.
`,
      "Monsters/owlbear.md": `---
smType: creature
name: Owlbear
size: Large
type: Monstrosity
alignmentOverride: Unaligned
ac: '13'
initiative: +1 (11)
hp: '59'
hitDice: 7d10 + 21
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 40 ft.
abilities:
  - key: str
    score: 20
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '15'
cr: '3'
xp: '700'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The owlbear makes two Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 14 (2d8 + 5) Slashing damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d8
          bonus: 5
          type: Slashing
          average: 14
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Owlbear
*Large, Monstrosity, Unaligned*

**AC** 13
**HP** 59 (7d10 + 21)
**Initiative** +1 (11)
**Speed** 40 ft., climb 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 15
CR 3, PB +2, XP 700

## Actions

**Multiattack**
The owlbear makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +7, reach 5 ft. 14 (2d8 + 5) Slashing damage.
`,
      "Monsters/pegasus.md": `---
smType: creature
name: Pegasus
size: Large
type: Celestial
alignmentLawChaos: Chaotic
alignmentGoodEvil: Good
ac: '12'
initiative: +2 (12)
hp: '59'
hitDice: 7d10 + 21
speeds:
  walk:
    distance: 60 ft.
  fly:
    distance: 90 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 15
    saveProf: true
    saveMod: 4
  - key: con
    score: 16
    saveProf: true
    saveMod: 5
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 15
    saveProf: true
    saveMod: 4
  - key: cha
    score: 13
    saveProf: true
    saveMod: 3
pb: '+2'
skills:
  - skill: Perception
    value: '6'
passivesList:
  - skill: Perception
    value: '16'
languagesList:
  - value: Understands Celestial
  - value: Common
  - value: Elvish
  - value: And Sylvan but can't speak
cr: '2'
xp: '450'
entries:
  - category: action
    name: Hooves
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 7 (1d6 + 4) Bludgeoning damage plus 5 (2d4) Radiant damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d6
          bonus: 4
          type: Bludgeoning
          average: 7
        - dice: 2d4
          bonus: 0
          type: Radiant
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Pegasus
*Large, Celestial, Chaotic Good*

**AC** 12
**HP** 59 (7d10 + 21)
**Initiative** +2 (12)
**Speed** 60 ft., fly 90 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Understands Celestial, Common, Elvish, And Sylvan but can't speak
CR 2, PB +2, XP 450

## Actions

**Hooves**
*Melee Attack Roll:* +6, reach 5 ft. 7 (1d6 + 4) Bludgeoning damage plus 5 (2d4) Radiant damage.
`,
      "Monsters/phase-spider.md": `---
smType: creature
name: Phase Spider
size: Large
type: Monstrosity
alignmentOverride: Unaligned
ac: '14'
initiative: +3 (13)
hp: '45'
hitDice: 7d10 + 7
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '7'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
cr: '3'
xp: '700'
entries:
  - category: trait
    name: Ethereal Sight
    entryType: special
    text: The spider can see 60 feet into the Ethereal Plane while on the Material Plane and vice versa.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Spider Climb
    entryType: special
    text: The spider can climb difficult surfaces, including along ceilings, without needing to make an ability check.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Web Walker
    entryType: special
    text: The spider ignores movement restrictions caused by webs, and the spider knows the location of any other creature in contact with the same web.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The spider makes two Bite attacks.
    multiattack:
      attacks:
        - name: Bite
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Piercing damage plus 9 (2d8) Poison damage. If this damage reduces the target to 0 Hit Points, the target becomes Stable, and it has the Poisoned condition for 1 hour. While Poisoned, the target also has the Paralyzed condition.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d10
          bonus: 3
          type: Piercing
          average: 8
        - dice: 2d8
          bonus: 0
          type: Poison
          average: 9
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Poisoned
            duration:
              type: hours
              count: 1
            restrictions:
              while: While Poisoned, the target also has the Paralyzed condition
          - condition: Paralyzed
            duration:
              type: hours
              count: 1
            restrictions:
              while: While Poisoned, the target also has the Paralyzed condition
      additionalEffects: If this damage reduces the target to 0 Hit Points, the target becomes Stable, and it has the Poisoned condition for 1 hour. While Poisoned, the target also has the Paralyzed condition.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Ethereal Jaunt
    entryType: special
    text: The spider teleports from the Material Plane to the Ethereal Plane or vice versa.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Phase Spider
*Large, Monstrosity, Unaligned*

**AC** 14
**HP** 45 (7d10 + 7)
**Initiative** +3 (13)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
CR 3, PB +2, XP 700

## Traits

**Ethereal Sight**
The spider can see 60 feet into the Ethereal Plane while on the Material Plane and vice versa.

**Spider Climb**
The spider can climb difficult surfaces, including along ceilings, without needing to make an ability check.

**Web Walker**
The spider ignores movement restrictions caused by webs, and the spider knows the location of any other creature in contact with the same web.

## Actions

**Multiattack**
The spider makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Piercing damage plus 9 (2d8) Poison damage. If this damage reduces the target to 0 Hit Points, the target becomes Stable, and it has the Poisoned condition for 1 hour. While Poisoned, the target also has the Paralyzed condition.

## Bonus Actions

**Ethereal Jaunt**
The spider teleports from the Material Plane to the Ethereal Plane or vice versa.
`,
      "Monsters/pirate-captain.md": `---
smType: creature
name: Pirate Captain
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '17'
initiative: +7 (17)
hp: '84'
hitDice: 13d8 + 26
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 10
    saveProf: true
    saveMod: 3
  - key: dex
    score: 18
    saveProf: true
    saveMod: 7
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 14
    saveProf: true
    saveMod: 5
  - key: cha
    score: 17
    saveProf: true
    saveMod: 6
pb: '+3'
skills:
  - skill: Acrobatics
    value: '7'
  - skill: Perception
    value: '5'
passivesList:
  - skill: Perception
    value: '15'
languagesList:
  - value: Common plus one other language
cr: '6'
xp: '2300'
entries:
  - category: action
    name: Multiattack
    entryType: special
    text: The pirate makes three attacks, using Rapier or Pistol in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Rapier
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Piercing damage, and the pirate has Advantage on the next attack roll it makes before the end of this turn.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d8
          bonus: 4
          type: Piercing
          average: 13
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Pistol
    entryType: attack
    text: '*Ranged Attack Roll:* +7, range 30/90 ft. 15 (2d10 + 4) Piercing damage.'
    attack:
      type: ranged
      bonus: 7
      damage:
        - dice: 2d10
          bonus: 4
          type: Piercing
          average: 15
      range: 30/90 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Captain's Charm
    entryType: save
    text: '*Wisdom Saving Throw*: DC 14, one creature the pirate can see within 30 feet. *Failure:*  The target has the Charmed condition until the start of the pirate''s next turn.'
    save:
      ability: wis
      dc: 14
      targeting:
        type: single
        range: 30 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Charmed
              duration:
                type: until
                trigger: the start of the pirate's next turn
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Pirate Captain
*Small, Humanoid, Neutral Neutral*

**AC** 17
**HP** 84 (13d8 + 26)
**Initiative** +7 (17)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common plus one other language
CR 6, PB +3, XP 2300

## Actions

**Multiattack**
The pirate makes three attacks, using Rapier or Pistol in any combination.

**Rapier**
*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Piercing damage, and the pirate has Advantage on the next attack roll it makes before the end of this turn.

**Pistol**
*Ranged Attack Roll:* +7, range 30/90 ft. 15 (2d10 + 4) Piercing damage.

## Bonus Actions

**Captain's Charm**
*Wisdom Saving Throw*: DC 14, one creature the pirate can see within 30 feet. *Failure:*  The target has the Charmed condition until the start of the pirate's next turn.
`,
      "Monsters/pirate.md": `---
smType: creature
name: Pirate
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '14'
initiative: +5 (15)
hp: '33'
hitDice: 6d8 + 6
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 16
    saveProf: true
    saveMod: 5
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 8
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 14
    saveProf: true
    saveMod: 4
pb: '+2'
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Common plus one other language
cr: '1'
xp: '200'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The pirate makes two Dagger attacks. It can replace one attack with a use of Enthralling Panache.
    multiattack:
      attacks:
        - name: Dagger
          count: 2
      substitutions:
        - replace: attack
          with:
            type: attack
            name: Enthralling Panache
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Dagger
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +5, reach 5 ft. or range 20/60 ft. 5 (1d4 + 3) Piercing damage.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Enthralling Panache
    entryType: save
    text: '*Wisdom Saving Throw*: DC 12, one creature the pirate can see within 30 feet. *Failure:*  The target has the Charmed condition until the start of the pirate''s next turn.'
    save:
      ability: wis
      dc: 12
      targeting:
        type: single
        range: 30 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Charmed
              duration:
                type: until
                trigger: the start of the pirate's next turn
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Pirate
*Small, Humanoid, Neutral Neutral*

**AC** 14
**HP** 33 (6d8 + 6)
**Initiative** +5 (15)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common plus one other language
CR 1, PB +2, XP 200

## Actions

**Multiattack**
The pirate makes two Dagger attacks. It can replace one attack with a use of Enthralling Panache.

**Dagger**
*Melee or Ranged Attack Roll:* +5, reach 5 ft. or range 20/60 ft. 5 (1d4 + 3) Piercing damage.

**Enthralling Panache**
*Wisdom Saving Throw*: DC 12, one creature the pirate can see within 30 feet. *Failure:*  The target has the Charmed condition until the start of the pirate's next turn.
`,
      "Monsters/pit-fiend.md": `---
smType: creature
name: Pit Fiend
size: Large
type: Fiend
typeTags:
  - value: Devil
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '21'
initiative: +14 (24)
hp: '337'
hitDice: 27d10 + 189
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 26
    saveProf: false
  - key: dex
    score: 14
    saveProf: true
    saveMod: 8
  - key: con
    score: 24
    saveProf: false
  - key: int
    score: 22
    saveProf: false
  - key: wis
    score: 18
    saveProf: true
    saveMod: 10
  - key: cha
    score: 24
    saveProf: false
pb: '+6'
skills:
  - skill: Perception
    value: '10'
  - skill: Persuasion
    value: '19'
sensesList:
  - type: truesight
    range: '120'
passivesList:
  - skill: Perception
    value: '20'
languagesList:
  - value: Infernal
  - value: telepathy 120 ft.
damageResistancesList:
  - value: Cold
damageImmunitiesList:
  - value: Fire
  - value: Poison; Poisoned
cr: '20'
xp: '25000'
entries:
  - category: trait
    name: Diabolical Restoration
    entryType: special
    text: If the pit fiend dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Fear Aura
    entryType: save
    text: 'The pit fiend emanates an aura in a 20-foot Emanation while it doesn''t have the Incapacitated condition. *Wisdom Saving Throw*: DC 21, any enemy that starts its turn in the aura. *Failure:*  The target has the Frightened condition until the start of its next turn. *Success:*  The target is immune to this pit fiend''s aura for 24 hours.'
    save:
      ability: wis
      dc: 21
      targeting:
        type: special
      onFail:
        effects:
          conditions:
            - condition: Frightened
              duration:
                type: until
                trigger: the start of its next turn
      onSuccess: The target is immune to this pit fiend's aura for 24 hours.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (4/Day)
    entryType: special
    text: If the pit fiend fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 4
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The pit fiend has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The pit fiend makes one Bite attack, two Devilish Claw attacks, and one Fiery Mace attack.
    multiattack:
      attacks:
        - name: Bite
          count: 1
        - name: Claw
          count: 1
        - name: Mace
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +14, reach 10 ft. 18 (3d6 + 8) Piercing damage. If the target is a creature, it must make the following saving throw. *Constitution Saving Throw*: DC 21. *Failure:*  The target has the Poisoned condition. While Poisoned, the target can''t regain Hit Points and takes 21 (6d6) Poison damage at the start of each of its turns, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.'
    attack:
      type: melee
      bonus: 14
      damage:
        - dice: 3d6
          bonus: 8
          type: Piercing
          average: 18
        - dice: 6d6
          bonus: 0
          type: Poison
          average: 21
      reach: 10 ft.
      onHit:
        conditions:
          - condition: Poisoned
            saveToEnd:
              timing: end-of-turn
      additionalEffects: 'If the target is a creature, it must make the following saving throw. *Constitution Saving Throw*: DC 21. *Failure:*  The target has the Poisoned condition. While Poisoned, the target can''t regain Hit Points and takes 21 (6d6) Poison damage at the start of each of its turns, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Devilish Claw
    entryType: attack
    text: '*Melee Attack Roll:* +14, reach 10 ft. 26 (4d8 + 8) Necrotic damage.'
    attack:
      type: melee
      bonus: 14
      damage:
        - dice: 4d8
          bonus: 8
          type: Necrotic
          average: 26
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fiery Mace
    entryType: attack
    text: '*Melee Attack Roll:* +14, reach 10 ft. 22 (4d6 + 8) Force damage plus 21 (6d6) Fire damage.'
    attack:
      type: melee
      bonus: 14
      damage:
        - dice: 4d6
          bonus: 8
          type: Force
          average: 22
        - dice: 6d6
          bonus: 0
          type: Fire
          average: 21
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Hellfire Spellcasting (Recharge 4-6)
    entryType: spellcasting
    text: The pit fiend casts *Fireball* (level 5 version) twice, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21). It can replace one *Fireball* with *Hold Monster* (level 7 version) or *Wall of Fire*. - **At Will:**
    recharge: 4-6
    spellcasting:
      ability: cha
      saveDC: 21
      excludeComponents:
        - M
      spellLists: []
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Pit Fiend
*Large, Fiend, Lawful Evil*

**AC** 21
**HP** 337 (27d10 + 189)
**Initiative** +14 (24)
**Speed** 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** truesight 120 ft.; Passive Perception 20
**Languages** Infernal, telepathy 120 ft.
CR 20, PB +6, XP 25000

## Traits

**Diabolical Restoration**
If the pit fiend dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.

**Fear Aura**
The pit fiend emanates an aura in a 20-foot Emanation while it doesn't have the Incapacitated condition. *Wisdom Saving Throw*: DC 21, any enemy that starts its turn in the aura. *Failure:*  The target has the Frightened condition until the start of its next turn. *Success:*  The target is immune to this pit fiend's aura for 24 hours.

**Legendary Resistance (4/Day)**
If the pit fiend fails a saving throw, it can choose to succeed instead.

**Magic Resistance**
The pit fiend has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The pit fiend makes one Bite attack, two Devilish Claw attacks, and one Fiery Mace attack.

**Bite**
*Melee Attack Roll:* +14, reach 10 ft. 18 (3d6 + 8) Piercing damage. If the target is a creature, it must make the following saving throw. *Constitution Saving Throw*: DC 21. *Failure:*  The target has the Poisoned condition. While Poisoned, the target can't regain Hit Points and takes 21 (6d6) Poison damage at the start of each of its turns, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.

**Devilish Claw**
*Melee Attack Roll:* +14, reach 10 ft. 26 (4d8 + 8) Necrotic damage.

**Fiery Mace**
*Melee Attack Roll:* +14, reach 10 ft. 22 (4d6 + 8) Force damage plus 21 (6d6) Fire damage.

**Hellfire Spellcasting (Recharge 4-6)**
The pit fiend casts *Fireball* (level 5 version) twice, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21). It can replace one *Fireball* with *Hold Monster* (level 7 version) or *Wall of Fire*. - **At Will:**
`,
      "Monsters/planetar.md": `---
smType: creature
name: Planetar
size: Large
type: Celestial
typeTags:
  - value: Angel
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '19'
initiative: +10 (20)
hp: '262'
hitDice: 21d10 + 147
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 120 ft.
    hover: true
abilities:
  - key: str
    score: 24
    saveProf: true
    saveMod: 12
  - key: dex
    score: 20
    saveProf: false
  - key: con
    score: 24
    saveProf: true
    saveMod: 12
  - key: int
    score: 19
    saveProf: false
  - key: wis
    score: 22
    saveProf: true
    saveMod: 11
  - key: cha
    score: 25
    saveProf: true
    saveMod: 12
pb: '+5'
skills:
  - skill: Perception
    value: '11'
sensesList:
  - type: truesight
    range: '120'
passivesList:
  - skill: Perception
    value: '21'
languagesList:
  - value: All
  - value: telepathy 120 ft.
damageResistancesList:
  - value: Radiant
damageImmunitiesList:
  - value: Exhaustion
conditionImmunitiesList:
  - value: Charmed
  - value: Frightened
cr: '16'
xp: '15000'
entries:
  - category: trait
    name: Divine Awareness
    entryType: special
    text: The planetar knows if it hears a lie.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Exalted Restoration
    entryType: special
    text: If the planetar dies outside Mount Celestia, its body disappears, and it gains a new body instantly, reviving with all its Hit Points somewhere in Mount Celestia.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The planetar has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The planetar makes three Radiant Sword attacks or uses Holy Burst twice.
    multiattack:
      attacks:
        - name: Sword
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Radiant Sword
    entryType: attack
    text: '*Melee Attack Roll:* +12, reach 10 ft. 14 (2d6 + 7) Slashing damage plus 18 (4d8) Radiant damage.'
    attack:
      type: melee
      bonus: 12
      damage:
        - dice: 2d6
          bonus: 7
          type: Slashing
          average: 14
        - dice: 4d8
          bonus: 0
          type: Radiant
          average: 18
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Holy Burst
    entryType: save
    text: '*Dexterity Saving Throw*: DC 20, each enemy in a 20-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the planetar can see within 120 feet. *Failure:*  24 (7d6) Radiant damage. *Success:*  Half damage.'
    save:
      ability: dex
      dc: 20
      targeting:
        shape: sphere
        size: 20 ft.
      onFail:
        effects:
          other: 24 (7d6) Radiant damage.
        damage:
          - dice: 7d6
            bonus: 0
            type: Radiant
            average: 24
        legacyEffects: 24 (7d6) Radiant damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The planetar casts one of the following spells, requiring no Material components and using Charisma as spellcasting ability (spell save DC 20): - **At Will:** *Detect Evil and Good* - **1e/Day Each:** *Commune*, *Control Weather*, *Dispel Evil and Good*, *Raise Dead*'
    spellcasting:
      ability: cha
      saveDC: 20
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Evil and Good
        - frequency: 1/day
          spells:
            - Commune
            - Control Weather
            - Dispel Evil and Good
            - Raise Dead
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Divine Aid (2/Day)
    entryType: spellcasting
    text: The planetar casts *Cure Wounds*, *Invisibility*, *Lesser Restoration*, or *Remove Curse*, using the same spellcasting ability as Spellcasting.
    limitedUse:
      count: 2
      reset: day
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Planetar
*Large, Celestial, Lawful Good*

**AC** 19
**HP** 262 (21d10 + 147)
**Initiative** +10 (20)
**Speed** 40 ft., fly 120 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** truesight 120 ft.; Passive Perception 21
**Languages** All, telepathy 120 ft.
CR 16, PB +5, XP 15000

## Traits

**Divine Awareness**
The planetar knows if it hears a lie.

**Exalted Restoration**
If the planetar dies outside Mount Celestia, its body disappears, and it gains a new body instantly, reviving with all its Hit Points somewhere in Mount Celestia.

**Magic Resistance**
The planetar has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The planetar makes three Radiant Sword attacks or uses Holy Burst twice.

**Radiant Sword**
*Melee Attack Roll:* +12, reach 10 ft. 14 (2d6 + 7) Slashing damage plus 18 (4d8) Radiant damage.

**Holy Burst**
*Dexterity Saving Throw*: DC 20, each enemy in a 20-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the planetar can see within 120 feet. *Failure:*  24 (7d6) Radiant damage. *Success:*  Half damage.

**Spellcasting**
The planetar casts one of the following spells, requiring no Material components and using Charisma as spellcasting ability (spell save DC 20): - **At Will:** *Detect Evil and Good* - **1e/Day Each:** *Commune*, *Control Weather*, *Dispel Evil and Good*, *Raise Dead*

## Bonus Actions

**Divine Aid (2/Day)**
The planetar casts *Cure Wounds*, *Invisibility*, *Lesser Restoration*, or *Remove Curse*, using the same spellcasting ability as Spellcasting.
`,
      "Monsters/priest-acolyte.md": `---
smType: creature
name: Priest Acolyte
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '13'
initiative: +0 (10)
hp: '11'
hitDice: 2d8 + 2
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 14
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 11
    saveProf: false
pb: '+2'
skills:
  - skill: Medicine
    value: '4'
  - skill: Religion
    value: '2'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Common
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Mace
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Bludgeoning damage plus 2 (1d4) Radiant damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Bludgeoning
          average: 5
        - dice: 1d4
          bonus: 0
          type: Radiant
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Radiant Flame
    entryType: attack
    text: '*Ranged Attack Roll:* +4, range 60 ft. 7 (2d6) Radiant damage.'
    attack:
      type: ranged
      bonus: 4
      damage:
        - dice: 2d6
          bonus: 0
          type: Radiant
          average: 7
      range: 60 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The priest casts one of the following spells, using Wisdom as the spellcasting ability: - **At Will:** *Light*, *Thaumaturgy*'
    spellcasting:
      ability: wis
      spellLists:
        - frequency: at-will
          spells:
            - Light
            - Thaumaturgy
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Divine Aid (1/Day)
    entryType: spellcasting
    text: The priest casts *Bless*, *Healing Word*, or *Sanctuary*, using the same spellcasting ability as Spellcasting.
    limitedUse:
      count: 1
      reset: day
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Priest Acolyte
*Small, Humanoid, Neutral Neutral*

**AC** 13
**HP** 11 (2d8 + 2)
**Initiative** +0 (10)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common
CR 1/4, PB +2, XP 50

## Actions

**Mace**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Bludgeoning damage plus 2 (1d4) Radiant damage.

**Radiant Flame**
*Ranged Attack Roll:* +4, range 60 ft. 7 (2d6) Radiant damage.

**Spellcasting**
The priest casts one of the following spells, using Wisdom as the spellcasting ability: - **At Will:** *Light*, *Thaumaturgy*

## Bonus Actions

**Divine Aid (1/Day)**
The priest casts *Bless*, *Healing Word*, or *Sanctuary*, using the same spellcasting ability as Spellcasting.
`,
      "Monsters/priest.md": `---
smType: creature
name: Priest
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '13'
initiative: +0 (10)
hp: '38'
hitDice: 7d8 + 7
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 13
    saveProf: false
  - key: wis
    score: 16
    saveProf: false
  - key: cha
    score: 13
    saveProf: false
pb: '+2'
skills:
  - skill: Medicine
    value: '7'
  - skill: Perception
    value: '5'
  - skill: Religion
    value: '5'
passivesList:
  - skill: Perception
    value: '15'
languagesList:
  - value: Common plus one other language
cr: '2'
xp: '450'
entries:
  - category: action
    name: Multiattack
    entryType: special
    text: The priest makes two attacks, using Mace or Radiant Flame in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Mace
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage plus 5 (2d4) Radiant damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d6
          bonus: 3
          type: Bludgeoning
          average: 6
        - dice: 2d4
          bonus: 0
          type: Radiant
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Radiant Flame
    entryType: attack
    text: '*Ranged Attack Roll:* +5, range 60 ft. 11 (2d10) Radiant damage.'
    attack:
      type: ranged
      bonus: 5
      damage:
        - dice: 2d10
          bonus: 0
          type: Radiant
          average: 11
      range: 60 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The priest casts one of the following spells, using Wisdom as the spellcasting ability: - **At Will:** *Light*, *Thaumaturgy* - **1/Day Each:** *Spirit Guardians*'
    spellcasting:
      ability: wis
      spellLists:
        - frequency: at-will
          spells:
            - Light
            - Thaumaturgy
        - frequency: 1/day
          spells:
            - Spirit Guardians
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Divine Aid (3/Day)
    entryType: spellcasting
    text: The priest casts *Bless*, *Dispel Magic*, *Healing Word*, or *Lesser Restoration*, using the same spellcasting ability as Spellcasting.
    limitedUse:
      count: 3
      reset: day
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Priest
*Small, Humanoid, Neutral Neutral*

**AC** 13
**HP** 38 (7d8 + 7)
**Initiative** +0 (10)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common plus one other language
CR 2, PB +2, XP 450

## Actions

**Multiattack**
The priest makes two attacks, using Mace or Radiant Flame in any combination.

**Mace**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage plus 5 (2d4) Radiant damage.

**Radiant Flame**
*Ranged Attack Roll:* +5, range 60 ft. 11 (2d10) Radiant damage.

**Spellcasting**
The priest casts one of the following spells, using Wisdom as the spellcasting ability: - **At Will:** *Light*, *Thaumaturgy* - **1/Day Each:** *Spirit Guardians*

## Bonus Actions

**Divine Aid (3/Day)**
The priest casts *Bless*, *Dispel Magic*, *Healing Word*, or *Lesser Restoration*, using the same spellcasting ability as Spellcasting.
`,
      "Monsters/pseudodragon.md": `---
smType: creature
name: Pseudodragon
size: Small
type: Dragon
alignmentLawChaos: Neutral
alignmentGoodEvil: Good
ac: '14'
initiative: +2 (12)
hp: '10'
hitDice: 3d4 + 3
speeds:
  walk:
    distance: 15 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 6
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 10
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
  - skill: Stealth
    value: '4'
sensesList:
  - type: blindsight
    range: '10'
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '15'
languagesList:
  - value: Understands Common and Draconic but can't speak
cr: 1/4
xp: '50'
entries:
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The pseudodragon has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The pseudodragon makes two Bite attacks.
    multiattack:
      attacks:
        - name: Bite
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d4
          bonus: 2
          type: Piercing
          average: 4
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Sting
    entryType: save
    text: '*Constitution Saving Throw*: DC 12, one creature the pseudodragon can see within 5 feet. *Failure:*  5 (2d4) Poison damage, and the target has the Poisoned condition for 1 hour. *Failure by 5 or More:* While Poisoned, the target also has the Unconscious condition, which ends early if the target takes damage or a creature within 5 feet of it takes an action to wake it.'
    save:
      ability: con
      dc: 12
      targeting:
        type: single
        range: 5 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Poisoned
              duration:
                type: hours
                count: 1
              restrictions:
                while: While Poisoned, the target also has the Unconscious condition
            - condition: Unconscious
              duration:
                type: hours
                count: 1
              restrictions:
                while: While Poisoned, the target also has the Unconscious condition
        damage:
          - dice: 2d4
            bonus: 0
            type: Poison
            average: 5
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Pseudodragon
*Small, Dragon, Neutral Good*

**AC** 14
**HP** 10 (3d4 + 3)
**Initiative** +2 (12)
**Speed** 15 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft., darkvision 60 ft.; Passive Perception 15
**Languages** Understands Common and Draconic but can't speak
CR 1/4, PB +2, XP 50

## Traits

**Magic Resistance**
The pseudodragon has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The pseudodragon makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage.

**Sting**
*Constitution Saving Throw*: DC 12, one creature the pseudodragon can see within 5 feet. *Failure:*  5 (2d4) Poison damage, and the target has the Poisoned condition for 1 hour. *Failure by 5 or More:* While Poisoned, the target also has the Unconscious condition, which ends early if the target takes damage or a creature within 5 feet of it takes an action to wake it.
`,
      "Monsters/purple-worm.md": `---
smType: creature
name: Purple Worm
size: Gargantuan
type: Monstrosity
alignmentOverride: Unaligned
ac: '18'
initiative: +3 (13)
hp: '247'
hitDice: 15d20 + 90
speeds:
  walk:
    distance: 50 ft.
  burrow:
    distance: 50 ft.
abilities:
  - key: str
    score: 28
    saveProf: false
  - key: dex
    score: 7
    saveProf: false
  - key: con
    score: 22
    saveProf: true
    saveMod: 11
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 8
    saveProf: true
    saveMod: 4
  - key: cha
    score: 4
    saveProf: false
pb: '+5'
sensesList:
  - type: blindsight
    range: '30'
  - type: tremorsense
    range: '60'
passivesList:
  - skill: Perception
    value: '9'
cr: '15'
xp: '13000'
entries:
  - category: trait
    name: Tunneler
    entryType: special
    text: The worm can burrow through solid rock at half its Burrow Speed and leaves a 10-foot-diameter tunnel in its wake.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The worm makes one Bite attack and one Tail Stinger attack.
    multiattack:
      attacks:
        - name: Bite
          count: 1
        - name: Stinger
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +14, reach 10 ft. 22 (3d8 + 9) Piercing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 19), and it has the Restrained condition until the grapple ends.'
    attack:
      type: melee
      bonus: 14
      damage:
        - dice: 3d8
          bonus: 9
          type: Piercing
          average: 22
      reach: 10 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 19
            restrictions:
              size: Large or smaller
            duration:
              type: until
              trigger: the grapple ends
          - condition: Restrained
            escape:
              type: dc
              dc: 19
            restrictions:
              size: Large or smaller
            duration:
              type: until
              trigger: the grapple ends
      additionalEffects: If the target is a Large or smaller creature, it has the Grappled condition (escape DC 19), and it has the Restrained condition until the grapple ends.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Tail Stinger
    entryType: attack
    text: '*Melee Attack Roll:* +14, reach 10 ft. 16 (2d6 + 9) Piercing damage plus 35 (10d6) Poison damage.'
    attack:
      type: melee
      bonus: 14
      damage:
        - dice: 2d6
          bonus: 9
          type: Piercing
          average: 16
        - dice: 10d6
          bonus: 0
          type: Poison
          average: 35
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Swallow
    entryType: save
    text: '*Strength Saving Throw*: DC 19, one Large or smaller creature Grappled by the worm (it can have up to three creatures swallowed at a time). *Failure:*  The target is swallowed by the worm, and the Grappled condition ends. A swallowed creature has the Blinded and Restrained conditions, has Cover|XPHB|Total Cover against attacks and other effects outside the worm, and takes 17 (5d6) Acid damage at the start of each of the worm''s turns. If the worm takes 30 damage or more on a single turn from a creature inside it, the worm must succeed on a DC 21 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, each of which falls in a space within 5 feet of the worm and has the Prone condition. If the worm dies, any swallowed creature no longer has the Restrained condition and can escape from the corpse using 20 feet of movement, exiting Prone.'
    save:
      ability: str
      dc: 19
      targeting:
        type: single
        count: 3
        restrictions:
          size:
            - Large
            - smaller
          other:
            - grappled by source
      onFail:
        effects:
          conditions:
            - condition: Prone
            - condition: Restrained
        damage:
          - dice: 5d6
            bonus: 0
            type: Acid
            average: 17
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Purple Worm
*Gargantuan, Monstrosity, Unaligned*

**AC** 18
**HP** 247 (15d20 + 90)
**Initiative** +3 (13)
**Speed** 50 ft., burrow 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft., tremorsense 60 ft.; Passive Perception 9
CR 15, PB +5, XP 13000

## Traits

**Tunneler**
The worm can burrow through solid rock at half its Burrow Speed and leaves a 10-foot-diameter tunnel in its wake.

## Actions

**Multiattack**
The worm makes one Bite attack and one Tail Stinger attack.

**Bite**
*Melee Attack Roll:* +14, reach 10 ft. 22 (3d8 + 9) Piercing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 19), and it has the Restrained condition until the grapple ends.

**Tail Stinger**
*Melee Attack Roll:* +14, reach 10 ft. 16 (2d6 + 9) Piercing damage plus 35 (10d6) Poison damage.

## Bonus Actions

**Swallow**
*Strength Saving Throw*: DC 19, one Large or smaller creature Grappled by the worm (it can have up to three creatures swallowed at a time). *Failure:*  The target is swallowed by the worm, and the Grappled condition ends. A swallowed creature has the Blinded and Restrained conditions, has Cover|XPHB|Total Cover against attacks and other effects outside the worm, and takes 17 (5d6) Acid damage at the start of each of the worm's turns. If the worm takes 30 damage or more on a single turn from a creature inside it, the worm must succeed on a DC 21 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, each of which falls in a space within 5 feet of the worm and has the Prone condition. If the worm dies, any swallowed creature no longer has the Restrained condition and can escape from the corpse using 20 feet of movement, exiting Prone.
`,
      "Monsters/quasit.md": `---
smType: creature
name: Quasit
size: Small
type: Fiend
typeTags:
  - value: Demon
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '13'
initiative: +3 (13)
hp: '25'
hitDice: 10d4
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 5
    saveProf: false
  - key: dex
    score: 17
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 7
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 10
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '5'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Abyssal
  - value: Common
damageResistancesList:
  - value: Cold
  - value: Fire
  - value: Lightning
damageImmunitiesList:
  - value: Poison; Poisoned
cr: '1'
xp: '200'
entries:
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The quasit has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Slashing damage, and the target has the Poisoned condition until the start of the quasit''s next turn.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d4
          bonus: 3
          type: Slashing
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Scare (1/Day)
    entryType: save
    text: '*Wisdom Saving Throw*: DC 10, one creature within 20 feet. *Failure:*  The target has the Frightened condition. At the end of each of its turns, the target repeats the save, ending the effect on itself on a success. After 1 minute, it succeeds automatically.'
    limitedUse:
      count: 1
      reset: day
    save:
      ability: wis
      dc: 10
      targeting:
        type: single
        range: 20 ft.
      onFail:
        effects:
          conditions:
            - condition: Frightened
              saveToEnd:
                timing: end-of-turn
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Shape-Shift
    entryType: special
    text: The quasit shape-shifts to resemble a bat (Speed 10 ft., Fly 40 ft.), a centipede (40 ft., Climb 40 ft.), or a toad (40 ft., Swim 40 ft.), or it returns to its true form. Its game statistics are the same in each form, except for its Speed. Any equipment it is wearing or carrying isn't transformed.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Invisibility
    entryType: spellcasting
    text: The quasit casts *Invisibility* on itself, requiring no spell components and using Charisma as the spellcasting ability. - **At Will:** *Invisibility*
    spellcasting:
      ability: cha
      spellLists:
        - frequency: at-will
          spells:
            - Invisibility
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Quasit
*Small, Fiend, Chaotic Evil*

**AC** 13
**HP** 25 (10d4)
**Initiative** +3 (13)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 10
**Languages** Abyssal, Common
CR 1, PB +2, XP 200

## Traits

**Magic Resistance**
The quasit has Advantage on saving throws against spells and other magical effects.

## Actions

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Slashing damage, and the target has the Poisoned condition until the start of the quasit's next turn.

**Scare (1/Day)**
*Wisdom Saving Throw*: DC 10, one creature within 20 feet. *Failure:*  The target has the Frightened condition. At the end of each of its turns, the target repeats the save, ending the effect on itself on a success. After 1 minute, it succeeds automatically.

**Shape-Shift**
The quasit shape-shifts to resemble a bat (Speed 10 ft., Fly 40 ft.), a centipede (40 ft., Climb 40 ft.), or a toad (40 ft., Swim 40 ft.), or it returns to its true form. Its game statistics are the same in each form, except for its Speed. Any equipment it is wearing or carrying isn't transformed.

**Invisibility**
The quasit casts *Invisibility* on itself, requiring no spell components and using Charisma as the spellcasting ability. - **At Will:** *Invisibility*
`,
      "Monsters/rakshasa.md": `---
smType: creature
name: Rakshasa
size: Medium
type: Fiend
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '17'
initiative: +8 (18)
hp: '221'
hitDice: 26d8 + 104
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 14
    saveProf: false
  - key: dex
    score: 17
    saveProf: false
  - key: con
    score: 18
    saveProf: false
  - key: int
    score: 13
    saveProf: false
  - key: wis
    score: 16
    saveProf: false
  - key: cha
    score: 20
    saveProf: false
pb: '+5'
skills:
  - skill: Deception
    value: '10'
  - skill: Insight
    value: '8'
  - skill: Perception
    value: '8'
sensesList:
  - type: truesight
    range: '60'
passivesList:
  - skill: Perception
    value: '18'
languagesList:
  - value: Common
  - value: Infernal
damageVulnerabilitiesList:
  - value: Piercing
conditionImmunitiesList:
  - value: Charmed
  - value: Frightened
cr: '13'
xp: '10000'
entries:
  - category: trait
    name: Greater Magic Resistance
    entryType: special
    text: The rakshasa automatically succeeds on saving throws against spells and other magical effects, and the attack rolls of spells automatically miss it. Without the rakshasa's permission, no spell can observe the rakshasa remotely or detect its thoughts, creature type, or alignment.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Fiendish Restoration
    entryType: special
    text: If the rakshasa dies outside the Nine Hells, its body turns to ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The rakshasa makes three Cursed Touch attacks.
    multiattack:
      attacks:
        - name: Touch
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Cursed Touch
    entryType: attack
    text: '*Melee Attack Roll:* +10, reach 5 ft. 12 (2d6 + 5) Slashing damage plus 19 (3d12) Necrotic damage. If the target is a creature, it is cursed. While cursed, the target gains no benefit from finishing a Short Rest|XPHB|Short or Long Rest.'
    attack:
      type: melee
      bonus: 10
      damage:
        - dice: 2d6
          bonus: 5
          type: Slashing
          average: 12
        - dice: 3d12
          bonus: 0
          type: Necrotic
          average: 19
      reach: 5 ft.
      onHit:
        other: If the target is a creature, it is cursed. While cursed, the target gains no benefit from finishing a Short Rest|XPHB|Short or Long Rest.
      additionalEffects: If the target is a creature, it is cursed. While cursed, the target gains no benefit from finishing a Short Rest|XPHB|Short or Long Rest.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Baleful Command (Recharge 5-6)
    entryType: save
    text: '*Wisdom Saving Throw*: DC 18, each enemy in a 30-foot Emanation originating from the rakshasa. *Failure:*  28 (8d6) Psychic damage, and the target has the Frightened and Incapacitated conditions until the start of the rakshasa''s next turn.'
    recharge: 5-6
    save:
      ability: wis
      dc: 18
      targeting:
        shape: emanation
        size: 30 ft.
        origin: self
      onFail:
        effects:
          other: 28 (8d6) Psychic damage, and the target has the Frightened and Incapacitated conditions until the start of the rakshasa's next turn.
        damage:
          - dice: 8d6
            bonus: 0
            type: Psychic
            average: 28
        legacyEffects: 28 (8d6) Psychic damage, and the target has the Frightened and Incapacitated conditions until the start of the rakshasa's next turn.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The rakshasa casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 18): - **At Will:** *Detect Magic*, *Detect Thoughts*, *Disguise Self*, *Mage Hand*, *Minor Illusion* - **1e/Day Each:** *Fly*, *Invisibility*, *Major Image*, *Plane Shift*'
    spellcasting:
      ability: cha
      saveDC: 18
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Detect Thoughts
            - Disguise Self
            - Mage Hand
            - Minor Illusion
        - frequency: 1/day
          spells:
            - Fly
            - Invisibility
            - Major Image
            - Plane Shift
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Rakshasa
*Medium, Fiend, Lawful Evil*

**AC** 17
**HP** 221 (26d8 + 104)
**Initiative** +8 (18)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** truesight 60 ft.; Passive Perception 18
**Languages** Common, Infernal
CR 13, PB +5, XP 10000

## Traits

**Greater Magic Resistance**
The rakshasa automatically succeeds on saving throws against spells and other magical effects, and the attack rolls of spells automatically miss it. Without the rakshasa's permission, no spell can observe the rakshasa remotely or detect its thoughts, creature type, or alignment.

**Fiendish Restoration**
If the rakshasa dies outside the Nine Hells, its body turns to ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.

## Actions

**Multiattack**
The rakshasa makes three Cursed Touch attacks.

**Cursed Touch**
*Melee Attack Roll:* +10, reach 5 ft. 12 (2d6 + 5) Slashing damage plus 19 (3d12) Necrotic damage. If the target is a creature, it is cursed. While cursed, the target gains no benefit from finishing a Short Rest|XPHB|Short or Long Rest.

**Baleful Command (Recharge 5-6)**
*Wisdom Saving Throw*: DC 18, each enemy in a 30-foot Emanation originating from the rakshasa. *Failure:*  28 (8d6) Psychic damage, and the target has the Frightened and Incapacitated conditions until the start of the rakshasa's next turn.

**Spellcasting**
The rakshasa casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 18): - **At Will:** *Detect Magic*, *Detect Thoughts*, *Disguise Self*, *Mage Hand*, *Minor Illusion* - **1e/Day Each:** *Fly*, *Invisibility*, *Major Image*, *Plane Shift*
`,
      "Monsters/red-dragon-wyrmling.md": `---
smType: creature
name: Red Dragon Wyrmling
size: Medium
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '17'
initiative: +2 (12)
hp: '75'
hitDice: 10d8 + 30
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 2
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 2
  - key: cha
    score: 15
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '2'
sensesList:
  - type: blindsight
    range: '10'
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Draconic
damageImmunitiesList:
  - value: Fire
cr: '4'
xp: '1100'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes two Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 9 (1d10 + 4) Slashing damage plus 3 (1d6) Fire damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d10
          bonus: 4
          type: Slashing
          average: 9
        - dice: 1d6
          bonus: 0
          type: Fire
          average: 3
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fire Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 13, each creature in a 15-foot Cone. *Failure:*  24 (7d6) Fire damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 13
      targeting:
        shape: cone
        size: 15 ft.
      onFail:
        effects:
          other: 24 (7d6) Fire damage.
        damage:
          - dice: 7d6
            bonus: 0
            type: Fire
            average: 24
        legacyEffects: 24 (7d6) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Red Dragon Wyrmling
*Medium, Dragon, Chaotic Evil*

**AC** 17
**HP** 75 (10d8 + 30)
**Initiative** +2 (12)
**Speed** 30 ft., climb 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft., darkvision 60 ft.; Passive Perception 14
**Languages** Draconic
CR 4, PB +2, XP 1100

## Actions

**Multiattack**
The dragon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +6, reach 5 ft. 9 (1d10 + 4) Slashing damage plus 3 (1d6) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 13, each creature in a 15-foot Cone. *Failure:*  24 (7d6) Fire damage. *Success:*  Half damage.
`,
      "Monsters/remorhaz.md": `---
smType: creature
name: Remorhaz
size: Huge
type: Monstrosity
alignmentOverride: Unaligned
ac: '17'
initiative: +5 (15)
hp: '195'
hitDice: 17d12 + 85
speeds:
  walk:
    distance: 40 ft.
  burrow:
    distance: 30 ft.
abilities:
  - key: str
    score: 24
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 21
    saveProf: false
  - key: int
    score: 4
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+4'
sensesList:
  - type: darkvision
    range: '60'
  - type: tremorsense
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
damageImmunitiesList:
  - value: Cold
  - value: Fire
cr: '11'
xp: '7200'
entries:
  - category: trait
    name: Heat Aura
    entryType: special
    text: At the end of each of the remorhaz's turns, each creature in a 5-foot Emanation originating from the remorhaz takes 16 (3d10) Fire damage.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +11, reach 10 ft. 18 (2d10 + 7) Piercing damage plus 14 (4d6) Fire damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 17), and it has the Restrained condition until the grapple ends.'
    attack:
      type: melee
      bonus: 11
      damage:
        - dice: 2d10
          bonus: 7
          type: Piercing
          average: 18
        - dice: 4d6
          bonus: 0
          type: Fire
          average: 14
      reach: 10 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 17
            restrictions:
              size: Large or smaller
            duration:
              type: until
              trigger: the grapple ends
          - condition: Restrained
            escape:
              type: dc
              dc: 17
            restrictions:
              size: Large or smaller
            duration:
              type: until
              trigger: the grapple ends
      additionalEffects: If the target is a Large or smaller creature, it has the Grappled condition (escape DC 17), and it has the Restrained condition until the grapple ends.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Swallow
    entryType: save
    text: '*Strength Saving Throw*: DC 19, one Large or smaller creature Grappled by the remorhaz (it can have up to two creatures swallowed at a time). *Failure:*  The target is swallowed by the remorhaz, and the Grappled condition ends. A swallowed creature has the Blinded and Restrained conditions, it has Cover|XPHB|Total Cover against attacks and other effects outside the remorhaz, and it takes 10 (3d6) Acid damage plus 10 (3d6) Fire damage at the start of each of the remorhaz''s turns. If the remorhaz takes 30 damage or more on a single turn from a creature inside it, the remorhaz must succeed on a DC 15 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, each of which falls in a space within 5 feet of the remorhaz and has the Prone condition. If the remorhaz dies, any swallowed creature no longer has the Restrained condition and can escape from the corpse by using 15 feet of movement, exiting Prone.'
    save:
      ability: str
      dc: 19
      targeting:
        type: single
        count: 2
        restrictions:
          size:
            - Large
            - smaller
          other:
            - grappled by source
      onFail:
        effects:
          conditions:
            - condition: Prone
            - condition: Restrained
        damage:
          - dice: 3d6
            bonus: 0
            type: Acid
            average: 10
          - dice: 3d6
            bonus: 0
            type: Fire
            average: 10
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Remorhaz
*Huge, Monstrosity, Unaligned*

**AC** 17
**HP** 195 (17d12 + 85)
**Initiative** +5 (15)
**Speed** 40 ft., burrow 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft., tremorsense 60 ft.; Passive Perception 10
CR 11, PB +4, XP 7200

## Traits

**Heat Aura**
At the end of each of the remorhaz's turns, each creature in a 5-foot Emanation originating from the remorhaz takes 16 (3d10) Fire damage.

## Actions

**Bite**
*Melee Attack Roll:* +11, reach 10 ft. 18 (2d10 + 7) Piercing damage plus 14 (4d6) Fire damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 17), and it has the Restrained condition until the grapple ends.

## Bonus Actions

**Swallow**
*Strength Saving Throw*: DC 19, one Large or smaller creature Grappled by the remorhaz (it can have up to two creatures swallowed at a time). *Failure:*  The target is swallowed by the remorhaz, and the Grappled condition ends. A swallowed creature has the Blinded and Restrained conditions, it has Cover|XPHB|Total Cover against attacks and other effects outside the remorhaz, and it takes 10 (3d6) Acid damage plus 10 (3d6) Fire damage at the start of each of the remorhaz's turns. If the remorhaz takes 30 damage or more on a single turn from a creature inside it, the remorhaz must succeed on a DC 15 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, each of which falls in a space within 5 feet of the remorhaz and has the Prone condition. If the remorhaz dies, any swallowed creature no longer has the Restrained condition and can escape from the corpse by using 15 feet of movement, exiting Prone.
`,
      "Monsters/roc.md": `---
smType: creature
name: Roc
size: Gargantuan
type: Monstrosity
alignmentOverride: Unaligned
ac: '15'
initiative: +8 (18)
hp: '248'
hitDice: 16d20 + 80
speeds:
  walk:
    distance: 20 ft.
  fly:
    distance: 120 ft.
abilities:
  - key: str
    score: 28
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 4
  - key: con
    score: 20
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 10
    saveProf: true
    saveMod: 4
  - key: cha
    score: 9
    saveProf: false
pb: '+4'
skills:
  - skill: Perception
    value: '8'
passivesList:
  - skill: Perception
    value: '18'
cr: '11'
xp: '7200'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The roc makes two Beak attacks. It can replace one attack with a Talons attack.
    multiattack:
      attacks:
        - name: Beak
          count: 2
      substitutions:
        - replace: attack
          with:
            type: attack
            name: a Talons attack
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Beak
    entryType: attack
    text: '*Melee Attack Roll:* +13, reach 10 ft. 28 (3d12 + 9) Piercing damage.'
    attack:
      type: melee
      bonus: 13
      damage:
        - dice: 3d12
          bonus: 9
          type: Piercing
          average: 28
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Talons
    entryType: attack
    text: '*Melee Attack Roll:* +13, reach 5 ft. 23 (4d6 + 9) Slashing damage. If the target is a Huge or smaller creature, it has the Grappled condition (escape DC 19) from both talons, and it has the Restrained condition until the grapple ends.'
    attack:
      type: melee
      bonus: 13
      damage:
        - dice: 4d6
          bonus: 9
          type: Slashing
          average: 23
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 19
            restrictions:
              size: Huge or smaller
            duration:
              type: until
              trigger: the grapple ends
          - condition: Restrained
            escape:
              type: dc
              dc: 19
            restrictions:
              size: Huge or smaller
            duration:
              type: until
              trigger: the grapple ends
      additionalEffects: If the target is a Huge or smaller creature, it has the Grappled condition (escape DC 19) from both talons, and it has the Restrained condition until the grapple ends.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Swoop (Recharge 5-6)
    entryType: special
    text: If the roc has a creature Grappled, the roc flies up to half its Fly Speed without provoking Opportunity Attacks and drops that creature.
    recharge: 5-6
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Roc
*Gargantuan, Monstrosity, Unaligned*

**AC** 15
**HP** 248 (16d20 + 80)
**Initiative** +8 (18)
**Speed** 20 ft., fly 120 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

CR 11, PB +4, XP 7200

## Actions

**Multiattack**
The roc makes two Beak attacks. It can replace one attack with a Talons attack.

**Beak**
*Melee Attack Roll:* +13, reach 10 ft. 28 (3d12 + 9) Piercing damage.

**Talons**
*Melee Attack Roll:* +13, reach 5 ft. 23 (4d6 + 9) Slashing damage. If the target is a Huge or smaller creature, it has the Grappled condition (escape DC 19) from both talons, and it has the Restrained condition until the grapple ends.

## Bonus Actions

**Swoop (Recharge 5-6)**
If the roc has a creature Grappled, the roc flies up to half its Fly Speed without provoking Opportunity Attacks and drops that creature.
`,
      "Monsters/roper.md": `---
smType: creature
name: Roper
size: Large
type: Aberration
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '20'
initiative: +5 (15)
hp: '93'
hitDice: 11d10 + 33
speeds:
  walk:
    distance: 10 ft.
  climb:
    distance: 20 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 8
    saveProf: false
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 7
    saveProf: false
  - key: wis
    score: 16
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '6'
  - skill: Stealth
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '16'
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Spider Climb
    entryType: special
    text: The roper can climb difficult surfaces, including along ceilings, without needing to make an ability check.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The roper makes two Tentacle attacks, uses Reel, and makes two Bite attacks.
    multiattack:
      attacks:
        - name: Tentacle
          count: 2
        - name: Bite
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 17 (3d8 + 4) Piercing damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 3d8
          bonus: 4
          type: Piercing
          average: 17
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Tentacle
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 60 ft. The target has the Grappled condition (escape DC 14) from one of six tentacles, and the target has the Poisoned condition until the grapple ends. The tentacle can be damaged, freeing a creature it has Grappled when destroyed (AC 20, HP 10, Immunity to Poison and Psychic damage). Damaging the tentacle deals no damage to the roper, and a destroyed tentacle regrows at the start of the roper''s next turn.'
    attack:
      type: melee
      bonus: 7
      damage: []
      reach: 60 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Reel
    entryType: special
    text: The roper pulls each creature Grappled by it up to 30 feet straight toward it.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Roper
*Large, Aberration, Neutral Evil*

**AC** 20
**HP** 93 (11d10 + 33)
**Initiative** +5 (15)
**Speed** 10 ft., climb 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 16
CR 5, PB +3, XP 1800

## Traits

**Spider Climb**
The roper can climb difficult surfaces, including along ceilings, without needing to make an ability check.

## Actions

**Multiattack**
The roper makes two Tentacle attacks, uses Reel, and makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +7, reach 5 ft. 17 (3d8 + 4) Piercing damage.

**Tentacle**
*Melee Attack Roll:* +7, reach 60 ft. The target has the Grappled condition (escape DC 14) from one of six tentacles, and the target has the Poisoned condition until the grapple ends. The tentacle can be damaged, freeing a creature it has Grappled when destroyed (AC 20, HP 10, Immunity to Poison and Psychic damage). Damaging the tentacle deals no damage to the roper, and a destroyed tentacle regrows at the start of the roper's next turn.

**Reel**
The roper pulls each creature Grappled by it up to 30 feet straight toward it.
`,
      "Monsters/rust-monster.md": `---
smType: creature
name: Rust Monster
size: Medium
type: Monstrosity
alignmentOverride: Unaligned
ac: '14'
initiative: +1 (11)
hp: '33'
hitDice: 6d8 + 6
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 13
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '11'
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Iron Scent
    entryType: special
    text: The rust monster can pinpoint the location of ferrous metal within 30 feet of itself.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The rust monster makes one Bite attack and uses Antennae twice.
    multiattack:
      attacks:
        - name: Bite
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 5 (1d8 + 1) Piercing damage.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 1d8
          bonus: 1
          type: Piercing
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Antennae
    entryType: save
    text: 'The rust monster targets one nonmagical metal object\u2014armor or a weapon\u2014worn or carried by a creature within 5 feet of itself. *Dexterity Saving Throw*: DC 11, the creature with the object. *Failure:*  The object takes a -1 penalty to the AC it offers (armor) or to its attack rolls (weapon). Armor is destroyed if the penalty reduces its AC to 10, and a weapon is destroyed if its penalty reaches -5. The penalty can be removed by casting the *Mending* spell on the armor or weapon.'
    save:
      ability: dex
      dc: 11
      targeting:
        type: single
      onFail:
        effects:
          other: The object takes a -1 penalty to the AC it offers (armor) or to its attack rolls (weapon). Armor is destroyed if the penalty reduces its AC to 10, and a weapon is destroyed if its penalty reaches -5. The penalty can be removed by casting the *Mending* spell on the armor or weapon.
        legacyEffects: The object takes a -1 penalty to the AC it offers (armor) or to its attack rolls (weapon). Armor is destroyed if the penalty reduces its AC to 10, and a weapon is destroyed if its penalty reaches -5. The penalty can be removed by casting the *Mending* spell on the armor or weapon.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Destroy Metal
    entryType: special
    text: The rust monster touches a nonmagical metal object within 5 feet of itself that isn't being worn or carried. The touch destroys a 1-foot Cube [Area of Effect]|XPHB|Cube of the object.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Rust Monster
*Medium, Monstrosity, Unaligned*

**AC** 14
**HP** 33 (6d8 + 6)
**Initiative** +1 (11)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 11
CR 1/2, PB +2, XP 100

## Traits

**Iron Scent**
The rust monster can pinpoint the location of ferrous metal within 30 feet of itself.

## Actions

**Multiattack**
The rust monster makes one Bite attack and uses Antennae twice.

**Bite**
*Melee Attack Roll:* +3, reach 5 ft. 5 (1d8 + 1) Piercing damage.

**Antennae**
The rust monster targets one nonmagical metal object\u2014armor or a weapon\u2014worn or carried by a creature within 5 feet of itself. *Dexterity Saving Throw*: DC 11, the creature with the object. *Failure:*  The object takes a -1 penalty to the AC it offers (armor) or to its attack rolls (weapon). Armor is destroyed if the penalty reduces its AC to 10, and a weapon is destroyed if its penalty reaches -5. The penalty can be removed by casting the *Mending* spell on the armor or weapon.

**Destroy Metal**
The rust monster touches a nonmagical metal object within 5 feet of itself that isn't being worn or carried. The touch destroys a 1-foot Cube [Area of Effect]|XPHB|Cube of the object.
`,
      "Monsters/sahuagin-warrior.md": `---
smType: creature
name: Sahuagin Warrior
size: Medium
type: Fiend
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '12'
initiative: +0 (10)
hp: '22'
hitDice: 4d8 + 4
speeds:
  walk:
    distance: 30 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 13
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 9
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '15'
languagesList:
  - value: Sahuagin
damageResistancesList:
  - value: Acid
  - value: Cold
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Blood Frenzy
    entryType: special
    text: The sahuagin has Advantage on attack rolls against any creature that doesn't have all its Hit Points.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Limited Amphibiousness
    entryType: special
    text: The sahuagin can breathe air and water, but it must be submerged at least once every 4 hours to avoid suffocating outside water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Shark Telepathy
    entryType: special
    text: The sahuagin can magically control sharks within 120 feet of itself, using a special telepathy.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The sahuagin makes two Claw attacks.
    multiattack:
      attacks:
        - name: Claw
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Slashing damage.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 1d6
          bonus: 1
          type: Slashing
          average: 4
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Aquatic Charge
    entryType: special
    text: The sahuagin swims up to its Swim Speed straight toward an enemy it can see.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Sahuagin Warrior
*Medium, Fiend, Lawful Evil*

**AC** 12
**HP** 22 (4d8 + 4)
**Initiative** +0 (10)
**Speed** 30 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 15
**Languages** Sahuagin
CR 1/2, PB +2, XP 100

## Traits

**Blood Frenzy**
The sahuagin has Advantage on attack rolls against any creature that doesn't have all its Hit Points.

**Limited Amphibiousness**
The sahuagin can breathe air and water, but it must be submerged at least once every 4 hours to avoid suffocating outside water.

**Shark Telepathy**
The sahuagin can magically control sharks within 120 feet of itself, using a special telepathy.

## Actions

**Multiattack**
The sahuagin makes two Claw attacks.

**Claw**
*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Slashing damage.

## Bonus Actions

**Aquatic Charge**
The sahuagin swims up to its Swim Speed straight toward an enemy it can see.
`,
      "Monsters/salamander.md": `---
smType: creature
name: Salamander
size: Large
type: Elemental
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '15'
initiative: +2 (12)
hp: '90'
hitDice: 12d10 + 24
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 11
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 12
    saveProf: false
pb: '+3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Primordial (Ignan)
damageVulnerabilitiesList:
  - value: Cold
damageImmunitiesList:
  - value: Fire
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Fire Aura
    entryType: special
    text: At the end of each of the salamander's turns, each creature of the salamander's choice in a 5-foot Emanation originating from the salamander takes 7 (2d6) Fire damage.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The salamander makes two Flame Spear attacks. It can replace one attack with a use of Constrict.
    multiattack:
      attacks:
        - name: Spear
          count: 1
      substitutions:
        - replace: attack
          with:
            type: attack
            name: Constrict
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Flame Spear
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +7, reach 5 ft. or range 20/60 ft. 13 (2d8 + 4) Piercing damage plus 7 (2d6) Fire damage. HitomThe spear magically returns to the salamander''s hand immediately after a ranged attack.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Constrict
    entryType: save
    text: '*Strength Saving Throw*: DC 15, one Large or smaller creature the salamander can see within 10 feet. *Failure:*  11 (2d6 + 4) Bludgeoning damage plus 7 (2d6) Fire damage. The target has the Grappled condition (escape DC 14), and it has the Restrained condition until the grapple ends.'
    save:
      ability: str
      dc: 15
      targeting:
        type: single
        range: 10 ft.
        restrictions:
          size:
            - Large
            - smaller
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Grappled
              escape:
                type: dc
                dc: 14
              duration:
                type: until
                trigger: the grapple ends
            - condition: Restrained
              escape:
                type: dc
                dc: 14
              duration:
                type: until
                trigger: the grapple ends
        damage:
          - dice: 2d6
            bonus: 4
            type: Bludgeoning
            average: 11
          - dice: 2d6
            bonus: 0
            type: Fire
            average: 7
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Salamander
*Large, Elemental, Neutral Evil*

**AC** 15
**HP** 90 (12d10 + 24)
**Initiative** +2 (12)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Primordial (Ignan)
CR 5, PB +3, XP 1800

## Traits

**Fire Aura**
At the end of each of the salamander's turns, each creature of the salamander's choice in a 5-foot Emanation originating from the salamander takes 7 (2d6) Fire damage.

## Actions

**Multiattack**
The salamander makes two Flame Spear attacks. It can replace one attack with a use of Constrict.

**Flame Spear**
*Melee or Ranged Attack Roll:* +7, reach 5 ft. or range 20/60 ft. 13 (2d8 + 4) Piercing damage plus 7 (2d6) Fire damage. HitomThe spear magically returns to the salamander's hand immediately after a ranged attack.

**Constrict**
*Strength Saving Throw*: DC 15, one Large or smaller creature the salamander can see within 10 feet. *Failure:*  11 (2d6 + 4) Bludgeoning damage plus 7 (2d6) Fire damage. The target has the Grappled condition (escape DC 14), and it has the Restrained condition until the grapple ends.
`,
      "Monsters/satyr.md": `---
smType: creature
name: Satyr
size: Medium
type: Fey
alignmentLawChaos: Chaotic
alignmentGoodEvil: Neutral
ac: '13'
initiative: +3 (13)
hp: '31'
hitDice: 7d8
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 12
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 14
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '2'
  - skill: Performance
    value: '6'
  - skill: Stealth
    value: '5'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Common
  - value: Elvish
  - value: Sylvan
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The satyr has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Hooves
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Bludgeoning damage. If the target is a Medium or smaller creature, the satyr pushes the target up to 10 feet straight away from itself.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d4
          bonus: 3
          type: Bludgeoning
          average: 5
      reach: 5 ft.
      onHit:
        other: If the target is a Medium or smaller creature, the satyr pushes the target up to 10 feet straight away from itself.
      additionalEffects: If the target is a Medium or smaller creature, the satyr pushes the target up to 10 feet straight away from itself.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Mockery
    entryType: save
    text: '*Wisdom Saving Throw*: DC 12, one creature the satyr can see within 90 feet. *Failure:*  5 (1d6 + 2) Psychic damage.'
    save:
      ability: wis
      dc: 12
      targeting:
        type: single
        range: 90 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          other: 5 (1d6 + 2) Psychic damage.
        damage:
          - dice: 1d6
            bonus: 2
            type: Psychic
            average: 5
        legacyEffects: 5 (1d6 + 2) Psychic damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Satyr
*Medium, Fey, Chaotic Neutral*

**AC** 13
**HP** 31 (7d8)
**Initiative** +3 (13)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common, Elvish, Sylvan
CR 1/2, PB +2, XP 100

## Traits

**Magic Resistance**
The satyr has Advantage on saving throws against spells and other magical effects.

## Actions

**Hooves**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Bludgeoning damage. If the target is a Medium or smaller creature, the satyr pushes the target up to 10 feet straight away from itself.

**Mockery**
*Wisdom Saving Throw*: DC 12, one creature the satyr can see within 90 feet. *Failure:*  5 (1d6 + 2) Psychic damage.
`,
      "Monsters/scout.md": `---
smType: creature
name: Scout
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '13'
initiative: +2 (12)
hp: '16'
hitDice: 3d8 + 3
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 11
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 11
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 11
    saveProf: false
pb: '+2'
skills:
  - skill: Nature
    value: '4'
  - skill: Perception
    value: '5'
  - skill: Stealth
    value: '6'
  - skill: Survival
    value: '5'
passivesList:
  - skill: Perception
    value: '15'
languagesList:
  - value: Common plus one other language
cr: 1/2
xp: '100'
entries:
  - category: action
    name: Multiattack
    entryType: special
    text: The scout makes two attacks, using Shortsword and Longbow in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Shortsword
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Piercing
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Longbow
    entryType: attack
    text: '*Ranged Attack Roll:* +4, range 150/600 ft. 6 (1d8 + 2) Piercing damage.'
    attack:
      type: ranged
      bonus: 4
      damage:
        - dice: 1d8
          bonus: 2
          type: Piercing
          average: 6
      range: 150/600 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Scout
*Small, Humanoid, Neutral Neutral*

**AC** 13
**HP** 16 (3d8 + 3)
**Initiative** +2 (12)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common plus one other language
CR 1/2, PB +2, XP 100

## Actions

**Multiattack**
The scout makes two attacks, using Shortsword and Longbow in any combination.

**Shortsword**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage.

**Longbow**
*Ranged Attack Roll:* +4, range 150/600 ft. 6 (1d8 + 2) Piercing damage.
`,
      "Monsters/sea-hag.md": `---
smType: creature
name: Sea Hag
size: Medium
type: Fey
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '14'
initiative: +1 (11)
hp: '52'
hitDice: 7d8 + 21
speeds:
  walk:
    distance: 30 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 13
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Common
  - value: Giant
  - value: Primordial (Aquan)
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The hag can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Vile Appearance
    entryType: save
    text: '*Wisdom Saving Throw*: DC 11, any Beast or Humanoid that starts its turn within 30 feet of the hag and can see the hag''s true form. *Failure:*  The target has the Frightened condition until the start of its next turn. *Success:*  The target is immune to this hag''s Vile Appearance for 24 hours.'
    save:
      ability: wis
      dc: 11
      targeting:
        type: special
      onFail:
        effects:
          conditions:
            - condition: Frightened
              duration:
                type: until
                trigger: the start of its next turn
      onSuccess: The target is immune to this hag's Vile Appearance for 24 hours.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d6
          bonus: 3
          type: Slashing
          average: 10
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Death Glare (Recharge 5-6)
    entryType: save
    text: '*Wisdom Saving Throw*: DC 11, one Frightened creature the hag can see within 30 feet. *Failure:*  If the target has 20 Hit Points or fewer, it drops to 0 Hit Points. Otherwise, the target takes 13 (3d8) Psychic damage.'
    recharge: 5-6
    save:
      ability: wis
      dc: 11
      targeting:
        type: single
        range: 30 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          other: If the target has 20 Hit Points or fewer, it drops to 0 Hit Points. Otherwise, the target takes 13 (3d8) Psychic damage.
        damage:
          - dice: 3d8
            bonus: 0
            type: Psychic
            average: 13
        legacyEffects: If the target has 20 Hit Points or fewer, it drops to 0 Hit Points. Otherwise, the target takes 13 (3d8) Psychic damage.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Illusory Appearance
    entryType: spellcasting
    text: The hag casts *Disguise Self*, using Constitution as the spellcasting ability (spell save DC 13). The spell's duration is 24 hours. - **At Will:** *Disguise Self*
    spellcasting:
      ability: int
      saveDC: 13
      spellLists:
        - frequency: at-will
          spells:
            - Disguise Self
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Sea Hag
*Medium, Fey, Chaotic Evil*

**AC** 14
**HP** 52 (7d8 + 21)
**Initiative** +1 (11)
**Speed** 30 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 11
**Languages** Common, Giant, Primordial (Aquan)
CR 2, PB +2, XP 450

## Traits

**Amphibious**
The hag can breathe air and water.

**Vile Appearance**
*Wisdom Saving Throw*: DC 11, any Beast or Humanoid that starts its turn within 30 feet of the hag and can see the hag's true form. *Failure:*  The target has the Frightened condition until the start of its next turn. *Success:*  The target is immune to this hag's Vile Appearance for 24 hours.

## Actions

**Claw**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage.

**Death Glare (Recharge 5-6)**
*Wisdom Saving Throw*: DC 11, one Frightened creature the hag can see within 30 feet. *Failure:*  If the target has 20 Hit Points or fewer, it drops to 0 Hit Points. Otherwise, the target takes 13 (3d8) Psychic damage.

**Illusory Appearance**
The hag casts *Disguise Self*, using Constitution as the spellcasting ability (spell save DC 13). The spell's duration is 24 hours. - **At Will:** *Disguise Self*
`,
      "Monsters/shadow.md": `---
smType: creature
name: Shadow
size: Medium
type: Undead
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '12'
initiative: +2 (12)
hp: '27'
hitDice: 5d8 + 5
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 6
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '6'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
damageVulnerabilitiesList:
  - value: Radiant
damageResistancesList:
  - value: Acid
  - value: Cold
  - value: Fire
  - value: Lightning
  - value: Thunder
damageImmunitiesList:
  - value: Necrotic
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Frightened
  - value: Grappled
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
  - value: Prone
  - value: Restrained
  - value: Unconscious
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Amorphous
    entryType: special
    text: The shadow can move through a space as narrow as 1 inch without expending extra movement to do so.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Sunlight Weakness
    entryType: special
    text: While in sunlight, the shadow has Disadvantage on D20 Test.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Draining Swipe
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Necrotic damage, and the target''s Strength score decreases by 1d4. The target dies if this reduces that score to 0. If a Humanoid is slain by this attack, a Shadow rises from the corpse 1d4 hours later.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Necrotic
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Shadow Stealth
    entryType: special
    text: While in Dim Light or darkness, the shadow takes the Hide action.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Shadow
*Medium, Undead, Chaotic Evil*

**AC** 12
**HP** 27 (5d8 + 5)
**Initiative** +2 (12)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
CR 1/2, PB +2, XP 100

## Traits

**Amorphous**
The shadow can move through a space as narrow as 1 inch without expending extra movement to do so.

**Sunlight Weakness**
While in sunlight, the shadow has Disadvantage on D20 Test.

## Actions

**Draining Swipe**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Necrotic damage, and the target's Strength score decreases by 1d4. The target dies if this reduces that score to 0. If a Humanoid is slain by this attack, a Shadow rises from the corpse 1d4 hours later.

## Bonus Actions

**Shadow Stealth**
While in Dim Light or darkness, the shadow takes the Hide action.
`,
      "Monsters/shambling-mound.md": `---
smType: creature
name: Shambling Mound
size: Large
type: Plant
alignmentOverride: Unaligned
ac: '15'
initiative: '-1 (9)'
hp: '110'
hitDice: 13d10 + 39
speeds:
  walk:
    distance: 30 ft.
  swim:
    distance: 20 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 8
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 5
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+3'
skills:
  - skill: Stealth
    value: '3'
sensesList:
  - type: blindsight
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
damageResistancesList:
  - value: Cold
  - value: Fire
damageImmunitiesList:
  - value: Lightning; Deafened
  - value: Exhaustion
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Lightning Absorption
    entryType: special
    text: Whenever the shambling mound is subjected to Lightning damage, it regains a number of Hit Points equal to the Lightning damage dealt.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The shambling mound makes three Charged Tendril attacks. It can replace one attack with a use of Engulf.
    multiattack:
      attacks:
        - name: Tendril
          count: 1
      substitutions:
        - replace: attack
          with:
            type: attack
            name: Engulf
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Charged Tendril
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 10 ft. 7 (1d6 + 4) Bludgeoning damage plus 5 (2d4) Lightning damage. If the target is a Medium or smaller creature, the shambling mound pulls the target 5 feet straight toward itself.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 1d6
          bonus: 4
          type: Bludgeoning
          average: 7
        - dice: 2d4
          bonus: 0
          type: Lightning
          average: 5
      reach: 10 ft.
      onHit:
        other: If the target is a Medium or smaller creature, the shambling mound pulls the target 5 feet straight toward itself.
      additionalEffects: If the target is a Medium or smaller creature, the shambling mound pulls the target 5 feet straight toward itself.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Engulf
    entryType: save
    text: '*Strength Saving Throw*: DC 15, one Medium or smaller creature within 5 feet. *Failure:*  The target is pulled into the shambling mound''s space and has the Grappled condition (escape DC 14). Until the grapple ends, the target has the Blinded and Restrained conditions, and it takes 10 (3d6) Lightning damage at the start of each of its turns. When the shambling mound moves, the Grappled target moves with it, costing it no extra movement. The shambling mound can have only one creature Grappled by this action at a time.'
    save:
      ability: str
      dc: 15
      targeting:
        type: single
        range: 5 ft.
        restrictions:
          size:
            - Medium
            - smaller
      onFail:
        effects:
          conditions:
            - condition: Grappled
              escape:
                type: dc
                dc: 14
              duration:
                type: until
                trigger: the grapple ends
        damage:
          - dice: 3d6
            bonus: 0
            type: Lightning
            average: 10
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Shambling Mound
*Large, Plant, Unaligned*

**AC** 15
**HP** 110 (13d10 + 39)
**Initiative** -1 (9)
**Speed** 30 ft., swim 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 60 ft.; Passive Perception 10
CR 5, PB +3, XP 1800

## Traits

**Lightning Absorption**
Whenever the shambling mound is subjected to Lightning damage, it regains a number of Hit Points equal to the Lightning damage dealt.

## Actions

**Multiattack**
The shambling mound makes three Charged Tendril attacks. It can replace one attack with a use of Engulf.

**Charged Tendril**
*Melee Attack Roll:* +7, reach 10 ft. 7 (1d6 + 4) Bludgeoning damage plus 5 (2d4) Lightning damage. If the target is a Medium or smaller creature, the shambling mound pulls the target 5 feet straight toward itself.

**Engulf**
*Strength Saving Throw*: DC 15, one Medium or smaller creature within 5 feet. *Failure:*  The target is pulled into the shambling mound's space and has the Grappled condition (escape DC 14). Until the grapple ends, the target has the Blinded and Restrained conditions, and it takes 10 (3d6) Lightning damage at the start of each of its turns. When the shambling mound moves, the Grappled target moves with it, costing it no extra movement. The shambling mound can have only one creature Grappled by this action at a time.
`,
      "Monsters/shield-guardian.md": `---
smType: creature
name: Shield Guardian
size: Large
type: Construct
alignmentOverride: Unaligned
ac: '17'
initiative: '-1 (9)'
hp: '142'
hitDice: 15d10 + 60
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 8
    saveProf: false
  - key: con
    score: 18
    saveProf: false
  - key: int
    score: 7
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 3
    saveProf: false
pb: '+3'
sensesList:
  - type: blindsight
    range: '10'
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Understands commands given in any language but can't speak
damageImmunitiesList:
  - value: Poison; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Frightened
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
cr: '7'
xp: '2900'
entries:
  - category: trait
    name: Bound
    entryType: special
    text: The guardian is magically bound to an amulet. While the guardian and its amulet are on the same plane of existence, the amulet's wearer can telepathically call the guardian to travel to it, and the guardian knows the distance and direction to the amulet. If the guardian is within 60 feet of the amulet's wearer, half of any damage the wearer takes (round up) is transferred to the guardian.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Regeneration
    entryType: special
    text: The guardian regains 10 Hit Points at the start of each of its turns if it has at least 1 Hit Point.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The guardian makes two Fist attacks.
    multiattack:
      attacks:
        - name: Fist
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Fist
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Bludgeoning damage plus 7 (2d6) Force damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d6
          bonus: 4
          type: Bludgeoning
          average: 11
        - dice: 2d6
          bonus: 0
          type: Force
          average: 7
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: trait
    name: Spell Storing
    entryType: spellcasting
    text: A spellcaster who wears the guardian's amulet can cause the guardian to store one spell of level 4 or lower. To do so, the wearer must cast the spell on the guardian while within 5 feet of it. The spell has no effect but is stored within the guardian. Any previously stored spell is lost when a new spell is stored. The guardian can cast the spell stored with any parameters set by the original caster, requiring no spell components and using the caster's spellcasting ability. The stored spell is then lost.
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: passive
    trigger.targeting:
      type: single
---

# Shield Guardian
*Large, Construct, Unaligned*

**AC** 17
**HP** 142 (15d10 + 60)
**Initiative** -1 (9)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft., darkvision 60 ft.; Passive Perception 10
**Languages** Understands commands given in any language but can't speak
CR 7, PB +3, XP 2900

## Traits

**Bound**
The guardian is magically bound to an amulet. While the guardian and its amulet are on the same plane of existence, the amulet's wearer can telepathically call the guardian to travel to it, and the guardian knows the distance and direction to the amulet. If the guardian is within 60 feet of the amulet's wearer, half of any damage the wearer takes (round up) is transferred to the guardian.

**Regeneration**
The guardian regains 10 Hit Points at the start of each of its turns if it has at least 1 Hit Point.

**Spell Storing**
A spellcaster who wears the guardian's amulet can cause the guardian to store one spell of level 4 or lower. To do so, the wearer must cast the spell on the guardian while within 5 feet of it. The spell has no effect but is stored within the guardian. Any previously stored spell is lost when a new spell is stored. The guardian can cast the spell stored with any parameters set by the original caster, requiring no spell components and using the caster's spellcasting ability. The stored spell is then lost.

## Actions

**Multiattack**
The guardian makes two Fist attacks.

**Fist**
*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Bludgeoning damage plus 7 (2d6) Force damage.
`,
      "Monsters/shrieker-fungus.md": `---
smType: creature
name: "Shrieker Fungus"
size: "Medium"
type: "Plant"
alignmentOverride: "Unaligned"
ac: "5"
initiative: "-5 (5)"
hp: "13"
hitDice: "3d8"
speeds:
  walk:
    distance: "5 ft."
abilities:
  -
    key: "str"
    score: 1
    saveProf: false
  -
    key: "dex"
    score: 1
    saveProf: false
  -
    key: "con"
    score: 10
    saveProf: false
  -
    key: "int"
    score: 1
    saveProf: false
  -
    key: "wis"
    score: 3
    saveProf: false
  -
    key: "cha"
    score: 1
    saveProf: false
pb: "+2"
sensesList:
  -
    type: "blindsight"
    range: "30"
passivesList:
  -
    skill: "Perception"
    value: "6"
conditionImmunitiesList:
  - value: "Blinded"
  - value: "Charmed"
  - value: "Deafened"
  - value: "Frightened"
cr: "0"
xp: "0"
---

# Shrieker Fungus
*Medium, Plant, Unaligned*

**AC** 5
**HP** 13 (3d8)
**Initiative** -5 (5)
**Speed** 5 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft.; Passive Perception 6
CR 0, PB +2, XP 0
`,
      "Monsters/silver-dragon-wyrmling.md": `---
smType: creature
name: Silver Dragon Wyrmling
size: Medium
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '17'
initiative: +2 (12)
hp: '45'
hitDice: 6d8 + 18
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 2
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 2
  - key: cha
    score: 15
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '2'
sensesList:
  - type: blindsight
    range: '10'
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Draconic
damageImmunitiesList:
  - value: Cold
cr: '2'
xp: '450'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes two Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 9 (1d10 + 4) Piercing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d10
          bonus: 4
          type: Piercing
          average: 9
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Cold Breath (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 13, each creature in a 15-foot Cone. *Failure:*  18 (4d8) Cold damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: con
      dc: 13
      targeting:
        shape: cone
        size: 15 ft.
      onFail:
        effects:
          other: 18 (4d8) Cold damage.
        damage:
          - dice: 4d8
            bonus: 0
            type: Cold
            average: 18
        legacyEffects: 18 (4d8) Cold damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Paralyzing Breath
    entryType: save
    text: '*Constitution Saving Throw*: DC 13, each creature in a 15-foot Cone. *First Failure* The target has the Incapacitated condition until the end of its next turn, when it repeats the save. *Second Failure* The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.'
    save:
      ability: con
      dc: 13
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Silver Dragon Wyrmling
*Medium, Dragon, Lawful Good*

**AC** 17
**HP** 45 (6d8 + 18)
**Initiative** +2 (12)
**Speed** 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft., darkvision 60 ft.; Passive Perception 14
**Languages** Draconic
CR 2, PB +2, XP 450

## Actions

**Multiattack**
The dragon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +6, reach 5 ft. 9 (1d10 + 4) Piercing damage.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 13, each creature in a 15-foot Cone. *Failure:*  18 (4d8) Cold damage. *Success:*  Half damage.

**Paralyzing Breath**
*Constitution Saving Throw*: DC 13, each creature in a 15-foot Cone. *First Failure* The target has the Incapacitated condition until the end of its next turn, when it repeats the save. *Second Failure* The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.
`,
      "Monsters/skeleton.md": `---
smType: creature
name: Skeleton
size: Medium
type: Undead
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '14'
initiative: +3 (13)
hp: '13'
hitDice: 2d8 + 4
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 8
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '9'
languagesList:
  - value: Understands Common plus one other language but can't speak
damageVulnerabilitiesList:
  - value: Bludgeoning
damageImmunitiesList:
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Poisoned
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Shortsword
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Piercing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d6
          bonus: 3
          type: Piercing
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Shortbow
    entryType: attack
    text: '*Ranged Attack Roll:* +5, range 80/320 ft. 6 (1d6 + 3) Piercing damage.'
    attack:
      type: ranged
      bonus: 5
      damage:
        - dice: 1d6
          bonus: 3
          type: Piercing
          average: 6
      range: 80/320 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Skeleton
*Medium, Undead, Lawful Evil*

**AC** 14
**HP** 13 (2d8 + 4)
**Initiative** +3 (13)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 9
**Languages** Understands Common plus one other language but can't speak
CR 1/4, PB +2, XP 50

## Actions

**Shortsword**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Piercing damage.

**Shortbow**
*Ranged Attack Roll:* +5, range 80/320 ft. 6 (1d6 + 3) Piercing damage.
`,
      "Monsters/solar.md": `---
smType: creature
name: Solar
size: Large
type: Celestial
typeTags:
  - value: Angel
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '21'
initiative: +20 (30)
hp: '297'
hitDice: 22d10 + 176
speeds:
  walk:
    distance: 50 ft.
  fly:
    distance: 150 ft.
    hover: true
abilities:
  - key: str
    score: 26
    saveProf: false
  - key: dex
    score: 22
    saveProf: false
  - key: con
    score: 26
    saveProf: false
  - key: int
    score: 25
    saveProf: false
  - key: wis
    score: 25
    saveProf: false
  - key: cha
    score: 30
    saveProf: false
pb: '+7'
skills:
  - skill: Perception
    value: '14'
sensesList:
  - type: truesight
    range: '120'
passivesList:
  - skill: Perception
    value: '24'
languagesList:
  - value: All
  - value: telepathy 120 ft.
damageImmunitiesList:
  - value: Poison
  - value: Radiant; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Frightened
  - value: Poisoned
cr: '21'
xp: '33000'
entries:
  - category: trait
    name: Divine Awareness
    entryType: special
    text: The solar knows if it hears a lie.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Exalted Restoration
    entryType: special
    text: If the solar dies outside Mount Celestia, its body disappears, and it gains a new body instantly, reviving with all its Hit Points somewhere in Mount Celestia.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (4/Day)
    entryType: special
    text: If the solar fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 4
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The solar has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The solar makes two Flying Sword attacks. It can replace one attack with a use of Slaying Bow.
    multiattack:
      attacks:
        - name: Sword
          count: 1
      substitutions:
        - replace: attack
          with:
            type: attack
            name: Slaying Bow
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Flying Sword
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +15, reach 10 ft. or range 120 ft. 22 (4d6 + 8) Slashing damage plus 36 (8d8) Radiant damage. HitomThe sword magically returns to the solar''s hand or hovers within 5 feet of the solar immediately after a ranged attack.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Slaying Bow
    entryType: save
    text: '*Dexterity Saving Throw*: DC 21, one creature the solar can see within 600 feet. *Failure:*  If the creature has 100 Hit Points or fewer, it dies. It otherwise takes 24 (4d8 + 6) Piercing damage plus 36 (8d8) Radiant damage.'
    save:
      ability: dex
      dc: 21
      targeting:
        type: single
        range: 600 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          other: If the creature has 100 Hit Points or fewer, it dies. It otherwise takes 24 (4d8 + 6) Piercing damage plus 36 (8d8) Radiant damage.
        damage:
          - dice: 4d8
            bonus: 6
            type: Piercing
            average: 24
          - dice: 8d8
            bonus: 0
            type: Radiant
            average: 36
        legacyEffects: If the creature has 100 Hit Points or fewer, it dies. It otherwise takes 24 (4d8 + 6) Piercing damage plus 36 (8d8) Radiant damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Blinding Gaze
    entryType: save
    text: '*Constitution Saving Throw*: DC 25, one creature the solar can see within 120 feet. *Failure:*  The target has the Blinded condition for 1 minute. *Failure or Success*:  The solar can''t take this action again until the start of its next turn.'
    save:
      ability: con
      dc: 25
      targeting:
        type: single
        range: 120 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          conditions:
            - condition: Blinded
              duration:
                type: minutes
                count: 1
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
  - category: legendary
    name: Radiant Teleport
    entryType: save
    text: 'The solar teleports up to 60 feet to an unoccupied space it can see. *Dexterity Saving Throw*: DC 25, each creature in a 10-foot Emanation originating from the solar at its destination space. *Failure:*  11 (2d10) Radiant damage. *Success:*  Half damage.'
    save:
      ability: dex
      dc: 25
      targeting:
        shape: emanation
        size: 10 ft.
        origin: self
      onFail:
        effects:
          other: 11 (2d10) Radiant damage.
        damage:
          - dice: 2d10
            bonus: 0
            type: Radiant
            average: 11
        legacyEffects: 11 (2d10) Radiant damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The solar casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 25): - **At Will:** *Detect Evil and Good* - **1e/Day Each:** *Commune*, *Control Weather*, *Dispel Evil and Good*, *Resurrection*'
    spellcasting:
      ability: cha
      saveDC: 25
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Evil and Good
        - frequency: 1/day
          spells:
            - Commune
            - Control Weather
            - Dispel Evil and Good
            - Resurrection
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Divine Aid (3/Day)
    entryType: spellcasting
    text: The solar casts *Cure Wounds* (level 2 version), *Lesser Restoration*, or *Remove Curse*, using the same spellcasting ability as Spellcasting.
    limitedUse:
      count: 3
      reset: day
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Solar
*Large, Celestial, Lawful Good*

**AC** 21
**HP** 297 (22d10 + 176)
**Initiative** +20 (30)
**Speed** 50 ft., fly 150 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** truesight 120 ft.; Passive Perception 24
**Languages** All, telepathy 120 ft.
CR 21, PB +7, XP 33000

## Traits

**Divine Awareness**
The solar knows if it hears a lie.

**Exalted Restoration**
If the solar dies outside Mount Celestia, its body disappears, and it gains a new body instantly, reviving with all its Hit Points somewhere in Mount Celestia.

**Legendary Resistance (4/Day)**
If the solar fails a saving throw, it can choose to succeed instead.

**Magic Resistance**
The solar has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The solar makes two Flying Sword attacks. It can replace one attack with a use of Slaying Bow.

**Flying Sword**
*Melee or Ranged Attack Roll:* +15, reach 10 ft. or range 120 ft. 22 (4d6 + 8) Slashing damage plus 36 (8d8) Radiant damage. HitomThe sword magically returns to the solar's hand or hovers within 5 feet of the solar immediately after a ranged attack.

**Slaying Bow**
*Dexterity Saving Throw*: DC 21, one creature the solar can see within 600 feet. *Failure:*  If the creature has 100 Hit Points or fewer, it dies. It otherwise takes 24 (4d8 + 6) Piercing damage plus 36 (8d8) Radiant damage.

**Spellcasting**
The solar casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 25): - **At Will:** *Detect Evil and Good* - **1e/Day Each:** *Commune*, *Control Weather*, *Dispel Evil and Good*, *Resurrection*

## Bonus Actions

**Divine Aid (3/Day)**
The solar casts *Cure Wounds* (level 2 version), *Lesser Restoration*, or *Remove Curse*, using the same spellcasting ability as Spellcasting.

## Legendary Actions

**Blinding Gaze**
*Constitution Saving Throw*: DC 25, one creature the solar can see within 120 feet. *Failure:*  The target has the Blinded condition for 1 minute. *Failure or Success*:  The solar can't take this action again until the start of its next turn.

**Radiant Teleport**
The solar teleports up to 60 feet to an unoccupied space it can see. *Dexterity Saving Throw*: DC 25, each creature in a 10-foot Emanation originating from the solar at its destination space. *Failure:*  11 (2d10) Radiant damage. *Success:*  Half damage.
`,
      "Monsters/specter.md": `---
smType: creature
name: Specter
size: Medium
type: Undead
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '12'
initiative: +2 (12)
hp: '22'
hitDice: 5d8
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 50 ft.
    hover: true
abilities:
  - key: str
    score: 1
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 11
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Understands Common plus one other language but can't speak
damageResistancesList:
  - value: Acid
  - value: Bludgeoning
  - value: Cold
  - value: Fire
  - value: Lightning
  - value: Piercing
  - value: Slashing
  - value: Thunder
damageImmunitiesList:
  - value: Necrotic
  - value: Poison; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Grappled
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
  - value: Prone
  - value: Restrained
  - value: Unconscious
cr: '1'
xp: '200'
entries:
  - category: trait
    name: Incorporeal Movement
    entryType: special
    text: The specter can move through other creatures and objects as if they were Difficult Terrain. It takes 5 (1d10) Force damage if it ends its turn inside an object.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Sunlight Sensitivity
    entryType: special
    text: While in sunlight, the specter has Disadvantage on ability checks and attack rolls.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Life Drain
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 7 (2d6) Necrotic damage. If the target is a creature, its Hit Point maximum decreases by an amount equal to the damage taken.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 2d6
          bonus: 0
          type: Necrotic
          average: 7
      reach: 5 ft.
      onHit:
        other: If the target is a creature, its Hit Point maximum decreases by an amount equal to the damage taken.
      additionalEffects: If the target is a creature, its Hit Point maximum decreases by an amount equal to the damage taken.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Specter
*Medium, Undead, Chaotic Evil*

**AC** 12
**HP** 22 (5d8)
**Initiative** +2 (12)
**Speed** 30 ft., fly 50 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Understands Common plus one other language but can't speak
CR 1, PB +2, XP 200

## Traits

**Incorporeal Movement**
The specter can move through other creatures and objects as if they were Difficult Terrain. It takes 5 (1d10) Force damage if it ends its turn inside an object.

**Sunlight Sensitivity**
While in sunlight, the specter has Disadvantage on ability checks and attack rolls.

## Actions

**Life Drain**
*Melee Attack Roll:* +4, reach 5 ft. 7 (2d6) Necrotic damage. If the target is a creature, its Hit Point maximum decreases by an amount equal to the damage taken.
`,
      "Monsters/sphinx-of-lore.md": `---
smType: creature
name: Sphinx of Lore
size: Large
type: Celestial
alignmentLawChaos: Lawful
alignmentGoodEvil: Neutral
ac: '17'
initiative: +6 (16)
hp: '170'
hitDice: 20d10 + 60
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 18
    saveProf: false
  - key: wis
    score: 18
    saveProf: false
  - key: cha
    score: 18
    saveProf: false
pb: '+4'
skills:
  - skill: Arcana
    value: '12'
  - skill: History
    value: '12'
  - skill: Perception
    value: '8'
  - skill: Religion
    value: '12'
sensesList:
  - type: truesight
    range: '120'
passivesList:
  - skill: Perception
    value: '18'
languagesList:
  - value: Celestial
  - value: Common
damageResistancesList:
  - value: Necrotic
  - value: Radiant
damageImmunitiesList:
  - value: Psychic; Charmed
conditionImmunitiesList:
  - value: Frightened
cr: '11'
xp: '7200'
entries:
  - category: trait
    name: Inscrutable
    entryType: special
    text: No magic can observe the sphinx remotely or detect its thoughts without its permission. Wisdom (Insight) checks made to ascertain its intentions or sincerity are made with Disadvantage.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (3/Day, or 4/Day in Lair)
    entryType: special
    text: If the sphinx fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The sphinx makes three Claw attacks.
    multiattack:
      attacks:
        - name: Claw
          count: 3
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +8, reach 5 ft. 14 (3d6 + 4) Slashing damage.'
    attack:
      type: melee
      bonus: 8
      damage:
        - dice: 3d6
          bonus: 4
          type: Slashing
          average: 14
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Mind-Rending Roar (Recharge 5-6)
    entryType: save
    text: '*Wisdom Saving Throw*: DC 16, each enemy in a 300-foot Emanation originating from the sphinx. *Failure:*  35 (10d6) Psychic damage, and the target has the Incapacitated condition until the start of the sphinx''s next turn.'
    recharge: 5-6
    save:
      ability: wis
      dc: 16
      targeting:
        shape: emanation
        size: 300 ft.
        origin: self
      onFail:
        effects:
          conditions:
            - condition: Incapacitated
              duration:
                type: until
                trigger: the start of the sphinx's next turn
        damage:
          - dice: 10d6
            bonus: 0
            type: Psychic
            average: 35
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Arcane Prowl
    entryType: multiattack
    text: The sphinx can teleport up to 30 feet to an unoccupied space it can see, and it makes one Claw attack.
    multiattack:
      attacks:
        - name: Claw
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
  - category: legendary
    name: Weight of Years
    entryType: save
    text: '*Constitution Saving Throw*: DC 16, one creature the sphinx can see within 120 feet. *Failure:*  The target gains 1 Exhaustion level. While the target has any Exhaustion levels, it appears 3d10 years older. *Failure or Success*:  The sphinx can''t take this action again until the start of its next turn.'
    save:
      ability: con
      dc: 16
      targeting:
        type: single
        range: 120 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          other: The target gains 1 Exhaustion level. While the target has any Exhaustion levels, it appears 3d10 years older.
        legacyEffects: The target gains 1 Exhaustion level. While the target has any Exhaustion levels, it appears 3d10 years older.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The sphinx casts one of the following spells, requiring no Material components and using Intelligence as the spellcasting ability (spell save DC 16): - **At Will:** *Detect Magic*, *Identify*, *Mage Hand*, *Minor Illusion*, *Prestidigitation* - **1e/Day Each:** *Dispel Magic*, *Legend Lore*, *Locate Object*, *Plane Shift*, *Remove Curse*, *Tongues*'
    spellcasting:
      ability: int
      saveDC: 16
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Identify
            - Mage Hand
            - Minor Illusion
            - Prestidigitation
        - frequency: 1/day
          spells:
            - Dispel Magic
            - Legend Lore
            - Locate Object
            - Plane Shift
            - Remove Curse
            - Tongues
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Sphinx of Lore
*Large, Celestial, Lawful Neutral*

**AC** 17
**HP** 170 (20d10 + 60)
**Initiative** +6 (16)
**Speed** 40 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** truesight 120 ft.; Passive Perception 18
**Languages** Celestial, Common
CR 11, PB +4, XP 7200

## Traits

**Inscrutable**
No magic can observe the sphinx remotely or detect its thoughts without its permission. Wisdom (Insight) checks made to ascertain its intentions or sincerity are made with Disadvantage.

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the sphinx fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The sphinx makes three Claw attacks.

**Claw**
*Melee Attack Roll:* +8, reach 5 ft. 14 (3d6 + 4) Slashing damage.

**Mind-Rending Roar (Recharge 5-6)**
*Wisdom Saving Throw*: DC 16, each enemy in a 300-foot Emanation originating from the sphinx. *Failure:*  35 (10d6) Psychic damage, and the target has the Incapacitated condition until the start of the sphinx's next turn.

**Spellcasting**
The sphinx casts one of the following spells, requiring no Material components and using Intelligence as the spellcasting ability (spell save DC 16): - **At Will:** *Detect Magic*, *Identify*, *Mage Hand*, *Minor Illusion*, *Prestidigitation* - **1e/Day Each:** *Dispel Magic*, *Legend Lore*, *Locate Object*, *Plane Shift*, *Remove Curse*, *Tongues*

## Legendary Actions

**Arcane Prowl**
The sphinx can teleport up to 30 feet to an unoccupied space it can see, and it makes one Claw attack.

**Weight of Years**
*Constitution Saving Throw*: DC 16, one creature the sphinx can see within 120 feet. *Failure:*  The target gains 1 Exhaustion level. While the target has any Exhaustion levels, it appears 3d10 years older. *Failure or Success*:  The sphinx can't take this action again until the start of its next turn.
`,
      "Monsters/sphinx-of-valor.md": `---
smType: creature
name: Sphinx of Valor
size: Large
type: Celestial
alignmentLawChaos: Lawful
alignmentGoodEvil: Neutral
ac: '17'
initiative: +4 (14)
hp: '199'
hitDice: 19d10 + 95
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 22
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 6
  - key: con
    score: 20
    saveProf: true
    saveMod: 11
  - key: int
    score: 16
    saveProf: true
    saveMod: 9
  - key: wis
    score: 23
    saveProf: true
    saveMod: 12
  - key: cha
    score: 18
    saveProf: false
pb: '+6'
skills:
  - skill: Arcana
    value: '9'
  - skill: Perception
    value: '12'
  - skill: Religion
    value: '15'
sensesList:
  - type: truesight
    range: '120'
passivesList:
  - skill: Perception
    value: '22'
languagesList:
  - value: Celestial
  - value: Common
damageResistancesList:
  - value: Necrotic
  - value: Radiant
damageImmunitiesList:
  - value: Psychic; Charmed
conditionImmunitiesList:
  - value: Frightened
cr: '17'
xp: '18000'
entries:
  - category: trait
    name: Inscrutable
    entryType: special
    text: No magic can observe the sphinx remotely or detect its thoughts without its permission. Wisdom (Insight) checks made to ascertain its intentions or sincerity are made with Disadvantage.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Legendary Resistance (3/Day, or 4/Day in Lair)
    entryType: special
    text: If the sphinx fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The sphinx makes two Claw attacks and uses Roar.
    multiattack:
      attacks:
        - name: Claw
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +12, reach 5 ft. 20 (4d6 + 6) Slashing damage.'
    attack:
      type: melee
      bonus: 12
      damage:
        - dice: 4d6
          bonus: 6
          type: Slashing
          average: 20
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Roar (3/Day)
    entryType: save
    text: 'The sphinx emits a magical roar. Whenever it roars, the roar has a different effect, as detailed below (the sequence resets when it takes a Long Rest): - **First Roar**: *Wisdom Saving Throw*: DC 20, each enemy in a 500-foot Emanation originating from the sphinx. *Failure:*  The target has the Frightened condition for 1 minute. - **Second Roar**: *Wisdom Saving Throw*: DC 20, each enemy in a 500-foot Emanation originating from the sphinx. *Failure:*  The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically. - **Third Roar**: *Constitution Saving Throw*: DC 20, each enemy in a 500-foot Emanation originating from the sphinx. *Failure:*  44 (8d10) Thunder damage, and the target has the Prone condition. *Success:*  Half damage only.'
    limitedUse:
      count: 3
      reset: day
    save:
      ability: wis
      dc: 20
      targeting:
        shape: emanation
        size: 500 ft.
        origin: self
      onFail:
        effects:
          conditions:
            - condition: Frightened
              duration:
                type: minutes
                count: 1
              saveToEnd:
                timing: end-of-turn
            - condition: Paralyzed
              duration:
                type: minutes
                count: 1
              saveToEnd:
                timing: end-of-turn
            - condition: Prone
              duration:
                type: minutes
                count: 1
              saveToEnd:
                timing: end-of-turn
        damage:
          - dice: 8d10
            bonus: 0
            type: Thunder
            average: 44
      onSuccess:
        damage: half
        legacyText: Half damage only.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Arcane Prowl
    entryType: multiattack
    text: The sphinx can teleport up to 30 feet to an unoccupied space it can see, and it makes one Claw attack.
    multiattack:
      attacks:
        - name: Claw
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
  - category: legendary
    name: Weight of Years
    entryType: save
    text: '*Constitution Saving Throw*: DC 16, one creature the sphinx can see within 120 feet. *Failure:*  The target gains 1 Exhaustion level. While the target has any Exhaustion levels, it appears 3d10 years older. *Failure or Success*:  The sphinx can''t take this action again until the start of its next turn.'
    save:
      ability: con
      dc: 16
      targeting:
        type: single
        range: 120 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          other: The target gains 1 Exhaustion level. While the target has any Exhaustion levels, it appears 3d10 years older.
        legacyEffects: The target gains 1 Exhaustion level. While the target has any Exhaustion levels, it appears 3d10 years older.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The sphinx casts one of the following spells, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 20): - **At Will:** *Detect Evil and Good*, *Thaumaturgy* - **1e/Day Each:** *Detect Magic*, *Dispel Magic*, *Greater Restoration*, *Heroes'' Feast*, *Zone of Truth*'
    spellcasting:
      ability: wis
      saveDC: 20
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Evil and Good
            - Thaumaturgy
        - frequency: 1/day
          spells:
            - Detect Magic
            - Dispel Magic
            - Greater Restoration
            - Heroes' Feast
            - Zone of Truth
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Sphinx of Valor
*Large, Celestial, Lawful Neutral*

**AC** 17
**HP** 199 (19d10 + 95)
**Initiative** +4 (14)
**Speed** 40 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** truesight 120 ft.; Passive Perception 22
**Languages** Celestial, Common
CR 17, PB +6, XP 18000

## Traits

**Inscrutable**
No magic can observe the sphinx remotely or detect its thoughts without its permission. Wisdom (Insight) checks made to ascertain its intentions or sincerity are made with Disadvantage.

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the sphinx fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The sphinx makes two Claw attacks and uses Roar.

**Claw**
*Melee Attack Roll:* +12, reach 5 ft. 20 (4d6 + 6) Slashing damage.

**Roar (3/Day)**
The sphinx emits a magical roar. Whenever it roars, the roar has a different effect, as detailed below (the sequence resets when it takes a Long Rest): - **First Roar**: *Wisdom Saving Throw*: DC 20, each enemy in a 500-foot Emanation originating from the sphinx. *Failure:*  The target has the Frightened condition for 1 minute. - **Second Roar**: *Wisdom Saving Throw*: DC 20, each enemy in a 500-foot Emanation originating from the sphinx. *Failure:*  The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically. - **Third Roar**: *Constitution Saving Throw*: DC 20, each enemy in a 500-foot Emanation originating from the sphinx. *Failure:*  44 (8d10) Thunder damage, and the target has the Prone condition. *Success:*  Half damage only.

**Spellcasting**
The sphinx casts one of the following spells, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 20): - **At Will:** *Detect Evil and Good*, *Thaumaturgy* - **1e/Day Each:** *Detect Magic*, *Dispel Magic*, *Greater Restoration*, *Heroes' Feast*, *Zone of Truth*

## Legendary Actions

**Arcane Prowl**
The sphinx can teleport up to 30 feet to an unoccupied space it can see, and it makes one Claw attack.

**Weight of Years**
*Constitution Saving Throw*: DC 16, one creature the sphinx can see within 120 feet. *Failure:*  The target gains 1 Exhaustion level. While the target has any Exhaustion levels, it appears 3d10 years older. *Failure or Success*:  The sphinx can't take this action again until the start of its next turn.
`,
      "Monsters/sphinx-of-wonder.md": `---
smType: creature
name: Sphinx of Wonder
size: Small
type: Celestial
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '13'
initiative: +3 (13)
hp: '24'
hitDice: 7d4 + 7
speeds:
  walk:
    distance: 20 ft.
  fly:
    distance: 40 ft.
abilities:
  - key: str
    score: 6
    saveProf: false
  - key: dex
    score: 17
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 15
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 11
    saveProf: false
pb: '+2'
skills:
  - skill: Arcana
    value: '4'
  - skill: Religion
    value: '4'
  - skill: Stealth
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Celestial
  - value: Common
damageResistancesList:
  - value: Necrotic
  - value: Psychic
  - value: Radiant
cr: '1'
xp: '200'
entries:
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The sphinx has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Slashing damage plus 7 (2d6) Radiant damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d4
          bonus: 3
          type: Slashing
          average: 5
        - dice: 2d6
          bonus: 0
          type: Radiant
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Sphinx of Wonder
*Small, Celestial, Lawful Good*

**AC** 13
**HP** 24 (7d4 + 7)
**Initiative** +3 (13)
**Speed** 20 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 11
**Languages** Celestial, Common
CR 1, PB +2, XP 200

## Traits

**Magic Resistance**
The sphinx has Advantage on saving throws against spells and other magical effects.

## Actions

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Slashing damage plus 7 (2d6) Radiant damage.
`,
      "Monsters/spirit-naga.md": `---
smType: creature
name: Spirit Naga
size: Large
type: Fiend
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '17'
initiative: +3 (13)
hp: '135'
hitDice: 18d10 + 36
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 17
    saveProf: true
    saveMod: 6
  - key: con
    score: 14
    saveProf: true
    saveMod: 5
  - key: int
    score: 16
    saveProf: false
  - key: wis
    score: 15
    saveProf: true
    saveMod: 5
  - key: cha
    score: 16
    saveProf: true
    saveMod: 6
pb: '+3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Abyssal
  - value: Common
damageImmunitiesList:
  - value: Poison; Charmed
conditionImmunitiesList:
  - value: Poisoned
cr: '8'
xp: '3900'
entries:
  - category: trait
    name: Fiendish Restoration
    entryType: special
    text: If it dies, the naga returns to life in 1d6 days and regains all its Hit Points. Only a *Wish* spell can prevent this trait from functioning.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: special
    text: The naga makes three attacks, using Bite or Necrotic Ray in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 10 ft. 7 (1d6 + 4) Piercing damage plus 14 (4d6) Poison damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 1d6
          bonus: 4
          type: Piercing
          average: 7
        - dice: 4d6
          bonus: 0
          type: Poison
          average: 14
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Necrotic Ray
    entryType: attack
    text: '*Ranged Attack Roll:* +6, range 60 ft. 21 (6d6) Necrotic damage.'
    attack:
      type: ranged
      bonus: 6
      damage:
        - dice: 6d6
          bonus: 0
          type: Necrotic
          average: 21
      range: 60 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The naga casts one of the following spells, requiring no Somatic or Material components and using Intelligence as the spellcasting ability (spell save DC 14): - **At Will:** *Detect Magic*, *Mage Hand*, *Minor Illusion*, *Water Breathing* - **2e/Day Each:** *Detect Thoughts*, *Dimension Door*, *Hold Person*, *Lightning Bolt*'
    spellcasting:
      ability: int
      saveDC: 14
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Mage Hand
            - Minor Illusion
            - Water Breathing
        - frequency: 2/day
          spells:
            - Detect Thoughts
            - Dimension Door
            - Hold Person
            - Lightning Bolt
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Spirit Naga
*Large, Fiend, Chaotic Evil*

**AC** 17
**HP** 135 (18d10 + 36)
**Initiative** +3 (13)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 12
**Languages** Abyssal, Common
CR 8, PB +3, XP 3900

## Traits

**Fiendish Restoration**
If it dies, the naga returns to life in 1d6 days and regains all its Hit Points. Only a *Wish* spell can prevent this trait from functioning.

## Actions

**Multiattack**
The naga makes three attacks, using Bite or Necrotic Ray in any combination.

**Bite**
*Melee Attack Roll:* +7, reach 10 ft. 7 (1d6 + 4) Piercing damage plus 14 (4d6) Poison damage.

**Necrotic Ray**
*Ranged Attack Roll:* +6, range 60 ft. 21 (6d6) Necrotic damage.

**Spellcasting**
The naga casts one of the following spells, requiring no Somatic or Material components and using Intelligence as the spellcasting ability (spell save DC 14): - **At Will:** *Detect Magic*, *Mage Hand*, *Minor Illusion*, *Water Breathing* - **2e/Day Each:** *Detect Thoughts*, *Dimension Door*, *Hold Person*, *Lightning Bolt*
`,
      "Monsters/sprite.md": `---
smType: creature
name: Sprite
size: Small
type: Fey
alignmentLawChaos: Neutral
alignmentGoodEvil: Good
ac: '15'
initiative: +4 (14)
hp: '10'
hitDice: 4d4
speeds:
  walk:
    distance: 10 ft.
  fly:
    distance: 40 ft.
abilities:
  - key: str
    score: 3
    saveProf: false
  - key: dex
    score: 18
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 14
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 11
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
  - skill: Stealth
    value: '8'
passivesList:
  - skill: Perception
    value: '13'
languagesList:
  - value: Common
  - value: Elvish
  - value: Sylvan
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Needle Sword
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 6 (1d4 + 4) Piercing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d4
          bonus: 4
          type: Piercing
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Enchanting Bow
    entryType: attack
    text: '*Ranged Attack Roll:* +6, range 40/160 ft. 1 Piercing damage, and the target has the Charmed condition until the start of the sprite''s next turn.'
    attack:
      type: ranged
      bonus: 6
      damage: []
      range: 40/160 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Heart Sight
    entryType: save
    text: '*Charisma Saving Throw*: DC 10, one creature within 5 feet the sprite can see (Celestials, Fiends, and Undead automatically fail the save). *Failure:*  The sprite knows the target''s emotions and alignment.'
    save:
      ability: cha
      dc: 10
      targeting:
        type: single
        range: 5 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          knowledge: the target's emotions and alignment
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Invisibility
    entryType: spellcasting
    text: The sprite casts *Invisibility* on itself, requiring no spell components and using Charisma as the spellcasting ability. - **At Will:** *Invisibility*
    spellcasting:
      ability: cha
      spellLists:
        - frequency: at-will
          spells:
            - Invisibility
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Sprite
*Small, Fey, Neutral Good*

**AC** 15
**HP** 10 (4d4)
**Initiative** +4 (14)
**Speed** 10 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common, Elvish, Sylvan
CR 1/4, PB +2, XP 50

## Actions

**Needle Sword**
*Melee Attack Roll:* +6, reach 5 ft. 6 (1d4 + 4) Piercing damage.

**Enchanting Bow**
*Ranged Attack Roll:* +6, range 40/160 ft. 1 Piercing damage, and the target has the Charmed condition until the start of the sprite's next turn.

**Heart Sight**
*Charisma Saving Throw*: DC 10, one creature within 5 feet the sprite can see (Celestials, Fiends, and Undead automatically fail the save). *Failure:*  The sprite knows the target's emotions and alignment.

**Invisibility**
The sprite casts *Invisibility* on itself, requiring no spell components and using Charisma as the spellcasting ability. - **At Will:** *Invisibility*
`,
      "Monsters/spy.md": `---
smType: creature
name: Spy
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '12'
initiative: +4 (14)
hp: '27'
hitDice: 6d8
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 16
    saveProf: false
pb: '+2'
skills:
  - skill: Deception
    value: '5'
  - skill: Insight
    value: '4'
  - skill: Investigation
    value: '5'
  - skill: Perception
    value: '6'
  - skill: Sleight of hand
    value: '4'
  - skill: Stealth
    value: '6'
passivesList:
  - skill: Perception
    value: '16'
languagesList:
  - value: Common plus one other language
cr: '1'
xp: '200'
entries:
  - category: action
    name: Shortsword
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 7 (2d6) Poison damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Piercing
          average: 5
        - dice: 2d6
          bonus: 0
          type: Poison
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Hand Crossbow
    entryType: attack
    text: '*Ranged Attack Roll:* +4, range 30/120 ft. 5 (1d6 + 2) Piercing damage plus 7 (2d6) Poison damage.'
    attack:
      type: ranged
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Piercing
          average: 5
        - dice: 2d6
          bonus: 0
          type: Poison
          average: 7
      range: 30/120 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Cunning Action
    entryType: special
    text: The spy takes the Dash, Disengage, or Hide action.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Spy
*Small, Humanoid, Neutral Neutral*

**AC** 12
**HP** 27 (6d8)
**Initiative** +4 (14)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common plus one other language
CR 1, PB +2, XP 200

## Actions

**Shortsword**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 7 (2d6) Poison damage.

**Hand Crossbow**
*Ranged Attack Roll:* +4, range 30/120 ft. 5 (1d6 + 2) Piercing damage plus 7 (2d6) Poison damage.

## Bonus Actions

**Cunning Action**
The spy takes the Dash, Disengage, or Hide action.
`,
      "Monsters/steam-mephit.md": `---
smType: creature
name: Steam Mephit
size: Small
type: Elemental
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '10'
initiative: +0 (10)
hp: '17'
hitDice: 5d6
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 30 ft.
abilities:
  - key: str
    score: 5
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 11
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 12
    saveProf: false
pb: '+2'
skills:
  - skill: Stealth
    value: '2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Primordial (Aquan
  - value: Ignan)
damageImmunitiesList:
  - value: Fire
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Poisoned
cr: 1/4
xp: '50'
entries:
  - category: trait
    name: Blurred Form
    entryType: special
    text: Attack rolls against the mephit are made with Disadvantage unless the mephit has the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Death Burst
    entryType: save
    text: 'The mephit explodes when it dies. *Dexterity Saving Throw*: DC 10, each creature in a 5-foot Emanation originating from the mephit. *Failure:*  5 (2d4) Fire damage. *Success:*  Half damage.'
    save:
      ability: dex
      dc: 10
      targeting:
        shape: emanation
        size: 5 ft.
        origin: self
      onFail:
        effects:
          other: 5 (2d4) Fire damage.
        damage:
          - dice: 2d4
            bonus: 0
            type: Fire
            average: 5
        legacyEffects: 5 (2d4) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Slashing damage plus 2 (1d4) Fire damage.'
    attack:
      type: melee
      bonus: 2
      damage:
        - dice: 1d4
          bonus: 0
          type: Slashing
          average: 2
        - dice: 1d4
          bonus: 0
          type: Fire
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Steam Breath
    entryType: save
    text: '*Constitution Saving Throw*: DC 10, each creature in a 15-foot Cone. *Failure:*  5 (2d4) Fire damage, and the target''s Speed decreases by 10 feet until the end of the mephit''s next turn. *Success:*  Half damage only. *Failure or Success*:  Being underwater doesn''t grant Resistance to this Fire damage.'
    save:
      ability: con
      dc: 10
      targeting:
        shape: cone
        size: 15 ft.
      onFail:
        effects:
          other: 5 (2d4) Fire damage, and the target's Speed decreases by 10 feet until the end of the mephit's next turn.
        damage:
          - dice: 2d4
            bonus: 0
            type: Fire
            average: 5
        legacyEffects: 5 (2d4) Fire damage, and the target's Speed decreases by 10 feet until the end of the mephit's next turn.
      onSuccess:
        damage: half
        legacyText: Half damage only.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Steam Mephit
*Small, Elemental, Neutral Evil*

**AC** 10
**HP** 17 (5d6)
**Initiative** +0 (10)
**Speed** 30 ft., fly 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Primordial (Aquan, Ignan)
CR 1/4, PB +2, XP 50

## Traits

**Blurred Form**
Attack rolls against the mephit are made with Disadvantage unless the mephit has the Incapacitated condition.

**Death Burst**
The mephit explodes when it dies. *Dexterity Saving Throw*: DC 10, each creature in a 5-foot Emanation originating from the mephit. *Failure:*  5 (2d4) Fire damage. *Success:*  Half damage.

## Actions

**Claw**
*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Slashing damage plus 2 (1d4) Fire damage.

**Steam Breath (Recharge 6)**
*Constitution Saving Throw*: DC 10, each creature in a 15-foot Cone. *Failure:*  5 (2d4) Fire damage, and the target's Speed decreases by 10 feet until the end of the mephit's next turn. *Success:*  Half damage only. *Failure or Success*:  Being underwater doesn't grant Resistance to this Fire damage.
`,
      "Monsters/stirge.md": `---
smType: creature
name: Stirge
size: Small
type: Monstrosity
alignmentOverride: Unaligned
ac: '13'
initiative: +3 (13)
hp: '5'
hitDice: 2d4
speeds:
  walk:
    distance: 10 ft.
  fly:
    distance: 40 ft.
abilities:
  - key: str
    score: 4
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 8
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '9'
cr: 1/8
xp: '25'
entries:
  - category: action
    name: Proboscis
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Piercing damage, and the stirge attaches to the target. While attached, the stirge can''t make Proboscis attacks, and the target takes 5 (2d4) Necrotic damage at the start of each of the stirge''s turns. The stirge can detach itself by spending 5 feet of its movement. The target or a creature within 5 feet of it can detach the stirge as an action.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d6
          bonus: 3
          type: Piercing
          average: 6
        - dice: 2d4
          bonus: 0
          type: Necrotic
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Stirge
*Small, Monstrosity, Unaligned*

**AC** 13
**HP** 5 (2d4)
**Initiative** +3 (13)
**Speed** 10 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 9
CR 1/8, PB +2, XP 25

## Actions

**Proboscis**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Piercing damage, and the stirge attaches to the target. While attached, the stirge can't make Proboscis attacks, and the target takes 5 (2d4) Necrotic damage at the start of each of the stirge's turns. The stirge can detach itself by spending 5 feet of its movement. The target or a creature within 5 feet of it can detach the stirge as an action.
`,
      "Monsters/stone-giant.md": `---
smType: creature
name: Stone Giant
size: Huge
type: Giant
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '17'
initiative: +5 (15)
hp: '126'
hitDice: 11d12 + 55
speeds:
  walk:
    distance: 40 ft.
abilities:
  - key: str
    score: 23
    saveProf: false
  - key: dex
    score: 15
    saveProf: true
    saveMod: 5
  - key: con
    score: 20
    saveProf: true
    saveMod: 8
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 12
    saveProf: true
    saveMod: 4
  - key: cha
    score: 9
    saveProf: false
pb: '+3'
skills:
  - skill: Athletics
    value: '12'
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Giant
cr: '7'
xp: '2900'
entries:
  - category: action
    name: Multiattack
    entryType: special
    text: The giant makes two attacks, using Stone Club or Boulder in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Stone Club
    entryType: attack
    text: '*Melee Attack Roll:* +9, reach 15 ft. 22 (3d10 + 6) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 9
      damage:
        - dice: 3d10
          bonus: 6
          type: Bludgeoning
          average: 22
      reach: 15 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Boulder
    entryType: attack
    text: '*Ranged Attack Roll:* +9, range 60/240 ft. 15 (2d8 + 6) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.'
    attack:
      type: ranged
      bonus: 9
      damage:
        - dice: 2d8
          bonus: 6
          type: Bludgeoning
          average: 15
      range: 60/240 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Stone Giant
*Huge, Giant, Neutral Neutral*

**AC** 17
**HP** 126 (11d12 + 55)
**Initiative** +5 (15)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 14
**Languages** Giant
CR 7, PB +3, XP 2900

## Actions

**Multiattack**
The giant makes two attacks, using Stone Club or Boulder in any combination.

**Stone Club**
*Melee Attack Roll:* +9, reach 15 ft. 22 (3d10 + 6) Bludgeoning damage.

**Boulder**
*Ranged Attack Roll:* +9, range 60/240 ft. 15 (2d8 + 6) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.
`,
      "Monsters/stone-golem.md": `---
smType: creature
name: Stone Golem
size: Large
type: Construct
alignmentOverride: Unaligned
ac: '18'
initiative: +3 (13)
hp: '220'
hitDice: 21d10 + 105
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 22
    saveProf: false
  - key: dex
    score: 9
    saveProf: false
  - key: con
    score: 20
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 1
    saveProf: false
pb: '+4'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Understands Common plus two other languages but can't speak
damageImmunitiesList:
  - value: Poison
  - value: Psychic; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Frightened
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
cr: '10'
xp: '5900'
entries:
  - category: trait
    name: Immutable Form
    entryType: special
    text: The golem can't shape-shift.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The golem has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: special
    text: The golem makes two attacks, using Slam or Force Bolt in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Slam
    entryType: attack
    text: '*Melee Attack Roll:* +10, reach 5 ft. 15 (2d8 + 6) Bludgeoning damage plus 9 (2d8) Force damage.'
    attack:
      type: melee
      bonus: 10
      damage:
        - dice: 2d8
          bonus: 6
          type: Bludgeoning
          average: 15
        - dice: 2d8
          bonus: 0
          type: Force
          average: 9
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Force Bolt
    entryType: attack
    text: '*Ranged Attack Roll:* +9, range 120 ft. 22 (4d10) Force damage.'
    attack:
      type: ranged
      bonus: 9
      damage:
        - dice: 4d10
          bonus: 0
          type: Force
          average: 22
      range: 120 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: bonus
    name: Slow (Recharge 5-6)
    entryType: spellcasting
    text: The golem casts the *Slow* spell, requiring no spell components and using Constitution as the spellcasting ability (spell save DC 17).
    recharge: 5-6
    spellcasting:
      ability: int
      saveDC: 17
      spellLists: []
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Stone Golem
*Large, Construct, Unaligned*

**AC** 18
**HP** 220 (21d10 + 105)
**Initiative** +3 (13)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 10
**Languages** Understands Common plus two other languages but can't speak
CR 10, PB +4, XP 5900

## Traits

**Immutable Form**
The golem can't shape-shift.

**Magic Resistance**
The golem has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The golem makes two attacks, using Slam or Force Bolt in any combination.

**Slam**
*Melee Attack Roll:* +10, reach 5 ft. 15 (2d8 + 6) Bludgeoning damage plus 9 (2d8) Force damage.

**Force Bolt**
*Ranged Attack Roll:* +9, range 120 ft. 22 (4d10) Force damage.

## Bonus Actions

**Slow (Recharge 5-6)**
The golem casts the *Slow* spell, requiring no spell components and using Constitution as the spellcasting ability (spell save DC 17).
`,
      "Monsters/storm-giant.md": `---
smType: creature
name: Storm Giant
size: Huge
type: Giant
alignmentLawChaos: Chaotic
alignmentGoodEvil: Good
ac: '16'
initiative: +7 (17)
hp: '230'
hitDice: 20d12 + 100
speeds:
  walk:
    distance: 50 ft.
  fly:
    distance: 25 ft.
    hover: true
  swim:
    distance: 50 ft.
abilities:
  - key: str
    score: 29
    saveProf: true
    saveMod: 14
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 20
    saveProf: true
    saveMod: 10
  - key: int
    score: 16
    saveProf: false
  - key: wis
    score: 20
    saveProf: true
    saveMod: 10
  - key: cha
    score: 18
    saveProf: true
    saveMod: 9
pb: '+5'
skills:
  - skill: Arcana
    value: '8'
  - skill: Athletics
    value: '14'
  - skill: History
    value: '8'
  - skill: Perception
    value: '10'
sensesList:
  - type: darkvision
    range: '120'
  - type: truesight
    range: '30'
passivesList:
  - skill: Perception
    value: '20'
languagesList:
  - value: Common
  - value: Giant
damageResistancesList:
  - value: Cold
damageImmunitiesList:
  - value: Lightning
  - value: Thunder
cr: '13'
xp: '10000'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The giant can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: special
    text: The giant makes two attacks, using Storm Sword or Thunderbolt in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Storm Sword
    entryType: attack
    text: '*Melee Attack Roll:* +14, reach 10 ft. 23 (4d6 + 9) Slashing damage plus 13 (3d8) Lightning damage.'
    attack:
      type: melee
      bonus: 14
      damage:
        - dice: 4d6
          bonus: 9
          type: Slashing
          average: 23
        - dice: 3d8
          bonus: 0
          type: Lightning
          average: 13
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Thunderbolt
    entryType: attack
    text: '*Ranged Attack Roll:* +14, range 500 ft. 22 (2d12 + 9) Lightning damage, and the target has the Blinded and Deafened conditions until the start of the giant''s next turn.'
    attack:
      type: ranged
      bonus: 14
      damage:
        - dice: 2d12
          bonus: 9
          type: Lightning
          average: 22
      range: 500 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Lightning Storm (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 18, each creature in a 10-foot-radius, 40-foot-high Cylinder [Area of Effect]|XPHB|Cylinder originating from a point the giant can see within 500 feet. *Failure:*  55 (10d10) Lightning damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 18
      targeting:
        shape: cylinder
        size: 10 ft.
        height: 40 ft.
        origin: self
      onFail:
        effects:
          other: 55 (10d10) Lightning damage.
        damage:
          - dice: 10d10
            bonus: 0
            type: Lightning
            average: 55
        legacyEffects: 55 (10d10) Lightning damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The giant casts one of the following spells, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 18): - **At Will:** *Detect Magic*, *Light* - **1/Day Each:** *Control Weather*'
    spellcasting:
      ability: wis
      saveDC: 18
      excludeComponents:
        - M
      spellLists:
        - frequency: at-will
          spells:
            - Detect Magic
            - Light
        - frequency: 1/day
          spells:
            - Control Weather
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Storm Giant
*Huge, Giant, Chaotic Good*

**AC** 16
**HP** 230 (20d12 + 100)
**Initiative** +7 (17)
**Speed** 50 ft., swim 50 ft., fly 25 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft., truesight 30 ft.; Passive Perception 20
**Languages** Common, Giant
CR 13, PB +5, XP 10000

## Traits

**Amphibious**
The giant can breathe air and water.

## Actions

**Multiattack**
The giant makes two attacks, using Storm Sword or Thunderbolt in any combination.

**Storm Sword**
*Melee Attack Roll:* +14, reach 10 ft. 23 (4d6 + 9) Slashing damage plus 13 (3d8) Lightning damage.

**Thunderbolt**
*Ranged Attack Roll:* +14, range 500 ft. 22 (2d12 + 9) Lightning damage, and the target has the Blinded and Deafened conditions until the start of the giant's next turn.

**Lightning Storm (Recharge 5-6)**
*Dexterity Saving Throw*: DC 18, each creature in a 10-foot-radius, 40-foot-high Cylinder [Area of Effect]|XPHB|Cylinder originating from a point the giant can see within 500 feet. *Failure:*  55 (10d10) Lightning damage. *Success:*  Half damage.

**Spellcasting**
The giant casts one of the following spells, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 18): - **At Will:** *Detect Magic*, *Light* - **1/Day Each:** *Control Weather*
`,
      "Monsters/succubus.md": `---
smType: creature
name: Succubus
size: Medium
type: Fiend
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '15'
initiative: +3 (13)
hp: '71'
hitDice: 13d8 + 13
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 8
    saveProf: false
  - key: dex
    score: 17
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 15
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 20
    saveProf: false
pb: '+2'
skills:
  - skill: Deception
    value: '9'
  - skill: Insight
    value: '5'
  - skill: Perception
    value: '5'
  - skill: Persuasion
    value: '9'
  - skill: Stealth
    value: '7'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '15'
languagesList:
  - value: Abyssal
  - value: Common
  - value: Infernal
  - value: telepathy 60 ft.
damageResistancesList:
  - value: Cold
  - value: Fire
  - value: Poison
  - value: Psychic
cr: '4'
xp: '1100'
entries:
  - category: trait
    name: Incubus Form
    entryType: special
    text: When the succubus finishes a Long Rest, it can shape-shift into an Incubus, using that stat block instead of this one.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The succubus makes one Fiendish Touch attack and uses Charm or Draining Kiss.
    multiattack:
      attacks:
        - name: Touch
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Fiendish Touch
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 16 (2d10 + 5) Psychic damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d10
          bonus: 5
          type: Psychic
          average: 16
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Draining Kiss
    entryType: save
    text: '*Constitution Saving Throw*: DC 15, one creature Charmed by the succubus within 5 feet. *Failure:*  13 (3d8) Psychic damage. *Success:*  Half damage. *Failure or Success*:  The target''s Hit Point maximum decreases by an amount equal to the damage taken.'
    save:
      ability: con
      dc: 15
      targeting:
        type: single
        range: 5 ft.
      onFail:
        effects:
          other: 13 (3d8) Psychic damage.
        damage:
          - dice: 3d8
            bonus: 0
            type: Psychic
            average: 13
        legacyEffects: 13 (3d8) Psychic damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Shape-Shift
    entryType: special
    text: The succubus shape-shifts to resemble a Medium or Small Humanoid or back into its true form. Its game statistics are the same in each form, except its Fly Speed is available only in its true form. Any equipment it's wearing or carrying isn't transformed.
    trigger.activation: bonus
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Charm
    entryType: spellcasting
    text: The succubus casts *Dominate Person* (level 8 version), requiring no spell components and using Charisma as the spellcasting ability (spell save DC 15).
    spellcasting:
      ability: cha
      saveDC: 15
      spellLists: []
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Succubus
*Medium, Fiend, Neutral Evil*

**AC** 15
**HP** 71 (13d8 + 13)
**Initiative** +3 (13)
**Speed** 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 15
**Languages** Abyssal, Common, Infernal, telepathy 60 ft.
CR 4, PB +2, XP 1100

## Traits

**Incubus Form**
When the succubus finishes a Long Rest, it can shape-shift into an Incubus, using that stat block instead of this one.

## Actions

**Multiattack**
The succubus makes one Fiendish Touch attack and uses Charm or Draining Kiss.

**Fiendish Touch**
*Melee Attack Roll:* +7, reach 5 ft. 16 (2d10 + 5) Psychic damage.

**Charm**
The succubus casts *Dominate Person* (level 8 version), requiring no spell components and using Charisma as the spellcasting ability (spell save DC 15).

**Draining Kiss**
*Constitution Saving Throw*: DC 15, one creature Charmed by the succubus within 5 feet. *Failure:*  13 (3d8) Psychic damage. *Success:*  Half damage. *Failure or Success*:  The target's Hit Point maximum decreases by an amount equal to the damage taken.

## Bonus Actions

**Shape-Shift**
The succubus shape-shifts to resemble a Medium or Small Humanoid or back into its true form. Its game statistics are the same in each form, except its Fly Speed is available only in its true form. Any equipment it's wearing or carrying isn't transformed.
`,
      "Monsters/swarm-of-crawling-claws.md": `---
smType: creature
name: Swarm of Crawling Claws
size: Medium
type: Undead
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '12'
initiative: +2 (12)
hp: '49'
hitDice: 11d8
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 14
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 5
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 4
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '30'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Understands Common but can't speak
damageResistancesList:
  - value: Bludgeoning
  - value: Piercing
  - value: Slashing
damageImmunitiesList:
  - value: Necrotic
  - value: Poison; Charmed
  - value: Exhaustion
  - value: Incapacitated
conditionImmunitiesList:
  - value: Frightened
  - value: Grappled
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
  - value: Prone
  - value: Restrained
  - value: Stunned
cr: '3'
xp: '700'
entries:
  - category: trait
    name: Swarm
    entryType: special
    text: The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny creature. The swarm can't regain Hit Points or gain Temporary Hit Points.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Swarm of Grasping Hands
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 20 (4d8 + 2) Necrotic damage, or 11 (2d8 + 2) Necrotic damage if the swarm is Bloodied. If the target is a Medium or smaller creature, it has the Prone condition.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 4d8
          bonus: 2
          type: Necrotic
          average: 20
        - dice: 2d8
          bonus: 2
          type: Necrotic
          average: 11
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Swarm of Crawling Claws
*Medium, Undead, Neutral Evil*

**AC** 12
**HP** 49 (11d8)
**Initiative** +2 (12)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft.; Passive Perception 10
**Languages** Understands Common but can't speak
CR 3, PB +2, XP 700

## Traits

**Swarm**
The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny creature. The swarm can't regain Hit Points or gain Temporary Hit Points.

## Actions

**Swarm of Grasping Hands**
*Melee Attack Roll:* +4, reach 5 ft. 20 (4d8 + 2) Necrotic damage, or 11 (2d8 + 2) Necrotic damage if the swarm is Bloodied. If the target is a Medium or smaller creature, it has the Prone condition.
`,
      "Monsters/tarrasque.md": `---
smType: creature
name: Tarrasque
size: Gargantuan
type: Monstrosity
typeTags:
  - value: Titan
alignmentOverride: Unaligned
ac: '25'
initiative: +18 (28)
hp: '697'
hitDice: 34d20 + 340
speeds:
  walk:
    distance: 60 ft.
  burrow:
    distance: 40 ft.
  climb:
    distance: 60 ft.
abilities:
  - key: str
    score: 30
    saveProf: false
  - key: dex
    score: 11
    saveProf: true
    saveMod: 9
  - key: con
    score: 30
    saveProf: false
  - key: int
    score: 3
    saveProf: true
    saveMod: 5
  - key: wis
    score: 11
    saveProf: true
    saveMod: 9
  - key: cha
    score: 11
    saveProf: true
    saveMod: 9
pb: '+9'
skills:
  - skill: Perception
    value: '9'
sensesList:
  - type: blindsight
    range: '120'
passivesList:
  - skill: Perception
    value: '19'
damageResistancesList:
  - value: Bludgeoning
  - value: Piercing
  - value: Slashing
damageImmunitiesList:
  - value: Fire
  - value: Poison; Charmed
conditionImmunitiesList:
  - value: Deafened
  - value: Frightened
  - value: Paralyzed
  - value: Poisoned
cr: '30'
xp: '155000'
entries:
  - category: trait
    name: Legendary Resistance (6/Day)
    entryType: special
    text: If the tarrasque fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 6
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The tarrasque has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Reflective Carapace
    entryType: special
    text: If the tarrasque is targeted by a *Magic Missile* spell or a spell that requires a ranged attack roll, roll 1d6. On a 1-5, the tarrasque is unaffected. On a 6, the tarrasque is unaffected and reflects the spell, turning the caster into the target.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Siege Monster
    entryType: special
    text: The tarrasque deals double damage to objects and structures.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The tarrasque makes one Bite attack and three other attacks, using Claw or Tail in any combination.
    multiattack:
      attacks:
        - name: Bite
          count: 1
        - name: other
          count: 3
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +19, reach 15 ft. 36 (4d12 + 10) Piercing damage, and the target has the Grappled condition (escape DC 20). Until the grapple ends, the target has the Restrained condition and can''t teleport.'
    attack:
      type: melee
      bonus: 19
      damage:
        - dice: 4d12
          bonus: 10
          type: Piercing
          average: 36
      reach: 15 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +19, reach 15 ft. 28 (4d8 + 10) Slashing damage.'
    attack:
      type: melee
      bonus: 19
      damage:
        - dice: 4d8
          bonus: 10
          type: Slashing
          average: 28
      reach: 15 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Tail
    entryType: attack
    text: '*Melee Attack Roll:* +19, reach 30 ft. 23 (3d8 + 10) Bludgeoning damage. If the target is a Huge or smaller creature, it has the Prone condition.'
    attack:
      type: melee
      bonus: 19
      damage:
        - dice: 3d8
          bonus: 10
          type: Bludgeoning
          average: 23
      reach: 30 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Huge or smaller
      additionalEffects: If the target is a Huge or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Thunderous Bellow (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 27, each creature and each object that isn''t being worn or carried in a 150-foot Cone. *Failure:*  78 (12d12) Thunder damage, and the target has the Deafened and Frightened conditions until the end of its next turn. *Success:*  Half damage only.'
    recharge: 5-6
    save:
      ability: con
      dc: 27
      targeting:
        shape: cone
        size: 150 ft.
      onFail:
        effects:
          other: 78 (12d12) Thunder damage, and the target has the Deafened and Frightened conditions until the end of its next turn.
        damage:
          - dice: 12d12
            bonus: 0
            type: Thunder
            average: 78
        legacyEffects: 78 (12d12) Thunder damage, and the target has the Deafened and Frightened conditions until the end of its next turn.
      onSuccess:
        damage: half
        legacyText: Half damage only.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Swallow
    entryType: save
    text: '*Strength Saving Throw*: DC 27, one Large or smaller creature Grappled by the tarrasque (it can have up to six creatures swallowed at a time). *Failure:*  The target is swallowed, and the Grappled condition ends. A swallowed creature has the Blinded and Restrained conditions and can''t teleport, it has Cover|XPHB|Total Cover against attacks and other effects outside the tarrasque, and it takes 56 (16d6) Acid damage at the start of each of the tarrasque''s turns. If the tarrasque takes 60 damage or more on a single turn from a creature inside it, the tarrasque must succeed on a DC 20 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, each of which falls in a space within 10 feet of the tarrasque and has the Prone condition. If the tarrasque dies, any swallowed creature no longer has the Restrained condition and can escape from the corpse using 20 feet of movement, exiting Prone.'
    save:
      ability: str
      dc: 27
      targeting:
        type: single
        count: six
        restrictions:
          size:
            - Large
            - smaller
          other:
            - grappled by source
      onFail:
        effects:
          conditions:
            - condition: Prone
            - condition: Restrained
        damage:
          - dice: 16d6
            bonus: 0
            type: Acid
            average: 56
    trigger.activation: bonus
    trigger.targeting:
      type: single
  - category: legendary
    name: Onslaught
    entryType: multiattack
    text: The tarrasque moves up to half its Speed, and it makes one Claw or Tail attack.
    multiattack:
      attacks:
        - name: Tail
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
  - category: legendary
    name: World-Shaking Movement
    entryType: special
    text: The tarrasque moves up to its Speed. At the end of this movement, the tarrasque creates an instantaneous shock wave in a 60-foot Emanation originating from itself. Creatures in that area lose  Concentration and, if Medium or smaller, have the Prone condition. The tarrasque can't take this action again until the start of its next turn.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Tarrasque
*Gargantuan, Monstrosity, Unaligned*

**AC** 25
**HP** 697 (34d20 + 340)
**Initiative** +18 (28)
**Speed** 60 ft., climb 60 ft., burrow 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 120 ft.; Passive Perception 19
CR 30, PB +9, XP 155000

## Traits

**Legendary Resistance (6/Day)**
If the tarrasque fails a saving throw, it can choose to succeed instead.

**Magic Resistance**
The tarrasque has Advantage on saving throws against spells and other magical effects.

**Reflective Carapace**
If the tarrasque is targeted by a *Magic Missile* spell or a spell that requires a ranged attack roll, roll 1d6. On a 1-5, the tarrasque is unaffected. On a 6, the tarrasque is unaffected and reflects the spell, turning the caster into the target.

**Siege Monster**
The tarrasque deals double damage to objects and structures.

## Actions

**Multiattack**
The tarrasque makes one Bite attack and three other attacks, using Claw or Tail in any combination.

**Bite**
*Melee Attack Roll:* +19, reach 15 ft. 36 (4d12 + 10) Piercing damage, and the target has the Grappled condition (escape DC 20). Until the grapple ends, the target has the Restrained condition and can't teleport.

**Claw**
*Melee Attack Roll:* +19, reach 15 ft. 28 (4d8 + 10) Slashing damage.

**Tail**
*Melee Attack Roll:* +19, reach 30 ft. 23 (3d8 + 10) Bludgeoning damage. If the target is a Huge or smaller creature, it has the Prone condition.

**Thunderous Bellow (Recharge 5-6)**
*Constitution Saving Throw*: DC 27, each creature and each object that isn't being worn or carried in a 150-foot Cone. *Failure:*  78 (12d12) Thunder damage, and the target has the Deafened and Frightened conditions until the end of its next turn. *Success:*  Half damage only.

## Bonus Actions

**Swallow**
*Strength Saving Throw*: DC 27, one Large or smaller creature Grappled by the tarrasque (it can have up to six creatures swallowed at a time). *Failure:*  The target is swallowed, and the Grappled condition ends. A swallowed creature has the Blinded and Restrained conditions and can't teleport, it has Cover|XPHB|Total Cover against attacks and other effects outside the tarrasque, and it takes 56 (16d6) Acid damage at the start of each of the tarrasque's turns. If the tarrasque takes 60 damage or more on a single turn from a creature inside it, the tarrasque must succeed on a DC 20 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, each of which falls in a space within 10 feet of the tarrasque and has the Prone condition. If the tarrasque dies, any swallowed creature no longer has the Restrained condition and can escape from the corpse using 20 feet of movement, exiting Prone.

## Legendary Actions

**Onslaught**
The tarrasque moves up to half its Speed, and it makes one Claw or Tail attack.

**World-Shaking Movement**
The tarrasque moves up to its Speed. At the end of this movement, the tarrasque creates an instantaneous shock wave in a 60-foot Emanation originating from itself. Creatures in that area lose  Concentration and, if Medium or smaller, have the Prone condition. The tarrasque can't take this action again until the start of its next turn.
`,
      "Monsters/tough-boss.md": `---
smType: creature
name: Tough Boss
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '16'
initiative: +2 (12)
hp: '82'
hitDice: 11d8 + 33
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 17
    saveProf: true
    saveMod: 5
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 16
    saveProf: true
    saveMod: 5
  - key: int
    score: 11
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 11
    saveProf: true
    saveMod: 2
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common plus one other language
cr: '4'
xp: '1100'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The tough has Advantage on an attack roll against a creature if at least one of the tough's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: special
    text: The tough makes two attacks, using Warhammer or Heavy Crossbow in any combination.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Warhammer
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 12 (2d8 + 3) Bludgeoning damage. If the target is a Large or smaller creature, the tough pushes the target up to 10 feet straight away from itself.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d8
          bonus: 3
          type: Bludgeoning
          average: 12
      reach: 5 ft.
      onHit:
        other: If the target is a Large or smaller creature, the tough pushes the target up to 10 feet straight away from itself.
      additionalEffects: If the target is a Large or smaller creature, the tough pushes the target up to 10 feet straight away from itself.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Heavy Crossbow
    entryType: attack
    text: '*Ranged Attack Roll:* +4, range 100/400 ft. 13 (2d10 + 2) Piercing damage.'
    attack:
      type: ranged
      bonus: 4
      damage:
        - dice: 2d10
          bonus: 2
          type: Piercing
          average: 13
      range: 100/400 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Tough Boss
*Small, Humanoid, Neutral Neutral*

**AC** 16
**HP** 82 (11d8 + 33)
**Initiative** +2 (12)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common plus one other language
CR 4, PB +2, XP 1100

## Traits

**Pack Tactics**
The tough has Advantage on an attack roll against a creature if at least one of the tough's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Multiattack**
The tough makes two attacks, using Warhammer or Heavy Crossbow in any combination.

**Warhammer**
*Melee Attack Roll:* +5, reach 5 ft. 12 (2d8 + 3) Bludgeoning damage. If the target is a Large or smaller creature, the tough pushes the target up to 10 feet straight away from itself.

**Heavy Crossbow**
*Ranged Attack Roll:* +4, range 100/400 ft. 13 (2d10 + 2) Piercing damage.
`,
      "Monsters/tough.md": `---
smType: creature
name: Tough
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '12'
initiative: +1 (11)
hp: '32'
hitDice: 5d8 + 10
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 11
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The tough has Advantage on an attack roll against a creature if at least one of the tough's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Mace
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d6
          bonus: 2
          type: Bludgeoning
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Heavy Crossbow
    entryType: attack
    text: '*Ranged Attack Roll:* +3, range 100/400 ft. 6 (1d10 + 1) Piercing damage.'
    attack:
      type: ranged
      bonus: 3
      damage:
        - dice: 1d10
          bonus: 1
          type: Piercing
          average: 6
      range: 100/400 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Tough
*Small, Humanoid, Neutral Neutral*

**AC** 12
**HP** 32 (5d8 + 10)
**Initiative** +1 (11)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common
CR 1/2, PB +2, XP 100

## Traits

**Pack Tactics**
The tough has Advantage on an attack roll against a creature if at least one of the tough's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Mace**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Bludgeoning damage.

**Heavy Crossbow**
*Ranged Attack Roll:* +3, range 100/400 ft. 6 (1d10 + 1) Piercing damage.
`,
      "Monsters/treant.md": `---
smType: creature
name: Treant
size: Huge
type: Plant
alignmentLawChaos: Chaotic
alignmentGoodEvil: Good
ac: '16'
initiative: +3 (13)
hp: '138'
hitDice: 12d12 + 60
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 23
    saveProf: false
  - key: dex
    score: 8
    saveProf: false
  - key: con
    score: 21
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 16
    saveProf: false
  - key: cha
    score: 12
    saveProf: false
pb: '+4'
passivesList:
  - skill: Perception
    value: '13'
languagesList:
  - value: Common
  - value: Druidic
  - value: Elvish
  - value: Sylvan
damageVulnerabilitiesList:
  - value: Fire
damageResistancesList:
  - value: Bludgeoning
  - value: Piercing
cr: '9'
xp: '5000'
entries:
  - category: trait
    name: Siege Monster
    entryType: special
    text: The treant deals double damage to objects and structures.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The treant makes two Slam attacks.
    multiattack:
      attacks:
        - name: Slam
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Slam
    entryType: attack
    text: '*Melee Attack Roll:* +10, reach 5 ft. 16 (3d6 + 6) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 10
      damage:
        - dice: 3d6
          bonus: 6
          type: Bludgeoning
          average: 16
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Hail of Bark
    entryType: attack
    text: '*Ranged Attack Roll:* +10, range 180 ft. 28 (4d10 + 6) Piercing damage.'
    attack:
      type: ranged
      bonus: 10
      damage:
        - dice: 4d10
          bonus: 6
          type: Piercing
          average: 28
      range: 180 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Animate Trees (1/Day)
    entryType: special
    text: The treant magically animates up to two trees it can see within 60 feet of itself. Each tree uses the Treant stat block, except it has Intelligence and Charisma scores of 1, it can't speak, and it lacks this action. The tree takes its turn immediately after the treant on the same Initiative count, and it obeys the treant. A tree remains animate for 1 day or until it dies, the treant dies, or it is more than 120 feet from the treant. The tree then takes root if possible.
    limitedUse:
      count: 1
      reset: day
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Treant
*Huge, Plant, Chaotic Good*

**AC** 16
**HP** 138 (12d12 + 60)
**Initiative** +3 (13)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common, Druidic, Elvish, Sylvan
CR 9, PB +4, XP 5000

## Traits

**Siege Monster**
The treant deals double damage to objects and structures.

## Actions

**Multiattack**
The treant makes two Slam attacks.

**Slam**
*Melee Attack Roll:* +10, reach 5 ft. 16 (3d6 + 6) Bludgeoning damage.

**Hail of Bark**
*Ranged Attack Roll:* +10, range 180 ft. 28 (4d10 + 6) Piercing damage.

**Animate Trees (1/Day)**
The treant magically animates up to two trees it can see within 60 feet of itself. Each tree uses the Treant stat block, except it has Intelligence and Charisma scores of 1, it can't speak, and it lacks this action. The tree takes its turn immediately after the treant on the same Initiative count, and it obeys the treant. A tree remains animate for 1 day or until it dies, the treant dies, or it is more than 120 feet from the treant. The tree then takes root if possible.
`,
      "Monsters/troll-limb.md": `---
smType: creature
name: Troll Limb
size: Small
type: Giant
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '13'
initiative: +1 (11)
hp: '14'
hitDice: 4d6
speeds:
  walk:
    distance: 20 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 9
    saveProf: false
  - key: cha
    score: 1
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '9'
cr: 1/2
xp: '100'
entries:
  - category: trait
    name: Regeneration
    entryType: special
    text: The limb regains 5 Hit Points at the start of each of its turns. If the limb takes Acid or Fire damage, this trait doesn't function on the limb's next turn. The limb dies only if it starts its turn with 0 Hit Points and doesn't regenerate.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Troll Spawn
    entryType: special
    text: The limb uncannily has the same senses as a whole troll. If the limb isn't destroyed within 24 hours, roll 1d12. On a 12, the limb turns into a Troll. Otherwise, the limb withers away.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 9 (2d4 + 4) Slashing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d4
          bonus: 4
          type: Slashing
          average: 9
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Troll Limb
*Small, Giant, Chaotic Evil*

**AC** 13
**HP** 14 (4d6)
**Initiative** +1 (11)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 9
CR 1/2, PB +2, XP 100

## Traits

**Regeneration**
The limb regains 5 Hit Points at the start of each of its turns. If the limb takes Acid or Fire damage, this trait doesn't function on the limb's next turn. The limb dies only if it starts its turn with 0 Hit Points and doesn't regenerate.

**Troll Spawn**
The limb uncannily has the same senses as a whole troll. If the limb isn't destroyed within 24 hours, roll 1d12. On a 12, the limb turns into a Troll. Otherwise, the limb withers away.

## Actions

**Rend**
*Melee Attack Roll:* +6, reach 5 ft. 9 (2d4 + 4) Slashing damage.
`,
      "Monsters/troll.md": `---
smType: creature
name: Troll
size: Large
type: Giant
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '15'
initiative: +1 (11)
hp: '94'
hitDice: 9d10 + 45
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 20
    saveProf: false
  - key: int
    score: 7
    saveProf: false
  - key: wis
    score: 9
    saveProf: false
  - key: cha
    score: 7
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '15'
languagesList:
  - value: Giant
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Loathsome Limbs (4/Day)
    entryType: special
    text: If the troll ends any turn Bloodied and took 15+ Slashing damage during that turn, one of the troll's limbs is severed, falls into the troll's space, and becomes a Troll Limb. The limb acts immediately after the troll's turn. The troll has 1 Exhaustion level for each missing limb, and it grows replacement limbs the next time it regains Hit Points.
    limitedUse:
      count: 4
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Regeneration
    entryType: special
    text: The troll regains 15 Hit Points at the start of each of its turns. If the troll takes Acid or Fire damage, this trait doesn't function on the troll's next turn. The troll dies only if it starts its turn with 0 Hit Points and doesn't regenerate.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The troll makes three Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Slashing damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d6
          bonus: 4
          type: Slashing
          average: 11
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Charge
    entryType: special
    text: The troll moves up to half its Speed straight toward an enemy it can see.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Troll
*Large, Giant, Chaotic Evil*

**AC** 15
**HP** 94 (9d10 + 45)
**Initiative** +1 (11)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 15
**Languages** Giant
CR 5, PB +3, XP 1800

## Traits

**Loathsome Limbs (4/Day)**
If the troll ends any turn Bloodied and took 15+ Slashing damage during that turn, one of the troll's limbs is severed, falls into the troll's space, and becomes a Troll Limb. The limb acts immediately after the troll's turn. The troll has 1 Exhaustion level for each missing limb, and it grows replacement limbs the next time it regains Hit Points.

**Regeneration**
The troll regains 15 Hit Points at the start of each of its turns. If the troll takes Acid or Fire damage, this trait doesn't function on the troll's next turn. The troll dies only if it starts its turn with 0 Hit Points and doesn't regenerate.

## Actions

**Multiattack**
The troll makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Slashing damage.

## Bonus Actions

**Charge**
The troll moves up to half its Speed straight toward an enemy it can see.
`,
      "Monsters/unicorn.md": `---
smType: creature
name: Unicorn
size: Large
type: Celestial
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '12'
initiative: +8 (18)
hp: '97'
hitDice: 13d10 + 26
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 11
    saveProf: false
  - key: wis
    score: 17
    saveProf: false
  - key: cha
    score: 16
    saveProf: false
pb: '+3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
languagesList:
  - value: Celestial
  - value: Elvish
  - value: Sylvan
  - value: telepathy 120 ft.
damageImmunitiesList:
  - value: Poison; Charmed
conditionImmunitiesList:
  - value: Paralyzed
  - value: Poisoned
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Legendary Resistance (3/Day)
    entryType: special
    text: If the unicorn fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The unicorn has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The unicorn makes one Hooves attack and one Radiant Horn attack.
    multiattack:
      attacks:
        - name: Hooves
          count: 1
        - name: Horn
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Hooves
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 11 (2d6 + 4) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d6
          bonus: 4
          type: Bludgeoning
          average: 11
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Radiant Horn
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 9 (1d10 + 4) Radiant damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 1d10
          bonus: 4
          type: Radiant
          average: 9
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: legendary
    name: Charging Horn
    entryType: multiattack
    text: The unicorn moves up to half its Speed without provoking Opportunity Attacks, and it makes one Radiant Horn attack.
    multiattack:
      attacks:
        - name: Opportunity
          count: 1
        - name: Horn
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
  - category: legendary
    name: Shimmering Shield
    entryType: special
    text: The unicorn targets itself or one creature it can see within 60 feet of itself. The target gains 10 (3d6) Temporary Hit Points, and its AC increases by 2 until the end of the unicorn's next turn. The unicorn can't take this action again until the start of its next turn.
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
spellcastingEntries:
  - category: action
    name: Spellcasting
    entryType: spellcasting
    text: 'The unicorn casts one of the following spells, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 14): - **At Will:** *Detect Evil and Good*, *Druidcraft* - **1e/Day Each:** *Calm Emotions*, *Dispel Evil and Good*, *Entangle*, *Pass without Trace*, *Word of Recall*'
    spellcasting:
      ability: cha
      saveDC: 14
      spellLists:
        - frequency: at-will
          spells:
            - Detect Evil and Good
            - Druidcraft
        - frequency: 1/day
          spells:
            - Calm Emotions
            - Dispel Evil and Good
            - Entangle
            - Pass without Trace
            - Word of Recall
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Unicorn's Blessing (3/Day)
    entryType: spellcasting
    text: The unicorn touches another creature with its horn and casts *Cure Wounds* or *Lesser Restoration* on that creature, using the same spellcasting ability as Spellcasting.
    limitedUse:
      count: 3
      reset: day
    spellcasting:
      ability: int
      spellLists: []
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Unicorn
*Large, Celestial, Lawful Good*

**AC** 12
**HP** 97 (13d10 + 26)
**Initiative** +8 (18)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 13
**Languages** Celestial, Elvish, Sylvan, telepathy 120 ft.
CR 5, PB +3, XP 1800

## Traits

**Legendary Resistance (3/Day)**
If the unicorn fails a saving throw, it can choose to succeed instead.

**Magic Resistance**
The unicorn has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The unicorn makes one Hooves attack and one Radiant Horn attack.

**Hooves**
*Melee Attack Roll:* +7, reach 5 ft. 11 (2d6 + 4) Bludgeoning damage.

**Radiant Horn**
*Melee Attack Roll:* +7, reach 5 ft. 9 (1d10 + 4) Radiant damage.

**Spellcasting**
The unicorn casts one of the following spells, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 14): - **At Will:** *Detect Evil and Good*, *Druidcraft* - **1e/Day Each:** *Calm Emotions*, *Dispel Evil and Good*, *Entangle*, *Pass without Trace*, *Word of Recall*

## Bonus Actions

**Unicorn's Blessing (3/Day)**
The unicorn touches another creature with its horn and casts *Cure Wounds* or *Lesser Restoration* on that creature, using the same spellcasting ability as Spellcasting.

## Legendary Actions

**Charging Horn**
The unicorn moves up to half its Speed without provoking Opportunity Attacks, and it makes one Radiant Horn attack.

**Shimmering Shield**
The unicorn targets itself or one creature it can see within 60 feet of itself. The target gains 10 (3d6) Temporary Hit Points, and its AC increases by 2 until the end of the unicorn's next turn. The unicorn can't take this action again until the start of its next turn.
`,
      "Monsters/vampire-familiar.md": `---
smType: creature
name: Vampire Familiar
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '15'
initiative: +5 (15)
hp: '65'
hitDice: 10d8 + 20
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 16
    saveProf: true
    saveMod: 5
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 10
    saveProf: true
    saveMod: 2
  - key: cha
    score: 14
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Persuasion
    value: '4'
  - skill: Stealth
    value: '7'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Common plus one other language
damageResistancesList:
  - value: Necrotic
damageImmunitiesList:
  - value: Charmed ((except from its vampire master))
cr: '3'
xp: '700'
entries:
  - category: trait
    name: Vampiric Connection
    entryType: special
    text: While the familiar and its vampire master are on the same plane of existence, the vampire can communicate with the familiar telepathically, and the vampire can perceive through the familiar's senses.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The familiar makes two Umbral Dagger attacks.
    multiattack:
      attacks:
        - name: Dagger
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Umbral Dagger
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +5, reach 5 ft. or range 20/60 ft. 5 (1d4 + 3) Piercing damage plus 7 (3d4) Necrotic damage. If the target is reduced to 0 Hit Points by this attack, the target becomes Stable but has the Poisoned condition for 1 hour. While it has the Poisoned condition, the target has the Paralyzed condition.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Deathless Agility
    entryType: special
    text: The familiar takes the Dash or Disengage action.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Vampire Familiar
*Small, Humanoid, Neutral Evil*

**AC** 15
**HP** 65 (10d8 + 20)
**Initiative** +5 (15)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 14
**Languages** Common plus one other language
CR 3, PB +2, XP 700

## Traits

**Vampiric Connection**
While the familiar and its vampire master are on the same plane of existence, the vampire can communicate with the familiar telepathically, and the vampire can perceive through the familiar's senses.

## Actions

**Multiattack**
The familiar makes two Umbral Dagger attacks.

**Umbral Dagger**
*Melee or Ranged Attack Roll:* +5, reach 5 ft. or range 20/60 ft. 5 (1d4 + 3) Piercing damage plus 7 (3d4) Necrotic damage. If the target is reduced to 0 Hit Points by this attack, the target becomes Stable but has the Poisoned condition for 1 hour. While it has the Poisoned condition, the target has the Paralyzed condition.

## Bonus Actions

**Deathless Agility**
The familiar takes the Dash or Disengage action.
`,
      "Monsters/vampire-spawn.md": `---
smType: creature
name: Vampire Spawn
size: Small
type: Undead
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '16'
initiative: +3 (13)
hp: '90'
hitDice: 12d8 + 36
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 16
    saveProf: true
    saveMod: 6
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 11
    saveProf: false
  - key: wis
    score: 10
    saveProf: true
    saveMod: 3
  - key: cha
    score: 12
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '3'
  - skill: Stealth
    value: '6'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
languagesList:
  - value: Common plus one other language
damageResistancesList:
  - value: Necrotic
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Spider Climb
    entryType: special
    text: The vampire can climb difficult surfaces, including along ceilings, without needing to make an ability check.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Vampire Weakness
    entryType: special
    text: 'The vampire has these weaknesses: - **Forbiddance**: The vampire can''t enter a residence without an invitation from an occupant. - **Running Water**: The vampire takes 20 Acid damage if it ends its turn in running water. - **Stake to the Heart**: The vampire is destroyed if a weapon that deals Piercing damage is driven into the vampire''s heart while the vampire has the Incapacitated condition. - **Sunlight**: The vampire takes 20 Radiant damage if it starts its turn in sunlight. While in sunlight, it has Disadvantage on attack rolls and ability checks.'
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The vampire makes two Claw attacks and uses Bite.
    multiattack:
      attacks:
        - name: Claw
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 8 (2d4 + 3) Slashing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 13) from one of two claws.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d4
          bonus: 3
          type: Slashing
          average: 8
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 13
            restrictions:
              size: Medium or smaller
      additionalEffects: If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 13) from one of two claws.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: save
    text: '*Constitution Saving Throw*: DC 14, one creature within 5 feet that is willing or that has the Grappled, Incapacitated, or Restrained condition. *Failure:*  5 (1d4 + 3) Piercing damage plus 10 (3d6) Necrotic damage. The target''s Hit Point maximum decreases by an amount equal to the Necrotic damage taken, and the vampire regains Hit Points equal to that amount.'
    save:
      ability: con
      dc: 14
      targeting:
        type: single
        range: 5 ft.
        restrictions:
          conditions:
            - willing
      onFail:
        effects:
          other: 5 (1d4 + 3) Piercing damage plus 10 (3d6) Necrotic damage. The target's Hit Point maximum decreases by an amount equal to the Necrotic damage taken, and the vampire regains Hit Points equal to that amount.
        damage:
          - dice: 1d4
            bonus: 3
            type: Piercing
            average: 5
          - dice: 3d6
            bonus: 0
            type: Necrotic
            average: 10
        legacyEffects: 5 (1d4 + 3) Piercing damage plus 10 (3d6) Necrotic damage. The target's Hit Point maximum decreases by an amount equal to the Necrotic damage taken, and the vampire regains Hit Points equal to that amount.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Deathless Agility
    entryType: special
    text: The vampire takes the Dash or Disengage action.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Vampire Spawn
*Small, Undead, Neutral Evil*

**AC** 16
**HP** 90 (12d8 + 36)
**Initiative** +3 (13)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 13
**Languages** Common plus one other language
CR 5, PB +3, XP 1800

## Traits

**Spider Climb**
The vampire can climb difficult surfaces, including along ceilings, without needing to make an ability check.

**Vampire Weakness**
The vampire has these weaknesses: - **Forbiddance**: The vampire can't enter a residence without an invitation from an occupant. - **Running Water**: The vampire takes 20 Acid damage if it ends its turn in running water. - **Stake to the Heart**: The vampire is destroyed if a weapon that deals Piercing damage is driven into the vampire's heart while the vampire has the Incapacitated condition. - **Sunlight**: The vampire takes 20 Radiant damage if it starts its turn in sunlight. While in sunlight, it has Disadvantage on attack rolls and ability checks.

## Actions

**Multiattack**
The vampire makes two Claw attacks and uses Bite.

**Claw**
*Melee Attack Roll:* +6, reach 5 ft. 8 (2d4 + 3) Slashing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 13) from one of two claws.

**Bite**
*Constitution Saving Throw*: DC 14, one creature within 5 feet that is willing or that has the Grappled, Incapacitated, or Restrained condition. *Failure:*  5 (1d4 + 3) Piercing damage plus 10 (3d6) Necrotic damage. The target's Hit Point maximum decreases by an amount equal to the Necrotic damage taken, and the vampire regains Hit Points equal to that amount.

## Bonus Actions

**Deathless Agility**
The vampire takes the Dash or Disengage action.
`,
      "Monsters/vampire.md": `---
smType: creature
name: Vampire
size: Small
type: Undead
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '16'
initiative: +8 (18)
hp: '195'
hitDice: 23d8 + 92
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 40 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 18
    saveProf: true
    saveMod: 9
  - key: con
    score: 18
    saveProf: true
    saveMod: 9
  - key: int
    score: 17
    saveProf: false
  - key: wis
    score: 15
    saveProf: true
    saveMod: 7
  - key: cha
    score: 18
    saveProf: true
    saveMod: 9
pb: '+5'
skills:
  - skill: Perception
    value: '7'
  - skill: Stealth
    value: '9'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '17'
languagesList:
  - value: Common plus two other languages
damageResistancesList:
  - value: Necrotic
cr: '13'
xp: '10000'
entries:
  - category: trait
    name: Legendary Resistance (3/Day, or 4/Day in Lair)
    entryType: special
    text: If the vampire fails a saving throw, it can choose to succeed instead.
    limitedUse:
      count: 3
      reset: day
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Misty Escape
    entryType: special
    text: If the vampire drops to 0 Hit Points outside its resting place, the vampire uses Shape-Shift to become mist (no action required). If it can't use Shape-Shift, it is destroyed. While it has 0 Hit Points in mist form, it can't return to its vampire form, and it must reach its resting place within 2 hours or be destroyed. Once in its resting place, it returns to its vampire form and has the Paralyzed condition until it regains any Hit Points, and it regains 1 Hit Point after spending 1 hour there.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Spider Climb
    entryType: special
    text: The vampire can climb difficult surfaces, including along ceilings, without needing to make an ability check.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Vampire Weakness
    entryType: special
    text: 'The vampire has these weaknesses: - **Forbiddance**: The vampire can''t enter a residence without an invitation from an occupant. - **Running Water**: The vampire takes 20 Acid damage if it ends its turn in running water. - **Stake to the Heart**: If a weapon that deals Piercing damage is driven into the vampire''s heart while the vampire has the Incapacitated condition in its resting place, the vampire has the Paralyzed condition until the weapon is removed. - **Sunlight**: The vampire takes 20 Radiant damage if it starts its turn in sunlight. While in sunlight, it has Disadvantage on attack rolls and ability checks.'
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack (Vampire Form Only)
    entryType: multiattack
    text: The vampire makes two Grave Strike attacks and uses Bite.
    multiattack:
      attacks:
        - name: Strike
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Grave Strike (Vampire Form Only)
    entryType: attack
    text: '*Melee Attack Roll:* +9, reach 5 ft. 8 (1d8 + 4) Bludgeoning damage plus 7 (2d6) Necrotic damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of two hands.'
    attack:
      type: melee
      bonus: 9
      damage:
        - dice: 1d8
          bonus: 4
          type: Bludgeoning
          average: 8
        - dice: 2d6
          bonus: 0
          type: Necrotic
          average: 7
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Grappled
            escape:
              type: dc
              dc: 14
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of two hands.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Bite (Bat or Vampire Form Only)
    entryType: save
    text: '*Constitution Saving Throw*: DC 17, one creature within 5 feet that is willing or that has the Grappled, Incapacitated, or Restrained condition. *Failure:*  6 (1d4 + 4) Piercing damage plus 13 (3d8) Necrotic damage. The target''s Hit Point maximum decreases by an amount equal to the Necrotic damage taken, and the vampire regains Hit Points equal to that amount. A Humanoid reduced to 0 Hit Points by this damage and then buried rises the following sunset as a Vampire Spawn under the vampire''s control.'
    save:
      ability: con
      dc: 17
      targeting:
        type: single
        range: 5 ft.
        restrictions:
          conditions:
            - willing
      onFail:
        effects:
          other: 6 (1d4 + 4) Piercing damage plus 13 (3d8) Necrotic damage. The target's Hit Point maximum decreases by an amount equal to the Necrotic damage taken, and the vampire regains Hit Points equal to that amount. A Humanoid reduced to 0 Hit Points by this damage and then buried rises the following sunset as a Vampire Spawn under the vampire's control.
        damage:
          - dice: 1d4
            bonus: 4
            type: Piercing
            average: 6
          - dice: 3d8
            bonus: 0
            type: Necrotic
            average: 13
        legacyEffects: 6 (1d4 + 4) Piercing damage plus 13 (3d8) Necrotic damage. The target's Hit Point maximum decreases by an amount equal to the Necrotic damage taken, and the vampire regains Hit Points equal to that amount. A Humanoid reduced to 0 Hit Points by this damage and then buried rises the following sunset as a Vampire Spawn under the vampire's control.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Shape-Shift
    entryType: special
    text: If the vampire isn't in sunlight or running water, it shape-shifts into a Tiny bat (Speed 5 ft., Fly Speed 30 ft.) or a Medium cloud of mist (Speed 5 ft., Fly Speed 20 ft. [hover]), or it returns to its vampire form. Anything it is wearing transforms with it. While in bat form, the vampire can't speak. Its game statistics, other than its size and Speed, are unchanged. While in mist form, the vampire can't take any actions, speak, or manipulate objects. It is weightless and can enter an enemy's space and stop there. If air can pass through a space, the mist can do so, but it can't pass through liquid. It has Resistance to all damage, except the damage it takes from sunlight.
    trigger.activation: bonus
    trigger.targeting:
      type: single
  - category: legendary
    name: Deathless Strike
    entryType: multiattack
    text: The vampire moves up to half its Speed, and it makes one Grave Strike attack.
    multiattack:
      attacks:
        - name: Strike
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: self
spellcastingEntries:
  - category: bonus
    name: Charm (Recharge 5-6)
    entryType: spellcasting
    text: The vampire casts *Charm Person*, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 17), and the duration is 24 hours. The Charmed target is a willing recipient of the vampire's Bite, the damage of which doesn't end the spell. When the spell ends, the target is unaware it was Charmed by the vampire.
    recharge: 5-6
    spellcasting:
      ability: cha
      saveDC: 17
      spellLists: []
    trigger.activation: bonus
    trigger.targeting:
      type: single
  - category: legendary
    name: Beguile
    entryType: spellcasting
    text: The vampire casts *Command*, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 17). The vampire can't take this action again until the start of its next turn.
    spellcasting:
      ability: cha
      saveDC: 17
      spellLists: []
    trigger.activation: action
    trigger.legendaryCost: 1
    trigger.targeting:
      type: single
---

# Vampire
*Small, Undead, Lawful Evil*

**AC** 16
**HP** 195 (23d8 + 92)
**Initiative** +8 (18)
**Speed** 40 ft., climb 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 17
**Languages** Common plus two other languages
CR 13, PB +5, XP 10000

## Traits

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the vampire fails a saving throw, it can choose to succeed instead.

**Misty Escape**
If the vampire drops to 0 Hit Points outside its resting place, the vampire uses Shape-Shift to become mist (no action required). If it can't use Shape-Shift, it is destroyed. While it has 0 Hit Points in mist form, it can't return to its vampire form, and it must reach its resting place within 2 hours or be destroyed. Once in its resting place, it returns to its vampire form and has the Paralyzed condition until it regains any Hit Points, and it regains 1 Hit Point after spending 1 hour there.

**Spider Climb**
The vampire can climb difficult surfaces, including along ceilings, without needing to make an ability check.

**Vampire Weakness**
The vampire has these weaknesses: - **Forbiddance**: The vampire can't enter a residence without an invitation from an occupant. - **Running Water**: The vampire takes 20 Acid damage if it ends its turn in running water. - **Stake to the Heart**: If a weapon that deals Piercing damage is driven into the vampire's heart while the vampire has the Incapacitated condition in its resting place, the vampire has the Paralyzed condition until the weapon is removed. - **Sunlight**: The vampire takes 20 Radiant damage if it starts its turn in sunlight. While in sunlight, it has Disadvantage on attack rolls and ability checks.

## Actions

**Multiattack (Vampire Form Only)**
The vampire makes two Grave Strike attacks and uses Bite.

**Grave Strike (Vampire Form Only)**
*Melee Attack Roll:* +9, reach 5 ft. 8 (1d8 + 4) Bludgeoning damage plus 7 (2d6) Necrotic damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of two hands.

**Bite (Bat or Vampire Form Only)**
*Constitution Saving Throw*: DC 17, one creature within 5 feet that is willing or that has the Grappled, Incapacitated, or Restrained condition. *Failure:*  6 (1d4 + 4) Piercing damage plus 13 (3d8) Necrotic damage. The target's Hit Point maximum decreases by an amount equal to the Necrotic damage taken, and the vampire regains Hit Points equal to that amount. A Humanoid reduced to 0 Hit Points by this damage and then buried rises the following sunset as a Vampire Spawn under the vampire's control.

## Bonus Actions

**Shape-Shift**
If the vampire isn't in sunlight or running water, it shape-shifts into a Tiny bat (Speed 5 ft., Fly Speed 30 ft.) or a Medium cloud of mist (Speed 5 ft., Fly Speed 20 ft. [hover]), or it returns to its vampire form. Anything it is wearing transforms with it. While in bat form, the vampire can't speak. Its game statistics, other than its size and Speed, are unchanged. While in mist form, the vampire can't take any actions, speak, or manipulate objects. It is weightless and can enter an enemy's space and stop there. If air can pass through a space, the mist can do so, but it can't pass through liquid. It has Resistance to all damage, except the damage it takes from sunlight.

**Charm (Recharge 5-6)**
The vampire casts *Charm Person*, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 17), and the duration is 24 hours. The Charmed target is a willing recipient of the vampire's Bite, the damage of which doesn't end the spell. When the spell ends, the target is unaware it was Charmed by the vampire.

## Legendary Actions

**Deathless Strike**
The vampire moves up to half its Speed, and it makes one Grave Strike attack.

**Beguile**
The vampire casts *Command*, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 17). The vampire can't take this action again until the start of its next turn.
`,
      "Monsters/violet-fungus.md": `---
smType: creature
name: Violet Fungus
size: Medium
type: Plant
alignmentOverride: Unaligned
ac: '5'
initiative: '-5 (5)'
hp: '18'
hitDice: 4d8
speeds:
  walk:
    distance: 5 ft.
abilities:
  - key: str
    score: 3
    saveProf: false
  - key: dex
    score: 1
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 1
    saveProf: false
  - key: wis
    score: 3
    saveProf: false
  - key: cha
    score: 1
    saveProf: false
pb: '+2'
sensesList:
  - type: blindsight
    range: '30'
passivesList:
  - skill: Perception
    value: '6'
conditionImmunitiesList:
  - value: Blinded
  - value: Charmed
  - value: Deafened
  - value: Frightened
cr: 1/4
xp: '50'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The fungus makes two Rotting Touch attacks.
    multiattack:
      attacks:
        - name: Touch
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rotting Touch
    entryType: attack
    text: '*Melee Attack Roll:* +2, reach 10 ft. 4 (1d8) Necrotic damage.'
    attack:
      type: melee
      bonus: 2
      damage:
        - dice: 1d8
          bonus: 0
          type: Necrotic
          average: 4
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Violet Fungus
*Medium, Plant, Unaligned*

**AC** 5
**HP** 18 (4d8)
**Initiative** -5 (5)
**Speed** 5 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft.; Passive Perception 6
CR 1/4, PB +2, XP 50

## Actions

**Multiattack**
The fungus makes two Rotting Touch attacks.

**Rotting Touch**
*Melee Attack Roll:* +2, reach 10 ft. 4 (1d8) Necrotic damage.
`,
      "Monsters/vrock.md": `---
smType: creature
name: Vrock
size: Large
type: Fiend
typeTags:
  - value: Demon
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '15'
initiative: +2 (12)
hp: '152'
hitDice: 16d10 + 64
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 60 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 15
    saveProf: true
    saveMod: 5
  - key: con
    score: 18
    saveProf: false
  - key: int
    score: 8
    saveProf: false
  - key: wis
    score: 13
    saveProf: true
    saveMod: 4
  - key: cha
    score: 8
    saveProf: true
    saveMod: 2
pb: '+3'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '11'
languagesList:
  - value: Abyssal
  - value: telepathy 120 ft.
damageResistancesList:
  - value: Cold
  - value: Fire
  - value: Lightning
damageImmunitiesList:
  - value: Poison; Poisoned
cr: '6'
xp: '2300'
entries:
  - category: trait
    name: Demonic Restoration
    entryType: special
    text: If the vrock dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Magic Resistance
    entryType: special
    text: The vrock has Advantage on saving throws against spells and other magical effects.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The vrock makes two Shred attacks.
    multiattack:
      attacks:
        - name: Shred
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Shred
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 10 (2d6 + 3) Piercing damage plus 10 (3d6) Poison damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d6
          bonus: 3
          type: Piercing
          average: 10
        - dice: 3d6
          bonus: 0
          type: Poison
          average: 10
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Spores
    entryType: save
    text: '*Constitution Saving Throw*: DC 15, each creature in a 20-foot Emanation originating from the vrock. *Failure:*  The target has the Poisoned condition and repeats the save at the end of each of its turns, ending the effect on itself on a success. While Poisoned, the target takes 5 (1d10) Poison damage at the start of each of its turns. Emptying a flask of Holy Water on the target ends the effect early.'
    save:
      ability: con
      dc: 15
      targeting:
        shape: emanation
        size: 20 ft.
        origin: self
      onFail:
        effects:
          conditions:
            - condition: Poisoned
              saveToEnd:
                timing: end-of-turn
        damage:
          - dice: 1d10
            bonus: 0
            type: Poison
            average: 5
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Stunning Screech (1/Day)
    entryType: save
    text: '*Constitution Saving Throw*: DC 15, each creature in a 20-foot Emanation originating from the vrock (demons succeed automatically). *Failure:*  10 (3d6) Thunder damage, and the target has the Stunned condition until the end of the vrock''s next turn.'
    limitedUse:
      count: 1
      reset: day
    save:
      ability: con
      dc: 15
      targeting:
        shape: emanation
        size: 20 ft.
        origin: self
      onFail:
        effects:
          conditions:
            - condition: Stunned
              duration:
                type: until
                trigger: the end of the vrock's next turn
        damage:
          - dice: 3d6
            bonus: 0
            type: Thunder
            average: 10
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Vrock
*Large, Fiend, Chaotic Evil*

**AC** 15
**HP** 152 (16d10 + 64)
**Initiative** +2 (12)
**Speed** 40 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 11
**Languages** Abyssal, telepathy 120 ft.
CR 6, PB +3, XP 2300

## Traits

**Demonic Restoration**
If the vrock dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.

**Magic Resistance**
The vrock has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The vrock makes two Shred attacks.

**Shred**
*Melee Attack Roll:* +6, reach 5 ft. 10 (2d6 + 3) Piercing damage plus 10 (3d6) Poison damage.

**Spores (Recharge 6)**
*Constitution Saving Throw*: DC 15, each creature in a 20-foot Emanation originating from the vrock. *Failure:*  The target has the Poisoned condition and repeats the save at the end of each of its turns, ending the effect on itself on a success. While Poisoned, the target takes 5 (1d10) Poison damage at the start of each of its turns. Emptying a flask of Holy Water on the target ends the effect early.

**Stunning Screech (1/Day)**
*Constitution Saving Throw*: DC 15, each creature in a 20-foot Emanation originating from the vrock (demons succeed automatically). *Failure:*  10 (3d6) Thunder damage, and the target has the Stunned condition until the end of the vrock's next turn.
`,
      "Monsters/warhorse-skeleton.md": `---
smType: creature
name: Warhorse Skeleton
size: Large
type: Undead
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '13'
initiative: +1 (11)
hp: '22'
hitDice: 3d10 + 6
speeds:
  walk:
    distance: 60 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 12
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 2
    saveProf: false
  - key: wis
    score: 8
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '9'
damageVulnerabilitiesList:
  - value: Bludgeoning
damageImmunitiesList:
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Poisoned
cr: 1/2
xp: '100'
entries:
  - category: action
    name: Hooves
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 7 (1d6 + 4) Bludgeoning damage. If the target is a Large or smaller creature and the skeleton moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d6
          bonus: 4
          type: Bludgeoning
          average: 7
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature and the skeleton moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Warhorse Skeleton
*Large, Undead, Lawful Evil*

**AC** 13
**HP** 22 (3d10 + 6)
**Initiative** +1 (11)
**Speed** 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 9
CR 1/2, PB +2, XP 100

## Actions

**Hooves**
*Melee Attack Roll:* +6, reach 5 ft. 7 (1d6 + 4) Bludgeoning damage. If the target is a Large or smaller creature and the skeleton moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.
`,
      "Monsters/warrior-infantry.md": `---
smType: creature
name: Warrior Infantry
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '13'
initiative: +0 (10)
hp: '9'
hitDice: 2d8
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 13
    saveProf: false
  - key: dex
    score: 11
    saveProf: false
  - key: con
    score: 11
    saveProf: false
  - key: int
    score: 8
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Common
cr: 1/8
xp: '25'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The warrior has Advantage on an attack roll against a creature if at least one of the warrior's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Spear
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +3, reach 5 ft. or range 20/60 ft. 4 (1d6 + 1) Piercing damage.'
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Warrior Infantry
*Small, Humanoid, Neutral Neutral*

**AC** 13
**HP** 9 (2d8)
**Initiative** +0 (10)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common
CR 1/8, PB +2, XP 25

## Traits

**Pack Tactics**
The warrior has Advantage on an attack roll against a creature if at least one of the warrior's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Spear**
*Melee or Ranged Attack Roll:* +3, reach 5 ft. or range 20/60 ft. 4 (1d6 + 1) Piercing damage.
`,
      "Monsters/warrior-veteran.md": `---
smType: creature
name: Warrior Veteran
size: Small
type: Humanoid
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '17'
initiative: +3 (13)
hp: '65'
hitDice: 10d8 + 20
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 10
    saveProf: false
pb: '+2'
skills:
  - skill: Athletics
    value: '5'
  - skill: Perception
    value: '2'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Common plus one other language
cr: '3'
xp: '700'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The warrior makes two Greatsword or Heavy Crossbow attacks.
    multiattack:
      attacks:
        - name: Crossbow
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Greatsword
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d6
          bonus: 3
          type: Slashing
          average: 10
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Heavy Crossbow
    entryType: attack
    text: '*Ranged Attack Roll:* +3, range 100/400 ft. 12 (2d10 + 1) Piercing damage.'
    attack:
      type: ranged
      bonus: 3
      damage:
        - dice: 2d10
          bonus: 1
          type: Piercing
          average: 12
      range: 100/400 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Warrior Veteran
*Small, Humanoid, Neutral Neutral*

**AC** 17
**HP** 65 (10d8 + 20)
**Initiative** +3 (13)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common plus one other language
CR 3, PB +2, XP 700

## Actions

**Multiattack**
The warrior makes two Greatsword or Heavy Crossbow attacks.

**Greatsword**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage.

**Heavy Crossbow**
*Ranged Attack Roll:* +3, range 100/400 ft. 12 (2d10 + 1) Piercing damage.
`,
      "Monsters/water-elemental.md": `---
smType: creature
name: Water Elemental
size: Large
type: Elemental
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '14'
initiative: +2 (12)
hp: '114'
hitDice: 12d10 + 48
speeds:
  walk:
    distance: 30 ft.
  swim:
    distance: 90 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 18
    saveProf: false
  - key: int
    score: 5
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '10'
languagesList:
  - value: Primordial (Aquan)
damageResistancesList:
  - value: Acid
  - value: Fire
damageImmunitiesList:
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Grappled
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
  - value: Prone
  - value: Restrained
  - value: Unconscious
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Freeze
    entryType: special
    text: If the elemental takes Cold damage, its Speed decreases by 20 feet until the end of its next turn.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Water Form
    entryType: special
    text: The elemental can enter an enemy's space and stop there. It can move through a space as narrow as 1 inch without expending extra movement to do so.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The elemental makes two Slam attacks.
    multiattack:
      attacks:
        - name: Slam
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Slam
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Prone condition.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d8
          bonus: 4
          type: Bludgeoning
          average: 13
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Medium or smaller
      additionalEffects: If the target is a Medium or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Whelm (Recharge 4-6)
    entryType: save
    text: '*Strength Saving Throw*: DC 15, each creature in the elemental''s space. *Failure:*  22 (4d8 + 4) Bludgeoning damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14). Until the grapple ends, the target has the Restrained condition, is suffocating unless it can breathe water, and takes 9 (2d8) Bludgeoning damage at the start of each of the elemental''s turns. The elemental can grapple one Large creature or up to two Medium or smaller creatures at a time with Whelm. As an action, a creature within 5 feet of the elemental can pull a creature out of it by succeeding on a DC 14 Strength (Athletics) check. *Success:*  Half damage only.'
    recharge: 4-6
    save:
      ability: str
      dc: 15
      targeting:
        type: single
        restrictions:
          creatureTypes:
            - creature
      onFail:
        effects:
          conditions:
            - condition: Grappled
              escape:
                type: dc
                dc: 14
              restrictions:
                size: Large or smaller
              duration:
                type: until
                trigger: the grapple ends
            - condition: Restrained
              escape:
                type: dc
                dc: 14
              restrictions:
                size: Large or smaller
              duration:
                type: until
                trigger: the grapple ends
        damage:
          - dice: 4d8
            bonus: 4
            type: Bludgeoning
            average: 22
          - dice: 2d8
            bonus: 0
            type: Bludgeoning
            average: 9
      onSuccess:
        damage: half
        legacyText: Half damage only.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Water Elemental
*Large, Elemental, Neutral Neutral*

**AC** 14
**HP** 114 (12d10 + 48)
**Initiative** +2 (12)
**Speed** 30 ft., swim 90 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 10
**Languages** Primordial (Aquan)
CR 5, PB +3, XP 1800

## Traits

**Freeze**
If the elemental takes Cold damage, its Speed decreases by 20 feet until the end of its next turn.

**Water Form**
The elemental can enter an enemy's space and stop there. It can move through a space as narrow as 1 inch without expending extra movement to do so.

## Actions

**Multiattack**
The elemental makes two Slam attacks.

**Slam**
*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Prone condition.

**Whelm (Recharge 4-6)**
*Strength Saving Throw*: DC 15, each creature in the elemental's space. *Failure:*  22 (4d8 + 4) Bludgeoning damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14). Until the grapple ends, the target has the Restrained condition, is suffocating unless it can breathe water, and takes 9 (2d8) Bludgeoning damage at the start of each of the elemental's turns. The elemental can grapple one Large creature or up to two Medium or smaller creatures at a time with Whelm. As an action, a creature within 5 feet of the elemental can pull a creature out of it by succeeding on a DC 14 Strength (Athletics) check. *Success:*  Half damage only.
`,
      "Monsters/werebear.md": `---
smType: creature
name: Werebear
size: Small
type: Monstrosity
alignmentLawChaos: Neutral
alignmentGoodEvil: Good
ac: '15'
initiative: +3 (13)
hp: '135'
hitDice: 18d8 + 54
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 11
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 12
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '7'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '17'
languagesList:
  - value: Common (can't speak in bear form)
cr: '5'
xp: '1800'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The werebear makes two attacks, using Handaxe or Rend in any combination. It can replace one attack with a Bite attack.
    multiattack:
      attacks:
        - name: two
          count: 1
      substitutions:
        - replace: attack
          with:
            type: attack
            name: a Bite attack
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite (Bear or Hybrid Form Only)
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 17 (2d12 + 4) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 14. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Werebear under the DM''s control and has 10 Hit Points. *Success:*  The target is immune to this werebear''s curse for 24 hours.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d12
          bonus: 4
          type: Piercing
          average: 17
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Cursed
            duration:
              type: hours
              count: 24
      additionalEffects: 'If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 14. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Werebear under the DM''s control and has 10 Hit Points. *Success:*  The target is immune to this werebear''s curse for 24 hours.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Handaxe (Humanoid or Hybrid Form Only)
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +7, reach 5 ft or range 20/60 ft. 14 (3d6 + 4) Slashing damage.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Rend (Bear or Hybrid Form Only)
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Slashing damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d8
          bonus: 4
          type: Slashing
          average: 13
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Shape-Shift
    entryType: special
    text: The werebear shape-shifts into a Large bear-humanoid hybrid form or a Large bear, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Werebear
*Small, Monstrosity, Neutral Good*

**AC** 15
**HP** 135 (18d8 + 54)
**Initiative** +3 (13)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 17
**Languages** Common (can't speak in bear form)
CR 5, PB +3, XP 1800

## Actions

**Multiattack**
The werebear makes two attacks, using Handaxe or Rend in any combination. It can replace one attack with a Bite attack.

**Bite (Bear or Hybrid Form Only)**
*Melee Attack Roll:* +7, reach 5 ft. 17 (2d12 + 4) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 14. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Werebear under the DM's control and has 10 Hit Points. *Success:*  The target is immune to this werebear's curse for 24 hours.

**Handaxe (Humanoid or Hybrid Form Only)**
*Melee or Ranged Attack Roll:* +7, reach 5 ft or range 20/60 ft. 14 (3d6 + 4) Slashing damage.

**Rend (Bear or Hybrid Form Only)**
*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Slashing damage.

## Bonus Actions

**Shape-Shift**
The werebear shape-shifts into a Large bear-humanoid hybrid form or a Large bear, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
`,
      "Monsters/wereboar.md": `---
smType: creature
name: Wereboar
size: Small
type: Monstrosity
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '15'
initiative: +2 (12)
hp: '97'
hitDice: 15d8 + 30
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 15
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '2'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Common (can't speak in boar form)
cr: '4'
xp: '1100'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The wereboar makes two attacks, using Javelin or Tusk in any combination. It can replace one attack with a Gore attack.
    multiattack:
      attacks:
        - name: two
          count: 1
      substitutions:
        - replace: attack
          with:
            type: attack
            name: a Gore attack
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Gore (Boar or Hybrid Form Only)
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 12 (2d8 + 3) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Wereboar under the DM''s control and has 10 Hit Points. *Success:*  The target is immune to this wereboar''s curse for 24 hours.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d8
          bonus: 3
          type: Piercing
          average: 12
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Cursed
            duration:
              type: hours
              count: 24
      additionalEffects: 'If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Wereboar under the DM''s control and has 10 Hit Points. *Success:*  The target is immune to this wereboar''s curse for 24 hours.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Javelin (Humanoid or Hybrid Form Only)
    entryType: special
    text: '*Melee or Ranged Attack Roll:* +5, reach 5 ft. or range 30/120 ft. 13 (3d6 + 3) Piercing damage.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Tusk (Boar or Hybrid Form Only)
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Piercing damage. If the target is a Medium or smaller creature and the wereboar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 7 (2d6) Piercing damage and has the Prone condition.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d6
          bonus: 3
          type: Piercing
          average: 10
        - dice: 2d6
          bonus: 0
          type: Piercing
          average: 7
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Medium or smaller
      additionalEffects: If the target is a Medium or smaller creature and the wereboar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 7 (2d6) Piercing damage and has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Shape-Shift
    entryType: special
    text: The wereboar shape-shifts into a Medium boar-humanoid hybrid or a Small boar, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Wereboar
*Small, Monstrosity, Neutral Evil*

**AC** 15
**HP** 97 (15d8 + 30)
**Initiative** +2 (12)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common (can't speak in boar form)
CR 4, PB +2, XP 1100

## Actions

**Multiattack**
The wereboar makes two attacks, using Javelin or Tusk in any combination. It can replace one attack with a Gore attack.

**Gore (Boar or Hybrid Form Only)**
*Melee Attack Roll:* +5, reach 5 ft. 12 (2d8 + 3) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Wereboar under the DM's control and has 10 Hit Points. *Success:*  The target is immune to this wereboar's curse for 24 hours.

**Javelin (Humanoid or Hybrid Form Only)**
*Melee or Ranged Attack Roll:* +5, reach 5 ft. or range 30/120 ft. 13 (3d6 + 3) Piercing damage.

**Tusk (Boar or Hybrid Form Only)**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Piercing damage. If the target is a Medium or smaller creature and the wereboar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 7 (2d6) Piercing damage and has the Prone condition.

## Bonus Actions

**Shape-Shift**
The wereboar shape-shifts into a Medium boar-humanoid hybrid or a Small boar, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
`,
      "Monsters/wererat.md": `---
smType: creature
name: Wererat
size: Small
type: Monstrosity
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '13'
initiative: +3 (13)
hp: '60'
hitDice: 11d8 + 11
speeds:
  walk:
    distance: 30 ft.
  climb:
    distance: 30 ft.
abilities:
  - key: str
    score: 10
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 12
    saveProf: false
  - key: int
    score: 11
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '5'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Common (can't speak in rat form)
cr: '2'
xp: '450'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The wererat makes two attacks, using Scratch or Hand Crossbow in any combination. It can replace one attack with a Bite attack.
    multiattack:
      attacks:
        - name: two
          count: 1
      substitutions:
        - replace: attack
          with:
            type: attack
            name: a Bite attack
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite (Rat or Hybrid Form Only)
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 8 (2d4 + 3) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 11. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Wererat under the DM''s control and has 10 Hit Points. *Success:*  The target is immune to this wererat''s curse for 24 hours.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d4
          bonus: 3
          type: Piercing
          average: 8
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Cursed
            duration:
              type: hours
              count: 24
      additionalEffects: 'If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 11. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Wererat under the DM''s control and has 10 Hit Points. *Success:*  The target is immune to this wererat''s curse for 24 hours.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Scratch
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Slashing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d6
          bonus: 3
          type: Slashing
          average: 6
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Hand Crossbow (Humanoid or Hybrid Form Only)
    entryType: attack
    text: '*Ranged Attack Roll:* +5, range 30/120 ft. 6 (1d6 + 3) Piercing damage.'
    attack:
      type: ranged
      bonus: 5
      damage:
        - dice: 1d6
          bonus: 3
          type: Piercing
          average: 6
      range: 30/120 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Shape-Shift
    entryType: special
    text: The wererat shape-shifts into a Medium rat-humanoid hybrid or a Small rat, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Wererat
*Small, Monstrosity, Lawful Evil*

**AC** 13
**HP** 60 (11d8 + 11)
**Initiative** +3 (13)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 14
**Languages** Common (can't speak in rat form)
CR 2, PB +2, XP 450

## Actions

**Multiattack**
The wererat makes two attacks, using Scratch or Hand Crossbow in any combination. It can replace one attack with a Bite attack.

**Bite (Rat or Hybrid Form Only)**
*Melee Attack Roll:* +5, reach 5 ft. 8 (2d4 + 3) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 11. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Wererat under the DM's control and has 10 Hit Points. *Success:*  The target is immune to this wererat's curse for 24 hours.

**Scratch**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Slashing damage.

**Hand Crossbow (Humanoid or Hybrid Form Only)**
*Ranged Attack Roll:* +5, range 30/120 ft. 6 (1d6 + 3) Piercing damage.

## Bonus Actions

**Shape-Shift**
The wererat shape-shifts into a Medium rat-humanoid hybrid or a Small rat, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
`,
      "Monsters/weretiger.md": `---
smType: creature
name: Weretiger
size: Small
type: Monstrosity
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '12'
initiative: +2 (12)
hp: '120'
hitDice: 16d8 + 48
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 15
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 11
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
  - skill: Stealth
    value: '4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '15'
languagesList:
  - value: Common (can't speak in tiger form)
cr: '4'
xp: '1100'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The weretiger makes two attacks, using Scratch or Longbow in any combination. It can replace one attack with a Bite attack.
    multiattack:
      attacks:
        - name: two
          count: 1
      substitutions:
        - replace: attack
          with:
            type: attack
            name: a Bite attack
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite (Tiger or Hybrid Form Only)
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 12 (2d8 + 3) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 13. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Weretiger under the DM''s control and has 10 Hit Points. *Success:*  The target is immune to this weretiger''s curse for 24 hours.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d8
          bonus: 3
          type: Piercing
          average: 12
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Cursed
            duration:
              type: hours
              count: 24
      additionalEffects: 'If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 13. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Weretiger under the DM''s control and has 10 Hit Points. *Success:*  The target is immune to this weretiger''s curse for 24 hours.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Scratch
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d6
          bonus: 3
          type: Slashing
          average: 10
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Longbow (Humanoid or Hybrid Form Only)
    entryType: attack
    text: '*Ranged Attack Roll:* +4, range 150/600 ft. 11 (2d8 + 2) Piercing damage.'
    attack:
      type: ranged
      bonus: 4
      damage:
        - dice: 2d8
          bonus: 2
          type: Piercing
          average: 11
      range: 150/600 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Prowl (Tiger or Hybrid Form Only)
    entryType: special
    text: The weretiger moves up to its Speed without provoking Opportunity Attacks. At the end of this movement, the weretiger can take the Hide action.
    trigger.activation: bonus
    trigger.targeting:
      type: single
  - category: bonus
    name: Shape-Shift
    entryType: special
    text: The weretiger shape-shifts into a Large tiger-humanoid hybrid or a Large tiger, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Weretiger
*Small, Monstrosity, Neutral Neutral*

**AC** 12
**HP** 120 (16d8 + 48)
**Initiative** +2 (12)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 15
**Languages** Common (can't speak in tiger form)
CR 4, PB +2, XP 1100

## Actions

**Multiattack**
The weretiger makes two attacks, using Scratch or Longbow in any combination. It can replace one attack with a Bite attack.

**Bite (Tiger or Hybrid Form Only)**
*Melee Attack Roll:* +5, reach 5 ft. 12 (2d8 + 3) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 13. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Weretiger under the DM's control and has 10 Hit Points. *Success:*  The target is immune to this weretiger's curse for 24 hours.

**Scratch**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage.

**Longbow (Humanoid or Hybrid Form Only)**
*Ranged Attack Roll:* +4, range 150/600 ft. 11 (2d8 + 2) Piercing damage.

## Bonus Actions

**Prowl (Tiger or Hybrid Form Only)**
The weretiger moves up to its Speed without provoking Opportunity Attacks. At the end of this movement, the weretiger can take the Hide action.

**Shape-Shift**
The weretiger shape-shifts into a Large tiger-humanoid hybrid or a Large tiger, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
`,
      "Monsters/werewolf.md": `---
smType: creature
name: Werewolf
size: Small
type: Monstrosity
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '15'
initiative: +4 (14)
hp: '71'
hitDice: 11d8 + 22
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 10
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Common (can't speak in wolf form)
cr: '3'
xp: '700'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The werewolf has Advantage on an attack roll against a creature if at least one of the werewolf's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The werewolf makes two attacks, using Scratch or Longbow in any combination. It can replace one attack with a Bite attack.
    multiattack:
      attacks:
        - name: two
          count: 1
      substitutions:
        - replace: attack
          with:
            type: attack
            name: a Bite attack
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite (Wolf or Hybrid Form Only)
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 12 (2d8 + 3) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Werewolf under the DM''s control and has 10 Hit Points. *Success:*  The target is immune to this werewolf''s curse for 24 hours.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d8
          bonus: 3
          type: Piercing
          average: 12
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Cursed
            duration:
              type: hours
              count: 24
      additionalEffects: 'If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Werewolf under the DM''s control and has 10 Hit Points. *Success:*  The target is immune to this werewolf''s curse for 24 hours.'
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Scratch
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 2d6
          bonus: 3
          type: Slashing
          average: 10
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Longbow (Humanoid or Hybrid Form Only)
    entryType: attack
    text: '*Ranged Attack Roll:* +4, range 150/600 ft. 11 (2d8 + 2) Piercing damage.'
    attack:
      type: ranged
      bonus: 4
      damage:
        - dice: 2d8
          bonus: 2
          type: Piercing
          average: 11
      range: 150/600 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Shape-Shift
    entryType: special
    text: The werewolf shape-shifts into a Large wolf-humanoid hybrid or a Medium wolf, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Werewolf
*Small, Monstrosity, Chaotic Evil*

**AC** 15
**HP** 71 (11d8 + 22)
**Initiative** +4 (14)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 14
**Languages** Common (can't speak in wolf form)
CR 3, PB +2, XP 700

## Traits

**Pack Tactics**
The werewolf has Advantage on an attack roll against a creature if at least one of the werewolf's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Multiattack**
The werewolf makes two attacks, using Scratch or Longbow in any combination. It can replace one attack with a Bite attack.

**Bite (Wolf or Hybrid Form Only)**
*Melee Attack Roll:* +5, reach 5 ft. 12 (2d8 + 3) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Werewolf under the DM's control and has 10 Hit Points. *Success:*  The target is immune to this werewolf's curse for 24 hours.

**Scratch**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage.

**Longbow (Humanoid or Hybrid Form Only)**
*Ranged Attack Roll:* +4, range 150/600 ft. 11 (2d8 + 2) Piercing damage.

## Bonus Actions

**Shape-Shift**
The werewolf shape-shifts into a Large wolf-humanoid hybrid or a Medium wolf, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
`,
      "Monsters/white-dragon-wyrmling.md": `---
smType: creature
name: White Dragon Wyrmling
size: Medium
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '16'
initiative: +2 (12)
hp: '32'
hitDice: 5d8 + 10
speeds:
  walk:
    distance: 30 ft.
  burrow:
    distance: 15 ft.
  fly:
    distance: 60 ft.
  swim:
    distance: 30 ft.
abilities:
  - key: str
    score: 14
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 2
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 5
    saveProf: false
  - key: wis
    score: 10
    saveProf: true
    saveMod: 2
  - key: cha
    score: 11
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
  - skill: Stealth
    value: '2'
sensesList:
  - type: blindsight
    range: '10'
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Draconic
damageImmunitiesList:
  - value: Cold
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Ice Walk
    entryType: special
    text: The dragon can move across and climb icy surfaces without needing to make an ability check. Additionally, Difficult Terrain composed of ice or snow doesn't cost it extra movement.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes two Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 2
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Slashing damage plus 2 (1d4) Cold damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d8
          bonus: 2
          type: Slashing
          average: 6
        - dice: 1d4
          bonus: 0
          type: Cold
          average: 2
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Cold Breath (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 12, each creature in a 15-foot Cone. *Failure:*  22 (5d8) Cold damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: con
      dc: 12
      targeting:
        shape: cone
        size: 15 ft.
      onFail:
        effects:
          other: 22 (5d8) Cold damage.
        damage:
          - dice: 5d8
            bonus: 0
            type: Cold
            average: 22
        legacyEffects: 22 (5d8) Cold damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# White Dragon Wyrmling
*Medium, Dragon, Chaotic Evil*

**AC** 16
**HP** 32 (5d8 + 10)
**Initiative** +2 (12)
**Speed** 30 ft., swim 30 ft., fly 60 ft., burrow 15 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 10 ft., darkvision 60 ft.; Passive Perception 14
**Languages** Draconic
CR 2, PB +2, XP 450

## Traits

**Ice Walk**
The dragon can move across and climb icy surfaces without needing to make an ability check. Additionally, Difficult Terrain composed of ice or snow doesn't cost it extra movement.

## Actions

**Multiattack**
The dragon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Slashing damage plus 2 (1d4) Cold damage.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 12, each creature in a 15-foot Cone. *Failure:*  22 (5d8) Cold damage. *Success:*  Half damage.
`,
      "Monsters/wight.md": `---
smType: creature
name: Wight
size: Medium
type: Undead
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '14'
initiative: +4 (14)
hp: '82'
hitDice: 11d8 + 33
speeds:
  walk:
    distance: 30 ft.
abilities:
  - key: str
    score: 15
    saveProf: false
  - key: dex
    score: 14
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 10
    saveProf: false
  - key: wis
    score: 13
    saveProf: false
  - key: cha
    score: 15
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '3'
  - skill: Stealth
    value: '4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '13'
languagesList:
  - value: Common plus one other language
damageResistancesList:
  - value: Necrotic
damageImmunitiesList:
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Poisoned
cr: '3'
xp: '700'
entries:
  - category: trait
    name: Sunlight Sensitivity
    entryType: special
    text: While in sunlight, the wight has Disadvantage on ability checks and attack rolls.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The wight makes two attacks, using Necrotic Sword or Necrotic Bow in any combination. It can replace one attack with a use of Life Drain.
    multiattack:
      attacks:
        - name: two
          count: 1
      substitutions:
        - replace: attack
          with:
            type: attack
            name: Life Drain
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Necrotic Sword
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Slashing damage plus 4 (1d8) Necrotic damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 1d8
          bonus: 2
          type: Slashing
          average: 6
        - dice: 1d8
          bonus: 0
          type: Necrotic
          average: 4
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Necrotic Bow
    entryType: attack
    text: '*Ranged Attack Roll:* +4, range 150/600 ft. 6 (1d8 + 2) Piercing damage plus 4 (1d8) Necrotic damage.'
    attack:
      type: ranged
      bonus: 4
      damage:
        - dice: 1d8
          bonus: 2
          type: Piercing
          average: 6
        - dice: 1d8
          bonus: 0
          type: Necrotic
          average: 4
      range: 150/600 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Life Drain
    entryType: save
    text: '*Constitution Saving Throw*: DC 13, one creature within 5 feet. *Failure:*  6 (1d8 + 2) Necrotic damage, and the target''s Hit Point maximum decreases by an amount equal to the damage taken. A Humanoid slain by this attack rises 24 hours later as a Zombie under the wight''s control, unless the Humanoid is restored to life or its body is destroyed. The wight can have no more than twelve zombies under its control at a time.'
    save:
      ability: con
      dc: 13
      targeting:
        type: single
        range: 5 ft.
      onFail:
        effects:
          other: 6 (1d8 + 2) Necrotic damage, and the target's Hit Point maximum decreases by an amount equal to the damage taken. A Humanoid slain by this attack rises 24 hours later as a Zombie under the wight's control, unless the Humanoid is restored to life or its body is destroyed. The wight can have no more than twelve zombies under its control at a time.
        damage:
          - dice: 1d8
            bonus: 2
            type: Necrotic
            average: 6
        legacyEffects: 6 (1d8 + 2) Necrotic damage, and the target's Hit Point maximum decreases by an amount equal to the damage taken. A Humanoid slain by this attack rises 24 hours later as a Zombie under the wight's control, unless the Humanoid is restored to life or its body is destroyed. The wight can have no more than twelve zombies under its control at a time.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Wight
*Medium, Undead, Neutral Evil*

**AC** 14
**HP** 82 (11d8 + 33)
**Initiative** +4 (14)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 13
**Languages** Common plus one other language
CR 3, PB +2, XP 700

## Traits

**Sunlight Sensitivity**
While in sunlight, the wight has Disadvantage on ability checks and attack rolls.

## Actions

**Multiattack**
The wight makes two attacks, using Necrotic Sword or Necrotic Bow in any combination. It can replace one attack with a use of Life Drain.

**Necrotic Sword**
*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Slashing damage plus 4 (1d8) Necrotic damage.

**Necrotic Bow**
*Ranged Attack Roll:* +4, range 150/600 ft. 6 (1d8 + 2) Piercing damage plus 4 (1d8) Necrotic damage.

**Life Drain**
*Constitution Saving Throw*: DC 13, one creature within 5 feet. *Failure:*  6 (1d8 + 2) Necrotic damage, and the target's Hit Point maximum decreases by an amount equal to the damage taken. A Humanoid slain by this attack rises 24 hours later as a Zombie under the wight's control, unless the Humanoid is restored to life or its body is destroyed. The wight can have no more than twelve zombies under its control at a time.
`,
      "Monsters/will-o-wisp.md": `---
smType: creature
name: Will-o'-Wisp
size: Small
type: Undead
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '19'
initiative: +9 (19)
hp: '27'
hitDice: 11d4
speeds:
  walk:
    distance: 5 ft.
  fly:
    distance: 50 ft.
    hover: true
abilities:
  - key: str
    score: 1
    saveProf: false
  - key: dex
    score: 28
    saveProf: false
  - key: con
    score: 10
    saveProf: false
  - key: int
    score: 13
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 11
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Common plus one other language
damageResistancesList:
  - value: Acid
  - value: Bludgeoning
  - value: Cold
  - value: Fire
  - value: Necrotic
  - value: Piercing
  - value: Slashing
damageImmunitiesList:
  - value: Lightning
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Grappled
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
  - value: Prone
  - value: Restrained
  - value: Unconscious
cr: '2'
xp: '450'
entries:
  - category: trait
    name: Ephemeral
    entryType: special
    text: The wisp can't wear or carry anything.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Illumination
    entryType: special
    text: The wisp sheds Bright Light in a 20-foot radius and Dim Light for an additional 20 feet.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Incorporeal Movement
    entryType: special
    text: The wisp can move through other creatures and objects as if they were Difficult Terrain. It takes 5 (1d10) Force damage if it ends its turn inside an object.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Shock
    entryType: attack
    text: '*Melee Attack Roll:* +4, reach 5 ft. 11 (2d8 + 2) Lightning damage.'
    attack:
      type: melee
      bonus: 4
      damage:
        - dice: 2d8
          bonus: 2
          type: Lightning
          average: 11
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Consume Life
    entryType: save
    text: '*Constitution Saving Throw*: DC 10, one living creature the wisp can see within 5 feet that has 0 Hit Points. *Failure:*  The target dies, and the wisp regains 10 (3d6) Hit Points.'
    save:
      ability: con
      dc: 10
      targeting:
        type: single
        range: 5 ft.
        restrictions:
          visibility: true
      onFail:
        effects:
          other: The target dies, and the wisp regains 10 (3d6) Hit Points.
        legacyEffects: The target dies, and the wisp regains 10 (3d6) Hit Points.
    trigger.activation: bonus
    trigger.targeting:
      type: single
  - category: bonus
    name: Vanish
    entryType: special
    text: The wisp and its light have the Invisible condition until the wisp's  Concentration ends on this effect, which ends early immediately after the wisp makes an attack roll or uses Consume Life.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Will-o'-Wisp
*Small, Undead, Chaotic Evil*

**AC** 19
**HP** 27 (11d4)
**Initiative** +9 (19)
**Speed** 5 ft., fly 50 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 12
**Languages** Common plus one other language
CR 2, PB +2, XP 450

## Traits

**Ephemeral**
The wisp can't wear or carry anything.

**Illumination**
The wisp sheds Bright Light in a 20-foot radius and Dim Light for an additional 20 feet.

**Incorporeal Movement**
The wisp can move through other creatures and objects as if they were Difficult Terrain. It takes 5 (1d10) Force damage if it ends its turn inside an object.

## Actions

**Shock**
*Melee Attack Roll:* +4, reach 5 ft. 11 (2d8 + 2) Lightning damage.

## Bonus Actions

**Consume Life**
*Constitution Saving Throw*: DC 10, one living creature the wisp can see within 5 feet that has 0 Hit Points. *Failure:*  The target dies, and the wisp regains 10 (3d6) Hit Points.

**Vanish**
The wisp and its light have the Invisible condition until the wisp's  Concentration ends on this effect, which ends early immediately after the wisp makes an attack roll or uses Consume Life.
`,
      "Monsters/winter-wolf.md": `---
smType: creature
name: Winter Wolf
size: Large
type: Monstrosity
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '13'
initiative: +1 (11)
hp: '75'
hitDice: 10d10 + 20
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 14
    saveProf: false
  - key: int
    score: 7
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '5'
  - skill: Stealth
    value: '5'
passivesList:
  - skill: Perception
    value: '15'
languagesList:
  - value: Common
  - value: Giant
damageImmunitiesList:
  - value: Cold
cr: '3'
xp: '700'
entries:
  - category: trait
    name: Pack Tactics
    entryType: special
    text: The wolf has Advantage on an attack roll against a creature if at least one of the wolf's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 11 (2d6 + 4) Piercing damage. If the target is a Large or smaller creature, it has the Prone condition.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 2d6
          bonus: 4
          type: Piercing
          average: 11
      reach: 5 ft.
      onHit:
        conditions:
          - condition: Prone
            restrictions:
              size: Large or smaller
      additionalEffects: If the target is a Large or smaller creature, it has the Prone condition.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Cold Breath (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 12, each creature in a 15-foot Cone. *Failure:*  18 (4d8) Cold damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: con
      dc: 12
      targeting:
        shape: cone
        size: 15 ft.
      onFail:
        effects:
          other: 18 (4d8) Cold damage.
        damage:
          - dice: 4d8
            bonus: 0
            type: Cold
            average: 18
        legacyEffects: 18 (4d8) Cold damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Winter Wolf
*Large, Monstrosity, Neutral Evil*

**AC** 13
**HP** 75 (10d10 + 20)
**Initiative** +1 (11)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Languages** Common, Giant
CR 3, PB +2, XP 700

## Traits

**Pack Tactics**
The wolf has Advantage on an attack roll against a creature if at least one of the wolf's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Bite**
*Melee Attack Roll:* +6, reach 5 ft. 11 (2d6 + 4) Piercing damage. If the target is a Large or smaller creature, it has the Prone condition.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 12, each creature in a 15-foot Cone. *Failure:*  18 (4d8) Cold damage. *Success:*  Half damage.
`,
      "Monsters/worg.md": `---
smType: creature
name: Worg
size: Large
type: Fey
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '13'
initiative: +1 (11)
hp: '26'
hitDice: 4d10 + 4
speeds:
  walk:
    distance: 50 ft.
abilities:
  - key: str
    score: 16
    saveProf: false
  - key: dex
    score: 13
    saveProf: false
  - key: con
    score: 13
    saveProf: false
  - key: int
    score: 7
    saveProf: false
  - key: wis
    score: 11
    saveProf: false
  - key: cha
    score: 8
    saveProf: false
pb: '+2'
skills:
  - skill: Perception
    value: '4'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '14'
languagesList:
  - value: Goblin
  - value: Worg
cr: 1/2
xp: '100'
entries:
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage, and the next attack roll made against the target before the start of the worg''s next turn has Advantage.'
    attack:
      type: melee
      bonus: 5
      damage:
        - dice: 1d8
          bonus: 3
          type: Piercing
          average: 7
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Worg
*Large, Fey, Neutral Evil*

**AC** 13
**HP** 26 (4d10 + 4)
**Initiative** +1 (11)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 14
**Languages** Goblin, Worg
CR 1/2, PB +2, XP 100

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage, and the next attack roll made against the target before the start of the worg's next turn has Advantage.
`,
      "Monsters/wraith.md": `---
smType: creature
name: Wraith
size: Small
type: Undead
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '13'
initiative: +3 (13)
hp: '67'
hitDice: 9d8 + 27
speeds:
  walk:
    distance: 5 ft.
  fly:
    distance: 60 ft.
    hover: true
abilities:
  - key: str
    score: 6
    saveProf: false
  - key: dex
    score: 16
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 14
    saveProf: false
  - key: cha
    score: 15
    saveProf: false
pb: '+3'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '12'
languagesList:
  - value: Common plus two other languages
damageResistancesList:
  - value: Acid
  - value: Bludgeoning
  - value: Cold
  - value: Fire
  - value: Piercing
  - value: Slashing
damageImmunitiesList:
  - value: Necrotic
  - value: Poison; Charmed
  - value: Exhaustion
conditionImmunitiesList:
  - value: Grappled
  - value: Paralyzed
  - value: Petrified
  - value: Poisoned
  - value: Prone
  - value: Restrained
  - value: Unconscious
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Incorporeal Movement
    entryType: special
    text: The wraith can move through other creatures and objects as if they were Difficult Terrain. It takes 5 (1d10) Force damage if it ends its turn inside an object.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Sunlight Sensitivity
    entryType: special
    text: While in sunlight, the wraith has Disadvantage on ability checks and attack rolls.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Life Drain
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 21 (4d8 + 3) Necrotic damage. If the target is a creature, its Hit Point maximum decreases by an amount equal to the damage taken.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 4d8
          bonus: 3
          type: Necrotic
          average: 21
      reach: 5 ft.
      onHit:
        other: If the target is a creature, its Hit Point maximum decreases by an amount equal to the damage taken.
      additionalEffects: If the target is a creature, its Hit Point maximum decreases by an amount equal to the damage taken.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Create Specter
    entryType: special
    text: The wraith targets a Humanoid corpse within 10 feet of itself that has been dead for no longer than 1 minute. The target's spirit rises as a Specter in the space of its corpse or in the nearest unoccupied space. The specter is under the wraith's control. The wraith can have no more than seven specters under its control at a time.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Wraith
*Small, Undead, Neutral Evil*

**AC** 13
**HP** 67 (9d8 + 27)
**Initiative** +3 (13)
**Speed** 5 ft., fly 60 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 12
**Languages** Common plus two other languages
CR 5, PB +3, XP 1800

## Traits

**Incorporeal Movement**
The wraith can move through other creatures and objects as if they were Difficult Terrain. It takes 5 (1d10) Force damage if it ends its turn inside an object.

**Sunlight Sensitivity**
While in sunlight, the wraith has Disadvantage on ability checks and attack rolls.

## Actions

**Life Drain**
*Melee Attack Roll:* +6, reach 5 ft. 21 (4d8 + 3) Necrotic damage. If the target is a creature, its Hit Point maximum decreases by an amount equal to the damage taken.

**Create Specter**
The wraith targets a Humanoid corpse within 10 feet of itself that has been dead for no longer than 1 minute. The target's spirit rises as a Specter in the space of its corpse or in the nearest unoccupied space. The specter is under the wraith's control. The wraith can have no more than seven specters under its control at a time.
`,
      "Monsters/wyvern.md": `---
smType: creature
name: Wyvern
size: Large
type: Dragon
alignmentOverride: Unaligned
ac: '14'
initiative: +0 (10)
hp: '127'
hitDice: 15d10 + 45
speeds:
  walk:
    distance: 30 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 5
    saveProf: false
  - key: wis
    score: 12
    saveProf: false
  - key: cha
    score: 6
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '4'
sensesList:
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '14'
cr: '6'
xp: '2300'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The wyvern makes one Bite attack and one Sting attack.
    multiattack:
      attacks:
        - name: Bite
          count: 1
        - name: Sting
          count: 1
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Piercing damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d8
          bonus: 4
          type: Piercing
          average: 13
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Sting
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Piercing damage plus 24 (7d6) Poison damage, and the target has the Poisoned condition until the start of the wyvern''s next turn.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d6
          bonus: 4
          type: Piercing
          average: 11
        - dice: 7d6
          bonus: 0
          type: Poison
          average: 24
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Wyvern
*Large, Dragon, Unaligned*

**AC** 14
**HP** 127 (15d10 + 45)
**Initiative** +0 (10)
**Speed** 30 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 120 ft.; Passive Perception 14
CR 6, PB +3, XP 2300

## Actions

**Multiattack**
The wyvern makes one Bite attack and one Sting attack.

**Bite**
*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Piercing damage.

**Sting**
*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Piercing damage plus 24 (7d6) Poison damage, and the target has the Poisoned condition until the start of the wyvern's next turn.
`,
      "Monsters/xorn.md": `---
smType: creature
name: Xorn
size: Medium
type: Elemental
alignmentLawChaos: Neutral
alignmentGoodEvil: Neutral
ac: '19'
initiative: +0 (10)
hp: '84'
hitDice: 8d8 + 48
speeds:
  walk:
    distance: 20 ft.
  burrow:
    distance: 20 ft.
abilities:
  - key: str
    score: 17
    saveProf: false
  - key: dex
    score: 10
    saveProf: false
  - key: con
    score: 22
    saveProf: false
  - key: int
    score: 11
    saveProf: false
  - key: wis
    score: 10
    saveProf: false
  - key: cha
    score: 11
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '6'
  - skill: Stealth
    value: '6'
sensesList:
  - type: darkvision
    range: '60'
  - type: tremorsense
    range: '60'
passivesList:
  - skill: Perception
    value: '16'
languagesList:
  - value: Primordial (Terran)
damageImmunitiesList:
  - value: Poison; Paralyzed
conditionImmunitiesList:
  - value: Petrified
  - value: Poisoned
cr: '5'
xp: '1800'
entries:
  - category: trait
    name: Earth Glide
    entryType: special
    text: The xorn can burrow through nonmagical, unworked earth and stone. While doing so, the xorn doesn't disturb the material it moves through.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: trait
    name: Treasure Sense
    entryType: special
    text: The xorn can pinpoint the location of precious metals and stones within 60 feet of itself.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The xorn makes one Bite attack and three Claw attacks.
    multiattack:
      attacks:
        - name: Bite
          count: 1
        - name: Claw
          count: 3
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Bite
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 17 (4d6 + 3) Piercing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 4d6
          bonus: 3
          type: Piercing
          average: 17
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Claw
    entryType: attack
    text: '*Melee Attack Roll:* +6, reach 5 ft. 8 (1d10 + 3) Slashing damage.'
    attack:
      type: melee
      bonus: 6
      damage:
        - dice: 1d10
          bonus: 3
          type: Slashing
          average: 8
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: bonus
    name: Charge
    entryType: special
    text: The xorn moves up to its Speed or Burrow Speed straight toward an enemy it can sense.
    trigger.activation: bonus
    trigger.targeting:
      type: single
---

# Xorn
*Medium, Elemental, Neutral Neutral*

**AC** 19
**HP** 84 (8d8 + 48)
**Initiative** +0 (10)
**Speed** 20 ft., burrow 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft., tremorsense 60 ft.; Passive Perception 16
**Languages** Primordial (Terran)
CR 5, PB +3, XP 1800

## Traits

**Earth Glide**
The xorn can burrow through nonmagical, unworked earth and stone. While doing so, the xorn doesn't disturb the material it moves through.

**Treasure Sense**
The xorn can pinpoint the location of precious metals and stones within 60 feet of itself.

## Actions

**Multiattack**
The xorn makes one Bite attack and three Claw attacks.

**Bite**
*Melee Attack Roll:* +6, reach 5 ft. 17 (4d6 + 3) Piercing damage.

**Claw**
*Melee Attack Roll:* +6, reach 5 ft. 8 (1d10 + 3) Slashing damage.

## Bonus Actions

**Charge**
The xorn moves up to its Speed or Burrow Speed straight toward an enemy it can sense.
`,
      "Monsters/young-black-dragon.md": `---
smType: creature
name: Young Black Dragon
size: Large
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '18'
initiative: +5 (15)
hp: '127'
hitDice: 15d10 + 45
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 80 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 14
    saveProf: true
    saveMod: 5
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 3
  - key: cha
    score: 15
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '6'
  - skill: Stealth
    value: '5'
sensesList:
  - type: blindsight
    range: '30'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '16'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Acid
cr: '7'
xp: '2900'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 10 ft. 9 (2d4 + 4) Slashing damage plus 3 (1d6) Acid damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d4
          bonus: 4
          type: Slashing
          average: 9
        - dice: 1d6
          bonus: 0
          type: Acid
          average: 3
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Acid Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 14, each creature in a 30-foot-long, 5-foot-wide Line. *Failure:*  49 (14d6) Acid damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 14
      targeting:
        shape: line
        size: 30 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 49 (14d6) Acid damage.
        damage:
          - dice: 14d6
            bonus: 0
            type: Acid
            average: 49
        legacyEffects: 49 (14d6) Acid damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Young Black Dragon
*Large, Dragon, Chaotic Evil*

**AC** 18
**HP** 127 (15d10 + 45)
**Initiative** +5 (15)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft., darkvision 120 ft.; Passive Perception 16
**Languages** Common, Draconic
CR 7, PB +3, XP 2900

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +7, reach 10 ft. 9 (2d4 + 4) Slashing damage plus 3 (1d6) Acid damage.

**Acid Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 14, each creature in a 30-foot-long, 5-foot-wide Line. *Failure:*  49 (14d6) Acid damage. *Success:*  Half damage.
`,
      "Monsters/young-blue-dragon.md": `---
smType: creature
name: Young Blue Dragon
size: Large
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '18'
initiative: +4 (14)
hp: '152'
hitDice: 16d10 + 64
speeds:
  walk:
    distance: 40 ft.
  burrow:
    distance: 20 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 21
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 4
  - key: con
    score: 19
    saveProf: false
  - key: int
    score: 14
    saveProf: false
  - key: wis
    score: 13
    saveProf: true
    saveMod: 5
  - key: cha
    score: 17
    saveProf: false
pb: '+4'
skills:
  - skill: Perception
    value: '9'
  - skill: Stealth
    value: '4'
sensesList:
  - type: blindsight
    range: '30'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '19'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Lightning
cr: '9'
xp: '5000'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +9, reach 10 ft. 12 (2d6 + 5) Slashing damage plus 5 (1d10) Lightning damage.'
    attack:
      type: melee
      bonus: 9
      damage:
        - dice: 2d6
          bonus: 5
          type: Slashing
          average: 12
        - dice: 1d10
          bonus: 0
          type: Lightning
          average: 5
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Lightning Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 16, each creature in a 60-foot-long, 5-foot-wide Line. *Failure:*  55 (10d10) Lightning damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 16
      targeting:
        shape: line
        size: 60 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 55 (10d10) Lightning damage.
        damage:
          - dice: 10d10
            bonus: 0
            type: Lightning
            average: 55
        legacyEffects: 55 (10d10) Lightning damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Young Blue Dragon
*Large, Dragon, Lawful Evil*

**AC** 18
**HP** 152 (16d10 + 64)
**Initiative** +4 (14)
**Speed** 40 ft., fly 80 ft., burrow 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft., darkvision 120 ft.; Passive Perception 19
**Languages** Common, Draconic
CR 9, PB +4, XP 5000

## Actions

**Multiattack**
The dragon makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +9, reach 10 ft. 12 (2d6 + 5) Slashing damage plus 5 (1d10) Lightning damage.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 16, each creature in a 60-foot-long, 5-foot-wide Line. *Failure:*  55 (10d10) Lightning damage. *Success:*  Half damage.
`,
      "Monsters/young-brass-dragon.md": `---
smType: creature
name: Young Brass Dragon
size: Large
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Good
ac: '17'
initiative: +3 (13)
hp: '110'
hitDice: 13d10 + 39
speeds:
  walk:
    distance: 40 ft.
  burrow:
    distance: 20 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 3
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 12
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 3
  - key: cha
    score: 15
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '6'
  - skill: Persuasion
    value: '5'
  - skill: Stealth
    value: '3'
sensesList:
  - type: blindsight
    range: '30'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '16'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Fire
cr: '6'
xp: '2300'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace two attacks with a use of Sleep Breath.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 10 ft. 15 (2d10 + 4) Slashing damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d10
          bonus: 4
          type: Slashing
          average: 15
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fire Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 14, each creature in a 40-foot-long, 5-foot-wide Line. *Failure:*  38 (11d6) Fire damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 14
      targeting:
        shape: line
        size: 40 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 38 (11d6) Fire damage.
        damage:
          - dice: 11d6
            bonus: 0
            type: Fire
            average: 38
        legacyEffects: 38 (11d6) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Sleep Breath
    entryType: save
    text: '*Constitution Saving Throw*: DC 14, each creature in a 30-foot Cone. *Failure:*  The target has the Incapacitated condition until the end of its next turn, at which point it repeats the save. *Second Failure* The target has the Unconscious condition for 1 minute. This effect ends for the target if it takes damage or a creature within 5 feet of it takes an action to wake it.'
    save:
      ability: con
      dc: 14
      targeting:
        shape: cone
        size: 30 ft.
      onFail:
        effects:
          conditions:
            - condition: Incapacitated
              duration:
                type: until
                trigger: the end of its next turn
              saveToEnd:
                timing: custom
            - condition: Unconscious
              duration:
                type: until
                trigger: the end of its next turn
              saveToEnd:
                timing: custom
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Young Brass Dragon
*Large, Dragon, Chaotic Good*

**AC** 17
**HP** 110 (13d10 + 39)
**Initiative** +3 (13)
**Speed** 40 ft., fly 80 ft., burrow 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft., darkvision 120 ft.; Passive Perception 16
**Languages** Common, Draconic
CR 6, PB +3, XP 2300

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace two attacks with a use of Sleep Breath.

**Rend**
*Melee Attack Roll:* +7, reach 10 ft. 15 (2d10 + 4) Slashing damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 14, each creature in a 40-foot-long, 5-foot-wide Line. *Failure:*  38 (11d6) Fire damage. *Success:*  Half damage.

**Sleep Breath**
*Constitution Saving Throw*: DC 14, each creature in a 30-foot Cone. *Failure:*  The target has the Incapacitated condition until the end of its next turn, at which point it repeats the save. *Second Failure* The target has the Unconscious condition for 1 minute. This effect ends for the target if it takes damage or a creature within 5 feet of it takes an action to wake it.
`,
      "Monsters/young-bronze-dragon.md": `---
smType: creature
name: Young Bronze Dragon
size: Large
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '17'
initiative: +3 (13)
hp: '142'
hitDice: 15d10 + 60
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 80 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 21
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 3
  - key: con
    score: 19
    saveProf: false
  - key: int
    score: 14
    saveProf: false
  - key: wis
    score: 13
    saveProf: true
    saveMod: 4
  - key: cha
    score: 17
    saveProf: false
pb: '+3'
skills:
  - skill: Insight
    value: '4'
  - skill: Perception
    value: '7'
  - skill: Stealth
    value: '3'
sensesList:
  - type: blindsight
    range: '30'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '17'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Lightning
cr: '8'
xp: '3900'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of Repulsion Breath.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: attack
            name: Repulsion Breath
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +8, reach 10 ft. 16 (2d10 + 5) Slashing damage.'
    attack:
      type: melee
      bonus: 8
      damage:
        - dice: 2d10
          bonus: 5
          type: Slashing
          average: 16
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Lightning Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 15, each creature in a 60-foot-long, 5-foot-wide Line. *Failure:*  49 (9d10) Lightning damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 15
      targeting:
        shape: line
        size: 60 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 49 (9d10) Lightning damage.
        damage:
          - dice: 9d10
            bonus: 0
            type: Lightning
            average: 49
        legacyEffects: 49 (9d10) Lightning damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Repulsion Breath
    entryType: save
    text: '*Strength Saving Throw*: DC 15, each creature in a 30-foot Cone. *Failure:*  The target is pushed up to 40 feet straight away from the dragon and has the Prone condition.'
    save:
      ability: str
      dc: 15
      targeting:
        shape: cone
        size: 30 ft.
      onFail:
        effects:
          conditions:
            - condition: Prone
          movement:
            type: push
            distance: 40 feet
            direction: straight away from the dragon
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Young Bronze Dragon
*Large, Dragon, Lawful Good*

**AC** 17
**HP** 142 (15d10 + 60)
**Initiative** +3 (13)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft., darkvision 120 ft.; Passive Perception 17
**Languages** Common, Draconic
CR 8, PB +3, XP 3900

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Repulsion Breath.

**Rend**
*Melee Attack Roll:* +8, reach 10 ft. 16 (2d10 + 5) Slashing damage.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 15, each creature in a 60-foot-long, 5-foot-wide Line. *Failure:*  49 (9d10) Lightning damage. *Success:*  Half damage.

**Repulsion Breath**
*Strength Saving Throw*: DC 15, each creature in a 30-foot Cone. *Failure:*  The target is pushed up to 40 feet straight away from the dragon and has the Prone condition.
`,
      "Monsters/young-copper-dragon.md": `---
smType: creature
name: Young Copper Dragon
size: Large
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Good
ac: '17'
initiative: +4 (14)
hp: '119'
hitDice: 14d10 + 42
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 40 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 12
    saveProf: true
    saveMod: 4
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 16
    saveProf: false
  - key: wis
    score: 13
    saveProf: true
    saveMod: 4
  - key: cha
    score: 15
    saveProf: false
pb: '+3'
skills:
  - skill: Deception
    value: '5'
  - skill: Perception
    value: '7'
  - skill: Stealth
    value: '4'
sensesList:
  - type: blindsight
    range: '30'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '17'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Acid
cr: '7'
xp: '2900'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of Slowing Breath.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: attack
            name: Slowing Breath
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 10 ft. 15 (2d10 + 4) Slashing damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d10
          bonus: 4
          type: Slashing
          average: 15
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Acid Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 14, each creature in a 40-foot-long, 5-foot-wide Line. *Failure:*  40 (9d8) Acid damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 14
      targeting:
        shape: line
        size: 40 ft.
        width: 5 ft.
      onFail:
        effects:
          other: 40 (9d8) Acid damage.
        damage:
          - dice: 9d8
            bonus: 0
            type: Acid
            average: 40
        legacyEffects: 40 (9d8) Acid damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Slowing Breath
    entryType: save
    text: '*Constitution Saving Throw*: DC 14, each creature in a 30-foot Cone. *Failure:*  The target can''t take Reactions; its Speed is halved; and it can take either an action or a Bonus Action on its turn, not both. This effect lasts until the end of its next turn.'
    save:
      ability: con
      dc: 14
      targeting:
        shape: cone
        size: 30 ft.
      onFail:
        effects:
          mechanical:
            - type: penalty
              modifier: half
              target: Speed
              description: Speed is halved
            - type: other
              target: Reactions
              description: can't take Reactions
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Young Copper Dragon
*Large, Dragon, Chaotic Good*

**AC** 17
**HP** 119 (14d10 + 42)
**Initiative** +4 (14)
**Speed** 40 ft., climb 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft., darkvision 120 ft.; Passive Perception 17
**Languages** Common, Draconic
CR 7, PB +3, XP 2900

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Slowing Breath.

**Rend**
*Melee Attack Roll:* +7, reach 10 ft. 15 (2d10 + 4) Slashing damage.

**Acid Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 14, each creature in a 40-foot-long, 5-foot-wide Line. *Failure:*  40 (9d8) Acid damage. *Success:*  Half damage.

**Slowing Breath**
*Constitution Saving Throw*: DC 14, each creature in a 30-foot Cone. *Failure:*  The target can't take Reactions; its Speed is halved; and it can take either an action or a Bonus Action on its turn, not both. This effect lasts until the end of its next turn.
`,
      "Monsters/young-gold-dragon.md": `---
smType: creature
name: Young Gold Dragon
size: Large
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '18'
initiative: +6 (16)
hp: '178'
hitDice: 17d10 + 85
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 80 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 23
    saveProf: false
  - key: dex
    score: 14
    saveProf: true
    saveMod: 6
  - key: con
    score: 21
    saveProf: false
  - key: int
    score: 16
    saveProf: false
  - key: wis
    score: 13
    saveProf: true
    saveMod: 5
  - key: cha
    score: 20
    saveProf: false
pb: '+4'
skills:
  - skill: Insight
    value: '5'
  - skill: Perception
    value: '9'
  - skill: Persuasion
    value: '9'
  - skill: Stealth
    value: '6'
sensesList:
  - type: blindsight
    range: '30'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '19'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Fire
cr: '10'
xp: '5900'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of Weakening Breath.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: attack
            name: Weakening Breath
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +10, reach 10 ft. 17 (2d10 + 6) Slashing damage.'
    attack:
      type: melee
      bonus: 10
      damage:
        - dice: 2d10
          bonus: 6
          type: Slashing
          average: 17
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fire Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 17, each creature in a 30-foot Cone. *Failure:*  55 (10d10) Fire damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 17
      targeting:
        shape: cone
        size: 30 ft.
      onFail:
        effects:
          other: 55 (10d10) Fire damage.
        damage:
          - dice: 10d10
            bonus: 0
            type: Fire
            average: 55
        legacyEffects: 55 (10d10) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Weakening Breath
    entryType: save
    text: '*Strength Saving Throw*: DC 17, each creature that isn''t currently affected by this breath in a 30-foot Cone. *Failure:*  The target has Disadvantage on Strength-based D20 Test and subtracts 3 (1d6) from its damage rolls. It repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.'
    save:
      ability: str
      dc: 17
      targeting:
        shape: cone
        size: 30 ft.
      onFail:
        effects:
          mechanical:
            - type: disadvantage
              target: Strength-based D20 Test
              description: has Disadvantage on Strength-based D20 Test and
            - type: advantage
              target: Strength-based D20 Test
              description: advantage on Strength-based D20 Test and
            - type: penalty
              modifier: -3
              target: damage rolls
              description: subtracts 3 (1d6) from its damage rolls.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Young Gold Dragon
*Large, Dragon, Lawful Good*

**AC** 18
**HP** 178 (17d10 + 85)
**Initiative** +6 (16)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft., darkvision 120 ft.; Passive Perception 19
**Languages** Common, Draconic
CR 10, PB +4, XP 5900

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Weakening Breath.

**Rend**
*Melee Attack Roll:* +10, reach 10 ft. 17 (2d10 + 6) Slashing damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 17, each creature in a 30-foot Cone. *Failure:*  55 (10d10) Fire damage. *Success:*  Half damage.

**Weakening Breath**
*Strength Saving Throw*: DC 17, each creature that isn't currently affected by this breath in a 30-foot Cone. *Failure:*  The target has Disadvantage on Strength-based D20 Test and subtracts 3 (1d6) from its damage rolls. It repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.
`,
      "Monsters/young-green-dragon.md": `---
smType: creature
name: Young Green Dragon
size: Large
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Lawful
alignmentGoodEvil: Evil
ac: '18'
initiative: +4 (14)
hp: '136'
hitDice: 16d10 + 48
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 80 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 19
    saveProf: false
  - key: dex
    score: 12
    saveProf: true
    saveMod: 4
  - key: con
    score: 17
    saveProf: false
  - key: int
    score: 16
    saveProf: false
  - key: wis
    score: 13
    saveProf: true
    saveMod: 4
  - key: cha
    score: 15
    saveProf: false
pb: '+3'
skills:
  - skill: Deception
    value: '5'
  - skill: Perception
    value: '7'
  - skill: Stealth
    value: '4'
sensesList:
  - type: blindsight
    range: '30'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '17'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Poison; Poisoned
cr: '8'
xp: '3900'
entries:
  - category: trait
    name: Amphibious
    entryType: special
    text: The dragon can breathe air and water.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Slashing damage plus 7 (2d6) Poison damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d6
          bonus: 4
          type: Slashing
          average: 11
        - dice: 2d6
          bonus: 0
          type: Poison
          average: 7
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Poison Breath (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 14, each creature in a 30-foot Cone. *Failure:*  42 (12d6) Poison damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: con
      dc: 14
      targeting:
        shape: cone
        size: 30 ft.
      onFail:
        effects:
          other: 42 (12d6) Poison damage.
        damage:
          - dice: 12d6
            bonus: 0
            type: Poison
            average: 42
        legacyEffects: 42 (12d6) Poison damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Young Green Dragon
*Large, Dragon, Lawful Evil*

**AC** 18
**HP** 136 (16d10 + 48)
**Initiative** +4 (14)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft., darkvision 120 ft.; Passive Perception 17
**Languages** Common, Draconic
CR 8, PB +3, XP 3900

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Slashing damage plus 7 (2d6) Poison damage.

**Poison Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 14, each creature in a 30-foot Cone. *Failure:*  42 (12d6) Poison damage. *Success:*  Half damage.
`,
      "Monsters/young-red-dragon.md": `---
smType: creature
name: Young Red Dragon
size: Large
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '18'
initiative: +4 (14)
hp: '178'
hitDice: 17d10 + 85
speeds:
  walk:
    distance: 40 ft.
  climb:
    distance: 40 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 23
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 4
  - key: con
    score: 21
    saveProf: false
  - key: int
    score: 14
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 4
  - key: cha
    score: 19
    saveProf: false
pb: '+4'
skills:
  - skill: Perception
    value: '8'
  - skill: Stealth
    value: '4'
sensesList:
  - type: blindsight
    range: '30'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '18'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Fire
cr: '10'
xp: '5900'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +10, reach 10 ft. 13 (2d6 + 6) Slashing damage plus 3 (1d6) Fire damage.'
    attack:
      type: melee
      bonus: 10
      damage:
        - dice: 2d6
          bonus: 6
          type: Slashing
          average: 13
        - dice: 1d6
          bonus: 0
          type: Fire
          average: 3
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Fire Breath (Recharge 5-6)
    entryType: save
    text: '*Dexterity Saving Throw*: DC 17, each creature in a 30-foot Cone. *Failure:*  56 (16d6) Fire damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: dex
      dc: 17
      targeting:
        shape: cone
        size: 30 ft.
      onFail:
        effects:
          other: 56 (16d6) Fire damage.
        damage:
          - dice: 16d6
            bonus: 0
            type: Fire
            average: 56
        legacyEffects: 56 (16d6) Fire damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Young Red Dragon
*Large, Dragon, Chaotic Evil*

**AC** 18
**HP** 178 (17d10 + 85)
**Initiative** +4 (14)
**Speed** 40 ft., climb 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft., darkvision 120 ft.; Passive Perception 18
**Languages** Common, Draconic
CR 10, PB +4, XP 5900

## Actions

**Multiattack**
The dragon makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +10, reach 10 ft. 13 (2d6 + 6) Slashing damage plus 3 (1d6) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 17, each creature in a 30-foot Cone. *Failure:*  56 (16d6) Fire damage. *Success:*  Half damage.
`,
      "Monsters/young-silver-dragon.md": `---
smType: creature
name: Young Silver Dragon
size: Large
type: Dragon
typeTags:
  - value: Metallic
alignmentLawChaos: Lawful
alignmentGoodEvil: Good
ac: '18'
initiative: +4 (14)
hp: '168'
hitDice: 16d10 + 80
speeds:
  walk:
    distance: 40 ft.
  fly:
    distance: 80 ft.
abilities:
  - key: str
    score: 23
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 4
  - key: con
    score: 21
    saveProf: false
  - key: int
    score: 14
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 4
  - key: cha
    score: 19
    saveProf: false
pb: '+4'
skills:
  - skill: History
    value: '6'
  - skill: Perception
    value: '8'
  - skill: Stealth
    value: '4'
sensesList:
  - type: blindsight
    range: '30'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '18'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Cold
cr: '9'
xp: '5000'
entries:
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks. It can replace one attack with a use of Paralyzing Breath.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions:
        - replace: attack
          with:
            type: attack
            name: Paralyzing Breath
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +10, reach 10 ft. 15 (2d8 + 6) Slashing damage.'
    attack:
      type: melee
      bonus: 10
      damage:
        - dice: 2d8
          bonus: 6
          type: Slashing
          average: 15
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Cold Breath (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 17, each creature in a 30-foot Cone. *Failure:*  49 (11d8) Cold damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: con
      dc: 17
      targeting:
        shape: cone
        size: 30 ft.
      onFail:
        effects:
          other: 49 (11d8) Cold damage.
        damage:
          - dice: 11d8
            bonus: 0
            type: Cold
            average: 49
        legacyEffects: 49 (11d8) Cold damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Paralyzing Breath
    entryType: save
    text: '*Constitution Saving Throw*: DC 17, each creature in a 30-foot Cone. *First Failure* The target has the Incapacitated condition until the end of its next turn, when it repeats the save. *Second Failure* The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.'
    save:
      ability: con
      dc: 17
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Young Silver Dragon
*Large, Dragon, Lawful Good*

**AC** 18
**HP** 168 (16d10 + 80)
**Initiative** +4 (14)
**Speed** 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft., darkvision 120 ft.; Passive Perception 18
**Languages** Common, Draconic
CR 9, PB +4, XP 5000

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Paralyzing Breath.

**Rend**
*Melee Attack Roll:* +10, reach 10 ft. 15 (2d8 + 6) Slashing damage.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 17, each creature in a 30-foot Cone. *Failure:*  49 (11d8) Cold damage. *Success:*  Half damage.

**Paralyzing Breath**
*Constitution Saving Throw*: DC 17, each creature in a 30-foot Cone. *First Failure* The target has the Incapacitated condition until the end of its next turn, when it repeats the save. *Second Failure* The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.
`,
      "Monsters/young-white-dragon.md": `---
smType: creature
name: Young White Dragon
size: Large
type: Dragon
typeTags:
  - value: Chromatic
alignmentLawChaos: Chaotic
alignmentGoodEvil: Evil
ac: '17'
initiative: +3 (13)
hp: '123'
hitDice: 13d10 + 52
speeds:
  walk:
    distance: 40 ft.
  burrow:
    distance: 20 ft.
  fly:
    distance: 80 ft.
  swim:
    distance: 40 ft.
abilities:
  - key: str
    score: 18
    saveProf: false
  - key: dex
    score: 10
    saveProf: true
    saveMod: 3
  - key: con
    score: 18
    saveProf: false
  - key: int
    score: 6
    saveProf: false
  - key: wis
    score: 11
    saveProf: true
    saveMod: 3
  - key: cha
    score: 12
    saveProf: false
pb: '+3'
skills:
  - skill: Perception
    value: '6'
  - skill: Stealth
    value: '3'
sensesList:
  - type: blindsight
    range: '30'
  - type: darkvision
    range: '120'
passivesList:
  - skill: Perception
    value: '16'
languagesList:
  - value: Common
  - value: Draconic
damageImmunitiesList:
  - value: Cold
cr: '6'
xp: '2300'
entries:
  - category: trait
    name: Ice Walk
    entryType: special
    text: The dragon can move across and climb icy surfaces without needing to make an ability check. Additionally, Difficult Terrain composed of ice or snow doesn't cost it extra movement.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Multiattack
    entryType: multiattack
    text: The dragon makes three Rend attacks.
    multiattack:
      attacks:
        - name: Rend
          count: 3
      substitutions: []
    trigger.activation: action
    trigger.targeting:
      type: self
  - category: action
    name: Rend
    entryType: attack
    text: '*Melee Attack Roll:* +7, reach 10 ft. 9 (2d4 + 4) Slashing damage plus 2 (1d4) Cold damage.'
    attack:
      type: melee
      bonus: 7
      damage:
        - dice: 2d4
          bonus: 4
          type: Slashing
          average: 9
        - dice: 1d4
          bonus: 0
          type: Cold
          average: 2
      reach: 10 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
  - category: action
    name: Cold Breath (Recharge 5-6)
    entryType: save
    text: '*Constitution Saving Throw*: DC 15, each creature in a 30-foot Cone. *Failure:*  40 (9d8) Cold damage. *Success:*  Half damage.'
    recharge: 5-6
    save:
      ability: con
      dc: 15
      targeting:
        shape: cone
        size: 30 ft.
      onFail:
        effects:
          other: 40 (9d8) Cold damage.
        damage:
          - dice: 9d8
            bonus: 0
            type: Cold
            average: 40
        legacyEffects: 40 (9d8) Cold damage.
      onSuccess:
        damage: half
        legacyText: Half damage.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Young White Dragon
*Large, Dragon, Chaotic Evil*

**AC** 17
**HP** 123 (13d10 + 52)
**Initiative** +3 (13)
**Speed** 40 ft., swim 40 ft., fly 80 ft., burrow 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** blindsight 30 ft., darkvision 120 ft.; Passive Perception 16
**Languages** Common, Draconic
CR 6, PB +3, XP 2300

## Traits

**Ice Walk**
The dragon can move across and climb icy surfaces without needing to make an ability check. Additionally, Difficult Terrain composed of ice or snow doesn't cost it extra movement.

## Actions

**Multiattack**
The dragon makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +7, reach 10 ft. 9 (2d4 + 4) Slashing damage plus 2 (1d4) Cold damage.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 15, each creature in a 30-foot Cone. *Failure:*  40 (9d8) Cold damage. *Success:*  Half damage.
`,
      "Monsters/zombie.md": `---
smType: creature
name: Zombie
size: Medium
type: Undead
alignmentLawChaos: Neutral
alignmentGoodEvil: Evil
ac: '8'
initiative: '-2 (8)'
hp: '15'
hitDice: 2d8 + 6
speeds:
  walk:
    distance: 20 ft.
abilities:
  - key: str
    score: 13
    saveProf: false
  - key: dex
    score: 6
    saveProf: false
  - key: con
    score: 16
    saveProf: false
  - key: int
    score: 3
    saveProf: false
  - key: wis
    score: 6
    saveProf: false
  - key: cha
    score: 5
    saveProf: false
pb: '+2'
sensesList:
  - type: darkvision
    range: '60'
passivesList:
  - skill: Perception
    value: '8'
languagesList:
  - value: Understands Common plus one other language but can't speak
damageImmunitiesList:
  - value: Poison; Exhaustion
conditionImmunitiesList:
  - value: Poisoned
cr: 1/4
xp: '50'
entries:
  - category: trait
    name: Undead Fortitude
    entryType: special
    text: If damage reduces the zombie to 0 Hit Points, it makes a Constitution saving throw (DC 5 plus the damage taken) unless the damage is Radiant or from a Critical Hit. On a successful save, the zombie drops to 1 Hit Point instead.
    trigger.activation: passive
    trigger.targeting:
      type: single
  - category: action
    name: Slam
    entryType: attack
    text: '*Melee Attack Roll:* +3, reach 5 ft. 5 (1d8 + 1) Bludgeoning damage.'
    attack:
      type: melee
      bonus: 3
      damage:
        - dice: 1d8
          bonus: 1
          type: Bludgeoning
          average: 5
      reach: 5 ft.
    trigger.activation: action
    trigger.targeting:
      type: single
---

# Zombie
*Medium, Undead, Neutral Evil*

**AC** 8
**HP** 15 (2d8 + 6)
**Initiative** -2 (8)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |

**Senses** darkvision 60 ft.; Passive Perception 8
**Languages** Understands Common plus one other language but can't speak
CR 1/4, PB +2, XP 50

## Traits

**Undead Fortitude**
If damage reduces the zombie to 0 Hit Points, it makes a Constitution saving throw (DC 5 plus the damage taken) unless the damage is Radiant or from a Critical Hit. On a successful save, the zombie drops to 1 Hit Point instead.

## Actions

**Slam**
*Melee Attack Roll:* +3, reach 5 ft. 5 (1d8 + 1) Bludgeoning damage.
`
    };
    PRESET_SPELLS = {
      "Acid-Arrow.md": `---
smType: spell
name: "Acid Arrow"
level: 2
school: "Evocation"
casting_time: "Action"
range: "90 feet"
components: ["V", "S", "M"]
materials: "powdered rhubarb leaf"
duration: "Instantaneous"
classes: ["Wizard"]
save_effect: "Half damage on success"
attack: "ranged spell attack"
damage: "4d4"
damage_type: "Acid"
---

# Acid Arrow
Level 2 Evocation

- Casting Time: Action
- Range: 90 feet
- Components: V, S, M (powdered rhubarb leaf)
- Duration: Instantaneous
- Classes: Wizard
- Attack: ranged spell attack
- Damage: 4d4 Acid

A shimmering green arrow streaks toward a target within range and bursts in a spray of acid. Make a ranged spell attack against the target. On a hit, the target takes 4d4 Acid damage and 2d4 Acid damage at the end of its next turn. On a miss, the arrow splashes the target with acid for half as much of the initial damage only.
`,
      "Acid-Splash.md": `---
smType: spell
name: "Acid Splash"
level: 0
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
damage: "1d6"
damage_type: "Acid"
---

# Acid Splash
Cantrip Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Save: DEX
- Damage: 1d6 Acid

You create an acidic bubble at a point within range, where it explodes in a 5-foot-radius Sphere. Each creature in that Sphere must succeed on a Dexterity saving throw or take 1d6 Acid damage.
`,
      "Aid.md": `---
smType: spell
name: "Aid"
level: 2
school: "Abjuration"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a strip of white cloth"
duration: "8 hours"
classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger"]
---

# Aid
Level 2 Abjuration

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a strip of white cloth)
- Duration: 8 hours
- Classes: Bard, Cleric, Druid, Paladin, Ranger

Choose up to three creatures within range. Each target's Hit Point maximum and current Hit Points increase by 5 for the duration.
`,
      "Alarm.md": `---
smType: spell
name: "Alarm"
level: 1
school: "Abjuration"
casting_time: "1 minute or Ritual"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a bell and silver wire"
duration: "8 hours"
ritual: true
classes: ["Ranger", "Wizard"]
---

# Alarm
Level 1 Abjuration

- Casting Time: 1 minute or Ritual
- Range: 30 feet
- Components: V, S, M (a bell and silver wire)
- Duration: 8 hours
- Ritual: yes
- Classes: Ranger, Wizard

You set an alarm against intrusion. Choose a door, a window, or an area within range that is no larger than a 20-foot Cube. Until the spell ends, an alarm alerts you whenever a creature touches or enters the warded area. When you cast the spell, you can designate creatures that won't set off the alarm. You also choose whether the alarm is audible or mental:

**Audible Alarm.** The alarm produces the sound of a handbell for 10 seconds within 60 feet of the warded area.

**Mental Alarm.** You are alerted by a mental ping if you are within 1 mile of the warded area. This ping awakens you if you're asleep.
`,
      "Alter-Self.md": `---
smType: spell
name: "Alter Self"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Sorcerer", "Wizard"]
---

# Alter Self
Level 2 Transmutation

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Sorcerer, Wizard

You alter your physical form. Choose one of the following options. Its effects last for the duration, during which you can take a Magic action to replace the option you chose with a different one.

**_Aquatic Adaptation._** You sprout gills and grow webs between your fingers. You can breathe underwater and gain a Swim Speed equal to your Speed.

**_Change Appearance._** You alter your appearance. You decide what you look like, including your height, weight, facial features, sound of your voice, hair length, coloration, and other distinguishing characteristics. You can make yourself appear as a member of another species, though none of your statistics change. You can't appear as a creature of a different size, and your basic shape stays the same; if you're bipedal, you can't use this spell to become quadrupedal, for instance. For the duration, you can take a Magic action to change your appearance in this way again.

**_Natural Weapons._** You grow claws (Slashing), fangs (Piercing), horns (Piercing), or hooves (Bludgeoning). When you use your Unarmed Strike to deal damage with that new growth, it deals 1d6 damage of the type in parentheses instead of dealing the normal damage for your Unarmed Strike, and you use your spellcasting ability modifier for the attack and damage rolls rather than using Strength.
`,
      "Animal-Friendship.md": `---
smType: spell
name: "Animal Friendship"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a morsel of food"
duration: "24 hours"
classes: ["Bard", "Druid", "Ranger"]
save_ability: "WIS"
---

# Animal Friendship
Level 1 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a morsel of food)
- Duration: 24 hours
- Classes: Bard, Druid, Ranger
- Save: WIS

Target a Beast that you can see within range. The target must succeed on a Wisdom saving throw or have the Charmed condition for the duration. If you or one of your allies deals damage to the target, the spells ends.
`,
      "Animal-Messenger.md": `---
smType: spell
name: "Animal Messenger"
level: 2
school: "Enchantment"
casting_time: "Action or Ritual"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a morsel of food"
duration: "24 hours"
ritual: true
classes: ["Bard", "Druid", "Ranger"]
save_ability: "CHA"
---

# Animal Messenger
Level 2 Enchantment

- Casting Time: Action or Ritual
- Range: 30 feet
- Components: V, S, M (a morsel of food)
- Duration: 24 hours
- Ritual: yes
- Classes: Bard, Druid, Ranger
- Save: CHA

A Tiny Beast of your choice that you can see within range must succeed on a Charisma saving throw, or it attempts to deliver a message for you (if the target's Challenge Rating isn't 0, it automatically succeeds). You specify a location you have visited and a recipient who matches a general description, such as "a person dressed in the uniform of the town guard" or "a red-haired dwarf wearing a pointed hat." You also communicate a message of up to twenty-five words. The Beast travels for the duration toward the specified location, covering about 25 miles per 24 hours or 50 miles if the Beast can fly.

When the Beast arrives, it delivers your message to the creature that you described, mimicking your communication. If the Beast doesn't reach its destination before the spell ends, the message is lost, and the Beast returns to where you cast the spell.
`,
      "Animal-Shapes.md": `---
smType: spell
name: "Animal Shapes"
level: 8
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "24 hours"
classes: ["Druid"]
---

# Animal Shapes
Level 8 Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: 24 hours
- Classes: Druid

Choose any number of willing creatures that you can see within range. Each target shape-shifts into a Large or smaller Beast of your choice that has a Challenge Rating of 4 or lower. You can choose a different form for each target. On later turns, you can take a Magic action to transform the targets again.

A target's game statistics are replaced by the chosen Beast's statistics, but the target retains its creature type; Hit Points; Hit Point Dice; alignment; ability to communicate; and Intelligence, Wisdom, and Charisma scores. The target's actions are limited by the Beast form's anatomy, and it can't cast spells. The target's equipment melds into the new form, and the target can't use any of that equipment while in that form.

The target gains a number of Temporary Hit Points equal to the Hit Points of the first form into which it shape-shifts. These Temporary Hit Points vanish if any remain when the spell ends. The transformation lasts for the duration or until the target ends it as a Bonus Action.
`,
      "Animate-Dead.md": `---
smType: spell
name: "Animate Dead"
level: 3
school: "Necromancy"
casting_time: "1 minute"
range: "10 feet"
components: ["V", "S", "M"]
materials: "a drop of blood, a piece of flesh, and a pinch of bone dust"
duration: "Instantaneous"
classes: ["Cleric", "Wizard"]
---

# Animate Dead
Level 3 Necromancy

- Casting Time: 1 minute
- Range: 10 feet
- Components: V, S, M (a drop of blood, a piece of flesh, and a pinch of bone dust)
- Duration: Instantaneous
- Classes: Cleric, Wizard

Choose a pile of bones or a corpse of a Medium or Small Humanoid within range. The target becomes an Undead creature: a **Skeleton** if you chose bones or a **Zombie** if you chose a corpse (see "Monsters" for the stat blocks).

On each of your turns, you can take a Bonus Action to mentally command any creature you made with this spell if the creature is within 60 feet of you (if you control multiple creatures, you can command any of them at the same time, issuing the same command to each one). You decide what action the creature will take and where it will move on its next turn, or you can issue a general command, such as to guard a chamber or corridor. If you issue no commands, the creature takes the Dodge action and moves only to avoid harm. Once given an order, the creature continues to follow it until its task is complete.

The creature is under your control for 24 hours, after which it stops obeying any command you've given it. To maintain control of the creature for another 24 hours, you must cast this spell on the creature again before the current 24-hour period ends. This use of the spell reasserts your control over up to four creatures you have animated with this spell rather than animating a new creature.
`,
      "Animate-Objects.md": `---
smType: spell
name: "Animate Objects"
level: 5
school: "Transmutation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
---

# Animate Objects
Level 5 Transmutation

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard

Objects animate at your command. Choose a number of nonmagical objects within range that aren't being worn or carried, aren't fixed to a surface, and aren't Gargantuan. The maximum number of objects is equal to your spellcasting ability modifier; for this number, a Medium or smaller target counts as one object, a Large target counts as two, and a Huge target counts as three.

Each target animates, sprouts legs, and becomes a Construct that uses the **Animated Object** stat block; this creature is under your control until the spell ends or until it is reduced to 0 Hit Points. Each creature you make with this spell is an ally to you and your allies. In combat, it shares your Initiative count and takes its turn immediately after yours.

Until the spell ends, you can take a Bonus Action to mentally command any creature you made with this spell if the creature is within 500 feet of you (if you control multiple creatures, you can command any of them at the same time, issuing the same command to each one). If you issue no commands, the creature takes the Dodge action and moves only to avoid harm. When the creature drops to 0 Hit Points, it reverts to its object form, and any remaining damage carries over to that form.

## At Higher Levels

> #### Animated Object

>

> *Huge or Smaller Construct, Unaligned*

>

> **AC** 15

>

> **HP** 10 (Medium or smaller), 20 (Large), 40 (Huge)

>

> **Speed** 30 ft.

>

> | Attribute | Score | Mod | Save |

> |-----------|-------|-----|------|

> | Str       | 16    | +3  | +3   |

> | Dex       | 10    | +0  | +0   |

> | Con       | 10    | +0  | +0   |

> | Int       | 3     | -4  | -4   |

> | Wis       | 3     | -4  | -4   |

> | Cha       | 1     | -5  | -5   |

>

> **Immunities** Poison, Psychic; Charmed, Exhaustion, Frightened, Paralyzed, Poisoned

>

> **Senses** Blindsight 30 ft.; Passive Perception 6

>

> **Languages** Understands the languages you know

>

> **CR** None (XP 0; PB equals your Proficiency Bonus)

>

> #### Actions

>

> **Slam.** *Melee Attack Roll:* Bonus equals your spell attack modifier, reach 5 ft. *Hit:* Force damage equal to 1d4 + 3 (Medium or smaller), 2d6 + 3 + your spellcasting ability modifier (Large), or 2d12 + 3 + your spellcasting ability modifier (Huge).
`,
      "Antilife-Shell.md": `---
smType: spell
name: "Antilife Shell"
level: 5
school: "Abjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Druid"]
---

# Antilife Shell
Level 5 Abjuration

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Druid

An aura extends from you in a 10-foot Emanation for the duration. The aura prevents creatures other than Constructs and Undead from passing or reaching through it. An affected creature can cast spells or make attacks with Ranged or Reach weapons through the barrier.

If you move so that an affected creature is forced to pass through the barrier, the spell ends.
`,
      "Antimagic-Field.md": `---
smType: spell
name: "Antimagic Field"
level: 8
school: "Abjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "iron filings"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Cleric", "Wizard"]
---

# Antimagic Field
Level 8 Abjuration

- Casting Time: Action
- Range: Self
- Components: V, S, M (iron filings)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Cleric, Wizard

An aura of antimagic surrounds you in 10-foot Emanation. No one can cast spells, take Magic actions, or create other magical effects inside the aura, and those things can't target or otherwise affect anything inside it. Magical properties of magic items don't work inside the aura or on anything inside it.

Areas of effect created by spells or other magic can't extend into the aura, and no one can teleport into or out of it or use planar travel there. Portals close temporarily while in the aura.

Ongoing spells, except those cast by an Artifact or a deity, are suppressed in the area. While an effect is suppressed, it doesn't function, but the time it spends suppressed counts against its duration.

*Dispel Magic* has no effect on the aura, and the auras created by different *Antimagic Field* spells don't nullify each other.
`,
      "Antipathy-Sympathy.md": `---
smType: spell
name: "Antipathy/Sympathy"
level: 8
school: "Enchantment"
casting_time: "1 hour"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a mix of vinegar and honey"
duration: "10 days"
classes: ["Bard", "Druid", "Wizard"]
save_ability: "WIS"
---

# Antipathy/Sympathy
Level 8 Enchantment

- Casting Time: 1 hour
- Range: 60 feet
- Components: V, S, M (a mix of vinegar and honey)
- Duration: 10 days
- Classes: Bard, Druid, Wizard
- Save: WIS

As you cast the spell, choose whether it creates antipathy or sympathy, and target one creature or object that is Huge or smaller. Then specify a kind of creature, such as red dragons, goblins, or vampires. A creature of the chosen kind makes a Wisdom saving throw when it comes within 120 feet of the target. Your choice of antipathy or sympathy determines what happens to a creature when it fails that save:

**Antipathy.** The creature has the Frightened condition. The Frightened creature must use its movement on its turns to get as far away as possible from the target, moving by the safest route.

**Sympathy.** The creature has the Charmed condition. The Charmed creature must use its movement on its turns to get as close as possible to the target, moving by the safest route. If the creature is within 5 feet of the target, the creature can't willingly move away. If the target damages the Charmed creature, that creature can make a

Wisdom saving throw to end the effect, as described below.

**_Ending the Effect._** If the Frightened or Charmed creature ends its turn more than 120 feet away from the target, the creature makes a Wisdom saving throw. On a successful save, the creature is no longer affected by the target. A creature that successfully saves against this effect is immune to it for 1 minute, after which it can be affected again.
`,
      "Arcane-Eye.md": `---
smType: spell
name: "Arcane Eye"
level: 4
school: "Divination"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a bit of bat fur"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Wizard"]
---

# Arcane Eye
Level 4 Divination

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a bit of bat fur)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Wizard

You create an Invisible, invulnerable eye within range that hovers for the duration. You mentally receive visual information from the eye, which can see in every direction. It also has Darkvision with a range of 30 feet.

As a Bonus Action, you can move the eye up to 30 feet in any direction. A solid barrier blocks the eye's movement, but the eye can pass through an opening as small as 1 inch in diameter.
`,
      "Arcane-Hand.md": `---
smType: spell
name: "Arcane Hand"
level: 5
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "an eggshell and a glove"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Sorcerer", "Wizard"]
save_ability: "STR"
save_effect: "Half damage on success"
attack: "melee spell attack"
damage: "5d8"
damage_type: "Force"
---

# Arcane Hand
Level 5 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (an eggshell and a glove)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Sorcerer, Wizard
- Attack: melee spell attack
- Save: STR (Half damage on success)
- Damage: 5d8 Force

You create a Large hand of shimmering magical energy in an unoccupied space that you can see within range. The hand lasts for the duration, and it moves at your command, mimicking the movements of your own hand.

The hand is an object that has AC 20 and Hit Points equal to your Hit Point maximum. If it drops to 0 Hit Points, the spell ends. The hand doesn't occupy its space.

When you cast the spell and as a Bonus Action on your later turns, you can move the hand up to 60 feet and then cause one of the following effects:

**Clenched Fist.** The hand strikes a target within 5 feet of it. Make a melee spell attack. On a hit, the target takes 5d8 Force damage.

**Forceful Hand.** The hand attempts to push a Huge or smaller creature within 5 feet of it. The target must succeed on a Strength saving throw, or the hand pushes the target up to 5 feet plus a number of feet equal to five times your spellcasting ability modifier. The hand moves with the target, remaining within 5 feet of it.

**Grasping Hand.** The hand attempts to grapple a Huge or smaller creature within 5 feet of it. The target must succeed on a Dexterity saving throw, or the target has the Grappled condition, with an escape DC equal to your spell save DC. While the hand grapples the target, you can take a Bonus Action to cause the hand to crush it, dealing Bludgeoning damage to the target equal to 4d6 plus your spellcasting ability modifier.

**Interposing Hand.** The hand grants you Half Cover against attacks and other effects that originate from its space or that pass through it. In addition, its space counts as Difficult Terrain for your enemies.
`,
      "Arcane-Lock.md": `---
smType: spell
name: "Arcane Lock"
level: 2
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "gold dust worth 25+ GP, which the spell consumes"
duration: "Until dispelled"
classes: ["Wizard"]
---

# Arcane Lock
Level 2 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S, M (gold dust worth 25+ GP, which the spell consumes)
- Duration: Until dispelled
- Classes: Wizard

You touch a closed door, window, gate, container, or hatch and magically lock it for the duration. This lock can't be unlocked by any nonmagical means. You and any creatures you designate when you cast the spell can open and close the object despite the lock. You can also set a password that, when spoken within 5 feet of the object, unlocks it for 1 minute.
`,
      "Arcane-Sword.md": `---
smType: spell
name: "Arcane Sword"
level: 7
school: "Evocation"
casting_time: "Action"
range: "90 feet"
components: ["V", "S", "M"]
materials: "a miniature sword worth 250+ GP"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Wizard"]
attack: "melee spell attack"
---

# Arcane Sword
Level 7 Evocation

- Casting Time: Action
- Range: 90 feet
- Components: V, S, M (a miniature sword worth 250+ GP)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Wizard
- Attack: melee spell attack

You create a spectral sword that hovers within range. It lasts for the duration.

When the sword appears, you make a melee spell attack against a target within 5 feet of the sword. On a hit, the target takes Force damage equal to 4d12 plus your spellcasting ability modifier.

On your later turns, you can take a Bonus Action to move the sword up to 30 feet to a spot you can see and repeat the attack against the same target or a different one.
`,
      "Arcanist-s-Magic-Aura.md": `---
smType: spell
name: "Arcanist's Magic Aura"
level: 2
school: "Illusion"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a small square of silk"
duration: "24 hours"
classes: ["Wizard"]
---

# Arcanist's Magic Aura
Level 2 Illusion

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a small square of silk)
- Duration: 24 hours
- Classes: Wizard

With a touch, you place an illusion on a willing creature or an object that isn't being worn or carried. A creature gains the Mask effect below, and an object gains the False Aura effect below. The effect lasts for the duration. If you cast the spell on the same target every day for 30 days, the illusion lasts until dispelled.

**_Mask (Creature)._** Choose a creature type other than the target's actual type. Spells and other magical effects treat the target as if it were a creature of the chosen type.

**_False Aura (Object)._** You change the way the target appears to spells and magical effects that detect magical auras, such as *Detect Magic*. You can make a nonmagical object appear magical, make a magic item appear nonmagical, or change the object's aura so that it appears to belong to a school of magic you choose.
`,
      "Astral-Projection.md": `---
smType: spell
name: "Astral Projection"
level: 9
school: "Necromancy"
casting_time: "1 hour"
range: "10 feet"
components: ["V", "S", "M"]
materials: "for each of the spell's targets, one jacinth worth 1,000+ GP and one silver bar worth 100+ GP, all of which the spell consumes"
duration: "Until dispelled"
classes: ["Cleric", "Warlock", "Wizard"]
---

# Astral Projection
Level 9 Necromancy

- Casting Time: 1 hour
- Range: 10 feet
- Components: V, S, M (for each of the spell's targets, one jacinth worth 1,000+ GP and one silver bar worth 100+ GP, all of which the spell consumes)
- Duration: Until dispelled
- Classes: Cleric, Warlock, Wizard

You and up to eight willing creatures within range project your astral bodies into the Astral Plane (the spell ends instantly if you are already on that plane). Each target's body is left behind in a state of suspended animation; it has the Unconscious condition, doesn't need food or air, and doesn't age.

A target's astral form resembles its body in almost every way, replicating its game statistics and possessions. The principal difference is the addition of a silvery cord that trails from between the shoulder blades of the astral form. The cord fades from view after 1 foot. If the cord is cut\u2014which happens only when an effect states that it does so\u2014the target's body and astral form both die.

A target's astral form can travel through the Astral Plane. The moment an astral form leaves that plane, the target's body and possessions travel along the silver cord, causing the target to re-enter its body on the new plane.

Any damage or other effects that apply to an astral form have no effect on the target's body and vice versa. If a target's body or astral form drops to 0 Hit Points, the spell ends for that target. The spell ends for all the targets if you take a Magic action to dismiss it.

When the spell ends for a target who isn't dead, the target reappears in its body and exits the state of suspended animation.
`,
      "Augury.md": `---
smType: spell
name: "Augury"
level: 2
school: "Divination"
casting_time: "1 minute or Ritual"
range: "Self"
components: ["V", "S", "M"]
materials: "specially marked sticks, bones, cards, or other divinatory tokens worth 25+ GP"
duration: "Instantaneous"
ritual: true
classes: ["Cleric", "Druid", "Wizard"]
---

# Augury
Level 2 Divination

- Casting Time: 1 minute or Ritual
- Range: Self
- Components: V, S, M (specially marked sticks, bones, cards, or other divinatory tokens worth 25+ GP)
- Duration: Instantaneous
- Ritual: yes
- Classes: Cleric, Druid, Wizard

You receive an omen from an otherworldly entity about the results of a course of action that you plan to take within the next 30 minutes. The GM chooses the omen from the Omens table.

Table: Omens

| Omen         | For Results That Will Be \u2026 |

|--------------|----------------------------|

| Weal         | Good                       |

| Woe          | Bad                        |

| Weal and woe | Good and bad               |

| Indifference | Neither good nor bad       |

The spell doesn't account for circumstances, such as other spells, that might change the results.

If you cast the spell more than once before finishing a Long Rest, there is a cumulative 25 percent chance for each casting after the first that you get no answer.
`,
      "Aura-of-Life.md": `---
smType: spell
name: "Aura of Life"
level: 4
school: "Abjuration"
casting_time: "Action"
range: "Self"
components: ["V"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Cleric", "Paladin"]
---

# Aura of Life
Level 4 Abjuration

- Casting Time: Action
- Range: Self
- Components: V
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Cleric, Paladin

An aura radiates from you in a 30-foot Emanation for the duration. While in the aura, you and your allies have Resistance to Necrotic damage, and your Hit Point maximums can't be reduced. If an ally with 0 Hit Points starts its turn in the aura, that ally regains 1 Hit Point.
`,
      "Awaken.md": `---
smType: spell
name: "Awaken"
level: 5
school: "Transmutation"
casting_time: "8 hours"
range: "Touch"
components: ["V", "S", "M"]
materials: "an agate worth 1,000+ GP, which the spell consumes"
duration: "Instantaneous"
classes: ["Bard", "Druid"]
---

# Awaken
Level 5 Transmutation

- Casting Time: 8 hours
- Range: Touch
- Components: V, S, M (an agate worth 1,000+ GP, which the spell consumes)
- Duration: Instantaneous
- Classes: Bard, Druid

You spend the casting time tracing magical pathways within a precious gemstone, and then touch the target. The target must be either a Beast or Plant creature with an Intelligence of 3 or less or a natural plant that isn't a creature. The target gains an Intelligence of 10 and the ability to speak one language you know. If the target is a natural plant, it becomes a Plant creature and gains the ability to move its limbs, roots, vines, creepers, and so forth, and it gains senses similar to a human's. The GM chooses statistics appropriate for the awakened Plant, such as the statistics for the **Awakened Shrub** or **Awakened Tree** in "Monsters."

The awakened target has the Charmed condition for 30 days or until you or your allies deal damage to it. When that condition ends, the awakened creature chooses its attitude toward you.

### B Spells
`,
      "Bane.md": `---
smType: spell
name: "Bane"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a drop of blood"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Cleric", "Warlock"]
save_ability: "CHA"
---

# Bane
Level 1 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a drop of blood)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Cleric, Warlock
- Save: CHA

Up to three creatures of your choice that you can see within range must each make a Charisma saving throw. Whenever a target that fails this save makes an attack roll or a saving throw before the spell ends, the target must subtract 1d4 from the attack roll or save.
`,
      "Banishment.md": `---
smType: spell
name: "Banishment"
level: 4
school: "Abjuration"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a pentacle"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric", "Paladin", "Sorcerer", "Warlock", "Wizard"]
save_ability: "CHA"
---

# Banishment
Level 4 Abjuration

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a pentacle)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric, Paladin, Sorcerer, Warlock, Wizard
- Save: CHA

One creature that you can see within range must succeed on a Charisma saving throw or be transported to a harmless demiplane for the duration. While there, the target has the Incapacitated condition. When the spell ends, the target reappears in the space it left or in the nearest unoccupied space if that space is occupied.

If the target is an Aberration, a Celestial, an Elemental, a Fey, or a Fiend, the target doesn't return if the spell lasts for 1 minute. The target is instead transported to a random location on a plane (GM's choice) associated with its creature type.
`,
      "Barkskin.md": `---
smType: spell
name: "Barkskin"
level: 2
school: "Transmutation"
casting_time: "Bonus Action"
range: "Touch"
duration: "1 hour"
classes: ["Druid", "Ranger"]
---

# Barkskin
Level 2 Transmutation

- Casting Time: Bonus Action
- Range: Touch
- Duration: 1 hour
- Classes: Druid, Ranger

You touch a willing creature. Until the spell ends, the target's skin assumes a bark-like appearance, and the target has an Armor Class of 17 if its AC is lower than that.
`,
      "Beacon-of-Hope.md": `---
smType: spell
name: "Beacon of Hope"
level: 3
school: "Abjuration"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric"]
save_ability: "WIS"
---

# Beacon of Hope
Level 3 Abjuration

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric
- Save: WIS

Choose any number of creatures within range. For the duration, each target has Advantage on Wisdom saving throws and Death Saving Throws and regains the maximum number of Hit Points possible from any healing.
`,
      "Befuddlement.md": `---
smType: spell
name: "Befuddlement"
level: 8
school: "Enchantment"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "a key ring with no keys"
duration: "Instantaneous"
classes: ["Bard", "Druid", "Warlock", "Wizard"]
save_ability: "INT"
save_effect: "Half damage on success"
damage: "10d12"
damage_type: "Psychic"
---

# Befuddlement
Level 8 Enchantment

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (a key ring with no keys)
- Duration: Instantaneous
- Classes: Bard, Druid, Warlock, Wizard
- Save: INT (Half damage on success)
- Damage: 10d12 Psychic

You blast the mind of a creature that you can see within range. The target makes an Intelligence saving throw.

On a failed save, the target takes 10d12 Psychic damage and can't cast spells or take the Magic action. At the end of every 30 days, the target repeats the save, ending the effect on a success. The effect can also be ended by the *Greater Restoration*, *Heal*, or *Wish* spell.

On a successful save, the target takes half as much damage only.
`,
      "Bestow-Curse.md": `---
smType: spell
name: "Bestow Curse"
level: 3
school: "Necromancy"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Cleric", "Wizard"]
save_ability: "WIS"
damage: "1d8"
damage_type: "Necrotic"
---

# Bestow Curse
Level 3 Necromancy

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Cleric, Wizard
- Save: WIS
- Damage: 1d8 Necrotic

You touch a creature, which must succeed on a Wisdom saving throw or become cursed for the duration. Until the curse ends, the target suffers one of the following effects of your choice:

- Choose one ability. The target has Disadvantage on ability checks and saving throws made with that ability.

- The target has Disadvantage on attack rolls against you.

- In combat, the target must succeed on a Wisdom saving throw at the start of each of its turns or be forced to take the Dodge action on that turn.

- If you deal damage to the target with an attack roll or a spell, the target takes an extra 1d8 Necrotic damage.
`,
      "Black-Tentacles.md": `---
smType: spell
name: "Black Tentacles"
level: 4
school: "Conjuration"
casting_time: "Action"
range: "90 feet"
components: ["V", "S", "M"]
materials: "a tentacle"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Wizard"]
save_ability: "STR"
damage: "3d6"
damage_type: "Bludgeoning"
---

# Black Tentacles
Level 4 Conjuration

- Casting Time: Action
- Range: 90 feet
- Components: V, S, M (a tentacle)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Wizard
- Save: STR
- Damage: 3d6 Bludgeoning

Squirming, ebony tentacles fill a 20-foot square on ground that you can see within range. For the duration, these tentacles turn the ground in that area into Difficult Terrain.

Each creature in that area makes a Strength saving throw. On a failed save, it takes 3d6 Bludgeoning damage, and it has the Restrained condition until the spell ends. A creature also makes that save if it enters the area or ends it turn there. A creature makes that save only once per turn.

A Restrained creature can take an action to make a Strength (Athletics) check against your spell save DC, ending the condition on itself on a success.
`,
      "Blade-Barrier.md": `---
smType: spell
name: "Blade Barrier"
level: 6
school: "Evocation"
casting_time: "Action"
range: "90 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Cleric"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "6d10"
damage_type: "Force"
---

# Blade Barrier
Level 6 Evocation

- Casting Time: Action
- Range: 90 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Cleric
- Save: DEX (Half damage on success)
- Damage: 6d10 Force

You create a wall of whirling blades made of magical energy. The wall appears within range and lasts for the duration. You make a straight wall up to 100 feet long, 20 feet high, and 5 feet thick, or a ringed wall up to 60 feet in diameter, 20 feet high, and 5 feet thick. The wall provides Three-Quarters Cover, and its space is Difficult Terrain.

Any creature in the wall's space makes a Dexterity saving throw, taking 6d10 Force damage on a failed save or half as much damage on a successful one. A creature also makes that save if it enters the wall's space or ends it turn there. A creature makes that save only once per turn.
`,
      "Bless.md": `---
smType: spell
name: "Bless"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a Holy Symbol worth 5+ GP"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric", "Paladin"]
---

# Bless
Level 1 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a Holy Symbol worth 5+ GP)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric, Paladin

You bless up to three creatures within range. Whenever a target makes an attack roll or a saving throw before the spell ends, the target adds 1d4 to the attack roll or save.
`,
      "Blight.md": `---
smType: spell
name: "Blight"
level: 4
school: "Necromancy"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Druid", "Sorcerer", "Warlock", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "8d8"
damage_type: "Necrotic"
---

# Blight
Level 4 Necromancy

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Druid, Sorcerer, Warlock, Wizard
- Save: CON (Half damage on success)
- Damage: 8d8 Necrotic

A creature that you can see within range makes a Constitution saving throw, taking 8d8 Necrotic damage on a failed save or half as much damage on a successful one. A Plant creature automatically fails the save.

Alternatively, target a nonmagical plant that isn't a creature, such as a tree or shrub. It doesn't make a save; it simply withers and dies.
`,
      "Blindness-Deafness.md": `---
smType: spell
name: "Blindness/Deafness"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "120 feet"
components: ["V"]
duration: "1 minute"
classes: ["Bard", "Cleric", "Sorcerer", "Wizard"]
save_ability: "CON"
---

# Blindness/Deafness
Level 2 Transmutation

- Casting Time: Action
- Range: 120 feet
- Components: V
- Duration: 1 minute
- Classes: Bard, Cleric, Sorcerer, Wizard
- Save: CON

One creature that you can see within range must succeed on a Constitution saving throw, or it has the Blinded or Deafened condition (your choice) for the duration. At the end of each of its turns, the target repeats the save, ending the spell on itself on a success.
`,
      "Blink.md": `---
smType: spell
name: "Blink"
level: 3
school: "Transmutation"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "1 minute"
classes: ["Sorcerer", "Wizard"]
---

# Blink
Level 3 Transmutation

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: 1 minute
- Classes: Sorcerer, Wizard

Roll 1d6 at the end of each of your turns for the duration. On a roll of 4\u20136, you vanish from your current plane of existence and appear in the Ethereal Plane (the spell ends instantly if you are already on that plane). While on the Ethereal Plane, you can

perceive the plane you left, which is cast in shades of gray, but you can't see anything there more than 60 feet away. You can affect and be affected only by other creatures on the Ethereal Plane, and creatures on the other plane can't perceive you unless they have a special ability that lets them perceive things on the Ethereal Plane.

You return to the other plane at the start of your next turn and when the spell ends if you are on the Ethereal Plane. You return to an unoccupied space of your choice that you can see within 10 feet of the space you left. If no unoccupied space is available within that range, you appear in the nearest unoccupied space.
`,
      "Blur.md": `---
smType: spell
name: "Blur"
level: 2
school: "Illusion"
casting_time: "Action"
range: "Self"
components: ["V"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Sorcerer", "Wizard"]
---

# Blur
Level 2 Illusion

- Casting Time: Action
- Range: Self
- Components: V
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Sorcerer, Wizard

Your body becomes blurred. For the duration, any creature has Disadvantage on attack rolls against you. An attacker is immune to this effect if it perceives you with Blindsight or Truesight.
`,
      "Burning-Hands.md": `---
smType: spell
name: "Burning Hands"
level: 1
school: "Evocation"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "3d6"
damage_type: "Fire"
---

# Burning Hands
Level 1 Evocation

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 3d6 Fire

A thin sheet of flames shoots forth from you. Each creature in a 15-foot Cone makes a Dexterity saving throw, taking 3d6 Fire damage on a failed save or half as much damage on a successful one.

Flammable objects in the Cone that aren't being worn or carried start burning.

## At Higher Levels

### C Spells
`,
      "Call-Lightning.md": `---
smType: spell
name: "Call Lightning"
level: 3
school: "Conjuration"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "3d10"
damage_type: "Lightning"
---

# Call Lightning
Level 3 Conjuration

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid
- Save: DEX (Half damage on success)
- Damage: 3d10 Lightning

A storm cloud appears at a point within range that you can see above yourself. It takes the shape of a Cylinder that is 10 feet tall with a 60-foot radius.

When you cast the spell, choose a point you can see under the cloud. A lightning bolt shoots from the cloud to that point. Each creature within 5 feet of that point makes a Dexterity saving throw, taking 3d10 Lightning damage on a failed save or half as much damage on a successful one.

Until the spell ends, you can take a Magic action to call down lightning in that way again, targeting the same point or a different one.

If you're outdoors in a storm when you cast this spell, the spell gives you control over that storm instead of creating a new one. Under such conditions, the spell's damage increases by 1d10.
`,
      "Calm-Emotions.md": `---
smType: spell
name: "Calm Emotions"
level: 2
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Cleric"]
save_ability: "CHA"
---

# Calm Emotions
Level 2 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Cleric
- Save: CHA

Each Humanoid in a 20-foot-radius Sphere centered on a point you choose within range must succeed on a Charisma saving throw or be affected by one of the following effects (choose for each creature):

- The creature has Immunity to the Charmed and Frightened conditions until the spell ends. If the creature was already Charmed or Frightened, those conditions are suppressed for the duration.

- The creature becomes Indifferent about creatures of your choice that it's Hostile toward. This indifference ends if the target takes damage or witnesses its allies taking damage. When the spell ends, the creature's attitude returns to normal.
`,
      "Chain-Lightning.md": `---
smType: spell
name: "Chain Lightning"
level: 6
school: "Evocation"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "three silver pins"
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "10d8"
damage_type: "Lightning"
---

# Chain Lightning
Level 6 Evocation

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (three silver pins)
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 10d8 Lightning

You launch a lightning bolt toward a target you can see within range. Three bolts then leap from that target to as many as three other targets of your choice, each of which must be within 30 feet of the first target. A target can be a creature or an object and can be targeted by only one of the bolts.

Each target makes a Dexterity saving throw, taking 10d8 Lightning damage on a failed save or half as much damage on a successful one.

*Using a Higher-Level Spell Slot.* One additional bolt leaps from the first target to another target for each spell slot level above 6.
`,
      "Charm-Monster.md": `---
smType: spell
name: "Charm Monster"
level: 4
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "1 hour"
classes: ["Bard", "Druid", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Charm Monster
Level 4 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: 1 hour
- Classes: Bard, Druid, Sorcerer, Warlock, Wizard
- Save: WIS

One creature you can see within range makes a Wisdom saving throw. It does so with Advantage if you or your allies are fighting it. On a failed save, the target has the Charmed condition until the spell ends or until you or your allies damage it. The Charmed creature is Friendly to you. When the spell ends, the target knows it was Charmed by you.
`,
      "Charm-Person.md": `---
smType: spell
name: "Charm Person"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "1 hour"
classes: ["Bard", "Druid", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Charm Person
Level 1 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: 1 hour
- Classes: Bard, Druid, Sorcerer, Warlock, Wizard
- Save: WIS

One Humanoid you can see within range makes a Wisdom saving throw. It does so with Advantage if you or your allies are fighting it. On a failed save, the target has the Charmed condition until the spell ends or until you or your allies damage it. The Charmed creature is Friendly to you. When the spell ends, the target knows it was Charmed by you.
`,
      "Chill-Touch.md": `---
smType: spell
name: "Chill Touch"
level: 0
school: "Necromancy"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Warlock", "Wizard"]
attack: "melee spell attack"
damage: "1d10"
damage_type: "Necrotic"
---

# Chill Touch
Cantrip Necromancy

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Warlock, Wizard
- Attack: melee spell attack
- Damage: 1d10 Necrotic

Channeling the chill of the grave, make a melee spell attack against a target within reach. On a hit, the target takes 1d10 Necrotic damage, and it can't regain Hit Points until the end of your next turn.
`,
      "Chromatic-Orb.md": `---
smType: spell
name: "Chromatic Orb"
level: 1
school: "Evocation"
casting_time: "Action"
range: "90 feet"
components: ["V", "S", "M"]
materials: "a diamond worth 50+ GP"
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
attack: "ranged spell attack"
---

# Chromatic Orb
Level 1 Evocation

- Casting Time: Action
- Range: 90 feet
- Components: V, S, M (a diamond worth 50+ GP)
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Attack: ranged spell attack

You hurl an orb of energy at a target within range. Choose Acid, Cold, Fire, Lightning, Poison, or Thunder for the type of orb you create, and then make a ranged spell attack against the target. On a hit, the target takes 3d8 damage of the chosen type.

If you roll the same number on two or more of the d8s, the orb leaps to a different target of your choice within 30 feet of the target. Make an attack roll against the new target, and make a new damage roll. The orb can't leap again unless you cast the spell with a level 2+ spell slot.
`,
      "Circle-of-Death.md": `---
smType: spell
name: "Circle of Death"
level: 6
school: "Necromancy"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "the powder of a crushed black pearl worth 500+ GP"
duration: "Instantaneous"
classes: ["Sorcerer", "Warlock", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "8d8"
damage_type: "Necrotic"
---

# Circle of Death
Level 6 Necromancy

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (the powder of a crushed black pearl worth 500+ GP)
- Duration: Instantaneous
- Classes: Sorcerer, Warlock, Wizard
- Save: CON (Half damage on success)
- Damage: 8d8 Necrotic

Negative energy ripples out in a 60-foot-radius Sphere from a point you choose within range. Each creature in that area makes a Constitution saving throw, taking 8d8 Necrotic damage on a failed save or half as much damage on a successful one.
`,
      "Clairvoyance.md": `---
smType: spell
name: "Clairvoyance"
level: 3
school: "Divination"
casting_time: "10 minutes"
range: "1 mile"
components: ["V", "S", "M"]
materials: "a focus worth 100+ GP, either a jeweled horn for hearing or a glass eye for seeing"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Bard", "Cleric", "Sorcerer", "Wizard"]
---

# Clairvoyance
Level 3 Divination

- Casting Time: 10 minutes
- Range: 1 mile
- Components: V, S, M (a focus worth 100+ GP, either a jeweled horn for hearing or a glass eye for seeing)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Bard, Cleric, Sorcerer, Wizard

You create an Invisible sensor within range in a location familiar to you (a place you have visited or seen before) or in an obvious location that is unfamiliar to you (such as behind a door, around a corner, or in a grove of trees). The intangible, invulnerable sensor remains in place for the duration.

When you cast the spell, choose seeing or hearing. You can use the chosen sense through the sensor as if you were in its space. As a Bonus Action, you can switch between seeing and hearing.

A creature that sees the sensor (such as a creature benefiting from *See Invisibility* or Truesight) sees a luminous orb about the size of your fist.
`,
      "Clone.md": `---
smType: spell
name: "Clone"
level: 8
school: "Necromancy"
casting_time: "1 hour"
range: "Touch"
components: ["V", "S", "M"]
materials: "a diamond worth 1,000+ GP, which the spell consumes, and a sealable vessel worth 2,000+ GP that is large enough to hold the creature being cloned"
duration: "Instantaneous"
classes: ["Wizard"]
---

# Clone
Level 8 Necromancy

- Casting Time: 1 hour
- Range: Touch
- Components: V, S, M (a diamond worth 1,000+ GP, which the spell consumes, and a sealable vessel worth 2,000+ GP that is large enough to hold the creature being cloned)
- Duration: Instantaneous
- Classes: Wizard

You touch a creature or at least 1 cubic inch of its flesh. An inert duplicate of that creature forms inside the vessel used in the spell's casting and finishes growing after 120 days; you choose whether the finished clone is the same age as the creature or younger. The clone remains inert and endures indefinitely while its vessel remains undisturbed.

If the original creature dies after the clone finishes forming, the creature's soul transfers to the clone if the soul is free and willing to return. The clone is physically identical to the original and has the same personality, memories, and abilities, but none of the original's equipment. The creature's original remains, if any, become inert and can't be revived, since the creature's soul is elsewhere.
`,
      "Cloudkill.md": `---
smType: spell
name: "Cloudkill"
level: 5
school: "Conjuration"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Sorcerer", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "5d8"
damage_type: "Poison"
---

# Cloudkill
Level 5 Conjuration

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Sorcerer, Wizard
- Save: CON (Half damage on success)
- Damage: 5d8 Poison

You create a 20-foot-radius Sphere of yellow-green fog centered on a point within range. The fog lasts for the duration or until strong wind (such as the one created by *Gust of Wind*) disperses it, ending the spell. Its area is Heavily Obscured.

Each creature in the Sphere makes a Constitution saving throw, taking 5d8 Poison damage on a failed save or half as much damage on a successful one. A creature must also make this save when the Sphere moves into its space and when it enters the Sphere or ends its turn there. A creature makes this save only once per turn.

The Sphere moves 10 feet away from you at the start of each of your turns.
`,
      "Color-Spray.md": `---
smType: spell
name: "Color Spray"
level: 1
school: "Illusion"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a pinch of colorful sand"
duration: "Instantaneous"
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "CON"
---

# Color Spray
Level 1 Illusion

- Casting Time: Action
- Range: Self
- Components: V, S, M (a pinch of colorful sand)
- Duration: Instantaneous
- Classes: Bard, Sorcerer, Wizard
- Save: CON

You launch a dazzling array of flashing, colorful light. Each creature in a 15-foot Cone originating from you must succeed on a Constitution saving throw or have the Blinded condition until the end of your next turn.
`,
      "Command.md": `---
smType: spell
name: "Command"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Paladin"]
save_ability: "WIS"
---

# Command
Level 1 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V
- Duration: Instantaneous
- Classes: Bard, Cleric, Paladin
- Save: WIS

You speak a one-word command to a creature you can see within range. The target must succeed on a Wisdom saving throw or follow the command on its next turn. Choose the command from these options:

**Approach.** The target moves toward you by the shortest and most direct route, ending its turn if it moves within 5 feet of you.

**Drop.** The target drops whatever it is holding and then ends its turn.

**Flee.** The target spends its turn moving away from you by the fastest available means.

**Grovel.** The target has the Prone condition and then ends its turn.

**Halt.** On its turn, the target doesn't move and takes no action or Bonus Action.
`,
      "Commune-with-Nature.md": `---
smType: spell
name: "Commune with Nature"
level: 5
school: "Divination"
casting_time: "1 minute or Ritual"
range: "Self"
components: ["V", "S"]
duration: "Instantaneous"
ritual: true
classes: ["Druid", "Ranger"]
---

# Commune with Nature
Level 5 Divination

- Casting Time: 1 minute or Ritual
- Range: Self
- Components: V, S
- Duration: Instantaneous
- Ritual: yes
- Classes: Druid, Ranger

You commune with nature spirits and gain knowledge of the surrounding area. In the outdoors, the spell gives you knowledge of the area within 3 miles of you. In caves and other natural underground settings, the radius is limited to 300 feet. The spell

doesn't function where nature has been replaced by construction, such as in castles and settlements.

Choose three of the following facts; you learn those facts as they pertain to the spell's area:

- Locations of settlements

- Locations of portals to other planes of existence

- Location of one Challenge Rating 10+ creature (GM's choice) that is a Celestial, an Elemental, a Fey, a Fiend, or an Undead

- The most prevalent kind of plant, mineral, or Beast (you choose which to learn)

- Locations of bodies of water

For example, you could determine the location of a powerful monster in the area, the locations of bodies of water, and the locations of any towns.
`,
      "Commune.md": `---
smType: spell
name: "Commune"
level: 5
school: "Divination"
casting_time: "1 minute or Ritual"
range: "Self"
components: ["V", "S", "M"]
materials: "incense"
duration: "1 minute"
ritual: true
classes: ["Cleric"]
---

# Commune
Level 5 Divination

- Casting Time: 1 minute or Ritual
- Range: Self
- Components: V, S, M (incense)
- Duration: 1 minute
- Ritual: yes
- Classes: Cleric

You contact a deity or a divine proxy and ask up to three questions that can be answered with yes or no. You must ask your questions before the spell ends. You receive a correct answer for each question.

Divine beings aren't necessarily omniscient, so you might receive "unclear" as an answer if a question pertains to information that lies beyond the deity's knowledge. In a case where a one-word answer could be misleading or contrary to the deity's interests, the GM might offer a short phrase as an answer instead.

If you cast the spell more than once before finishing a Long Rest, there is a cumulative 25 percent chance for each casting after the first that you get no answer.
`,
      "Comprehend-Languages.md": `---
smType: spell
name: "Comprehend Languages"
level: 1
school: "Divination"
casting_time: "Action or Ritual"
range: "Self"
components: ["V", "S", "M"]
materials: "a pinch of soot and salt"
duration: "1 hour"
ritual: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# Comprehend Languages
Level 1 Divination

- Casting Time: Action or Ritual
- Range: Self
- Components: V, S, M (a pinch of soot and salt)
- Duration: 1 hour
- Ritual: yes
- Classes: Bard, Sorcerer, Warlock, Wizard

For the duration, you understand the literal meaning of any language that you hear or see signed. You also understand any written language that you see, but you must be touching the surface on which the words are written. It takes about 1 minute to read one page of text. This spell doesn't decode symbols or secret messages.
`,
      "Compulsion.md": `---
smType: spell
name: "Compulsion"
level: 4
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard"]
save_ability: "WIS"
---

# Compulsion
Level 4 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard
- Save: WIS

Each creature of your choice that you can see within range must succeed on a Wisdom saving throw or have the Charmed condition until the spell ends.

For the duration, you can take a Bonus Action to designate a direction that is horizontal to you. Each Charmed target must use as much of its movement as possible to move in that direction on its next turn, taking the safest route. After moving in this way, a target repeats the save, ending the spell on itself on a success.
`,
      "Cone-of-Cold.md": `---
smType: spell
name: "Cone of Cold"
level: 5
school: "Evocation"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a small crystal or glass cone"
duration: "Instantaneous"
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "8d8"
damage_type: "Cold"
---

# Cone of Cold
Level 5 Evocation

- Casting Time: Action
- Range: Self
- Components: V, S, M (a small crystal or glass cone)
- Duration: Instantaneous
- Classes: Druid, Sorcerer, Wizard
- Save: CON (Half damage on success)
- Damage: 8d8 Cold

You unleash a blast of cold air. Each creature in a 60-foot Cone originating from you makes a

Constitution saving throw, taking 8d8 Cold damage on a failed save or half as much damage on a successful one. A creature killed by this spell becomes a frozen statue until it thaws.
`,
      "Confusion.md": `---
smType: spell
name: "Confusion"
level: 4
school: "Enchantment"
casting_time: "Action"
range: "90 feet"
components: ["V", "S", "M"]
materials: "three nut shells"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Druid", "Sorcerer", "Wizard"]
save_ability: "WIS"
---

# Confusion
Level 4 Enchantment

- Casting Time: Action
- Range: 90 feet
- Components: V, S, M (three nut shells)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Druid, Sorcerer, Wizard
- Save: WIS

Each creature in a 10-foot-radius Sphere centered on a point you choose within range must succeed on a Wisdom saving throw, or that target can't take Bonus Actions or Reactions and must roll 1d10 at the start of each of its turns to determine its behavior for that turn, consulting the table below.

Table: 1d10 Behavior for the Turn**

| d10  | Behavior for the Turn                                                                                                                        |

|------|----------------------------------------------------------------------------------------------------------------------------------------------|

| 1    | The target doesn't take an action, and it uses all its movement to move. Roll 1d4 for the direction: 1, north; 2, east; 3, south; or 4, west.|

| 2\u20136  | The target doesn't move or take actions.                                                                                                     |

| 7\u20138  | The target doesn't move, and it takes the Attack action to make one melee attack against a random creature within reach. If none are within reach, the target takes no action. |

| 9\u201310 | The target chooses its behavior.                                                                                                             |

At the end of each of its turns, an affected target repeats the save, ending the spell on itself on a success.
`,
      "Conjure-Animals.md": `---
smType: spell
name: "Conjure Animals"
level: 3
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid", "Ranger"]
save_ability: "STR"
damage: "3d10"
damage_type: "Slashing"
---

# Conjure Animals
Level 3 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid, Ranger
- Save: STR
- Damage: 3d10 Slashing

You conjure nature spirits that appear as a Large pack of spectral, intangible animals in an unoccupied space you can see within range. The pack lasts for the duration, and you choose the spirits' animal form, such as wolves, serpents, or birds.

You have Advantage on Strength saving throws while you're within 5 feet of the pack, and when you move on your turn, you can also move the pack up to 30 feet to an unoccupied space you can see.

Whenever the pack moves within 10 feet of a creature you can see and whenever a creature you can see enters a space within 10 feet of the pack or ends its turn there, you can force that creature to make a Dexterity saving throw. On a failed save, the creature takes 3d10 Slashing damage. A creature makes this save only once per turn.
`,
      "Conjure-Celestial.md": `---
smType: spell
name: "Conjure Celestial"
level: 7
school: "Conjuration"
casting_time: "Action"
range: "90 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Cleric"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "6d12"
damage_type: "Radiant"
---

# Conjure Celestial
Level 7 Conjuration

- Casting Time: Action
- Range: 90 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Cleric
- Save: DEX (Half damage on success)
- Damage: 6d12 Radiant

You conjure a spirit from the Upper Planes, which manifests as a pillar of light in a 10-foot-radius, 40-foot-high Cylinder centered on a point within range. For each creature you can see in the Cylinder, choose which of these lights shines on it:

**Healing Light.** The target regains Hit Points equal to 4d12 plus your spellcasting ability modifier.

**Searing Light.** The target makes a Dexterity saving throw, taking 6d12 Radiant damage on a failed save or half as much damage on a successful one.

Until the spell ends, Bright Light fills the Cylinder, and when you move on your turn, you can also move the Cylinder up to 30 feet.

Whenever the Cylinder moves into the space of a creature you can see and whenever a creature you can see enters the Cylinder or ends its turn there, you can bathe it in one of the lights. A creature can be affected by this spell only once per turn.
`,
      "Conjure-Elemental.md": `---
smType: spell
name: "Conjure Elemental"
level: 5
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid", "Wizard"]
save_ability: "DEX"
---

# Conjure Elemental
Level 5 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid, Wizard
- Save: DEX

You conjure a Large, intangible spirit from the Elemental Planes that appears in an unoccupied space within range. Choose the spirit's element, which determines its damage type: air (Lightning), earth (Thunder), fire (Fire), or water (Cold). The spirit lasts for the duration.

Whenever a creature you can see enters the spirit's space or starts its turn within 5 feet of the spirit, you can force that creature to make a Dexterity saving throw if the spirit has no creature Restrained. On failed save, the target takes 8d8 damage of the spirit's type, and the target has the Restrained condition until the spell ends. At the start of each of its turns, the Restrained target repeats the save.

On a failed save, the target takes 4d8 damage of the spirit's type. On a successful save, the target isn't Restrained by the spirit.
`,
      "Conjure-Fey.md": `---
smType: spell
name: "Conjure Fey"
level: 6
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid"]
attack: "melee spell attack"
---

# Conjure Fey
Level 6 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid
- Attack: melee spell attack

You conjure a Medium spirit from the Feywild in an unoccupied space you can see within range. The spirit lasts for the duration, and it looks like a Fey creature of your choice. When the spirit appears, you can make one melee spell attack against a creature within 5 feet of it. On a hit, the target takes Psychic damage equal to 3d12 plus your spellcasting ability modifier, and the target has the Frightened condition until the start of your next turn, with both you and the spirit as the source of the fear.

As a Bonus Action on your later turns, you can teleport the spirit to an unoccupied space you can see within 30 feet of the space it left and make the attack against a creature within 5 feet of it.
`,
      "Conjure-Minor-Elementals.md": `---
smType: spell
name: "Conjure Minor Elementals"
level: 4
school: "Conjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid", "Wizard"]
---

# Conjure Minor Elementals
Level 4 Conjuration

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid, Wizard

You conjure spirits from the Elemental Planes that flit around you in a 15-foot Emanation for the duration. Until the spell ends, any attack you make deals an extra 2d8 damage when you hit a creature in the Emanation. This damage is Acid, Cold, Fire, or Lightning (your choice when you make the attack).

In addition, the ground in the Emanation is Difficult Terrain for your enemies.
`,
      "Conjure-Woodland-Beings.md": `---
smType: spell
name: "Conjure Woodland Beings"
level: 4
school: "Conjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid", "Ranger"]
save_ability: "WIS"
save_effect: "Half damage on success"
damage: "5d8"
damage_type: "Force"
---

# Conjure Woodland Beings
Level 4 Conjuration

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid, Ranger
- Save: WIS (Half damage on success)
- Damage: 5d8 Force

You conjure nature spirits that flit around you in a 10-foot Emanation for the duration. Whenever the Emanation enters the space of a creature you can

see and whenever a creature you can see enters the Emanation or ends its turn there, you can force that creature to make a Wisdom saving throw. The creature takes 5d8 Force damage on a failed save or half as much damage on a successful one. A creature makes this save only once per turn.

In addition, you can take the Disengage action as a Bonus Action for the spell's duration.
`,
      "Contact-Other-Plane.md": `---
smType: spell
name: "Contact Other Plane"
level: 5
school: "Divination"
casting_time: "1 minute or Ritual"
range: "Self"
components: ["V"]
duration: "1 minute"
ritual: true
classes: ["Warlock", "Wizard"]
save_ability: "INT"
damage: "6d6"
damage_type: "Psychic"
---

# Contact Other Plane
Level 5 Divination

- Casting Time: 1 minute or Ritual
- Range: Self
- Components: V
- Duration: 1 minute
- Ritual: yes
- Classes: Warlock, Wizard
- Save: INT
- Damage: 6d6 Psychic

You mentally contact a demigod, the spirit of a longdead sage, or some other knowledgeable entity from another plane. Contacting this otherworldly intelligence can break your mind. When you cast this spell, make a DC 15 Intelligence saving throw. On a successful save, you can ask the entity up to five questions. You must ask your questions before the spell ends. The GM answers each question with one word, such as "yes," "no," "maybe," "never," "irrelevant," or "unclear" (if the entity doesn't know the answer to the question). If a one-word answer would be misleading, the GM might instead offer a short phrase as an answer.

On a failed save, you take 6d6 Psychic damage and have the Incapacitated condition until you finish a Long Rest. A *Greater Restoration* spell cast on you ends this effect.
`,
      "Contagion.md": `---
smType: spell
name: "Contagion"
level: 5
school: "Necromancy"
casting_time: "Action"
range: "Touch"
duration: "7 days"
classes: ["Cleric", "Druid"]
save_ability: "CON"
damage: "11d8"
damage_type: "Necrotic"
---

# Contagion
Level 5 Necromancy

- Casting Time: Action
- Range: Touch
- Duration: 7 days
- Classes: Cleric, Druid
- Save: CON
- Damage: 11d8 Necrotic

Your touch inflicts a magical contagion. The target must succeed on a Constitution saving throw or take 11d8 Necrotic damage and have the Poisoned condition. Also, choose one ability when you cast the spell. While Poisoned, the target has Disadvantage on saving throws made with the chosen ability.

The target must repeat the saving throw at the end of each of its turns until it gets three successes or failures. If the target succeeds on three of these saves, the spell ends on the target. If the target fails three of the saves, the spell lasts for 7 days on it.

Whenever the Poisoned target receives an effect that would end the Poisoned condition, the target must succeed on a Constitution saving throw, or the Poisoned condition doesn't end on it.
`,
      "Contingency.md": `---
smType: spell
name: "Contingency"
level: 6
school: "Abjuration"
casting_time: "10 minutes"
range: "Self"
components: ["V", "S", "M"]
materials: "a gem-encrusted statuette of yourself worth 1,500+ GP"
duration: "10 days"
classes: ["Wizard"]
---

# Contingency
Level 6 Abjuration

- Casting Time: 10 minutes
- Range: Self
- Components: V, S, M (a gem-encrusted statuette of yourself worth 1,500+ GP)
- Duration: 10 days
- Classes: Wizard

Choose a spell of level 5 or lower that you can cast, that has a casting time of an action, and that can target you. You cast that spell\u2014called the contingent spell\u2014as part of casting *Contingency*, expending spell slots for both, but the contingent spell doesn't come into effect. Instead, it takes effect when a certain trigger occurs. You describe that trigger when you cast the two spells. For example, a *Contingency* cast with *Water Breathing* might stipulate that *Water Breathing* comes into effect when you are engulfed in water or a similar liquid.

The contingent spell takes effect immediately after the trigger occurs for the first time, whether or not you want it to, and then *Contingency* ends.

The contingent spell takes effect only on you, even if it can normally target others. You can use only one *Contingency* spell at a time. If you cast this spell again, the effect of another *Contingency* spell on you ends. Also, *Contingency* ends on you if its material component is ever not on your person.
`,
      "Continual-Flame.md": `---
smType: spell
name: "Continual Flame"
level: 2
school: "Evocation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "ruby dust worth 50+ GP, which the spell consumes"
duration: "Until dispelled"
classes: ["Cleric", "Druid", "Wizard"]
---

# Continual Flame
Level 2 Evocation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (ruby dust worth 50+ GP, which the spell consumes)
- Duration: Until dispelled
- Classes: Cleric, Druid, Wizard

A flame springs from an object that you touch. The effect casts Bright Light in a 20-foot radius and Dim Light for an additional 20 feet. It looks like a regular flame, but it creates no heat and consumes no fuel. The flame can be covered or hidden but not smothered or quenched.
`,
      "Control-Water.md": `---
smType: spell
name: "Control Water"
level: 4
school: "Transmutation"
casting_time: "Action"
range: "300 feet"
components: ["V", "S", "M"]
materials: "a mixture of water and dust"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Cleric", "Druid", "Wizard"]
save_ability: "STR"
save_effect: "Half damage on success"
damage: "2d8"
damage_type: "Bludgeoning"
---

# Control Water
Level 4 Transmutation

- Casting Time: Action
- Range: 300 feet
- Components: V, S, M (a mixture of water and dust)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Cleric, Druid, Wizard
- Save: STR (Half damage on success)
- Damage: 2d8 Bludgeoning

Until the spell ends, you control any water inside an area you choose that is a Cube up to 100 feet on a side, using one of the following effects. As a Magic action on your later turns, you can repeat the same effect or choose a different one.

**_Flood._** You cause the water level of all standing water in the area to rise by as much as 20 feet. If you choose an area in a large body of water, you instead create a 20-foot tall wave that travels from one side of the area to the other and then crashes. Any Huge or smaller vehicles in the wave's path are carried with it to the other side. Any Huge or smaller vehicles struck by the wave have a 25 percent chance of capsizing.

The water level remains elevated until the spell ends or you choose a different effect. If this effect produced a wave, the wave repeats on the start of your next turn while the flood effect lasts.

**_Part Water._** You part water in the area and create a trench. The trench extends across the spell's area, and the separated water forms a wall to either side. The trench remains until the spell ends or you choose a different effect. The water then slowly fills in the trench over the course of the next round until the normal water level is restored.

**_Redirect Flow._** You cause flowing water in the area to move in a direction you choose, even if the water has to flow over obstacles, up walls, or in other unlikely directions. The water in the area moves as you direct it, but once it moves beyond the spell's area, it resumes its flow based on the terrain. The water continues to move in the direction you chose until the spell ends or you choose a different effect.

**_Whirlpool._** You cause a whirlpool to form in the center of the area, which must be at least 50 feet square and 25 feet deep. The whirlpool lasts until you choose a different effect or the spell ends. The whirlpool is 5 feet wide at the base, up to 50 feet wide at the top, and 25 feet tall. Any creature in the water and within 25 feet of the whirlpool is pulled 10 feet toward it. When a creature enters the whirlpool for the first time on a turn or ends its turn there, it makes a Strength saving throw. On a failed save, the creature takes 2d8 Bludgeoning damage. On a successful save, the creature takes half as much damage. A creature can swim away from the whirlpool only if it first takes an action to pull away and succeeds on a Strength (Athletics) check against your spell save DC.
`,
      "Control-Weather.md": `---
smType: spell
name: "Control Weather"
level: 8
school: "Transmutation"
casting_time: "10 minutes"
range: "Self"
components: ["V", "S", "M"]
materials: "burning incense"
duration: "Concentration, up to 8 hours"
concentration: true
classes: ["Cleric", "Druid", "Wizard"]
---

# Control Weather
Level 8 Transmutation

- Casting Time: 10 minutes
- Range: Self
- Components: V, S, M (burning incense)
- Duration: Concentration, up to 8 hours
- Concentration: yes
- Classes: Cleric, Druid, Wizard

You take control of the weather within 5 miles of you for the duration. You must be outdoors to cast this spell, and it ends early if you go indoors.

When you cast the spell, you change the current weather conditions, which are determined by the GM. You can change precipitation, temperature, and wind. It takes 1d4 \xD7 10 minutes for the new

conditions to take effect. Once they do so, you can change the conditions again. When the spell ends, the weather gradually returns to normal.

When you change the weather conditions, find a current condition on the following tables and change its stage by one, up or down. When changing the wind, you can change its direction.

Table: Precipitation

| Stage | Condition                                  |

|-------|--------------------------------------------|

| 1     | Clear                                      |

| 2     | Light clouds                               |

| 3     | Overcast or ground fog                     |

| 4     | Rain, hail, or snow                        |

| 5     | Torrential rain, driving hail, or blizzard |

Table: Temperature

| Stage       | Condition |

|-------------|-----------|

| 1           | Heat wave |

| 2           | Hot       |

| 3           | Warm      |

| 4           | Cool      |

| 5           | Cold      |

| 6           | Freezing  |

Table: Wind

| Stage | Condition     |

|-------|---------------|

| 1     | Calm          |

| 2     | Moderate wind |

| 3     | Strong wind   |

| 4     | Gale          |

| 5     | Storm         |
`,
      "Counterspell.md": `---
smType: spell
name: "Counterspell"
level: 3
school: "Abjuration"
casting_time: "Reaction, which you take when you see a creature within 60 feet of yourself casting a spell with Verbal, Somatic, or Material components"
range: "60 feet"
components: ["S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Warlock", "Wizard"]
save_ability: "CON"
---

# Counterspell
Level 3 Abjuration

- Casting Time: Reaction, which you take when you see a creature within 60 feet of yourself casting a spell with Verbal, Somatic, or Material components
- Range: 60 feet
- Components: S
- Duration: Instantaneous
- Classes: Sorcerer, Warlock, Wizard
- Save: CON

You attempt to interrupt a creature in the process of casting a spell. The creature makes a Constitution saving throw. On a failed save, the spell dissipates with no effect, and the action, Bonus Action, or Reaction used to cast it is wasted. If that spell was cast with a spell slot, the slot isn't expended.
`,
      "Create-Food-and-Water.md": `---
smType: spell
name: "Create Food and Water"
level: 3
school: "Conjuration"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric", "Paladin"]
---

# Create Food and Water
Level 3 Conjuration

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric, Paladin

You create 45 pounds of food and 30 gallons of fresh water on the ground or in containers within range\u2014both useful in fending off the hazards of malnutrition and dehydration. The food is bland but nourishing and looks like a food of your choice, and the water is clean. The food spoils after 24 hours if uneaten.
`,
      "Create-or-Destroy-Water.md": `---
smType: spell
name: "Create or Destroy Water"
level: 1
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a mix of water and sand"
duration: "Instantaneous"
classes: ["Cleric", "Druid"]
---

# Create or Destroy Water
Level 1 Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a mix of water and sand)
- Duration: Instantaneous
- Classes: Cleric, Druid

You do one of the following:

**Create Water.** You create up to 10 gallons of clean water within range in an open container. Alternatively, the water falls as rain in a 30-foot Cube within range, extinguishing exposed flames there.

**Destroy Water.** You destroy up to 10 gallons of water in an open container within range. Alternatively, you destroy fog in a 30-foot Cube within range.
`,
      "Create-Undead.md": `---
smType: spell
name: "Create Undead"
level: 6
school: "Necromancy"
casting_time: "1 minute"
range: "10 feet"
components: ["V", "S", "M"]
materials: "one 150+ GP black onyx stone for each corpse"
duration: "Instantaneous"
classes: ["Cleric", "Warlock", "Wizard"]
---

# Create Undead
Level 6 Necromancy

- Casting Time: 1 minute
- Range: 10 feet
- Components: V, S, M (one 150+ GP black onyx stone for each corpse)
- Duration: Instantaneous
- Classes: Cleric, Warlock, Wizard

You can cast this spell only at night. Choose up to three corpses of Medium or Small Humanoids within range. Each one becomes a **Ghoul** under your control (see "Monsters" for its stat block).

As a Bonus Action on each of your turns, you can mentally command any creature you animated with this spell if the creature is within 120 feet of you (if you control multiple creatures, you can command any of them at the same time, issuing the same command to them). You decide what action the creature will take and where it will move on its next turn, or you can issue a general command, such as to guard a particular place. If you issue no commands, the creature takes the Dodge action and moves only to avoid harm. Once given an order, the creature continues to follow the order until its task is complete.

The creature is under your control for 24 hours, after which it stops obeying any command you've given it. To maintain control of the creature for another 24 hours, you must cast this spell on the creature before the current 24-hour period ends. This use of the spell reasserts your control over up to three creatures you have animated with this spell rather than animating new ones.
`,
      "Creation.md": `---
smType: spell
name: "Creation"
level: 5
school: "Illusion"
casting_time: "1 minute"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a paintbrush"
duration: "Special"
classes: ["Sorcerer", "Wizard"]
---

# Creation
Level 5 Illusion

- Casting Time: 1 minute
- Range: 30 feet
- Components: V, S, M (a paintbrush)
- Duration: Special
- Classes: Sorcerer, Wizard

You pull wisps of shadow material from the Shadowfell to create an object within range. It is either an object of vegetable matter (soft goods, rope, wood, and the like) or mineral matter (stone, crystal, metal, and the like). The object must be no larger than a 5-foot Cube, and the object must be of a form and material that you have seen.

The spell's duration depends on the object's material, as shown in the Materials table. If the object is composed of multiple materials, use the shortest duration. Using any object created by this spell as another spell's Material component causes the other spell to fail.

Table: Materials

| Material              | Duration   |

|-----------------------|------------|

| Vegetable matter      | 24 hours   |

| Stone or crystal      | 12 hours   |

| Precious metals       | 1 hour     |

| Gems                  | 10 minutes |

| Adamantine or mithral | 1 minute   |
`,
      "Cure-Wounds.md": `---
smType: spell
name: "Cure Wounds"
level: 1
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger"]
---

# Cure Wounds
Level 1 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid, Paladin, Ranger

A creature you touch regains a number of Hit Points equal to 2d8 plus your spellcasting ability modifier.

## At Higher Levels

### D Spells
`,
      "Dancing-Lights.md": `---
smType: spell
name: "Dancing Lights"
level: 0
school: "Illusion"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a bit of phosphorus"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
---

# Dancing Lights
Cantrip Illusion

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a bit of phosphorus)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard

You create up to four torch-size lights within range, making them appear as torches, lanterns, or glowing orbs that hover for the duration. Alternatively, you combine the four lights into one glowing Medium form that is vaguely humanlike. Whichever form you choose, each light sheds Dim Light in a 10 foot radius.

As a Bonus Action, you can move the lights up to 60 feet to a space within range. A light must be within 20 feet of another light created by this spell, and a light vanishes if it exceeds the spell's range.
`,
      "Darkness.md": `---
smType: spell
name: "Darkness"
level: 2
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V", "M"]
materials: "bat fur and a piece of coal"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Sorcerer", "Warlock", "Wizard"]
---

# Darkness
Level 2 Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V, M (bat fur and a piece of coal)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Sorcerer, Warlock, Wizard

For the duration, magical Darkness spreads from a point within range and fills a 15-foot-radius Sphere. Darkvision can't see through it, and nonmagical light can't illuminate it.

Alternatively, you cast the spell on an object that isn't being worn or carried, causing the Darkness to fill a 15-foot Emanation originating from that object. Covering that object with something opaque, such as a bowl or helm, blocks the Darkness.

If any of this spell's area overlaps with an area of Bright Light or Dim Light created by a spell of level 2 or lower, that other spell is dispelled.
`,
      "Darkvision.md": `---
smType: spell
name: "Darkvision"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a dried carrot"
duration: "8 hours"
classes: ["Druid", "Ranger", "Sorcerer", "Wizard"]
---

# Darkvision
Level 2 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a dried carrot)
- Duration: 8 hours
- Classes: Druid, Ranger, Sorcerer, Wizard

For the duration, a willing creature you touch has Darkvision with a range of 150 feet.
`,
      "Daylight.md": `---
smType: spell
name: "Daylight"
level: 3
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "1 hour"
classes: ["Cleric", "Druid", "Paladin", "Ranger", "Sorcerer"]
---

# Daylight
Level 3 Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: 1 hour
- Classes: Cleric, Druid, Paladin, Ranger, Sorcerer

For the duration, sunlight spreads from a point within range and fills a 60-foot-radius Sphere. The sunlight's area is Bright Light and sheds Dim Light for an additional 60 feet.

Alternatively, you cast the spell on an object that isn't being worn or carried, causing the sunlight to fill a 60-foot Emanation originating from that object. Covering that object with something opaque, such as a bowl or helm, blocks the sunlight.

If any of this spell's area overlaps with an area of Darkness created by a spell of level 3 or lower, that other spell is dispelled.
`,
      "Death-Ward.md": `---
smType: spell
name: "Death Ward"
level: 4
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "8 hours"
classes: ["Cleric", "Paladin"]
---

# Death Ward
Level 4 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: 8 hours
- Classes: Cleric, Paladin

You touch a creature and grant it a measure of protection from death. The first time the target would drop to 0 Hit Points before the spell ends, the target instead drops to 1 Hit Point, and the spell ends.

If the spell is still in effect when the target is subjected to an effect that would kill it instantly without dealing damage, that effect is negated against the target, and the spell ends.
`,
      "Delayed-Blast-Fireball.md": `---
smType: spell
name: "Delayed Blast Fireball"
level: 7
school: "Evocation"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "a ball of bat guano and sulfur"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
---

# Delayed Blast Fireball
Level 7 Evocation

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (a ball of bat guano and sulfur)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Sorcerer, Wizard
- Save: DEX (Half damage on success)

A beam of yellow light flashes from you, then condenses at a chosen point within range as a glowing bead for the duration. When the spell ends, the bead explodes, and each creature in a 20-foot-radius Sphere centered on that point makes a Dexterity saving throw. A creature takes Fire damage equal to the total accumulated damage on a failed save or half as much damage on a successful one.

The spell's base damage is 12d6, and the damage increases by 1d6 whenever your turn ends and the spell hasn't ended.

If a creature touches the glowing bead before the spell ends, that creature makes a Dexterity saving throw. On a failed save, the spell ends, causing the bead to explode. On a successful save, the creature can throw the bead up to 40 feet. If the thrown bead enters a creature's space or collides with a solid object, the spell ends, and the bead explodes.

When the bead explodes, flammable objects in the explosion that aren't being worn or carried start burning.
`,
      "Demiplane.md": `---
smType: spell
name: "Demiplane"
level: 8
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["S"]
duration: "1 hour"
classes: ["Sorcerer", "Warlock", "Wizard"]
---

# Demiplane
Level 8 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: S
- Duration: 1 hour
- Classes: Sorcerer, Warlock, Wizard

You create a shadowy Medium door on a flat solid surface that you can see within range. This door can be opened and closed, and it leads to a demiplane that is an empty room 30 feet in each dimension, made of wood or stone (your choice).

When the spell ends, the door vanishes, and any objects inside the demiplane remain there. Any creatures inside also remain unless they opt to be shunted through the door as it vanishes, landing with the Prone condition in the unoccupied spaces closest to the door's former space.

Each time you cast this spell, you can create a new demiplane or connect the shadowy door to a demiplane you created with a previous casting of this spell. Additionally, if you know the nature and contents of a demiplane created by a casting of this spell by another creature, you can connect the shadowy door to that demiplane instead.
`,
      "Detect-Evil-and-Good.md": `---
smType: spell
name: "Detect Evil and Good"
level: 1
school: "Divination"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Cleric", "Paladin"]
---

# Detect Evil and Good
Level 1 Divination

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Cleric, Paladin

For the duration, you sense the location of any Aberration, Celestial, Elemental, Fey, Fiend, or Undead within 30 feet of yourself. You also sense whether the *Hallow* spell is active there and, if so, where.

The spell is blocked by 1 foot of stone, dirt, or wood; 1 inch of metal; or a thin sheet of lead.
`,
      "Detect-Magic.md": `---
smType: spell
name: "Detect Magic"
level: 1
school: "Divination"
casting_time: "Action or Ritual"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
ritual: true
classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger", "Sorcerer", "Warlock", "Wizard"]
---

# Detect Magic
Level 1 Divination

- Casting Time: Action or Ritual
- Range: Self
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Ritual: yes
- Classes: Bard, Cleric, Druid, Paladin, Ranger, Sorcerer, Warlock, Wizard

For the duration, you sense the presence of magical effects within 30 feet of yourself. If you sense such effects, you can take the Magic action to see a faint aura around any visible creature or object in the area that bears the magic, and if an effect was created by a spell, you learn the spell's school of magic.

The spell is blocked by 1 foot of stone, dirt, or wood; 1 inch of metal; or a thin sheet of lead.
`,
      "Detect-Poison-and-Disease.md": `---
smType: spell
name: "Detect Poison and Disease"
level: 1
school: "Divination"
casting_time: "Action or Ritual"
range: "Self"
components: ["V", "S", "M"]
materials: "a yew leaf"
duration: "Concentration, up to 10 minutes"
concentration: true
ritual: true
classes: ["Cleric", "Druid", "Paladin", "Ranger"]
---

# Detect Poison and Disease
Level 1 Divination

- Casting Time: Action or Ritual
- Range: Self
- Components: V, S, M (a yew leaf)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Ritual: yes
- Classes: Cleric, Druid, Paladin, Ranger

For the duration, you sense the location of poisons, poisonous or venomous creatures, and magical contagions within 30 feet of yourself. You sense the kind of poison, creature, or contagion in each case.

The spell is blocked by 1 foot of stone, dirt, or wood; 1 inch of metal; or a thin sheet of lead.
`,
      "Detect-Thoughts.md": `---
smType: spell
name: "Detect Thoughts"
level: 2
school: "Divination"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "1 Copper Piece"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "WIS"
---

# Detect Thoughts
Level 2 Divination

- Casting Time: Action
- Range: Self
- Components: V, S, M (1 Copper Piece)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard
- Save: WIS

You activate one of the effects below. Until the spell ends, you can activate either effect as a Magic action on your later turns.

**_Sense Thoughts._** You sense the presence of thoughts within 30 feet of yourself that belong to creatures that know languages or are telepathic. You don't read the thoughts, but you know that a thinking creature is present.

The spell is blocked by 1 foot of stone, dirt, or wood; 1 inch of metal; or a thin sheet of lead.

**_Read Thoughts._** Target one creature you can see within 30 feet of yourself or one creature within 30 feet of yourself that you detected with the Sense Thoughts option. You learn what is most on the target's mind right now. If the target doesn't know any languages and isn't telepathic, you learn nothing.

As a Magic action on your next turn, you can try to probe deeper into the target's mind. If you probe deeper, the target makes a Wisdom saving throw. On a failed save, you discern the target's reasoning, emotions, and something that looms large in its mind (such as a worry, love, or hate). On a successful save, the spell ends. Either way, the target knows that you are probing into its mind, and until you shift your attention away from the target's mind, the target can take an action on its turn to make an Intelligence (Arcana) check against your spell save DC, ending the spell on a success.
`,
      "Dimension-Door.md": `---
smType: spell
name: "Dimension Door"
level: 4
school: "Conjuration"
casting_time: "Action"
range: "500 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
damage: "4d6"
damage_type: "Force"
---

# Dimension Door
Level 4 Conjuration

- Casting Time: Action
- Range: 500 feet
- Components: V
- Duration: Instantaneous
- Classes: Bard, Sorcerer, Warlock, Wizard
- Damage: 4d6 Force

You teleport to a location within range. You arrive at exactly the spot desired. It can be a place you can see, one you can visualize, or one you can describe by stating distance and direction, such as "200 feet straight downward" or "300 feet upward to the northwest at a 45-degree angle."

You can also teleport one willing creature. The creature must be within 5 feet of you when you teleport, and it teleports to a space within 5 feet of your destination space.

If you, the other creature, or both would arrive in a space occupied by a creature or completely filled by one or more objects, you and any creature traveling with you each take 4d6 Force damage, and the teleportation fails.
`,
      "Disguise-Self.md": `---
smType: spell
name: "Disguise Self"
level: 1
school: "Illusion"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "1 hour"
classes: ["Bard", "Sorcerer", "Wizard"]
---

# Disguise Self
Level 1 Illusion

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: 1 hour
- Classes: Bard, Sorcerer, Wizard

You make yourself\u2014including your clothing, armor, weapons, and other belongings on your person look different until the spell ends. You can seem 1 foot shorter or taller and can appear heavier or lighter. You must adopt a form that has the same basic arrangement of limbs as you have. Otherwise, the extent of the illusion is up to you.

The changes wrought by this spell fail to hold up to physical inspection. For example, if you use this spell to add a hat to your outfit, objects pass through the hat, and anyone who touches it would feel nothing.

To discern that you are disguised, a creature must take the Study action to inspect your appearance and succeed on an Intelligence (Investigation) check against your spell save DC.
`,
      "Disintegrate.md": `---
smType: spell
name: "Disintegrate"
level: 6
school: "Transmutation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a lodestone and dust"
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
damage: "10d6 + 40"
damage_type: "Force"
---

# Disintegrate
Level 6 Transmutation

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a lodestone and dust)
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Save: DEX
- Damage: 10d6 + 40 Force

You launch a green ray at a target you can see within range. The target can be a creature, a nonmagical object, or a creation of magical force, such as the wall created by *Wall of Force.*

A creature targeted by this spell makes a Dexterity saving throw. On a failed save, the target takes 10d6 + 40 Force damage. If this damage reduces it to 0 Hit Points, it and everything nonmagical it is wearing and carrying are disintegrated into gray dust. The target can be revived only by a *True Resurrection* or a *Wish* spell.

This spell automatically disintegrates a Large or smaller nonmagical object or a creation of magical force. If such a target is Huge or larger, this spell disintegrates a 10-foot-Cube portion of it.
`,
      "Dispel-Evil-and-Good.md": `---
smType: spell
name: "Dispel Evil and Good"
level: 5
school: "Abjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "powdered silver and iron"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric", "Paladin"]
save_ability: "CHA"
---

# Dispel Evil and Good
Level 5 Abjuration

- Casting Time: Action
- Range: Self
- Components: V, S, M (powdered silver and iron)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric, Paladin
- Save: CHA

For the duration, Celestials, Elementals, Fey, Fiends, and Undead have Disadvantage on attack rolls against you. You can end the spell early by using either of the following special functions.

*Break Enchantment.* As a Magic action, you touch a creature that is possessed by or has the Charmed or Frightened condition from one or more creatures of the types above. The target is no longer possessed, Charmed, or Frightened by such creatures.

*Dismissal.* As a Magic action, you target one creature you can see within 5 feet of you that has one of the creature types above. The target must succeed on a Charisma saving throw or be sent back to its home plane if it isn't there already. If they aren't on their home plane, Undead are sent to the Shadowfell, and Fey are sent to the Feywild.
`,
      "Dispel-Magic.md": `---
smType: spell
name: "Dispel Magic"
level: 3
school: "Abjuration"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger", "Sorcerer", "Warlock", "Wizard"]
---

# Dispel Magic
Level 3 Abjuration

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid, Paladin, Ranger, Sorcerer, Warlock, Wizard

Choose one creature, object, or magical effect within range. Any ongoing spell of level 3 or lower on the target ends. For each ongoing spell of level 4 or higher on the target, make an ability check using your spellcasting ability (DC 10 plus that spell's level). On a successful check, the spell ends.
`,
      "Dissonant-Whispers.md": `---
smType: spell
name: "Dissonant Whispers"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Bard"]
save_ability: "WIS"
save_effect: "Half damage on success"
damage: "3d6"
damage_type: "Psychic"
---

# Dissonant Whispers
Level 1 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V
- Duration: Instantaneous
- Classes: Bard
- Save: WIS (Half damage on success)
- Damage: 3d6 Psychic

One creature of your choice that you can see within range hears a discordant melody in its mind. The target makes a Wisdom saving throw. On a failed save, it takes 3d6 Psychic damage and must immediately use its Reaction, if available, to move as far away from you as it can, using the safest route. On a successful save, the target takes half as much damage only.

**Using a Higher-Level Spell Slot._** The damage increases by 1d6 for each spell slot level above 1.
`,
      "Divination.md": `---
smType: spell
name: "Divination"
level: 4
school: "Divination"
casting_time: "Action or Ritual"
range: "Self"
components: ["V", "S", "M"]
materials: "incense worth 25+ GP, which the spell consumes"
duration: "Instantaneous"
ritual: true
classes: ["Cleric", "Druid", "Wizard"]
---

# Divination
Level 4 Divination

- Casting Time: Action or Ritual
- Range: Self
- Components: V, S, M (incense worth 25+ GP, which the spell consumes)
- Duration: Instantaneous
- Ritual: yes
- Classes: Cleric, Druid, Wizard

This spell puts you in contact with a god or a god's servants. You ask one question about a specific goal, event, or activity to occur within 7 days. The GM offers a truthful reply, which might be a short phrase or cryptic rhyme. The spell doesn't account for circumstances that might change the answer, such as the casting of other spells.

If you cast the spell more than once before finishing a Long Rest, there is a cumulative 25 percent chance for each casting after the first that you get no answer.
`,
      "Divine-Favor.md": `---
smType: spell
name: "Divine Favor"
level: 1
school: "Transmutation"
casting_time: "Bonus Action"
range: "Self"
components: ["V", "S"]
duration: "1 minute"
classes: ["Paladin"]
damage: "1d4"
damage_type: "Radiant"
---

# Divine Favor
Level 1 Transmutation

- Casting Time: Bonus Action
- Range: Self
- Components: V, S
- Duration: 1 minute
- Classes: Paladin
- Damage: 1d4 Radiant

Until the spell ends, your attacks with weapons deal an extra 1d4 Radiant damage on a hit.
`,
      "Divine-Smite.md": `---
smType: spell
name: "Divine Smite"
level: 1
school: "Evocation"
casting_time: "Bonus Action, which you take immediately after hitting a target with a Melee weapon or an Unarmed Strike"
range: "Self"
duration: "Instantaneous"
classes: ["Paladin"]
damage: "2d8"
damage_type: "Radiant"
---

# Divine Smite
Level 1 Evocation

- Casting Time: Bonus Action, which you take immediately after hitting a target with a Melee weapon or an Unarmed Strike
- Range: Self
- Duration: Instantaneous
- Classes: Paladin
- Damage: 2d8 Radiant

The target takes an extra 2d8 Radiant damage from the attack. The damage increases by 1d8 if the target is a Fiend or an Undead.
`,
      "Divine-Word.md": `---
smType: spell
name: "Divine Word"
level: 7
school: "Evocation"
casting_time: "Bonus Action"
range: "30 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Cleric"]
save_ability: "CHA"
---

# Divine Word
Level 7 Evocation

- Casting Time: Bonus Action
- Range: 30 feet
- Components: V
- Duration: Instantaneous
- Classes: Cleric
- Save: CHA

You utter a word imbued with power from the Upper Planes. Each creature of your choice in range makes a Charisma saving throw. On a failed save, a target that has 50 Hit Points or fewer suffers an effect based on its current Hit Points, as shown in the Divine Word Effects table. Regardless of its Hit Points, a Celestial, an Elemental, a Fey, or a Fiend target that fails its save is forced back to its plane of origin (if it isn't there already) and can't return to the current plane for 24 hours by any means short of a *Wish* spell.

Table: Divine Word Effects

| Hit Points | Effect                                                                   |

|------------|--------------------------------------------------------------------------|

| 0\u201320       | The target dies.                                                         |

| 21\u201330      | The target has the Blinded, Deafened, and Stunned conditions for 1 hour. |

| 31\u201340      | The target has the Blinded and Deafened conditions for 10 minutes.       |

| 41\u201350      | The target has the Deafened condition for 1 minute.                      |
`,
      "Dominate-Beast.md": `---
smType: spell
name: "Dominate Beast"
level: 4
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Ranger", "Sorcerer"]
save_ability: "WIS"
---

# Dominate Beast
Level 4 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Ranger, Sorcerer
- Save: WIS

One Beast you can see within range must succeed on a Wisdom saving throw or have the Charmed condition for the duration. The target has Advantage on the save if you or your allies are fighting it. Whenever the target takes damage, it repeats the save, ending the spell on itself on a success.

You have a telepathic link with the Charmed target while the two of you are on the same plane of existence. On your turn, you can use this link to issue commands to the target (no action required), such as "Attack that creature," "Move over there," or "Fetch that object." The target does its best to obey on its turn. If it completes an order and doesn't receive further direction from you, it acts and moves as it likes, focusing on protecting itself.

You can command the target to take a Reaction but must take your own Reaction to do so.
`,
      "Dominate-Monster.md": `---
smType: spell
name: "Dominate Monster"
level: 8
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Dominate Monster
Level 8 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Bard, Sorcerer, Warlock, Wizard
- Save: WIS

One creature you can see within range must succeed on a Wisdom saving throw or have the Charmed condition for the duration. The target has Advantage on the save if you or your allies are fighting it. Whenever the target takes damage, it repeats the save, ending the spell on itself on a success.

You have a telepathic link with the Charmed target while the two of you are on the same plane of existence. On your turn, you can use this link to issue commands to the target (no action required), such as "Attack that creature," "Move over there," or "Fetch that object." The target does its best to obey on its turn. If it completes an order and doesn't receive further direction from you, it acts and moves as it likes, focusing on protecting itself.

You can command the target to take a Reaction but must take your own Reaction to do so.
`,
      "Dominate-Person.md": `---
smType: spell
name: "Dominate Person"
level: 5
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "WIS"
---

# Dominate Person
Level 5 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard
- Save: WIS

One Humanoid you can see within range must succeed on a Wisdom saving throw or have the Charmed condition for the duration. The target has Advantage on the save if you or your allies are fighting it. Whenever the target takes damage, it repeats the save, ending the spell on itself on a success.

You have a telepathic link with the Charmed target while the two of you are on the same plane of existence. On your turn, you can use this link to issue commands to the target (no action required), such as "Attack that creature," "Move over there," or "Fetch that object." The target does its best to obey on its turn. If it completes an order and doesn't receive further direction from you, it acts and moves as it likes, focusing on protecting itself.

You can command the target to take a Reaction but must take your own Reaction to do so.
`,
      "Dragon-s-Breath.md": `---
smType: spell
name: "Dragon's Breath"
level: 2
school: "Transmutation"
casting_time: "Bonus Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a hot pepper"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
---

# Dragon's Breath
Level 2 Transmutation

- Casting Time: Bonus Action
- Range: Touch
- Components: V, S, M (a hot pepper)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Sorcerer, Wizard
- Save: DEX (Half damage on success)

You touch one willing creature, and choose Acid, Cold, Fire, Lightning, or Poison. Until the spell ends, the target can take a Magic action to exhale a 15-foot Cone. Each creature in that area makes a Dexterity saving throw, taking 3d6 damage of the chosen type on a failed save or half as much damage on a successful one.
`,
      "Dream.md": `---
smType: spell
name: "Dream"
level: 5
school: "Illusion"
casting_time: "1 minute"
range: "Special"
components: ["V", "S", "M"]
materials: "a handful of sand"
duration: "8 hours"
classes: ["Bard", "Warlock", "Wizard"]
save_ability: "WIS"
damage: "3d6"
damage_type: "Psychic"
---

# Dream
Level 5 Illusion

- Casting Time: 1 minute
- Range: Special
- Components: V, S, M (a handful of sand)
- Duration: 8 hours
- Classes: Bard, Warlock, Wizard
- Save: WIS
- Damage: 3d6 Psychic

You target a creature you know on the same plane of existence. You or a willing creature you touch enters a trance state to act as a dream messenger. While in the trance, the messenger is Incapacitated and has a Speed of 0.

If the target is asleep, the messenger appears in the target's dreams and can converse with the target as long as it remains asleep, through the spell's duration. The messenger can also shape the dream's environment, creating landscapes, objects, and other images. The messenger can emerge from the trance at any time, ending the spell. The target recalls the dream perfectly upon waking.

If the target is awake when you cast the spell, the messenger knows it and can either end the trance (and the spell) or wait for the target to sleep, at which point the messenger enters its dreams.

You can make the messenger terrifying to the target. If you do so, the messenger can deliver a message of no more than ten words, and then the target makes a Wisdom saving throw. On a failed save, the target gains no benefit from its rest, and it takes 3d6 Psychic damage when it wakes up.
`,
      "Druidcraft.md": `---
smType: spell
name: "Druidcraft"
level: 0
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Druid"]
---

# Druidcraft
Cantrip Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Druid

Whispering to the spirits of nature, you create one of the following effects within range.

**_Weather Sensor._** You create a Tiny, harmless sensory effect that predicts what the weather will be at your location for the next 24 hours. The effect might manifest as a golden orb for clear skies, a cloud for rain, falling snowflakes for snow, and so on. This effect persists for 1 round.

**_Bloom._** You instantly make a flower blossom, a seed pod open, or a leaf bud bloom.

**_Sensory Effect._** You create a harmless sensory effect, such as falling leaves, spectral dancing fairies, a gentle breeze, the sound of an animal, or the faint odor of skunk. The effect must fit in a 5-foot Cube.

**_Fire Play._** You light or snuff out a candle, a torch, or a campfire.

### E Spells
`,
      "Earthquake.md": `---
smType: spell
name: "Earthquake"
level: 8
school: "Transmutation"
casting_time: "Action"
range: "500 feet"
components: ["V", "S", "M"]
materials: "a fractured rock"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric", "Druid", "Sorcerer"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "12d6"
damage_type: "Bludgeoning"
---

# Earthquake
Level 8 Transmutation

- Casting Time: Action
- Range: 500 feet
- Components: V, S, M (a fractured rock)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric, Druid, Sorcerer
- Save: DEX (Half damage on success)
- Damage: 12d6 Bludgeoning

Choose a point on the ground that you can see within range. For the duration, an intense tremor rips through the ground in a 100-foot-radius circle centered on that point. The ground there is Difficult Terrain.

When you cast this spell and at the end of each of your turns for the duration, each creature on the ground in the area makes a Dexterity saving throw. On a failed save, a creature has the Prone condition, and its Concentration is broken.

You can also cause the effects below.

**_Fissures._** A total of 1d6 fissures open in the spell's area at the end of the turn you cast it. You choose the fissures' locations, which can't be under structures. Each fissure is 1d10 \xD7 10 feet deep and 10 feet wide, and it extends from one edge of the spell's area to another edge. A creature in the same space as a fissure must succeed on a Dexterity saving throw or fall in. A creature that successfully saves moves with the fissure's edge as it opens.

**Structures._** The tremor deals 50 Bludgeoning damage to any structure in contact with the ground in the area when you cast the spell and at the end of each of your turns until the spell ends. If a structure drops to 0 Hit Points, it collapses.

A creature within a distance from a collapsing structure equal to half the structure's height makes a Dexterity saving throw. On a failed save, the creature takes 12d6 Bludgeoning damage, has the Prone condition, and is buried in the rubble, requiring a DC 20 Strength (Athletics) check as an action to escape. On a successful save, the creature takes half as much damage only.
`,
      "Eldritch-Blast.md": `---
smType: spell
name: "Eldritch Blast"
level: 0
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Warlock"]
attack: "ranged spell attack"
damage: "1d10"
damage_type: "Force"
---

# Eldritch Blast
Cantrip Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Warlock
- Attack: ranged spell attack
- Damage: 1d10 Force

You hurl a beam of crackling energy. Make a ranged spell attack against one creature or object in range. On a hit, the target takes 1d10 Force damage.
`,
      "Elementalism.md": `---
smType: spell
name: "Elementalism"
level: 0
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Druid", "Sorcerer", "Wizard"]
---

# Elementalism
Cantrip Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Druid, Sorcerer, Wizard

You exert control over the elements, creating one of the following effects within range.

**_Beckon Air._** You create a breeze strong enough to ripple cloth, stir dust, rustle leaves, and close open doors and shutters, all in a 5-foot Cube. Doors and shutters being held open by someone or something aren't affected.

**_Beckon Earth._** You create a thin shroud of dust or sand that covers surfaces in a 5-foot-square area, or you cause a single word to appear in your handwriting in a patch of dirt or sand.

**_Beckon Fire._** You create a thin cloud of harmless embers and colored, scented smoke in a 5-foot Cube. You choose the color and scent, and the embers can light candles, torches, or lamps in that area. The smoke's scent lingers for 1 minute.

**_Beckon Water._** You create a spray of cool mist that lightly dampens creatures and objects in a 5-foot Cube. Alternatively, you create 1 cup of clean water either in an open container or on a surface, and the water evaporates in 1 minute.

**_Sculpt Element._** You cause dirt, sand, fire, smoke, mist, or water that can fit in a 1-foot Cube to assume a crude shape (such as that of a creature) for 1 hour.
`,
      "Enhance-Ability.md": `---
smType: spell
name: "Enhance Ability"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "fur or a feather"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Bard", "Cleric", "Druid", "Ranger", "Sorcerer", "Wizard"]
---

# Enhance Ability
Level 2 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (fur or a feather)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Bard, Cleric, Druid, Ranger, Sorcerer, Wizard

You touch a creature and choose Strength, Dexterity, Intelligence, Wisdom, or Charisma. For the duration, the target has Advantage on ability checks using the chosen ability.
`,
      "Enlarge-Reduce.md": `---
smType: spell
name: "Enlarge/Reduce"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a pinch of powdered iron"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Druid", "Sorcerer", "Wizard"]
save_ability: "CON"
damage: "1d4"
damage_type: "less"
---

# Enlarge/Reduce
Level 2 Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a pinch of powdered iron)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Druid, Sorcerer, Wizard
- Save: CON
- Damage: 1d4 less

For the duration, the spell enlarges or reduces a creature or an object you can see within range (see the chosen effect below). A targeted object must be neither worn nor carried. If the target is an unwilling creature, it can make a Constitution saving throw. On a successful save, the spell has no effect.

Everything that a targeted creature is wearing and carrying changes size with it. Any item it drops returns to normal size at once. A thrown weapon or piece of ammunition returns to normal size immediately after it hits or misses a target.

**_Enlarge._** The target's size increases by one category\u2014from Medium to Large, for example. The target also has Advantage on Strength checks and Strength saving throws. The target's attacks with its enlarged weapons or Unarmed Strikes deal an extra 1d4 damage on a hit.

**_Reduce._** The target's size decreases by one category\u2014from Medium to Small, for example. The target also has Disadvantage on Strength checks and Strength saving throws. The target's attacks with its reduced weapons or Unarmed Strikes deal 1d4 less damage on a hit (this can't reduce the damage below 1).
`,
      "Ensnaring-Strike.md": `---
smType: spell
name: "Ensnaring Strike"
level: 1
school: "Conjuration"
casting_time: "Bonus Action, which you take immediately after hitting a creature with a weapon"
range: "Self"
components: ["V"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Ranger"]
save_ability: "STR"
damage: "1d6"
damage_type: "Piercing"
---

# Ensnaring Strike
Level 1 Conjuration

- Casting Time: Bonus Action, which you take immediately after hitting a creature with a weapon
- Range: Self
- Components: V
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Ranger
- Save: STR
- Damage: 1d6 Piercing

As you hit the target, grasping vines appear on it, and it makes a Strength saving throw. A Large or larger creature has Advantage on this save. On a failed save, the target has the Restrained condition until the spell ends. On a successful save, the vines shrivel away, and the spell ends.

While Restrained, the target takes 1d6 Piercing damage at the start of each of its turns. The target or a creature within reach of it can take an action to make a Strength (Athletics) check against your spell save DC. On a success, the spell ends.
`,
      "Entangle.md": `---
smType: spell
name: "Entangle"
level: 1
school: "Conjuration"
casting_time: "Action"
range: "90 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Ranger"]
save_ability: "STR"
---

# Entangle
Level 1 Conjuration

- Casting Time: Action
- Range: 90 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Ranger
- Save: STR

Grasping plants sprout from the ground in a 20-foot square within range. For the duration, these plants turn the ground in the area into Difficult Terrain. They disappear when the spell ends.

Each creature (other than you) in the area when you cast the spell must succeed on a Strength

saving throw or have the Restrained condition until the spell ends. A Restrained creature can take an action to make a Strength (Athletics) check against your spell save DC. On a success, it frees itself from the grasping plants and is no longer Restrained by them.
`,
      "Enthrall.md": `---
smType: spell
name: "Enthrall"
level: 2
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Warlock"]
save_ability: "WIS"
---

# Enthrall
Level 2 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Warlock
- Save: WIS

You weave a distracting string of words, causing creatures of your choice that you can see within range to make a Wisdom saving throw. Any creature you or your companions are fighting automatically succeeds on this save. On a failed save, a target has a \u221210 penalty to Wisdom (Perception) checks and Passive Perception until the spell ends.
`,
      "Etherealness.md": `---
smType: spell
name: "Etherealness"
level: 7
school: "Conjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Up to 8 hours"
classes: ["Bard", "Cleric", "Sorcerer", "Warlock", "Wizard"]
---

# Etherealness
Level 7 Conjuration

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Up to 8 hours
- Classes: Bard, Cleric, Sorcerer, Warlock, Wizard

You step into the border regions of the Ethereal Plane, where it overlaps with your current plane. You remain in the Border Ethereal for the duration. During this time, you can move in any direction. If you move up or down, every foot of movement costs an extra foot. You can perceive the plane you left, which looks gray, and you can't see anything there more than 60 feet away.

While on the Ethereal Plane, you can affect and be affected only by creatures, objects, and effects on that plane. Creatures that aren't on the Ethereal Plane can't perceive or interact with you unless a feature gives them the ability to do so.

When the spell ends, you return to the plane you left in the spot that corresponds to your space in the Border Ethereal. If you appear in an occupied space, you are shunted to the nearest unoccupied space and take Force damage equal to twice the number of feet you are moved.

This spell ends instantly if you cast it while you are on the Ethereal Plane or a plane that doesn't border it, such as one of the Outer Planes.
`,
      "Expeditious-Retreat.md": `---
smType: spell
name: "Expeditious Retreat"
level: 1
school: "Transmutation"
casting_time: "Bonus Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Sorcerer", "Warlock", "Wizard"]
---

# Expeditious Retreat
Level 1 Transmutation

- Casting Time: Bonus Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Sorcerer, Warlock, Wizard

You take the Dash action, and until the spell ends, you can take that action again as a Bonus Action.
`,
      "Eyebite.md": `---
smType: spell
name: "Eyebite"
level: 6
school: "Necromancy"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Eyebite
Level 6 Necromancy

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Warlock, Wizard
- Save: WIS

For the duration, your eyes become an inky void. One creature of your choice within 60 feet of you that you can see must succeed on a Wisdom saving throw or be affected by one of the following effects of your choice for the duration.

On each of your turns until the spell ends, you can take a Magic action to target another creature but can't target a creature again if it has succeeded on a save against this casting of the spell.

**_Asleep._** The target has the Unconscious condition. It wakes up if it takes any damage or if another creature takes an action to shake it awake.

**_Panicked._** The target has the Frightened condition. On each of its turns, the Frightened target must take the Dash action and move away from you by the safest and shortest route available. If the target moves to a space at least 60 feet away from you where it can't see you, this effect ends.

**_Sickened._** The target has the Poisoned condition.

### F Spells
`,
      "Fabricate.md": `---
smType: spell
name: "Fabricate"
level: 4
school: "Transmutation"
casting_time: "10 minutes"
range: "120 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Wizard"]
---

# Fabricate
Level 4 Transmutation

- Casting Time: 10 minutes
- Range: 120 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Wizard

You convert raw materials into products of the same material. For example, you can fabricate a wooden bridge from a clump of trees, a rope from a patch of hemp, or clothes from flax or wool.

Choose raw materials that you can see within range. You can fabricate a Large or smaller object (contained within a 10-foot Cube or eight connected 5-foot Cubes) given a sufficient quantity of material. If you're working with metal, stone, or another mineral substance, however, the fabricated object can be no larger than Medium (contained within a 5-foot Cube). The quality of any fabricated objects is based on the quality of the raw materials.

Creatures and magic items can't be created by this spell. You also can't use it to create items that require a high degree of skill\u2014such as weapons and armor\u2014unless you have proficiency with the type of Artisan's Tools used to craft such objects.
`,
      "Faerie-Fire.md": `---
smType: spell
name: "Faerie Fire"
level: 1
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Druid"]
save_ability: "DEX"
---

# Faerie Fire
Level 1 Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Druid
- Save: DEX

Objects in a 20-foot Cube within range are outlined in blue, green, or violet light (your choice). Each creature in the Cube is also outlined if it fails a Dexterity saving throw. For the duration, objects and affected creatures shed Dim Light in a 10-foot radius and can't benefit from the Invisible condition.

Attack rolls against an affected creature or object have Advantage if the attacker can see it.
`,
      "Faithful-Hound.md": `---
smType: spell
name: "Faithful Hound"
level: 4
school: "Conjuration"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a silver whistle"
duration: "8 hours"
classes: ["Wizard"]
save_ability: "DEX"
damage: "4d8"
damage_type: "Force"
---

# Faithful Hound
Level 4 Conjuration

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a silver whistle)
- Duration: 8 hours
- Classes: Wizard
- Save: DEX
- Damage: 4d8 Force

You conjure a phantom watchdog in an unoccupied space that you can see within range. The hound remains for the duration or until the two of you are more than 300 feet apart from each other.

No one but you can see the hound, and it is intangible and invulnerable. When a Small or larger creature comes within 30 feet of it without first speaking the password that you specify when you cast this spell, the hound starts barking loudly. The hound has Truesight with a range of 30 feet.

At the start of each of your turns, the hound attempts to bite one enemy within 5 feet of it. That enemy must succeed on a Dexterity saving throw or take 4d8 Force damage.

On your later turns, you can take a Magic action to move the hound up to 30 feet.
`,
      "False-Life.md": `---
smType: spell
name: "False Life"
level: 1
school: "Necromancy"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a drop of alcohol"
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
---

# False Life
Level 1 Necromancy

- Casting Time: Action
- Range: Self
- Components: V, S, M (a drop of alcohol)
- Duration: Instantaneous
- Classes: Sorcerer, Wizard

You gain 2d4 + 4 Temporary Hit Points.
`,
      "Fear.md": `---
smType: spell
name: "Fear"
level: 3
school: "Illusion"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a white feather"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Fear
Level 3 Illusion

- Casting Time: Action
- Range: Self
- Components: V, S, M (a white feather)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Warlock, Wizard
- Save: WIS

Each creature in a 30-foot Cone must succeed on a Wisdom saving throw or drop whatever it is holding and have the Frightened condition for the duration.

A Frightened creature takes the Dash action and moves away from you by the safest route on each of its turns unless there is nowhere to move. If the creature ends its turn in a space where it doesn't have line of sight to you, the creature makes a Wisdom saving throw. On a successful save, the spell ends on that creature.
`,
      "Feather-Fall.md": `---
smType: spell
name: "Feather Fall"
level: 1
school: "Transmutation"
casting_time: "Reaction, which you take when you or a creature you can see within 60 feet of you falls"
range: "60 feet"
components: ["V", "M"]
materials: "a small feather or piece of down"
duration: "1 minute"
classes: ["Bard", "Sorcerer", "Wizard"]
---

# Feather Fall
Level 1 Transmutation

- Casting Time: Reaction, which you take when you or a creature you can see within 60 feet of you falls
- Range: 60 feet
- Components: V, M (a small feather or piece of down)
- Duration: 1 minute
- Classes: Bard, Sorcerer, Wizard

Choose up to five falling creatures within range. A falling creature's rate of descent slows to 60 feet per round until the spell ends. If a creature lands before the spell ends, the creature takes no damage from the fall, and the spell ends for that creature.
`,
      "Find-Familiar.md": `---
smType: spell
name: "Find Familiar"
level: 1
school: "Conjuration"
casting_time: "1 hour or Ritual"
range: "10 feet"
components: ["V", "S", "M"]
materials: "burning incense worth 10+ GP, which the spell consumes"
duration: "Instantaneous"
ritual: true
classes: ["Wizard"]
---

# Find Familiar
Level 1 Conjuration

- Casting Time: 1 hour or Ritual
- Range: 10 feet
- Components: V, S, M (burning incense worth 10+ GP, which the spell consumes)
- Duration: Instantaneous
- Ritual: yes
- Classes: Wizard

You gain the service of a familiar, a spirit that takes an animal form you choose: **Bat, Cat, Frog, Hawk, Lizard, Octopus, Owl, Rat, Raven, Spider, Weasel,** or another Beast that has a Challenge Rating of 0. Appearing in an unoccupied space within range, the familiar has the statistics of the chosen form (see "Monsters"), though it is a Celestial, Fey, or Fiend (your choice) instead of a Beast. Your familiar acts independently of you, but it obeys your commands.

**_Telepathic Connection._** While your familiar is within 100 feet of you, you can communicate with it telepathically. Additionally, as a Bonus Action, you can see through the familiar's eyes and hear what it hears until the start of your next turn, gaining the benefits of any special senses it has.

Finally, when you cast a spell with a range of touch, your familiar can deliver the touch. Your familiar must be within 100 feet of you, and it must take a Reaction to deliver the touch when you cast the spell.

**_Combat._** The familiar is an ally to you and your allies. It rolls its own Initiative and acts on its own turn. A familiar can't attack, but it can take other actions as normal.

**_Disappearance of the Familiar._** When the familiar drops to 0 Hit Points, it disappears. It reappears after you cast this spell again. As a Magic action, you can temporarily dismiss the familiar to a pocket dimension. Alternatively, you can dismiss it forever. As a Magic action while it is temporarily dismissed, you can cause it to reappear in an unoccupied space within 30 feet of you. Whenever the familiar drops to 0 Hit Points or disappears into the pocket dimension, it leaves behind in its space anything it was wearing or carrying.

**_One Familiar Only._** You can't have more than one familiar at a time. If you cast this spell while you have a familiar, you instead cause it to adopt a new eligible form.
`,
      "Find-Steed.md": `---
smType: spell
name: "Find Steed"
level: 2
school: "Conjuration"
casting_time: "Action"
range: "30 feet"
duration: "Instantaneous"
classes: ["Paladin"]
---

# Find Steed
Level 2 Conjuration

- Casting Time: Action
- Range: 30 feet
- Duration: Instantaneous
- Classes: Paladin

You summon an otherworldly being that appears as a loyal steed in an unoccupied space of your choice within range. This creature uses the **Otherworldly Steed** stat block. If you already have a steed from this spell, the steed is replaced by the new one.

The steed resembles a Large, rideable animal of your choice, such as a horse, a camel, a dire wolf, or an elk. Whenever you cast the spell, choose the steed's creature type\u2014Celestial, Fey, or Fiend which determines certain traits in the stat block.

**_Combat._** The steed is an ally to you and your allies. In combat, it shares your Initiative count, and it functions as a controlled mount while you ride it (as defined in the rules on mounted combat). If you have the Incapacitated condition, the steed takes its turn immediately after yours and acts independently, focusing on protecting you.

**_Disappearance of the Steed._** The steed disappears if it drops to 0 Hit Points or if you die. When it disappears, it leaves behind anything it was wearing or carrying. If you cast this spell again, you decide whether you summon the steed that disappeared or a different one.

## At Higher Levels

> #### **Otherworldly Steed**

>

> *Large Celestial, Fey, or Fiend (Your Choice), Neutral*

>

> **AC** 10 + 1 per spell level

>

> **HP** 5 + 10 per spell level (the steed has a number of Hit Dice [d10s] equal to the spell's level)

>

> **Speed** 60 ft., Fly 60 ft. (requires level 4+ spell)

>

> | Attribute | Score | Mod | Save |

> |-----------|-------|-----|------|

> | Str       | 18    | +4  | +4   |

> | Dex       | 12    | +1  | +1   |

> | Con       | 14    | +2  | +2   |

> | Int       | 6     | -2  | -2   |

> | Wis       | 12    | +1  | +1   |

> | Cha       | 8     | -1  | -1   |

>

> **Senses** Passive Perception 11

>

> **Languages** Telepathy 1 mile (works only with you)

>

> **CR** None (XP 0; PB equals your Proficiency Bonus)

>

> ##### Traits

>

> **_Life Bond._** When you regain Hit Points from a level 1+ spell, the steed regains the same number of Hit Points if you're within 5 feet of it.

>

> ##### Actions

>

> **_.Otherworldly Slam. Melee Attack Roll:_** Bonus equals your spell attack modifier, reach 5 ft. *Hit:* 1d8 plus the spell's level of Radiant (Celestial), Psychic (Fey), or Necrotic (Fiend) damage.

>

> ##### Bonus Actions

>

> **_Fell Glare (Fiend Only; Recharges after a Long Rest)._** *Wisdom Saving Throw:* DC equals your spell save DC, one creature within 60 feet the steed can see. *Failure:* The target has the Frightened condition until the end of your next turn.

>

> **_Fey Step (Fey Only; Recharges after a Long Rest)._** The steed teleports, along with its rider, to an unoccupied space of your choice up to 60 feet away from itself.

>

> **Healing Touch (Celestial Only; Recharges after a Long Rest)._** One creature within 5 feet of the steed regains a number of Hit Points equal to 2d8 plus the spell's level.
`,
      "Find-the-Path.md": `---
smType: spell
name: "Find the Path"
level: 6
school: "Divination"
casting_time: "1 minute"
range: "Self"
components: ["V", "S", "M"]
materials: "a set of divination tools\u2014such as cards or runes\u2014worth 100+ GP"
duration: "Concentration, up to 1 day"
concentration: true
classes: ["Bard", "Cleric", "Druid"]
---

# Find the Path
Level 6 Divination

- Casting Time: 1 minute
- Range: Self
- Components: V, S, M (a set of divination tools\u2014such as cards or runes\u2014worth 100+ GP)
- Duration: Concentration, up to 1 day
- Concentration: yes
- Classes: Bard, Cleric, Druid

You magically sense the most direct physical route to a location you name. You must be familiar with the location, and the spell fails if you name a destination on another plane of existence, a moving destination (such as a mobile fortress), or an unspecific destination (such as "a green dragon's lair").

For the duration, as long as you are on the same plane of existence as the destination, you know how far it is and in what direction it lies. Whenever you face a choice of paths along the way there, you know which path is the most direct.
`,
      "Find-Traps.md": `---
smType: spell
name: "Find Traps"
level: 2
school: "Divination"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric", "Druid", "Ranger"]
---

# Find Traps
Level 2 Divination

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric, Druid, Ranger

You sense any trap within range that is within line of sight. A trap, for the purpose of this spell, includes any object or mechanism that was created to cause damage or other danger. Thus, the spell would sense the *Alarm* or *Glyph of Warding* spell or a mechanical pit trap, but it wouldn't reveal a natural weakness in the floor, an unstable ceiling, or a hidden sinkhole.

This spell reveals that a trap is present but not its location. You do learn the general nature of the danger posed by a trap you sense.
`,
      "Finger-of-Death.md": `---
smType: spell
name: "Finger of Death"
level: 7
school: "Necromancy"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Warlock", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "7d8 + 30"
damage_type: "Necrotic"
---

# Finger of Death
Level 7 Necromancy

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Warlock, Wizard
- Save: CON (Half damage on success)
- Damage: 7d8 + 30 Necrotic

You unleash negative energy toward a creature you can see within range. The target makes a Constitution saving throw, taking 7d8 + 30 Necrotic damage on a failed save or half as much damage on a successful one.

A Humanoid killed by this spell rises at the start of your next turn as a **Zombie** (see "Monsters") that follows your verbal orders.
`,
      "Fire-Bolt.md": `---
smType: spell
name: "Fire Bolt"
level: 0
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
attack: "ranged spell attack"
damage: "1d10"
damage_type: "Fire"
---

# Fire Bolt
Cantrip Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Attack: ranged spell attack
- Damage: 1d10 Fire

You hurl a mote of fire at a creature or an object within range. Make a ranged spell attack against the target. On a hit, the target takes 1d10 Fire damage. A flammable object hit by this spell starts burning if it isn't being worn or carried.
`,
      "Fire-Shield.md": `---
smType: spell
name: "Fire Shield"
level: 4
school: "Evocation"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a bit of phosphorus or a firefly"
duration: "10 minutes"
classes: ["Druid", "Sorcerer", "Wizard"]
damage: "2d8"
damage_type: "Fire"
---

# Fire Shield
Level 4 Evocation

- Casting Time: Action
- Range: Self
- Components: V, S, M (a bit of phosphorus or a firefly)
- Duration: 10 minutes
- Classes: Druid, Sorcerer, Wizard
- Damage: 2d8 Fire

Wispy flames wreathe your body for the duration, shedding Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.

The flames provide you with a warm shield or a chill shield, as you choose. The warm shield grants you Resistance to Cold damage, and the chill shield grants you Resistance to Fire damage.

In addition, whenever a creature within 5 feet of you hits you with a melee attack roll, the shield erupts with flame. The attacker takes 2d8 Fire damage from a warm shield or 2d8 Cold damage from a chill shield.
`,
      "Fire-Storm.md": `---
smType: spell
name: "Fire Storm"
level: 7
school: "Evocation"
casting_time: "Action"
range: "150 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric", "Druid", "Sorcerer"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "7d10"
damage_type: "Fire"
---

# Fire Storm
Level 7 Evocation

- Casting Time: Action
- Range: 150 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric, Druid, Sorcerer
- Save: DEX (Half damage on success)
- Damage: 7d10 Fire

A storm of fire appears within range. The area of the storm consists of up to ten 10-foot Cubes, which you arrange as you like. Each Cube must be contiguous with at least one other Cube. Each creature in the area makes a Dexterity saving throw, taking 7d10 Fire damage on a failed save or half as much damage on a successful one.

Flammable objects in the area that aren't being worn or carried start burning.
`,
      "Fireball.md": `---
smType: spell
name: "Fireball"
level: 3
school: "Evocation"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "a ball of bat guano and sulfur"
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "8d6"
damage_type: "Fire"
---

# Fireball
Level 3 Evocation

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (a ball of bat guano and sulfur)
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 8d6 Fire

A bright streak flashes from you to a point you choose within range and then blossoms with a low roar into a fiery explosion. Each creature in a 20-foot-radius Sphere centered on that point makes a Dexterity saving throw, taking 8d6 Fire damage on a failed save or half as much damage on a successful one.

Flammable objects in the area that aren't being worn or carried start burning.

**Using a Higher-Level Spell Slot._** The damage increases by 1d6 for each spell slot level above 3.
`,
      "Flame-Blade.md": `---
smType: spell
name: "Flame Blade"
level: 2
school: "Evocation"
casting_time: "Bonus Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a sumac leaf"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid", "Sorcerer"]
attack: "melee spell attack"
---

# Flame Blade
Level 2 Evocation

- Casting Time: Bonus Action
- Range: Self
- Components: V, S, M (a sumac leaf)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid, Sorcerer
- Attack: melee spell attack

You evoke a fiery blade in your free hand. The blade is similar in size and shape to a scimitar, and it lasts for the duration. If you let go of the blade, it disappears, but you can evoke it again as a Bonus Action.

As a Magic action, you can make a melee spell attack with the fiery blade. On a hit, the target takes Fire damage equal to 3d6 plus your spellcasting ability modifier.

The flaming blade sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.
`,
      "Flame-Strike.md": `---
smType: spell
name: "Flame Strike"
level: 5
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a pinch of sulfur"
duration: "Instantaneous"
classes: ["Cleric"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "5d6"
damage_type: "Fire"
---

# Flame Strike
Level 5 Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a pinch of sulfur)
- Duration: Instantaneous
- Classes: Cleric
- Save: DEX (Half damage on success)
- Damage: 5d6 Fire

A vertical column of brilliant fire roars down from above. Each creature in a 10-foot-radius, 40-foothigh Cylinder centered on a point within range makes a Dexterity saving throw, taking 5d6 Fire damage and 5d6 Radiant damage on a failed save or half as much damage on a successful one.
`,
      "Flaming-Sphere.md": `---
smType: spell
name: "Flaming Sphere"
level: 2
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a ball of wax"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "2d6"
damage_type: "Fire"
---

# Flaming Sphere
Level 2 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a ball of wax)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 2d6 Fire

You create a 5-foot-diameter sphere of fire in an unoccupied space on the ground within range. It lasts for the duration. Any creature that ends its turn within 5 feet of the sphere makes a Dexterity saving throw, taking 2d6 Fire damage on a failed save or half as much damage on a successful one.

As a Bonus Action, you can move the sphere up to 30 feet, rolling it along the ground. If you move the sphere into a creature's space, that creature makes the save against the sphere, and the sphere stops moving for the turn.

When you move the sphere, you can direct it over barriers up to 5 feet tall and jump it across pits up to 10 feet wide. Flammable objects that aren't being worn or carried start burning if touched by the sphere, and it sheds Bright Light in a 20-foot radius and Dim Light for an additional 20 feet.
`,
      "Flesh-to-Stone.md": `---
smType: spell
name: "Flesh to Stone"
level: 6
school: "Transmutation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a cockatrice feather"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "CON"
---

# Flesh to Stone
Level 6 Transmutation

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a cockatrice feather)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Sorcerer, Wizard
- Save: CON

You attempt to turn one creature that you can see within range into stone. The target makes a Constitution saving throw. On a failed save, it has the Restrained condition for the duration. On a successful save, its Speed is 0 until the start of your next turn. Constructs automatically succeed on the save.

A Restrained target makes another Constitution saving throw at the end of each of its turns. If it successfully saves against this spell three times, the spell ends. If it fails its saves three times, it is turned to stone and has the Petrified condition for the duration. The successes and failures needn't be consecutive; keep track of both until the target collects three of a kind.

If you maintain your Concentration on this spell for the entire possible duration, the target is Petrified until the condition is ended by *Greater Restoration* or similar magic.
`,
      "Floating-Disk.md": `---
smType: spell
name: "Floating Disk"
level: 1
school: "Conjuration"
casting_time: "Action or Ritual"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a drop of mercury"
duration: "1 hour"
ritual: true
classes: ["Wizard"]
---

# Floating Disk
Level 1 Conjuration

- Casting Time: Action or Ritual
- Range: 30 feet
- Components: V, S, M (a drop of mercury)
- Duration: 1 hour
- Ritual: yes
- Classes: Wizard

This spell creates a circular, horizontal plane of force, 3 feet in diameter and 1 inch thick, that floats 3 feet above the ground in an unoccupied space of your choice that you can see within range. The disk remains for the duration and can hold up to 500 pounds. If more weight is placed on it, the spell ends, and everything on the disk falls to the ground.

The disk is immobile while you are within 20 feet of it. If you move more than 20 feet away from it, the disk follows you so that it remains within 20 feet of you. It can move across uneven terrain, up or down stairs, slopes and the like, but it can't cross an elevation change of 10 feet or more. For example, the disk can't move across a 10-foot-deep pit, nor could it leave such a pit if it was created at the bottom.

If you move more than 100 feet from the disk (typically because it can't move around an obstacle to follow you), the spell ends.
`,
      "Fly.md": `---
smType: spell
name: "Fly"
level: 3
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a feather"
duration: "Concentration, up to 10 minutes You touch a willing creature. For the duration, the target gains a Fly Speed of 60 feet and can hover. When the spell ends, the target falls if it is still aloft unless it can stop the fall."
concentration: true
classes: ["Sorcerer", "Warlock", "Wizard"]
---

# Fly
Level 3 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a feather)
- Duration: Concentration, up to 10 minutes You touch a willing creature. For the duration, the target gains a Fly Speed of 60 feet and can hover. When the spell ends, the target falls if it is still aloft unless it can stop the fall.
- Concentration: yes
- Classes: Sorcerer, Warlock, Wizard
`,
      "Fog-Cloud.md": `---
smType: spell
name: "Fog Cloud"
level: 1
school: "Conjuration"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Druid", "Ranger", "Sorcerer", "Wizard"]
---

# Fog Cloud
Level 1 Conjuration

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Druid, Ranger, Sorcerer, Wizard

You create a 20-foot-radius Sphere of fog centered on a point within range. The Sphere is Heavily Obscured. It lasts for the duration or until a strong wind (such as one created by *Gust of Wind*) disperses it.
`,
      "Forbiddance.md": `---
smType: spell
name: "Forbiddance"
level: 6
school: "Abjuration"
casting_time: "10 minutes or Ritual"
range: "Touch"
components: ["V", "S", "M"]
materials: "ruby dust worth 1,000+ GP"
duration: "1 day"
ritual: true
classes: ["Cleric"]
---

# Forbiddance
Level 6 Abjuration

- Casting Time: 10 minutes or Ritual
- Range: Touch
- Components: V, S, M (ruby dust worth 1,000+ GP)
- Duration: 1 day
- Ritual: yes
- Classes: Cleric

You create a ward against magical travel that protects up to 40,000 square feet of floor space to a height of 30 feet above the floor. For the duration, creatures can't teleport into the area or use portals, such as those created by the *Gate* spell, to enter the area. The spell proofs the area against planar travel, and therefore prevents creatures from accessing the area by way of the Astral Plane, the Ethereal Plane, the Feywild, the Shadowfell, or the *Plane Shift* spell.

In addition, the spell damages types of creatures that you choose when you cast it. Choose one or more of the following: Aberrations, Celestials, Elementals, Fey, Fiends, and Undead. When a creature of a chosen type enters the spell's area for the first time on a turn or ends its turn there, the creature takes 5d10 Radiant or Necrotic damage (your choice when you cast this spell).

You can designate a password when you cast the spell. A creature that speaks the password as it enters the area takes no damage from the spell.

The spell's area can't overlap with the area of another *Forbiddance* spell. If you cast *Forbiddance* every day for 30 days in the same location, the spell lasts until it is dispelled, and the Material components are consumed on the last casting.
`,
      "Forcecage.md": `---
smType: spell
name: "Forcecage"
level: 7
school: "Evocation"
casting_time: "Action **Range:** 100 feet **Components:** V, S, M (ruby dust worth 1,500+ GP, which the spell consumes) **Duration:** Concentration, up to 1 hour"
classes: ["Bard", "Warlock", "Wizard"]
---

# Forcecage
Level 7 Evocation

- Casting Time: Action **Range:** 100 feet **Components:** V, S, M (ruby dust worth 1,500+ GP, which the spell consumes) **Duration:** Concentration, up to 1 hour
- Classes: Bard, Warlock, Wizard
`,
      "Foresight.md": `---
smType: spell
name: "Foresight"
level: 9
school: "Divination"
casting_time: "1 minute"
range: "Touch"
components: ["V", "S", "M"]
materials: "a hummingbird feather"
duration: "8 hours"
classes: ["Bard", "Druid", "Warlock", "Wizard"]
---

# Foresight
Level 9 Divination

- Casting Time: 1 minute
- Range: Touch
- Components: V, S, M (a hummingbird feather)
- Duration: 8 hours
- Classes: Bard, Druid, Warlock, Wizard

You touch a willing creature and bestow a limited ability to see into the immediate future. For the duration, the target has Advantage on D20 Tests, and other creatures have Disadvantage on attack rolls against it. The spell ends early if you cast it again.
`,
      "Freedom-of-Movement.md": `---
smType: spell
name: "Freedom of Movement"
level: 4
school: "Abjuration"
casting_time: "Action"
range: "300 feet"
components: ["V", "S", "M"]
materials: "a miniature crystal sphere"
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid", "Ranger"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "10d6"
damage_type: "Cold"
---

# Freedom of Movement
Level 4 Abjuration

- Casting Time: Action
- Range: 300 feet
- Components: V, S, M (a miniature crystal sphere)
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid, Ranger
- Save: CON (Half damage on success)
- Damage: 10d6 Cold

A frigid globe streaks from you to a point of your choice within range, where it explodes in a 60-foot-radius Sphere. Each creature in that area makes a Constitution saving throw, taking 10d6 Cold damage on failed save or half as much damage on a successful one.

If the globe strikes a body of water, it freezes the water to a depth of 6 inches over an area 30 feet square. This ice lasts for 1 minute. Creatures that were swimming on the surface of frozen water are trapped in the ice and have the Restrained condition. A trapped creature can take an action to make a Strength (Athletics) check against your spell save DC to break free.

You can refrain from firing the globe after completing the spell's casting. If you do so, a globe about the size of a sling bullet, cool to the touch, appears in your hand. At any time, you or a creature you give the globe to can throw the globe (to a range of 40 feet) or hurl it with a sling (to the sling's normal range). It shatters on impact, with the same effect as a normal casting of the spell. You can also set the globe down without shattering it. After 1 minute, if the globe hasn't already shattered, it explodes.

*Using a Higher-Level Spell Slot.* The damage increases by 1d6 for each spell slot level above 6.

### G Spells
`,
      "Gaseous-Form.md": `---
smType: spell
name: "Gaseous Form"
level: 3
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a bit of gauze"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Sorcerer", "Warlock", "Wizard"]
save_ability: "CON"
---

# Gaseous Form
Level 3 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a bit of gauze)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Sorcerer, Warlock, Wizard
- Save: CON

A willing creature you touch shape-shifts, along with everything it's wearing and carrying, into a misty cloud for the duration. The spell ends on the target if it drops to 0 Hit Points or if it takes a Magic action to end the spell on itself.

While in this form, the target's only method of movement is a Fly Speed of 10 feet, and it can hover. The target can enter and occupy the space of another creature. The target has Resistance to Bludgeoning, Piercing, and Slashing damage; it has Immunity to the Prone condition; and it has Advantage on Strength, Dexterity, and Constitution saving throws. The target can pass through narrow openings, but it treats liquids as though they were solid surfaces.

The target can't talk or manipulate objects, and any objects it was carrying or holding can't be dropped, used, or otherwise interacted with. Finally, the target can't attack or cast spells.
`,
      "Gate.md": `---
smType: spell
name: "Gate"
level: 9
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a diamond worth 5,000+ GP"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric", "Sorcerer", "Warlock", "Wizard"]
---

# Gate
Level 9 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a diamond worth 5,000+ GP)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric, Sorcerer, Warlock, Wizard

You conjure a portal linking an unoccupied space you can see within range to a precise location on a different plane of existence. The portal is a circular opening, which you can make 5 to 20 feet in diameter. You can orient the portal in any direction you choose. The portal lasts for the duration, and the portal's destination is visible through it.

The portal has a front and a back on each plane where it appears. Travel through the portal is possible only by moving through its front. Anything that does so is instantly transported to the other plane, appearing in the unoccupied space nearest to the portal.

Deities and other planar rulers can prevent portals created by this spell from opening in their presence or anywhere within their domains.

When you cast this spell, you can speak the name of a specific creature (a pseudonym, title, or nickname doesn't work). If that creature is on a plane other than the one you are on, the portal opens next to the named creature and transports it to the nearest unoccupied space on your side of the portal. You gain no special power over the creature, and it is free to act as the GM deems appropriate. It might leave, attack you, or help you.
`,
      "Geas.md": `---
smType: spell
name: "Geas"
level: 5
school: "Enchantment"
casting_time: "1 minute"
range: "60 feet"
components: ["V"]
duration: "30 days"
classes: ["Bard", "Cleric", "Druid", "Paladin", "Wizard"]
save_ability: "WIS"
damage: "5d10"
damage_type: "Psychic"
---

# Geas
Level 5 Enchantment

- Casting Time: 1 minute
- Range: 60 feet
- Components: V
- Duration: 30 days
- Classes: Bard, Cleric, Druid, Paladin, Wizard
- Save: WIS
- Damage: 5d10 Psychic

You give a verbal command to a creature that you can see within range, ordering it to carry out some service or refrain from an action or a course of activity as you decide. The target must succeed on a Wisdom saving throw or have the Charmed condition for the duration. The target automatically succeeds if it can't understand your command.

While Charmed, the creature takes 5d10 Psychic damage if it acts in a manner directly counter to your command. It takes this damage no more than once each day.

You can issue any command you choose, short of an activity that would result in certain death. Should you issue a suicidal command, the spell ends.

A *Remove Curse*, *Greater Restoration*, or *Wish* spell ends this spell.
`,
      "Gentle-Repose.md": `---
smType: spell
name: "Gentle Repose"
level: 2
school: "Necromancy"
casting_time: "Action or Ritual"
range: "Touch"
components: ["V", "S", "M"]
materials: "2 Copper Pieces, which the spell consumes"
duration: "10 days"
ritual: true
classes: ["Cleric", "Paladin", "Wizard"]
---

# Gentle Repose
Level 2 Necromancy

- Casting Time: Action or Ritual
- Range: Touch
- Components: V, S, M (2 Copper Pieces, which the spell consumes)
- Duration: 10 days
- Ritual: yes
- Classes: Cleric, Paladin, Wizard

You touch a corpse or other remains. For the duration, the target is protected from decay and can't become Undead.

The spell also effectively extends the time limit on raising the target from the dead, since days spent under the influence of this spell don't count against the time limit of spells such as *Raise Dead*.
`,
      "Giant-Insect.md": `---
smType: spell
name: "Giant Insect"
level: 4
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid"]
---

# Giant Insect
Level 4 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid

You summon a giant centipede, spider, or wasp (chosen when you cast the spell). It manifests in an unoccupied space you can see within range and uses the **Giant Insect** stat block. The form you choose determines certain details in its stat block. The creature disappears when it drops to 0 Hit Points or when the spell ends.

The creature is an ally to you and your allies. In combat, the creature shares your Initiative count, but it takes its turn immediately after yours. It obeys your verbal commands (no action required by you). If you don't issue any, it takes the Dodge action and uses its movement to avoid danger.

## At Higher Levels

> #### Giant Insect

>

> *Large Beast, Unaligned*

>

> **AC** 11 + the spell's level

>

> **HP** 30 + 10 for each spell level above 4

>

> **Speed** 40 ft., Climb 40 ft., Fly 40 ft. (Wasp only)

>

> | Attribute | Score | Mod | Save |

> |-----------|-------|-----|------|

> | Str       | 17    | +3  | +3   |

> | Dex       | 13    | +1  | +1   |

> | Con       | 15    | +2  | +2   |

> | Int       | 4     | -3  | -3   |

> | Wis       | 14    | +2  | +2   |

> | Cha       | 3     | -4  | -4   |

>

> **Senses** Darkvision 60 ft.; Passive Perception 12

>

> **Languages** Understands the languages you know

>

> **CR** None (XP 0; PB equals your Proficiency Bonus)

>

> ##### Traits

>

> **_Spider Climb._** The insect can climb difficult surfaces, including along ceilings, without needing to make an ability check.

>

> ##### Actions

>

> **_Multiattack._** The insect makes a number of attacks equal to half this spell's level (round down).

>

> **_Poison Jab. Melee Attack Roll:_** Bonus equals your spell attack modifier, reach 10 ft. *Hit:* 1d6 + 3 plus the spell's level Piercing damage plus 1d4 Poison damage.

>

> **Web Bolt (Spider Only). Ranged Attack Roll:_** Bonus equals your spell attack modifier, range 60 ft. *Hit:* 1d10 + 3 plus the spell's level Bludgeoning damage, and the target's Speed is reduced to 0 until the start of the insect's next turn.

>

> ##### Bonus Actions

>

> **Venomous Spew (Centipede Only). Constitution Saving Throw:_** Your spell save DC, one creature the insect can see within 10 feet. *Failure:* The target has the Poisoned condition until the start of the insect's next turn.
`,
      "Glibness.md": `---
smType: spell
name: "Glibness"
level: 8
school: "Enchantment"
casting_time: "Action"
range: "Self"
components: ["V"]
duration: "1 hour"
classes: ["Bard", "Warlock"]
---

# Glibness
Level 8 Enchantment

- Casting Time: Action
- Range: Self
- Components: V
- Duration: 1 hour
- Classes: Bard, Warlock

Until the spell ends, when you make a Charisma check, you can replace the number you roll with a 15. Additionally, no matter what you say, magic that would determine if you are telling the truth indicates that you are being truthful.
`,
      "Globe-of-Invulnerability.md": `---
smType: spell
name: "Globe of Invulnerability"
level: 6
school: "Abjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a glass bead"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Sorcerer", "Wizard"]
---

# Globe of Invulnerability
Level 6 Abjuration

- Casting Time: Action
- Range: Self
- Components: V, S, M (a glass bead)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Sorcerer, Wizard

An immobile, shimmering barrier appears in a 10 foot Emanation around you and remains for the duration.

Any spell of level 5 or lower cast from outside the barrier can't affect anything within it. Such a spell can target creatures and objects within the barrier, but the spell has no effect on them. Similarly, the area within the barrier is excluded from areas of effect created by such spells.
`,
      "Glyph-of-Warding.md": `---
smType: spell
name: "Glyph of Warding"
level: 3
school: "Abjuration"
casting_time: "1 hour"
range: "Touch"
components: ["V", "S", "M"]
materials: "powdered diamond worth 200+ GP, which the spell consumes"
duration: "Until dispelled or triggered"
classes: ["Bard", "Cleric", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
---

# Glyph of Warding
Level 3 Abjuration

- Casting Time: 1 hour
- Range: Touch
- Components: V, S, M (powdered diamond worth 200+ GP, which the spell consumes)
- Duration: Until dispelled or triggered
- Classes: Bard, Cleric, Wizard
- Save: DEX (Half damage on success)

You inscribe a glyph that later unleashes a magical effect. You inscribe it either on a surface (such as a table or a section of floor) or within an object that can be closed (such as a book or chest) to conceal the glyph. The glyph can cover an area no larger than 10 feet in diameter. If the surface or object is moved more than 10 feet from where you cast this spell, the glyph is broken, and the spell ends without being triggered.

The glyph is nearly imperceptible and requires a successful Wisdom (Perception) check against your spell save DC to notice.

When you inscribe the glyph, you set its trigger and choose whether it's an explosive rune or a spell glyph, as explained below.

**_Set the Trigger._** You decide what triggers the glyph when you cast the spell. For glyphs inscribed on a surface, common triggers include touching or stepping on the glyph, removing another object covering it, or approaching within a certain distance of it. For glyphs inscribed within an object, common triggers include opening that object or seeing the glyph. Once a glyph is triggered, this spell ends.

You can refine the trigger so that only creatures of certain types activate it (for example, the glyph could be set to affect Aberrations). You can also set conditions for creatures that don't trigger the glyph, such as those who say a certain password.

**_Explosive Rune._** When triggered, the glyph erupts with magical energy in a 20-foot-radius Sphere centered on the glyph. Each creature in the area makes a Dexterity saving throw. A creature takes 5d8 Acid, Cold, Fire, Lightning, or Thunder damage (your choice when you create the glyph) on a failed save or half as much damage on a successful one.

**_Spell Glyph._** You can store a prepared spell of level 3 or lower in the glyph by casting it as part of creating the glyph. The spell must target a single creature or an area. The spell being stored has no immediate effect when cast in this way.

When the glyph is triggered, the stored spell takes effect. If the spell has a target, it targets the creature that triggered the glyph. If the spell affects an area, the area is centered on that creature. If the spell summons Hostile creatures or creates harmful objects or traps, they appear as close as possible to the intruder and attack it. If the spell requires Concentration, it lasts until the end of its full duration.
`,
      "Goodberry.md": `---
smType: spell
name: "Goodberry"
level: 1
school: "Conjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a sprig of mistletoe"
duration: "24 hours"
classes: ["Druid", "Ranger"]
---

# Goodberry
Level 1 Conjuration

- Casting Time: Action
- Range: Self
- Components: V, S, M (a sprig of mistletoe)
- Duration: 24 hours
- Classes: Druid, Ranger

Ten berries appear in your hand and are infused with magic for the duration. A creature can take a Bonus Action to eat one berry. Eating a berry restores 1 Hit Point, and the berry provides enough nourishment to sustain a creature for one day.

Uneaten berries disappear when the spell ends.
`,
      "Grease.md": `---
smType: spell
name: "Grease"
level: 1
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a bit of pork rind or butter"
duration: "1 minute"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
---

# Grease
Level 1 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a bit of pork rind or butter)
- Duration: 1 minute
- Classes: Sorcerer, Wizard
- Save: DEX

Nonflammable grease covers the ground in a 10 foot square centered on a point within range and turns it into Difficult Terrain for the duration.

When the grease appears, each creature standing in its area must succeed on a Dexterity saving throw or have the Prone condition. A creature that enters the area or ends its turn there must also succeed on that save or fall Prone.
`,
      "Greater-Invisibility.md": `---
smType: spell
name: "Greater Invisibility"
level: 4
school: "Illusion"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Concentration, up to 1 minute A creature you touch has the Invisible condition until the spell ends."
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
---

# Greater Invisibility
Level 4 Illusion

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Concentration, up to 1 minute A creature you touch has the Invisible condition until the spell ends.
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard
`,
      "Greater-Restoration.md": `---
smType: spell
name: "Greater Restoration"
level: 5
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "diamond dust worth 100+ GP, which the spell consumes"
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger"]
---

# Greater Restoration
Level 5 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S, M (diamond dust worth 100+ GP, which the spell consumes)
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid, Paladin, Ranger

You touch a creature and magically remove one of the following effects from it:

- 1 Exhaustion level

- The Charmed or Petrified condition

- A curse, including the target's Attunement to a cursed magic item

- Any reduction to one of the target's ability scores

- Any reduction to the target's Hit Point maximum
`,
      "Guardian-of-Faith.md": `---
smType: spell
name: "Guardian of Faith"
level: 4
school: "Conjuration"
casting_time: "Action"
range: "30 feet"
components: ["V"]
duration: "8 hours"
classes: ["Cleric"]
save_ability: "DEX"
save_effect: "Half damage on success"
---

# Guardian of Faith
Level 4 Conjuration

- Casting Time: Action
- Range: 30 feet
- Components: V
- Duration: 8 hours
- Classes: Cleric
- Save: DEX (Half damage on success)

A Large spectral guardian appears and hovers for the duration in an unoccupied space that you can see within range. The guardian occupies that space and is invulnerable, and it appears in a form appropriate for your deity or pantheon.

Any enemy that moves to a space within 10 feet of the guardian for the first time on a turn or starts its turn there makes a Dexterity saving throw, taking 20 Radiant damage on a failed save or half as much damage on a successful one. The guardian vanishes when it has dealt a total of 60 damage.
`,
      "Guards-and-Wards.md": `---
smType: spell
name: "Guards and Wards"
level: 6
school: "Abjuration"
casting_time: "1 hour"
range: "Touch"
components: ["V", "S", "M"]
materials: "a silver rod worth 10+ GP"
duration: "24 hours"
classes: ["Bard", "Wizard"]
---

# Guards and Wards
Level 6 Abjuration

- Casting Time: 1 hour
- Range: Touch
- Components: V, S, M (a silver rod worth 10+ GP)
- Duration: 24 hours
- Classes: Bard, Wizard

You create a ward that protects up to 2,500 square feet of floor space. The warded area can be up to 20 feet tall, and you shape it as one 50-foot square, one hundred 5-foot squares that are contiguous, or twenty-five 10-foot squares that are contiguous.

When you cast this spell, you can specify individuals that are unaffected by the spell's effects. You can also specify a password that, when spoken aloud within 5 feet of the warded area, makes the speaker immune to its effects.

The spell creates the effects below within the warded area. *Dispel Magic* has no effect on *Guards and Wards* itself, but each of the following effects can be dispelled. If all four are dispelled, *Guards and Wards* ends. If you cast the spell every day for 365 days on the same area, the spell thereafter lasts until all its effects are dispelled.

**_Corridors._** Fog fills all the warded corridors, making them Heavily Obscured. In addition, at each intersection or branching passage offering a choice of direction, there is a 50 percent chance that a creature other than you believes it is going in the opposite direction from the one it chooses.

**_Doors._** All doors in the warded area are magically locked, as if sealed by the *Arcane Lock* spell. In addition, you can cover up to ten doors with an illusion to make them appear as plain sections of wall.

**_Stairs._** Webs fill all stairs in the warded area from top to bottom, as in the *Web* spell. These strands regrow in 10 minutes if they are destroyed while *Guards and Wards* lasts.

**_Other Spell Effect._** Place one of the following magical effects within the warded area:

- *Dancing Lights* in four corridors, with a simple program that the lights repeat as long as *Guards and Wards* lasts

- *Magic Mouth* in two locations

- *Stinking Cloud* in two locations (the vapors return within 10 minutes if dispersed while *Guards and Wards* lasts)

- *Gust of Wind* in one corridor or room (the wind blows continuously while the spell lasts)

- *Suggestion* in one 5-foot square; any creature that enters that square receives the suggestion mentally
`,
      "Guidance.md": `---
smType: spell
name: "Guidance"
level: 0
school: "Divination"
casting_time: "Action"
range: "Touch"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric", "Druid"]
---

# Guidance
Cantrip Divination

- Casting Time: Action
- Range: Touch
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric, Druid

You touch a willing creature and choose a skill. Until the spell ends, the creature adds 1d4 to any ability check using the chosen skill.
`,
      "Guiding-Bolt.md": `---
smType: spell
name: "Guiding Bolt"
level: 1
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "1 round"
classes: ["Cleric"]
attack: "ranged spell attack"
damage: "4d6"
damage_type: "Radiant"
---

# Guiding Bolt
Level 1 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: 1 round
- Classes: Cleric
- Attack: ranged spell attack
- Damage: 4d6 Radiant

You hurl a bolt of light toward a creature within range. Make a ranged spell attack against the target. On a hit, it takes 4d6 Radiant damage, and the next attack roll made against it before the end of your next turn has Advantage.
`,
      "Gust-of-Wind.md": `---
smType: spell
name: "Gust of Wind"
level: 2
school: "Evocation"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a legume seed"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Ranger", "Sorcerer", "Wizard"]
save_ability: "STR"
---

# Gust of Wind
Level 2 Evocation

- Casting Time: Action
- Range: Self
- Components: V, S, M (a legume seed)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Ranger, Sorcerer, Wizard
- Save: STR

A Line of strong wind 60 feet long and 10 feet wide blasts from you in a direction you choose for the duration. Each creature in the Line must succeed on a Strength saving throw or be pushed 15 feet away from you in a direction following the Line. A creature that ends its turn in the Line must make the same save.

Any creature in the Line must spend 2 feet of movement for every 1 foot it moves when moving closer to you.

The gust disperses gas or vapor, and it extinguishes candles and similar unprotected flames in the area. It causes protected flames, such as those of lanterns, to dance wildly and has a 50 percent chance to extinguish them.

As a Bonus Action on your later turns, you can change the direction in which the Line blasts from you.

### H Spells
`,
      "Hallow.md": `---
smType: spell
name: "Hallow"
level: 5
school: "Abjuration"
casting_time: "24 hours"
range: "Touch"
components: ["V", "S", "M"]
materials: "incense worth 1,000+ GP, which the spell consumes"
duration: "Until dispelled"
classes: ["Cleric"]
---

# Hallow
Level 5 Abjuration

- Casting Time: 24 hours
- Range: Touch
- Components: V, S, M (incense worth 1,000+ GP, which the spell consumes)
- Duration: Until dispelled
- Classes: Cleric

You touch a point and infuse an area around it with holy or unholy power. The area can have a radius up to 60 feet, and the spell fails if the radius includes an area already under the effect of *Hallow*. The affected area has the following effects.

**_Hallowed Ward._** Choose any of these creature types: Aberration, Celestial, Elemental, Fey, Fiend, or Undead. Creatures of the chosen types can't willingly enter the area, and any creature that is possessed by or that has the Charmed or Frightened condition from such creatures isn't possessed, Charmed, or Frightened by them while in the area.

**_Extra Effect._** You bind an extra effect to the area from the list below:

**_Courage._** Creatures of any types you choose can't gain the Frightened condition while in the area.

**_Darkness._** Darkness fills the area. Normal light, as well as magical light created by spells of a level lower than this spell, can't illuminate the area.

**_Daylight._** Bright light fills the area. Magical Darkness created by spells of a level lower than this spell can't extinguish the light.

**_Peaceful Rest._** Dead bodies interred in the area can't be turned into Undead.

**_Extradimensional Interference._** Creatures of any types you choose can't enter or exit the area using teleportation or interplanar travel.

**_Fear._** Creatures of any types you choose have the Frightened condition while in the area.

**_Resistance._** Creatures of any types you choose have Resistance to one damage type of your choice while in the area.

**_Silence._** No sound can emanate from within the area, and no sound can reach into it.

**_Tongues._** Creatures of any types you choose can communicate with any other creature in the area even if they don't share a common language.

**_Vulnerability._** Creatures of any types you choose have Vulnerability to one damage type of your choice while in the area.
`,
      "Hallucinatory-Terrain.md": `---
smType: spell
name: "Hallucinatory Terrain"
level: 4
school: "Illusion"
casting_time: "10 minutes"
range: "300 feet"
components: ["V", "S", "M"]
materials: "a mushroom"
duration: "24 hours"
classes: ["Bard", "Druid", "Warlock", "Wizard"]
---

# Hallucinatory Terrain
Level 4 Illusion

- Casting Time: 10 minutes
- Range: 300 feet
- Components: V, S, M (a mushroom)
- Duration: 24 hours
- Classes: Bard, Druid, Warlock, Wizard

You make natural terrain in a 150-foot Cube in range look, sound, and smell like another sort of natural terrain. Thus, open fields or a road can be made to resemble a swamp, hill, crevasse, or some other difficult or impassable terrain. A pond can be made to seem like a grassy meadow, a precipice like a gentle slope, or a rock-strewn gully like a wide and smooth road. Manufactured structures, equipment, and creatures within the area aren't changed.

The tactile characteristics of the terrain are unchanged, so creatures entering the area are likely to notice the illusion. If the difference isn't obvious by touch, a creature examining the illusion can take the Study action to make an Intelligence (Investigation) check against your spell save DC to disbelieve it. If a creature discerns that the terrain is illusory, the creature sees a vague image superimposed on the real terrain.
`,
      "Harm.md": `---
smType: spell
name: "Harm"
level: 6
school: "Necromancy"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "14d6"
damage_type: "Necrotic"
---

# Harm
Level 6 Necromancy

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric
- Save: CON (Half damage on success)
- Damage: 14d6 Necrotic

You unleash virulent magic on a creature you can see within range. The target makes a Constitution saving throw. On a failed save, it takes 14d6

Necrotic damage, and its Hit Point maximum is reduced by an amount equal to the Necrotic damage it took. On a successful save, it takes half as much damage only. This spell can't reduce a target's Hit Point maximum below 1.
`,
      "Haste.md": `---
smType: spell
name: "Haste"
level: 3
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a shaving of licorice root"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
---

# Haste
Level 3 Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a shaving of licorice root)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Sorcerer, Wizard
- Save: DEX

Choose a willing creature that you can see within range. Until the spell ends, the target's Speed is doubled, it gains a +2 bonus to Armor Class, it has Advantage on Dexterity saving throws, and it gains an additional action on each of its turns. That action can be used to take only the Attack (one attack only), Dash, Disengage, Hide, or Utilize action.

When the spell ends, the target is Incapacitated and has a Speed of 0 until the end of its next turn, as a wave of lethargy washes over it.
`,
      "Heal.md": `---
smType: spell
name: "Heal"
level: 6
school: "Abjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric", "Druid"]
---

# Heal
Level 6 Abjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric, Druid

Choose a creature that you can see within range. Positive energy washes through the target, restoring 70 Hit Points. This spell also ends the Blinded, Deafened, and Poisoned conditions on the target.
`,
      "Healing-Word.md": `---
smType: spell
name: "Healing Word"
level: 1
school: "Abjuration"
casting_time: "Bonus Action"
range: "60 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid"]
---

# Healing Word
Level 1 Abjuration

- Casting Time: Bonus Action
- Range: 60 feet
- Components: V
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid

A creature of your choice that you can see within range regains Hit Points equal to 2d4 plus your spellcasting ability modifier.
`,
      "Heat-Metal.md": `---
smType: spell
name: "Heat Metal"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a piece of iron and a flame"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Druid"]
save_ability: "CON"
damage: "2d8"
damage_type: "Fire"
---

# Heat Metal
Level 2 Transmutation

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a piece of iron and a flame)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Druid
- Save: CON
- Damage: 2d8 Fire

Choose a manufactured metal object, such as a metal weapon or a suit of Heavy or Medium metal armor, that you can see within range. You cause the object to glow red-hot. Any creature in physical contact with the object takes 2d8 Fire damage when you cast the spell. Until the spell ends, you can take a Bonus Action on each of your later turns to deal this damage again if the object is within range.

If a creature is holding or wearing the object and takes the damage from it, the creature must succeed on a Constitution saving throw or drop the object if it can. If it doesn't drop the object, it has Disadvantage on attack rolls and ability checks until the start of your next turn.
`,
      "Hellish-Rebuke.md": `---
smType: spell
name: "Hellish Rebuke"
level: 1
school: "Evocation"
casting_time: "Reaction, which you take in response to taking damage from a creature that you can see within 60 feet of yourself"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Warlock"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "2d10"
damage_type: "Fire"
---

# Hellish Rebuke
Level 1 Evocation

- Casting Time: Reaction, which you take in response to taking damage from a creature that you can see within 60 feet of yourself
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Warlock
- Save: DEX (Half damage on success)
- Damage: 2d10 Fire

The creature that damaged you is momentarily surrounded by green flames. It makes a Dexterity saving throw, taking 2d10 Fire damage on a failed save or half as much damage on a successful one.
`,
      "Heroes-Feast.md": `---
smType: spell
name: "Heroes' Feast"
level: 6
school: "Conjuration"
casting_time: "10 minutes"
range: "Self"
components: ["V", "S", "M"]
materials: "a gem-encrusted bowl worth 1,000+ GP, which the spell consumes"
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid"]
---

# Heroes' Feast
Level 6 Conjuration

- Casting Time: 10 minutes
- Range: Self
- Components: V, S, M (a gem-encrusted bowl worth 1,000+ GP, which the spell consumes)
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid

You conjure a feast that appears on a surface in an unoccupied 10-foot Cube next to you. The feast takes 1 hour to consume and disappears at the end of that time, and the beneficial effects don't set in until this hour is over. Up to twelve creatures can partake of the feast.

A creature that partakes gains several benefits, which last for 24 hours. The creature has Resistance to Poison damage, and it has Immunity to the Frightened and Poisoned conditions. Its Hit Point maximum also increases by 2d10, and it gains the same number of Hit Points.
`,
      "Heroism.md": `---
smType: spell
name: "Heroism"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Paladin"]
---

# Heroism
Level 1 Enchantment

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Paladin

A willing creature you touch is imbued with bravery. Until the spell ends, the creature is immune to the Frightened condition and gains Temporary Hit Points equal to your spellcasting ability modifier at the start of each of its turns.
`,
      "Hex.md": `---
smType: spell
name: "Hex"
level: 1
school: "Enchantment"
casting_time: "Bonus Action"
range: "90 feet"
components: ["V", "S", "M"]
materials: "the petrified eye of a newt"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Warlock"]
damage: "1d6"
damage_type: "Necrotic"
---

# Hex
Level 1 Enchantment

- Casting Time: Bonus Action
- Range: 90 feet
- Components: V, S, M (the petrified eye of a newt)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Warlock
- Damage: 1d6 Necrotic

You place a curse on a creature that you can see within range. Until the spell ends, you deal an extra 1d6 Necrotic damage to the target whenever you hit it with an attack roll. Also, choose one ability when you cast the spell. The target has Disadvantage on ability checks made with the chosen ability.

If the target drops to 0 Hit Points before this spell ends, you can take a Bonus Action on a later turn to curse a new creature.
`,
      "Hideous-Laughter.md": `---
smType: spell
name: "Hideous Laughter"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a tart and a feather"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Hideous Laughter
Level 1 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a tart and a feather)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Warlock, Wizard
- Save: WIS

One creature of your choice that you can see within range makes a Wisdom saving throw. On a failed save, it has the Prone and Incapacitated conditions for the duration. During that time, it laughs uncontrollably if it's capable of laughter, and it can't end the Prone condition on itself.

At the end of each of its turns and each time it takes damage, it makes another Wisdom saving throw. The target has Advantage on the save if the save is triggered by damage. On a successful save, the spell ends.
`,
      "Hold-Monster.md": `---
smType: spell
name: "Hold Monster"
level: 5
school: "Enchantment"
casting_time: "Action"
range: "90 feet"
components: ["V", "S", "M"]
materials: "a straight piece of iron"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Hold Monster
Level 5 Enchantment

- Casting Time: Action
- Range: 90 feet
- Components: V, S, M (a straight piece of iron)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Warlock, Wizard
- Save: WIS

Choose a creature that you can see within range. The target must succeed on a Wisdom saving throw or have the Paralyzed condition for the duration. At the end of each of its turns, the target repeats the save, ending the spell on itself on a success.
`,
      "Hold-Person.md": `---
smType: spell
name: "Hold Person"
level: 2
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a straight piece of iron"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Cleric", "Druid", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Hold Person
Level 2 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a straight piece of iron)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Cleric, Druid, Sorcerer, Warlock, Wizard
- Save: WIS

Choose a Humanoid that you can see within range. The target must succeed on a Wisdom saving throw or have the Paralyzed condition for the duration. At the end of each of its turns, the target repeats the save, ending the spell on itself on a success.
`,
      "Holy-Aura.md": `---
smType: spell
name: "Holy Aura"
level: 8
school: "Abjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a reliquary worth 1,000+ GP"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric"]
save_ability: "CON"
---

# Holy Aura
Level 8 Abjuration

- Casting Time: Action
- Range: Self
- Components: V, S, M (a reliquary worth 1,000+ GP)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric
- Save: CON

For the duration, you emit an aura in a 30-foot Emanation. While in the aura, creatures of your choice have Advantage on all saving throws, and other creatures have Disadvantage on attack rolls against them. In addition, when a Fiend or an Undead hits an affected creature with a melee attack roll, the attacker must succeed on a Constitution saving throw or have the Blinded condition until the end of its next turn.
`,
      "Hunter-s-Mark.md": `---
smType: spell
name: "Hunter's Mark"
level: 1
school: "Divination"
casting_time: "Bonus Action"
range: "90 feet"
components: ["V"]
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Ranger"]
damage: "1d6"
damage_type: "Force"
---

# Hunter's Mark
Level 1 Divination

- Casting Time: Bonus Action
- Range: 90 feet
- Components: V
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Ranger
- Damage: 1d6 Force

You magically mark one creature you can see within range as your quarry. Until the spell ends, you deal an extra 1d6 Force damage to the target whenever you hit it with an attack roll. You also have Advantage on any Wisdom (Perception or Survival) check you make to find it.

If the target drops to 0 Hit Points before this spell ends, you can take a Bonus Action to move the mark to a new creature you can see within range.
`,
      "Hypnotic-Pattern.md": `---
smType: spell
name: "Hypnotic Pattern"
level: 3
school: "Illusion"
casting_time: "Action"
range: "120 feet"
components: ["S", "M"]
materials: "a pinch of confetti"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Hypnotic Pattern
Level 3 Illusion

- Casting Time: Action
- Range: 120 feet
- Components: S, M (a pinch of confetti)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Warlock, Wizard
- Save: WIS

You create a twisting pattern of colors in a 30-foot Cube within range. The pattern appears for a moment and vanishes. Each creature in the area who can see the pattern must succeed on a Wisdom saving throw or have the Charmed condition for the duration. While Charmed, the creature has the Incapacitated condition and a Speed of 0.

The spell ends for an affected creature if it takes any damage or if someone else uses an action to shake the creature out of its stupor.

### I Spells
`,
      "Ice-Knife.md": `---
smType: spell
name: "Ice Knife"
level: 1
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["S", "M"]
materials: "a drop of water or a piece of ice"
duration: "Instantaneous"
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "DEX"
attack: "ranged spell attack"
damage: "1d10"
damage_type: "Piercing"
---

# Ice Knife
Level 1 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: S, M (a drop of water or a piece of ice)
- Duration: Instantaneous
- Classes: Druid, Sorcerer, Wizard
- Attack: ranged spell attack
- Save: DEX
- Damage: 1d10 Piercing

You create a shard of ice and fling it at one creature within range. Make a ranged spell attack against the target. On a hit, the target takes 1d10 Piercing damage. Hit or miss, the shard then explodes. The target and each creature within 5 feet of it must succeed on a Dexterity saving throw or take 2d6 Cold damage.
`,
      "Ice-Storm.md": `---
smType: spell
name: "Ice Storm"
level: 4
school: "Evocation"
casting_time: "Action"
range: "300 feet"
components: ["V", "S", "M"]
materials: "a mitten"
duration: "Instantaneous"
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "2d10"
damage_type: "Bludgeoning"
---

# Ice Storm
Level 4 Evocation

- Casting Time: Action
- Range: 300 feet
- Components: V, S, M (a mitten)
- Duration: Instantaneous
- Classes: Druid, Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 2d10 Bludgeoning

Hail falls in a 20-foot-radius, 40-foot-high Cylinder centered on a point within range. Each creature in the Cylinder makes a Dexterity saving throw. A creature takes 2d10 Bludgeoning damage and 4d6 Cold damage on a failed save or half as much damage on a successful one.

Hailstones turn ground in the Cylinder into Difficult Terrain until the end of your next turn.
`,
      "Identify.md": `---
smType: spell
name: "Identify"
level: 1
school: "Divination"
casting_time: "1 minute or Ritual"
range: "Touch"
components: ["V", "S", "M"]
materials: "a pearl worth 100+ GP"
duration: "Instantaneous"
ritual: true
classes: ["Bard", "Wizard"]
---

# Identify
Level 1 Divination

- Casting Time: 1 minute or Ritual
- Range: Touch
- Components: V, S, M (a pearl worth 100+ GP)
- Duration: Instantaneous
- Ritual: yes
- Classes: Bard, Wizard

You touch an object throughout the spell's casting. If the object is a magic item or some other magical object, you learn its properties and how to use them, whether it requires Attunement, and how many charges it has, if any. You learn whether any ongoing spells are affecting the item and what they are. If the item was created by a spell, you learn that spell's name.

If you instead touch a creature throughout the casting, you learn which ongoing spells, if any, are currently affecting it.
`,
      "Illusory-Script.md": `---
smType: spell
name: "Illusory Script"
level: 1
school: "Illusion"
casting_time: "1 minute or Ritual"
range: "Touch"
components: ["S", "M"]
materials: "ink worth 10+ GP, which the spell consumes"
duration: "10 days"
ritual: true
classes: ["Bard", "Warlock", "Wizard"]
---

# Illusory Script
Level 1 Illusion

- Casting Time: 1 minute or Ritual
- Range: Touch
- Components: S, M (ink worth 10+ GP, which the spell consumes)
- Duration: 10 days
- Ritual: yes
- Classes: Bard, Warlock, Wizard

You write on parchment, paper, or another suitable material and imbue it with an illusion that lasts for the duration. To you and any creatures you designate when you cast the spell, the writing appears normal, seems to be written in your hand, and conveys whatever meaning you intended when you wrote the text. To all others, the writing appears as if it were written in an unknown or magical script that is unintelligible. Alternatively, the illusion can alter the meaning, handwriting, and language of the text, though the language must be one you know.

If the spell is dispelled, the original script and the illusion both disappear.

A creature that has Truesight can read the hidden message.
`,
      "Imprisonment.md": `---
smType: spell
name: "Imprisonment"
level: 9
school: "Abjuration"
casting_time: "1 minute"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a statuette of the target worth 5,000+ GP"
duration: "Until dispelled"
classes: ["Warlock", "Wizard"]
save_ability: "WIS"
---

# Imprisonment
Level 9 Abjuration

- Casting Time: 1 minute
- Range: 30 feet
- Components: V, S, M (a statuette of the target worth 5,000+ GP)
- Duration: Until dispelled
- Classes: Warlock, Wizard
- Save: WIS

You create a magical restraint to hold a creature that you can see within range. The target must make a Wisdom saving throw. On a successful save, the target is unaffected, and it is immune to this

spell for the next 24 hours. On a failed save, the target is imprisoned. While imprisoned, the target doesn't need to breathe, eat, or drink, and it doesn't age. Divination spells can't locate or perceive the imprisoned target, and the target can't teleport.

Until the spell ends, the target is also affected by one of the following effects of your choice:

**Burial.** The target is entombed beneath the earth in a hollow globe of magical force that is just large enough to contain the target. Nothing can pass into or out of the globe.

**Chaining.** Chains firmly rooted in the ground hold the target in place. The target has the Restrained condition and can't be moved by any means.

**Hedged Prison.** The target is trapped in a demiplane that is warded against teleportation and planar travel. The demiplane is your choice of a labyrinth, a cage, a tower, or the like.

**Minimus Containment.** The target becomes 1 inch tall and is trapped inside an indestructible gemstone or a similar object. Light can pass through the gemstone (allowing the target to see out and other creatures to see in), but nothing else can pass through by any means.

**Slumber.** The target has the Unconscious condition and can't be awoken.

**_Ending the Spell._** When you cast the spell, specify a trigger that will end it. The trigger can be as simple or as elaborate as you choose, but the GM must agree that it has a high likelihood of happening within the next decade. The trigger must be an observable action, such as someone making a particular offering at the temple of your god, saving your true love, or defeating a specific monster.

A *Dispel Magic* spell can end the spell only if it is cast with a level 9 spell slot, targeting either the prison or the component used to create it.
`,
      "Incendiary-Cloud.md": `---
smType: spell
name: "Incendiary Cloud"
level: 8
school: "Conjuration"
casting_time: "Action"
range: "150 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "10d8"
damage_type: "Fire"
---

# Incendiary Cloud
Level 8 Conjuration

- Casting Time: Action
- Range: 150 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 10d8 Fire

A swirling cloud of embers and smoke fills a 20-foot-radius Sphere centered on a point within range. The cloud's area is Heavily Obscured. It lasts for the duration or until a strong wind (like that created by *Gust of Wind*) disperses it.

When the cloud appears, each creature in it makes a Dexterity saving throw, taking 10d8 Fire damage on a failed save or half as much damage on a successful one. A creature must also make this save when the Sphere moves into its space and when it enters the Sphere or ends its turn there. A creature makes this save only once per turn.

The cloud moves 10 feet away from you in a direction you choose at the start of each of your turns.
`,
      "Inflict-Wounds.md": `---
smType: spell
name: "Inflict Wounds"
level: 1
school: "Necromancy"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "2d10"
damage_type: "Necrotic"
---

# Inflict Wounds
Level 1 Necromancy

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric
- Save: CON (Half damage on success)
- Damage: 2d10 Necrotic

A creature you touch makes a Constitution saving throw, taking 2d10 Necrotic damage on a failed save or half as much damage on a successful one.
`,
      "Insect-Plague.md": `---
smType: spell
name: "Insect Plague"
level: 5
school: "Conjuration"
casting_time: "Action"
range: "300 feet"
components: ["V", "S", "M"]
materials: "a locust"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Cleric", "Druid", "Sorcerer"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "4d10"
damage_type: "Piercing"
---

# Insect Plague
Level 5 Conjuration

- Casting Time: Action
- Range: 300 feet
- Components: V, S, M (a locust)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Cleric, Druid, Sorcerer
- Save: CON (Half damage on success)
- Damage: 4d10 Piercing

Swarming locusts fill a 20-foot-radius Sphere centered on a point you choose within range. The Sphere remains for the duration, and its area is Lightly Obscured and Difficult Terrain.

When the swarm appears, each creature in it makes a Constitution saving throw, taking 4d10 Piercing damage on a failed save or half as much damage on a successful one. A creature also makes this save when it enters the spell's area for the first time on a turn or ends its turn there. A creature makes this save only once per turn.
`,
      "Instant-Summons.md": `---
smType: spell
name: "Instant Summons"
level: 6
school: "Conjuration"
casting_time: "1 minute or Ritual"
range: "Touch"
components: ["V", "S", "M"]
materials: "a sapphire worth 1,000+ GP"
duration: "Until dispelled"
ritual: true
classes: ["Wizard"]
---

# Instant Summons
Level 6 Conjuration

- Casting Time: 1 minute or Ritual
- Range: Touch
- Components: V, S, M (a sapphire worth 1,000+ GP)
- Duration: Until dispelled
- Ritual: yes
- Classes: Wizard

You touch the sapphire used in the casting and an object weighing 10 pounds or less whose longest dimension is 6 feet or less. The spell leaves an Invisible mark on that object and invisibly inscribes the object's name on the sapphire. Each time you cast this spell, you must use a different sapphire.

Thereafter, you can take a Magic action to speak the object's name and crush the sapphire. The object instantly appears in your hand regardless of physical or planar distances, and the spell ends.

If another creature is holding or carrying the object, crushing the sapphire doesn't transport it, but instead you learn who that creature is and where that creature is currently located.
`,
      "Invisibility.md": `---
smType: spell
name: "Invisibility"
level: 2
school: "Illusion"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "an eyelash in gum arabic"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# Invisibility
Level 2 Illusion

- Casting Time: Action
- Range: Touch
- Components: V, S, M (an eyelash in gum arabic)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Bard, Sorcerer, Warlock, Wizard

A creature you touch has the Invisible condition until the spell ends. The spell ends early immediately after the target makes an attack roll, deals damage, or casts a spell.

## At Higher Levels

### J,K and L Spells
`,
      "Irresistible-Dance.md": `---
smType: spell
name: "Irresistible Dance"
level: 6
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Wizard"]
save_ability: "WIS"
---

# Irresistible Dance
Level 6 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Wizard
- Save: WIS

One creature that you can see within range must make a Wisdom saving throw. On a successful save, the target dances comically until the end of its next turn, during which it must spend all its movement to dance in place.

On a failed save, the target has the Charmed condition for the duration. While Charmed, the target dances comically, must use all its movement to dance in place, and has Disadvantage on Dexterity saving throws and attack rolls, and other creatures have Advantage on attack rolls against it. On each of its turns, the target can take an action to collect itself and repeat the save, ending the spell on itself on a success.
`,
      "Jump.md": `---
smType: spell
name: "Jump"
level: 1
school: "Transmutation"
casting_time: "Bonus Action"
range: "Touch"
duration: "1 minute"
classes: ["Druid", "Ranger", "Sorcerer", "Wizard"]
---

# Jump
Level 1 Transmutation

- Casting Time: Bonus Action
- Range: Touch
- Duration: 1 minute
- Classes: Druid, Ranger, Sorcerer, Wizard

You touch a willing creature. Once on each of its turns until the spell ends, that creature can jump up to 30 feet by spending 10 feet of movement.
`,
      "Knock.md": `---
smType: spell
name: "Knock"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "60 feet"
components: ["V"]
duration: "Instantaneous Choose an object that you can see within range. The object can be a door, a box, a chest, a set of manacles, a padlock, or another object that contains a mundane or magical means that prevents access."
classes: ["Bard", "Sorcerer", "Wizard"]
---

# Knock
Level 2 Transmutation

- Casting Time: Action
- Range: 60 feet
- Components: V
- Duration: Instantaneous Choose an object that you can see within range. The object can be a door, a box, a chest, a set of manacles, a padlock, or another object that contains a mundane or magical means that prevents access.
- Classes: Bard, Sorcerer, Wizard

A target that is held shut by a mundane lock or that is stuck or barred becomes unlocked, unstuck, or unbarred. If the object has multiple locks, only one of them is unlocked.

If the target is held shut by *Arcane Lock*, that spell is suppressed for 10 minutes, during which time the target can be opened and closed.

When you cast the spell, a loud knock, audible up to 300 feet away, emanates from the target.
`,
      "Legend-Lore.md": `---
smType: spell
name: "Legend Lore"
level: 5
school: "Divination"
casting_time: "10 minutes"
range: "Self"
components: ["V", "S", "M"]
materials: "incense worth 250+ GP, which the spell consumes, and four ivory strips worth 50+ GP each"
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Wizard"]
---

# Legend Lore
Level 5 Divination

- Casting Time: 10 minutes
- Range: Self
- Components: V, S, M (incense worth 250+ GP, which the spell consumes, and four ivory strips worth 50+ GP each)
- Duration: Instantaneous
- Classes: Bard, Cleric, Wizard

Name or describe a famous person, place, or object. The spell brings to your mind a brief summary of the significant lore about that famous thing, as described by the GM.

The lore might consist of important details, amusing revelations, or even secret lore that has never been widely known. The more information you already know about the thing, the more precise and detailed the information you receive is. That information is accurate but might be couched in figurative language or poetry, as determined by the GM.

If the famous thing you chose isn't actually famous, you hear sad musical notes played on a trombone, and the spell fails.
`,
      "Lesser-Restoration.md": `---
smType: spell
name: "Lesser Restoration"
level: 2
school: "Abjuration"
casting_time: "Bonus Action"
range: "Touch"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger"]
---

# Lesser Restoration
Level 2 Abjuration

- Casting Time: Bonus Action
- Range: Touch
- Components: V, S
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid, Paladin, Ranger

You touch a creature and end one condition on it: Blinded, Deafened, Paralyzed, or Poisoned.
`,
      "Levitate.md": `---
smType: spell
name: "Levitate"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a metal spring"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Sorcerer", "Wizard"]
save_ability: "CON"
---

# Levitate
Level 2 Transmutation

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a metal spring)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Sorcerer, Wizard
- Save: CON

One creature or loose object of your choice that you can see within range rises vertically up to 20 feet and remains suspended there for the duration. The spell can levitate an object that weighs up to 500 pounds. An unwilling creature that succeeds on a Constitution saving throw is unaffected.

The target can move only by pushing or pulling against a fixed object or surface within reach (such as a wall or a ceiling), which allows it to move as if it were climbing. You can change the target's altitude by up to 20 feet in either direction on your turn. If you are the target, you can move up or down as part of your move. Otherwise, you can take a Magic action to move the target, which must remain within the spell's range.

When the spell ends, the target floats gently to the ground if it is still aloft.
`,
      "Light.md": `---
smType: spell
name: "Light"
level: 0
school: "Evocation"
casting_time: "Action"
range: "Touch"
components: ["V", "M"]
materials: "a firefly or phosphorescent moss"
duration: "1 hour"
classes: ["Bard", "Cleric", "Sorcerer", "Wizard"]
---

# Light
Cantrip Evocation

- Casting Time: Action
- Range: Touch
- Components: V, M (a firefly or phosphorescent moss)
- Duration: 1 hour
- Classes: Bard, Cleric, Sorcerer, Wizard

You touch one Large or smaller object that isn't being worn or carried by someone else. Until the spell ends, the object sheds Bright Light in a 20-foot radius and Dim Light for an additional 20 feet. The light can be colored as you like.

Covering the object with something opaque blocks the light. The spell ends if you cast it again.
`,
      "Lightning-Bolt.md": `---
smType: spell
name: "Lightning Bolt"
level: 3
school: "Evocation"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a bit of fur and a crystal rod"
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "8d6"
damage_type: "Lightning"
---

# Lightning Bolt
Level 3 Evocation

- Casting Time: Action
- Range: Self
- Components: V, S, M (a bit of fur and a crystal rod)
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 8d6 Lightning

A stroke of lightning forming a 100-foot-long, 5-foot-wide Line blasts out from you in a direction you choose. Each creature in the Line makes a Dexterity saving throw, taking 8d6 Lightning damage on a failed save or half as much damage on a successful one.
`,
      "Locate-Animals-or-Plants.md": `---
smType: spell
name: "Locate Animals or Plants"
level: 2
school: "Divination"
casting_time: "Action or Ritual"
range: "Self"
components: ["V", "S", "M"]
materials: "fur from a bloodhound"
duration: "Instantaneous"
ritual: true
classes: ["Bard", "Druid", "Ranger"]
---

# Locate Animals or Plants
Level 2 Divination

- Casting Time: Action or Ritual
- Range: Self
- Components: V, S, M (fur from a bloodhound)
- Duration: Instantaneous
- Ritual: yes
- Classes: Bard, Druid, Ranger

Describe or name a specific kind of Beast, Plant creature, or nonmagical plant. You learn the direction and distance to the closest creature or plant of that kind within 5 miles, if any are present.
`,
      "Locate-Creature.md": `---
smType: spell
name: "Locate Creature"
level: 4
school: "Divination"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "fur from a bloodhound"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger", "Wizard"]
---

# Locate Creature
Level 4 Divination

- Casting Time: Action
- Range: Self
- Components: V, S, M (fur from a bloodhound)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Bard, Cleric, Druid, Paladin, Ranger, Wizard

Describe or name a creature that is familiar to you. You sense the direction to the creature's location if that creature is within 1,000 feet of you. If the creature is moving, you know the direction of its movement.

The spell can locate a specific creature known to you or the nearest creature of a specific kind (such as a human or a unicorn) if you have seen such a creature up close\u2014within 30 feet\u2014at least once. If the creature you described or named is in a different form, such as under the effects of a *Flesh to Stone* or *Polymorph* spell, this spell doesn't locate the creature.

This spell can't locate a creature if any thickness of lead blocks a direct path between you and the creature.
`,
      "Locate-Object.md": `---
smType: spell
name: "Locate Object"
level: 2
school: "Divination"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a forked twig"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger", "Wizard"]
---

# Locate Object
Level 2 Divination

- Casting Time: Action
- Range: Self
- Components: V, S, M (a forked twig)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Bard, Cleric, Druid, Paladin, Ranger, Wizard

Describe or name an object that is familiar to you. You sense the direction to the object's location if that object is within 1,000 feet of you. If the object is in motion, you know the direction of its movement.

The spell can locate a specific object known to you if you have seen it up close\u2014within 30 feet\u2014at least once. Alternatively, the spell can locate the nearest object of a particular kind, such as a certain kind of apparel, jewelry, furniture, tool, or weapon.

This spell can't locate an object if any thickness of lead blocks a direct path between you and the object.
`,
      "Longstrider.md": `---
smType: spell
name: "Longstrider"
level: 1
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a pinch of dirt"
duration: "1 hour"
classes: ["Bard", "Druid", "Ranger", "Wizard"]
---

# Longstrider
Level 1 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a pinch of dirt)
- Duration: 1 hour
- Classes: Bard, Druid, Ranger, Wizard

You touch a creature. The target's Speed increases by 10 feet until the spell ends.

## At Higher Levels

### M and N Spells
`,
      "Mage-Armor.md": `---
smType: spell
name: "Mage Armor"
level: 1
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a piece of cured leather"
duration: "8 hours"
classes: ["Sorcerer", "Wizard"]
---

# Mage Armor
Level 1 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a piece of cured leather)
- Duration: 8 hours
- Classes: Sorcerer, Wizard

You touch a willing creature who isn't wearing armor. Until the spell ends, the target's base AC becomes 13 plus its Dexterity modifier. The spell ends early if the target dons armor.
`,
      "Mage-Hand.md": `---
smType: spell
name: "Mage Hand"
level: 0
school: "Conjuration"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "1 minute"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# Mage Hand
Cantrip Conjuration

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: 1 minute
- Classes: Bard, Sorcerer, Warlock, Wizard

A spectral, floating hand appears at a point you choose within range. The hand lasts for the duration. The hand vanishes if it is ever more than 30 feet away from you or if you cast this spell again.

When you cast the spell, you can use the hand to manipulate an object, open an unlocked door or container, stow or retrieve an item from an open container, or pour the contents out of a vial.

As a Magic action on your later turns, you can control the hand thus again. As part of that action, you can move the hand up to 30 feet.

The hand can't attack, activate magic items, or carry more than 10 pounds.
`,
      "Magic-Circle.md": `---
smType: spell
name: "Magic Circle"
level: 3
school: "Abjuration"
casting_time: "1 minute"
range: "10 feet"
components: ["V", "S", "M"]
materials: "salt and powdered silver worth 100+ GP, which the spell consumes"
duration: "1 hour"
classes: ["Cleric", "Paladin", "Warlock", "Wizard"]
save_ability: "CHA"
---

# Magic Circle
Level 3 Abjuration

- Casting Time: 1 minute
- Range: 10 feet
- Components: V, S, M (salt and powdered silver worth 100+ GP, which the spell consumes)
- Duration: 1 hour
- Classes: Cleric, Paladin, Warlock, Wizard
- Save: CHA

You create a 10-foot-radius, 20-foot-tall Cylinder of magical energy centered on a point on the ground that you can see within range. Glowing runes appear wherever the Cylinder intersects with the floor or other surface.

Choose one or more of the following types of creatures: Celestials, Elementals, Fey, Fiends, or Undead. The circle affects a creature of the chosen type in the following ways:

- The creature can't willingly enter the Cylinder by nonmagical means. If the creature tries to use teleportation or interplanar travel to do so, it must first succeed on a Charisma saving throw.

- The creature has Disadvantage on attack rolls against targets within the Cylinder.

- Targets within the Cylinder can't be possessed by or gain the Charmed or Frightened condition from the creature.

Each time you cast this spell, you can cause its magic to operate in the reverse direction, preventing a creature of the specified type from leaving the Cylinder and protecting targets outside it.
`,
      "Magic-Jar.md": `---
smType: spell
name: "Magic Jar"
level: 6
school: "Necromancy"
casting_time: "1 minute"
range: "Self"
components: ["V", "S", "M"]
materials: "a gem, crystal, or reliquary worth 500+ GP"
duration: "Until dispelled"
classes: ["Wizard"]
save_ability: "CHA"
---

# Magic Jar
Level 6 Necromancy

- Casting Time: 1 minute
- Range: Self
- Components: V, S, M (a gem, crystal, or reliquary worth 500+ GP)
- Duration: Until dispelled
- Classes: Wizard
- Save: CHA

Your body falls into a catatonic state as your soul leaves it and enters the container you used for the spell's Material component. While your soul inhabits the container, you are aware of your surroundings as if you were in the container's space. You can't move or take Reactions. The only action you can take is to project your soul up to 100 feet out of the container, either returning to your living body (and ending the spell) or attempting to possess a Humanoid's body.

You can attempt to possess any Humanoid within 100 feet of you that you can see (creatures warded by a *Protection from Evil and Good* or *Magic Circle* spell can't be possessed). The target makes a Charisma saving throw. On a failed save, your soul enters the target's body, and the target's soul becomes trapped in the container. On a successful save, the target resists your efforts to possess it, and you can't attempt to possess it again for 24 hours.

Once you possess a creature's body, you control it. Your Hit Points, Hit Point Dice, Strength, Dexterity, Constitution, Speed, and senses are replaced by the creature's. You otherwise keep your game statistics.

Meanwhile, the possessed creature's soul can perceive from the container using its own senses, but it can't move and it is Incapacitated.

While possessing a body, you can take a Magic action to return from the host body to the container if it is within 100 feet of you, returning the host creature's soul to its body. If the host body dies while you're in it, the creature dies, and you make a Charisma saving throw against your own spellcasting DC. On a success, you return to the container if it is within 100 feet of you. Otherwise, you die.

If the container is destroyed or the spell ends, your soul returns to your body. If your body is more than 100 feet away from you or if your body is dead, you die. If another creature's soul is in the container when it is destroyed, the creature's soul returns to its body if the body is alive and within 100 feet. Otherwise, that creature dies.

When the spell ends, the container is destroyed.
`,
      "Magic-Missile.md": `---
smType: spell
name: "Magic Missile"
level: 1
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
damage: "1d4 + 1"
damage_type: "Force"
---

# Magic Missile
Level 1 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Damage: 1d4 + 1 Force

You create three glowing darts of magical force. Each dart strikes a creature of your choice that you can see within range. A dart deals 1d4 + 1 Force damage to its target. The darts all strike simultaneously, and you can direct them to hit one creature or several.
`,
      "Magic-Mouth.md": `---
smType: spell
name: "Magic Mouth"
level: 2
school: "Illusion"
casting_time: "1 minute or Ritual"
range: "30 feet"
components: ["V", "S", "M"]
materials: "jade dust worth 10+ GP, which the spell consumes"
duration: "Until dispelled"
ritual: true
classes: ["Bard", "Wizard"]
---

# Magic Mouth
Level 2 Illusion

- Casting Time: 1 minute or Ritual
- Range: 30 feet
- Components: V, S, M (jade dust worth 10+ GP, which the spell consumes)
- Duration: Until dispelled
- Ritual: yes
- Classes: Bard, Wizard

You implant a message within an object in range\u2014a message that is uttered when a trigger condition is met. Choose an object that you can see and that isn't being worn or carried by another creature. Then speak the message, which must be 25 words or fewer, though it can be delivered over as long as 10 minutes. Finally, determine the circumstance that will trigger the spell to deliver your message.

When that trigger occurs, a magical mouth appears on the object and recites the message in your voice and at the same volume you spoke. If the object you chose has a mouth or something that looks like a mouth (for example, the mouth of a statue), the magical mouth appears there, so the words appear to come from the object's mouth. When you cast this spell, you can have the spell end after it delivers its message, or it can remain and repeat its message whenever the trigger occurs.

The trigger can be as general or as detailed as you like, though it must be based on visual or audible conditions that occur within 30 feet of the object. For example, you could instruct the mouth to speak when any creature moves within 30 feet of the object or when a silver bell rings within 30 feet of it.
`,
      "Magic-Weapon.md": `---
smType: spell
name: "Magic Weapon"
level: 2
school: "Transmutation"
casting_time: "Bonus Action"
range: "Touch"
components: ["V", "S"]
duration: "1 hour"
classes: ["Paladin", "Ranger", "Sorcerer", "Wizard"]
---

# Magic Weapon
Level 2 Transmutation

- Casting Time: Bonus Action
- Range: Touch
- Components: V, S
- Duration: 1 hour
- Classes: Paladin, Ranger, Sorcerer, Wizard

You touch a nonmagical weapon. Until the spell ends, that weapon becomes a magic weapon with a +1 bonus to attack rolls and damage rolls. The spell ends early if you cast it again.
`,
      "Magnificent-Mansion.md": `---
smType: spell
name: "Magnificent Mansion"
level: 7
school: "Conjuration"
casting_time: "1 minute"
range: "300 feet"
components: ["V", "S", "M"]
materials: "a miniature door worth 15+ GP"
duration: "24 hours"
classes: ["Bard", "Wizard"]
---

# Magnificent Mansion
Level 7 Conjuration

- Casting Time: 1 minute
- Range: 300 feet
- Components: V, S, M (a miniature door worth 15+ GP)
- Duration: 24 hours
- Classes: Bard, Wizard

You conjure a shimmering door in range that lasts for the duration. The door leads to an extradimensional dwelling and is 5 feet wide and 10 feet tall. You and any creature you designate when you cast the spell can enter the extradimensional dwelling as long as the door remains open. You can open or close it (no action required) if you are within 30 feet of it. While closed, the door is imperceptible.

Beyond the door is a magnificent foyer with numerous chambers beyond. The dwelling's atmosphere is clean, fresh, and warm.

You can create any floor plan you like for the dwelling, but it can't exceed 50 contiguous 10-foot Cubes. The place is furnished and decorated as you choose. It contains sufficient food to serve a ninecourse banquet for up to 100 people. Furnishings and other objects created by this spell dissipate into smoke if removed from it.

A staff of 100 near-transparent servants attends all who enter. You determine the appearance of these servants and their attire. They are invulnerable and obey your commands. Each servant can perform tasks that a human could perform, but they can't attack or take any action that would directly harm another creature. Thus the servants can fetch things, clean, mend, fold clothes, light fires, serve food, pour wine, and so on. The servants can't leave the dwelling.

When the spell ends, any creatures or objects left inside the extradimensional space are expelled into the unoccupied spaces nearest to the entrance.
`,
      "Major-Image.md": `---
smType: spell
name: "Major Image"
level: 3
school: "Illusion"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a bit of fleece"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# Major Image
Level 3 Illusion

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a bit of fleece)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Bard, Sorcerer, Warlock, Wizard

You create the image of an object, a creature, or some other visible phenomenon that is no larger than a 20-foot Cube. The image appears at a spot that you can see within range and lasts for the duration. It seems real, including sounds, smells, and temperature appropriate to the thing depicted, but it can't deal damage or cause conditions.

If you are within range of the illusion, you can take a Magic action to cause the image to move to any other spot within range. As the image changes location, you can alter its appearance so that its movements appear natural for the image. For example, if you create an image of a creature and move it, you can alter the image so that it appears to be walking. Similarly, you can cause the illusion to make different sounds at different times, even making it carry on a conversation, for example.

Physical interaction with the image reveals it to be an illusion, for things can pass through it. A creature that takes a Study action to examine the image can determine that it is an illusion with a successful Intelligence (Investigation) check against your spell save DC. If a creature discerns the illusion for what it is, the creature can see through the image, and its other sensory qualities become faint to the creature.
`,
      "Mass-Cure-Wounds.md": `---
smType: spell
name: "Mass Cure Wounds"
level: 5
school: "Abjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid"]
---

# Mass Cure Wounds
Level 5 Abjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid

A wave of healing energy washes out from a point you can see within range. Choose up to six creatures in a 30-foot-radius Sphere centered on that point. Each target regains Hit Points equal to 5d8 plus your spellcasting ability modifier.
`,
      "Mass-Heal.md": `---
smType: spell
name: "Mass Heal"
level: 9
school: "Abjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric"]
---

# Mass Heal
Level 9 Abjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric

A flood of healing energy flows from you into creatures around you. You restore up to 700 Hit Points, divided as you choose among any number of creatures that you can see within range. Creatures healed by this spell also have the Blinded, Deafened, and Poisoned conditions removed from them.
`,
      "Mass-Healing-Word.md": `---
smType: spell
name: "Mass Healing Word"
level: 3
school: "Abjuration"
casting_time: "Bonus Action"
range: "60 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Bard", "Cleric"]
---

# Mass Healing Word
Level 3 Abjuration

- Casting Time: Bonus Action
- Range: 60 feet
- Components: V
- Duration: Instantaneous
- Classes: Bard, Cleric

Up to six creatures of your choice that you can see within range regain Hit Points equal to 2d4 plus your spellcasting ability modifier.
`,
      "Mass-Suggestion.md": `---
smType: spell
name: "Mass Suggestion"
level: 6
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "M"]
materials: "a snake's tongue"
duration: "24 hours"
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "WIS"
---

# Mass Suggestion
Level 6 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, M (a snake's tongue)
- Duration: 24 hours
- Classes: Bard, Sorcerer, Wizard
- Save: WIS

You suggest a course of activity\u2014described in no more than 25 words\u2014to twelve or fewer creatures you can see within range that can hear and understand you. The suggestion must sound achievable and not involve anything that would obviously deal damage to any of the targets or their allies. For example, you could say, "Walk to the village down that road, and help the villagers there harvest crops until sunset." Or you could say, "Now is not the time for violence. Drop your weapons, and dance! Stop in an hour."

Each target must succeed on a Wisdom saving throw or have the Charmed condition for the duration or until you or your allies deal damage to the target. Each Charmed target pursues the suggestion to the best of its ability. The suggested activity can continue for the entire duration, but if the suggested activity can be completed in a shorter time, the spell ends for a target upon completing it.
`,
      "Maze.md": `---
smType: spell
name: "Maze"
level: 8
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Wizard"]
---

# Maze
Level 8 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Wizard

You banish a creature that you can see within range into a labyrinthine demiplane. The target remains there for the duration or until it escapes the maze.

The target can take a Study action to try to escape. When it does so, it makes a DC 20 Intelligence (Investigation) check. If it succeeds, it escapes, and the spell ends.

When the spell ends, the target reappears in the space it left or, if that space is occupied, in the nearest unoccupied space.
`,
      "Meld-into-Stone.md": `---
smType: spell
name: "Meld into Stone"
level: 3
school: "Transmutation"
casting_time: "Action or Ritual"
range: "Touch"
components: ["V", "S"]
duration: "8 hours"
ritual: true
classes: ["Cleric", "Druid", "Ranger"]
damage: "6d6"
damage_type: "Force"
---

# Meld into Stone
Level 3 Transmutation

- Casting Time: Action or Ritual
- Range: Touch
- Components: V, S
- Duration: 8 hours
- Ritual: yes
- Classes: Cleric, Druid, Ranger
- Damage: 6d6 Force

You step into a stone object or surface large enough to fully contain your body, merging yourself and your equipment with the stone for the duration. You must touch the stone to do so. Nothing of your presence remains visible or otherwise detectable by nonmagical senses.

While merged with the stone, you can't see what occurs outside it, and any Wisdom (Perception) checks you make to hear sounds outside it are made with Disadvantage. You remain aware of the passage of time and can cast spells on yourself while merged in the stone. You can use 5 feet of movement to leave the stone where you entered it, which ends the spell. You otherwise can't move.

Minor physical damage to the stone doesn't harm you, but its partial destruction or a change in its shape (to the extent that you no longer fit within it) expels you and deals 6d6 Force damage to you. The stone's complete destruction (or transmutation into a different substance) expels you and deals 50 Force damage to you. If expelled, you move into an unoccupied space closest to where you first entered and have the Prone condition.
`,
      "Mending.md": `---
smType: spell
name: "Mending"
level: 0
school: "Transmutation"
casting_time: "1 minute"
range: "Touch"
components: ["V", "S", "M"]
materials: "two lodestones"
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid", "Sorcerer", "Wizard"]
---

# Mending
Cantrip Transmutation

- Casting Time: 1 minute
- Range: Touch
- Components: V, S, M (two lodestones)
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid, Sorcerer, Wizard

This spell repairs a single break or tear in an object you touch, such as a broken chain link, two halves of a broken key, a torn cloak, or a leaking wineskin. As long as the break or tear is no larger than 1 foot in any dimension, you mend it, leaving no trace of the former damage.

This spell can physically repair a magic item, but it can't restore magic to such an object.
`,
      "Message.md": `---
smType: spell
name: "Message"
level: 0
school: "Transmutation"
casting_time: "Action"
range: "120 feet"
components: ["S", "M"]
materials: "a copper wire"
duration: "1 round"
classes: ["Bard", "Druid", "Sorcerer", "Wizard"]
---

# Message
Cantrip Transmutation

- Casting Time: Action
- Range: 120 feet
- Components: S, M (a copper wire)
- Duration: 1 round
- Classes: Bard, Druid, Sorcerer, Wizard

You point toward a creature within range and whisper a message. The target (and only the target) hears the message and can reply in a whisper that only you can hear.

You can cast this spell through solid objects if you are familiar with the target and know it is beyond the barrier. Magical silence; 1 foot of stone, metal, or wood; or a thin sheet of lead blocks the spell.
`,
      "Meteor-Swarm.md": `---
smType: spell
name: "Meteor Swarm"
level: 9
school: "Evocation"
casting_time: "Action"
range: "1 mile"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "20d6"
damage_type: "Fire"
---

# Meteor Swarm
Level 9 Evocation

- Casting Time: Action
- Range: 1 mile
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 20d6 Fire

Blazing orbs of fire plummet to the ground at four different points you can see within range. Each creature in a 40-foot-radius Sphere centered on each of those points makes a Dexterity saving throw. A creature takes 20d6 Fire damage and 20d6 Bludgeoning damage on a failed save or half as much damage on a successful one. A creature in the area of more than one fiery Sphere is affected only once.

A nonmagical object that isn't being worn or carried also takes the damage if it's in the spell's area, and the object starts burning if it's flammable.
`,
      "Mind-Blank.md": `---
smType: spell
name: "Mind Blank"
level: 8
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "24 hours"
classes: ["Bard", "Wizard"]
---

# Mind Blank
Level 8 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: 24 hours
- Classes: Bard, Wizard

Until the spell ends, one willing creature you touch has Immunity to Psychic damage and the Charmed condition. The target is also unaffected by anything that would sense its emotions or alignment, read its thoughts, or magically detect its location, and no spell\u2014not even *Wish*\u2014can gather information about the target, observe it remotely, or control its mind.
`,
      "Mind-Spike.md": `---
smType: spell
name: "Mind Spike"
level: 2
school: "Divination"
casting_time: "Action"
range: "120 feet"
components: ["S"]
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
save_effect: "Half damage on success"
damage: "3d8"
damage_type: "Psychic"
---

# Mind Spike
Level 2 Divination

- Casting Time: Action
- Range: 120 feet
- Components: S
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Sorcerer, Warlock, Wizard
- Save: WIS (Half damage on success)
- Damage: 3d8 Psychic

You drive a spike of psionic energy into the mind of one creature you can see within range. The target makes a Wisdom saving throw, taking 3d8 Psychic damage on a failed save or half as much damage on a successful one. On a failed save, you also always know the target's location until the spell ends, but only while the two of you are on the same plane of existence. While you have this knowledge, the target can't become hidden from you, and if it has the Invisible condition, it gains no benefit from that condition against you.
`,
      "Minor-Illusion.md": `---
smType: spell
name: "Minor Illusion"
level: 0
school: "Illusion"
casting_time: "Action"
range: "30 feet"
components: ["S", "M"]
materials: "a bit of fleece"
duration: "1 minute"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# Minor Illusion
Cantrip Illusion

- Casting Time: Action
- Range: 30 feet
- Components: S, M (a bit of fleece)
- Duration: 1 minute
- Classes: Bard, Sorcerer, Warlock, Wizard

You create a sound or an image of an object within range that lasts for the duration. See the descriptions below for the effects of each. The illusion ends if you cast this spell again.

If a creature takes a Study action to examine the sound or image, the creature can determine that it is an illusion with a successful Intelligence (Investigation) check against your spell save DC. If a creature discerns the illusion for what it is, the illusion becomes faint to the creature.

**_Sound._** If you create a sound, its volume can range from a whisper to a scream. It can be your voice, someone else's voice, a lion's roar, a beating of drums, or any other sound you choose. The sound continues unabated throughout the duration, or you can make discrete sounds at different times before the spell ends.

**_Image._** If you create an image of an object\u2014such as a chair, muddy footprints, or a small chest\u2014it must be no larger than a 5-foot Cube. The image can't create sound, light, smell, or any other sensory effect. Physical interaction with the image reveals it to be an illusion, since things can pass through it.
`,
      "Mirage-Arcane.md": `---
smType: spell
name: "Mirage Arcane"
level: 7
school: "Illusion"
casting_time: "10 minutes"
range: "Sight"
components: ["V", "S"]
duration: "10 days"
classes: ["Bard", "Druid", "Wizard"]
---

# Mirage Arcane
Level 7 Illusion

- Casting Time: 10 minutes
- Range: Sight
- Components: V, S
- Duration: 10 days
- Classes: Bard, Druid, Wizard

You make terrain in an area up to 1 mile square look, sound, smell, and even feel like some other sort of terrain. Open fields or a road could be made to resemble a swamp, hill, crevasse, or some other rough or impassable terrain. A pond can be made to seem like a grassy meadow, a precipice like a gentle slope, or a rock-strewn gully like a wide and smooth road.

Similarly, you can alter the appearance of structures or add them where none are present. The spell doesn't disguise, conceal, or add creatures.

The illusion includes audible, visual, tactile, and olfactory elements, so it can turn clear ground into Difficult Terrain (or vice versa) or otherwise impede movement through the area. Any piece of the illusory terrain (such as a rock or stick) that is removed from the spell's area disappears immediately.

Creatures with Truesight can see through the illusion to the terrain's true form; however, all other elements of the illusion remain, so while the creature is aware of the illusion's presence, the creature can still physically interact with the illusion.
`,
      "Mirror-Image.md": `---
smType: spell
name: "Mirror Image"
level: 2
school: "Illusion"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "1 minute"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# Mirror Image
Level 2 Illusion

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: 1 minute
- Classes: Bard, Sorcerer, Warlock, Wizard

Three illusory duplicates of yourself appear in your space. Until the spell ends, the duplicates move with you and mimic your actions, shifting position so it's impossible to track which image is real.

Each time a creature hits you with an attack roll during the spell's duration, roll a d6 for each of your remaining duplicates. If any of the d6s rolls a 3 or higher, one of the duplicates is hit instead of you, and the duplicate is destroyed. The duplicates otherwise ignore all other damage and effects. The spell ends when all three duplicates are destroyed.

A creature is unaffected by this spell if it has the Blinded condition, Blindsight, or Truesight.
`,
      "Mislead.md": `---
smType: spell
name: "Mislead"
level: 5
school: "Illusion"
casting_time: "Action"
range: "Self"
components: ["S"]
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Bard", "Warlock", "Wizard"]
---

# Mislead
Level 5 Illusion

- Casting Time: Action
- Range: Self
- Components: S
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Bard, Warlock, Wizard

You gain the Invisible condition at the same time that an illusory double of you appears where you are standing. The double lasts for the duration, but the invisibility ends immediately after you make an attack roll, deal damage, or cast a spell.

As a Magic action, you can move the illusory double up to twice your Speed and make it gesture, speak, and behave in whatever way you choose. It is intangible and invulnerable.

You can see through its eyes and hear through its ears as if you were located where it is.
`,
      "Misty-Step.md": `---
smType: spell
name: "Misty Step"
level: 2
school: "Conjuration"
casting_time: "Bonus Action"
range: "Self"
components: ["V"]
duration: "Instantaneous"
classes: ["Sorcerer", "Warlock", "Wizard"]
---

# Misty Step
Level 2 Conjuration

- Casting Time: Bonus Action
- Range: Self
- Components: V
- Duration: Instantaneous
- Classes: Sorcerer, Warlock, Wizard

Briefly surrounded by silvery mist, you teleport up to 30 feet to an unoccupied space you can see.
`,
      "Modify-Memory.md": `---
smType: spell
name: "Modify Memory"
level: 5
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Wizard"]
save_ability: "WIS"
---

# Modify Memory
Level 5 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Wizard
- Save: WIS

You attempt to reshape another creature's memories. One creature that you can see within range makes a Wisdom saving throw. If you are fighting the creature, it has Advantage on the save. On a failed save, the target has the Charmed condition for the duration. While Charmed in this way, the target also has the Incapacitated condition and is unaware of its surroundings, though it can hear you. If it takes any damage or is targeted by another spell, this spell ends, and no memories are modified.

While this charm lasts, you can affect the target's memory of an event that it experienced within the last 24 hours and that lasted no more than 10 minutes. You can permanently eliminate all memory of the event, allow the target to recall the event with perfect clarity, change its memory of the event's details, or create a memory of some other event.

You must speak to the target to describe how its memories are affected, and it must be able to understand your language for the modified memories to take root. Its mind fills in any gaps in the details of your description. If the spell ends before you finish describing the modified memories, the creature's memory isn't altered. Otherwise, the modified memories take hold when the spell ends.

A modified memory doesn't necessarily affect how a creature behaves, particularly if the memory contradicts the creature's natural inclinations, alignment, or beliefs. An illogical modified memory, such as a false memory of how much the creature enjoyed swimming in acid, is dismissed as a bad dream. The GM might deem a modified memory too nonsensical to affect a creature.

A *Remove Curse* or *Greater Restoration* spell cast on the target restores the creature's true memory.
`,
      "Moonbeam.md": `---
smType: spell
name: "Moonbeam"
level: 2
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a moonseed leaf"
duration: "Concentration, up to 1 minute A silvery beam of pale light shines down in a 5-foot-radius, 40-foot-high Cylinder centered on a point within range. Until the spell ends, Dim Light fills the Cylinder, and you can take a Magic action on later turns to move the Cylinder up to 60 feet."
concentration: true
classes: ["Druid"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "2d10"
damage_type: "Radiant"
---

# Moonbeam
Level 2 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a moonseed leaf)
- Duration: Concentration, up to 1 minute A silvery beam of pale light shines down in a 5-foot-radius, 40-foot-high Cylinder centered on a point within range. Until the spell ends, Dim Light fills the Cylinder, and you can take a Magic action on later turns to move the Cylinder up to 60 feet.
- Concentration: yes
- Classes: Druid
- Save: CON (Half damage on success)
- Damage: 2d10 Radiant

When the Cylinder appears, each creature in it makes a Constitution saving throw. On a failed save, a creature takes 2d10 Radiant damage, and if the creature is shape-shifted (as a result of the *Polymorph* spell, for example), it reverts to its true form and can't shape-shift until it leaves the Cylinder. On a successful save, a creature takes half as much damage only. A creature also makes this save when the spell's area moves into its space and when it enters the spell's area or ends its turn there. A creature makes this save only once per turn.
`,
      "Move-Earth.md": `---
smType: spell
name: "Move Earth"
level: 6
school: "Transmutation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a miniature shovel"
duration: "Concentration, up to 2 hours"
concentration: true
classes: ["Druid", "Sorcerer", "Wizard"]
---

# Move Earth
Level 6 Transmutation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a miniature shovel)
- Duration: Concentration, up to 2 hours
- Concentration: yes
- Classes: Druid, Sorcerer, Wizard

Choose an area of terrain no larger than 40 feet on a side within range. You can reshape dirt, sand, or clay in the area in any manner you choose for the duration. You can raise or lower the area's elevation, create or fill in a trench, erect or flatten a wall, or form a pillar. The extent of any such changes can't exceed half the area's largest dimension. For example, if you affect a 40-foot square, you can create a pillar up to 20 feet high, raise or lower the square's elevation by up to 20 feet, dig a trench up to 20 feet deep, and so on. It takes 10 minutes for these changes to complete. Because the terrain's transformation occurs slowly, creatures in the area can't usually be trapped or injured by the ground's movement.

At the end of every 10 minutes you spend concentrating on the spell, you can choose a new area of terrain to affect within range.

This spell can't manipulate natural stone or stone construction. Rocks and structures shift to accommodate the new terrain. If the way you shape the terrain would make a structure unstable, it might collapse.

Similarly, this spell doesn't directly affect plant growth. The moved earth carries any plants along with it.
`,
      "Nondetection.md": `---
smType: spell
name: "Nondetection"
level: 3
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a pinch of diamond dust worth 25+ GP, which the spell consumes"
duration: "8 hours"
classes: ["Bard", "Ranger", "Wizard"]
---

# Nondetection
Level 3 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a pinch of diamond dust worth 25+ GP, which the spell consumes)
- Duration: 8 hours
- Classes: Bard, Ranger, Wizard

For the duration, you hide a target that you touch from Divination spells. The target can be a willing creature, or it can be a place or an object no larger than 10 feet in any dimension. The target can't be targeted by any Divination spell or perceived through magical scrying sensors.

### P Spells
`,
      "Pass-without-Trace.md": `---
smType: spell
name: "Pass without Trace"
level: 2
school: "Abjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "ashes from burned mistletoe"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Druid", "Ranger"]
---

# Pass without Trace
Level 2 Abjuration

- Casting Time: Action
- Range: Self
- Components: V, S, M (ashes from burned mistletoe)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Druid, Ranger

You radiate a concealing aura in a 30-foot Emanation for the duration. While in the aura, you and each creature you choose have a +10 bonus to Dexterity (Stealth) checks and leave no tracks.
`,
      "Passwall.md": `---
smType: spell
name: "Passwall"
level: 5
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a pinch of sesame seeds"
duration: "1 hour"
classes: ["Wizard"]
---

# Passwall
Level 5 Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a pinch of sesame seeds)
- Duration: 1 hour
- Classes: Wizard

A passage appears at a point that you can see on a wooden, plaster, or stone surface (such as a wall, ceiling, or floor) within range and lasts for the duration. You choose the opening's dimensions: up to 5 feet wide, 8 feet tall, and 20 feet deep. The passage creates no instability in a structure surrounding it.

When the opening disappears, any creatures or objects still in the passage created by the spell are safely ejected to an unoccupied space nearest to the surface on which you cast the spell.
`,
      "Phantasmal-Force.md": `---
smType: spell
name: "Phantasmal Force"
level: 2
school: "Illusion"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a bit of fleece"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "INT"
damage: "2d8"
damage_type: "Psychic"
---

# Phantasmal Force
Level 2 Illusion

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a bit of fleece)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard
- Save: INT
- Damage: 2d8 Psychic

You attempt to craft an illusion in the mind of a creature you can see within range. The target makes an Intelligence saving throw. On a failed save, you create a phantasmal object, creature, or other phenomenon that is no larger than a 10-foot Cube and that is perceivable only to the target for the duration. The phantasm includes sound, temperature, and other stimuli.

The target can take a Study action to examine the phantasm with an Intelligence (Investigation) check against your spell save DC. If the check succeeds, the target realizes that the phantasm is an illusion, and the spell ends.

While affected by the spell, the target treats the phantasm as if it were real and rationalizes any illogical outcomes from interacting with it. For example, if the target steps through a phantasmal bridge and survives the fall, it believes the bridge exists and something else caused it to fall.

An affected target can even take damage from the illusion if the phantasm represents a dangerous creature or hazard. On each of your turns, such a phantasm can deal 2d8 Psychic damage to the target if it is in the phantasm's area or within 5 feet of the phantasm. The target perceives the damage as a type appropriate to the illusion.
`,
      "Phantasmal-Killer.md": `---
smType: spell
name: "Phantasmal Killer"
level: 4
school: "Illusion"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Wizard"]
save_ability: "WIS"
save_effect: "Half damage on success"
damage: "4d10"
damage_type: "Psychic"
---

# Phantasmal Killer
Level 4 Illusion

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Wizard
- Save: WIS (Half damage on success)
- Damage: 4d10 Psychic

You tap into the nightmares of a creature you can see within range and create an illusion of its deepest fears, visible only to that creature. The target makes a Wisdom saving throw. On a failed save, the target takes 4d10 Psychic damage and has Disadvantage on ability checks and attack rolls for the duration. On a successful save, the target takes half as much damage, and the spell ends.

For the duration, the target makes a Wisdom saving throw at the end of each of its turns. On a failed save, it takes the Psychic damage again. On a successful save, the spell ends.
`,
      "Phantom-Steed.md": `---
smType: spell
name: "Phantom Steed"
level: 3
school: "Illusion"
casting_time: "1 minute or Ritual"
range: "30 feet"
components: ["V", "S"]
duration: "1 hour"
ritual: true
classes: ["Wizard"]
---

# Phantom Steed
Level 3 Illusion

- Casting Time: 1 minute or Ritual
- Range: 30 feet
- Components: V, S
- Duration: 1 hour
- Ritual: yes
- Classes: Wizard

A Large, quasi-real, horselike creature appears on the ground in an unoccupied space of your choice within range. You decide the creature's appearance, and it is equipped with a saddle, bit, and bridle. Any of the equipment created by the spell vanishes in a puff of smoke if it is carried more than 10 feet away from the steed.

For the duration, you or a creature you choose can ride the steed. The steed uses the **Riding Horse**  stat block (see "Monsters"), except it has a Speed of 100 feet and can travel 13 miles in an hour. When the spell ends, the steed gradually fades, giving the rider 1 minute to dismount. The spell ends early if the steed takes any damage.
`,
      "Planar-Ally.md": `---
smType: spell
name: "Planar Ally"
level: 6
school: "Conjuration"
casting_time: "10 minutes"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric"]
---

# Planar Ally
Level 6 Conjuration

- Casting Time: 10 minutes
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric

You beseech an otherworldly entity for aid. The being must be known to you: a god, a demon prince, or some other being of cosmic power. That entity sends a Celestial, an Elemental, or a Fiend loyal to it to aid you, making the creature appear in an unoccupied space within range. If you know a specific creature's name, you can speak that name when you cast this spell to request that creature, though you might get a different creature anyway (GM's choice).

When the creature appears, it is under no compulsion to behave a particular way. You can ask it to perform a service in exchange for payment, but it isn't obliged to do so. The requested task could range from simple (fly us across the chasm, or help us fight a battle) to complex (spy on our enemies, or protect us during our foray into the dungeon). You must be able to communicate with the creature to bargain for its services.

Payment can take a variety of forms. A Celestial might require a sizable donation of gold or magic items to an allied temple, while a Fiend might demand a living sacrifice or a gift of treasure. Some creatures might exchange their service for a quest undertaken by you.

A task that can be measured in minutes requires a payment worth 100 GP per minute. A task measured in hours requires 1,000 GP per hour. And a task measured in days (up to 10 days) requires 10,000 GP per day. The GM can adjust these payments based on the circumstances under which you cast the spell. If the task is aligned with the creature's ethos, the payment might be halved or even waived. Nonhazardous tasks typically require only half the suggested payment, while especially dangerous tasks might require a greater gift. Creatures rarely accept tasks that seem suicidal.

After the creature completes the task, or when the agreed-upon duration of service expires, the creature returns to its home plane after reporting back to you if possible. If you are unable to agree on a price for the creature's service, the creature immediately returns to its home plane.
`,
      "Planar-Binding.md": `---
smType: spell
name: "Planar Binding"
level: 5
school: "Abjuration"
casting_time: "1 hour"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a jewel worth 1,000+ GP, which the spell consumes"
duration: "24 hours"
classes: ["Bard", "Cleric", "Druid", "Warlock", "Wizard"]
save_ability: "CHA"
---

# Planar Binding
Level 5 Abjuration

- Casting Time: 1 hour
- Range: 60 feet
- Components: V, S, M (a jewel worth 1,000+ GP, which the spell consumes)
- Duration: 24 hours
- Classes: Bard, Cleric, Druid, Warlock, Wizard
- Save: CHA

You attempt to bind a Celestial, an Elemental, a Fey, or a Fiend to your service. The creature must be within range for the entire casting of the spell. (Typically, the creature is first summoned into the center of the inverted version of the *Magic Circle* spell to trap it while this spell is cast.) At the completion of the casting, the target must succeed on a Charisma saving throw or be bound to serve you for the duration. If the creature was summoned or created by another spell, that spell's duration is extended to match the duration of this spell.

A bound creature must follow your commands to the best of its ability. You might command the creature to accompany you on an adventure, to guard a location, or to deliver a message. If the creature is Hostile, it strives to twist your commands to achieve its own objectives. If the creature carries out your commands completely before the spell ends, it travels to you to report this fact if you are on the same plane of existence. If you are on a different plane, it returns to the place where you bound it and remains there until the spell ends.
`,
      "Plane-Shift.md": `---
smType: spell
name: "Plane Shift"
level: 7
school: "Conjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a forked, metal rod worth 250+ GP and attuned to a plane of existence"
duration: "Instantaneous"
classes: ["Cleric", "Druid", "Sorcerer", "Warlock", "Wizard"]
---

# Plane Shift
Level 7 Conjuration

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a forked, metal rod worth 250+ GP and attuned to a plane of existence)
- Duration: Instantaneous
- Classes: Cleric, Druid, Sorcerer, Warlock, Wizard

You and up to eight willing creatures who link hands in a circle are transported to a different plane of existence. You can specify a target destination in general terms, such as a specific city on the Elemental Plane of Fire or palace on the second level of the Nine Hells, and you appear in or near that destination, as determined by the GM.

Alternatively, if you know the sigil sequence of a teleportation circle on another plane of existence, this spell can take you to that circle. If the teleportation circle is too small to hold all the creatures you transported, they appear in the closest unoccupied spaces next to the circle.
`,
      "Plant-Growth.md": `---
smType: spell
name: "Plant Growth"
level: 3
school: "Transmutation"
casting_time: "Action (Overgrowth) or 8 hours (Enrichment)"
range: "150 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Bard", "Druid", "Ranger"]
---

# Plant Growth
Level 3 Transmutation

- Casting Time: Action (Overgrowth) or 8 hours (Enrichment)
- Range: 150 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Bard, Druid, Ranger

This spell channels vitality into plants. The casting time you use determines whether the spell has the Overgrowth or the Enrichment effect below.

**_Overgrowth._** Choose a point within range. All normal plants in a 100-foot-radius Sphere centered on that point become thick and overgrown. A creature moving through that area must spend 4 feet of movement for every 1 foot it moves. You can exclude one or more areas of any size within the spell's area from being affected.

**_Enrichment._** All plants in a half-mile radius centered on a point within range become enriched for 365 days. The plants yield twice the normal amount of food when harvested. They can benefit from only one *Plant Growth* per year.
`,
      "Poison-Spray.md": `---
smType: spell
name: "Poison Spray"
level: 0
school: "Necromancy"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Druid", "Sorcerer", "Warlock", "Wizard"]
attack: "ranged spell attack"
damage: "1d12"
damage_type: "Poison"
---

# Poison Spray
Cantrip Necromancy

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Druid, Sorcerer, Warlock, Wizard
- Attack: ranged spell attack
- Damage: 1d12 Poison

You spray toxic mist at a creature within range. Make a ranged spell attack against the target. On a hit, the target takes 1d12 Poison damage.
`,
      "Polymorph.md": `---
smType: spell
name: "Polymorph"
level: 4
school: "Transmutation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a caterpillar cocoon"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Bard", "Druid", "Sorcerer", "Wizard"]
save_ability: "WIS"
---

# Polymorph
Level 4 Transmutation

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a caterpillar cocoon)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Bard, Druid, Sorcerer, Wizard
- Save: WIS

You attempt to transform a creature that you can see within range into a Beast. The target must succeed on a Wisdom saving throw or shape-shift into a Beast form for the duration. That form can be any Beast you choose that has a Challenge Rating equal to or less than the target's (or the target's level if it doesn't have a Challenge Rating). The target's game statistics are replaced by the stat block of the chosen Beast, but the target retains its alignment, personality, creature type, Hit Points, and Hit Point Dice. See the "Animals" section of "Monsters" for a sample of Beast stat blocks.

The target gains a number of Temporary Hit Points equal to the Hit Points of the Beast form. These Temporary Hit Points vanish if any remain when the spell ends. The spell ends early on the target if it has no Temporary Hit Points left.

The target is limited in the actions it can perform by the anatomy of its new form, and it can't speak or cast spells.

The target's gear melds into the new form. The creature can't use or otherwise benefit from any of that equipment.
`,
      "Power-Word-Heal.md": `---
smType: spell
name: "Power Word Heal"
level: 9
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
duration: "Instantaneous"
classes: ["Bard", "Cleric"]
---

# Power Word Heal
Level 9 Enchantment

- Casting Time: Action
- Range: 60 feet
- Duration: Instantaneous
- Classes: Bard, Cleric

A wave of healing energy washes over one creature you can see within range. The target regains all its Hit Points. If the creature has the Charmed, Frightened, Paralyzed, Poisoned, or Stunned condition, the condition ends. If the creature has the Prone condition, it can use its Reaction to stand up.
`,
      "Power-Word-Kill.md": `---
smType: spell
name: "Power Word Kill"
level: 9
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
duration: "Instantaneous"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
damage: "12d12"
damage_type: "Psychic"
---

# Power Word Kill
Level 9 Enchantment

- Casting Time: Action
- Range: 60 feet
- Duration: Instantaneous
- Classes: Bard, Sorcerer, Warlock, Wizard
- Damage: 12d12 Psychic

You compel one creature you can see within range to die. If the target has 100 Hit Points or fewer, it dies. Otherwise, it takes 12d12 Psychic damage.
`,
      "Power-Word-Stun.md": `---
smType: spell
name: "Power Word Stun"
level: 8
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
save_ability: "CON"
---

# Power Word Stun
Level 8 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V
- Duration: Instantaneous
- Classes: Bard, Sorcerer, Warlock, Wizard
- Save: CON

You overwhelm the mind of one creature you can see within range. If the target has 150 Hit Points or fewer, it has the Stunned condition. Otherwise, its Speed is 0 until the start of your next turn.

The Stunned target makes a Constitution saving throw at the end of each of its turns, ending the condition on itself on a success.
`,
      "Prayer-of-Healing.md": `---
smType: spell
name: "Prayer of Healing"
level: 2
school: "Abjuration"
casting_time: "10 minutes"
range: "30 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Cleric", "Paladin"]
---

# Prayer of Healing
Level 2 Abjuration

- Casting Time: 10 minutes
- Range: 30 feet
- Components: V
- Duration: Instantaneous
- Classes: Cleric, Paladin

Up to five creatures of your choice who remain within range for the spell's entire casting gain the benefits of a Short Rest and also regain 2d8 Hit Points. A creature can't be affected by this spell again until that creature finishes a Long Rest.
`,
      "Prestidigitation.md": `---
smType: spell
name: "Prestidigitation"
level: 0
school: "Transmutation"
casting_time: "Action"
range: "10 feet"
components: ["V", "S"]
duration: "Up to 1 hour"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# Prestidigitation
Cantrip Transmutation

- Casting Time: Action
- Range: 10 feet
- Components: V, S
- Duration: Up to 1 hour
- Classes: Bard, Sorcerer, Warlock, Wizard

You create a magical effect within range. Choose the effect from the options below. If you cast this spell multiple times, you can have up to three of its non-instantaneous effects active at a time.

**_Sensory Effect._** You create an instantaneous, harmless sensory effect, such as a shower of sparks,

a puff of wind, faint musical notes, or an odd odor. *Fire Play.* You instantaneously light or snuff out a candle, a torch, or a small campfire.

**_Clean or Soil._** You instantaneously clean or soil an object no larger than 1 cubic foot.

**_Minor Sensation._** You chill, warm, or flavor up to 1 cubic foot of nonliving material for 1 hour.

**_Magic Mark._** You make a color, a small mark, or a symbol appear on an object or a surface for 1 hour.

**_Minor Creation._** You create a nonmagical trinket or an illusory image that can fit in your hand. It lasts until the end of your next turn. A trinket can deal no damage and has no monetary worth.
`,
      "Prismatic-Spray.md": `---
smType: spell
name: "Prismatic Spray"
level: 7
school: "Evocation"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "12d6"
damage_type: "Fire"
---

# Prismatic Spray
Level 7 Evocation

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Instantaneous
- Classes: Bard, Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 12d6 Fire

Eight rays of light flash from you in a 60-foot Cone. Each creature in the Cone makes a Dexterity saving throw. For each target, roll 1d8 to determine which color ray affects it, consulting the Prismatic Rays table.

Table: Prismatic Rays

| 1d8 | Ray                                                                                       |

|-----|-------------------------------------------------------------------------------------------|

| 1   | **Red.** *Failed Save:* 12d6 Fire damage. *Successful Save:* Half as much damage.         |

| 2   | **Orange.** *Failed Save:* 12d6 Acid damage. *Successful Save:* Half as much damage.      |

| 3   | **Yellow.** *Failed Save:* 12d6 Lightning damage. *Successful Save:* Half as much damage. |

| 4   | **Green.** *Failed Save:* 12d6 Poison damage. *Successful Save:* Half as much damage.     |

| 5   | **Blue.** *Failed Save:* 12d6 Cold damage. *Successful Save:* Half as much damage.        |

| 6   | **Indigo.** *Failed Save:* The target has the Restrained condition and makes a Constitution saving throw at the end of each of its turns. If it successfully saves three times, the condition ends. If it fails three times, it has the Petrified condition until it is freed by an effect like the *Greater Restoration* spell. The successes and failures needn't be consecutive; keep track of both until the target collects three of a kind. |

| 7   | **Violet.** *Failed Save:* The target has the Blinded condition and makes a Wisdom saving throw at the start of your next turn. On a successful save, the condition ends. On a failed save, the condition ends, and the creature teleports to another plane of existence (GM's choice). |

| 8   | **Special.** The target is struck by two rays. Roll twice, rerolling any 8.               |
`,
      "Prismatic-Wall.md": `---
smType: spell
name: "Prismatic Wall"
level: 9
school: "Abjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "10 minutes"
classes: ["Bard", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "12d6"
damage_type: "Fire"
---

# Prismatic Wall
Level 9 Abjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: 10 minutes
- Classes: Bard, Wizard
- Save: CON (Half damage on success)
- Damage: 12d6 Fire

A shimmering, multicolored plane of light forms a vertical opaque wall\u2014up to 90 feet long, 30 feet high, and 1 inch thick\u2014centered on a point within range. Alternatively, you shape the wall into a globe up to 30 feet in diameter centered on a point within range. The wall lasts for the duration. If you position the wall in a space occupied by a creature, the spell ends instantly without effect.

The wall sheds Bright Light within 100 feet and Dim Light for an additional 100 feet. You and creatures you designate when you cast the spell can pass through and be near the wall without harm. If another creature that can see the wall moves within 20 feet of it or starts its turn there, the creature must succeed on a Constitution saving throw or have the Blinded condition for 1 minute.

The wall consists of seven layers, each with a different color. When a creature reaches into or passes through the wall, it does so one layer at a time through all the layers. Each layer forces the creature to make a Dexterity saving throw or be affected by that layer's properties as described in the Prismatic Layers table.

The wall, which has AC 10, can be destroyed one layer at a time, in order from red to violet, by means specific to each layer. If a layer is destroyed, it is gone for the duration. *Antimagic Field* has no effect on the wall, and *Dispel Magic* can affect only the violet layer.

Table: Prismatic Layers

| Order | Effects                      |

|-------|------------------------------|

| 1     | **Red.** *Failed Save:* 12d6 Fire damage. *Successful Save:* Half as much damage. *Additional Effects*: Nonmagical ranged attacks can't pass through this layer, which is destroyed if it takes at least 25 Cold damage. |

| 2     | **Orange.** *Failed Save:* 12d6 Acid damage. *Successful Save:* Half as much damage. *Additional Effects:* Magical ranged attacks can't pass through this layer, which is destroyed by a strong wind (such as the one created by *Gust of Wind*). |

| 3     | **Yellow.** *Failed Save:* 12d6 Lightning damage. *Successful Save:* Half as much damage. *Additional Effects:* The layer is destroyed if it takes at least 60 Force damage. |

| 4     | **Green.** *Failed Save:* 12d6 Poison damage. *Successful Save:* Half as much damage. *Additional Effects:* A *Passwall* spell, or another spell of equal or greater level that can open a portal on a solid surface, destroys this layer. |

| 5     | **Blue.** *Failed Save:* 12d6 Cold damage. *Successful Save:* Half as much damage. *Additional Effects:* The layer is destroyed if it takes at least 25 Fire damage. |

| 6     | **Indigo.** *Failed Save:* The target has the Restrained condition and makes a Constitution saving throw at the end of each of its turns. If it successfully saves three times, the condition ends. If it fails three times, it has the Petrified condition until it is freed by an effect like the *Greater Restoration* spell. The successes and failures needn't be consecutive; keep track of both until the target collects three of a kind. *Additional Effects:* Spells can't be cast through this layer, which is destroyed by Bright Light shed by the *Daylight* spell. |

| 7     | **Violet.** *Failed Save:* The target has the Blinded condition and makes a Wisdom saving throw at the start of your next turn. On a successful save, the condition ends. On a failed save, the condition ends, and the creature teleports to another plane of existence (GM's choice). *Additional Effects:* This layer is destroyed by *Dispel Magic*. |
`,
      "Private-Sanctum.md": `---
smType: spell
name: "Private Sanctum"
level: 4
school: "Abjuration"
casting_time: "10 minutes"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a thin sheet of lead"
duration: "24 hours"
classes: ["Wizard"]
---

# Private Sanctum
Level 4 Abjuration

- Casting Time: 10 minutes
- Range: 120 feet
- Components: V, S, M (a thin sheet of lead)
- Duration: 24 hours
- Classes: Wizard

You make an area within range magically secure. The area is a Cube that can be as small as 5 feet to as large as 100 feet on each side. The spell lasts for the duration.

When you cast the spell, you decide what sort of security the spell provides, choosing any of the following properties:

- Sound can't pass through the barrier at the edge of the warded area.

- The barrier of the warded area appears dark and foggy, preventing vision (including Darkvision) through it.

- Sensors created by Divination spells can't appear inside the protected area or pass through the barrier at its perimeter.

- Creatures in the area can't be targeted by Divination spells.

- Nothing can teleport into or out of the warded area.

- Planar travel is blocked within the warded area.

Casting this spell on the same spot every day for 365 days makes the spell last until dispelled.
`,
      "Produce-Flame.md": `---
smType: spell
name: "Produce Flame"
level: 0
school: "Conjuration"
casting_time: "Bonus Action"
range: "Self"
components: ["V", "S"]
duration: "10 minutes"
classes: ["Druid"]
attack: "ranged spell attack"
damage: "1d8"
damage_type: "Fire"
---

# Produce Flame
Cantrip Conjuration

- Casting Time: Bonus Action
- Range: Self
- Components: V, S
- Duration: 10 minutes
- Classes: Druid
- Attack: ranged spell attack
- Damage: 1d8 Fire

A flickering flame appears in your hand and remains there for the duration. While there, the flame emits no heat and ignites nothing, and it sheds Bright Light in a 20-foot radius and Dim Light for an additional 20 feet. The spell ends if you cast it again.

Until the spell ends, you can take a Magic action to hurl fire at a creature or an object within 60 feet of you. Make a ranged spell attack. On a hit, the target takes 1d8 Fire damage.
`,
      "Programmed-Illusion.md": `---
smType: spell
name: "Programmed Illusion"
level: 6
school: "Illusion"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "jade dust worth 25+ GP"
duration: "Until dispelled"
classes: ["Bard", "Wizard"]
---

# Programmed Illusion
Level 6 Illusion

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (jade dust worth 25+ GP)
- Duration: Until dispelled
- Classes: Bard, Wizard

You create an illusion of an object, a creature, or some other visible phenomenon within range that activates when a specific trigger occurs. The illusion is imperceptible until then. It must be no larger than a 30-foot Cube, and you decide when you cast the spell how the illusion behaves and what sounds it makes. This scripted performance can last up to 5 minutes.

When the trigger you specify occurs, the illusion springs into existence and performs in the manner you described. Once the illusion finishes performing, it disappears and remains dormant for 10 minutes, after which the illusion can be activated again.

The trigger can be as general or as detailed as you like, though it must be based on visual or audible phenomena that occur within 30 feet of the area. For example, you could create an illusion of yourself to appear and warn off others who attempt to open a trapped door.

Physical interaction with the image reveals it to be illusory, since things can pass through it. A creature that takes the Study action to examine the image can determine that it is an illusion with a successful Intelligence (Investigation) check against your spell save DC. If a creature discerns the illusion for what it is, the creature can see through the image, and any noise it makes sounds hollow to the creature.
`,
      "Project-Image.md": `---
smType: spell
name: "Project Image"
level: 7
school: "Illusion"
casting_time: "Action"
range: "500 miles"
components: ["V", "S", "M"]
materials: "a statuette of yourself worth 5+ GP"
duration: "Concentration, up to 1 day"
concentration: true
classes: ["Bard", "Wizard"]
---

# Project Image
Level 7 Illusion

- Casting Time: Action
- Range: 500 miles
- Components: V, S, M (a statuette of yourself worth 5+ GP)
- Duration: Concentration, up to 1 day
- Concentration: yes
- Classes: Bard, Wizard

You create an illusory copy of yourself that lasts for the duration. The copy can appear at any location within range that you have seen before, regardless of intervening obstacles. The illusion looks and sounds like you, but it is intangible. If the illusion takes any damage, it disappears, and the spell ends.

You can see through the illusion's eyes and hear through its ears as if you were in its space. As a Magic action, you can move it up to 60 feet and make it gesture, speak, and behave in whatever way you choose. It mimics your mannerisms perfectly.

Physical interaction with the image reveals it to be illusory, since things can pass through it. A creature that takes the Study action to examine the image can determine that it is an illusion with a successful Intelligence (Investigation) check against your spell save DC. If a creature discerns the illusion for what it is, the creature can see through the image, and any noise it makes sounds hollow to the creature.
`,
      "Protection-from-Energy.md": `---
smType: spell
name: "Protection from Energy"
level: 3
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Cleric", "Druid", "Ranger", "Sorcerer", "Wizard"]
---

# Protection from Energy
Level 3 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Cleric, Druid, Ranger, Sorcerer, Wizard

For the duration, the willing creature you touch has Resistance to one damage type of your choice: Acid, Cold, Fire, Lightning, or Thunder.
`,
      "Protection-from-Evil-and-Good.md": `---
smType: spell
name: "Protection from Evil and Good"
level: 1
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a flask of Holy Water worth 25+ GP, which the spell consumes"
duration: "Concentration up to 10 minutes"
concentration: true
classes: ["Cleric", "Druid", "Paladin", "Warlock", "Wizard"]
---

# Protection from Evil and Good
Level 1 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a flask of Holy Water worth 25+ GP, which the spell consumes)
- Duration: Concentration up to 10 minutes
- Concentration: yes
- Classes: Cleric, Druid, Paladin, Warlock, Wizard

Until the spell ends, one willing creature you touch is protected against creatures that are Aberrations, Celestials, Elementals, Fey, Fiends, or Undead. The protection grants several benefits. Creatures of those types have Disadvantage on attack rolls against the target. The target also can't be possessed by or gain the Charmed or Frightened conditions from them. If the target is already possessed, Charmed, or Frightened by such a creature, the target has Advantage on any new saving throw against the relevant effect.
`,
      "Protection-from-Poison.md": `---
smType: spell
name: "Protection from Poison"
level: 2
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "1 hour"
classes: ["Cleric", "Druid", "Paladin", "Ranger"]
---

# Protection from Poison
Level 2 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: 1 hour
- Classes: Cleric, Druid, Paladin, Ranger

You touch a creature and end the Poisoned condition on it. For the duration, the target has Advantage on saving throws to avoid or end the Poisoned condition, and it has Resistance to Poison damage.
`,
      "Purify-Food-and-Drink.md": `---
smType: spell
name: "Purify Food and Drink"
level: 1
school: "Transmutation"
casting_time: "Action or Ritual"
range: "10 feet"
components: ["V", "S"]
duration: "Instantaneous"
ritual: true
classes: ["Cleric", "Druid", "Paladin"]
---

# Purify Food and Drink
Level 1 Transmutation

- Casting Time: Action or Ritual
- Range: 10 feet
- Components: V, S
- Duration: Instantaneous
- Ritual: yes
- Classes: Cleric, Druid, Paladin

You remove poison and rot from nonmagical food and drink in a 5-foot-radius Sphere centered on a point within range.

### R Spells
`,
      "Raise-Dead.md": `---
smType: spell
name: "Raise Dead"
level: 5
school: "Necromancy"
casting_time: "1 hour"
range: "Touch"
components: ["V", "S", "M"]
materials: "a diamond worth 500+ GP, which the spell consumes"
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Paladin"]
---

# Raise Dead
Level 5 Necromancy

- Casting Time: 1 hour
- Range: Touch
- Components: V, S, M (a diamond worth 500+ GP, which the spell consumes)
- Duration: Instantaneous
- Classes: Bard, Cleric, Paladin

With a touch, you revive a dead creature if it has been dead no longer than 10 days and it wasn't Undead when it died.

The creature returns to life with 1 Hit Point. This spell also neutralizes any poisons that affected the creature at the time of death.

This spell closes all mortal wounds, but it doesn't restore missing body parts. If the creature is lacking body parts or organs integral for its survival its head, for instance\u2014the spell automatically fails.

Coming back from the dead is an ordeal. The target takes a \u22124 penalty to D20 Tests. Every time the target finishes a Long Rest, the penalty is reduced by 1 until it becomes 0.
`,
      "Ray-of-Enfeeblement.md": `---
smType: spell
name: "Ray of Enfeeblement"
level: 2
school: "Necromancy"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Warlock", "Wizard"]
save_ability: "CON"
---

# Ray of Enfeeblement
Level 2 Necromancy

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Warlock, Wizard
- Save: CON

A beam of enervating energy shoots from you toward a creature within range. The target must make a Constitution saving throw. On a successful save, the target has Disadvantage on the next attack roll it makes until the start of your next turn.

On a failed save, the target has Disadvantage on Strength-based D20 Tests for the duration. During that time, it also subtracts 1d8 from all its damage rolls. The target repeats the save at the end of each of its turns, ending the spell on a success.
`,
      "Ray-of-Frost.md": `---
smType: spell
name: "Ray of Frost"
level: 0
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
attack: "ranged spell attack"
damage: "1d8"
damage_type: "Cold"
---

# Ray of Frost
Cantrip Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Attack: ranged spell attack
- Damage: 1d8 Cold

A frigid beam of blue-white light streaks toward a creature within range. Make a ranged spell attack against the target. On a hit, it takes 1d8 Cold damage, and its Speed is reduced by 10 feet until the start of your next turn.
`,
      "Ray-of-Sickness.md": `---
smType: spell
name: "Ray of Sickness"
level: 1
school: "Necromancy"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
attack: "ranged spell attack"
damage: "2d8"
damage_type: "Poison"
---

# Ray of Sickness
Level 1 Necromancy

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Attack: ranged spell attack
- Damage: 2d8 Poison

You shoot a greenish ray at a creature within range. Make a ranged spell attack against the target. On a hit, the target takes 2d8 Poison damage and has the Poisoned condition until the end of your next turn.
`,
      "Regenerate.md": `---
smType: spell
name: "Regenerate"
level: 7
school: "Transmutation"
casting_time: "1 minute"
range: "Touch"
components: ["V", "S", "M"]
materials: "a prayer wheel"
duration: "1 hour"
classes: ["Bard", "Cleric", "Druid"]
---

# Regenerate
Level 7 Transmutation

- Casting Time: 1 minute
- Range: Touch
- Components: V, S, M (a prayer wheel)
- Duration: 1 hour
- Classes: Bard, Cleric, Druid

A creature you touch regains 4d8 + 15 Hit Points. For the duration, the target regains 1 Hit Point at the start of each of its turns, and any severed body parts regrow after 2 minutes.
`,
      "Reincarnate.md": `---
smType: spell
name: "Reincarnate"
level: 5
school: "Necromancy"
casting_time: "1 hour"
range: "Touch"
components: ["V", "S", "M"]
materials: "rare oils worth 1,000+ GP, which the spell consumes"
duration: "Instantaneous"
classes: ["Druid"]
---

# Reincarnate
Level 5 Necromancy

- Casting Time: 1 hour
- Range: Touch
- Components: V, S, M (rare oils worth 1,000+ GP, which the spell consumes)
- Duration: Instantaneous
- Classes: Druid

You touch a dead Humanoid or a piece of one. If the creature has been dead no longer than 10 days, the spell forms a new body for it and calls the soul to enter that body. Roll 1d10 and consult the table below to determine the body's species, or the GM chooses another playable species.

| 1d10 | Species     |

|------|-------------|

| 1    | Roll again. |

| 2    | Dragonborn  |

| 3    | Dwarf       |

| 4    | Elf         |

| 5    | Gnome       |

| 6    | Goliath     |

| 7    | Halfling    |

| 8    | Human       |

| 9    | Orc         |

| 10   | Tiefling    |

The reincarnated creature makes any choices that a species' description offers, and the creature recalls its former life. It retains the capabilities it had in its original form, except it loses the traits of its previous species and gains the traits of its new one.
`,
      "Remove-Curse.md": `---
smType: spell
name: "Remove Curse"
level: 3
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric", "Paladin", "Warlock", "Wizard"]
---

# Remove Curse
Level 3 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric, Paladin, Warlock, Wizard

At your touch, all curses affecting one creature or object end. If the object is a cursed magic item, its curse remains, but the spell breaks its owner's Attunement to the object so it can be removed or discarded.
`,
      "Resilient-Sphere.md": `---
smType: spell
name: "Resilient Sphere"
level: 4
school: "Abjuration"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a glass sphere"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
---

# Resilient Sphere
Level 4 Abjuration

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a glass sphere)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Wizard
- Save: DEX (Half damage on success)

A shimmering sphere encloses a Large or smaller creature or object within range. An unwilling creature must succeed on a Dexterity saving throw or be enclosed for the duration.

Nothing\u2014not physical objects, energy, or other spell effects\u2014can pass through the barrier, in or out, though a creature in the sphere can breathe there. The sphere is immune to all damage, and a creature or object inside can't be damaged by attacks or effects originating from outside, nor can a creature inside the sphere damage anything outside it.

The sphere is weightless and just large enough to contain the creature or object inside. An enclosed creature can take an action to push against the sphere's walls and thus roll the sphere at up to half the creature's Speed. Similarly, the globe can be picked up and moved by other creatures.

A *Disintegrate* spell targeting the globe destroys it without harming anything inside.
`,
      "Resistance.md": `---
smType: spell
name: "Resistance"
level: 0
school: "Abjuration"
casting_time: "Action"
range: "Touch"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric", "Druid"]
---

# Resistance
Cantrip Abjuration

- Casting Time: Action
- Range: Touch
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric, Druid

You touch a willing creature and choose a damage type: Acid, Bludgeoning, Cold, Fire, Lightning, Necrotic, Piercing, Poison, Radiant, Slashing, or Thunder. When the creature takes damage of the chosen type before the spell ends, the creature reduces the total damage taken by 1d4. A creature can benefit from this spell only once per turn.
`,
      "Resurrection.md": `---
smType: spell
name: "Resurrection"
level: 7
school: "Necromancy"
casting_time: "1 hour"
range: "Touch"
components: ["V", "S", "M"]
materials: "a diamond worth 1,000+ GP, which the spell consumes"
duration: "Instantaneous"
classes: ["Bard", "Cleric"]
---

# Resurrection
Level 7 Necromancy

- Casting Time: 1 hour
- Range: Touch
- Components: V, S, M (a diamond worth 1,000+ GP, which the spell consumes)
- Duration: Instantaneous
- Classes: Bard, Cleric

With a touch, you revive a dead creature that has been dead for no more than a century, didn't die of old age, and wasn't Undead when it died.

The creature returns to life with all its Hit Points. This spell also neutralizes any poisons that affected the creature at the time of death. This spell closes all mortal wounds and restores any missing body parts.

Coming back from the dead is an ordeal. The target takes a \u22124 penalty to D20 Tests. Every time the target finishes a Long Rest, the penalty is reduced by 1 until it becomes 0.

Casting this spell to revive a creature that has been dead for 365 days or longer taxes you. Until you finish a Long Rest, you can't cast spells again, and you have Disadvantage on D20 Tests.
`,
      "Reverse-Gravity.md": `---
smType: spell
name: "Reverse Gravity"
level: 7
school: "Transmutation"
casting_time: "Action"
range: "100 feet"
components: ["V", "S", "M"]
materials: "a lodestone and iron filings"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "DEX"
---

# Reverse Gravity
Level 7 Transmutation

- Casting Time: Action
- Range: 100 feet
- Components: V, S, M (a lodestone and iron filings)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Sorcerer, Wizard
- Save: DEX

This spell reverses gravity in a 50-foot-radius, 100 foot high Cylinder centered on a point within range. All creatures and objects in that area that aren't anchored to the ground fall upward and reach the top of the Cylinder. A creature can make a Dexterity saving throw to grab a fixed object it can reach, thus avoiding the fall upward.

If a ceiling or an anchored object is encountered in this upward fall, creatures and objects strike it just as they would during a downward fall. If an affected creature or object reaches the Cylinder's top without striking anything, it hovers there for the duration. When the spell ends, affected objects and creatures fall downward.
`,
      "Revivify.md": `---
smType: spell
name: "Revivify"
level: 3
school: "Necromancy"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a diamond worth 300+ GP, which the spell consumes"
duration: "Instantaneous"
classes: ["Cleric", "Druid", "Paladin", "Ranger"]
---

# Revivify
Level 3 Necromancy

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a diamond worth 300+ GP, which the spell consumes)
- Duration: Instantaneous
- Classes: Cleric, Druid, Paladin, Ranger

You touch a creature that has died within the last minute. That creature revives with 1 Hit Point. This spell can't revive a creature that has died of old age, nor does it restore any missing body parts.
`,
      "Rope-Trick.md": `---
smType: spell
name: "Rope Trick"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a segment of rope"
duration: "1 hour"
classes: ["Wizard"]
---

# Rope Trick
Level 2 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a segment of rope)
- Duration: 1 hour
- Classes: Wizard

You touch a rope. One end of it hovers upward until the rope hangs perpendicular to the ground or the rope reaches a ceiling. At the rope's upper end, an Invisible 3-foot-by-5-foot portal opens to an extradimensional space that lasts until the spell ends. That space can be reached by climbing the rope, which can be pulled into or dropped out of it.

The space can hold up to eight Medium or smaller creatures. Attacks, spells, and other effects can't pass into or out of the space, but creatures inside it can see through the portal. Anything inside the space drops out when the spell ends.

### S Spells
`,
      "Sacred-Flame.md": `---
smType: spell
name: "Sacred Flame"
level: 0
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "1d8"
damage_type: "Radiant"
---

# Sacred Flame
Cantrip Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric
- Save: DEX (Half damage on success)
- Damage: 1d8 Radiant

Flame-like radiance descends on a creature that you can see within range. The target must succeed on a Dexterity saving throw or take 1d8 Radiant damage. The target gains no benefit from Half Cover or Three-Quarters Cover for this save.
`,
      "Sanctuary.md": `---
smType: spell
name: "Sanctuary"
level: 1
school: "Abjuration"
casting_time: "Bonus Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a shard of glass from a mirror"
duration: "1 minute"
classes: ["Cleric"]
save_ability: "WIS"
---

# Sanctuary
Level 1 Abjuration

- Casting Time: Bonus Action
- Range: 30 feet
- Components: V, S, M (a shard of glass from a mirror)
- Duration: 1 minute
- Classes: Cleric
- Save: WIS

You ward a creature within range. Until the spell ends, any creature who targets the warded creature with an attack roll or a damaging spell must succeed on a Wisdom saving throw or either choose a new target or lose the attack or spell. This spell doesn't protect the warded creature from areas of effect. The spell ends if the warded creature makes an attack roll, casts a spell, or deals damage.
`,
      "Scorching-Ray.md": `---
smType: spell
name: "Scorching Ray"
level: 2
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
attack: "ranged spell attack"
damage: "2d6"
damage_type: "Fire"
---

# Scorching Ray
Level 2 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Attack: ranged spell attack
- Damage: 2d6 Fire

You hurl three fiery rays. You can hurl them at one target within range or at several. Make a ranged spell attack for each ray. On a hit, the target takes 2d6 Fire damage.
`,
      "Scrying.md": `---
smType: spell
name: "Scrying"
level: 5
school: "Divination"
casting_time: "10 minutes"
range: "Self"
components: ["V", "S", "M"]
materials: "a focus worth 1,000+ GP, such as a crystal ball, mirror, or water-filled font"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Bard", "Cleric", "Druid", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Scrying
Level 5 Divination

- Casting Time: 10 minutes
- Range: Self
- Components: V, S, M (a focus worth 1,000+ GP, such as a crystal ball, mirror, or water-filled font)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Bard, Cleric, Druid, Warlock, Wizard
- Save: WIS

You can see and hear a creature you choose that is on the same plane of existence as you. The target makes a Wisdom saving throw, which is modified (see the tables below) by how well you know the target and the sort of physical connection you have to it. The target doesn't know what it is making the save against, only that it feels uneasy.

| Your Knowledge of the Target Is \u2026       | Save Modifier |

|-----------------------------------------|---------------|

| Secondhand (heard of the target)        | +5            |

| Firsthand (met the target)              | +0            |

| Extensive (know the target well)        | \u22125            |

| You Have the Target's \u2026                 | Save Modifier |

|-----------------------------------------|---------------|

| Picture or other likeness               | \u22122            |

| Garment or other possession             | \u22124            |

| Body part, lock of hair, or bit of nail | \u221210           |

On a successful save, the target isn't affected, and you can't use this spell on it again for 24 hours.

On a failed save, the spell creates an Invisible, intangible sensor within 10 feet of the target. You can see and hear through the sensor as if you were there. The sensor moves with the target, remaining within 10 feet of it for the duration. If something can see the sensor, it appears as a luminous orb about the size of your fist.

Instead of targeting a creature, you can target a location you have seen. When you do so, the sensor appears at that location and doesn't move.
`,
      "Searing-Smite.md": `---
smType: spell
name: "Searing Smite"
level: 1
school: "Evocation"
casting_time: "Bonus Action, which you take immediately after hitting a target with a Melee weapon or an Unarmed Strike"
range: "Self"
duration: "1 minute"
classes: ["Paladin"]
save_ability: "CON"
damage: "1d6"
damage_type: "Fire"
---

# Searing Smite
Level 1 Evocation

- Casting Time: Bonus Action, which you take immediately after hitting a target with a Melee weapon or an Unarmed Strike
- Range: Self
- Duration: 1 minute
- Classes: Paladin
- Save: CON
- Damage: 1d6 Fire

As you hit the target, it takes an extra 1d6 Fire damage from the attack. At the start of each of its turns until the spell ends, the target takes 1d6 Fire damage and then makes a Constitution saving throw. On a failed save, the spell continues. On a successful save, the spell ends.
`,
      "Secret-Chest.md": `---
smType: spell
name: "Secret Chest"
level: 4
school: "Conjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a chest, 3 feet by 2 feet by 2 feet, constructed from rare materials worth 5,000+ GP, and a Tiny replica of the chest made from the same materials worth 50+ GP"
duration: "Until dispelled"
classes: ["Wizard"]
---

# Secret Chest
Level 4 Conjuration

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a chest, 3 feet by 2 feet by 2 feet, constructed from rare materials worth 5,000+ GP, and a Tiny replica of the chest made from the same materials worth 50+ GP)
- Duration: Until dispelled
- Classes: Wizard

You hide a chest and all its contents on the Ethereal Plane. You must touch the chest and the miniature replica that serve as Material components for the spell. The chest can contain up to 12 cubic feet of nonliving material (3 feet by 2 feet by 2 feet).

While the chest remains on the Ethereal Plane, you can take a Magic action and touch the replica to recall the chest. It appears in an unoccupied space on the ground within 5 feet of you. You can send the chest back to the Ethereal Plane by taking a Magic action to touch the chest and the replica.

After 60 days, there is a cumulative 5 percent chance at the end of each day that the spell ends. The spell also ends if you cast this spell again or if the Tiny replica chest is destroyed. If the spell ends and the larger chest is on the Ethereal Plane, the chest remains there for you or someone else to find.
`,
      "See-Invisibility.md": `---
smType: spell
name: "See Invisibility"
level: 2
school: "Divination"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a pinch of talc"
duration: "1 hour"
classes: ["Bard", "Sorcerer", "Wizard"]
---

# See Invisibility
Level 2 Divination

- Casting Time: Action
- Range: Self
- Components: V, S, M (a pinch of talc)
- Duration: 1 hour
- Classes: Bard, Sorcerer, Wizard

For the duration, you see creatures and objects that have the Invisible condition as if they were visible, and you can see into the Ethereal Plane. Creatures and objects there appear ghostly.
`,
      "Seeming.md": `---
smType: spell
name: "Seeming"
level: 5
school: "Illusion"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "8 hours"
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "CHA"
---

# Seeming
Level 5 Illusion

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: 8 hours
- Classes: Bard, Sorcerer, Wizard
- Save: CHA

You give an illusory appearance to each creature of your choice that you can see within range. An unwilling target can make a Charisma saving throw, and if it succeeds, it is unaffected by this spell.

You can give the same appearance or different ones to the targets. The spell can change the appearance of the targets' bodies and equipment. You can make each creature seem 1 foot shorter or taller and appear heavier or lighter. A target's new appearance must have the same basic arrangement of limbs as the target, but the extent of the illusion is otherwise up to you. The spell lasts for the duration.

The changes wrought by this spell fail to hold up to physical inspection. For example, if you use this spell to add a hat to a creature's outfit, objects pass through the hat.

A creature that takes the Study action to examine a target can make an Intelligence (Investigation) check against your spell save DC. If it succeeds, it becomes aware that the target is disguised.
`,
      "Sending.md": `---
smType: spell
name: "Sending"
level: 3
school: "Divination"
casting_time: "Action"
range: "Unlimited"
components: ["V", "S", "M"]
materials: "a copper wire"
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Wizard"]
---

# Sending
Level 3 Divination

- Casting Time: Action
- Range: Unlimited
- Components: V, S, M (a copper wire)
- Duration: Instantaneous
- Classes: Bard, Cleric, Wizard

You send a short message of 25 words or fewer to a creature you have met or a creature described to you by someone who has met it. The target hears the message in its mind, recognizes you as the sender if it knows you, and can answer in a like manner immediately. The spell enables targets to understand the meaning of your message.

You can send the message across any distance and even to other planes of existence, but if the target is on a different plane than you, there is a 5 percent chance that the message doesn't arrive. You know if the delivery fails.

Upon receiving your message, a creature can block your ability to reach it again with this spell for 8 hours. If you try to send another message during that time, you learn that you are blocked, and the spell fails.
`,
      "Sequester.md": `---
smType: spell
name: "Sequester"
level: 7
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "gem dust worth 5,000+ GP, which the spell consumes"
duration: "Until dispelled"
classes: ["Wizard"]
---

# Sequester
Level 7 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (gem dust worth 5,000+ GP, which the spell consumes)
- Duration: Until dispelled
- Classes: Wizard

With a touch, you magically sequester an object or a willing creature. For the duration, the target has the Invisible condition and can't be targeted by Divination spells, detected by magic, or viewed remotely with magic.

If the target is a creature, it enters a state of suspended animation; it has the Unconscious condition, doesn't age, and doesn't need food, water, or air.

You can set a condition for the spell to end early. The condition can be anything you choose, but it must occur or be visible within 1 mile of the target. Examples include "after 1,000 years" or "when the tarrasque awakens." This spell also ends if the target takes any damage.
`,
      "Shapechange.md": `---
smType: spell
name: "Shapechange"
level: 9
school: "Transmutation"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a jade circlet worth 1,500+ GP"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Druid", "Wizard"]
---

# Shapechange
Level 9 Transmutation

- Casting Time: Action
- Range: Self
- Components: V, S, M (a jade circlet worth 1,500+ GP)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Druid, Wizard

You shape-shift into another creature for the duration or until you take a Magic action to shape-shift into a different eligible form. The new form must be of a creature that has a Challenge Rating no higher than your level or Challenge Rating. You must have seen the sort of creature before, and it can't be a Construct or an Undead.

When you cast the spell, you gain a number of Temporary Hit Points equal to the Hit Points of the first form into which you shape-shift. These Temporary Hit Points vanish if any remain when the spell ends.

Your game statistics are replaced by the stat block of the chosen form, but you retain your creature type; alignment; personality; Intelligence, Wisdom, and Charisma scores; Hit Points; Hit Point Dice; proficiencies; and ability to communicate. If you have the Spellcasting feature, you retain it too.

Upon shape-shifting, you determine whether your equipment drops to the ground or changes in size and shape to fit the new form while you're in it.
`,
      "Shatter.md": `---
smType: spell
name: "Shatter"
level: 2
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a chip of mica"
duration: "Instantaneous"
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "3d8"
damage_type: "Thunder"
---

# Shatter
Level 2 Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a chip of mica)
- Duration: Instantaneous
- Classes: Bard, Sorcerer, Wizard
- Save: CON (Half damage on success)
- Damage: 3d8 Thunder

A loud noise erupts from a point of your choice within range. Each creature in a 10-foot-radius Sphere centered there makes a Constitution saving throw, taking 3d8 Thunder damage on a failed save or half as much damage on a successful one. A Construct has Disadvantage on the save.

A nonmagical object that isn't being worn or carried also takes the damage if it's in the spell's area.
`,
      "Shield-of-Faith.md": `---
smType: spell
name: "Shield of Faith"
level: 1
school: "Abjuration"
casting_time: "Bonus Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a prayer scroll"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Cleric", "Paladin"]
---

# Shield of Faith
Level 1 Abjuration

- Casting Time: Bonus Action
- Range: 60 feet
- Components: V, S, M (a prayer scroll)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Cleric, Paladin

A shimmering field surrounds a creature of your choice within range, granting it a +2 bonus to AC for the duration.
`,
      "Shield.md": `---
smType: spell
name: "Shield"
level: 1
school: "Abjuration"
casting_time: "Reaction, which you take when you are hit by an attack roll or targeted by the *Magic Missile* spell"
range: "Self"
components: ["V", "S"]
duration: "1 round"
classes: ["Sorcerer", "Wizard"]
---

# Shield
Level 1 Abjuration

- Casting Time: Reaction, which you take when you are hit by an attack roll or targeted by the *Magic Missile* spell
- Range: Self
- Components: V, S
- Duration: 1 round
- Classes: Sorcerer, Wizard

An imperceptible barrier of magical force protects you. Until the start of your next turn, you have a +5 bonus to AC, including against the triggering attack, and you take no damage from *Magic Missile*.
`,
      "Shillelagh.md": `---
smType: spell
name: "Shillelagh"
level: 0
school: "Transmutation"
casting_time: "Bonus Action"
range: "Self"
components: ["V", "S", "M"]
materials: "mistletoe"
duration: "1 minute"
classes: ["Druid"]
---

# Shillelagh
Cantrip Transmutation

- Casting Time: Bonus Action
- Range: Self
- Components: V, S, M (mistletoe)
- Duration: 1 minute
- Classes: Druid

A Club or Quarterstaff you are holding is imbued with nature's power. For the duration, you can use your spellcasting ability instead of Strength for the attack and damage rolls of melee attacks using that weapon, and the weapon's damage die becomes a d8. If the attack deals damage, it can be Force damage or the weapon's normal damage type (your choice).

The spell ends early if you cast it again or if you let go of the weapon.
`,
      "Shining-Smite.md": `---
smType: spell
name: "Shining Smite"
level: 2
school: "Transmutation"
casting_time: "Bonus Action, which you take immediately after hitting a creature with a Melee weapon or an Unarmed Strike"
range: "Self"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Paladin"]
damage: "2d6"
damage_type: "Radiant"
---

# Shining Smite
Level 2 Transmutation

- Casting Time: Bonus Action, which you take immediately after hitting a creature with a Melee weapon or an Unarmed Strike
- Range: Self
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Paladin
- Damage: 2d6 Radiant

The target hit by the strike takes an extra 2d6 Radiant damage from the attack. Until the spell ends, the target sheds Bright Light in a 5-foot radius, attack rolls against it have Advantage, and it can't benefit from the Invisible condition.
`,
      "Shocking-Grasp.md": `---
smType: spell
name: "Shocking Grasp"
level: 0
school: "Evocation"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
attack: "melee spell attack"
damage: "1d8"
damage_type: "Lightning"
---

# Shocking Grasp
Cantrip Evocation

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Attack: melee spell attack
- Damage: 1d8 Lightning

Lightning springs from you to a creature that you try to touch. Make a melee spell attack against the target. On a hit, the target takes 1d8 Lightning damage, and it can't make Opportunity Attacks until the start of its next turn.
`,
      "Silence.md": `---
smType: spell
name: "Silence"
level: 2
school: "Illusion"
casting_time: "Action or Ritual"
range: "120 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
ritual: true
classes: ["Bard", "Cleric", "Ranger"]
---

# Silence
Level 2 Illusion

- Casting Time: Action or Ritual
- Range: 120 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Ritual: yes
- Classes: Bard, Cleric, Ranger

For the duration, no sound can be created within or pass through a 20-foot-radius Sphere centered on a point you choose within range. Any creature or object entirely inside the Sphere has Immunity to Thunder damage, and creatures have the Deafened condition while entirely inside it. Casting a spell that includes a Verbal component is impossible there.
`,
      "Silent-Image.md": `---
smType: spell
name: "Silent Image"
level: 1
school: "Illusion"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a bit of fleece"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
---

# Silent Image
Level 1 Illusion

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a bit of fleece)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard

You create the image of an object, a creature, or some other visible phenomenon that is no larger than a 15-foot Cube. The image appears at a spot within range and lasts for the duration. The image is purely visual; it isn't accompanied by sound, smell, or other sensory effects.

As a Magic action, you can cause the image to move to any spot within range. As the image changes location, you can alter its appearance so that its movements appear natural for the image. For example, if you create an image of a creature and move it, you can alter the image so that it appears to be walking.

Physical interaction with the image reveals it to be an illusion, since things can pass through it. A creature that takes a Study action to examine the image can determine that it is an illusion with a successful Intelligence (Investigation) check against your spell save DC. If a creature discerns the illusion for what it is, the creature can see through the image.
`,
      "Simulacrum.md": `---
smType: spell
name: "Simulacrum"
level: 7
school: "Illusion"
casting_time: "12 hours"
range: "Touch"
components: ["V", "S", "M"]
materials: "powdered ruby worth 1,500+ GP, which the spell consumes"
duration: "Until dispelled"
classes: ["Wizard"]
save_effect: "Half damage on success"
---

# Simulacrum
Level 7 Illusion

- Casting Time: 12 hours
- Range: Touch
- Components: V, S, M (powdered ruby worth 1,500+ GP, which the spell consumes)
- Duration: Until dispelled
- Classes: Wizard

You create a simulacrum of one Beast or Humanoid that is within 10 feet of you for the entire casting of the spell. You finish the casting by touching both the creature and a pile of ice or snow that is the same size as that creature, and the pile turns into the simulacrum, which is a creature. It uses the game statistics of the original creature at the time of casting, except it is a Construct, its Hit Point maximum is half as much, and it can't cast this spell.

The simulacrum is Friendly to you and creatures you designate. It obeys your commands and acts on your turn in combat. The simulacrum can't gain levels, and it can't take Short or Long Rests.

If the simulacrum takes damage, the only way to restore its Hit Points is to repair it as you take a Long Rest, during which you expend components worth 100 GP per Hit Point restored. The simulacrum must stay within 5 feet of you for the repair.

The simulacrum lasts until it drops to 0 Hit Points, at which point it reverts to snow and melts away. If you cast this spell again, any simulacrum you created with this spell is instantly destroyed.
`,
      "Sleep.md": `---
smType: spell
name: "Sleep"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a pinch of sand or rose petals"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "WIS"
---

# Sleep
Level 1 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a pinch of sand or rose petals)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard
- Save: WIS

Each creature of your choice in a 5-foot-radius Sphere centered on a point within range must succeed on a Wisdom saving throw or have the Incapacitated condition until the end of its next turn, at which point it must repeat the save. If the target fails the second save, the target has the Unconscious condition for the duration. The spell ends on a target if it takes damage or someone within 5 feet of it takes an action to shake it out of the spell's effect.

Creatures that don't sleep, such as elves, or that have Immunity to the Exhaustion condition automatically succeed on saves against this spell.
`,
      "Sleet-Storm.md": `---
smType: spell
name: "Sleet Storm"
level: 3
school: "Conjuration"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "a miniature umbrella"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "DEX"
---

# Sleet Storm
Level 3 Conjuration

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (a miniature umbrella)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Sorcerer, Wizard
- Save: DEX

Until the spell ends, sleet falls in a 40-foot-tall, 20-foot-radius Cylinder centered on a point you choose within range. The area is Heavily Obscured, and exposed flames in the area are doused.

Ground in the Cylinder is Difficult Terrain. When a creature enters the Cylinder for the first time on a turn or starts its turn there, it must succeed on a

Dexterity saving throw or have the Prone condition and lose Concentration.
`,
      "Slow.md": `---
smType: spell
name: "Slow"
level: 3
school: "Transmutation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a drop of molasses"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "WIS"
---

# Slow
Level 3 Transmutation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a drop of molasses)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard
- Save: WIS

You alter time around up to six creatures of your choice in a 40-foot Cube within range. Each target must succeed on a Wisdom saving throw or be affected by this spell for the duration.

An affected target's Speed is halved, it takes a \u22122 penalty to AC and Dexterity saving throws, and it can't take Reactions. On its turns, it can take either an action or a Bonus Action, not both, and it can make only one attack if it takes the Attack action. If it casts a spell with a Somatic component, there is a 25 percent chance the spell fails as a result of the target making the spell's gestures too slowly.

An affected target repeats the save at the end of each of its turns, ending the spell on itself on a success.
`,
      "Sorcerous-Burst.md": `---
smType: spell
name: "Sorcerous Burst"
level: 0
school: "Evocation"
casting_time: "Action"
range: "120 feet"
duration: "Instantaneous"
classes: ["Sorcerer"]
attack: "ranged spell attack"
---

# Sorcerous Burst
Cantrip Evocation

- Casting Time: Action
- Range: 120 feet
- Duration: Instantaneous
- Classes: Sorcerer
- Attack: ranged spell attack

You cast sorcerous energy at one creature or object within range. Make a ranged spell attack against the target. On a hit, the target takes 1d8 damage of a type you choose: Acid, Cold, Fire, Lightning, Poison, Psychic, or Thunder.

If you roll an 8 on a d8 for this spell, you can roll another d8, and add it to the damage. When you cast this spell, the maximum number of these d8s you can add to the spell's damage equals your spellcasting ability modifier.
`,
      "Spare-the-Dying.md": `---
smType: spell
name: "Spare the Dying"
level: 0
school: "Necromancy"
casting_time: "Action"
range: "15 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric", "Druid"]
---

# Spare the Dying
Cantrip Necromancy

- Casting Time: Action
- Range: 15 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric, Druid

Choose a creature within range that has 0 Hit Points and isn't dead. The creature becomes Stable.
`,
      "Speak-with-Animals.md": `---
smType: spell
name: "Speak with Animals"
level: 1
school: "Divination"
casting_time: "Action or Ritual"
range: "Self"
components: ["V", "S"]
duration: "10 minutes"
ritual: true
classes: ["Bard", "Druid", "Ranger", "Warlock"]
---

# Speak with Animals
Level 1 Divination

- Casting Time: Action or Ritual
- Range: Self
- Components: V, S
- Duration: 10 minutes
- Ritual: yes
- Classes: Bard, Druid, Ranger, Warlock

For the duration, you can comprehend and verbally communicate with Beasts, and you can use any of the Influence action's skill options with them.

Most Beasts have little to say about topics that don't pertain to survival or companionship, but at minimum, a Beast can give you information about nearby locations and monsters, including whatever it has perceived within the past day.
`,
      "Speak-with-Dead.md": `---
smType: spell
name: "Speak with Dead"
level: 3
school: "Necromancy"
casting_time: "Action"
range: "10 feet"
components: ["V", "S", "M"]
materials: "burning incense"
duration: "10 minutes"
classes: ["Bard", "Cleric", "Wizard"]
---

# Speak with Dead
Level 3 Necromancy

- Casting Time: Action
- Range: 10 feet
- Components: V, S, M (burning incense)
- Duration: 10 minutes
- Classes: Bard, Cleric, Wizard

You grant the semblance of life to a corpse of your choice within range, allowing it to answer questions you pose. The corpse must have a mouth, and this spell fails if the deceased creature was Undead when it died. The spell also fails if the corpse was the target of this spell within the past 10 days.

Until the spell ends, you can ask the corpse up to five questions. The corpse knows only what it knew in life, including the languages it knew. Answers are usually brief, cryptic, or repetitive, and the corpse is under no compulsion to offer a truthful answer if you are antagonistic toward it or it recognizes you as an enemy. This spell doesn't return the creature's soul to its body, only its animating spirit. Thus, the corpse can't learn new information, doesn't comprehend anything that has happened since it died, and can't speculate about future events.
`,
      "Speak-with-Plants.md": `---
smType: spell
name: "Speak with Plants"
level: 3
school: "Transmutation"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "10 minutes"
classes: ["Bard", "Druid", "Ranger"]
---

# Speak with Plants
Level 3 Transmutation

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: 10 minutes
- Classes: Bard, Druid, Ranger

You imbue plants in an immobile 30-foot Emanation with limited sentience and animation, giving them the ability to communicate with you and follow your simple commands. You can question plants about events in the spell's area within the past day, gaining information about creatures that have passed, weather, and other circumstances.

You can also turn Difficult Terrain caused by plant growth (such as thickets and undergrowth) into ordinary terrain that lasts for the duration. Or you can turn ordinary terrain where plants are present into Difficult Terrain that lasts for the duration.

The spell doesn't enable plants to uproot themselves and move about, but they can move their branches, tendrils, and stalks for you.

If a Plant creature is in the area, you can communicate with it as if you shared a common language.
`,
      "Spider-Climb.md": `---
smType: spell
name: "Spider Climb"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a drop of bitumen and a spider"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Sorcerer", "Warlock", "Wizard"]
---

# Spider Climb
Level 2 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a drop of bitumen and a spider)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Sorcerer, Warlock, Wizard

Until the spell ends, one willing creature you touch gains the ability to move up, down, and across vertical surfaces and along ceilings, while leaving its hands free. The target also gains a Climb Speed equal to its Speed.
`,
      "Spike-Growth.md": `---
smType: spell
name: "Spike Growth"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "seven thorns"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid", "Ranger"]
damage: "2d4"
damage_type: "Piercing"
---

# Spike Growth
Level 2 Transmutation

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (seven thorns)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid, Ranger
- Damage: 2d4 Piercing

The ground in a 20-foot-radius Sphere centered on a point within range sprouts hard spikes and thorns. The area becomes Difficult Terrain for the duration. When a creature moves into or within the area, it takes 2d4 Piercing damage for every 5 feet it travels.

The transformation of the ground is camouflaged to look natural. Any creature that can't see the area when the spell is cast must take a Search action and succeed on a Wisdom (Perception or Survival) check against your spell save DC to recognize the terrain as hazardous before entering it.
`,
      "Spirit-Guardians.md": `---
smType: spell
name: "Spirit Guardians"
level: 3
school: "Conjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a prayer scroll"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Cleric"]
save_ability: "WIS"
save_effect: "Half damage on success"
damage: "3d8"
damage_type: "Radiant"
---

# Spirit Guardians
Level 3 Conjuration

- Casting Time: Action
- Range: Self
- Components: V, S, M (a prayer scroll)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Cleric
- Save: WIS (Half damage on success)
- Damage: 3d8 Radiant

Protective spirits flit around you in a 15-foot Emanation for the duration. If you are good or neutral, their spectral form appears angelic or fey (your choice). If you are evil, they appear fiendish.

When you cast this spell, you can designate creatures to be unaffected by it. Any other creature's Speed is halved in the Emanation, and whenever the Emanation enters a creature's space and whenever a creature enters the Emanation or ends its turn there, the creature must make a Wisdom saving throw. On a failed save, the creature takes 3d8 Radiant damage (if you are good or neutral) or 3d8 Necrotic damage (if you are evil). On a successful save, the creature takes half as much damage. A creature makes this save only once per turn.
`,
      "Spiritual-Weapon.md": `---
smType: spell
name: "Spiritual Weapon"
level: 2
school: "Evocation"
casting_time: "Bonus Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric"]
attack: "melee spell attack"
---

# Spiritual Weapon
Level 2 Evocation

- Casting Time: Bonus Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric
- Attack: melee spell attack

You create a floating, spectral force that resembles a weapon of your choice and lasts for the duration. The force appears within range in a space of your choice, and you can immediately make one melee spell attack against one creature within 5 feet of the force. On a hit, the target takes Force damage equal to 1d8 plus your spellcasting ability modifier.

As a Bonus Action on your later turns, you can move the force up to 20 feet and repeat the attack against a creature within 5 feet of it.
`,
      "Starry-Wisp.md": `---
smType: spell
name: "Starry Wisp"
level: 0
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Bard", "Druid"]
attack: "ranged spell attack"
damage: "1d8"
damage_type: "Radiant"
---

# Starry Wisp
Cantrip Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Bard, Druid
- Attack: ranged spell attack
- Damage: 1d8 Radiant

You launch a mote of light at one creature or object within range. Make a ranged spell attack against the target. On a hit, the target takes 1d8 Radiant damage, and until the end of your next turn, it emits Dim Light in a 10-foot radius and can't benefit from the Invisible condition.
`,
      "Stinking-Cloud.md": `---
smType: spell
name: "Stinking Cloud"
level: 3
school: "Conjuration"
casting_time: "Action"
range: "90 feet"
components: ["V", "S", "M"]
materials: "a rotten egg"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "CON"
---

# Stinking Cloud
Level 3 Conjuration

- Casting Time: Action
- Range: 90 feet
- Components: V, S, M (a rotten egg)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard
- Save: CON

You create a 20-foot-radius Sphere of yellow, nauseating gas centered on a point within range. The cloud is Heavily Obscured. The cloud lingers in the air for the duration or until a strong wind (such as the one created by *Gust of Wind*) disperses it.

Each creature that starts its turn in the Sphere must succeed on a Constitution saving throw or have the Poisoned condition until the end of the current turn. While Poisoned in this way, the creature can't take an action or a Bonus Action.
`,
      "Stone-Shape.md": `---
smType: spell
name: "Stone Shape"
level: 4
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "soft clay"
duration: "Instantaneous"
classes: ["Cleric", "Druid", "Wizard"]
---

# Stone Shape
Level 4 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (soft clay)
- Duration: Instantaneous
- Classes: Cleric, Druid, Wizard

You touch a stone object of Medium size or smaller or a section of stone no more than 5 feet in any dimension and form it into any shape you like. For example, you could shape a large rock into a weapon, statue, or coffer, or you could make a small passage through a wall that is 5 feet thick. You could also shape a stone door or its frame to seal the door shut. The object you create can have up to two hinges and a latch, but finer mechanical detail isn't possible.
`,
      "Stoneskin.md": `---
smType: spell
name: "Stoneskin"
level: 4
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "diamond dust worth 100+ GP, which the spell consumes"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Druid", "Ranger", "Sorcerer", "Wizard"]
---

# Stoneskin
Level 4 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (diamond dust worth 100+ GP, which the spell consumes)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Druid, Ranger, Sorcerer, Wizard

Until the spell ends, one willing creature you touch has Resistance to Bludgeoning, Piercing, and Slashing damage.
`,
      "Storm-of-Vengeance.md": `---
smType: spell
name: "Storm of Vengeance"
level: 9
school: "Conjuration"
casting_time: "Action"
range: "1 mile"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "2d6"
damage_type: "Thunder"
---

# Storm of Vengeance
Level 9 Conjuration

- Casting Time: Action
- Range: 1 mile
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid
- Save: CON (Half damage on success)
- Damage: 2d6 Thunder

A churning storm cloud forms for the duration, centered on a point within range and spreading to a radius of 300 feet. Each creature under the cloud when it appears must succeed on a Constitution saving throw or take 2d6 Thunder damage and have the Deafened condition for the duration.

At the start of each of your later turns, the storm produces different effects, as detailed below.

**_Turn 2._** Acidic rain falls. Each creature and object under the cloud takes 4d6 Acid damage.

**_Turn 3._** You call six bolts of lightning from the cloud to strike six different creatures or objects beneath it. Each target makes a Dexterity saving throw, taking 10d6 Lightning damage on a failed save or half as much damage on a successful one.

**_Turn 4._** Hailstones rain down. Each creature under the cloud takes 2d6 Bludgeoning damage.

**_Turns 5\u201310._** Gusts and freezing rain assail the area under the cloud. Each creature there takes 1d6 Cold damage. Until the spell ends, the area is Difficult Terrain and Heavily Obscured, ranged attacks with weapons are impossible there, and strong wind blows through the area.
`,
      "Suggestion.md": `---
smType: spell
name: "Suggestion"
level: 2
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "M"]
materials: "a drop of honey"
duration: "Concentration, up to 8 hours"
concentration: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Suggestion
Level 2 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, M (a drop of honey)
- Duration: Concentration, up to 8 hours
- Concentration: yes
- Classes: Bard, Sorcerer, Warlock, Wizard
- Save: WIS

You suggest a course of activity\u2014described in no more than 25 words\u2014to one creature you can see within range that can hear and understand you. The suggestion must sound achievable and not involve anything that would obviously deal damage to the target or its allies. For example, you could say, "Fetch the key to the cult's treasure vault, and give the key to me." Or you could say, "Stop fighting, leave this library peacefully, and don't return."

The target must succeed on a Wisdom saving throw or have the Charmed condition for the duration or until you or your allies deal damage to the target. The Charmed target pursues the suggestion to the best of its ability. The suggested activity can continue for the entire duration, but if the suggested activity can be completed in a shorter time, the spell ends for the target upon completing it.
`,
      "Summon-Dragon.md": `---
smType: spell
name: "Summon Dragon"
level: 5
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "an object with the image of a dragon engraved on it worth 500+ GP"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Wizard"]
---

# Summon Dragon
Level 5 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (an object with the image of a dragon engraved on it worth 500+ GP)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Wizard

You call forth a Dragon spirit. It manifests in an unoccupied space that you can see within range and uses the **Draconic Spirit** stat block. The creature disappears when it drops to 0 Hit Points or when the spell ends.

The creature is an ally to you and your allies. In combat, the creature shares your Initiative count, but it takes its turn immediately after yours. It obeys your verbal commands (no action required by you). If you don't issue any, it takes the Dodge action and uses its movement to avoid danger.

## At Higher Levels

> #### Draconic Spirit

>

> *Large Dragon, Neutral*

>

> **AC** 14 + the spell's level

>

> **HP** 50 + 10 for each spell level above 5

>

> **Speed** 30 ft., Fly 60 ft., Swim 30 ft.

>

> | Attribute | Score | Mod | Save |

> |-----------|-------|-----|------|

> | Str       | 19    | +4  | +4   |

> | Dex       | 14    | +2  | +2   |

> | Con       | 17    | +3  | +3   |

> | Int       | 10    | +0  | +0   |

> | Wis       | 14    | +2  | +2   |

> | Cha       | 14    | +2  | +2   |

>

> **Resistances** Acid, Cold, Fire, Lightning, Poison

>

> **Immunities** Charmed, Frightened, Poisoned

>

> **Senses** Blindsight 30 ft., Darkvision 60 ft.; Passive Perception 12

>

> **Languages** Draconic, understands the languages you know **CR** None (XP 0; PB equals your Proficiency Bonus)

>

> ##### Traits

>

> **_Shared Resistances._** When you summon the spirit, choose one of its Resistances. You have Resistance to the chosen damage type until the spell ends.

>

> ##### Actions

>

> **_Multiattack._** The spirit makes a number of Rend attacks equal to half the spell's level (round down), and it uses Breath Weapon.

>

> **_Rend. Melee Attack Roll:_** Bonus equals your spell attack modifier, reach 10 feet. *Hit:* 1d6 + 4 + the spell's level Piercing damage.

>

> **_Breath Weapon. Dexterity Saving Throw:_** DC equals your spell save DC, each creature in a 30-foot Cone. *Failure:* 2d6 damage of a type this spirit has Resistance to (your choice when you cast the spell). *Success:*  Half damage.
`,
      "Sunbeam.md": `---
smType: spell
name: "Sunbeam"
level: 6
school: "Evocation"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a magnifying glass"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric", "Druid", "Sorcerer", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "6d8"
damage_type: "Radiant"
---

# Sunbeam
Level 6 Evocation

- Casting Time: Action
- Range: Self
- Components: V, S, M (a magnifying glass)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric, Druid, Sorcerer, Wizard
- Save: CON (Half damage on success)
- Damage: 6d8 Radiant

You launch a sunbeam in a 5-foot-wide, 60-foot-long Line. Each creature in the Line makes a Constitution saving throw. On a failed save, a creature takes 6d8 Radiant damage and has the Blinded condition until the start of your next turn. On a successful save, it takes half as much damage only.

Until the spell ends, you can take a Magic action to create a new Line of radiance.

For the duration, a mote of brilliant radiance shines above you. It sheds Bright Light in a 30-foot radius and Dim Light for an additional 30 feet. This light is sunlight.
`,
      "Sunburst.md": `---
smType: spell
name: "Sunburst"
level: 8
school: "Evocation"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "a piece of sunstone"
duration: "Instantaneous"
classes: ["Cleric", "Druid", "Sorcerer", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "12d6"
damage_type: "Radiant"
---

# Sunburst
Level 8 Evocation

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (a piece of sunstone)
- Duration: Instantaneous
- Classes: Cleric, Druid, Sorcerer, Wizard
- Save: CON (Half damage on success)
- Damage: 12d6 Radiant

Brilliant sunlight flashes in a 60-foot-radius Sphere centered on a point you choose within range. Each creature in the Sphere makes a Constitution saving throw. On a failed save, a creature takes 12d6 Radiant damage and has the Blinded condition for 1 minute. On a successful save, it takes half as much damage only.

A creature Blinded by this spell makes another Constitution saving throw at the end of each of its turns, ending the effect on itself on a success.

This spell dispels Darkness in its area that was created by any spell.
`,
      "Symbol.md": `---
smType: spell
name: "Symbol"
level: 7
school: "Abjuration"
casting_time: "1 minute"
range: "Touch"
components: ["V", "S", "M"]
materials: "powdered diamond worth 1,000+ GP, which the spell consumes"
duration: "Until dispelled or triggered"
classes: ["Bard", "Cleric", "Druid", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "10d10"
damage_type: "Necrotic"
---

# Symbol
Level 7 Abjuration

- Casting Time: 1 minute
- Range: Touch
- Components: V, S, M (powdered diamond worth 1,000+ GP, which the spell consumes)
- Duration: Until dispelled or triggered
- Classes: Bard, Cleric, Druid, Wizard
- Save: CON (Half damage on success)
- Damage: 10d10 Necrotic

You inscribe a harmful glyph either on a surface (such as a section of floor or wall) or within an object that can be closed (such as a book or chest). The glyph can cover an area no larger than 10 feet in diameter. If you choose an object, it must remain in place; if it is moved more than 10 feet from where you cast this spell, the glyph is broken, and the spell ends without being triggered.

The glyph is nearly imperceptible and requires a successful Wisdom (Perception) check against your spell save DC to notice.

When you inscribe the glyph, you set its trigger and choose which effect the symbol bears: Death, Discord, Fear, Pain, Sleep, or Stunning. Each one is explained below.

**_Set the Trigger._** You decide what triggers the glyph when you cast the spell. For glyphs inscribed on a surface, common triggers include touching or stepping on the glyph, removing another object covering it, or approaching within a certain distance of it. For glyphs inscribed within an object, common triggers include opening that object or seeing the glyph.

You can refine the trigger so that only creatures of certain types activate it (for example, the glyph could be set to affect Aberrations). You can also set conditions for creatures that don't trigger the glyph, such as those who say a certain password.

Once triggered, the glyph glows, filling a 60-foot-radius Sphere with Dim Light for 10 minutes, after which time the spell ends. Each creature in the Sphere when the glyph activates is targeted by its effect, as is a creature that enters the Sphere for the first time on a turn or ends its turn there. A creature is targeted only once per turn.

**_Death._** Each target makes a Constitution saving throw, taking 10d10 Necrotic damage on a failed save or half as much damage on a successful save.

**_Discord._** Each target makes a Wisdom saving throw. On a failed save, a target argues with other creatures for 1 minute. During this time, it is incapable of meaningful communication and has Disadvantage on attack rolls and ability checks.

**_Fear._** Each target must succeed on a Wisdom saving throw or have the Frightened condition for 1 minute. While Frightened, the target must move at least 30 feet away from the glyph on each of its turns, if able.

**_Pain._** Each target must succeed on a Constitution saving throw or have the Incapacitated condition for 1 minute.

**_Sleep._** Each target must succeed on a Wisdom saving throw or have the Unconscious condition for 10 minutes. A creature awakens if it takes damage or if someone takes an action to shake it awake.

**_Stunning._** Each target must succeed on a Wisdom saving throw or have the Stunned condition for 1 minute.

### T Spells
`,
      "Telekinesis.md": `---
smType: spell
name: "Telekinesis"
level: 5
school: "Transmutation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Sorcerer", "Wizard"]
save_ability: "STR"
---

# Telekinesis
Level 5 Transmutation

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Sorcerer, Wizard
- Save: STR

You gain the ability to move or manipulate creatures or objects by thought. When you cast the spell and as a Magic action on your later turns before the spell ends, you can exert your will on one creature or object that you can see within range, causing the appropriate effect below. You can affect the same target round after round or choose a new one at any time. If you switch targets, the prior target is no longer affected by the spell.

**_Creature._** You can try to move a Huge or smaller creature. The target must succeed on a Strength saving throw, or you move it up to 30 feet in any direction within the spell's range. Until the end of your next turn, the creature has the Restrained condition, and if you lift it into the air, it is suspended there. It falls at the end of your next turn unless you use this option on it again and it fails the save.

**_Object._** You can try to move a Huge or smaller object. If the object isn't being worn or carried, you automatically move it up to 30 feet in any direction within the spell's range.

If the object is worn or carried by a creature, that creature must succeed on a Strength saving throw, or you pull the object away and move it up to 30 feet in any direction within the spell's range.

You can exert fine control on objects with your telekinetic grip, such as manipulating a simple tool,
`,
      "Telepathic-Bond.md": `---
smType: spell
name: "Telepathic Bond"
level: 5
school: "Divination"
casting_time: "Action or Ritual"
range: "30 feet"
components: ["V", "S", "M"]
materials: "two eggs"
duration: "1 hour"
ritual: true
classes: ["Bard", "Wizard"]
---

# Telepathic Bond
Level 5 Divination

- Casting Time: Action or Ritual
- Range: 30 feet
- Components: V, S, M (two eggs)
- Duration: 1 hour
- Ritual: yes
- Classes: Bard, Wizard

You forge a telepathic link among up to eight willing creatures of your choice within range, psychically linking each creature to all the others for the duration. Creatures that can't communicate in any languages aren't affected by this spell.

Until the spell ends, the targets can communicate telepathically through the bond whether or not they share a language. The communication is possible over any distance, though it can't extend to other planes of existence.
`,
      "Teleport.md": `---
smType: spell
name: "Teleport"
level: 7
school: "Conjuration"
casting_time: "Action"
range: "10 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Bard", "Sorcerer", "Wizard"]
damage: "3d10"
damage_type: "Force"
---

# Teleport
Level 7 Conjuration

- Casting Time: Action
- Range: 10 feet
- Components: V
- Duration: Instantaneous
- Classes: Bard, Sorcerer, Wizard
- Damage: 3d10 Force

This spell instantly transports you and up to eight willing creatures that you can see within range, or a single object that you can see within range, to a destination you select. If you target an object, it must be Large or smaller, and it can't be held or carried by an unwilling creature.

The destination you choose must be known to you, and it must be on the same plane of existence as you. Your familiarity with the destination determines whether you arrive there successfully. The GM rolls 1d100 and consults the Teleportation Outcome table and the explanations after it.

Table: Teleportation Outcome

| Familiarity              | Mishap | Similar Area | Off Target | On Target |

|--------------------------|--------|--------------|------------|-----------|

| Permanent circle         | \u2014      | \u2014            | \u2014          | 01\u201300     |

| Linked object            | \u2014      | \u2014            | \u2014          | 01\u201300     |

| Very familiar            | 01\u201305  | 06\u201313        | 14\u201324      | 25\u201300     |

| Seen casually            | 01\u201333  | 34\u201343        | 44\u201353      | 54\u201300     |

| Viewed once or described | 01\u201343  | 44\u201353        | 54\u201373      | 74\u201300     |

| False destination        | 01\u201350  | 51\u201300        | \u2014          | \u2014         |

**_Familiarity._** Here are the meanings of the terms in the table's Familiarity column:

- "Permanent circle" means a permanent teleportation circle whose sigil sequence you know.

- "Linked object" means you possess an object taken from the desired destination within the last six months, such as a book from a wizard's library.

- "Very familiar" is a place you have visited often, a place you have carefully studied, or a place you can see when you cast the spell.

- "Seen casually" is a place you have seen more than once but with which you aren't very familiar.

- "Viewed once or described" is a place you have seen once, possibly using magic, or a place you know through someone else's description, perhaps from a map.

- "False destination" is a place that doesn't exist. Perhaps you tried to scry an enemy's sanctum but instead viewed an illusion, or you are attempting to teleport to a location that no longer exists.

**_Mishap._** The spell's unpredictable magic results in a difficult journey. Each teleporting creature (or the target object) takes 3d10 Force damage, and the GM rerolls on the table to see where you wind up (multiple mishaps can occur, dealing damage each time).

**_Similar Area._** You and your group (or the target object) appear in a different area that's visually or thematically similar to the target area. You appear in the closest similar place. If you are heading for your home laboratory, for example, you might appear in another person's laboratory in the same city.

**_Off Target._** You and your group (or the target object) appear 2d12 miles away from the destination in a random direction. Roll 1d8 for the direction: 1, east; 2, southeast; 3, south; 4, southwest; 5, west; 6, northwest; 7, north; or 8, northeast.

**_On Target._** You and your group (or the target object) appear where you intended.
`,
      "Teleportation-Circle.md": `---
smType: spell
name: "Teleportation Circle"
level: 5
school: "Conjuration"
casting_time: "1 minute"
range: "10 feet"
components: ["V", "M"]
materials: "rare inks worth 50+ GP, which the spell consumes"
duration: "1 round"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# Teleportation Circle
Level 5 Conjuration

- Casting Time: 1 minute
- Range: 10 feet
- Components: V, M (rare inks worth 50+ GP, which the spell consumes)
- Duration: 1 round
- Classes: Bard, Sorcerer, Warlock, Wizard

As you cast the spell, you draw a 5-foot-radius circle on the ground inscribed with sigils that link your location to a permanent teleportation circle of your choice whose sigil sequence you know and that is on the same plane of existence as you. A shimmering portal opens within the circle you drew and remains open until the end of your next turn. Any creature that enters the portal instantly appears within 5 feet of the destination circle or in the nearest unoccupied space if that space is occupied.

Many major temples, guildhalls, and other important places have permanent teleportation circles. Each circle includes a unique sigil sequence\u2014a string of runes arranged in a particular pattern.

When you first gain the ability to cast this spell, you learn the sigil sequences for two destinations on the Material Plane, determined by the GM. You might learn additional sigil sequences during your adventures. You can commit a new sigil sequence to memory after studying it for 1 minute.

You can create a permanent teleportation circle by casting this spell in the same location every day for 365 days.
`,
      "Thaumaturgy.md": `---
smType: spell
name: "Thaumaturgy"
level: 0
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V"]
duration: "Up to 1 minute"
classes: ["Cleric"]
---

# Thaumaturgy
Cantrip Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V
- Duration: Up to 1 minute
- Classes: Cleric

You manifest a minor wonder within range. You create one of the effects below within range. If you cast this spell multiple times, you can have up to three of its 1-minute effects active at a time.

**_Altered Eyes._** You alter the appearance of your eyes for 1 minute.

**_Booming Voice._** Your voice booms up to three times as loud as normal for 1 minute. For the duration, you have Advantage on Charisma (Intimidation) checks.

**_Fire Play._** You cause flames to flicker, brighten, dim, or change color for 1 minute.

**_Invisible Hand._** You instantaneously cause an unlocked door or window to fly open or slam shut.

**_Phantom Sound._** You create an instantaneous sound that originates from a point of your choice within range, such as a rumble of thunder, the cry of a raven, or ominous whispers.

**_Tremors._** You cause harmless tremors in the ground for 1 minute.
`,
      "Thunderwavea.md": `---
smType: spell
name: "Thunderwavea"
level: 1
school: "Evocation"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Bard", "Druid", "Sorcerer", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "2d8"
damage_type: "Thunder"
---

# Thunderwavea
Level 1 Evocation

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Instantaneous
- Classes: Bard, Druid, Sorcerer, Wizard
- Save: CON (Half damage on success)
- Damage: 2d8 Thunder

You unleash a wave of thunderous energy. Each creature in a 15-foot Cube originating from you makes a Constitution saving throw. On a failed save, a creature takes 2d8 Thunder damage and is pushed 10 feet away from you. On a successful save, a creature takes half as much damage only.

In addition, unsecured objects that are entirely within the Cube are pushed 10 feet away from you, and a thunderous boom is audible within 300 feet.
`,
      "Time-Stop.md": `---
smType: spell
name: "Time Stop"
level: 9
school: "Transmutation"
casting_time: "Action"
range: "Self"
components: ["V"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
---

# Time Stop
Level 9 Transmutation

- Casting Time: Action
- Range: Self
- Components: V
- Duration: Instantaneous
- Classes: Sorcerer, Wizard

You briefly stop the flow of time for everyone but yourself. No time passes for other creatures, while you take 1d4 + 1 turns in a row, during which you can use actions and move as normal.

This spell ends if one of the actions you use during this period, or any effects that you create during it, affects a creature other than you or an object being worn or carried by someone other than you. In addition, the spell ends if you move to a place more than 1,000 feet from the location where you cast it.
`,
      "Tiny-Hut.md": `---
smType: spell
name: "Tiny Hut"
level: 3
school: "Evocation"
casting_time: "1 minute or Ritual"
range: "Self"
components: ["V", "S", "M"]
materials: "a crystal bead"
duration: "8 hours"
ritual: true
classes: ["Bard", "Wizard"]
---

# Tiny Hut
Level 3 Evocation

- Casting Time: 1 minute or Ritual
- Range: Self
- Components: V, S, M (a crystal bead)
- Duration: 8 hours
- Ritual: yes
- Classes: Bard, Wizard

A 10-foot Emanation springs into existence around you and remains stationary for the duration. The spell fails when you cast it if the Emanation isn't big enough to fully encapsulate all creatures in its area.

Creatures and objects within the Emanation when you cast the spell can move through it freely. All other creatures and objects are barred from passing through it. Spells of level 3 or lower can't be cast through it, and the effects of such spells can't extend into it.

The atmosphere inside the Emanation is comfortable and dry, regardless of the weather outside. Until the spell ends, you can command the interior to have Dim Light or Darkness (no action required). The Emanation is opaque from the outside and of any color you choose, but it's transparent from the inside.

The spell ends early if you leave the Emanation or if you cast it again.
`,
      "Tongues.md": `---
smType: spell
name: "Tongues"
level: 3
school: "Divination"
casting_time: "Action"
range: "Touch"
components: ["V", "M"]
materials: "a miniature ziggurat"
duration: "1 hour"
classes: ["Bard", "Cleric", "Sorcerer", "Warlock", "Wizard"]
---

# Tongues
Level 3 Divination

- Casting Time: Action
- Range: Touch
- Components: V, M (a miniature ziggurat)
- Duration: 1 hour
- Classes: Bard, Cleric, Sorcerer, Warlock, Wizard

This spell grants the creature you touch the ability to understand any spoken or signed language that it hears or sees. Moreover, when the target communicates by speaking or signing, any creature that

knows at least one language can understand it if that creature can hear the speech or see the signing.
`,
      "Transport-via-Plants.md": `---
smType: spell
name: "Transport via Plants"
level: 6
school: "Conjuration"
casting_time: "Action"
range: "10 feet"
components: ["V", "S"]
duration: "1 minute"
classes: ["Druid"]
---

# Transport via Plants
Level 6 Conjuration

- Casting Time: Action
- Range: 10 feet
- Components: V, S
- Duration: 1 minute
- Classes: Druid

This spell creates a magical link between a Large or larger inanimate plant within range and another plant, at any distance, on the same plane of existence. You must have seen or touched the destination plant at least once before. For the duration, any creature can step into the target plant and exit from the destination plant by using 5 feet of movement.
`,
      "Tree-Stride.md": `---
smType: spell
name: "Tree Stride"
level: 5
school: "Conjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Ranger"]
---

# Tree Stride
Level 5 Conjuration

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Ranger

You gain the ability to enter a tree and move from inside it to inside another tree of the same kind within 500 feet. Both trees must be living and at least the same size as you. You must use 5 feet of movement to enter a tree. You instantly know the location of all other trees of the same kind within 500 feet and, as part of the move used to enter the tree, can either pass into one of those trees or step out of the tree you're in. You appear in a spot of your choice within 5 feet of the destination tree, using another 5 feet of movement. If you have no movement left, you appear within 5 feet of the tree you entered.

You can use this transportation ability only once on each of your turns. You must end each turn outside a tree.
`,
      "True-Polymorph.md": `---
smType: spell
name: "True Polymorph"
level: 9
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a drop of mercury, a dollop of gum arabic, and a wisp of smoke"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Bard", "Warlock", "Wizard"]
save_ability: "WIS"
---

# True Polymorph
Level 9 Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a drop of mercury, a dollop of gum arabic, and a wisp of smoke)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Bard, Warlock, Wizard
- Save: WIS

Choose one creature or nonmagical object that you can see within range. The creature shape-shifts into a different creature or a nonmagical object, or the object shape-shifts into a creature (the object must be neither worn nor carried). The transformation lasts for the duration or until the target dies or is destroyed, but if you maintain Concentration on this spell for the full duration, the spell lasts until dispelled.

An unwilling creature can make a Wisdom saving throw, and if it succeeds, it isn't affected by this spell.

**_Creature into Creature._** If you turn a creature into another kind of creature, the new form can be any kind you choose that has a Challenge Rating equal to or less than the target's Challenge Rating or level. The target's game statistics are replaced by the stat block of the new form, but it retains its Hit Points, Hit Point Dice, alignment, and personality.

The target gains a number of Temporary Hit Points equal to the Hit Points of the new form. These Temporary Hit Points vanish if any remain when the spell ends.

The target is limited in the actions it can perform by the anatomy of its new form, and it can't speak or cast spells.

The target's gear melds into the new form. The creature can't use or otherwise benefit from any of that equipment.

**_Object into Creature._** You can turn an object into any kind of creature, as long as the creature's size is no larger than the object's size and the creature has a Challenge Rating of 9 or lower. The creature is Friendly to you and your allies. In combat, it takes its turns immediately after yours, and it obeys your commands.

If the spell lasts more than an hour, you no longer control the creature. It might remain Friendly to you, depending on how you have treated it.

**_Creature into Object._** If you turn a creature into an object, it transforms along with whatever it is wearing and carrying into that form, as long as the object's size is no larger than the creature's size. The creature's statistics become those of the object, and the creature has no memory of time spent in this form after the spell ends and it returns to normal.
`,
      "True-Resurrection.md": `---
smType: spell
name: "True Resurrection"
level: 9
school: "Necromancy"
casting_time: "1 hour"
range: "Touch"
components: ["V", "S", "M"]
materials: "diamonds worth 25,000+ GP, which the spell consumes"
duration: "Instantaneous"
classes: ["Cleric", "Druid"]
---

# True Resurrection
Level 9 Necromancy

- Casting Time: 1 hour
- Range: Touch
- Components: V, S, M (diamonds worth 25,000+ GP, which the spell consumes)
- Duration: Instantaneous
- Classes: Cleric, Druid

You touch a creature that has been dead for no longer than 200 years and that died for any reason except old age. The creature is revived with all its Hit Points.

This spell closes all wounds, neutralizes any poison, cures all magical contagions, and lifts any curses affecting the creature when it died. The spell replaces damaged or missing organs and limbs. If the creature was Undead, it is restored to its non-Undead form.

The spell can provide a new body if the original no longer exists, in which case you must speak the creature's name. The creature then appears in an unoccupied space you choose within 10 feet of you.
`,
      "True-Seeing.md": `---
smType: spell
name: "True Seeing"
level: 6
school: "Divination"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "mushroom powder worth 25+ GP, which the spell consumes"
duration: "1 hour"
classes: ["Bard", "Cleric", "Sorcerer", "Warlock", "Wizard"]
---

# True Seeing
Level 6 Divination

- Casting Time: Action
- Range: Touch
- Components: V, S, M (mushroom powder worth 25+ GP, which the spell consumes)
- Duration: 1 hour
- Classes: Bard, Cleric, Sorcerer, Warlock, Wizard

For the duration, the willing creature you touch has Truesight with a range of 120 feet.
`,
      "True-Strike.md": `---
smType: spell
name: "True Strike"
level: 0
school: "Divination"
casting_time: "Action"
range: "Self"
components: ["S", "M"]
materials: "a weapon with which you have proficiency and that is worth 1+ CP"
duration: "Instantaneous"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# True Strike
Cantrip Divination

- Casting Time: Action
- Range: Self
- Components: S, M (a weapon with which you have proficiency and that is worth 1+ CP)
- Duration: Instantaneous
- Classes: Bard, Sorcerer, Warlock, Wizard

Guided by a flash of magical insight, you make one attack with the weapon used in the spell's casting. The attack uses your spellcasting ability for the attack and damage rolls instead of using Strength or Dexterity. If the attack deals damage, it can be Radiant damage or the weapon's normal damage type (your choice).
`,
      "Tsunami.md": `---
smType: spell
name: "Tsunami"
level: 8
school: "Conjuration"
casting_time: "1 minute"
range: "1 mile"
components: ["V", "S"]
duration: "Concentration, up to 6 rounds"
concentration: true
classes: ["Druid"]
save_ability: "STR"
save_effect: "Half damage on success"
damage: "6d10"
damage_type: "Bludgeoning"
---

# Tsunami
Level 8 Conjuration

- Casting Time: 1 minute
- Range: 1 mile
- Components: V, S
- Duration: Concentration, up to 6 rounds
- Concentration: yes
- Classes: Druid
- Save: STR (Half damage on success)
- Damage: 6d10 Bludgeoning

A wall of water springs into existence at a point you choose within range. You can make the wall up to 300 feet long, 300 feet high, and 50 feet thick. The wall lasts for the duration.

When the wall appears, each creature in its area makes a Strength saving throw, taking 6d10 Bludgeoning damage on a failed save or half as much damage on a successful one.

At the start of each of your turns after the wall appears, the wall, along with any creatures in it, moves 50 feet away from you. Any Huge or smaller creature inside the wall or whose space the wall enters when it moves must succeed on a Strength saving throw or take 5d10 Bludgeoning damage. A creature can take this damage only once per round. At the end of the turn, the wall's height is reduced by 50 feet, and the damage the wall deals on later rounds is reduced by 1d10. When the wall reaches 0 feet in height, the spell ends.

A creature caught in the wall can move by swimming. Because of the wave's force, though, the creature must succeed on a Strength (Athletics) check against your spell save DC to move at all. If it fails the check, it can't move. A creature that moves out of the wall falls to the ground.

### U-Z Spells
`,
      "Unseen-Servant.md": `---
smType: spell
name: "Unseen Servant"
level: 1
school: "Conjuration"
casting_time: "Action or Ritual"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a bit of string and of wood"
duration: "1 hour"
ritual: true
classes: ["Bard", "Warlock", "Wizard"]
---

# Unseen Servant
Level 1 Conjuration

- Casting Time: Action or Ritual
- Range: 60 feet
- Components: V, S, M (a bit of string and of wood)
- Duration: 1 hour
- Ritual: yes
- Classes: Bard, Warlock, Wizard

This spell creates an Invisible, mindless, shapeless, Medium force that performs simple tasks at your command until the spell ends. The servant springs into existence in an unoccupied space on the ground within range. It has AC 10, 1 Hit Point, and a Strength of 2, and it can't attack. If it drops to 0 Hit Points, the spell ends.

Once on each of your turns as a Bonus Action, you can mentally command the servant to move up to 15 feet and interact with an object. The servant can perform simple tasks that a human could do, such as fetching things, cleaning, mending, folding clothes, lighting fires, serving food, and pouring drinks. Once you give the command, the servant performs the task to the best of its ability until it completes the task, then waits for your next command.

If you command the servant to perform a task that would move it more than 60 feet away from you, the spell ends.
`,
      "Vampiric-Touch.md": `---
smType: spell
name: "Vampiric Touch"
level: 3
school: "Necromancy"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Sorcerer", "Warlock", "Wizard"]
save_effect: "Half damage on success"
attack: "melee spell attack"
damage: "3d6"
damage_type: "Necrotic"
---

# Vampiric Touch
Level 3 Necromancy

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Sorcerer, Warlock, Wizard
- Attack: melee spell attack
- Damage: 3d6 Necrotic

The touch of your shadow-wreathed hand can siphon life force from others to heal your wounds. Make a melee spell attack against one creature within reach. On a hit, the target takes 3d6 Necrotic damage, and you regain Hit Points equal to half the amount of Necrotic damage dealt.

Until the spell ends, you can make the attack again on each of your turns as a Magic action, targeting the same creature or a different one.
`,
      "Vicious-Mockery.md": `---
smType: spell
name: "Vicious Mockery"
level: 0
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Bard"]
save_ability: "WIS"
damage: "1d6"
damage_type: "Psychic"
---

# Vicious Mockery
Cantrip Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V
- Duration: Instantaneous
- Classes: Bard
- Save: WIS
- Damage: 1d6 Psychic

You unleash a string of insults laced with subtle enchantments at one creature you can see or hear within range. The target must succeed on a Wisdom saving throw or take 1d6 Psychic damage and have Disadvantage on the next attack roll it makes before the end of its next turn.
`,
      "Vitriolic-Sphere.md": `---
smType: spell
name: "Vitriolic Sphere"
level: 4
school: "Evocation"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "a drop of bile"
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "10d4"
damage_type: "Acid"
---

# Vitriolic Sphere
Level 4 Evocation

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (a drop of bile)
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 10d4 Acid

You point at a location within range, and a glowing, 1-foot-diameter ball of acid streaks there and explodes in a 20-foot-radius Sphere. Each creature in that area makes a Dexterity saving throw. On a failed save, a creature takes 10d4 Acid damage and another 5d4 Acid damage at the end of its next turn. On a successful save, a creature takes half the initial damage only.
`,
      "Wall-of-Fire.md": `---
smType: spell
name: "Wall of Fire"
level: 4
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a piece of charcoal"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "5d8"
damage_type: "Fire"
---

# Wall of Fire
Level 4 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a piece of charcoal)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 5d8 Fire

You create a wall of fire on a solid surface within range. You can make the wall up to 60 feet long, 20 feet high, and 1 foot thick, or a ringed wall up to 20 feet in diameter, 20 feet high, and 1 foot thick. The wall is opaque and lasts for the duration.

When the wall appears, each creature in its area makes a Dexterity saving throw, taking 5d8 Fire damage on a failed save or half as much damage on a successful one.

One side of the wall, selected by you when you cast this spell, deals 5d8 Fire damage to each creature that ends its turn within 10 feet of that side or inside the wall. A creature takes the same damage when it enters the wall for the first time on a turn or ends its turn there. The other side of the wall deals no damage.
`,
      "Wall-of-Force.md": `---
smType: spell
name: "Wall of Force"
level: 5
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a shard of glass"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Wizard"]
---

# Wall of Force
Level 5 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a shard of glass)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Wizard

An Invisible wall of force springs into existence at a point you choose within range. The wall appears in any orientation you choose, as a horizontal or vertical barrier or at an angle. It can be free floating or resting on a solid surface. You can form it into a hemispherical dome or a globe with a radius of up to 10 feet, or you can shape a flat surface made up of ten 10-foot-by-10-foot panels. Each panel must be contiguous with another panel. In any form, the wall is 1/4 inch thick and lasts for the duration. If the wall cuts through a creature's space when it appears, the creature is pushed to one side of the wall (you choose which side).

Nothing can physically pass through the wall. It is immune to all damage and can't be dispelled by *Dispel Magic.* A *Disintegrate* spell destroys the wall instantly, however. The wall also extends into the Ethereal Plane and blocks ethereal travel through the wall.
`,
      "Wall-of-Ice.md": `---
smType: spell
name: "Wall of Ice"
level: 6
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a piece of quartz"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "10d6"
damage_type: "Cold"
---

# Wall of Ice
Level 6 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a piece of quartz)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Wizard
- Save: DEX (Half damage on success)
- Damage: 10d6 Cold

You create a wall of ice on a solid surface within range. You can form it into a hemispherical dome or a globe with a radius of up to 10 feet, or you can shape a flat surface made up of ten 10-foot-square panels. Each panel must be contiguous with another panel. In any form, the wall is 1 foot thick and lasts for the duration.

If the wall cuts through a creature's space when it appears, the creature is pushed to one side of the wall (you choose which side) and makes a Dexterity saving throw, taking 10d6 Cold damage on a failed save or half as much damage on a successful one.

The wall is an object that can be damaged and thus breached. It has AC 12 and 30 Hit Points per 10-foot section, and it has Immunity to Cold, Poison, and Psychic damage and Vulnerability to Fire damage. Reducing a 10-foot section of wall to 0 Hit Points destroys it and leaves behind a sheet of frigid air in the space the wall occupied.

A creature moving through the sheet of frigid air for the first time on a turn makes a Constitution saving throw, taking 5d6 Cold damage on a failed save or half as much damage on a successful one.
`,
      "Wall-of-Stone.md": `---
smType: spell
name: "Wall of Stone"
level: 5
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a cube of granite"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "DEX"
---

# Wall of Stone
Level 5 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a cube of granite)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid, Sorcerer, Wizard
- Save: DEX

A nonmagical wall of solid stone springs into existence at a point you choose within range. The wall is 6 inches thick and is composed of ten 10-foot-by-10-foot panels. Each panel must be contiguous with another panel. Alternatively, you can create 10-footby-20-foot panels that are only 3 inches thick.

If the wall cuts through a creature's space when it appears, the creature is pushed to one side of the wall (you choose which side). If a creature would be surrounded on all sides by the wall (or the wall and another solid surface), that creature can make a Dexterity saving throw. On a success, it can use its Reaction to move up to its Speed so that it is no longer enclosed by the wall.

The wall can have any shape you desire, though it can't occupy the same space as a creature or object. The wall doesn't need to be vertical or rest on a firm foundation. It must, however, merge with and be solidly supported by existing stone. Thus, you can use this spell to bridge a chasm or create a ramp.

If you create a span greater than 20 feet in length, you must halve the size of each panel to create supports. You can crudely shape the wall to create battlements and the like.

The wall is an object made of stone that can be damaged and thus breached. Each panel has AC 15 and 30 Hit Points per inch of thickness, and it has Immunity to Poison and Psychic damage. Reducing a panel to 0 Hit Points destroys it and might cause connected panels to collapse at the GM's discretion.

If you maintain your Concentration on this spell for its full duration, the wall becomes permanent and can't be dispelled. Otherwise, the wall disappears when the spell ends.
`,
      "Wall-of-Thorns.md": `---
smType: spell
name: "Wall of Thorns"
level: 6
school: "Conjuration"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a handful of thorns"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "7d8"
damage_type: "Piercing"
---

# Wall of Thorns
Level 6 Conjuration

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a handful of thorns)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid
- Save: DEX (Half damage on success)
- Damage: 7d8 Piercing

You create a wall of tangled brush bristling with needle-sharp thorns. The wall appears within range on a solid surface and lasts for the duration. You choose to make the wall up to 60 feet long, 10 feet high, and 5 feet thick or a circle that has a 20-foot diameter and is up to 20 feet high and 5 feet thick. The wall blocks line of sight.

When the wall appears, each creature in its area makes a Dexterity saving throw, taking 7d8 Piercing damage on a failed save or half as much damage on a successful one.

A creature can move through the wall, albeit slowly and painfully. For every 1 foot a creature moves through the wall, it must spend 4 feet of movement. Furthermore, the first time a creature enters a space in the wall on a turn or ends its turn there, the creature makes a Dexterity saving throw, taking 7d8 Slashing damage on a failed save or half as much damage on a successful one. A creature makes this save only once per turn.
`,
      "Warding-Bond.md": `---
smType: spell
name: "Warding Bond"
level: 2
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a pair of platinum rings worth 50+ GP each, which you and the target must wear for the duration"
duration: "1 hour"
classes: ["Cleric", "Paladin"]
---

# Warding Bond
Level 2 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a pair of platinum rings worth 50+ GP each, which you and the target must wear for the duration)
- Duration: 1 hour
- Classes: Cleric, Paladin

You touch another creature that is willing and create a mystic connection between you and the target until the spell ends. While the target is within 60 feet of you, it gains a +1 bonus to AC and saving throws, and it has Resistance to all damage. Also, each time it takes damage, you take the same amount of damage.

The spell ends if you drop to 0 Hit Points or if you and the target become separated by more than 60 feet. It also ends if the spell is cast again on either of the connected creatures.
`,
      "Water-Breathing.md": `---
smType: spell
name: "Water Breathing"
level: 3
school: "Transmutation"
casting_time: "Action or Ritual"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a short reed"
duration: "24 hours"
ritual: true
classes: ["Druid", "Ranger", "Sorcerer", "Wizard"]
---

# Water Breathing
Level 3 Transmutation

- Casting Time: Action or Ritual
- Range: 30 feet
- Components: V, S, M (a short reed)
- Duration: 24 hours
- Ritual: yes
- Classes: Druid, Ranger, Sorcerer, Wizard

This spell grants up to ten willing creatures of your choice within range the ability to breathe underwater until the spell ends. Affected creatures also retain their normal mode of respiration.
`,
      "Water-Walk.md": `---
smType: spell
name: "Water Walk"
level: 3
school: "Transmutation"
casting_time: "Action or Ritual"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a piece of cork"
duration: "1 hour"
ritual: true
classes: ["Cleric", "Druid", "Ranger", "Sorcerer"]
---

# Water Walk
Level 3 Transmutation

- Casting Time: Action or Ritual
- Range: 30 feet
- Components: V, S, M (a piece of cork)
- Duration: 1 hour
- Ritual: yes
- Classes: Cleric, Druid, Ranger, Sorcerer

This spell grants the ability to move across any liquid surface\u2014such as water, acid, mud, snow, quicksand, or lava\u2014as if it were harmless solid ground (creatures crossing molten lava can still take damage from the heat). Up to ten willing creatures of your choice within range gain this ability for the duration.

An affected target must take a Bonus Action to pass from the liquid's surface into the liquid itself and vice versa, but if the target falls into the liquid, the target passes through the surface into the liquid below.
`,
      "Web.md": `---
smType: spell
name: "Web"
level: 2
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a bit of spiderweb"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
damage: "2d4"
damage_type: "Fire"
---

# Web
Level 2 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a bit of spiderweb)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Sorcerer, Wizard
- Save: DEX
- Damage: 2d4 Fire

You conjure a mass of sticky webbing at a point within range. The webs fill a 20-foot Cube there for the duration. The webs are Difficult Terrain, and the area within them is Lightly Obscured.

If the webs aren't anchored between two solid masses (such as walls or trees) or layered across a floor, wall, or ceiling, the web collapses on itself, and the spell ends at the start of your next turn. Webs layered over a flat surface have a depth of 5 feet.

The first time a creature enters the webs on a turn or starts its turn there, it must succeed on a Dexterity saving throw or have the Restrained condition while in the webs or until it breaks free.

A creature Restrained by the webs can take an action to make a Strength (Athletics) check against your spell save DC. If it succeeds, it is no longer Restrained.

The webs are flammable. Any 5-foot Cube of webs exposed to fire burns away in 1 round, dealing 2d4 Fire damage to any creature that starts its turn in the fire.
`,
      "Weird.md": `---
smType: spell
name: "Weird"
level: 9
school: "Illusion"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Warlock", "Wizard"]
save_ability: "WIS"
save_effect: "Half damage on success"
damage: "10d10"
damage_type: "Psychic"
---

# Weird
Level 9 Illusion

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Warlock, Wizard
- Save: WIS (Half damage on success)
- Damage: 10d10 Psychic

You try to create illusory terrors in others' minds. Each creature of your choice in a 30-foot-radius Sphere centered on a point within range makes a Wisdom saving throw. On a failed save, a target takes 10d10 Psychic damage and has the Frightened condition for the duration. On a successful save, a target takes half as much damage only.

A Frightened target makes a Wisdom saving throw at the end of each of its turns. On a failed save, it takes 5d10 Psychic damage. On a successful save, the spell ends on that target.
`,
      "Wind-Walk.md": `---
smType: spell
name: "Wind Walk"
level: 6
school: "Transmutation"
casting_time: "1 minute"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a candle"
duration: "8 hours"
classes: ["Druid"]
---

# Wind Walk
Level 6 Transmutation

- Casting Time: 1 minute
- Range: 30 feet
- Components: V, S, M (a candle)
- Duration: 8 hours
- Classes: Druid

You and up to ten willing creatures of your choice within range assume gaseous forms for the duration, appearing as wisps of cloud. While in this cloud form, a target has a Fly Speed of 300 feet and can hover; it has Immunity to the Prone condition; and it has Resistance to Bludgeoning, Piercing, and Slashing damage. The only actions a target can take in this form are the Dash action or a Magic action to begin reverting to its normal form. Reverting takes 1 minute, during which the target has the Stunned condition. Until the spell ends, the target can revert to cloud form, which also requires a Magic action followed by a 1-minute transformation.

If a target is in cloud form and flying when the effect ends, the target descends 60 feet per round for 1 minute until it lands, which it does safely. If it can't land after 1 minute, it falls the remaining distance.
`,
      "Wind-Wall.md": `---
smType: spell
name: "Wind Wall"
level: 3
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a fan and a feather"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Ranger"]
save_ability: "STR"
save_effect: "Half damage on success"
damage: "4d8"
damage_type: "Bludgeoning"
---

# Wind Wall
Level 3 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a fan and a feather)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Ranger
- Save: STR (Half damage on success)
- Damage: 4d8 Bludgeoning

A wall of strong wind rises from the ground at a point you choose within range. You can make the wall up to 50 feet long, 15 feet high, and 1 foot thick. You can shape the wall in any way you choose so long as it makes one continuous path along the ground. The wall lasts for the duration.

When the wall appears, each creature in its area makes a Strength saving throw, taking 4d8 Bludgeoning damage on a failed save or half as much damage on a successful one.

The strong wind keeps fog, smoke, and other gases at bay. Small or smaller flying creatures or objects can't pass through the wall. Loose, lightweight materials brought into the wall fly upward. Arrows, bolts, and other ordinary projectiles launched at targets behind the wall are deflected upward and miss automatically. Boulders hurled by Giants or siege engines, and similar projectiles, are unaffected. Creatures in gaseous form can't pass through it.
`,
      "Wish.md": `---
smType: spell
name: "Wish"
level: 9
school: "Conjuration"
casting_time: "Action"
range: "Self"
components: ["V"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
damage: "1d10"
damage_type: "Necrotic"
---

# Wish
Level 9 Conjuration

- Casting Time: Action
- Range: Self
- Components: V
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Damage: 1d10 Necrotic

*Wish* is the mightiest spell a mortal can cast. By simply speaking aloud, you can alter reality itself.

The basic use of this spell is to duplicate any other spell of level 8 or lower. If you use it this way, you don't need to meet any requirements to cast that spell, including costly components. The spell simply takes effect.

Alternatively, you can create one of the following effects of your choice:

**_Object Creation._** You create one object of up to 25,000 GP in value that isn't a magic item. The object can be no more than 300 feet in any dimension, and it appears in an unoccupied space that you can see on the ground.

**_Instant Health._** You allow yourself and up to twenty creatures that you can see to regain all Hit Points, and you end all effects on them listed in the *Greater Restoration* spell.

**_Resistance._** You grant up to ten creatures that you can see Resistance to one damage type that you choose. This Resistance is permanent.

**_Spell Immunity._** You grant up to ten creatures you can see immunity to a single spell or other magical effect for 8 hours.

**_Sudden Learning._** You replace one of your feats with another feat for which you are eligible. You lose all the benefits of the old feat and gain the benefits of the new one. You can't replace a feat that is a prerequisite for any of your other feats or features.

**_Roll Redo._** You undo a single recent event by forcing a reroll of any die roll made within the last round (including your last turn). Reality reshapes itself to accommodate the new result. For example, a *Wish* spell could undo an ally's failed saving throw or a foe's Critical Hit. You can force the reroll to be made with Advantage or Disadvantage, and you choose whether to use the reroll or the original roll.

**_Reshape Reality._** You may wish for something not included in any of the other effects. To do so, state your wish to the GM as precisely as possible. The GM has great latitude in ruling what occurs in such an instance; the greater the wish, the greater the likelihood that something goes wrong. This spell might simply fail, the effect you desire might be achieved only in part, or you might suffer an unforeseen consequence as a result of how you worded the wish. For example, wishing that a villain were dead might propel you forward in time to a period when that villain is no longer alive, effectively removing you from the game.

Similarly, wishing for a Legendary magic item or an Artifact might instantly transport you to the presence of the item's current owner. If your wish is granted and its effects have consequences for a whole community, region, or world, you are likely to attract powerful foes. If your wish would affect a god, the god's divine servants might instantly intervene to prevent it or to encourage you to craft the wish in a particular way. If your wish would undo the multiverse itself, your wish fails.

The stress of casting *Wish* to produce any effect other than duplicating another spell weakens you. After enduring that stress, each time you cast a spell until you finish a Long Rest, you take 1d10 Necrotic damage per level of that spell. This damage can't be reduced or prevented in any way. In addition, your Strength score becomes 3 for 2d4 days. For each of those days that you spend resting and doing nothing more than light activity, your remaining recovery time decreases by 2 days. Finally, there is a 33 percent chance that you are unable to cast *Wish* ever again if you suffer this stress.
`,
      "Word-of-Recall.md": `---
smType: spell
name: "Word of Recall"
level: 6
school: "Conjuration"
casting_time: "Action"
range: "5 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Cleric"]
---

# Word of Recall
Level 6 Conjuration

- Casting Time: Action
- Range: 5 feet
- Components: V
- Duration: Instantaneous
- Classes: Cleric

You and up to five willing creatures within 5 feet of you instantly teleport to a previously designated sanctuary. You and any creatures that teleport with you appear in the nearest unoccupied space to the spot you designated when you prepared your sanctuary (see below). If you cast this spell without first preparing a sanctuary, the spell has no effect.

You must designate a location, such as a temple, as a sanctuary by casting this spell there.
`,
      "Zone-of-Truth.md": `---
smType: spell
name: "Zone of Truth"
level: 2
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "10 minutes"
classes: ["Bard", "Cleric", "Paladin"]
save_ability: "CHA"
---

# Zone of Truth
Level 2 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: 10 minutes
- Classes: Bard, Cleric, Paladin
- Save: CHA

You create a magical zone that guards against deception in a 15-foot-radius Sphere centered on a point within range. Until the spell ends, a creature that enters the spell's area for the first time on a turn or starts its turn there makes a Charisma saving throw. On a failed save, a creature can't speak a deliberate lie while in the radius. You know whether a creature succeeds or fails on this save.

An affected creature is aware of the spell and can avoid answering questions to which it would normally respond with a lie. Such a creature can be evasive yet must be truthful.
`
    };
    PRESET_ITEMS = {
      "Adamantine-Armor.md": `---
smType: item
name: "Adamantine Armor"
category: "Armor"
type: "Any Medium or Heavy, Except Hide Armor"
rarity: "Uncommon"
---

# Adamantine Armor
*Armor (Any Medium or Heavy, Except Hide Armor) Uncommon*

This suit of armor is reinforced with adamantine, one of the hardest substances in existence. While you're wearing it, any Critical Hit against you becomes a normal hit.
`,
      "Ammunition-1-2-or-3.md": `---
smType: item
name: "Ammunition, +1, +2, or +3"
category: "Weapon"
type: "Any Ammunition"
rarity: "Uncommon"
---

# Ammunition, +1, +2, or +3
*Weapon (Any Ammunition) Uncommon*

You have a bonus to attack rolls and damage rolls made with this piece of magic ammunition. The bonus is determined by the rarity of the ammunition. Once it hits a target, the ammunition is no longer magical.

This ammunition is typically found or sold in quantities of ten or twenty pieces. Ten pieces of this ammunition are equivalent in value to a potion of the same rarity.
`,
      "Ammunition-of-Slaying.md": `---
smType: item
name: "Ammunition of Slaying"
category: "Weapon"
type: "Any Ammunition"
rarity: "Very Rare"
---

# Ammunition of Slaying
*Weapon (Any Ammunition) Very Rare*

This magic ammunition is meant to slay creatures of a particular type, which the GM chooses or determines randomly by rolling on the table below. If a creature of that type takes damage from the ammunition, the creature makes a DC 17 Constitution saving throw, taking an extra 6d10 Force damage on a failed save or half as much extra damage on a successful one.

After dealing its extra damage to a creature, the ammunition becomes nonmagical.
`,
      "Amulet-of-Health.md": `---
smType: item
name: "Amulet of Health"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
ability_changes_json: "[{\\"ability\\":\\"con\\",\\"value\\":19},{\\"ability\\":\\"con\\",\\"value\\":19}]"
---

# Amulet of Health
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

## Ability Changes

- CON becomes 19
- CON becomes 19

Your Constitution is 19 while you wear this amulet. It has no effect on you if your Constitution is 19 or higher without it.
`,
      "Amulet-of-Proof-against-Detection-and-Location.md": `---
smType: item
name: "Amulet of Proof against Detection and Location"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Amulet of Proof against Detection and Location
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this amulet, you can't be targeted by Divination spells or perceived through magical scrying sensors unless you allow it.
`,
      "Amulet-of-the-Planes.md": `---
smType: item
name: "Amulet of the Planes"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
---

# Amulet of the Planes
*Wondrous (Requires Attunement) Very Rare (Requires Attunement)*

While wearing this amulet, you can take a Magic action to name a location that you are familiar with on another plane of existence. Then make a DC 15 Intelligence (Arcana) check. On a successful check, you cast *Plane Shift*. On a failed check, you and each creature and object within 15 feet of you travel to a random destination determined by rolling 1d100 and consulting the following table.
`,
      "Animated-Shield.md": `---
smType: item
name: "Animated Shield"
category: "Armor"
type: "Shield"
rarity: "Very Rare"
attunement: true
---

# Animated Shield
*Armor (Shield) Very Rare (Requires Attunement)*

While holding this Shield, you can take a Bonus Action to cause it to animate. The Shield leaps into the air and hovers in your space to protect you as if you were wielding it, leaving your hands free. The Shield remains animate for 1 minute, until you take a Bonus Action to end this effect, or until you die or have the Incapacitated condition, at which point the Shield falls to the ground or into your hand if you have one free.
`,
      "Apparatus-of-the-Crab.md": `---
smType: item
name: "Apparatus of the Crab"
category: "Wondrous"
rarity: "Legendary"
---

# Apparatus of the Crab
*Wondrous Legendary*

This item first appears to be a sealed iron barrel weighing 500 pounds. The barrel has a hidden catch, which can be found with a successful DC 20 Intelligence (Investigation) check. Releasing the catch unlocks a hatch at one end of the barrel, allowing two Medium or smaller creatures to crawl inside. Ten levers are set in a row at the far end, each in a neutral position, able to move up or down. When certain levers are used, the apparatus transforms to resemble a giant lobster.

The *Apparatus of the Crab* is a Large object with the following statistics: AC 20; HP 200; Speed 30 ft., Swim 30 ft. (or 0 ft. for both if the legs aren't extended); Immunity to Poison and Psychic damage.

To be used as a vehicle, the apparatus requires one pilot. While the apparatus's hatch is closed, the compartment is airtight and watertight. The compartment holds enough air for 10 hours of breathing, divided by the number of breathing creatures inside.

The apparatus floats on water. It can also go underwater to a depth of 900 feet. Below that, the vehicle takes 2d6 Bludgeoning damage each minute from pressure.

A creature in the compartment can take a Utilize action to move as many as two of the apparatus's levers up or down. After each use, a lever goes back to its neutral position. Each lever, from left to right, functions as shown in the Apparatus of the Crab Levers table.
`,
      "Armor-1-2-or-3.md": `---
smType: item
name: "Armor, +1, +2, or +3"
category: "Armor"
type: "Any Light, Medium, or Heavy"
rarity: "Rare"
---

# Armor, +1, +2, or +3
*Armor (Any Light, Medium, or Heavy) Rare*

You have a bonus to Armor Class while wearing this armor. The bonus is determined by its rarity.
`,
      "Armor-of-Invulnerability.md": `---
smType: item
name: "Armor of Invulnerability"
category: "Armor"
type: "Plate Armor"
rarity: "Legendary"
attunement: true
---

# Armor of Invulnerability
*Armor (Plate Armor) Legendary (Requires Attunement)*

You have Resistance to Bludgeoning, Piercing, and Slashing damage while you wear this armor.

*Metal Shell.* You can take a Magic action to give yourself Immunity to Bludgeoning, Piercing, and Slashing damage for 10 minutes or until you are no longer wearing the armor. Once this property is used, it can't be used again until the next dawn.
`,
      "Armor-of-Resistance.md": `---
smType: item
name: "Armor of Resistance"
category: "Armor"
type: "Any Light, Medium, or Heavy"
rarity: "Rare"
attunement: true
---

# Armor of Resistance
*Armor (Any Light, Medium, or Heavy) Rare (Requires Attunement)*

You have Resistance to one type of damage while you wear this armor. The GM chooses the type or determines it randomly by rolling on the following table.
`,
      "Armor-of-Vulnerability.md": `---
smType: item
name: "Armor of Vulnerability"
category: "Armor"
type: "Any Light, Medium, or Heavy"
rarity: "Rare"
attunement: true
---

# Armor of Vulnerability
*Armor (Any Light, Medium, or Heavy) Rare (Requires Attunement)*

While wearing this armor, you have Resistance to one of the following damage types: Bludgeoning, Piercing, or Slashing. The GM chooses the type or determines it randomly.

*Curse.* This armor is cursed, a fact that is revealed only when the *Identify* spell is cast on the armor or you attune to it. Attuning to the armor curses you until you are targeted by a *Remove Curse* spell or similar magic; removing the armor fails to end the curse. While cursed, you have Vulnerability to two of the three damage types associated with the armor (not the one to which it grants Resistance).
`,
      "Arrow-Catching-Shield.md": `---
smType: item
name: "Arrow-Catching Shield"
category: "Armor"
type: "Shield"
rarity: "Rare"
attunement: true
---

# Arrow-Catching Shield
*Armor (Shield) Rare (Requires Attunement)*

You gain a +2 bonus to Armor Class against ranged attack rolls while you wield this Shield. This bonus is in addition to the Shield's normal bonus to AC.

Whenever an attacker makes a ranged attack roll against a target within 5 feet of you, you can take a Reaction to become the target of the attack instead.
`,
      "Bag-of-Beans.md": `---
smType: item
name: "Bag of Beans"
category: "Wondrous"
rarity: "Rare"
---

# Bag of Beans
*Wondrous Rare*

This heavy cloth bag contains 3d4 dry beans when found. The bag weighs half a pound regardless of how many beans it contains and becomes a nonmagical item when it no longer contains any beans.

If you dump one or more beans out of the bag, they explode in a 10-foot-radius Sphere centered on them. All the dumped beans are destroyed in the explosion, and each creature in the Sphere, including you, makes a DC 15 Dexterity saving throw, taking 5d4 Force damage on a failed save or half as much damage on a successful one.

If you remove a bean from the bag, plant it in dirt or sand, and then water it, the bean disappears as it produces an effect 1 minute later from the ground where it was planted. The GM can choose an effect from the following table or determine it randomly.
`,
      "Bag-of-Devouring.md": `---
smType: item
name: "Bag of Devouring"
category: "Wondrous"
rarity: "Very Rare"
---

# Bag of Devouring
*Wondrous Very Rare*

This bag resembles a *Bag of Holding* but is a feeding orifice for a gigantic extradimensional creature. Turning the bag inside out closes the orifice.

The extradimensional creature attached to the bag can sense whatever is placed inside the bag. Animal or vegetable matter placed wholly in the bag is devoured and lost forever. When part of a living creature is placed in the bag, as happens when someone reaches inside it, there is a 50 percent chance that the creature is pulled inside the bag. A creature inside the bag can take an action to try to escape, doing so with a successful DC 15 Strength (Athletics) check. Another creature can take an action to reach into the bag to pull a creature out, doing so with a successful DC 20 Strength (Athletics) check, provided the puller isn't pulled inside the bag first. Any creature that starts its turn inside the bag is devoured, its body destroyed.

Inanimate objects can be stored in the bag, which can hold a cubic foot of such material. However, once each day, the bag swallows any objects inside it and spits them out into another plane of existence. The GM determines the time and plane.

If the bag is pierced or torn, it is destroyed, and anything contained within it is transported to a random location on the Astral Plane.
`,
      "Bag-of-Holding.md": `---
smType: item
name: "Bag of Holding"
category: "Wondrous"
rarity: "Uncommon"
---

# Bag of Holding
*Wondrous Uncommon*

This bag has an interior space considerably larger than its outside dimensions\u2014roughly 2 feet square and 4 feet deep on the inside. The bag can hold up to 500 pounds, not exceeding a volume of 64 cubic feet. The bag weighs 5 pounds, regardless of its contents. Retrieving an item from the bag requires a Utilize action.

If the bag is overloaded, pierced, or torn, it is destroyed, and its contents are scattered in the Astral Plane. If the bag is turned inside out, its contents spill forth unharmed, but the bag must be put right before it can be used again. The bag holds enough air for 10 minutes of breathing, divided by the number of breathing creatures inside.

Placing a *Bag of Holding* inside an extradimensional space created by a *Handy Haversack*, *Portable Hole*, or similar item instantly destroys both items and opens a gate to the Astral Plane. The gate originates where the one item was placed inside the other. Any creature within a 10-foot-radius Sphere centered on the gate is sucked through it to a random location on the Astral Plane. The gate then closes. The gate is one-way and can't be reopened.
`,
      "Bag-of-Tricks.md": `---
smType: item
name: "Bag of Tricks"
category: "Wondrous"
rarity: "Uncommon"
---

# Bag of Tricks
*Wondrous Uncommon*

This bag made from gray, rust, or tan cloth appears empty. Reaching inside the bag, however, reveals the presence of a small, fuzzy object.

You can take a Magic action to pull the fuzzy object from the bag and throw it up to 20 feet. When the object lands, it transforms into a creature you determine by rolling on the table that corresponds to the bag's color. See "Monsters" for the creature's stat block. The creature vanishes at the next dawn or when it is reduced to 0 Hit Points.

The creature is Friendly to you and your allies, and it acts immediately after you on your Initiative count. You can take a Bonus Action to command how the creature moves and what action it takes on its next turn, such as attacking an enemy. In the absence of such orders, the creature acts in a fashion appropriate to its nature.

Once three fuzzy objects have been pulled from the bag, the bag can't be used again until the next dawn.
`,
      "Bead-of-Force.md": `---
smType: item
name: "Bead of Force"
category: "Wondrous"
rarity: "Rare"
---

# Bead of Force
*Wondrous Rare*

This small black sphere measures 3/4 of an inch in diameter and weighs an ounce. Typically, 1d4 + 4 *Beads of Force* are found together.

You can take a Magic action to throw the bead up to 60 feet. The bead explodes in a 10-foot-radius Sphere on impact and is destroyed. Each creature

in the Sphere must succeed on a DC 15 Dexterity saving throw or take 5d4 Force damage. A sphere of transparent force then encloses the area for 1 minute. Any creature that failed the save and is completely within the area is trapped inside this sphere. Creatures that succeeded on the save or are partially within the area are pushed away from the center of the sphere until they are no longer inside it. Only breathable air can pass through the sphere's wall. No attack or other effect can pass through.

An enclosed creature can take a Utilize action to push against the sphere's wall, moving the sphere up to half the creature's Speed. The sphere can be picked up, and its magic causes it to weigh only 1 pound, regardless of the weight of creatures inside.
`,
      "Belt-of-Dwarvenkind.md": `---
smType: item
name: "Belt of Dwarvenkind"
resistances: ["Poison"]
---

# Belt of Dwarvenkind

- Resistances: Poison
`,
      "Belt-of-Giant-Strength.md": `---
smType: item
name: "Belt of Giant Strength"
category: "Wondrous"
type: "Requires Attunement"
attunement: true
---

# Belt of Giant Strength
*Wondrous (Requires Attunement) (Requires Attunement)*

While wearing this belt, your Strength changes to a score granted by the belt. The type of giant determines the score (see the table below). The item has no effect on you if your Strength without the belt is equal to or greater than the belt's score.
`,
      "Berserker-Axe.md": `---
smType: item
name: "Berserker Axe"
category: "Weapon"
type: "Battleaxe, Greataxe, or Halberd"
rarity: "Rare"
attunement: true
cursed: true
curse_description: "This weapon is cursed, and becoming attuned to it extends the curse to you. As long as you remain cursed, you are unwilling to part with the weapon, keeping it within reach at all times. You also have Disadvantage on attack rolls with weapons other than this one. Whenever another creature damages you while the weapon is in your possession, you must succeed on a DC 15 Wisdom saving throw or go berserk. This berserk state ends when you start your turn and there are no creatures within 60 feet of you that you can see or hear. While berserk, you regard the creature nearest to you that you can see or hear as your enemy. If there are multiple possible creatures, choose one at random. On each of your turns, you must move as close to the creature as possible and take the Attack action, targeting the creature. If you're unable to get close enough to the creature to attack it with the weapon, your turn ends after you've used up all your available movement. If the creature dies or can no longer be seen or heard by you, the next nearest creature that you can see or hear becomes your new target."
---

# Berserker Axe
*Weapon (Battleaxe, Greataxe, or Halberd) Rare (Requires Attunement)*

You gain a +1 bonus to attack rolls and damage rolls made with this magic weapon. In addition, while you are attuned to this weapon, your Hit Point maximum increases by 1 for each level you have attained.

## Curse

This weapon is cursed, and becoming attuned to it extends the curse to you. As long as you remain cursed, you are unwilling to part with the weapon, keeping it within reach at all times. You also have Disadvantage on attack rolls with weapons other than this one. Whenever another creature damages you while the weapon is in your possession, you must succeed on a DC 15 Wisdom saving throw or go berserk. This berserk state ends when you start your turn and there are no creatures within 60 feet of you that you can see or hear. While berserk, you regard the creature nearest to you that you can see or hear as your enemy. If there are multiple possible creatures, choose one at random. On each of your turns, you must move as close to the creature as possible and take the Attack action, targeting the creature. If you're unable to get close enough to the creature to attack it with the weapon, your turn ends after you've used up all your available movement. If the creature dies or can no longer be seen or heard by you, the next nearest creature that you can see or hear becomes your new target.
`,
      "Boots-of-Elvenkind.md": `---
smType: item
name: "Boots of Elvenkind"
category: "Wondrous"
rarity: "Uncommon"
---

# Boots of Elvenkind
*Wondrous Uncommon*

While you wear these boots, your steps make no sound, regardless of the surface you are moving across. You also have Advantage on Dexterity (Stealth) checks.
`,
      "Boots-of-Levitation.md": `---
smType: item
name: "Boots of Levitation"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Boots of Levitation
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

While you wear these boots, you can cast *Levitate* on yourself.
`,
      "Boots-of-Speed.md": `---
smType: item
name: "Boots of Speed"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Boots of Speed
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

While you wear these boots, you can take a Bonus Action to click the boots' heels together. If you do, the boots double your Speed, and any creature that makes an Opportunity Attack against you has Disadvantage on the attack roll. If you click your heels together again, you end the effect.

When you've used the boots' property for a total of 10 minutes, the magic ceases to function for you until you finish a Long Rest.
`,
      "Boots-of-Striding-and-Springing.md": `---
smType: item
name: "Boots of Striding and Springing"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Boots of Striding and Springing
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While you wear these boots, your Speed becomes 30 feet unless your Speed is higher, and your Speed isn't reduced by you carrying weight in excess of your carrying capacity or wearing Heavy Armor.

Once on each of your turns, you can jump up to 30 feet by spending only 10 feet of movement.
`,
      "Boots-of-the-Winterlands.md": `---
smType: item
name: "Boots of the Winterlands"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
resistances: ["Cold"]
---

# Boots of the Winterlands
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

- Resistances: Cold

These furred boots are snug and feel warm. While wearing them, you gain the following benefits.
`,
      "Bowl-of-Commanding-Water-Elementals.md": `---
smType: item
name: "Bowl of Commanding Water Elementals"
category: "Wondrous"
rarity: "Rare"
---

# Bowl of Commanding Water Elementals
*Wondrous Rare*

While this bowl is filled with water and you are within 5 feet of it, you can take a Magic action to summon a **Water Elemental**. The elemental appears in an unoccupied space as close to the bowl as possible, understands your languages, obeys your commands, and takes its turn immediately after you on your Initiative count. The elemental disappears after 1 hour, when it dies, or when you dismiss it as a Bonus Action. The bowl can't be used this way again until the next dawn.

The bowl is about 1 foot in diameter and half as deep. It holds about 3 gallons.
`,
      "Bracers-of-Archery.md": `---
smType: item
name: "Bracers of Archery"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Bracers of Archery
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing these bracers, you have proficiency with the Longbow and Shortbow, and you gain a +2 bonus to damage rolls made with such weapons.
`,
      "Bracers-of-Defense.md": `---
smType: item
name: "Bracers of Defense"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Bracers of Defense
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

While wearing these bracers, you gain a +2 bonus to Armor Class if you are wearing no armor and using no Shield.
`,
      "Brazier-of-Commanding-Fire-Elementals.md": `---
smType: item
name: "Brazier of Commanding Fire Elementals"
category: "Wondrous"
rarity: "Rare"
---

# Brazier of Commanding Fire Elementals
*Wondrous Rare*

While you are within 5 feet of this brazier, you can take a Magic action to summon a **Fire Elemental**. The elemental appears in an unoccupied space as close to the brazier as possible, understands your languages, obeys your commands, and takes its turn immediately after you on your Initiative count. The elemental disappears after 1 hour, when it dies, or

when you dismiss it as a Bonus Action. The brazier can't be used this way again until the next dawn.
`,
      "Brooch-of-Shielding.md": `---
smType: item
name: "Brooch of Shielding"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
resistances: ["Force"]
---

# Brooch of Shielding
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

- Resistances: Force

While wearing this brooch, you have Resistance to Force damage, and you have Immunity to damage from the *Magic Missile* spell.
`,
      "Broom-of-Flying.md": `---
smType: item
name: "Broom of Flying"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Broom of Flying
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

This wooden broom functions like a mundane broom until you stand astride it and take a Magic action to make it hover beneath you, at which time it can be ridden in the air. It has a Fly Speed of 50 feet. It can carry up to 400 pounds, but its Fly Speed becomes 30 feet while carrying over 200 pounds. The broom stops hovering when you land or when you're no longer riding it.

As a Magic action, you can send the broom to travel alone to a destination within 1 mile of you if you name the location and are familiar with it. The broom comes back to you when you take a Magic action and use a command word if the broom is still within 1 mile of you.
`,
      "Candle-of-Invocation.md": `---
smType: item
name: "Candle of Invocation"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
---

# Candle of Invocation
*Wondrous (Requires Attunement) Very Rare (Requires Attunement)*

This candle's magic is activated when the candle is lit, which requires a Magic action. After burning for 4 hours, the candle is destroyed. You can snuff it out early for use at a later time. Deduct the time it burned in increments of 1 minute from its total burn time.

While lit, the candle sheds Dim Light in a 30-foot radius. While you are within that light, you have Advantage on D20 Tests. In addition, a Cleric or Druid in the light can cast level 1 spells they have prepared without expending spell slots.

Alternatively, when you light the candle for the first time, you can cast *Gate* with it. Doing so destroys the candle. The portal created by the spell links to a particular Outer Plane chosen by the GM or determined by rolling on the following table.
`,
      "Cape-of-the-Mountebank.md": `---
smType: item
name: "Cape of the Mountebank"
category: "Wondrous"
rarity: "Rare"
---

# Cape of the Mountebank
*Wondrous Rare*

This cape smells faintly of brimstone. While wearing it, you can use it to cast *Dimension Door* as a Magic action. This property can't be used again until the next dawn.

When you teleport with that spell, you leave behind a cloud of smoke. The space you left is Lightly Obscured by that smoke until the end of your next turn.
`,
      "Carpet-of-Flying.md": `---
smType: item
name: "Carpet of Flying"
category: "Wondrous"
rarity: "Very Rare"
---

# Carpet of Flying
*Wondrous Very Rare*

You can make this carpet hover and fly by taking a Magic action and using the carpet's command word. It moves according to your directions if you are within 30 feet of it.

Four sizes of *Carpet of Flying* exist. The GM chooses the size of a given carpet or determines it randomly by rolling on the following table. A carpet can carry up to twice the weight shown on the table, but its Fly Speed is halved if it carries more than its normal capacity.
`,
      "Censer-of-Controlling-Air-Elementals.md": `---
smType: item
name: "Censer of Controlling Air Elementals"
category: "Wondrous"
rarity: "Rare"
---

# Censer of Controlling Air Elementals
*Wondrous Rare*

While gently swinging this censer, you can take a Magic action to summon an **Air Elemental**. The elemental appears in an unoccupied space as close to the censer as possible, understands your languages, obeys your commands, and takes its turn immediately after you on your Initiative count. The elemental disappears after 1 hour, when it dies, or when you dismiss it as a Bonus Action. The censer can't be used this way again until the next dawn.
`,
      "Chime-of-Opening.md": `---
smType: item
name: "Chime of Opening"
category: "Wondrous"
rarity: "Rare"
---

# Chime of Opening
*Wondrous Rare*

This hollow metal tube measures about 1 foot long and weighs 1 pound. As a Magic action, you can strike the chime to cast *Knock*. The spell's customary knocking sound is replaced by the clear, ringing tone of the chime, which is audible out to 300 feet.

The chime can be used 10 times. After the tenth time, it cracks and becomes useless.
`,
      "Circlet-of-Blasting.md": `---
smType: item
name: "Circlet of Blasting"
category: "Wondrous"
rarity: "Uncommon"
---

# Circlet of Blasting
*Wondrous Uncommon*

While wearing this circlet, you can cast *Scorching Ray* with it (+5 to hit). The circlet can't cast this spell again until the next dawn.
`,
      "Cloak-of-Arachnida.md": `---
smType: item
name: "Cloak of Arachnida"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
resistances: ["Poison"]
---

# Cloak of Arachnida
*Wondrous (Requires Attunement) Very Rare (Requires Attunement)*

- Resistances: Poison

This fine garment is made of black silk interwoven with faint, silvery threads. While wearing it, you gain the following benefits.
`,
      "Cloak-of-Displacement.md": `---
smType: item
name: "Cloak of Displacement"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Cloak of Displacement
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

While you wear this cloak, it magically projects an illusion that makes you appear to be standing in a place near your actual location, causing any creature to have Disadvantage on attack rolls against you. If you take damage, the property ceases to function until the start of your next turn. This property is suppressed while your Speed is 0.
`,
      "Cloak-of-Elvenkind.md": `---
smType: item
name: "Cloak of Elvenkind"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Cloak of Elvenkind
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While you wear this cloak, Wisdom (Perception) checks made to perceive you have Disadvantage, and you have Advantage on Dexterity (Stealth) checks.
`,
      "Cloak-of-Protection.md": `---
smType: item
name: "Cloak of Protection"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Cloak of Protection
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

You gain a +1 bonus to Armor Class and saving throws while you wear this cloak.
`,
      "Cloak-of-the-Bat.md": `---
smType: item
name: "Cloak of the Bat"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Cloak of the Bat
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

While wearing this cloak, you have Advantage on Dexterity (Stealth) checks. In an area of Dim Light or Darkness, you can grip the edges of the cloak and use it to gain a Fly Speed of 40 feet. If you ever fail to grip the cloak's edges while flying in this way, or if you are no longer in Dim Light or Darkness, you lose this Fly Speed.

While wearing the cloak in an area of Dim Light or Darkness, you can cast *Polymorph* on yourself, shape-shifting into a **Bat**. While in that form, you retain your Intelligence, Wisdom, and Charisma scores. The cloak can't be used this way again until the next dawn.
`,
      "Cloak-of-the-Manta-Ray.md": `---
smType: item
name: "Cloak of the Manta Ray"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Cloak of the Manta Ray
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this cloak, you can breathe underwater, and you have a Swim Speed of 60 feet.
`,
      "Crystal-Ball-of-Mind-Reading.md": `---
smType: item
name: "Crystal Ball of Mind Reading"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
---

# Crystal Ball of Mind Reading
*Wondrous (Requires Attunement) Legendary (Requires Attunement)*

While touching this crystal orb, you can cast *Scrying* (save DC 17) with it. In addition, you can cast *Detect Thoughts* (save DC 17) targeting creatures you can see within 30 feet of the spell's sensor. You don't need to concentrate on this *Detect Thoughts* spell to maintain it during its duration, but it ends if the *Scrying* spell ends.
`,
      "Crystal-Ball-of-Telepathy.md": `---
smType: item
name: "Crystal Ball of Telepathy"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
---

# Crystal Ball of Telepathy
*Wondrous (Requires Attunement) Legendary (Requires Attunement)*

While touching this crystal orb, you can cast *Scrying* (save DC 17) with it. In addition, you can communicate telepathically with creatures you can see within 30 feet of the spell's sensor. You can also cast *Suggestion* (save DC 17) through the sensor on one of those creatures. You don't need to concentrate on this *Suggestion* to maintain it during its duration, but it ends if *Scrying* ends. You can't cast *Suggestion* in this way again until the next dawn.
`,
      "Crystal-Ball-of-True-Seeing.md": `---
smType: item
name: "Crystal Ball of True Seeing"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
---

# Crystal Ball of True Seeing
*Wondrous (Requires Attunement) Legendary (Requires Attunement)*

While touching this crystal orb, you can cast *Scrying* (save DC 17) with it. In addition, you have Truesight with a range of 120 feet centered on the spell's sensor.
`,
      "Crystal-Ball.md": `---
smType: item
name: "Crystal Ball"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
---

# Crystal Ball
*Wondrous (Requires Attunement) Very Rare (Requires Attunement)*

While touching this crystal orb, you can cast *Scrying* (save DC 17) with it.
`,
      "Cube-of-Force.md": `---
smType: item
name: "Cube of Force"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
recharge_formula: "1d6"
recharge_time: "Dawn"
---

# Cube of Force
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

This cube is about an inch across. Each face has a distinct marking on it. You can press one of those faces, expend the number of charges required for it, and thereby cast the spell associated with it (save DC 17), as shown in the Cube of Force Faces table.

The cube starts with 10 charges, and it regains 1d6 expended charges daily at dawn.
`,
      "Cubic-Gate.md": `---
smType: item
name: "Cubic Gate"
category: "Wondrous"
rarity: "Legendary"
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Cubic Gate
*Wondrous Legendary*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This cube is 3 inches across and radiates palpable magical energy. The six sides of the cube are each keyed to a different plane of existence, one of which is the Material Plane. The other sides are linked to planes determined by the GM.

The cube has 3 charges and regains 1d3 expended charges daily at dawn. As a Magic action, you can expend 1 of the cube's charges to cast one of the following spells using the cube.
`,
      "Dagger-of-Venom.md": `---
smType: item
name: "Dagger of Venom"
category: "Weapon"
type: "Dagger"
rarity: "Rare"
---

# Dagger of Venom
*Weapon (Dagger) Rare*

You gain a +1 bonus to attack rolls and damage rolls made with this magic weapon.

You can take a Bonus Action to magically coat the blade with poison. The poison remains for 1 minute or until an attack using this weapon hits a creature. That creature must succeed on a DC 15 Constitution saving throw or take 2d10 Poison damage and have the Poisoned condition for 1 minute. The weapon can't be used this way again until the next dawn.
`,
      "Dancing-Sword.md": `---
smType: item
name: "Dancing Sword"
category: "Weapon"
type: "Greatsword, Longsword, Rapier, Scimitar, or Shortsword"
rarity: "Very Rare"
attunement: true
---

# Dancing Sword
*Weapon (Greatsword, Longsword, Rapier, Scimitar, or Shortsword) Very Rare (Requires Attunement)*

You can take a Bonus Action to toss this magic weapon into the air. When you do so, the weapon begins to hover, flies up to 30 feet, and attacks one creature of your choice within 5 feet of itself. The weapon uses your attack roll and adds your ability modifier to damage rolls.

While the weapon hovers, you can take a Bonus Action to cause it to fly up to 30 feet to another spot within 30 feet of you. As part of the same Bonus Action, you can cause the weapon to attack one creature within 5 feet of the weapon.

After the hovering weapon attacks for the fourth time, it flies back to you and tries to return to your hand. If you have no hand free, the weapon falls to the ground in your space. If the weapon has no unobstructed path to you, it moves as close to you as it can and then falls to the ground. It also ceases to hover if you grasp it or are more than 30 feet away from it.
`,
      "Decanter-of-Endless-Water.md": `---
smType: item
name: "Decanter of Endless Water"
category: "Wondrous"
rarity: "Uncommon"
---

# Decanter of Endless Water
*Wondrous Uncommon*

This stoppered flask sloshes when shaken, as if it contains water. The decanter weighs 2 pounds.

You can take a Magic action to remove the stopper and issue one of three command words, whereupon an amount of fresh water or salt water (your choice) pours out of the flask. The water stops pouring out at the start of your next turn. Choose from the following command words:

**Splash.** The decanter produces 1 gallon of water.

**Fountain.** The decanter produces 5 gallons of water.

**Geyser.** The decanter produces 30 gallons of water that gushes forth in a Line 30 feet long and 1 foot wide. If you're holding the decanter, you can aim the geyser in one direction (no action required). One creature of your choice in the Line must succeed on a DC 13 Strength saving throw or take 1d4 Bludgeoning damage and have the Prone condition. Instead of a creature, you can target one object in the Line that isn't being worn or carried and that weighs no more than 200 pounds. The object is knocked over by the geyser.
`,
      "Deck-of-Illusions.md": `---
smType: item
name: "Deck of Illusions"
category: "Wondrous"
rarity: "Uncommon"
---

# Deck of Illusions
*Wondrous Uncommon*

This box contains a set of cards. A full deck has 34 cards: 32 depicting specific creatures and two with a mirrored surface. A deck found as treasure is usually missing 1d20 \u2212 1 cards.

The magic of the deck functions only if its cards are drawn at random. You can take a Magic action to draw a card at random from the deck and throw it to the ground at a point within 30 feet of yourself. An illusion of a creature, determined by rolling on the Deck of Illusions table, forms over the thrown card and remains until dispelled. The illusory creature created by the card looks and behaves like a real creature of its kind, except that it can do no harm. While you are within 120 feet of the illusory creature and can see it, you can take a Magic action to move it anywhere within 30 feet of its card.

Any physical interaction with the illusory creature reveals it to be false, because objects pass through it. A creature that takes a Study action to visually inspect the illusory creature identifies it as an illusion with a successful DC 15 Intelligence (Investigation) check. The illusion lasts until its card is moved or the illusion is dispelled (using a *Dispel Magic* spell or a similar effect). When the illusion ends, the image on its card disappears, and that card can't be used again.
`,
      "Defender.md": `---
smType: item
name: "Defender"
category: "Weapon"
type: "Any Melee Weapon"
rarity: "Legendary"
attunement: true
---

# Defender
*Weapon (Any Melee Weapon) Legendary (Requires Attunement)*

You gain a +3 bonus to attack rolls and damage rolls made with this magic weapon.

The first time you attack with the weapon on each of your turns, you can transfer some or all of the weapon's bonus to your Armor Class. For example, you could reduce the bonus to your attack rolls and damage rolls to +1 and gain a +2 bonus to Armor Class. The adjusted bonuses remain in effect until the start of your next turn, although you must hold the weapon to gain a bonus to AC from it.
`,
      "Demon-Armor.md": `---
smType: item
name: "Demon Armor"
category: "Armor"
type: "Any Light, Medium, or Heavy"
rarity: "Very Rare"
attunement: true
---

# Demon Armor
*Armor (Any Light, Medium, or Heavy) Very Rare (Requires Attunement)*

While wearing this armor, you gain a +1 bonus to Armor Class, and you know Abyssal. In addition, the armor's clawed gauntlets allow your Unarmed Strikes to deal 1d8 Slashing damage instead of the usual Bludgeoning damage, and you gain a +1 bonus to the attack and damage rolls of your Unarmed Strikes.
`,
      "Dimensional-Shackles.md": `---
smType: item
name: "Dimensional Shackles"
category: "Wondrous"
rarity: "Rare"
---

# Dimensional Shackles
*Wondrous Rare*

You can take a Utilize action to place these shackles on a creature that has the Incapacitated condition. The shackles adjust to fit a creature of Small to Large size. The shackles prevent a creature bound by them from using any method of extradimensional movement, including teleportation or travel to a different plane of existence. They don't prevent the creature from passing through an interdimensional portal.

You and any creature you designate when you use the shackles can take a Utilize action to remove them. Once every 30 days, the bound creature can make a DC 30 Strength (Athletics) check. On a successful check, the creature breaks free and destroys the shackles.
`,
      "Dragon-Orb.md": `---
smType: item
name: "Dragon Orb"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Artifact"
attunement: true
max_charges: 7
recharge_formula: "1d4 + 3"
recharge_time: "Dawn"
---

# Dragon Orb
*Wondrous (Requires Attunement) Artifact (Requires Attunement)*

## Charges

This item has 7 charges.
regains 1d4 + 3 charges at Dawn.

An orb is an etched crystal globe about 10 inches in diameter. When used, it grows to about 20 inches in diameter, and mist swirls inside it.

While attuned to an orb, you can take a Magic action to peer into the orb's depths. You must then make a DC 15 Charisma saving throw. On a successful save, you control the orb for as long as you remain attuned to it. On a failed save, the orb imposes the Charmed condition on you for as long as you remain attuned to it.

While you are Charmed by the orb, you can't voluntarily end your Attunement to it, and the orb casts *Suggestion* on you at will (save DC 18), urging you to work toward the evil ends it desires. The dragon essence within the orb might want many things: the annihilation of a particular society or organization, freedom from the orb, to spread suffering in the world, to advance the worship of Tiamat, or something else the GM decides.
`,
      "Dragon-Scale-Mail.md": `---
smType: item
name: "Dragon Scale Mail"
category: "Armor"
type: "Scale Mail"
rarity: "Very Rare"
attunement: true
resistances: ["one"]
---

# Dragon Scale Mail
*Armor (Scale Mail) Very Rare (Requires Attunement)*

- Resistances: one

*Dragon Scale Mail* is made of the scales of one kind of dragon. Sometimes dragons collect their cast-off scales and gift them. Other times, hunters carefully preserve the hide of a dead dragon. In either case, *Dragon Scale Mail* is highly valued.

While wearing this armor, you gain a +1 bonus to Armor Class, you have Advantage on saving throws against the breath weapons of Dragons, and you have Resistance to one damage type determined by the kind of dragon that provided the scales (see the accompanying table).

Additionally, you can focus your senses as a Magic action to discern the distance and direction to the closest dragon within 30 miles of yourself that is of the same type as the armor. This action can't be used again until the next dawn.
`,
      "Dragon-Slayer.md": `---
smType: item
name: "Dragon Slayer"
category: "Weapon"
type: "Any Simple or Martial"
rarity: "Rare"
---

# Dragon Slayer
*Weapon (Any Simple or Martial) Rare*

You gain a +1 bonus to attack rolls and damage rolls made with this magic weapon.

The weapon deals an extra 3d6 damage of the weapon's type if the target is a Dragon.
`,
      "Dust-of-Disappearance.md": `---
smType: item
name: "Dust of Disappearance"
category: "Wondrous"
rarity: "Uncommon"
---

# Dust of Disappearance
*Wondrous Uncommon*

This powder resembles fine sand. There is enough of it for one use. When you take a Utilize action to throw the dust into the air, you and each creature and object within a 10-foot Emanation originating from you have the Invisible condition for 2d4 minutes. The duration is the same for all subjects, and the dust is consumed when its magic takes effect. Immediately after an affected creature makes an attack roll, deals damage, or casts a spell, the Invisible condition ends for that creature.
`,
      "Dust-of-Dryness.md": `---
smType: item
name: "Dust of Dryness"
category: "Wondrous"
rarity: "Uncommon"
---

# Dust of Dryness
*Wondrous Uncommon*

This small packet contains 1d6 + 4 pinches of dust. As a Utilize action, you can sprinkle a pinch of the dust over water, turning up to a 15-foot Cube of water into one marble-sized pellet, which floats or rests near where the dust was sprinkled. The pellet's weight is negligible. A creature can take a Utilize action to smash the pellet against a hard surface, causing the pellet to shatter and release the water the dust absorbed. Doing so destroys the pellet and ends its magic.

As a Utilize action, you can sprinkle a pinch of the dust on an Elemental within 5 feet of yourself that is composed mostly of water (such as a **Water Elemental**). Such a creature exposed to a pinch of the dust makes a DC 13 Constitution saving throw, taking 10d6 Necrotic damage on a failed save or half as much damage on a successful one.
`,
      "Dust-of-Sneezing-and-Choking.md": `---
smType: item
name: "Dust of Sneezing and Choking"
category: "Wondrous"
rarity: "Uncommon"
---

# Dust of Sneezing and Choking
*Wondrous Uncommon*

Found in a small container, this powder resembles *Dust of Disappearance*, and *Identify* reveals it to be such. There is enough of it for one use.

As a Utilize action, you can throw the dust into the air, forcing yourself and every creature in a 30-foot

Emanation originating from you to make a DC 15 Constitution saving throw. Constructs, Elementals, Oozes, Plants, and Undead succeed on the save automatically.

On a failed save, a creature begins sneezing uncontrollably; it has the Incapacitated condition and is suffocating. The creature repeats the save at the end of each of its turns, ending the effect on itself on a success. The effect also ends on any creature targeted by a *Lesser Restoration* spell.
`,
      "Dwarven-Plate.md": `---
smType: item
name: "Dwarven Plate"
category: "Armor"
type: "Half Plate Armor or Plate Armor"
rarity: "Very Rare"
---

# Dwarven Plate
*Armor (Half Plate Armor or Plate Armor) Very Rare*

While wearing this armor, you gain a +2 bonus to Armor Class. In addition, if an effect moves you against your will along the ground, you can take a Reaction to reduce the distance you are moved by up to 10 feet.
`,
      "Dwarven-Thrower.md": `---
smType: item
name: "Dwarven Thrower"
category: "Weapon"
type: "Warhammer"
rarity: "Very Rare"
attunement: true
attunement_req: "by a Dwarf or a Creature Attuned to a Belt of Dwarvenkind"
---

# Dwarven Thrower
*Weapon (Warhammer) Very Rare (Requires Attunement by a Dwarf or a Creature Attuned to a Belt of Dwarvenkind)*

You gain a +3 bonus to attack rolls and damage rolls made with this magic weapon. It has the Thrown property with a normal range of 20 feet and a long range of 60 feet. When you hit with a ranged attack using this weapon, it deals an extra 1d8 Force damage, or an extra 2d8 Force damage if the target is a Giant. Immediately after hitting or missing, the weapon flies back to your hand.
`,
      "Efficient-Quiver.md": `---
smType: item
name: "Efficient Quiver"
category: "Wondrous"
rarity: "Uncommon"
---

# Efficient Quiver
*Wondrous Uncommon*

Each of the quiver's three compartments connects to an extradimensional space that allows the quiver to hold numerous items while never weighing more than 2 pounds. The shortest compartment can hold up to 60 Arrows, Bolts, or similar objects. The midsize compartment holds up to 18 Javelins or similar objects. The longest compartment holds up to 6 long objects, such as bows, Quarterstaffs, or Spears.

You can draw any item the quiver contains as if doing so from a regular quiver or scabbard.
`,
      "Efreeti-Bottle.md": `---
smType: item
name: "Efreeti Bottle"
category: "Wondrous"
rarity: "Very Rare"
---

# Efreeti Bottle
*Wondrous Very Rare*

When you take a Magic action to remove the stopper of this painted brass bottle, a cloud of thick smoke flows out of it. At the end of your turn, the smoke disappears with a flash of harmless fire, and an **Efreeti** appears in an unoccupied space within 30 feet of you.

The first time the bottle is opened, the GM rolls on the following table to determine what happens.
`,
      "Elemental-Gem.md": `---
smType: item
name: "Elemental Gem"
category: "Wondrous"
rarity: "Uncommon"
---

# Elemental Gem
*Wondrous Uncommon*

This gem contains a mote of elemental energy. When you take a Utilize action to break the gem, an elemental is summoned (see "Monsters" for its stat block), and the gem ceases to be magical. The elemental appears in an unoccupied space as close to the broken gem as possible, understands your languages, obeys your commands, and takes its turn immediately after you on your Initiative count. The elemental disappears after 1 hour, when it dies, or when you dismiss it as a Bonus Action. The type of gem determines the elemental, as shown in the following table.
`,
      "Elven-Chain.md": `---
smType: item
name: "Elven Chain"
category: "Armor"
type: "Chain Mail or Chain Shirt"
rarity: "Rare"
---

# Elven Chain
*Armor (Chain Mail or Chain Shirt) Rare*

You gain a +1 bonus to Armor Class while you wear this armor. You are considered trained with this armor even if you lack training with Medium or Heavy armor.
`,
      "Eversmoking-Bottle.md": `---
smType: item
name: "Eversmoking Bottle"
category: "Wondrous"
rarity: "Uncommon"
---

# Eversmoking Bottle
*Wondrous Uncommon*

As a Magic action, you can open or close this bottle. Opening the bottle causes thick smoke to billow out, forming a cloud that fills a 60-foot Emanation originating from the bottle. The area within the smoke is Heavily Obscured.

Each minute the bottle remains open, the size of the Emanation increases by 10 feet until it reaches its maximum size of 120 feet.

Closing the bottle causes the cloud to become fixed in place until it disperses after 10 minutes. A strong wind (such as that created by the *Gust of Wind* spell) disperses the cloud after 1 minute.
`,
      "Eyes-of-Charming.md": `---
smType: item
name: "Eyes of Charming"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Eyes of Charming
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

These crystal lenses fit over the eyes. They have 3 charges. While wearing them, you can expend 1 or more charges to cast *Charm Person* (save DC 13). For 1 charge, you cast the level 1 version of the spell. You increase the spell's level by one for each additional charge you expend. The lenses regain all expended charges daily at dawn.
`,
      "Eyes-of-Minute-Seeing.md": `---
smType: item
name: "Eyes of Minute Seeing"
category: "Wondrous"
rarity: "Uncommon"
---

# Eyes of Minute Seeing
*Wondrous Uncommon*

These crystal lenses fit over the eyes. While wearing them, your vision improves significantly out to a range of 1 foot, granting you Darkvision within that range and Advantage on Intelligence (Investigation) checks made to examine something within that range.
`,
      "Eyes-of-the-Eagle.md": `---
smType: item
name: "Eyes of the Eagle"
category: "Wondrous"
rarity: "Uncommon"
---

# Eyes of the Eagle
*Wondrous Uncommon*

These crystal lenses fit over the eyes. While wearing them, you have Advantage on Wisdom (Perception) checks that rely on sight. In conditions of clear visibility, you can make out details of even extremely distant creatures and objects as small as 2 feet across.
`,
      "Feather-Token.md": `---
smType: item
name: "Feather Token"
category: "Wondrous"
---

# Feather Token
*Wondrous*

This object looks like a feather. Different types of feather tokens exist, each with a different single-use effect. The GM chooses the kind of token or determines it randomly by rolling on the Feather Tokens table. The type of token determines its rarity.
`,
      "Figurine-of-Wondrous-Power.md": `---
smType: item
name: "Figurine of Wondrous Power"
category: "Wondrous"
max_charges: 24
---

# Figurine of Wondrous Power
*Wondrous*

## Charges

This item has 24 charges.

A *Figurine of Wondrous Power* is a statuette small enough to fit in a pocket. If you take a Magic action to throw the figurine to a point on the ground within 60 feet of yourself, the figurine becomes a living creature specified in the figurine's description below. If the space where the creature would appear is occupied by other creatures or objects, or if there isn't enough space for the creature, the figurine doesn't become a creature.

The creature is Friendly to you and your allies. It understands your languages, obeys your commands, and takes its turn immediately after you on your Initiative count. If you issue no commands, the creature defends itself but takes no other actions.

The creature exists for a duration specific to each figurine. At the end of the duration, the creature reverts to its figurine form. It reverts to a figurine early if its creature form drops to 0 Hit Points or if you take a Magic action while touching the creature to make it revert to figurine form. When the creature becomes a figurine again, its property can't be used again until a certain amount of time has passed, as specified in the figurine's description.
`,
      "Flame-Tongue.md": `---
smType: item
name: "Flame Tongue"
category: "Weapon"
type: "Any Melee Weapon"
rarity: "Rare"
attunement: true
---

# Flame Tongue
*Weapon (Any Melee Weapon) Rare (Requires Attunement)*

While holding this magic weapon, you can take a Bonus Action and use a command word to cause flames to engulf the damage-dealing part of the weapon. These flames shed Bright Light in a 40 foot radius and Dim Light for an additional 40 feet. While the weapon is ablaze, it deals an extra 2d6 Fire damage on a hit. The flames last until you take a Bonus Action to issue the command again or until you drop, stow, or sheathe the weapon.
`,
      "Folding-Boat.md": `---
smType: item
name: "Folding Boat"
category: "Wondrous"
rarity: "Rare"
---

# Folding Boat
*Wondrous Rare*

This object appears as a wooden box that measures 12 inches long, 6 inches wide, and 6 inches deep. It weighs 4 pounds and floats. It can be opened to store items inside. This item also has three command words, each requiring a Magic action to use:

**First Command Word.** The box unfolds into a Rowboat.

**Second Command Word.** The box unfolds into a Keelboat.

**Third Command Word.** The *Folding Boat* folds back into a box if no creatures are aboard. Any objects in the vessel that can't fit inside the box remain outside the box as it folds. Any objects in the vessel that can fit inside the box do so.

When the box becomes a vessel, its weight becomes that of a normal vessel its size, and anything that was stored in the box remains in the boat.

Statistics for the Rowboat and Keelboat appear in "Equipment." If either vessel is reduced to 0 Hit Points, the *Folding Boat* is destroyed.
`,
      "Frost-Brand.md": `---
smType: item
name: "Frost Brand"
category: "Weapon"
type: "Glaive, Greatsword, Longsword, Rapier, Scimitar, or Shortsword"
rarity: "Very Rare"
attunement: true
resistances: ["Fire"]
---

# Frost Brand
*Weapon (Glaive, Greatsword, Longsword, Rapier, Scimitar, or Shortsword) Very Rare (Requires Attunement)*

- Resistances: Fire

When you hit with an attack roll using this magic weapon, the target takes an extra 1d6 Cold damage. In addition, while you hold the weapon, you have Resistance to Fire damage.

In freezing temperatures, the weapon sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.

When you draw this weapon, you can extinguish all nonmagical flames within 30 feet of yourself. Once used, this property can't be used again for 1 hour.
`,
      "Gauntlets-of-Ogre-Power.md": `---
smType: item
name: "Gauntlets of Ogre Power"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
ability_changes_json: "[{\\"ability\\":\\"str\\",\\"value\\":19},{\\"ability\\":\\"str\\",\\"value\\":19}]"
---

# Gauntlets of Ogre Power
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

## Ability Changes

- STR becomes 19
- STR becomes 19

Your Strength is 19 while you wear these gauntlets. They have no effect on you if your Strength is 19 or higher without them.
`,
      "Gem-of-Brightness.md": `---
smType: item
name: "Gem of Brightness"
category: "Wondrous"
rarity: "Uncommon"
max_charges: 50
---

# Gem of Brightness
*Wondrous Uncommon*

## Charges

This item has 50 charges.

This prism has 50 charges. While you are holding it, you can take a Magic action and use one of three command words to cause one of the following effects:

**First Command Word.** The gem sheds Bright Light in a 30-foot radius and Dim Light for an additional 30 feet. This effect doesn't expend a charge. It lasts until you take a Bonus Action to repeat the command word or until you use another function of the gem.

**Second Command Word.** You expend 1 charge and cause the gem to fire a brilliant beam of light at one creature you can see within 60 feet of yourself. The creature must succeed on a DC 15 Constitution saving throw or have the Blinded condition for 1 minute. The creature repeats the save at the end of each of its turns, ending the effect on itself on a success.

**Third Command Word.** You expend 5 charges and cause the gem to flare with intense light in a 30 foot Cone. Each creature in the Cone makes a saving throw as if struck by the beam created with the second command word.

When all of the gem's charges are expended, the gem becomes a nonmagical jewel worth 50 GP.
`,
      "Gem-of-Seeing.md": `---
smType: item
name: "Gem of Seeing"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Gem of Seeing
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This gem has 3 charges. As a Magic action, you can expend 1 charge. For the next 10 minutes, you have Truesight out to 120 feet when you peer through the gem.

The gem regains 1d3 expended charges daily at dawn.
`,
      "Giant-Slayer.md": `---
smType: item
name: "Giant Slayer"
category: "Weapon"
type: "Any Simple or Martial"
rarity: "Rare"
---

# Giant Slayer
*Weapon (Any Simple or Martial) Rare*

You gain a +1 bonus to attack rolls and damage rolls made with this magic weapon.

When you hit a Giant with this weapon, the Giant takes an extra 2d6 damage of the weapon's type and must succeed on a DC 15 Strength saving throw or have the Prone condition.
`,
      "Glamoured-Studded-Leather.md": `---
smType: item
name: "Glamoured Studded Leather"
category: "Armor"
type: "Studded Leather Armor"
rarity: "Rare"
---

# Glamoured Studded Leather
*Armor (Studded Leather Armor) Rare*

While wearing this armor, you gain a +1 bonus to Armor Class. You can also take a Bonus Action to cause the armor to assume the appearance of a normal set of clothing or some other kind of armor. You decide what it looks like\u2014including color, style, and accessories\u2014but the armor retains its normal bulk and weight. The illusory appearance lasts until you use this property again or doff the armor.
`,
      "Gloves-of-Missile-Snaring.md": `---
smType: item
name: "Gloves of Missile Snaring"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Gloves of Missile Snaring
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

If you're hit by an attack roll made with a Ranged or Thrown weapon while wearing these gloves, you can take a Reaction to reduce the damage by 1d10 plus your Dexterity modifier if you have a free hand. If you reduce the damage to 0, you can catch the ammunition or weapon if it is small enough for you to hold in that hand.
`,
      "Gloves-of-Swimming-and-Climbing.md": `---
smType: item
name: "Gloves of Swimming and Climbing"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Gloves of Swimming and Climbing
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing these gloves, you have a Climb Speed and a Swim Speed equal to your Speed, and you gain a +5 bonus to Strength (Athletics) checks made to climb or swim.
`,
      "Goggles-of-Night.md": `---
smType: item
name: "Goggles of Night"
category: "Wondrous"
rarity: "Uncommon"
---

# Goggles of Night
*Wondrous Uncommon*

While wearing these dark lenses, you have Darkvision out to 60 feet. If you already have Darkvision, wearing the goggles increases its range by 60 feet.
`,
      "Hammer-of-Thunderbolts.md": `---
smType: item
name: "Hammer of Thunderbolts"
category: "Weapon"
type: "Maul or Warhammer"
rarity: "Legendary"
attunement: true
max_charges: 5
recharge_formula: "1d4 + 1"
recharge_time: "Dawn"
---

# Hammer of Thunderbolts
*Weapon (Maul or Warhammer) Legendary (Requires Attunement)*

## Charges

This item has 5 charges.
regains 1d4 + 1 charges at Dawn.

You gain a +1 bonus to attack rolls and damage rolls made with this magic weapon.

The weapon has 5 charges. You can expend 1 charge and make a ranged attack with the weapon, hurling it as if it had the Thrown property with a normal range of 20 feet and a long range of 60 feet. If the attack hits, the weapon unleashes a thunderclap audible out to 300 feet. The target and every creature within 30 feet of it other than you must succeed on a DC 17 Constitution saving throw or have the Stunned condition until the end of your next turn. Immediately after hitting or missing, the weapon flies back to your hand. The weapon regains 1d4 + 1 expended charges daily at dawn.
`,
      "Handy-Haversack.md": `---
smType: item
name: "Handy Haversack"
category: "Wondrous"
rarity: "Rare"
---

# Handy Haversack
*Wondrous Rare*

This backpack has a central pouch and two side pouches, each of which is an extradimensional space. Each side pouch can hold up to 200 pounds of material, not exceeding a volume of 25 cubic feet. The central pouch can hold up to 500 pounds of material, not exceeding a volume of 64 cubic feet. The haversack always weighs 5 pounds, regardless of its contents.

Retrieving an item from the haversack requires a Utilize action or a Bonus Action (your choice). When you reach into the haversack for a specific item, the item is always magically on top.

If any of its pouches is overloaded, pierced, or torn, the haversack ruptures and is destroyed. If the haversack is destroyed, its contents are lost forever, although an Artifact always turns up again somewhere. If the haversack is turned inside out, its contents spill forth unharmed, and the haversack must be put right before it can be used again.

Each pouch of the haversack holds enough air for 10 minutes of breathing, divided by the number of breathing creatures inside.

Placing the haversack inside an extradimensional space created by a *Bag of Holding*, *Portable Hole*, or similar item instantly destroys both items and opens a gate to the Astral Plane. The gate originates where the one item was placed inside the other. Any creature within 10 feet of the gate and not behind Total Cover is sucked through it and deposited in a random location on the Astral Plane. The gate then closes. The gate is one-way only and can't be reopened.
`,
      "Hat-of-Disguise.md": `---
smType: item
name: "Hat of Disguise"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Hat of Disguise
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this hat, you can cast the *Disguise Self* spell. The spell ends if the hat is removed.
`,
      "Headband-of-Intellect.md": `---
smType: item
name: "Headband of Intellect"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
ability_changes_json: "[{\\"ability\\":\\"int\\",\\"value\\":19},{\\"ability\\":\\"int\\",\\"value\\":19}]"
---

# Headband of Intellect
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

## Ability Changes

- INT becomes 19
- INT becomes 19

Your Intelligence is 19 while you wear this headband. It has no effect on you if your Intelligence is 19 or higher without it.
`,
      "Helm-of-Brilliance.md": `---
smType: item
name: "Helm of Brilliance"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
resistances: ["Fire"]
---

# Helm of Brilliance
*Wondrous (Requires Attunement) Very Rare (Requires Attunement)*

- Resistances: Fire

This helm is set with 1d10 diamonds, 2d10 rubies, 3d10 fire opals, and 4d10 opals. Any gem pried from the helm crumbles to dust. When all the gems are removed or destroyed, the helm loses its magic.

You gain the following benefits while wearing the helm.
`,
      "Helm-of-Comprehending-Languages.md": `---
smType: item
name: "Helm of Comprehending Languages"
category: "Wondrous"
rarity: "Uncommon"
---

# Helm of Comprehending Languages
*Wondrous Uncommon*

While wearing this helm, you can cast *Comprehend Languages* from it.
`,
      "Helm-of-Telepathy.md": `---
smType: item
name: "Helm of Telepathy"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Helm of Telepathy
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this helm, you have telepathy with a range of 30 feet, and you can cast *Detect Thoughts* or *Suggestion* (save DC 13) from the helm. Once either spell is cast from the helm, that spell can't be cast from it again until the next dawn.
`,
      "Helm-of-Teleportation.md": `---
smType: item
name: "Helm of Teleportation"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Helm of Teleportation
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This helm has 3 charges. While wearing it, you can expend 1 charge to cast *Teleport* from it. The helm regains 1d3 expended charges daily at dawn.
`,
      "Holy-Avenger.md": `---
smType: item
name: "Holy Avenger"
category: "Weapon"
type: "Any Simple or Martial"
rarity: "Legendary"
attunement: true
attunement_req: "by a Paladin"
---

# Holy Avenger
*Weapon (Any Simple or Martial) Legendary (Requires Attunement by a Paladin)*

You gain a +3 bonus to attack rolls and damage rolls made with this magic weapon. When you hit a Fiend or an Undead with it, that creature takes an extra 2d10 Radiant damage.

While you hold the drawn weapon, it creates a 10-foot Emanation originating from you. You and all creatures Friendly to you in the Emanation have Advantage on saving throws against spells and other magical effects. If you have 17 or more levels in the Paladin class, the size of the Emanation increases to 30 feet.
`,
      "Horn-of-Blasting.md": `---
smType: item
name: "Horn of Blasting"
category: "Wondrous"
rarity: "Rare"
---

# Horn of Blasting
*Wondrous Rare*

You can take a Magic action to blow the horn, which emits a thunderous blast in a 30-foot Cone that is audible out to 600 feet. Each creature in the Cone makes a DC 15 Constitution saving throw. On a failed save, a creature takes 5d8 Thunder damage and has the Deafened condition for 1 minute. On a successful save, a creature takes half as much damage only. Glass or crystal objects in the Cone that aren't being worn or carried take 10d8 Thunder damage.

Each use of the horn's magic has a 20 percent chance of causing the horn to explode. The explosion deals 10d6 Force damage to the user and destroys the horn.
`,
      "Horn-of-Valhalla.md": `---
smType: item
name: "Horn of Valhalla"
category: "Wondrous"
type: "Silver or Brass"
rarity: "Rare"
---

# Horn of Valhalla
*Wondrous (Silver or Brass) Rare*

You can take a Magic action to blow this horn. In response, warrior spirits from the plane of Ysgard appear in unoccupied spaces within 60 feet of you. Each spirit uses the **Berserker** stat block and returns to Ysgard after 1 hour or when it drops to 0 Hit Points. The spirits look like living, breathing warriors, and they have Immunity to the Charmed and Frightened conditions. Once you use the horn, it can't be used again until 7 days have passed.

Four types of *Horn of Valhalla* are known to exist, each made of a different metal. The horn's type determines how many spirits it summons, as well as the requirement for its use. The GM chooses the horn's type or determines it randomly by rolling on the following table.

If you blow the horn without meeting its requirement, the summoned spirits attack you. If you meet the requirement, they are Friendly to you and your allies and follow your commands.
`,
      "Horseshoes-of-a-Zephyr.md": `---
smType: item
name: "Horseshoes of a Zephyr"
category: "Wondrous"
rarity: "Very Rare"
---

# Horseshoes of a Zephyr
*Wondrous Very Rare*

These horseshoes come in a set of four. As a Magic action, you can touch one of the horseshoes to the hoof of a horse or similar creature, whereupon the horseshoe affixes itself to the hoof. Removing a horseshoe also takes a Magic action.

While all four shoes are affixed to the hooves of a horse or similar creature, they allow the creature to move normally while floating 4 inches above a surface. This effect means the creature can cross or stand above nonsolid or unstable surfaces, such as water or lava. The creature leaves no tracks and ignores Difficult Terrain. In addition, the creature can travel for up to 12 hours a day without gaining Exhaustion levels from extended travel.
`,
      "Horseshoes-of-Speed.md": `---
smType: item
name: "Horseshoes of Speed"
category: "Wondrous"
rarity: "Rare"
---

# Horseshoes of Speed
*Wondrous Rare*

These horseshoes come in a set of four. As a Magic action, you can touch one of the horseshoes to the hoof of a horse or similar creature, whereupon the horseshoe affixes itself to the hoof. Removing a horseshoe also takes a Magic action.

While all four horseshoes are attached to the same creature, its Speed is increased by 30 feet.
`,
      "Immovable-Rod.md": `---
smType: item
name: "Immovable Rod"
category: "Rod"
rarity: "Uncommon"
---

# Immovable Rod
*Rod Uncommon*

This iron rod has a button on one end. You can take a Utilize action to press the button, which causes the rod to become magically fixed in place. Until you or another creature takes a Utilize action to push the button again, the rod doesn't move, even if it defies gravity. The rod can hold up to 8,000 pounds of weight. More weight causes the rod to deactivate and fall. A creature can take a Utilize action to make a DC 30 Strength (Athletics) check, moving the fixed rod up to 10 feet on a successful check.
`,
      "Instant-Fortress.md": `---
smType: item
name: "Instant Fortress"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Instant Fortress
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

As a Magic action, you can place this 1-inch adamantine statuette on the ground and, using a command word, cause it to grow rapidly into a square adamantine tower. Repeating the command word causes the tower to revert to statuette form, which works only if the tower is empty. Each creature in the area where the tower appears is pushed to an unoccupied space outside but next to the tower. Objects in the area that aren't being worn or carried are also pushed clear of the tower.

The tower is 20 feet on a side and 30 feet high, with arrow slits on all sides and a battlement atop it. Its interior is divided into two floors, with a ladder, staircase, or ramp (your choice) connecting them. This ladder, staircase, or ramp ends at a trapdoor leading to the roof. When created, the tower has a single door at ground level on the side facing you. The door opens only at your command, which you can issue as a Bonus Action. It is immune to the *Knock* spell and similar magic.

Magic prevents the tower from being tipped over. The roof, the door, and the walls each have AC 20; HP 100; Immunity to Bludgeoning, Piercing, and Slashing damage except that which is dealt by siege equipment; and Resistance to all other damage. Shrinking the tower back down to statuette form doesn't repair damage to the tower. Only a *Wish* spell can repair the tower (this use of the spell counts as replicating a spell of level 8 or lower). Each casting of *Wish* causes the tower to regain all its Hit Points.
`,
      "Ioun-Stone.md": `---
smType: item
name: "Ioun Stone"
category: "Wondrous"
type: "Requires Attunement"
attunement: true
---

# Ioun Stone
*Wondrous (Requires Attunement) (Requires Attunement)*

Roughly marble sized, *Ioun Stones* are named after Ioun, a god of knowledge and prophecy revered on some worlds. Many types of *Ioun Stones* exist, each type a distinct combination of shape and color.

When you take a Magic action to toss an *Ioun Stone* into the air, the stone orbits your head at a distance of 1d3 feet, conferring its benefit to you while doing so. You can have up to three *Ioun Stones* orbiting your head at the same time.

Each *Ioun Stone* orbiting your head is considered to be an object you are wearing. The orbiting stone avoids contact with other creatures and objects, adjusting its orbit to avoid collisions and thwarting all attempts by other creatures to attack or snatch it.

As a Utilize action, you can seize and stow any number of *Ioun Stones* orbiting your head. If your Attunement to an *Ioun Stone* ends while it's orbiting your head, the stone falls as though you had dropped it.

The type of stone determines its rarity and effects.
`,
      "Iron-Bands.md": `---
smType: item
name: "Iron Bands"
category: "Wondrous"
rarity: "Rare"
---

# Iron Bands
*Wondrous Rare*

This rusty iron sphere measures 3 inches in diameter and weighs 1 pound. You can take a Magic action to throw the sphere at a Huge or smaller creature you can see within 60 feet of yourself. As the sphere moves through the air, it opens into a tangle of metal bands.

Make a ranged attack roll with an attack bonus equal to your Dexterity modifier plus your Proficiency Bonus. On a hit, the target has the Restrained condition until you take a Bonus Action to issue a command that releases it. Doing so or missing with the attack causes the bands to contract and become a sphere once more.

A creature that can touch the bands, including the one Restrained, can take an action to make a DC 20 Strength (Athletics) check to break the iron bands. On a successful check, the item is destroyed, and the Restrained creature is freed. On a failed check, any further attempts made by that creature automatically fail until 24 hours have elapsed.

Once the bands are used, they can't be used again until the next dawn.
`,
      "Iron-Flask.md": `---
smType: item
name: "Iron Flask"
category: "Wondrous"
rarity: "Legendary"
---

# Iron Flask
*Wondrous Legendary*

While holding this brass-stoppered iron flask, you can take a Magic action to target a creature that you can see within 60 feet of yourself. If the flask is empty and the target is native to a plane of existence other than the one you're on, the target must succeed on a DC 17 Wisdom saving throw or be trapped in the flask. If the target has been trapped by the flask before, it has Advantage on the save. Once trapped, a creature remains in the flask until released. The flask can hold only one creature at a time. A creature trapped in the flask doesn't age and doesn't need to breathe, eat, or drink.

You can take a Magic action to remove the flask's stopper and release the creature in the flask. The creature then obeys your commands for 1 hour, understanding those commands even if it doesn't know the language in which the commands are given. If you issue no commands or give the creature a command that is likely to result in its death or imprisonment, it defends itself but otherwise takes no actions. At the end of the duration, the creature acts in accordance with its normal disposition and alignment.

An *Identify* spell reveals if the flask contains a creature, but the only way to determine the type of creature is to open the flask. A newly discovered *Iron Flask* might already contain a creature chosen by the GM.
`,
      "Javelin-of-Lightning.md": `---
smType: item
name: "Javelin of Lightning"
category: "Weapon"
type: "Javelin"
rarity: "Uncommon"
---

# Javelin of Lightning
*Weapon (Javelin) Uncommon*

Each time you make an attack roll with this magic weapon and hit, you can have it deal Lightning damage instead of Piercing damage.

*Lightning Bolt.* When you throw this weapon at a target no farther than 120 feet from you, you can forgo making a ranged attack roll and instead turn the weapon into a bolt of lightning. This bolt forms a 5-foot-wide Line between you and the target. The target and each other creature in the Line (excluding you) makes a DC 13 Dexterity saving throw, taking 4d6 Lightning damage on a failed save or half as much damage on a successful one. Immediately after dealing this damage, the weapon reappears in your hand. This property can't be used again until the next dawn.
`,
      "Lantern-of-Revealing.md": `---
smType: item
name: "Lantern of Revealing"
category: "Wondrous"
rarity: "Uncommon"
---

# Lantern of Revealing
*Wondrous Uncommon*

While lit, this hooded lantern burns for 6 hours on 1 pint of oil, shedding Bright Light in a 30-foot radius and Dim Light for an additional 30 feet. Invisible creatures and objects are visible as long as they are in the lantern's Bright Light. You can take a Utilize action to lower the hood, reducing the lantern's light to Dim Light in a 5-foot radius.
`,
      "Luck-Blade.md": `---
smType: item
name: "Luck Blade"
category: "Weapon"
type: "Glaive, Greatsword, Longsword, Rapier, Scimitar, Sickle, or Shortsword"
rarity: "Legendary"
attunement: true
---

# Luck Blade
*Weapon (Glaive, Greatsword, Longsword, Rapier, Scimitar, Sickle, or Shortsword) Legendary (Requires Attunement)*

You gain a +1 bonus to attack rolls and damage rolls made with this magic weapon. While the weapon is on your person, you also gain a +1 bonus to saving throws.

*Luck.* If the weapon is on your person, you can call on its luck (no action required) to reroll one failed D20 Test if you don't have the Incapacitated condition. You must use the second roll. Once used, this property can't be used again until the next dawn.

*Wish.* The weapon has 1d3 charges. While holding it, you can expend 1 charge and cast *Wish* from it. Once used, this property can't be used again until the next dawn. The weapon loses this property if it has no charges.
`,
      "Mace-of-Disruption.md": `---
smType: item
name: "Mace of Disruption"
category: "Weapon"
type: "Mace"
rarity: "Rare"
attunement: true
---

# Mace of Disruption
*Weapon (Mace) Rare (Requires Attunement)*

When you hit a Fiend or an Undead with this magic weapon, that creature takes an extra 2d6 Radiant damage. If the target has 25 Hit Points or fewer after taking this damage, it must succeed on a DC 15 Wisdom saving throw or be destroyed. On a successful save, the creature has the Frightened condition until the end of your next turn.
`,
      "Mace-of-Smiting.md": `---
smType: item
name: "Mace of Smiting"
category: "Weapon"
type: "Mace"
rarity: "Rare"
---

# Mace of Smiting
*Weapon (Mace) Rare*

You gain a +1 bonus to attack rolls and damage rolls made with this magic weapon. The bonus increases to +3 when you use the weapon to attack a Construct.

When you roll a 20 on an attack roll made with this weapon, the target takes an extra 7 Bludgeoning damage, or 14 Bludgeoning damage if it's a Construct. If a Construct has 25 Hit Points or fewer after taking this damage, it is destroyed.
`,
      "Mace-of-Terror.md": `---
smType: item
name: "Mace of Terror"
category: "Weapon"
type: "Mace"
rarity: "Rare"
attunement: true
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Mace of Terror
*Weapon (Mace) Rare (Requires Attunement)*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This magic weapon has 3 charges and regains 1d3 expended charges daily at dawn. While holding the weapon, you can take a Magic action and expend 1 charge to release a wave of terror from it. Each creature of your choice within 30 feet of you must succeed on a DC 15 Wisdom saving throw or have the Frightened condition for 1 minute. While Frightened in this way, a creature must spend its turns trying to move as far away from you as it can, and it can't make Opportunity Attacks. For its action, it can use only the Dash action or try to escape from an effect that prevents it from moving. If it has nowhere it can move, the creature can take the Dodge action. At the end of each of its turns, a creature repeats the save, ending the effect on itself on a success.
`,
      "Mantle-of-Spell-Resistance.md": `---
smType: item
name: "Mantle of Spell Resistance"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Mantle of Spell Resistance
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

You have Advantage on saving throws against spells while you wear this cloak.
`,
      "Manual-of-Bodily-Health.md": `---
smType: item
name: "Manual of Bodily Health"
category: "Wondrous"
rarity: "Very Rare"
---

# Manual of Bodily Health
*Wondrous Very Rare*

This book contains health and nutrition tips, and its words are charged with magic. If you spend 48 hours over a period of 6 days or fewer studying the book's contents and practicing its guidelines, your Constitution increases by 2, to a maximum of 30. The manual then loses its magic but regains it in a century.
`,
      "Manual-of-Gainful-Exercise.md": `---
smType: item
name: "Manual of Gainful Exercise"
category: "Wondrous"
rarity: "Very Rare"
---

# Manual of Gainful Exercise
*Wondrous Very Rare*

This book describes fitness exercises, and its words are charged with magic. If you spend 48 hours over a period of 6 days or fewer studying the book's contents and practicing its guidelines, your Strength increases by 2, to a maximum of 30. The manual then loses its magic but regains it in a century.
`,
      "Manual-of-Golems.md": `---
smType: item
name: "Manual of Golems"
category: "Wondrous"
rarity: "Very Rare"
---

# Manual of Golems
*Wondrous Very Rare*

This tome contains information and incantations necessary to make a particular type of golem. The GM chooses the type or determines it randomly by rolling on the accompanying table. To decipher and use the manual, you must be a spellcaster with at least two level 5 spell slots. A creature that can't use a *Manual of Golems* and attempts to read it takes 6d6 Psychic damage.

To create a golem, you must spend the time shown on the table, working without interruption with the manual at hand and resting no more than 8 hours per day. You must also pay the specified cost to purchase supplies.

Once you finish creating the golem, the book is consumed in eldritch flames. The golem becomes animate when the ashes of the manual are sprinkled on it. See "Monsters" for the golem's stat block. The golem is under your control, and it understands and obeys your commands.
`,
      "Manual-of-Quickness-of-Action.md": `---
smType: item
name: "Manual of Quickness of Action"
category: "Wondrous"
rarity: "Very Rare"
---

# Manual of Quickness of Action
*Wondrous Very Rare*

This book contains coordination and balance exercises, and its words are charged with magic. If you spend 48 hours over a period of 6 days or fewer studying the book's contents and practicing its guidelines, your Dexterity increases by 2, to a maximum of 30. The manual then loses its magic but regains it in a century.
`,
      "Marvelous-Pigments.md": `---
smType: item
name: "Marvelous Pigments"
category: "Wondrous"
rarity: "Very Rare"
---

# Marvelous Pigments
*Wondrous Very Rare*

This fine wooden box contains 1d4 pots of pigment and a brush (weighing 1 pound in total).

Using the brush and expending 1 pot of pigment, you can paint any number of three-dimensional objects and terrain features (such as walls, doors, trees, flowers, weapons, webs, and pits), provided these elements are all confined to a 20-foot Cube. The effort takes 10 minutes (regardless of the number of elements you create), during which time you must remain in the Cube, and requires Concentration. If your Concentration is broken or you leave the Cube before the work is done, all the painted elements vanish, and the pot of pigment is wasted.

When the work is done, all the painted objects and terrain features become real. Thus, painting a door on a wall creates an actual door, which can be opened to whatever is beyond. Painting a pit creates a real pit, the entire depth of which must lie within the 20-foot Cube.

No object created by a pot of pigment can have a value greater than 25 GP, and the total value of all objects created by a pot of pigment can't exceed 500 GP. If you paint objects of greater value (such as a large pile of gold), they look authentic, but close inspection reveals they're made from paste, cookies, or some other worthless material.

If you paint a form of energy such as fire or lightning, the energy dissipates as soon as you complete the painting, doing no harm.
`,
      "Medallion-of-Thoughts.md": `---
smType: item
name: "Medallion of Thoughts"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
max_charges: 5
recharge_formula: "1d4"
recharge_time: "Dawn"
---

# Medallion of Thoughts
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

## Charges

This item has 5 charges.
regains 1d4 charges at Dawn.

The medallion has 5 charges. While wearing it, you can expend 1 charge to cast *Detect Thoughts* (save DC 13) from it. The medallion regains 1d4 expended charges daily at dawn.
`,
      "Mirror-of-Life-Trapping.md": `---
smType: item
name: "Mirror of Life Trapping"
category: "Wondrous"
rarity: "Very Rare"
---

# Mirror of Life Trapping
*Wondrous Very Rare*

When this 4-foot-tall, 2-foot-wide mirror is viewed indirectly, its surface shows faint images of creatures. The mirror weighs 50 pounds, and it has AC 11, HP 10, Immunity to Poison and Psychic damage, and Vulnerability to Bludgeoning damage. It shatters and is destroyed when reduced to 0 Hit Points.

If the mirror is hanging on a vertical surface and you are within 5 feet of it, you can take a Magic action and use a command word to activate it. It remains activated until you take a Magic action and repeat the command word to deactivate it.

Any creature other than you that sees its reflection in the activated mirror while within 30 feet of the mirror must succeed on a DC 15 Charisma saving throw or be trapped, along with anything it is wearing or carrying, in one of the mirror's twelve extradimensional cells. A creature that knows the mirror's nature makes the save with Advantage, and Constructs succeed on the save automatically.

An extradimensional cell is an infinite expanse filled with thick fog that reduces visibility to 10 feet. Creatures trapped in the mirror's cells don't age, and they don't need to eat, drink, or sleep. A creature trapped within a cell can escape using magic that permits planar travel. Otherwise, the creature is confined to the cell until freed.

If the mirror traps a creature but its twelve extradimensional cells are already occupied, the mirror frees one trapped creature at random to accommodate the new prisoner. A freed creature appears in an unoccupied space within sight of the mirror but facing away from it. If the mirror is shattered, all creatures it contains are freed and appear in unoccupied spaces near it.

While within 5 feet of the mirror, you can take a Magic action to name one creature trapped in it or call out a particular cell by number. The creature named or contained in the named cell appears as an image on the mirror's surface. You and the creature can then communicate.

In a similar way, you can take a Magic action and use a second command word to free one creature trapped in the mirror. The freed creature appears, along with its possessions, in the unoccupied space nearest to the mirror and facing away from it.

Placing the mirror inside an extradimensional space created by a *Bag of Holding*, *Portable Hole*, or similar item instantly destroys both items and opens a gate to the Astral Plane. The gate originates where the one item was placed inside the other. Any creature within 10 feet of the gate and not behind Total Cover is sucked through it to a random location on the Astral Plane. The gate then closes. The gate is one-way only and can't be reopened.
`,
      "Mithral-Armor.md": `---
smType: item
name: "Mithral Armor"
category: "Armor"
type: "Any Medium or Heavy, Except Hide Armor"
rarity: "Uncommon"
---

# Mithral Armor
*Armor (Any Medium or Heavy, Except Hide Armor) Uncommon*

Mithral is a light, flexible metal. Armor made of this substance can be worn under normal clothes. If the armor normally imposes Disadvantage on Dexterity (Stealth) checks or has a Strength requirement, the mithral version of the armor doesn't.
`,
      "Mysterious-Deck.md": `---
smType: item
name: "Mysterious Deck"
category: "Wondrous"
rarity: "Legendary"
---

# Mysterious Deck
*Wondrous Legendary*

Usually found in a box or pouch, this deck contains a number of cards made of ivory or vellum. Most (75 percent) of these decks have thirteen cards, but some have twenty-two. Use the appropriate column of the Mysterious Deck table when randomly determining cards drawn from the deck.

Before you draw a card, you must declare how many cards you intend to draw and then draw them randomly. Any cards drawn in excess of this number have no effect. Otherwise, as soon as you draw a card from the deck, its magic takes effect. You must draw each card no more than 1 hour after the previous draw. If you fail to draw the chosen number, the remaining number of cards fly from the deck on their own and take effect all at once.

Once a card is drawn, it disappears. Unless the card is the Fool or Jester, the card reappears in the deck, making it possible to draw the same card twice. (Once the Fool or Jester has left the deck, reroll on the table if that card comes up again.)
`,
      "Necklace-of-Adaptation.md": `---
smType: item
name: "Necklace of Adaptation"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Necklace of Adaptation
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this necklace, you can breathe normally in any environment, and you have Advantage on saving throws made to avoid or end the Poisoned condition.
`,
      "Necklace-of-Fireballs.md": `---
smType: item
name: "Necklace of Fireballs"
category: "Wondrous"
rarity: "Rare"
---

# Necklace of Fireballs
*Wondrous Rare*

This necklace has 1d6 + 3 beads hanging from it. You can take a Magic action to detach a bead and throw it up to 60 feet away. When it reaches the end of its trajectory, the bead detonates as a level 3 *Fireball* (save DC 15).

You can hurl multiple beads, or even the whole necklace, at one time. When you do so, increase the damage of the *Fireball* by 1d6 for each bead after the first (maximum 12d6).
`,
      "Necklace-of-Prayer-Beads.md": `---
smType: item
name: "Necklace of Prayer Beads"
category: "Wondrous"
type: "Requires Attunement by a Cleric, Druid, or Paladin"
rarity: "Rare"
attunement: true
attunement_req: "by a Cleric, Druid, or Paladin"
---

# Necklace of Prayer Beads
*Wondrous (Requires Attunement by a Cleric, Druid, or Paladin) Rare (Requires Attunement by a Cleric, Druid, or Paladin)*

This necklace has 1d4 + 2 magic beads made from aquamarine, black pearl, or topaz. It also has many nonmagical beads made from stones such as amber, bloodstone, citrine, coral, jade, pearl, or quartz. If a magic bead is removed from the necklace, that bead loses its magic.

Six types of magic beads exist. The GM decides the type of each bead on the necklace or determines it randomly by rolling on the table below. A necklace can have more than one bead of the same type. To use one, you must be wearing the necklace. Each bead contains a spell that you can cast from it as a Bonus Action (using your spell save DC if a save is necessary). Once a magic bead's spell is cast, that bead can't be used again until the next dawn.
`,
      "Nine-Lives-Stealer.md": `---
smType: item
name: "Nine Lives Stealer"
category: "Weapon"
type: "Any Simple or Martial"
rarity: "Very Rare"
attunement: true
---

# Nine Lives Stealer
*Weapon (Any Simple or Martial) Very Rare (Requires Attunement)*

You gain a +2 bonus to attack rolls and damage rolls made with this magic weapon.
`,
      "Oathbow.md": `---
smType: item
name: "Oathbow"
category: "Weapon"
type: "Longbow or Shortbow"
rarity: "Very Rare"
attunement: true
---

# Oathbow
*Weapon (Longbow or Shortbow) Very Rare (Requires Attunement)*

When you nock an arrow on this bow, it whispers in Elvish, "Swift defeat to my enemies." When you use this weapon to make a ranged attack, you can utter or sign the following command words: "Swift death to you who have wronged me." The target of your attack becomes your sworn enemy until it dies or until dawn 7 days later. You can have only one such sworn enemy at a time. When your sworn enemy dies, you can choose a new one after the next dawn.

When you make a ranged attack roll with this weapon against your sworn enemy, you have Advantage on the roll. In addition, your target gains no benefit from Half Cover or Three-Quarters Cover, and you suffer no Disadvantage due to long range. If the attack hits, your sworn enemy takes an extra 3d6 Piercing damage.

While your sworn enemy lives, you have Disadvantage on attack rolls with all other weapons.
`,
      "Oil-of-Etherealness.md": `---
smType: item
name: "Oil of Etherealness"
category: "Potion"
rarity: "Rare"
---

# Oil of Etherealness
*Potion Rare*

One vial of this oil can cover one Medium or smaller creature, along with the equipment it's wearing and carrying (one additional vial is required for each size category above Medium). Applying the oil takes 10 minutes. The affected creature then gains the effect of the *Etherealness* spell for 1 hour.

Beads of this cloudy, gray oil form on the outside of its container and quickly evaporate.
`,
      "Oil-of-Sharpness.md": `---
smType: item
name: "Oil of Sharpness"
category: "Potion"
rarity: "Very Rare"
---

# Oil of Sharpness
*Potion Very Rare*

One vial of this oil can coat one Melee weapon or twenty pieces of ammunition, but only ammunition and Melee weapons that are nonmagical and deal Slashing or Piercing damage are affected. Applying the oil takes 1 minute, after which the oil magically seeps into whatever it coats, turning the coated weapon into a *+3 Weapon* or the coated ammunition into *+3 Ammunition*.

This clear, gelatinous oil sparkles with tiny, ultrathin silver shards.
`,
      "Oil-of-Slipperiness.md": `---
smType: item
name: "Oil of Slipperiness"
category: "Potion"
rarity: "Uncommon"
---

# Oil of Slipperiness
*Potion Uncommon*

One vial of this oil can cover one Medium or smaller creature, along with the equipment it's wearing and carrying (one additional vial is required for each size category above Medium). Applying the oil takes 10 minutes. The affected creature then gains the effect of the *Freedom of Movement* spell for 8 hours.

Alternatively, the oil can be poured on the ground as a Magic action, where it covers a 10-foot square, duplicating the effect of the *Grease* spell in that area for 8 hours.

This sticky, black unguent is thick and heavy, but it flows quickly when poured.
`,
      "Pearl-of-Power.md": `---
smType: item
name: "Pearl of Power"
category: "Wondrous"
type: "Requires Attunement by a Spellcaster"
rarity: "Uncommon"
attunement: true
attunement_req: "by a Spellcaster"
---

# Pearl of Power
*Wondrous (Requires Attunement by a Spellcaster) Uncommon (Requires Attunement by a Spellcaster)*

While this pearl is on your person, you can take a Magic action to regain one expended spell slot of level 3 or lower. Once you use the pearl, it can't be used again until the next dawn.
`,
      "Periapt-of-Health.md": `---
smType: item
name: "Periapt of Health"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Periapt of Health
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this pendant, you can take a Magic action to regain 2d4 + 2 Hit Points. Once used, this property can't be used again until the next dawn.

In addition, you have Advantage on saving throws to avoid or end the Poisoned condition while you wear this pendant.
`,
      "Periapt-of-Proof-against-Poison.md": `---
smType: item
name: "Periapt of Proof against Poison"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Periapt of Proof against Poison
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

This delicate silver chain has a brilliant-cut black gem pendant. While you wear it, you have Immunity to the Poisoned condition and Poison damage.
`,
      "Periapt-of-Wound-Closure.md": `---
smType: item
name: "Periapt of Wound Closure"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Periapt of Wound Closure
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this pendant, you gain the following benefits.
`,
      "Philter-of-Love.md": `---
smType: item
name: "Philter of Love"
category: "Potion"
rarity: "Uncommon"
---

# Philter of Love
*Potion Uncommon*

The next time you see a creature within 10 minutes after drinking this philter, you are charmed by that creature and have the Charmed condition for 1 hour.

This rose-hued, effervescent liquid contains one easy-to-miss bubble shaped like a heart.
`,
      "Pipes-of-Haunting.md": `---
smType: item
name: "Pipes of Haunting"
category: "Wondrous"
rarity: "Uncommon"
---

# Pipes of Haunting
*Wondrous Uncommon*

These pipes have 3 charges and regain 1d3 expended charges daily at dawn. You can take a Magic action to play them and expend 1 charge to create an eerie, spellbinding tune. Each creature of your choice within 30 feet of you must succeed on a DC 15 Wisdom saving throw or have the Frightened condition for 1 minute. A creature that fails the save repeats it at the end of each of its turns, ending the effect on itself on a success. A creature that succeeds on its save is immune to the effect of these pipes for 24 hours.
`,
      "Pipes-of-the-Sewers.md": `---
smType: item
name: "Pipes of the Sewers"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Pipes of the Sewers
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While these pipes are on your person, ordinary rats and giant rats are Indifferent toward you and won't attack you unless you threaten or harm them.

The pipes have 3 charges and regain 1d3 expended charges daily at dawn. If you play the pipes as a Magic action, you can take a Bonus Action to expend 1 to 3 charges, calling forth one **Swarm of Rats** with each expended charge if enough rats are within half a mile of you to be called in this fashion (as determined by the GM). If there aren't enough rats to form a swarm, the charge is wasted. Called swarms move toward the music by the shortest available route but aren't under your control otherwise.

Whenever a **Swarm of Rats** that isn't under another creature's control comes within 30 feet of you while you are playing the pipes, the swarm makes a DC 15 Wisdom saving throw. On a successful save, the swarm behaves as it normally would and can't be swayed by the pipes' music for the next 24 hours. On a failed save, the swarm is swayed by the pipes' music and becomes Friendly to you and your allies for as long as you continue to play the pipes each round as a Magic action. A Friendly swarm obeys your commands. If you issue no commands to a Friendly swarm, it defends itself but otherwise takes no actions. If a Friendly swarm starts its turn more than 30 feet away from you, your control over that swarm ends, and the swarm behaves as it normally would and can't be swayed by the pipes' music for the next 24 hours.
`,
      "Plate-Armor-of-Etherealness.md": `---
smType: item
name: "Plate Armor of Etherealness"
category: "Armor"
type: "Half Plate Armor or Plate Armor"
rarity: "Legendary"
attunement: true
---

# Plate Armor of Etherealness
*Armor (Half Plate Armor or Plate Armor) Legendary (Requires Attunement)*

While you're wearing this armor, you can take a Magic action and use a command word to gain the effect of the *Etherealness* spell. The spell ends immediately if you remove the armor or take a Magic action to repeat the command word. This property of the armor can't be used again until the next dawn.
`,
      "Portable-Hole.md": `---
smType: item
name: "Portable Hole"
category: "Wondrous"
rarity: "Rare"
---

# Portable Hole
*Wondrous Rare*

This fine black cloth, soft as silk, is folded up to the dimensions of a handkerchief. It unfolds into a circular sheet 6 feet in diameter.

You can take a Magic action to unfold a *Portable Hole* and place it on or against a solid surface, whereupon the *Portable Hole* creates an extradimensional hole 10 feet deep. The cylindrical space within the hole exists on a different plane of existence, so it can't be used to create open passages. Any creature inside an open *Portable Hole* can exit the hole by climbing out of it.

You can take a Magic action to close a *Portable Hole* by taking hold of the edges of the cloth and folding it up. Folding the cloth closes the hole, and any creatures or objects within remain in the extradimensional space. No matter what's in it, the hole weighs next to nothing.

If the hole is folded up, a creature within the hole's extradimensional space can take an action to make a DC 10 Strength (Athletics) check. On a successful check, the creature forces its way out and appears within 5 feet of the *Portable Hole*. A closed *Portable Hole* holds enough air for 1 hour of breathing, divided by the number of breathing creatures inside.

Placing a *Portable Hole* inside an extradimensional space created by a *Bag of Holding*, *Handy Haversack*, or similar item instantly destroys both items and opens a gate to the Astral Plane. The gate originates where the one item was placed inside the other. Any creature within 10 feet of the gate and not behind Total Cover is sucked through it and deposited in a random location on the Astral Plane. The gate then closes. The gate is one-way only and can't be reopened.
`,
      "Potion-of-Animal-Friendship.md": `---
smType: item
name: "Potion of Animal Friendship"
category: "Potion"
rarity: "Uncommon"
---

# Potion of Animal Friendship
*Potion Uncommon*

When you drink this potion, you can cast the level 3 version of the *Animal Friendship* spell (save DC 13).

Agitating this potion's muddy liquid brings little bits into view: a fish scale, a hummingbird feather, a cat claw, or a squirrel hair.
`,
      "Potion-of-Clairvoyance.md": `---
smType: item
name: "Potion of Clairvoyance"
category: "Potion"
rarity: "Rare"
---

# Potion of Clairvoyance
*Potion Rare*

When you drink this potion, you gain the effect of the *Clairvoyance* spell (no Concentration required).

An eyeball bobs in this potion's yellowish liquid but vanishes when the potion is opened.
`,
      "Potion-of-Climbing.md": `---
smType: item
name: "Potion of Climbing"
category: "Potion"
rarity: "Common"
---

# Potion of Climbing
*Potion Common*

When you drink this potion, you gain a Climb Speed equal to your Speed for 1 hour. During this time, you have Advantage on Strength (Athletics) checks to climb.

This potion is separated into brown, silver, and gray layers resembling bands of stone. Shaking the bottle fails to mix the colors.
`,
      "Potion-of-Diminution.md": `---
smType: item
name: "Potion of Diminution"
category: "Potion"
rarity: "Rare"
---

# Potion of Diminution
*Potion Rare*

When you drink this potion, you gain the "reduce" effect of the *Enlarge/Reduce* spell for 1d4 hours (no Concentration required).

The red in the potion's liquid continuously contracts to a tiny bead and then expands to color the clear liquid around it. Shaking the bottle fails to interrupt this process.
`,
      "Potion-of-Flying.md": `---
smType: item
name: "Potion of Flying"
category: "Potion"
rarity: "Very Rare"
---

# Potion of Flying
*Potion Very Rare*

When you drink this potion, you gain a Fly Speed equal to your Speed for 1 hour and can hover. If you're in the air when the potion wears off, you fall unless you have some other means of staying aloft.

This potion's clear liquid floats at the top of its container and has cloudy white impurities drifting in it.
`,
      "Potion-of-Gaseous-Form.md": `---
smType: item
name: "Potion of Gaseous Form"
category: "Potion"
rarity: "Rare"
---

# Potion of Gaseous Form
*Potion Rare*

When you drink this potion, you gain the effect of the *Gaseous Form* spell for 1 hour (no Concentration required) or until you end the effect as a Bonus Action.

This potion's container seems to hold fog that moves and pours like water.
`,
      "Potion-of-Giant-Strength.md": `---
smType: item
name: "Potion of Giant Strength"
category: "Potion"
---

# Potion of Giant Strength
*Potion*

When you drink this potion, your Strength score changes for 1 hour. The type of giant determines the score (see the table below). The potion has no effect on you if your Strength is equal to or greater than that score.

This potion's transparent liquid has floating in it a sliver of light resembling a giant's fingernail.
`,
      "Potion-of-Growth.md": `---
smType: item
name: "Potion of Growth"
category: "Potion"
rarity: "Uncommon"
---

# Potion of Growth
*Potion Uncommon*

When you drink this potion, you gain the "enlarge" effect of the *Enlarge/Reduce* spell for 10 minutes (no Concentration required).

The red in the potion's liquid continuously expands from a tiny bead to color the clear liquid around it and then contracts. Shaking the bottle fails to interrupt this process.
`,
      "Potion-of-Heroism.md": `---
smType: item
name: "Potion of Heroism"
category: "Potion"
rarity: "Rare"
---

# Potion of Heroism
*Potion Rare*

When you drink this potion, you gain 10 Temporary Hit Points that last for 1 hour. For the same duration, you are under the effect of the *Bless* spell (no Concentration required).

This potion's blue liquid bubbles and steams as if boiling.
`,
      "Potion-of-Invisibility.md": `---
smType: item
name: "Potion of Invisibility"
category: "Potion"
rarity: "Rare"
---

# Potion of Invisibility
*Potion Rare*

This potion's container looks empty but feels as though it holds liquid. When you drink the potion, you have the Invisible condition for 1 hour. The effect ends early if you make an attack roll, deal damage, or cast a spell.
`,
      "Potion-of-Mind-Reading.md": `---
smType: item
name: "Potion of Mind Reading"
category: "Potion"
rarity: "Rare"
---

# Potion of Mind Reading
*Potion Rare*

When you drink this potion, you gain the effect of the *Detect Thoughts* spell (save DC 13) for 10 minutes (no Concentration required).

This potion's dense, purple liquid has an ovoid cloud of pink floating in it.
`,
      "Potion-of-Poison.md": `---
smType: item
name: "Potion of Poison"
category: "Potion"
rarity: "Uncommon"
---

# Potion of Poison
*Potion Uncommon*

This concoction looks, smells, and tastes like a *Potion of Healing* or another beneficial potion. However, it is actually poison masked by illusion magic. *Identify* reveals its true nature.

If you drink this potion, you take 4d6 Poison damage and must succeed on a DC 13 Constitution saving throw or have the Poisoned condition for 1 hour.
`,
      "Potion-of-Resistance.md": `---
smType: item
name: "Potion of Resistance"
category: "Potion"
rarity: "Uncommon"
---

# Potion of Resistance
*Potion Uncommon*

When you drink this potion, you have Resistance to one type of damage for 1 hour. The GM chooses the type or determines it randomly by rolling on the following table.
`,
      "Potion-of-Speed.md": `---
smType: item
name: "Potion of Speed"
category: "Potion"
rarity: "Very Rare"
---

# Potion of Speed
*Potion Very Rare*

When you drink this potion, you gain the effect of the *Haste* spell for 1 minute (no Concentration required) without suffering the wave of lethargy that typically occurs when the effect ends.

This potion's yellow fluid is streaked with black and swirls on its own.
`,
      "Potion-of-Water-Breathing.md": `---
smType: item
name: "Potion of Water Breathing"
category: "Potion"
rarity: "Uncommon"
---

# Potion of Water Breathing
*Potion Uncommon*

You can breathe underwater for 24 hours after drinking this potion.

This potion's cloudy green fluid smells of the sea and has a jellyfish-like bubble floating in it.
`,
      "Potions-of-Healing.md": `---
smType: item
name: "Potions of Healing"
category: "Potion"
---

# Potions of Healing
*Potion*

You regain Hit Points when you drink this potion. The number of Hit Points depends on the potion's rarity, as shown in the table below.

Whatever its potency, the potion's red liquid glimmers when agitated.
`,
      "Ring-of-Animal-Influence.md": `---
smType: item
name: "Ring of Animal Influence"
category: "Ring"
rarity: "Rare"
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Ring of Animal Influence
*Ring Rare*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This ring has 3 charges, and it regains 1d3 expended charges daily at dawn. While wearing the ring, you can expend 1 charge to cast one of the following spells (save DC 13) from it:

- *Animal Friendship*

- *Fear* (affects Beasts only)

- *Speak with Animals*
`,
      "Ring-of-Djinni-Summoning.md": `---
smType: item
name: "Ring of Djinni Summoning"
category: "Ring"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
---

# Ring of Djinni Summoning
*Ring (Requires Attunement) Legendary (Requires Attunement)*

While wearing this ring, you can take a Magic action to summon a particular **Djinni** from the Elemental Plane of Air. The djinni appears in an unoccupied space you choose within 120 feet of yourself. It remains as long as you maintain Concentration, to a maximum of 1 hour, or until it drops to 0 Hit Points.

While summoned, the djinni is Friendly to you and your allies, and it obeys your commands. If you fail to command it, the djinni defends itself against attackers but takes no other actions.

After the djinni departs, it can't be summoned again for 24 hours, and the ring becomes nonmagical if the djinni dies.

*Rings of Djinni Summoning* are often created by the djinn they summon and given to mortals as gifts of friendship or tokens of esteem.
`,
      "Ring-of-Elemental-Command.md": `---
smType: item
name: "Ring of Elemental Command"
category: "Ring"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
max_charges: 5
recharge_formula: "1d4 + 1"
recharge_time: "Dawn"
resistances: ["Lightning", "Acid"]
---

# Ring of Elemental Command
*Ring (Requires Attunement) Legendary (Requires Attunement)*

## Charges

This item has 5 charges.
regains 1d4 + 1 charges at Dawn.

- Resistances: Lightning, Acid

Each *Ring of Elemental Command* is linked to one of the four Elemental Planes. The GM chooses or randomly determines the linked plane. For example, a *Ring of Elemental Command* (air) is linked to the Elemental Plane of Air.

Every *Ring of Elemental Command* has the following two properties:
`,
      "Ring-of-Evasion.md": `---
smType: item
name: "Ring of Evasion"
category: "Ring"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Ring of Evasion
*Ring (Requires Attunement) Rare (Requires Attunement)*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This ring has 3 charges, and it regains 1d3 expended charges daily at dawn. When you fail a Dexterity saving throw while wearing the ring, you can take a Reaction to expend 1 charge to succeed on that save instead.
`,
      "Ring-of-Feather-Falling.md": `---
smType: item
name: "Ring of Feather Falling"
category: "Ring"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Ring of Feather Falling
*Ring (Requires Attunement) Rare (Requires Attunement)*

When you fall while wearing this ring, you descend 60 feet per round and take no damage from falling.
`,
      "Ring-of-Free-Action.md": `---
smType: item
name: "Ring of Free Action"
category: "Ring"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Ring of Free Action
*Ring (Requires Attunement) Rare (Requires Attunement)*

While you wear this ring, Difficult Terrain doesn't cost you extra movement. In addition, magic can neither reduce any of your Speeds nor cause you to have the Paralyzed or Restrained condition.
`,
      "Ring-of-Invisibility.md": `---
smType: item
name: "Ring of Invisibility"
category: "Ring"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
---

# Ring of Invisibility
*Ring (Requires Attunement) Legendary (Requires Attunement)*

While wearing this ring, you can take a Magic action to give yourself the Invisible condition. You remain Invisible until the ring is removed or until you take a Bonus Action to become visible again.
`,
      "Ring-of-Jumping.md": `---
smType: item
name: "Ring of Jumping"
category: "Ring"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Ring of Jumping
*Ring (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this ring, you can cast *Jump* from it, but can target only yourself when you do so.
`,
      "Ring-of-Mind-Shielding.md": `---
smType: item
name: "Ring of Mind Shielding"
category: "Ring"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Ring of Mind Shielding
*Ring (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this ring, you are immune to magic that allows other creatures to read your thoughts, determine whether you are lying, know your alignment, or know your creature type. Creatures can telepathically communicate with you only if you allow it.

You can take a Magic action to cause the ring to become imperceptible until you take another Magic action to make it perceptible, until you remove the ring, or until you die.

If you die while wearing the ring, your soul enters it, unless it already houses a soul. You can remain in the ring or depart for the afterlife. As long as your soul is in the ring, you can telepathically communicate with any creature wearing it. A wearer can't prevent this telepathic communication.
`,
      "Ring-of-Protection.md": `---
smType: item
name: "Ring of Protection"
category: "Ring"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Ring of Protection
*Ring (Requires Attunement) Rare (Requires Attunement)*

You gain a +1 bonus to Armor Class and saving throws while wearing this ring.
`,
      "Ring-of-Regeneration.md": `---
smType: item
name: "Ring of Regeneration"
category: "Ring"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
---

# Ring of Regeneration
*Ring (Requires Attunement) Very Rare (Requires Attunement)*

While wearing this ring, you regain 1d6 Hit Points every 10 minutes if you have at least 1 Hit Point. If you lose a body part, the ring causes the missing part to regrow and return to full functionality after 1d6 + 1 days if you have at least 1 Hit Point the whole time.
`,
      "Ring-of-Resistance.md": `---
smType: item
name: "Ring of Resistance"
category: "Ring"
rarity: "Rare"
resistances: ["one"]
---

# Ring of Resistance
*Ring Rare*

- Resistances: one

You have Resistance to one damage type while wearing this ring. The gemstone in the ring indicates the type, which the GM chooses or determines randomly by rolling on the following table.
`,
      "Ring-of-Shooting-Stars.md": `---
smType: item
name: "Ring of Shooting Stars"
category: "Ring"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
max_charges: 6
recharge_formula: "1d6"
recharge_time: "Dawn"
---

# Ring of Shooting Stars
*Ring (Requires Attunement) Very Rare (Requires Attunement)*

## Charges

This item has 6 charges.
regains 1d6 charges at Dawn.

You can cast *Dancing Lights* or *Light* from the ring.

The ring has 6 charges and regains 1d6 expended charges daily at dawn. You can expend its charges to use the properties below.
`,
      "Ring-of-Spell-Storing.md": `---
smType: item
name: "Ring of Spell Storing"
category: "Ring"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Ring of Spell Storing
*Ring (Requires Attunement) Rare (Requires Attunement)*

This ring stores spells cast into it, holding them until the attuned wearer uses them. The ring can store up to 5 levels worth of spells at a time. When found, it contains 1d6 \u2212 1 levels of stored spells chosen by the GM.

Any creature can cast a spell of level 1 through 5 into the ring by touching the ring as the spell is cast. The spell has no effect other than to be stored in the ring. If the ring can't hold the spell, the spell is expended without effect. The level of the slot used to cast the spell determines how much space it uses.

While wearing this ring, you can cast any spell stored in it. The spell uses the slot level, spell save DC, spell attack bonus, and spellcasting ability of the original caster but is otherwise treated as if you cast the spell. The spell cast from the ring is no longer stored in it, freeing up space.
`,
      "Ring-of-Spell-Turning.md": `---
smType: item
name: "Ring of Spell Turning"
category: "Ring"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
---

# Ring of Spell Turning
*Ring (Requires Attunement) Legendary (Requires Attunement)*

While wearing this ring, you have Advantage on saving throws against spells. If you succeed on the save for a spell of level 7 or lower, the spell has no effect on you. If that spell targeted only you and didn't create an area of effect, you can take a Reaction to deflect the spell back at the spell's caster; the caster must make a saving throw against the spell using their own spell save DC.
`,
      "Ring-of-Swimming.md": `---
smType: item
name: "Ring of Swimming"
category: "Ring"
rarity: "Uncommon"
---

# Ring of Swimming
*Ring Uncommon*

You have a Swim Speed of 40 feet while wearing this ring.
`,
      "Ring-of-Telekinesis.md": `---
smType: item
name: "Ring of Telekinesis"
---

# Ring of Telekinesis
`,
      "Ring-of-the-Ram.md": `---
smType: item
name: "Ring of the Ram"
category: "Ring"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Ring of the Ram
*Ring (Requires Attunement) Rare (Requires Attunement)*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This ring has 3 charges and regains 1d3 expended charges daily at dawn. While wearing the ring, you can take a Magic action to expend 1 to 3 charges to make a ranged spell attack against one creature you can see within 60 feet of yourself. The ring produces a spectral ram's head and makes its attack roll with a +7 bonus. On a hit, for each charge you spend, the target takes 2d10 Force damage and is pushed 5 feet away from you.

Alternatively, you can expend 1 to 3 of the ring's charges as a Magic action to try to break a nonmagical object you can see within 60 feet of yourself that isn't being worn or carried. The ring makes a Strength check with a +5 bonus for each charge you spend.
`,
      "Ring-of-Three-Wishes.md": `---
smType: item
name: "Ring of Three Wishes"
category: "Ring"
rarity: "Legendary"
---

# Ring of Three Wishes
*Ring Legendary*

While wearing this ring, you can expend 1 of its 3 charges to cast *Wish* from it. The ring becomes nonmagical when you use the last charge.
`,
      "Ring-of-Warmth.md": `---
smType: item
name: "Ring of Warmth"
category: "Ring"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Ring of Warmth
*Ring (Requires Attunement) Uncommon (Requires Attunement)*

If you take Cold damage while wearing this ring, the ring reduces the damage you take by 2d8.

In addition, while wearing this ring, you and everything you wear and carry are unharmed by temperatures of 0 degrees Fahrenheit or lower.
`,
      "Ring-of-Water-Walking.md": `---
smType: item
name: "Ring of Water Walking"
category: "Ring"
rarity: "Uncommon"
---

# Ring of Water Walking
*Ring Uncommon*

While wearing this ring, you cast *Water Walk* from it, targeting only yourself.
`,
      "Ring-of-X-ray-Vision.md": `---
smType: item
name: "Ring of X-ray Vision"
category: "Ring"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Ring of X-ray Vision
*Ring (Requires Attunement) Rare (Requires Attunement)*

While wearing this ring, you can take a Magic action to gain X-ray vision with a range of 30 feet for 1 minute. To you, solid objects within that radius appear transparent and don't prevent light from passing through them. The vision can penetrate 1 foot of stone, 1 inch of common metal, or up to 3 feet of wood or dirt. Thicker substances or a thin sheet of lead block the vision.

Whenever you use the ring again before taking a Long Rest, you must succeed on a DC 15 Constitution saving throw or gain 1 Exhaustion level.
`,
      "Robe-of-Eyes.md": `---
smType: item
name: "Robe of Eyes"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Robe of Eyes
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

This robe is adorned with eyelike patterns. While you wear the robe, you gain the following benefits:

**All-Around Vision.** The robe gives you Advantage on Wisdom (Perception) checks that rely on sight.

**Special Senses.** You have Darkvision and Truesight, both with a range of 120 feet.
`,
      "Robe-of-Scintillating-Colors.md": `---
smType: item
name: "Robe of Scintillating Colors"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Robe of Scintillating Colors
*Wondrous (Requires Attunement) Very Rare (Requires Attunement)*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This robe has 3 charges, and it regains 1d3 expended charges daily at dawn. While you wear it, you can take a Magic action and expend 1 charge to cause the garment to display a shifting pattern of dazzling hues until the end of your next turn. During this time, the robe sheds Bright Light in a 30-foot radius and Dim Light for an additional 30 feet, and creatures that can see you have Disadvantage on attack rolls against you. Any creature in the Bright Light that can see you when the robe's power is activated must succeed on a DC 15 Wisdom saving throw or have the Stunned condition until the effect ends.
`,
      "Robe-of-Stars.md": `---
smType: item
name: "Robe of Stars"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
---

# Robe of Stars
*Wondrous (Requires Attunement) Very Rare (Requires Attunement)*

This black or dark-blue robe is embroidered with small white or silver stars. You gain a +1 bonus to saving throws while you wear it.

Six stars, located on the robe's upper-front portion, are particularly large. While wearing this robe, you can take a Magic action to remove one of the stars and expend it to cast the level 5 version of *Magic Missile*. Daily at dusk, 1d6 removed stars reappear on the robe.

While you wear the robe, you can take a Magic action to enter the Astral Plane along with everything you are wearing and carrying. You remain there until you take a Magic action to return to the plane you were on. You reappear in the last space you occupied or, if that space is occupied, the nearest unoccupied space.
`,
      "Robe-of-the-Archmagi.md": `---
smType: item
name: "Robe of the Archmagi"
category: "Wondrous"
type: "Requires Attunement by a Sorcerer, Warlock, or Wizard"
rarity: "Legendary"
attunement: true
attunement_req: "by a Sorcerer, Warlock, or Wizard"
---

# Robe of the Archmagi
*Wondrous (Requires Attunement by a Sorcerer, Warlock, or Wizard) Legendary (Requires Attunement by a Sorcerer, Warlock, or Wizard)*

This elegant garment is made from exquisite cloth and adorned with runes.

You gain these benefits while wearing the robe. *Armor.* If you aren't wearing armor, your base

Armor Class is 15 plus your Dexterity modifier. *Magic Resistance.* You have Advantage on saving throws against spells and other magical effects. *War Mage.* Your spell save DC and spell attack bonus each increase by 2.
`,
      "Robe-of-Useful-Items.md": `---
smType: item
name: "Robe of Useful Items"
category: "Wondrous"
rarity: "Uncommon"
---

# Robe of Useful Items
*Wondrous Uncommon*

This robe has cloth patches of various shapes and colors covering it. While wearing the robe, you can take a Magic action to detach one of the patches, causing it to become the object or creature it represents. Once the last patch is removed, the robe becomes an ordinary garment.

The robe has two of each of the following patches:

- Bullseye Lantern (filled and lit)

- Dagger

- Mirror

- Pole

- Rope (coiled)

- Sack

In addition, the robe has 4d4 other patches. The GM chooses the patches or determines them randomly by rolling on the following table.
`,
      "Rod-of-Absorption.md": `---
smType: item
name: "Rod of Absorption"
category: "Rod"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
---

# Rod of Absorption
*Rod (Requires Attunement) Very Rare (Requires Attunement)*

While holding this rod, you can take a Reaction to absorb a spell that is targeting only you and doesn't create an area of effect. The absorbed spell's effect is canceled, and the spell's energy\u2014not the spell itself\u2014is stored in the rod. The energy has the same level as the spell when it was cast. A canceled spell dissipates with no effect, and any resources used to cast it are wasted. The rod can absorb and store up to 50 levels of energy over the course of its existence. Once the rod absorbs 50 levels of energy, it can't absorb more. If you are targeted by a spell that the rod can't store, the rod has no effect on that spell.

When you become attuned to the rod, you know how many levels of energy the rod has absorbed over the course of its existence and how many levels of spell energy it currently has stored.

If you are a spellcaster holding the rod, you can convert energy stored in it into spell slots to cast spells you have prepared or know. You can create spell slots only of a level equal to or lower than your own spell slots, up to a maximum of level 5. You use the stored levels in place of your slots but otherwise cast the spell as normal. For example, you can use 3 levels stored in the rod as a level 3 spell slot.

A newly found rod typically has 1d10 levels of spell energy stored in it. A rod that can no longer absorb spell energy and has no energy remaining becomes nonmagical.
`,
      "Rod-of-Alertness.md": `---
smType: item
name: "Rod of Alertness"
category: "Rod"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
---

# Rod of Alertness
*Rod (Requires Attunement) Very Rare (Requires Attunement)*

This rod has the following properties.
`,
      "Rod-of-Lordly-Might.md": `---
smType: item
name: "Rod of Lordly Might"
category: "Rod"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
---

# Rod of Lordly Might
*Rod (Requires Attunement) Legendary (Requires Attunement)*

This rod has a flanged head, and it functions as a magic Mace that grants a +3 bonus to attack rolls and damage rolls made with it. The rod has properties associated with six different buttons that are set in a row along the haft. It has three other properties as well, detailed below.
`,
      "Rod-of-Rulership.md": `---
smType: item
name: "Rod of Rulership"
category: "Rod"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Rod of Rulership
*Rod (Requires Attunement) Rare (Requires Attunement)*

You can take a Magic action to present the rod and command obedience from each creature of your choice that you can see within 120 feet of yourself. Each target must succeed on a DC 15 Wisdom saving throw or have the Charmed condition for 8 hours. While Charmed in this way, the creature regards you as its trusted leader. If harmed by you or your allies or commanded to do something contrary to its nature, a target ceases to be Charmed in this way. Once used, this property can't be used again until the next dawn.
`,
      "Rod-of-Security.md": `---
smType: item
name: "Rod of Security"
category: "Rod"
rarity: "Very Rare"
---

# Rod of Security
*Rod Very Rare*

While holding this rod, you can take a Magic action to activate it. The rod then instantly transports you and up to 199 other willing creatures you can see to a demiplane. You choose the form the demiplane takes. It could be a tranquil garden, a cheery tavern, an immense palace, a tropical island, a fantastic carnival, or whatever else you can imagine. Regardless of its nature, the demiplane contains enough water and food to sustain its visitors, and the demiplane's environment can't harm its occupants. Everything else that can be interacted with there can exist only there. For example, a flower picked from a garden there disappears if it is taken outside the demiplane.

For each hour spent in the demiplane, a visitor regains Hit Points as if it had spent 1 Hit Point Die. Also, creatures don't age while there, although time passes normally. Visitors can remain there for up to 200 days divided by the number of creatures present (round down).

When the time runs out or you take a Magic action to end the effect, all visitors reappear in the location they occupied when you activated the rod or an unoccupied space nearest that location. Once used, this property can't be used again until 10 days have passed.
`,
      "Rope-of-Climbing.md": `---
smType: item
name: "Rope of Climbing"
category: "Wondrous"
rarity: "Uncommon"
---

# Rope of Climbing
*Wondrous Uncommon*

This 60-foot length of rope can hold up to 3,000 pounds. While holding one end of the rope, you can take a Magic action to command the other end of the rope to animate and move toward a destination you choose, up to the rope's length away from you. That end moves 10 feet on your turn when you first command it and 10 feet at the start of each of your subsequent turns until reaching its destination or until you tell it to stop. You can also tell the rope to fasten itself securely to an object or to unfasten itself, to knot or unknot itself, or to coil itself for carrying.

If you tell the rope to knot, large knots appear at 1-foot intervals along the rope. While knotted, the rope shortens to a 50-foot length and grants Advantage on ability checks made to climb using the rope.

The rope has AC 20, HP 20, and Immunity to Poison and Psychic damage. It regains 1 Hit Point every 5 minutes as long as it has at least 1 Hit Point. If the rope drops to 0 Hit Points, it is destroyed.
`,
      "Rope-of-Entanglement.md": `---
smType: item
name: "Rope of Entanglement"
category: "Wondrous"
rarity: "Rare"
---

# Rope of Entanglement
*Wondrous Rare*

This rope is 30 feet long. While holding one end of the rope, you can take a Magic action to command the other end to dart forward and entangle one creature you can see within 20 feet of yourself. The target must succeed on a DC 15 Dexterity saving throw or have the Restrained condition. You can release the target by letting go of your end of the rope (causing the rope to coil up in the target's space) or by using a Bonus Action to repeat the command (causing the rope to coil up in your hand).

A target Restrained by the rope can take an action to make its choice of a DC 15 Strength (Athletics) or Dexterity (Acrobatics) check. On a successful check, the target is no longer Restrained by the rope. If you're still holding onto the rope when a target escapes from it, you can take a Reaction to command the rope to coil up in your hand; otherwise, the rope coils up in the target's space.

The rope has AC 20, HP 20, and Immunity to Poison and Psychic damage. It regains 1 Hit Point every 5 minutes as long as it has at least 1 Hit Point. If the rope drops to 0 Hit Points, it is destroyed.
`,
      "Scarab-of-Protection.md": `---
smType: item
name: "Scarab of Protection"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
max_charges: 12
---

# Scarab of Protection
*Wondrous (Requires Attunement) Legendary (Requires Attunement)*

## Charges

This item has 12 charges.

This beetle-shaped medallion provides three benefits while it is on your person.
`,
      "Scimitar-of-Speed.md": `---
smType: item
name: "Scimitar of Speed"
category: "Weapon"
type: "Scimitar"
rarity: "Very Rare"
attunement: true
---

# Scimitar of Speed
*Weapon (Scimitar) Very Rare (Requires Attunement)*

You gain a +2 bonus to attack rolls and damage rolls made with this magic weapon. In addition, you can make one attack with it as a Bonus Action on each of your turns.
`,
      "Shield-1-2-or-3.md": `---
smType: item
name: "Shield, +1, +2, or +3"
category: "Armor"
type: "Shield"
rarity: "Uncommon"
---

# Shield, +1, +2, or +3
*Armor (Shield) Uncommon*

While holding this Shield, you have a bonus to Armor Class determined by the Shield's rarity, in addition to the Shield's normal bonus to AC.
`,
      "Shield-of-Missile-Attraction.md": `---
smType: item
name: "Shield of Missile Attraction"
category: "Armor"
type: "Shield"
rarity: "Rare"
attunement: true
---

# Shield of Missile Attraction
*Armor (Shield) Rare (Requires Attunement)*

While holding this Shield, you have Resistance to damage from attacks made with Ranged weapons.
`,
      "Slippers-of-Spider-Climbing.md": `---
smType: item
name: "Slippers of Spider Climbing"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Slippers of Spider Climbing
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While you wear these light shoes, you can move up, down, and across vertical surfaces and along ceilings, while leaving your hands free. You have a Climb Speed equal to your Speed. However, the slippers don't allow you to move this way on a slippery surface, such as one covered by ice or oil.
`,
      "Sovereign-Glue.md": `---
smType: item
name: "Sovereign Glue"
category: "Wondrous"
rarity: "Legendary"
---

# Sovereign Glue
*Wondrous Legendary*

This viscous, milky-white substance can form a permanent adhesive bond between any two objects. It must be stored in a jar or flask that has been coated inside with *Oil of Slipperiness*. When found, a container contains 1d6 + 1 ounces.

One ounce of the glue can cover a 1-foot square surface. Applying an ounce of *Sovereign Glue* takes a Utilize action, and the applied glue takes 1 minute to set. Once it has done so, the bond it creates can be broken only by the application of *Universal Solvent* or *Oil of Etherealness*, or with a *Wish* spell.
`,
      "Spell-Scroll.md": `---
smType: item
name: "Spell Scroll"
category: "Scroll"
---

# Spell Scroll
*Scroll*

A *Spell Scroll* bears the words of a single spell, written in a mystical cipher. If the spell is on your spell list, you can read the scroll and cast its spell without Material components. Otherwise, the scroll is unintelligible. Casting the spell by reading the scroll requires the spell's normal casting time. Once the spell is cast, the scroll crumbles to dust. If the casting is interrupted, the scroll isn't lost.

If the spell is on your spell list but of a higher level than you can normally cast, you make an ability check using your spellcasting ability to determine whether you cast the spell. The DC equals 10 plus the spell's level. On a failed check, the spell disappears from the scroll with no other effect.

The level of the spell on the scroll determines the spell's saving throw DC and attack bonus, as well as the scroll's rarity, as shown in the following table.
`,
      "Spellguard-Shield.md": `---
smType: item
name: "Spellguard Shield"
category: "Armor"
type: "Shield"
rarity: "Very Rare"
attunement: true
---

# Spellguard Shield
*Armor (Shield) Very Rare (Requires Attunement)*

While holding this Shield, you have Advantage on saving throws against spells and other magical effects, and spell attack rolls have Disadvantage against you.
`,
      "Sphere-of-Annihilation.md": `---
smType: item
name: "Sphere of Annihilation"
category: "Wondrous"
rarity: "Legendary"
---

# Sphere of Annihilation
*Wondrous Legendary*

This 2-foot-diameter black sphere is a hole in the multiverse, hovering in space and stabilized by a magical field surrounding it.

The sphere obliterates all matter it passes through and all matter that passes through it. Artifacts are the exception. Unless an Artifact is susceptible to damage from a *Sphere of Annihilation*, it passes through the sphere unscathed. Anything else that touches the sphere but isn't wholly engulfed and obliterated by it takes 8d10 Force damage.
`,
      "Staff-of-Charming.md": `---
smType: item
name: "Staff of Charming"
category: "Staff"
type: "Requires Attunement by a Bard, Cleric, Druid, Sorcerer, Warlock, or Wizard"
rarity: "Rare"
attunement: true
attunement_req: "by a Bard, Cleric, Druid, Sorcerer, Warlock, or Wizard"
max_charges: 10
recharge_formula: "1d8 + 2"
recharge_time: "Dawn"
destruction_risk: "On 1, the staff crumbles to dust and is destroyed"
---

# Staff of Charming
*Staff (Requires Attunement by a Bard, Cleric, Druid, Sorcerer, Warlock, or Wizard) Rare (Requires Attunement by a Bard, Cleric, Druid, Sorcerer, Warlock, or Wizard)*

## Charges

This item has 10 charges.
regains 1d8 + 2 charges at Dawn.
On 1, the staff crumbles to dust and is destroyed

This staff has 10 charges. While holding the staff, you can use any of its properties:

**Cast Spell.** You can expend 1 of the staff's charges to cast *Charm Person*, *Command*, or *Comprehend Languages* from it using your spell save DC.

**Reflect Enchantment.*** If you succeed on a saving throw against an Enchantment spell that targets only you, you can take a Reaction to expend 1 charge from the staff and turn the spell back on its caster as if you had cast the spell.

**Resist Enchantment.** If you fail a saving throw against an Enchantment spell that targets only you, you can turn your failed save into a successful one. You can't use this property of the staff again until the next dawn.

**Regaining Charges.** The staff regains 1d8 + 2 expended charges daily at dawn. If you expend the last charge, roll 1d20. On a 1, the staff crumbles to dust and is destroyed.
`,
      "Staff-of-Fire.md": `---
smType: item
name: "Staff of Fire"
category: "Staff"
type: "Requires Attunement by a Druid, Sorcerer, Warlock, or Wizard"
rarity: "Very Rare"
attunement: true
attunement_req: "by a Druid, Sorcerer, Warlock, or Wizard"
max_charges: 10
recharge_formula: "1d6 + 4"
recharge_time: "Dawn"
destruction_risk: "On 1, the staff crumbles into cinders and is destroyed"
resistances: ["Fire"]
---

# Staff of Fire
*Staff (Requires Attunement by a Druid, Sorcerer, Warlock, or Wizard) Very Rare (Requires Attunement by a Druid, Sorcerer, Warlock, or Wizard)*

## Charges

This item has 10 charges.
regains 1d6 + 4 charges at Dawn.
On 1, the staff crumbles into cinders and is destroyed

- Resistances: Fire

You have Resistance to Fire damage while you hold this staff.
`,
      "Staff-of-Frost.md": `---
smType: item
name: "Staff of Frost"
category: "Staff"
type: "Requires Attunement by a Druid, Sorcerer, Warlock, or Wizard"
rarity: "Very Rare"
attunement: true
attunement_req: "by a Druid, Sorcerer, Warlock, or Wizard"
max_charges: 10
recharge_formula: "1d6 + 4"
recharge_time: "Dawn"
destruction_risk: "On 1, the staff turns to water and is destroyed"
resistances: ["Cold"]
---

# Staff of Frost
*Staff (Requires Attunement by a Druid, Sorcerer, Warlock, or Wizard) Very Rare (Requires Attunement by a Druid, Sorcerer, Warlock, or Wizard)*

## Charges

This item has 10 charges.
regains 1d6 + 4 charges at Dawn.
On 1, the staff turns to water and is destroyed

- Resistances: Cold

You have Resistance to Cold damage while you hold this staff.
`,
      "Staff-of-Healing.md": `---
smType: item
name: "Staff of Healing"
category: "Staff"
type: "Requires Attunement by a Bard, Cleric, or Druid"
rarity: "Rare"
attunement: true
attunement_req: "by a Bard, Cleric, or Druid"
max_charges: 10
recharge_formula: "1d6 + 4"
recharge_time: "Dawn"
destruction_risk: "On 1, the staff vanishes in a flash of light, lost forever"
---

# Staff of Healing
*Staff (Requires Attunement by a Bard, Cleric, or Druid) Rare (Requires Attunement by a Bard, Cleric, or Druid)*

## Charges

This item has 10 charges.
regains 1d6 + 4 charges at Dawn.
On 1, the staff vanishes in a flash of light, lost forever

This staff has 10 charges. While holding the staff, you can cast one of the spells on the following table from it, using your spellcasting ability modifier. The table indicates how many charges you must expend to cast the spell.
`,
      "Staff-of-Power.md": `---
smType: item
name: "Staff of Power"
category: "Staff"
type: "Requires Attunement by a Sorcerer, Warlock, or Wizard"
rarity: "Very Rare"
attunement: true
attunement_req: "by a Sorcerer, Warlock, or Wizard"
max_charges: 20
recharge_formula: "2d8 + 4"
recharge_time: "Dawn"
destruction_risk: "On 1, the staff retains its +2 bonus to attack rolls and damage rolls but loses all other properties"
---

# Staff of Power
*Staff (Requires Attunement by a Sorcerer, Warlock, or Wizard) Very Rare (Requires Attunement by a Sorcerer, Warlock, or Wizard)*

## Charges

This item has 20 charges.
regains 2d8 + 4 charges at Dawn.
On 1, the staff retains its +2 bonus to attack rolls and damage rolls but loses all other properties

This staff has 20 charges and can be wielded as a magic Quarterstaff that grants a +2 bonus to attack rolls and damage rolls made with it. While holding it, you gain a +2 bonus to Armor Class, saving throws, and spell attack rolls.
`,
      "Staff-of-Striking.md": `---
smType: item
name: "Staff of Striking"
category: "Staff"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
max_charges: 10
recharge_formula: "1d6 + 4"
recharge_time: "Dawn"
destruction_risk: "On 1, the staff becomes a nonmagical Quarterstaff"
---

# Staff of Striking
*Staff (Requires Attunement) Very Rare (Requires Attunement)*

## Charges

This item has 10 charges.
regains 1d6 + 4 charges at Dawn.
On 1, the staff becomes a nonmagical Quarterstaff

This staff can be wielded as a magic Quarterstaff that grants a +3 bonus to attack rolls and damage rolls made with it.

The staff has 10 charges. When you hit with a melee attack using it, you can expend up to 3 charges. For each charge you expend, the target takes an extra 1d6 Force damage.
`,
      "Staff-of-Swarming-Insects.md": `---
smType: item
name: "Staff of Swarming Insects"
category: "Staff"
type: "Requires Attunement by a Bard, Cleric, Druid, Sorcerer, Warlock, or Wizard"
rarity: "Rare"
attunement: true
attunement_req: "by a Bard, Cleric, Druid, Sorcerer, Warlock, or Wizard"
max_charges: 10
recharge_formula: "1d6 + 4"
recharge_time: "Dawn"
destruction_risk: "On 1, a swarm of insects consumes and destroys the staff, then disperses"
---

# Staff of Swarming Insects
*Staff (Requires Attunement by a Bard, Cleric, Druid, Sorcerer, Warlock, or Wizard) Rare (Requires Attunement by a Bard, Cleric, Druid, Sorcerer, Warlock, or Wizard)*

## Charges

This item has 10 charges.
regains 1d6 + 4 charges at Dawn.
On 1, a swarm of insects consumes and destroys the staff, then disperses

This staff has 10 charges.
`,
      "Staff-of-the-Magi.md": `---
smType: item
name: "Staff of the Magi"
category: "Staff"
type: "Requires Attunement by a Sorcerer, Warlock, or Wizard"
rarity: "Legendary"
attunement: true
attunement_req: "by a Sorcerer, Warlock, or Wizard"
max_charges: 50
recharge_formula: "4d6 + 2"
recharge_time: "Dawn"
---

# Staff of the Magi
*Staff (Requires Attunement by a Sorcerer, Warlock, or Wizard) Legendary (Requires Attunement by a Sorcerer, Warlock, or Wizard)*

## Charges

This item has 50 charges.
regains 4d6 + 2 charges at Dawn.

This staff has 50 charges and can be wielded as a magic Quarterstaff that grants a +2 bonus to attack rolls and damage rolls made with it. While you hold it, you gain a +2 bonus to spell attack rolls.
`,
      "Staff-of-the-Python.md": `---
smType: item
name: "Staff of the Python"
category: "Staff"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Staff of the Python
*Staff (Requires Attunement) Uncommon (Requires Attunement)*

As a Magic action, you can throw this staff so that it lands in an unoccupied space within 10 feet of you, causing the staff to become a **Giant Constrictor Snake** in that space. The snake is under your control and shares your Initiative count, taking its turn immediately after yours.

On your turn, you can mentally command the snake (no action required) if it is within 60 feet of you and you don't have the Incapacitated condition. You decide what action the snake takes and where it moves during its turn, or you can issue it a general command, such as to attack your enemies or guard a location. Absent commands from you, the snake defends itself.

As a Bonus Action, you can command the snake to revert to staff form in its current space, and you can't use the staff's property again for 1 hour. If the snake is reduced to 0 Hit Points, it dies and reverts to its staff form; the staff then shatters and is destroyed. If the snake reverts to staff form before losing all its Hit Points, it regains all of them.
`,
      "Staff-of-the-Woodlands.md": `---
smType: item
name: "Staff of the Woodlands"
category: "Staff"
type: "Requires Attunement by a Druid"
rarity: "Rare"
attunement: true
attunement_req: "by a Druid"
max_charges: 6
recharge_formula: "1d6"
recharge_time: "Dawn"
destruction_risk: "On 1, the staff loses its properties and becomes a nonmagical Quarterstaff"
---

# Staff of the Woodlands
*Staff (Requires Attunement by a Druid) Rare (Requires Attunement by a Druid)*

## Charges

This item has 6 charges.
regains 1d6 charges at Dawn.
On 1, the staff loses its properties and becomes a nonmagical Quarterstaff

This staff has 6 charges and can be wielded as a magic Quarterstaff that grants a +2 bonus to attack rolls and damage rolls made with it. While holding it, you have a +2 bonus to spell attack rolls.
`,
      "Staff-of-Thunder-and-Lightning.md": `---
smType: item
name: "Staff of Thunder and Lightning"
category: "Staff"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
---

# Staff of Thunder and Lightning
*Staff (Requires Attunement) Very Rare (Requires Attunement)*

This staff can be wielded as a magic Quarterstaff that grants a +2 bonus to attack rolls and damage rolls made with it. It also has the following additional properties. Once one of these properties is used, it can't be used again until the next dawn.
`,
      "Staff-of-Withering.md": `---
smType: item
name: "Staff of Withering"
category: "Staff"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Staff of Withering
*Staff (Requires Attunement) Rare (Requires Attunement)*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This staff has 3 charges and regains 1d3 expended charges daily at dawn.

The staff can be wielded as a magic Quarterstaff. On a hit, it deals damage as a normal Quarterstaff, and you can expend 1 charge to deal an extra 2d10 Necrotic damage to the target and force it to make a DC 15 Constitution saving throw. On a failed save, the target has Disadvantage for 1 hour on any ability check or saving throw that uses Strength or Constitution.
`,
      "Stone-of-Controlling-Earth-Elementals.md": `---
smType: item
name: "Stone of Controlling Earth Elementals"
category: "Wondrous"
rarity: "Rare"
---

# Stone of Controlling Earth Elementals
*Wondrous Rare*

While touching this 5-pound stone to the ground, you can take a Magic action to summon an **Earth Elemental**. The elemental appears in an unoccupied space you choose within 30 feet of yourself, obeys your commands, and takes its turn immediately after you on your Initiative count. The elemental disappears after 1 hour, when it dies, or when you dismiss it as a Bonus Action. The stone can't be used this way again until the next dawn.
`,
      "Stone-of-Good-Luck-Luckstone.md": `---
smType: item
name: "Stone of Good Luck (Luckstone)"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Stone of Good Luck (Luckstone)
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While this polished agate is on your person, you gain a +1 bonus to ability checks and saving throws.
`,
      "Sun-Blade.md": `---
smType: item
name: "Sun Blade"
category: "Weapon"
type: "Longsword"
rarity: "Rare"
attunement: true
---

# Sun Blade
*Weapon (Longsword) Rare (Requires Attunement)*

This item appears to be a sword hilt.
`,
      "Sword-of-Life-Stealing.md": `---
smType: item
name: "Sword of Life Stealing"
category: "Weapon"
type: "Glaive, Greatsword, Longsword, Rapier, Scimitar, or Shortsword"
rarity: "Rare"
attunement: true
---

# Sword of Life Stealing
*Weapon (Glaive, Greatsword, Longsword, Rapier, Scimitar, or Shortsword) Rare (Requires Attunement)*

When you attack a creature with this magic weapon and roll a 20 on the d20 for the attack roll, that target takes an extra 15 Necrotic damage if it isn't a Construct or an Undead, and you gain Temporary Hit Points equal to the amount of Necrotic damage taken.
`,
      "Sword-of-Sharpness.md": `---
smType: item
name: "Sword of Sharpness"
category: "Weapon"
type: "Glaive, Greatsword, Longsword, or Scimitar"
rarity: "Very Rare"
attunement: true
---

# Sword of Sharpness
*Weapon (Glaive, Greatsword, Longsword, or Scimitar) Very Rare (Requires Attunement)*

When you attack an object with this magic weapon and hit, maximize your weapon damage dice against the target.

When you attack a creature with this weapon and roll a 20 on the d20 for the attack roll, that target takes an extra 14 Slashing damage and gains 1 Exhaustion level.
`,
      "Sword-of-Wounding.md": `---
smType: item
name: "Sword of Wounding"
category: "Weapon"
type: "Glaive, Greatsword, Longsword, Rapier, Scimitar, or Shortsword"
rarity: "Rare"
attunement: true
---

# Sword of Wounding
*Weapon (Glaive, Greatsword, Longsword, Rapier, Scimitar, or Shortsword) Rare (Requires Attunement)*

When you hit a creature with an attack using this magic weapon, the target takes an extra 2d6 Necrotic damage and must succeed on a DC 15 Constitution saving throw or be unable to regain Hit Points for 1 hour. The target repeats the save at the end of each of its turns, ending the effect on itself on a success.
`,
      "Talisman-of-Pure-Good.md": `---
smType: item
name: "Talisman of Pure Good"
category: "Wondrous"
type: "Requires Attunement by a Cleric or Paladin"
rarity: "Legendary"
attunement: true
attunement_req: "by a Cleric or Paladin"
max_charges: 7
---

# Talisman of Pure Good
*Wondrous (Requires Attunement by a Cleric or Paladin) Legendary (Requires Attunement by a Cleric or Paladin)*

## Charges

This item has 7 charges.

This talisman is a mighty symbol of goodness. A Fiend or an Undead that touches the talisman takes 8d6 Radiant damage and takes the damage again each time it ends its turn holding or carrying the talisman.
`,
      "Talisman-of-the-Sphere.md": `---
smType: item
name: "Talisman of the Sphere"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
---

# Talisman of the Sphere
*Wondrous (Requires Attunement) Legendary (Requires Attunement)*

While holding or wearing this talisman, you have Advantage on any Intelligence (Arcana) check you make to control a *Sphere of Annihilation*. In addition, when you start your turn in control of a *Sphere of Annihilation*, you can take a Magic action to move it 10 feet plus a number of additional feet equal to 10 times your Intelligence modifier. This movement doesn't have to be in a straight line.
`,
      "Talisman-of-Ultimate-Evil.md": `---
smType: item
name: "Talisman of Ultimate Evil"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
max_charges: 6
---

# Talisman of Ultimate Evil
*Wondrous (Requires Attunement) Legendary (Requires Attunement)*

## Charges

This item has 6 charges.

This item symbolizes unrepentant evil. A creature that isn't a Fiend or an Undead that touches the talisman takes 8d6 Necrotic damage and takes the damage again each time it ends its turn holding or carrying the talisman.
`,
      "Tome-of-Clear-Thought.md": `---
smType: item
name: "Tome of Clear Thought"
category: "Wondrous"
rarity: "Very Rare"
---

# Tome of Clear Thought
*Wondrous Very Rare*

This book contains memory and logic exercises, and its words are charged with magic. If you spend 48 hours over a period of 6 days or fewer studying the book's contents and practicing its guidelines, your Intelligence increases by 2, to a maximum of 30. The manual then loses its magic but regains it in a century.
`,
      "Tome-of-Leadership-and-Influence.md": `---
smType: item
name: "Tome of Leadership and Influence"
category: "Wondrous"
rarity: "Very Rare"
---

# Tome of Leadership and Influence
*Wondrous Very Rare*

This book contains guidelines for influencing and charming others, and its words are charged with magic. If you spend 48 hours over a period of 6 days or fewer studying the book's contents and practicing its guidelines, your Charisma increases by 2, to a maximum of 30. The manual then loses its magic but regains it in a century.
`,
      "Tome-of-Understanding.md": `---
smType: item
name: "Tome of Understanding"
category: "Wondrous"
rarity: "Very Rare"
---

# Tome of Understanding
*Wondrous Very Rare*

This book contains intuition and insight exercises, and its words are charged with magic. If you spend 48 hours over a period of 6 days or fewer studying the book's contents and practicing its guidelines, your Wisdom increases by 2, to a maximum of 30. The manual then loses its magic, but regains it in a century.
`,
      "Trident-of-Fish-Command.md": `---
smType: item
name: "Trident of Fish Command"
category: "Weapon"
type: "Trident"
rarity: "Uncommon"
attunement: true
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Trident of Fish Command
*Weapon (Trident) Uncommon (Requires Attunement)*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This magic weapon has 3 charges, and it regains 1d3 expended charges daily at dawn. While you carry it, you can expend 1 charge to cast *Dominate Beast* (save DC 15) from it on a Beast that has a Swim Speed.
`,
      "Universal-Solvent.md": `---
smType: item
name: "Universal Solvent"
category: "Wondrous"
rarity: "Legendary"
---

# Universal Solvent
*Wondrous Legendary*

This tube holds milky liquid with a strong alcohol smell. When found, a tube contains 1d6 + 1 ounces.

You can take a Utilize action to pour 1 or more ounces of solvent from the tube onto a surface within reach. Each ounce instantly dissolves up to 1 square foot of adhesive it touches, including *Sovereign Glue*.
`,
      "Vicious-Weapon.md": `---
smType: item
name: "Vicious Weapon"
category: "Weapon"
type: "Any Simple or Martial"
rarity: "Rare"
---

# Vicious Weapon
*Weapon (Any Simple or Martial) Rare*

This magic weapon deals an extra 2d6 damage to any creature it hits. This extra damage is of the same type as the weapon's normal damage.
`,
      "Vorpal-Sword.md": `---
smType: item
name: "Vorpal Sword"
category: "Weapon"
type: "Glaive, Greatsword, Longsword, or Scimitar"
rarity: "Legendary"
attunement: true
resistances: ["Slashing"]
---

# Vorpal Sword
*Weapon (Glaive, Greatsword, Longsword, or Scimitar) Legendary (Requires Attunement)*

- Resistances: Slashing

You gain a +3 bonus to attack rolls and damage rolls made with this magic weapon. In addition, the weapon ignores Resistance to Slashing damage.

When you use this weapon to attack a creature that has at least one head and roll a 20 on the d20 for the attack roll, you cut off one of the creature's heads. The creature dies if it can't survive without the lost head. A creature is immune to this effect if it has Immunity to Slashing damage, if it doesn't have or need a head, or if the GM decides that the creature is too big for its head to be cut off with this weapon. Such a creature instead takes an extra 30 Slashing damage from the hit. If the creature has Legendary Resistance, it can expend one daily use of that trait to avoid losing its head, taking the extra damage instead.
`,
      "Wand-of-Binding.md": `---
smType: item
name: "Wand of Binding"
category: "Wand"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# Wand of Binding
*Wand (Requires Attunement) Rare (Requires Attunement)*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed

This wand has 7 charges.
`,
      "Wand-of-Enemy-Detection.md": `---
smType: item
name: "Wand of Enemy Detection"
category: "Wand"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# Wand of Enemy Detection
*Wand (Requires Attunement) Rare (Requires Attunement)*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed

This wand has 7 charges. While holding it, you can take a Magic action to expend 1 charge. For 1 minute, you know the direction of the nearest creature Hostile to you within 60 feet, but not its distance from you. The wand can sense the presence of Hostile creatures that are Invisible, ethereal, disguised, or hidden, as well as those in plain sight. The effect ends if you stop holding the wand.
`,
      "Wand-of-Fear.md": `---
smType: item
name: "Wand of Fear"
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# Wand of Fear

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed
`,
      "Wand-of-Fireballs.md": `---
smType: item
name: "**Wand of Fireballs"
category: "Wand"
type: "Requires Attunement by a Spellcaster"
rarity: "Rare"
attunement: true
attunement_req: "by a Spellcaster"
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# **Wand of Fireballs
*Wand (Requires Attunement by a Spellcaster) Rare (Requires Attunement by a Spellcaster)*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed

This wand has 7 charges. While holding it, you can expend no more than 3 charges to cast *Fireball* (save DC 15) from it. For 1 charge, you cast the level 3 version of the spell. You can increase the spell's level by 1 for each additional charge you expend.
`,
      "Wand-of-Lightning-Bolts.md": `---
smType: item
name: "Wand of Lightning Bolts"
category: "Wand"
type: "Requires Attunement by a Spellcaster"
rarity: "Rare"
attunement: true
attunement_req: "by a Spellcaster"
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# Wand of Lightning Bolts
*Wand (Requires Attunement by a Spellcaster) Rare (Requires Attunement by a Spellcaster)*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed

This wand has 7 charges. While holding it, you can expend no more than 3 charges to cast *Lightning Bolt* (save DC 15) from it. For 1 charge, you cast the level 3 version of the spell. You can increase the spell's level by 1 for each additional charge you expend.
`,
      "Wand-of-Magic-Detection.md": `---
smType: item
name: "Wand of Magic Detection"
category: "Wand"
rarity: "Uncommon"
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Wand of Magic Detection
*Wand Uncommon*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This wand has 3 charges. While holding it, you can expend 1 charge to cast *Detect Magic* from it. The wand regains 1d3 expended charges daily at dawn.
`,
      "Wand-of-Magic-Missiles.md": `---
smType: item
name: "Wand of Magic Missiles"
category: "Wand"
rarity: "Uncommon"
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# Wand of Magic Missiles
*Wand Uncommon*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed

This wand has 7 charges. While holding it, you can expend no more than 3 charges to cast *Magic Missile* from it. For 1 charge, you cast the level 1 version of the spell. You can increase the spell's level by 1 for each additional charge you expend.
`,
      "Wand-of-Paralysis.md": `---
smType: item
name: "Wand of Paralysis"
category: "Wand"
type: "Requires Attunement by a Spellcaster"
rarity: "Rare"
attunement: true
attunement_req: "by a Spellcaster"
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# Wand of Paralysis
*Wand (Requires Attunement by a Spellcaster) Rare (Requires Attunement by a Spellcaster)*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed

This wand has 7 charges. While holding it, you can take a Magic action to expend 1 charge to cause a thin blue ray to streak from the tip toward a creature you can see within 60 feet of yourself. The target must succeed on a DC 15 Constitution saving throw or have the Paralyzed condition for 1 minute. At the end of each of the target's turns, it repeats the save, ending the effect on itself on a success.
`,
      "Wand-of-Polymorph.md": `---
smType: item
name: "Wand of Polymorph"
category: "Wand"
type: "Requires Attunement by a Spellcaster"
rarity: "Very Rare"
attunement: true
attunement_req: "by a Spellcaster"
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# Wand of Polymorph
*Wand (Requires Attunement by a Spellcaster) Very Rare (Requires Attunement by a Spellcaster)*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed

This wand has 7 charges. While holding it, you can expend 1 charge to cast *Polymorph* (save DC 15) from it.
`,
      "Wand-of-Secrets.md": `---
smType: item
name: "Wand of Secrets"
category: "Wand"
rarity: "Uncommon"
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Wand of Secrets
*Wand Uncommon*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This wand has 3 charges and regains 1d3 expended charges daily at dawn. While holding it, you can take a Magic action to expend 1 charge, and if a secret door or trap is within 60 feet of you, the wand pulses and points at the one nearest to you.
`,
      "Wand-of-the-War-Mage-1-2-or-3.md": `---
smType: item
name: "Wand of the War Mage, +1, +2, or +3"
category: "Wand"
type: "+1"
rarity: "Uncommon"
attunement: true
attunement_req: "by a Spellcaster"
---

# Wand of the War Mage, +1, +2, or +3
*Wand (+1) Uncommon (Requires Attunement by a Spellcaster)*

While holding this wand, you gain a bonus to spell attack rolls determined by the wand's rarity. In addition, you ignore Half Cover when making a spell attack roll.
`,
      "Wand-of-Web.md": `---
smType: item
name: "Wand of Web"
category: "Wand"
type: "Requires Attunement by a Spellcaster"
rarity: "Uncommon"
attunement: true
attunement_req: "by a Spellcaster"
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# Wand of Web
*Wand (Requires Attunement by a Spellcaster) Uncommon (Requires Attunement by a Spellcaster)*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed

This wand has 7 charges. While holding it, you can expend 1 charge to cast *Web* (save DC 13) from it.
`,
      "Wand-of-Wonder.md": `---
smType: item
name: "Wand of Wonder"
category: "Wand"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into dust and is destroyed"
---

# Wand of Wonder
*Wand (Requires Attunement) Rare (Requires Attunement)*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into dust and is destroyed

This wand has 7 charges. While holding it, you can take a Magic action to expend 1 charge while choosing a point within 120 feet of yourself. That location becomes the point of origin of a spell or other magical effect determined by rolling on the Wand of Wonder Effects table. Spells cast from the wand have a save DC of 15. If a spell's maximum range is normally less than 120 feet, it becomes 120 feet when cast from the wand. If an effect has multiple possible subjects, the GM determines randomly which among them are affected.
`,
      "Weapon-1-2-or-3.md": `---
smType: item
name: "Weapon, +1, +2, or +3"
category: "Weapon"
type: "Any Simple or Martial"
rarity: "Uncommon"
---

# Weapon, +1, +2, or +3
*Weapon (Any Simple or Martial) Uncommon*

You have a bonus to attack rolls and damage rolls made with this magic weapon. The bonus is determined by the weapon's rarity.
`,
      "Weapon-of-Warning.md": `---
smType: item
name: "Weapon of Warning"
category: "Weapon"
type: "Any Simple or Martial"
rarity: "Uncommon"
attunement: true
---

# Weapon of Warning
*Weapon (Any Simple or Martial) Uncommon (Requires Attunement)*

As long as this weapon is within your reach and you are attuned to it, you and allies within 30 feet of you gain the following benefits.
`,
      "Well-of-Many-Worlds.md": `---
smType: item
name: "Well of Many Worlds"
category: "Wondrous"
rarity: "Legendary"
---

# Well of Many Worlds
*Wondrous Legendary*

This fine black cloth, soft as silk, is folded up to the dimensions of a handkerchief. It unfolds into a circular sheet 6 feet in diameter.

You can take a Magic action to unfold the *Well of Many Worlds* and place it on a solid surface, whereupon it forms a two-way, 6-foot-diameter, circular portal to another world or plane of existence. Each time the item opens a portal, the GM decides where it leads. The portal remains open until a creature within 5 feet of it takes a Magic action to close it by taking hold of the edges of the cloth and folding it up.

Once the *Well of Many Worlds* has opened a portal, it can't do so again for 1d8 hours.
`,
      "Wind-Fan.md": `---
smType: item
name: "Wind Fan"
category: "Wondrous"
rarity: "Uncommon"
---

# Wind Fan
*Wondrous Uncommon*

While holding this fan, you can cast *Gust of Wind* (save DC 13) from it. Each subsequent time the fan is used before the next dawn, it has a cumulative 20 percent chance of not working; if the fan fails to work, it tears into useless, nonmagical tatters.
`,
      "Winged-Boots.md": `---
smType: item
name: "Winged Boots"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Winged Boots
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

These boots have 4 charges and regain 1d4 expended charges daily at dawn. While wearing the boots, you can take a Magic action to expend 1 charge, gaining a Fly Speed of 30 feet for 1 hour. If you are flying when the duration expires, you descend at a rate of 30 feet per round until you land.
`,
      "Wings-of-Flying.md": `---
smType: item
name: "Wings of Flying"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Wings of Flying
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

While wearing this cloak, you can take a Magic action to turn the cloak into a pair of wings on your back. The wings lasts for 1 hour or until you end the effect early as a Magic action. The wings give you a Fly Speed of 60 feet. If you are aloft when the wings disappear, you fall. When the wings disappear, you can't use them again for 1d12 hours.
`
    };
    PRESET_EQUIPMENT = {
      "Armor/.md": `---
smType: equipment
name: ""
type: "armor"
armor_category: "Shield"
don_time: "Utilize Action"
doff_time: "Utilize Action"
---

# 
*Shield Armor*

**Time:** Don: Utilize Action, Doff: Utilize Action
`,
      "Gear/Acid.md": `---
smType: equipment
name: "Acid"
type: "gear"
cost: "25 GP"
weight: "1 lb."
---

# Acid
*Adventuring Gear*

- **Cost:** 25 GP
- **Weight:** 1 lb.
`,
      "Gear/Alchemist-s-Fire.md": `---
smType: equipment
name: "Alchemist's Fire"
type: "gear"
cost: "50 GP"
weight: "1 lb."
---

# Alchemist's Fire
*Adventuring Gear*

- **Cost:** 50 GP
- **Weight:** 1 lb.
`,
      "Gear/Ammunition.md": `---
smType: equipment
name: "Ammunition"
type: "gear"
cost: "Varies"
weight: "Varies"
---

# Ammunition
*Adventuring Gear*

- **Cost:** Varies
- **Weight:** Varies
`,
      "Gear/Antitoxin.md": `---
smType: equipment
name: "Antitoxin"
type: "gear"
cost: "50 GP"
weight: "\u2014"
---

# Antitoxin
*Adventuring Gear*

- **Cost:** 50 GP
- **Weight:** \u2014
`,
      "Gear/Arcane-Focus.md": `---
smType: equipment
name: "Arcane Focus"
type: "gear"
cost: "Varies"
weight: "Varies"
---

# Arcane Focus
*Adventuring Gear*

- **Cost:** Varies
- **Weight:** Varies
`,
      "Gear/Backpack.md": `---
smType: equipment
name: "Backpack"
type: "gear"
cost: "2 GP"
weight: "5 lb."
---

# Backpack
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 5 lb.
`,
      "Gear/Ball-Bearings.md": `---
smType: equipment
name: "Ball Bearings"
type: "gear"
cost: "1 GP"
weight: "2 lb."
---

# Ball Bearings
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 2 lb.
`,
      "Gear/Barrel.md": `---
smType: equipment
name: "Barrel"
type: "gear"
cost: "2 GP"
weight: "70 lb."
---

# Barrel
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 70 lb.
`,
      "Gear/Basket.md": `---
smType: equipment
name: "Basket"
type: "gear"
cost: "4 SP"
weight: "2 lb."
---

# Basket
*Adventuring Gear*

- **Cost:** 4 SP
- **Weight:** 2 lb.
`,
      "Gear/Bedroll.md": `---
smType: equipment
name: "Bedroll"
type: "gear"
cost: "1 GP"
weight: "7 lb."
---

# Bedroll
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 7 lb.
`,
      "Gear/Bell.md": `---
smType: equipment
name: "Bell"
type: "gear"
cost: "1 GP"
weight: "\u2014"
---

# Bell
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** \u2014
`,
      "Gear/Blanket.md": `---
smType: equipment
name: "Blanket"
type: "gear"
cost: "5 SP"
weight: "3 lb."
---

# Blanket
*Adventuring Gear*

- **Cost:** 5 SP
- **Weight:** 3 lb.
`,
      "Gear/Block-and-Tackle.md": `---
smType: equipment
name: "Block and Tackle"
type: "gear"
cost: "1 GP"
weight: "5 lb."
---

# Block and Tackle
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 5 lb.
`,
      "Gear/Book.md": `---
smType: equipment
name: "Book"
type: "gear"
cost: "25 GP"
weight: "5 lb."
---

# Book
*Adventuring Gear*

- **Cost:** 25 GP
- **Weight:** 5 lb.
`,
      "Gear/Bottle-Glass.md": `---
smType: equipment
name: "Bottle, Glass"
type: "gear"
cost: "2 GP"
weight: "2 lb."
---

# Bottle, Glass
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 2 lb.
`,
      "Gear/Bucket.md": `---
smType: equipment
name: "Bucket"
type: "gear"
cost: "5 CP"
weight: "2 lb."
---

# Bucket
*Adventuring Gear*

- **Cost:** 5 CP
- **Weight:** 2 lb.
`,
      "Gear/Burglar-s-Pack.md": `---
smType: equipment
name: "Burglar's Pack"
type: "gear"
cost: "16 GP"
weight: "42 lb."
---

# Burglar's Pack
*Adventuring Gear*

- **Cost:** 16 GP
- **Weight:** 42 lb.
`,
      "Gear/Caltrops.md": `---
smType: equipment
name: "Caltrops"
type: "gear"
cost: "1 GP"
weight: "2 lb."
---

# Caltrops
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 2 lb.
`,
      "Gear/Candle.md": `---
smType: equipment
name: "Candle"
type: "gear"
cost: "1 CP"
weight: "\u2014"
---

# Candle
*Adventuring Gear*

- **Cost:** 1 CP
- **Weight:** \u2014
`,
      "Gear/Case-Crossbow-Bolt.md": `---
smType: equipment
name: "Case, Crossbow Bolt"
type: "gear"
cost: "1 GP"
weight: "1 lb."
---

# Case, Crossbow Bolt
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 1 lb.
`,
      "Gear/Case-Map-or-Scroll.md": `---
smType: equipment
name: "Case, Map or Scroll"
type: "gear"
cost: "1 GP"
weight: "1 lb."
---

# Case, Map or Scroll
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 1 lb.
`,
      "Gear/Chain.md": `---
smType: equipment
name: "Chain"
type: "gear"
cost: "5 GP"
weight: "10 lb."
---

# Chain
*Adventuring Gear*

- **Cost:** 5 GP
- **Weight:** 10 lb.
`,
      "Gear/Chest.md": `---
smType: equipment
name: "Chest"
type: "gear"
cost: "5 GP"
weight: "25 lb."
---

# Chest
*Adventuring Gear*

- **Cost:** 5 GP
- **Weight:** 25 lb.
`,
      "Gear/Climber-s-Kit.md": `---
smType: equipment
name: "Climber's Kit"
type: "gear"
cost: "25 GP"
weight: "12 lb."
---

# Climber's Kit
*Adventuring Gear*

- **Cost:** 25 GP
- **Weight:** 12 lb.
`,
      "Gear/Clothes-Fine.md": `---
smType: equipment
name: "Clothes, Fine"
type: "gear"
cost: "15 GP"
weight: "6 lb."
---

# Clothes, Fine
*Adventuring Gear*

- **Cost:** 15 GP
- **Weight:** 6 lb.
`,
      "Gear/Clothes-Traveler-s.md": `---
smType: equipment
name: "Clothes, Traveler's"
type: "gear"
cost: "2 GP"
weight: "4 lb."
---

# Clothes, Traveler's
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 4 lb.
`,
      "Gear/Component-Pouch.md": `---
smType: equipment
name: "Component Pouch"
type: "gear"
cost: "25 GP"
weight: "2 lb."
---

# Component Pouch
*Adventuring Gear*

- **Cost:** 25 GP
- **Weight:** 2 lb.
`,
      "Gear/Costume.md": `---
smType: equipment
name: "Costume"
type: "gear"
cost: "5 GP"
weight: "4 lb."
---

# Costume
*Adventuring Gear*

- **Cost:** 5 GP
- **Weight:** 4 lb.
`,
      "Gear/Crowbar.md": `---
smType: equipment
name: "Crowbar"
type: "gear"
cost: "2 GP"
weight: "5 lb."
---

# Crowbar
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 5 lb.
`,
      "Gear/Diplomat-s-Pack.md": `---
smType: equipment
name: "Diplomat's Pack"
type: "gear"
cost: "39 GP"
weight: "39 lb."
---

# Diplomat's Pack
*Adventuring Gear*

- **Cost:** 39 GP
- **Weight:** 39 lb.
`,
      "Gear/Druidic-Focus.md": `---
smType: equipment
name: "Druidic Focus"
type: "gear"
cost: "Varies"
weight: "Varies"
---

# Druidic Focus
*Adventuring Gear*

- **Cost:** Varies
- **Weight:** Varies
`,
      "Gear/Dungeoneer-s-Pack.md": `---
smType: equipment
name: "Dungeoneer's Pack"
type: "gear"
cost: "12 GP"
weight: "55 lb."
---

# Dungeoneer's Pack
*Adventuring Gear*

- **Cost:** 12 GP
- **Weight:** 55 lb.
`,
      "Gear/Entertainer-s-Pack.md": `---
smType: equipment
name: "Entertainer's Pack"
type: "gear"
cost: "40 GP"
weight: "58\xBD lb."
---

# Entertainer's Pack
*Adventuring Gear*

- **Cost:** 40 GP
- **Weight:** 58\xBD lb.
`,
      "Gear/Explorer-s-Pack.md": `---
smType: equipment
name: "Explorer's Pack"
type: "gear"
cost: "10 GP"
weight: "55 lb."
---

# Explorer's Pack
*Adventuring Gear*

- **Cost:** 10 GP
- **Weight:** 55 lb.
`,
      "Gear/Flask.md": `---
smType: equipment
name: "Flask"
type: "gear"
cost: "2 CP"
weight: "1 lb."
---

# Flask
*Adventuring Gear*

- **Cost:** 2 CP
- **Weight:** 1 lb.
`,
      "Gear/Grappling-Hook.md": `---
smType: equipment
name: "Grappling Hook"
type: "gear"
cost: "2 GP"
weight: "4 lb."
---

# Grappling Hook
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 4 lb.
`,
      "Gear/Healer-s-Kit.md": `---
smType: equipment
name: "Healer's Kit"
type: "gear"
cost: "5 GP"
weight: "3 lb."
---

# Healer's Kit
*Adventuring Gear*

- **Cost:** 5 GP
- **Weight:** 3 lb.
`,
      "Gear/Holy-Symbol.md": `---
smType: equipment
name: "Holy Symbol"
type: "gear"
cost: "Varies"
weight: "Varies"
---

# Holy Symbol
*Adventuring Gear*

- **Cost:** Varies
- **Weight:** Varies
`,
      "Gear/Holy-Water.md": `---
smType: equipment
name: "Holy Water"
type: "gear"
cost: "25 GP"
weight: "1 lb."
---

# Holy Water
*Adventuring Gear*

- **Cost:** 25 GP
- **Weight:** 1 lb.
`,
      "Gear/Hunting-Trap.md": `---
smType: equipment
name: "Hunting Trap"
type: "gear"
cost: "5 GP"
weight: "25 lb."
---

# Hunting Trap
*Adventuring Gear*

- **Cost:** 5 GP
- **Weight:** 25 lb.
`,
      "Gear/Ink-Pen.md": `---
smType: equipment
name: "Ink Pen"
type: "gear"
cost: "2 CP"
weight: "\u2014"
---

# Ink Pen
*Adventuring Gear*

- **Cost:** 2 CP
- **Weight:** \u2014
`,
      "Gear/Ink.md": `---
smType: equipment
name: "Ink"
type: "gear"
cost: "10 GP"
weight: "\u2014"
---

# Ink
*Adventuring Gear*

- **Cost:** 10 GP
- **Weight:** \u2014
`,
      "Gear/Jug.md": `---
smType: equipment
name: "Jug"
type: "gear"
cost: "2 CP"
weight: "4 lb."
---

# Jug
*Adventuring Gear*

- **Cost:** 2 CP
- **Weight:** 4 lb.
`,
      "Gear/Ladder.md": `---
smType: equipment
name: "Ladder"
type: "gear"
cost: "1 SP"
weight: "25 lb."
---

# Ladder
*Adventuring Gear*

- **Cost:** 1 SP
- **Weight:** 25 lb.
`,
      "Gear/Lamp.md": `---
smType: equipment
name: "Lamp"
type: "gear"
cost: "5 SP"
weight: "1 lb."
---

# Lamp
*Adventuring Gear*

- **Cost:** 5 SP
- **Weight:** 1 lb.
`,
      "Gear/Lantern-Bullseye.md": `---
smType: equipment
name: "Lantern, Bullseye"
type: "gear"
cost: "10 GP"
weight: "2 lb."
---

# Lantern, Bullseye
*Adventuring Gear*

- **Cost:** 10 GP
- **Weight:** 2 lb.
`,
      "Gear/Lantern-Hooded.md": `---
smType: equipment
name: "Lantern, Hooded"
type: "gear"
cost: "5 GP"
weight: "2 lb."
---

# Lantern, Hooded
*Adventuring Gear*

- **Cost:** 5 GP
- **Weight:** 2 lb.
`,
      "Gear/Lock.md": `---
smType: equipment
name: "Lock"
type: "gear"
cost: "10 GP"
weight: "1 lb."
---

# Lock
*Adventuring Gear*

- **Cost:** 10 GP
- **Weight:** 1 lb.
`,
      "Gear/Magnifying-Glass.md": `---
smType: equipment
name: "Magnifying Glass"
type: "gear"
cost: "100 GP"
weight: "\u2014"
---

# Magnifying Glass
*Adventuring Gear*

- **Cost:** 100 GP
- **Weight:** \u2014
`,
      "Gear/Manacles.md": `---
smType: equipment
name: "Manacles"
type: "gear"
cost: "2 GP"
weight: "6 lb."
---

# Manacles
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 6 lb.
`,
      "Gear/Map.md": `---
smType: equipment
name: "Map"
type: "gear"
cost: "1 GP"
weight: "\u2014"
---

# Map
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** \u2014
`,
      "Gear/Mirror.md": `---
smType: equipment
name: "Mirror"
type: "gear"
cost: "5 GP"
weight: "1/2 lb."
---

# Mirror
*Adventuring Gear*

- **Cost:** 5 GP
- **Weight:** 1/2 lb.
`,
      "Gear/Net.md": `---
smType: equipment
name: "Net"
type: "gear"
cost: "1 GP"
weight: "3 lb."
---

# Net
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 3 lb.
`,
      "Gear/Oil.md": `---
smType: equipment
name: "Oil"
type: "gear"
cost: "1 SP"
weight: "1 lb."
---

# Oil
*Adventuring Gear*

- **Cost:** 1 SP
- **Weight:** 1 lb.
`,
      "Gear/Paper.md": `---
smType: equipment
name: "Paper"
type: "gear"
cost: "2 SP"
weight: "\u2014"
---

# Paper
*Adventuring Gear*

- **Cost:** 2 SP
- **Weight:** \u2014
`,
      "Gear/Parchment.md": `---
smType: equipment
name: "Parchment"
type: "gear"
cost: "1 SP"
weight: "\u2014"
---

# Parchment
*Adventuring Gear*

- **Cost:** 1 SP
- **Weight:** \u2014
`,
      "Gear/Perfume.md": `---
smType: equipment
name: "Perfume"
type: "gear"
cost: "5 GP"
weight: "\u2014"
---

# Perfume
*Adventuring Gear*

- **Cost:** 5 GP
- **Weight:** \u2014
`,
      "Gear/Poison-Basic.md": `---
smType: equipment
name: "Poison, Basic"
type: "gear"
cost: "100 GP"
weight: "\u2014"
---

# Poison, Basic
*Adventuring Gear*

- **Cost:** 100 GP
- **Weight:** \u2014
`,
      "Gear/Pole.md": `---
smType: equipment
name: "Pole"
type: "gear"
cost: "5 CP"
weight: "7 lb."
---

# Pole
*Adventuring Gear*

- **Cost:** 5 CP
- **Weight:** 7 lb.
`,
      "Gear/Pot-Iron.md": `---
smType: equipment
name: "Pot, Iron"
type: "gear"
cost: "2 GP"
weight: "10 lb."
---

# Pot, Iron
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 10 lb.
`,
      "Gear/Potion-of-Healing.md": `---
smType: equipment
name: "Potion of Healing"
type: "gear"
cost: "50 GP"
weight: "1/2 lb."
---

# Potion of Healing
*Adventuring Gear*

- **Cost:** 50 GP
- **Weight:** 1/2 lb.
`,
      "Gear/Pouch.md": `---
smType: equipment
name: "Pouch"
type: "gear"
cost: "5 SP"
weight: "1 lb."
---

# Pouch
*Adventuring Gear*

- **Cost:** 5 SP
- **Weight:** 1 lb.
`,
      "Gear/Priest-s-Pack.md": `---
smType: equipment
name: "Priest's Pack"
type: "gear"
cost: "33 GP"
weight: "29 lb."
---

# Priest's Pack
*Adventuring Gear*

- **Cost:** 33 GP
- **Weight:** 29 lb.
`,
      "Gear/Quiver.md": `---
smType: equipment
name: "Quiver"
type: "gear"
cost: "1 GP"
weight: "1 lb."
---

# Quiver
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 1 lb.
`,
      "Gear/Ram-Portable.md": `---
smType: equipment
name: "Ram, Portable"
type: "gear"
cost: "4 GP"
weight: "35 lb."
---

# Ram, Portable
*Adventuring Gear*

- **Cost:** 4 GP
- **Weight:** 35 lb.
`,
      "Gear/Rations.md": `---
smType: equipment
name: "Rations"
type: "gear"
cost: "5 SP"
weight: "2 lb."
---

# Rations
*Adventuring Gear*

- **Cost:** 5 SP
- **Weight:** 2 lb.
`,
      "Gear/Robe.md": `---
smType: equipment
name: "Robe"
type: "gear"
cost: "1 GP"
weight: "4 lb."
---

# Robe
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 4 lb.
`,
      "Gear/Rope.md": `---
smType: equipment
name: "Rope"
type: "gear"
cost: "1 GP"
weight: "5 lb."
---

# Rope
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 5 lb.
`,
      "Gear/Sack.md": `---
smType: equipment
name: "Sack"
type: "gear"
cost: "1 CP"
weight: "1/2 lb."
---

# Sack
*Adventuring Gear*

- **Cost:** 1 CP
- **Weight:** 1/2 lb.
`,
      "Gear/Scholar-s-Pack.md": `---
smType: equipment
name: "Scholar's Pack"
type: "gear"
cost: "40 GP"
weight: "22 lb."
---

# Scholar's Pack
*Adventuring Gear*

- **Cost:** 40 GP
- **Weight:** 22 lb.
`,
      "Gear/Shovel.md": `---
smType: equipment
name: "Shovel"
type: "gear"
cost: "2 GP"
weight: "5 lb."
---

# Shovel
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 5 lb.
`,
      "Gear/Signal-Whistle.md": `---
smType: equipment
name: "Signal Whistle"
type: "gear"
cost: "5 CP"
weight: "\u2014"
---

# Signal Whistle
*Adventuring Gear*

- **Cost:** 5 CP
- **Weight:** \u2014
`,
      "Gear/Spell-Scroll-Cantrip.md": `---
smType: equipment
name: "Spell Scroll (Cantrip)"
type: "gear"
cost: "30 GP"
weight: "\u2014"
---

# Spell Scroll (Cantrip)
*Adventuring Gear*

- **Cost:** 30 GP
- **Weight:** \u2014
`,
      "Gear/Spell-Scroll-Level-1.md": `---
smType: equipment
name: "Spell Scroll (Level 1)"
type: "gear"
cost: "50 GP"
weight: "\u2014"
---

# Spell Scroll (Level 1)
*Adventuring Gear*

- **Cost:** 50 GP
- **Weight:** \u2014
`,
      "Gear/Spikes-Iron.md": `---
smType: equipment
name: "Spikes, Iron"
type: "gear"
cost: "1 GP"
weight: "5 lb."
---

# Spikes, Iron
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 5 lb.
`,
      "Gear/Spyglass.md": `---
smType: equipment
name: "Spyglass"
type: "gear"
cost: "1,000 GP"
weight: "1 lb."
---

# Spyglass
*Adventuring Gear*

- **Cost:** 1,000 GP
- **Weight:** 1 lb.
`,
      "Gear/String.md": `---
smType: equipment
name: "String"
type: "gear"
cost: "1 SP"
weight: "\u2014"
---

# String
*Adventuring Gear*

- **Cost:** 1 SP
- **Weight:** \u2014
`,
      "Gear/Tent.md": `---
smType: equipment
name: "Tent"
type: "gear"
cost: "2 GP"
weight: "20 lb."
---

# Tent
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 20 lb.
`,
      "Gear/Tinderbox.md": `---
smType: equipment
name: "Tinderbox"
type: "gear"
cost: "5 SP"
weight: "1 lb."
---

# Tinderbox
*Adventuring Gear*

- **Cost:** 5 SP
- **Weight:** 1 lb.
`,
      "Gear/Torch.md": `---
smType: equipment
name: "Torch"
type: "gear"
cost: "1 CP"
weight: "1 lb."
---

# Torch
*Adventuring Gear*

- **Cost:** 1 CP
- **Weight:** 1 lb.
`,
      "Gear/Vial.md": `---
smType: equipment
name: "Vial"
type: "gear"
cost: "1 GP"
weight: "\u2014"
---

# Vial
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** \u2014
`,
      "Gear/Waterskin.md": `---
smType: equipment
name: "Waterskin"
type: "gear"
cost: "2 SP"
weight: "5 lb. (full)"
---

# Waterskin
*Adventuring Gear*

- **Cost:** 2 SP
- **Weight:** 5 lb. (full)
`,
      "Tools/Alchemist-s-Supplies.md": `---
smType: equipment
name: "Alchemist's Supplies"
type: "tool"
cost: "50 GP"
weight: "8 lb."
tool_category: "Artisan"
ability: "Intelligence"
utilize: ["Identify a substance (DC 15)", "start a fire (DC 15)"]
craft: ["Acid", "Alchemist's Fire", "Component Pouch", "Oil", "Paper", "Perfume"]
---

# Alchemist's Supplies
*Artisan Tool*

- **Cost:** 50 GP
- **Weight:** 8 lb.

**Ability:** Intelligence

## Utilize

- Identify a substance (DC 15)
- start a fire (DC 15)

## Craft

Acid, Alchemist's Fire, Component Pouch, Oil, Paper, Perfume
`,
      "Tools/Brewer-s-Supplies.md": `---
smType: equipment
name: "Brewer's Supplies"
type: "tool"
cost: "20 GP"
weight: "9 lb."
tool_category: "Artisan"
ability: "Intelligence"
utilize: ["Detect poisoned drink (DC 15)", "identify alcohol (DC 10)"]
craft: ["Antitoxin"]
---

# Brewer's Supplies
*Artisan Tool*

- **Cost:** 20 GP
- **Weight:** 9 lb.

**Ability:** Intelligence

## Utilize

- Detect poisoned drink (DC 15)
- identify alcohol (DC 10)

## Craft

Antitoxin
`,
      "Tools/Calligrapher-s-Supplies.md": `---
smType: equipment
name: "Calligrapher's Supplies"
type: "tool"
cost: "10 GP"
weight: "5 lb."
tool_category: "Artisan"
ability: "Dexterity"
utilize: ["Write text with impressive flourishes that guard against forgery (DC 15)"]
craft: ["Ink", "*Spell Scroll*"]
---

# Calligrapher's Supplies
*Artisan Tool*

- **Cost:** 10 GP
- **Weight:** 5 lb.

**Ability:** Dexterity

## Utilize

- Write text with impressive flourishes that guard against forgery (DC 15)

## Craft

Ink, *Spell Scroll*
`,
      "Tools/Carpenter-s-Tools.md": `---
smType: equipment
name: "Carpenter's Tools"
type: "tool"
cost: "8 GP"
weight: "6 lb."
tool_category: "Artisan"
ability: "Strength"
utilize: ["Seal or pry open a door or container (DC 20)"]
craft: ["Club", "Greatclub", "Quarterstaff", "Barrel", "Chest", "Ladder", "Pole", "Portable Ram", "Torch"]
---

# Carpenter's Tools
*Artisan Tool*

- **Cost:** 8 GP
- **Weight:** 6 lb.

**Ability:** Strength

## Utilize

- Seal or pry open a door or container (DC 20)

## Craft

Club, Greatclub, Quarterstaff, Barrel, Chest, Ladder, Pole, Portable Ram, Torch
`,
      "Tools/Cartographer-s-Tools.md": `---
smType: equipment
name: "Cartographer's Tools"
type: "tool"
cost: "15 GP"
weight: "6 lb."
tool_category: "Artisan"
ability: "Wisdom"
utilize: ["Draft a map of a small area (DC 15)"]
craft: ["Map"]
---

# Cartographer's Tools
*Artisan Tool*

- **Cost:** 15 GP
- **Weight:** 6 lb.

**Ability:** Wisdom

## Utilize

- Draft a map of a small area (DC 15)

## Craft

Map
`,
      "Tools/Cobbler-s-Tools.md": `---
smType: equipment
name: "Cobbler's Tools"
type: "tool"
cost: "5 GP"
weight: "5 lb."
tool_category: "Artisan"
ability: "Dexterity"
utilize: ["Modify footwear to give Advantage on the wearer's next Dexterity (Acrobatics) check (DC 10)"]
craft: ["Climber's Kit"]
---

# Cobbler's Tools
*Artisan Tool*

- **Cost:** 5 GP
- **Weight:** 5 lb.

**Ability:** Dexterity

## Utilize

- Modify footwear to give Advantage on the wearer's next Dexterity (Acrobatics) check (DC 10)

## Craft

Climber's Kit
`,
      "Tools/Cook-s-Utensils.md": `---
smType: equipment
name: "Cook's Utensils"
type: "tool"
cost: "1 GP"
weight: "8 lb."
tool_category: "Artisan"
ability: "Wisdom"
utilize: ["Improve food's flavor (DC 10)", "detect spoiled or poisoned food (DC 15)"]
craft: ["Rations"]
---

# Cook's Utensils
*Artisan Tool*

- **Cost:** 1 GP
- **Weight:** 8 lb.

**Ability:** Wisdom

## Utilize

- Improve food's flavor (DC 10)
- detect spoiled or poisoned food (DC 15)

## Craft

Rations
`,
      "Tools/Disguise-Kit.md": `---
smType: equipment
name: "Disguise Kit"
type: "tool"
cost: "25 GP"
weight: "3 lb."
tool_category: "Other"
ability: "Charisma"
utilize: ["Apply makeup (DC 10)"]
craft: ["Costume"]
---

# Disguise Kit
*Other Tool*

- **Cost:** 25 GP
- **Weight:** 3 lb.

**Ability:** Charisma

## Utilize

- Apply makeup (DC 10)

## Craft

Costume
`,
      "Tools/Forgery-Kit.md": `---
smType: equipment
name: "Forgery Kit"
type: "tool"
cost: "15 GP"
weight: "5 lb."
tool_category: "Other"
ability: "Dexterity"
utilize: ["Mimic 10 or fewer words of someone else's handwriting (DC 15)", "duplicate a wax seal (DC 20)"]
---

# Forgery Kit
*Other Tool*

- **Cost:** 15 GP
- **Weight:** 5 lb.

**Ability:** Dexterity

## Utilize

- Mimic 10 or fewer words of someone else's handwriting (DC 15)
- duplicate a wax seal (DC 20)
`,
      "Tools/Gaming-Set.md": `---
smType: equipment
name: "Gaming Set"
type: "tool"
cost: "Varies"
weight: "\u2014"
tool_category: "Gaming"
ability: "Wisdom"
utilize: ["Discern whether someone is cheating (DC 10)", "win the game (DC 20)"]
variants: ["Dice (1 SP)", "dragonchess (1 GP)", "playing cards (5 SP)", "three-dragon ante (1 GP)"]
---

# Gaming Set
*Gaming Tool*

- **Cost:** Varies
- **Weight:** \u2014

**Ability:** Wisdom

## Utilize

- Discern whether someone is cheating (DC 10)
- win the game (DC 20)

## Variants

- Dice (1 SP)
- dragonchess (1 GP)
- playing cards (5 SP)
- three-dragon ante (1 GP)
`,
      "Tools/Glassblower-s-Tools.md": `---
smType: equipment
name: "Glassblower's Tools"
type: "tool"
cost: "30 GP"
weight: "5 lb."
tool_category: "Artisan"
ability: "Intelligence"
utilize: ["Discern what a glass object held in the past 24 hours (DC 15)"]
craft: ["Glass Bottle", "Magnifying Glass", "Spyglass", "Vial"]
---

# Glassblower's Tools
*Artisan Tool*

- **Cost:** 30 GP
- **Weight:** 5 lb.

**Ability:** Intelligence

## Utilize

- Discern what a glass object held in the past 24 hours (DC 15)

## Craft

Glass Bottle, Magnifying Glass, Spyglass, Vial
`,
      "Tools/Herbalism-Kit.md": `---
smType: equipment
name: "Herbalism Kit"
type: "tool"
cost: "5 GP"
weight: "3 lb."
tool_category: "Other"
ability: "Intelligence"
utilize: ["Identify a plant (DC 10)"]
craft: ["Antitoxin", "Candle", "Healer's Kit", "*Potion of Healing*"]
---

# Herbalism Kit
*Other Tool*

- **Cost:** 5 GP
- **Weight:** 3 lb.

**Ability:** Intelligence

## Utilize

- Identify a plant (DC 10)

## Craft

Antitoxin, Candle, Healer's Kit, *Potion of Healing*
`,
      "Tools/Jeweler-s-Tools.md": `---
smType: equipment
name: "Jeweler's Tools"
type: "tool"
cost: "25 GP"
weight: "2 lb."
tool_category: "Artisan"
ability: "Intelligence"
utilize: ["Discern a gem's value (DC 15)"]
craft: ["Arcane Focus", "Holy Symbol"]
---

# Jeweler's Tools
*Artisan Tool*

- **Cost:** 25 GP
- **Weight:** 2 lb.

**Ability:** Intelligence

## Utilize

- Discern a gem's value (DC 15)

## Craft

Arcane Focus, Holy Symbol
`,
      "Tools/Leatherworker-s-Tools.md": `---
smType: equipment
name: "Leatherworker's Tools"
type: "tool"
cost: "5 GP"
weight: "5 lb."
tool_category: "Artisan"
ability: "Dexterity"
utilize: ["Add a design to a leather item (DC 10)"]
craft: ["Sling", "Whip", "Hide Armor", "Leather Armor", "Studded Leather Armor", "Backpack", "Crossbow Bolt Case", "Map or Scroll Case", "Parchment", "Pouch", "Quiver", "Waterskin"]
---

# Leatherworker's Tools
*Artisan Tool*

- **Cost:** 5 GP
- **Weight:** 5 lb.

**Ability:** Dexterity

## Utilize

- Add a design to a leather item (DC 10)

## Craft

Sling, Whip, Hide Armor, Leather Armor, Studded Leather Armor, Backpack, Crossbow Bolt Case, Map or Scroll Case, Parchment, Pouch, Quiver, Waterskin
`,
      "Tools/Mason-s-Tools.md": `---
smType: equipment
name: "Mason's Tools"
type: "tool"
cost: "10 GP"
weight: "8 lb."
tool_category: "Artisan"
ability: "Strength"
utilize: ["Chisel a symbol or hole in stone (DC 10)"]
craft: ["Block and Tackle"]
---

# Mason's Tools
*Artisan Tool*

- **Cost:** 10 GP
- **Weight:** 8 lb.

**Ability:** Strength

## Utilize

- Chisel a symbol or hole in stone (DC 10)

## Craft

Block and Tackle
`,
      "Tools/Musical-Instrument.md": `---
smType: equipment
name: "Musical Instrument"
type: "tool"
cost: "Varies"
weight: "Varies"
tool_category: "Musical"
ability: "Charisma"
utilize: ["Play a known tune (DC 10)", "improvise a song (DC 15)"]
variants: ["Bagpipes (30 GP", "6 lb.)", "drum (6 GP", "3 lb.)", "dulcimer (25 GP", "10 lb.)", "flute (2 GP", "1 lb.)", "horn (3 GP", "2 lb.)", "lute (35 GP", "2 lb.)", "lyre (30 GP", "2 lb.)", "pan flute (12 GP", "2 lb.)", "shawm (2 GP", "1 lb.)", "viol (30 GP", "1 lb.)"]
---

# Musical Instrument
*Musical Tool*

- **Cost:** Varies
- **Weight:** Varies

**Ability:** Charisma

## Utilize

- Play a known tune (DC 10)
- improvise a song (DC 15)

## Variants

- Bagpipes (30 GP
- 6 lb.)
- drum (6 GP
- 3 lb.)
- dulcimer (25 GP
- 10 lb.)
- flute (2 GP
- 1 lb.)
- horn (3 GP
- 2 lb.)
- lute (35 GP
- 2 lb.)
- lyre (30 GP
- 2 lb.)
- pan flute (12 GP
- 2 lb.)
- shawm (2 GP
- 1 lb.)
- viol (30 GP
- 1 lb.)
`,
      "Tools/Navigator-s-Tools.md": `---
smType: equipment
name: "Navigator's Tools"
type: "tool"
cost: "25 GP"
weight: "2 lb."
tool_category: "Other"
ability: "Wisdom"
utilize: ["Plot a course (DC 10)", "determine position by stargazing (DC 15)"]
---

# Navigator's Tools
*Other Tool*

- **Cost:** 25 GP
- **Weight:** 2 lb.

**Ability:** Wisdom

## Utilize

- Plot a course (DC 10)
- determine position by stargazing (DC 15)
`,
      "Tools/Painter-s-Supplies.md": `---
smType: equipment
name: "Painter's Supplies"
type: "tool"
cost: "10 GP"
weight: "5 lb."
tool_category: "Artisan"
ability: "Wisdom"
utilize: ["Paint a recognizable image of something you've seen (DC 10)"]
craft: ["Druidic Focus", "Holy Symbol"]
---

# Painter's Supplies
*Artisan Tool*

- **Cost:** 10 GP
- **Weight:** 5 lb.

**Ability:** Wisdom

## Utilize

- Paint a recognizable image of something you've seen (DC 10)

## Craft

Druidic Focus, Holy Symbol
`,
      "Tools/Poisoner-s-Kit.md": `---
smType: equipment
name: "Poisoner's Kit"
type: "tool"
cost: "50 GP"
weight: "2 lb."
tool_category: "Other"
ability: "Intelligence"
utilize: ["Detect a poisoned object (DC 10)"]
craft: ["Basic Poison"]
---

# Poisoner's Kit
*Other Tool*

- **Cost:** 50 GP
- **Weight:** 2 lb.

**Ability:** Intelligence

## Utilize

- Detect a poisoned object (DC 10)

## Craft

Basic Poison
`,
      "Tools/Potter-s-Tools.md": `---
smType: equipment
name: "Potter's Tools"
type: "tool"
cost: "10 GP"
weight: "3 lb."
tool_category: "Artisan"
ability: "Intelligence"
utilize: ["Discern what a ceramic object held in the past 24 hours (DC 15)"]
craft: ["Jug", "Lamp"]
---

# Potter's Tools
*Artisan Tool*

- **Cost:** 10 GP
- **Weight:** 3 lb.

**Ability:** Intelligence

## Utilize

- Discern what a ceramic object held in the past 24 hours (DC 15)

## Craft

Jug, Lamp
`,
      "Tools/Smith-s-Tools.md": `---
smType: equipment
name: "Smith's Tools"
type: "tool"
cost: "20 GP"
weight: "8 lb."
tool_category: "Artisan"
ability: "Strength"
utilize: ["Pry open a door or container (DC 20)"]
craft: ["Any Melee weapon (except Club", "Greatclub", "Quarterstaff", "and Whip)", "Medium armor (except Hide)", "Heavy armor", "Ball Bearings", "Bucket", "Caltrops", "Chain", "Crowbar", "Firearm Bullets", "Grappling Hook", "Iron Pot", "Iron Spikes", "Sling Bullets"]
---

# Smith's Tools
*Artisan Tool*

- **Cost:** 20 GP
- **Weight:** 8 lb.

**Ability:** Strength

## Utilize

- Pry open a door or container (DC 20)

## Craft

Any Melee weapon (except Club, Greatclub, Quarterstaff, and Whip), Medium armor (except Hide), Heavy armor, Ball Bearings, Bucket, Caltrops, Chain, Crowbar, Firearm Bullets, Grappling Hook, Iron Pot, Iron Spikes, Sling Bullets
`,
      "Tools/Thieves-Tools.md": `---
smType: equipment
name: "Thieves' Tools"
type: "tool"
cost: "25 GP"
weight: "1 lb."
tool_category: "Other"
ability: "Dexterity"
utilize: ["Pick a lock (DC 15)", "disarm a trap (DC 15)"]
---

# Thieves' Tools
*Other Tool*

- **Cost:** 25 GP
- **Weight:** 1 lb.

**Ability:** Dexterity

## Utilize

- Pick a lock (DC 15)
- disarm a trap (DC 15)
`,
      "Tools/Tinker-s-Tools.md": `---
smType: equipment
name: "Tinker's Tools"
type: "tool"
cost: "50 GP"
weight: "10 lb."
tool_category: "Artisan"
ability: "Dexterity"
utilize: ["Assemble a Tiny item composed of scrap, which falls apart in 1 minute (DC 20)"]
craft: ["Musket", "Pistol", "Bell", "Bullseye Lantern", "Flask", "Hooded Lantern", "Hunting Trap", "Lock", "Manacles", "Mirror", "Shovel", "Signal Whistle", "Tinderbox"]
---

# Tinker's Tools
*Artisan Tool*

- **Cost:** 50 GP
- **Weight:** 10 lb.

**Ability:** Dexterity

## Utilize

- Assemble a Tiny item composed of scrap, which falls apart in 1 minute (DC 20)

## Craft

Musket, Pistol, Bell, Bullseye Lantern, Flask, Hooded Lantern, Hunting Trap, Lock, Manacles, Mirror, Shovel, Signal Whistle, Tinderbox
`,
      "Tools/Weaver-s-Tools.md": `---
smType: equipment
name: "Weaver's Tools"
type: "tool"
cost: "1 GP"
weight: "5 lb."
tool_category: "Artisan"
ability: "Dexterity"
utilize: ["Mend a tear in clothing (DC 10)", "sew a Tiny design (DC 10)"]
craft: ["Padded Armor", "Basket", "Bedroll", "Blanket", "Fine Clothes", "Net", "Robe", "Rope", "Sack", "String", "Tent", "Traveler's Clothes"]
---

# Weaver's Tools
*Artisan Tool*

- **Cost:** 1 GP
- **Weight:** 5 lb.

**Ability:** Dexterity

## Utilize

- Mend a tear in clothing (DC 10)
- sew a Tiny design (DC 10)

## Craft

Padded Armor, Basket, Bedroll, Blanket, Fine Clothes, Net, Robe, Rope, Sack, String, Tent, Traveler's Clothes
`,
      "Tools/Woodcarver-s-Tools.md": `---
smType: equipment
name: "Woodcarver's Tools"
type: "tool"
cost: "1 GP"
weight: "5 lb."
tool_category: "Artisan"
ability: "Dexterity"
utilize: ["Carve a pattern in wood (DC 10)"]
craft: ["Club", "Greatclub", "Quarterstaff", "Ranged weapons (except Pistol", "Musket", "and Sling)", "Arcane Focus", "Arrows", "Bolts", "Druidic Focus", "Ink Pen", "Needles"]
---

# Woodcarver's Tools
*Artisan Tool*

- **Cost:** 1 GP
- **Weight:** 5 lb.

**Ability:** Dexterity

## Utilize

- Carve a pattern in wood (DC 10)

## Craft

Club, Greatclub, Quarterstaff, Ranged weapons (except Pistol, Musket, and Sling), Arcane Focus, Arrows, Bolts, Druidic Focus, Ink Pen, Needles
`,
      "Weapons/Battleaxe.md": `---
smType: equipment
name: "Battleaxe"
type: "weapon"
cost: "10 GP"
weight: "4 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d8 Slashing"
properties: ["Versatile (1d10)"]
mastery: "Topple"
---

# Battleaxe
*Martial Melee Weapon*

- **Cost:** 10 GP
- **Weight:** 4 lb.

**Damage:** 1d8 Slashing

**Properties:** Versatile (1d10)

**Mastery:** Topple
`,
      "Weapons/Blowgun.md": `---
smType: equipment
name: "Blowgun"
type: "weapon"
cost: "10 GP"
weight: "1 lb."
weapon_category: "Martial"
weapon_type: "Ranged"
damage: "1 Piercing"
properties: ["Ammunition (Range 25/100; Needle)", "Loading"]
mastery: "Vex"
---

# Blowgun
*Martial Ranged Weapon*

- **Cost:** 10 GP
- **Weight:** 1 lb.

**Damage:** 1 Piercing

**Properties:** Ammunition (Range 25/100; Needle), Loading

**Mastery:** Vex
`,
      "Weapons/Club.md": `---
smType: equipment
name: "Club"
type: "weapon"
cost: "1 SP"
weight: "2 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d4 Bludgeoning"
properties: ["Light"]
mastery: "Slow"
---

# Club
*Simple Melee Weapon*

- **Cost:** 1 SP
- **Weight:** 2 lb.

**Damage:** 1d4 Bludgeoning

**Properties:** Light

**Mastery:** Slow
`,
      "Weapons/Dagger.md": `---
smType: equipment
name: "Dagger"
type: "weapon"
cost: "2 GP"
weight: "1 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d4 Piercing"
properties: ["Finesse", "Light", "Thrown (Range 20/60)"]
mastery: "Nick"
---

# Dagger
*Simple Melee Weapon*

- **Cost:** 2 GP
- **Weight:** 1 lb.

**Damage:** 1d4 Piercing

**Properties:** Finesse, Light, Thrown (Range 20/60)

**Mastery:** Nick
`,
      "Weapons/Dart.md": `---
smType: equipment
name: "Dart"
type: "weapon"
cost: "5 CP"
weight: "1/4 lb."
weapon_category: "Simple"
weapon_type: "Ranged"
damage: "1d4 Piercing"
properties: ["Finesse", "Thrown (Range 20/60)"]
mastery: "Vex"
---

# Dart
*Simple Ranged Weapon*

- **Cost:** 5 CP
- **Weight:** 1/4 lb.

**Damage:** 1d4 Piercing

**Properties:** Finesse, Thrown (Range 20/60)

**Mastery:** Vex
`,
      "Weapons/Flail.md": `---
smType: equipment
name: "Flail"
type: "weapon"
cost: "10 GP"
weight: "2 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d8 Bludgeoning"
mastery: "Sap"
---

# Flail
*Martial Melee Weapon*

- **Cost:** 10 GP
- **Weight:** 2 lb.

**Damage:** 1d8 Bludgeoning

**Mastery:** Sap
`,
      "Weapons/Glaive.md": `---
smType: equipment
name: "Glaive"
type: "weapon"
cost: "20 GP"
weight: "6 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d10 Slashing"
properties: ["Heavy", "Reach", "Two-Handed"]
mastery: "Graze"
---

# Glaive
*Martial Melee Weapon*

- **Cost:** 20 GP
- **Weight:** 6 lb.

**Damage:** 1d10 Slashing

**Properties:** Heavy, Reach, Two-Handed

**Mastery:** Graze
`,
      "Weapons/Greataxe.md": `---
smType: equipment
name: "Greataxe"
type: "weapon"
cost: "30 GP"
weight: "7 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d12 Slashing"
properties: ["Heavy", "Two-Handed"]
mastery: "Cleave"
---

# Greataxe
*Martial Melee Weapon*

- **Cost:** 30 GP
- **Weight:** 7 lb.

**Damage:** 1d12 Slashing

**Properties:** Heavy, Two-Handed

**Mastery:** Cleave
`,
      "Weapons/Greatclub.md": `---
smType: equipment
name: "Greatclub"
type: "weapon"
cost: "2 SP"
weight: "10 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d8 Bludgeoning"
properties: ["Two-Handed"]
mastery: "Push"
---

# Greatclub
*Simple Melee Weapon*

- **Cost:** 2 SP
- **Weight:** 10 lb.

**Damage:** 1d8 Bludgeoning

**Properties:** Two-Handed

**Mastery:** Push
`,
      "Weapons/Greatsword.md": `---
smType: equipment
name: "Greatsword"
type: "weapon"
cost: "50 GP"
weight: "6 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "2d6 Slashing"
properties: ["Heavy", "Two-Handed"]
mastery: "Graze"
---

# Greatsword
*Martial Melee Weapon*

- **Cost:** 50 GP
- **Weight:** 6 lb.

**Damage:** 2d6 Slashing

**Properties:** Heavy, Two-Handed

**Mastery:** Graze
`,
      "Weapons/Halberd.md": `---
smType: equipment
name: "Halberd"
type: "weapon"
cost: "20 GP"
weight: "6 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d10 Slashing"
properties: ["Heavy", "Reach", "Two-Handed"]
mastery: "Cleave"
---

# Halberd
*Martial Melee Weapon*

- **Cost:** 20 GP
- **Weight:** 6 lb.

**Damage:** 1d10 Slashing

**Properties:** Heavy, Reach, Two-Handed

**Mastery:** Cleave
`,
      "Weapons/Hand-Crossbow.md": `---
smType: equipment
name: "Hand Crossbow"
type: "weapon"
cost: "75 GP"
weight: "3 lb."
weapon_category: "Martial"
weapon_type: "Ranged"
damage: "1d6 Piercing"
properties: ["Ammunition (Range 30/120; Bolt)", "Light", "Loading"]
mastery: "Vex"
---

# Hand Crossbow
*Martial Ranged Weapon*

- **Cost:** 75 GP
- **Weight:** 3 lb.

**Damage:** 1d6 Piercing

**Properties:** Ammunition (Range 30/120; Bolt), Light, Loading

**Mastery:** Vex
`,
      "Weapons/Handaxe.md": `---
smType: equipment
name: "Handaxe"
type: "weapon"
cost: "5 GP"
weight: "2 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d6 Slashing"
properties: ["Light", "Thrown (Range 20/60)"]
mastery: "Vex"
---

# Handaxe
*Simple Melee Weapon*

- **Cost:** 5 GP
- **Weight:** 2 lb.

**Damage:** 1d6 Slashing

**Properties:** Light, Thrown (Range 20/60)

**Mastery:** Vex
`,
      "Weapons/Heavy-Crossbow.md": `---
smType: equipment
name: "Heavy Crossbow"
type: "weapon"
cost: "50 GP"
weight: "18 lb."
weapon_category: "Martial"
weapon_type: "Ranged"
damage: "1d10 Piercing"
properties: ["Ammunition (Range 100/400; Bolt)", "Heavy", "Loading", "Two-Handed"]
mastery: "Push"
---

# Heavy Crossbow
*Martial Ranged Weapon*

- **Cost:** 50 GP
- **Weight:** 18 lb.

**Damage:** 1d10 Piercing

**Properties:** Ammunition (Range 100/400; Bolt), Heavy, Loading, Two-Handed

**Mastery:** Push
`,
      "Weapons/Javelin.md": `---
smType: equipment
name: "Javelin"
type: "weapon"
cost: "5 SP"
weight: "2 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d6 Piercing"
properties: ["Thrown (Range 30/120)"]
mastery: "Slow"
---

# Javelin
*Simple Melee Weapon*

- **Cost:** 5 SP
- **Weight:** 2 lb.

**Damage:** 1d6 Piercing

**Properties:** Thrown (Range 30/120)

**Mastery:** Slow
`,
      "Weapons/Lance.md": `---
smType: equipment
name: "Lance"
type: "weapon"
cost: "10 GP"
weight: "6 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d10 Piercing"
properties: ["Heavy", "Reach", "Two-Handed (unless mounted)"]
mastery: "Topple"
---

# Lance
*Martial Melee Weapon*

- **Cost:** 10 GP
- **Weight:** 6 lb.

**Damage:** 1d10 Piercing

**Properties:** Heavy, Reach, Two-Handed (unless mounted)

**Mastery:** Topple
`,
      "Weapons/Light-Crossbow.md": `---
smType: equipment
name: "Light Crossbow"
type: "weapon"
cost: "25 GP"
weight: "5 lb."
weapon_category: "Simple"
weapon_type: "Ranged"
damage: "1d8 Piercing"
properties: ["Ammunition (Range 80/320; Bolt)", "Loading", "Two-Handed"]
mastery: "Slow"
---

# Light Crossbow
*Simple Ranged Weapon*

- **Cost:** 25 GP
- **Weight:** 5 lb.

**Damage:** 1d8 Piercing

**Properties:** Ammunition (Range 80/320; Bolt), Loading, Two-Handed

**Mastery:** Slow
`,
      "Weapons/Light-Hammer.md": `---
smType: equipment
name: "Light Hammer"
type: "weapon"
cost: "2 GP"
weight: "2 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d4 Bludgeoning"
properties: ["Light", "Thrown (Range 20/60)"]
mastery: "Nick"
---

# Light Hammer
*Simple Melee Weapon*

- **Cost:** 2 GP
- **Weight:** 2 lb.

**Damage:** 1d4 Bludgeoning

**Properties:** Light, Thrown (Range 20/60)

**Mastery:** Nick
`,
      "Weapons/Longbow.md": `---
smType: equipment
name: "Longbow"
type: "weapon"
cost: "50 GP"
weight: "2 lb."
weapon_category: "Martial"
weapon_type: "Ranged"
damage: "1d8 Piercing"
properties: ["Ammunition (Range 150/600; Arrow)", "Heavy", "Two-Handed"]
mastery: "Slow"
---

# Longbow
*Martial Ranged Weapon*

- **Cost:** 50 GP
- **Weight:** 2 lb.

**Damage:** 1d8 Piercing

**Properties:** Ammunition (Range 150/600; Arrow), Heavy, Two-Handed

**Mastery:** Slow
`,
      "Weapons/Longsword.md": `---
smType: equipment
name: "Longsword"
type: "weapon"
cost: "15 GP"
weight: "3 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d8 Slashing"
properties: ["Versatile (1d10)"]
mastery: "Sap"
---

# Longsword
*Martial Melee Weapon*

- **Cost:** 15 GP
- **Weight:** 3 lb.

**Damage:** 1d8 Slashing

**Properties:** Versatile (1d10)

**Mastery:** Sap
`,
      "Weapons/Mace.md": `---
smType: equipment
name: "Mace"
type: "weapon"
cost: "5 GP"
weight: "4 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d6 Bludgeoning"
mastery: "Sap"
---

# Mace
*Simple Melee Weapon*

- **Cost:** 5 GP
- **Weight:** 4 lb.

**Damage:** 1d6 Bludgeoning

**Mastery:** Sap
`,
      "Weapons/Maul.md": `---
smType: equipment
name: "Maul"
type: "weapon"
cost: "10 GP"
weight: "10 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "2d6 Bludgeoning"
properties: ["Heavy", "Two-Handed"]
mastery: "Topple"
---

# Maul
*Martial Melee Weapon*

- **Cost:** 10 GP
- **Weight:** 10 lb.

**Damage:** 2d6 Bludgeoning

**Properties:** Heavy, Two-Handed

**Mastery:** Topple
`,
      "Weapons/Morningstar.md": `---
smType: equipment
name: "Morningstar"
type: "weapon"
cost: "15 GP"
weight: "4 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d8 Piercing"
mastery: "Sap"
---

# Morningstar
*Martial Melee Weapon*

- **Cost:** 15 GP
- **Weight:** 4 lb.

**Damage:** 1d8 Piercing

**Mastery:** Sap
`,
      "Weapons/Musket.md": `---
smType: equipment
name: "Musket"
type: "weapon"
cost: "500 GP"
weight: "10 lb."
weapon_category: "Martial"
weapon_type: "Ranged"
damage: "1d12 Piercing"
properties: ["Ammunition (Range 40/120; Bullet)", "Loading", "Two-Handed"]
mastery: "Slow"
---

# Musket
*Martial Ranged Weapon*

- **Cost:** 500 GP
- **Weight:** 10 lb.

**Damage:** 1d12 Piercing

**Properties:** Ammunition (Range 40/120; Bullet), Loading, Two-Handed

**Mastery:** Slow
`,
      "Weapons/Pike.md": `---
smType: equipment
name: "Pike"
type: "weapon"
cost: "5 GP"
weight: "18 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d10 Piercing"
properties: ["Heavy", "Reach", "Two-Handed"]
mastery: "Push"
---

# Pike
*Martial Melee Weapon*

- **Cost:** 5 GP
- **Weight:** 18 lb.

**Damage:** 1d10 Piercing

**Properties:** Heavy, Reach, Two-Handed

**Mastery:** Push
`,
      "Weapons/Pistol.md": `---
smType: equipment
name: "Pistol"
type: "weapon"
cost: "250 GP"
weight: "3 lb."
weapon_category: "Martial"
weapon_type: "Ranged"
damage: "1d10 Piercing"
properties: ["Ammunition (Range 30/90; Bullet)", "Loading"]
mastery: "Vex"
---

# Pistol
*Martial Ranged Weapon*

- **Cost:** 250 GP
- **Weight:** 3 lb.

**Damage:** 1d10 Piercing

**Properties:** Ammunition (Range 30/90; Bullet), Loading

**Mastery:** Vex
`,
      "Weapons/Quarterstaff.md": `---
smType: equipment
name: "Quarterstaff"
type: "weapon"
cost: "2 SP"
weight: "4 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d6 Bludgeoning"
properties: ["Versatile (1d8)"]
mastery: "Topple"
---

# Quarterstaff
*Simple Melee Weapon*

- **Cost:** 2 SP
- **Weight:** 4 lb.

**Damage:** 1d6 Bludgeoning

**Properties:** Versatile (1d8)

**Mastery:** Topple
`,
      "Weapons/Rapier.md": `---
smType: equipment
name: "Rapier"
type: "weapon"
cost: "25 GP"
weight: "2 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d8 Piercing"
properties: ["Finesse"]
mastery: "Vex"
---

# Rapier
*Martial Melee Weapon*

- **Cost:** 25 GP
- **Weight:** 2 lb.

**Damage:** 1d8 Piercing

**Properties:** Finesse

**Mastery:** Vex
`,
      "Weapons/Scimitar.md": `---
smType: equipment
name: "Scimitar"
type: "weapon"
cost: "25 GP"
weight: "3 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d6 Slashing"
properties: ["Finesse", "Light"]
mastery: "Nick"
---

# Scimitar
*Martial Melee Weapon*

- **Cost:** 25 GP
- **Weight:** 3 lb.

**Damage:** 1d6 Slashing

**Properties:** Finesse, Light

**Mastery:** Nick
`,
      "Weapons/Shortbow.md": `---
smType: equipment
name: "Shortbow"
type: "weapon"
cost: "25 GP"
weight: "2 lb."
weapon_category: "Simple"
weapon_type: "Ranged"
damage: "1d6 Piercing"
properties: ["Ammunition (Range 80/320; Arrow)", "Two-Handed"]
mastery: "Vex"
---

# Shortbow
*Simple Ranged Weapon*

- **Cost:** 25 GP
- **Weight:** 2 lb.

**Damage:** 1d6 Piercing

**Properties:** Ammunition (Range 80/320; Arrow), Two-Handed

**Mastery:** Vex
`,
      "Weapons/Shortsword.md": `---
smType: equipment
name: "Shortsword"
type: "weapon"
cost: "10 GP"
weight: "2 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d6 Piercing"
properties: ["Finesse", "Light"]
mastery: "Vex"
---

# Shortsword
*Martial Melee Weapon*

- **Cost:** 10 GP
- **Weight:** 2 lb.

**Damage:** 1d6 Piercing

**Properties:** Finesse, Light

**Mastery:** Vex
`,
      "Weapons/Sickle.md": `---
smType: equipment
name: "Sickle"
type: "weapon"
cost: "1 GP"
weight: "2 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d4 Slashing"
properties: ["Light"]
mastery: "Nick"
---

# Sickle
*Simple Melee Weapon*

- **Cost:** 1 GP
- **Weight:** 2 lb.

**Damage:** 1d4 Slashing

**Properties:** Light

**Mastery:** Nick
`,
      "Weapons/Sling.md": `---
smType: equipment
name: "Sling"
type: "weapon"
cost: "1 SP"
weight: "\u2014"
weapon_category: "Simple"
weapon_type: "Ranged"
damage: "1d4 Bludgeoning"
properties: ["Ammunition (Range 30/120; Bullet)"]
mastery: "Slow"
---

# Sling
*Simple Ranged Weapon*

- **Cost:** 1 SP
- **Weight:** \u2014

**Damage:** 1d4 Bludgeoning

**Properties:** Ammunition (Range 30/120; Bullet)

**Mastery:** Slow
`,
      "Weapons/Spear.md": `---
smType: equipment
name: "Spear"
type: "weapon"
cost: "1 GP"
weight: "3 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d6 Piercing"
properties: ["Thrown (Range 20/60)", "Versatile (1d8)"]
mastery: "Sap"
---

# Spear
*Simple Melee Weapon*

- **Cost:** 1 GP
- **Weight:** 3 lb.

**Damage:** 1d6 Piercing

**Properties:** Thrown (Range 20/60), Versatile (1d8)

**Mastery:** Sap
`,
      "Weapons/Trident.md": `---
smType: equipment
name: "Trident"
type: "weapon"
cost: "5 GP"
weight: "4 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d8 Piercing"
properties: ["Thrown (Range 20/60)", "Versatile (1d10)"]
mastery: "Topple"
---

# Trident
*Martial Melee Weapon*

- **Cost:** 5 GP
- **Weight:** 4 lb.

**Damage:** 1d8 Piercing

**Properties:** Thrown (Range 20/60), Versatile (1d10)

**Mastery:** Topple
`,
      "Weapons/War-Pick.md": `---
smType: equipment
name: "War Pick"
type: "weapon"
cost: "5 GP"
weight: "2 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d8 Piercing"
properties: ["Versatile (1d10)"]
mastery: "Sap"
---

# War Pick
*Martial Melee Weapon*

- **Cost:** 5 GP
- **Weight:** 2 lb.

**Damage:** 1d8 Piercing

**Properties:** Versatile (1d10)

**Mastery:** Sap
`,
      "Weapons/Warhammer.md": `---
smType: equipment
name: "Warhammer"
type: "weapon"
cost: "15 GP"
weight: "5 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d8 Bludgeoning"
properties: ["Versatile (1d10)"]
mastery: "Push"
---

# Warhammer
*Martial Melee Weapon*

- **Cost:** 15 GP
- **Weight:** 5 lb.

**Damage:** 1d8 Bludgeoning

**Properties:** Versatile (1d10)

**Mastery:** Push
`,
      "Weapons/Whip.md": `---
smType: equipment
name: "Whip"
type: "weapon"
cost: "2 GP"
weight: "3 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d4 Slashing"
properties: ["Finesse", "Reach"]
mastery: "Slow"
---

# Whip
*Martial Melee Weapon*

- **Cost:** 2 GP
- **Weight:** 3 lb.

**Damage:** 1d4 Slashing

**Properties:** Finesse, Reach

**Mastery:** Slow
`
    };
    PRESET_TERRAINS = {
      "berg.md": `---
smType: terrain
name: "Berg"
color: "#6d4c41"
speed: 0.4
---

# Berg
Steile Berge sind sehr schwer zu durchqueren (40% Geschwindigkeit).
`,
      "meer.md": `---
smType: terrain
name: "Meer"
color: "#0288d1"
speed: 0.5
---

# Meer
Tiefes Wasser verlangsamt die Bewegung erheblich (50% Geschwindigkeit).
`,
      "transparent.md": `---
smType: terrain
name: ""
display_name: "(default)"
color: "transparent"
speed: 1.0
---

# Default Terrain
Transparent background, normal movement speed.
`,
      "wald.md": `---
smType: terrain
name: "Wald"
color: "#2e7d32"
speed: 0.6
---

# Wald
Dichter Wald verlangsamt die Bewegung (60% Geschwindigkeit).
`
    };
    PRESET_REGIONS = {
      "saltmarsh.md": `---
smType: region
name: "Saltmarsh"
terrain: "K\xFCste"
encounter_odds: 6
---

# Saltmarsh
K\xFCstenregion mit moderater Encounter-Rate (1/6).
`
    };
    PRESET_CALENDARS = {
      "Gregorian.md": `---
smType: calendar
id: "gregorian-standard"
name: "Gregorian Calendar"
description: "Standard Earth calendar with 12 months (24-hour days)"
daysPerWeek: 7
hoursPerDay: 24
minutesPerHour: 60
secondsPerMinute: 60
minuteStep: 15
months:
  - id: "jan"
    name: "January"
    length: 31
  - id: "feb"
    name: "February"
    length: 28
  - id: "mar"
    name: "March"
    length: 31
  - id: "apr"
    name: "April"
    length: 30
  - id: "may"
    name: "May"
    length: 31
  - id: "jun"
    name: "June"
    length: 30
  - id: "jul"
    name: "July"
    length: 31
  - id: "aug"
    name: "August"
    length: 31
  - id: "sep"
    name: "September"
    length: 30
  - id: "oct"
    name: "October"
    length: 31
  - id: "nov"
    name: "November"
    length: 30
  - id: "dec"
    name: "December"
    length: 31
epoch:
  year: 2024
  monthId: "jan"
  day: 1
schemaVersion: "1.0.0"
---

# Gregorian Calendar

The standard Earth calendar system used worldwide. Features 12 months with varying lengths totaling 365 days per year.

## Months

| Month | Days | Season |
|-------|------|--------|
| January | 31 | Winter |
| February | 28 | Winter |
| March | 31 | Spring |
| April | 30 | Spring |
| May | 31 | Spring |
| June | 30 | Summer |
| July | 31 | Summer |
| August | 31 | Summer |
| September | 30 | Autumn |
| October | 31 | Autumn |
| November | 30 | Autumn |
| December | 31 | Winter |

## Time Structure

- **Week**: 7 days (Monday through Sunday)
- **Day**: 24 hours
- **Hour**: 60 minutes
- **Minute**: 60 seconds

## Epoch

The epoch (reference point) for this calendar is set to **January 1, 2024**.

## Notes

This is a simplified version of the Gregorian calendar. Leap years are not currently implemented in this version.
`
    };
    PRESET_PLAYLISTS = {
      "Combat-Music.md": `---
name: Combat-Music
display_name: Combat Music
type: music
description: Intense battle music for combat encounters
terrain_tags: []
weather_tags: []
time_of_day_tags: []
faction_tags:
  - value: Hostile
situation_tags:
  - value: Combat
  - value: Chase
  - value: Tension
shuffle: true
loop: true
crossfade_duration: 1
default_volume: 0.7
tracks:
  - name: Battle Theme
    source: Audio/music/combat/battle-01.mp3
    duration: 180
    volume: 1.0
  - name: Fight or Flight
    source: Audio/music/combat/battle-02.mp3
    duration: 200
    volume: 0.9
  - name: Clash of Steel
    source: Audio/music/combat/battle-03.mp3
    duration: 190
    volume: 1.0
smType: playlist
---

# Combat Music

High-energy battle music that intensifies combat encounters and chase scenes.
`,
      "Dungeon-Ambience.md": `---
name: Dungeon-Ambience
display_name: Dungeon Ambience
type: ambience
description: Dripping water and distant echoes in underground chambers
terrain_tags:
  - value: Cave
  - value: Underground
  - value: Ruins
weather_tags: []
time_of_day_tags: []
situation_tags:
  - value: Exploration
  - value: Tension
  - value: Dungeon
shuffle: false
loop: true
crossfade_duration: 2
default_volume: 0.55
tracks:
  - name: Water Drips
    source: Audio/dungeon/drips.mp3
    duration: 200
    volume: 0.7
  - name: Stone Echoes
    source: Audio/dungeon/echoes.mp3
    duration: 240
    volume: 0.5
  - name: Distant Growls
    source: Audio/dungeon/growls.mp3
    duration: 180
    volume: 0.4
smType: playlist
---

# Dungeon Ambience

Dark, atmospheric dungeon sounds perfect for underground exploration and tense moments.
`,
      "Exploration-Music.md": `---
name: Exploration-Music
display_name: Exploration Music
type: music
description: Melodic background music for adventuring and discovery
terrain_tags:
  - value: Forest
  - value: Plains
  - value: Mountain
weather_tags:
  - value: Clear
  - value: Cloudy
time_of_day_tags:
  - value: Morning
  - value: Afternoon
  - value: Noon
situation_tags:
  - value: Exploration
  - value: Travel
shuffle: true
loop: true
crossfade_duration: 2
default_volume: 0.6
tracks:
  - name: Journey Begins
    source: Audio/music/exploration/explore-01.mp3
    duration: 220
    volume: 0.9
  - name: Over the Hills
    source: Audio/music/exploration/explore-02.mp3
    duration: 240
    volume: 0.85
  - name: Wanderer's Path
    source: Audio/music/exploration/explore-03.mp3
    duration: 210
    volume: 0.9
smType: playlist
---

# Exploration Music

Inspiring music for outdoor exploration and travel across varied terrain.
`,
      "Forest-Ambience.md": `---
name: Forest-Ambience
display_name: Forest Ambience
type: ambience
description: Peaceful forest sounds with birds and rustling leaves
terrain_tags:
  - value: Forest
  - value: Jungle
weather_tags:
  - value: Clear
  - value: Cloudy
situation_tags:
  - value: Exploration
  - value: Rest
shuffle: false
loop: true
crossfade_duration: 3
default_volume: 0.6
tracks:
  - name: Birds Chirping
    source: Audio/forest/birds.mp3
    duration: 180
    volume: 0.8
  - name: Wind Through Trees
    source: Audio/forest/wind.mp3
    duration: 240
    volume: 0.6
  - name: Creek Flowing
    source: Audio/forest/creek.mp3
    duration: 200
    volume: 0.7
smType: playlist
---

# Forest Ambience

Ambient forest sounds perfect for exploration and rest scenes in woodland environments.
`,
      "Mountain-Ambience.md": `---
name: Mountain-Ambience
display_name: Mountain Ambience
type: ambience
description: Wind and echoes across mountain peaks
terrain_tags:
  - value: Mountain
  - value: Hills
weather_tags:
  - value: Clear
  - value: Wind
  - value: Cold
situation_tags:
  - value: Exploration
  - value: Travel
shuffle: false
loop: true
crossfade_duration: 3
default_volume: 0.65
tracks:
  - name: Mountain Wind
    source: Audio/mountain/wind.mp3
    duration: 220
    volume: 0.75
  - name: Distant Eagle Cry
    source: Audio/mountain/eagle.mp3
    duration: 180
    volume: 0.5
  - name: Rock Echoes
    source: Audio/mountain/echoes.mp3
    duration: 190
    volume: 0.6
smType: playlist
---

# Mountain Ambience

Atmospheric mountain sounds with wind and distant wildlife, ideal for high-altitude exploration.
`,
      "Rest-Music.md": `---
name: Rest-Music
display_name: Rest Music
type: music
description: Calm, peaceful music for rest and social scenes
terrain_tags:
  - value: Urban
weather_tags: []
time_of_day_tags:
  - value: Evening
  - value: Night
faction_tags:
  - value: Friendly
  - value: Neutral
situation_tags:
  - value: Rest
  - value: Social
  - value: Celebration
shuffle: false
loop: true
crossfade_duration: 3
default_volume: 0.5
tracks:
  - name: Tavern Hearth
    source: Audio/music/rest/tavern-01.mp3
    duration: 180
    volume: 0.8
  - name: Peaceful Night
    source: Audio/music/rest/calm-01.mp3
    duration: 220
    volume: 0.7
  - name: Gentle Lullaby
    source: Audio/music/rest/lullaby-01.mp3
    duration: 200
    volume: 0.6
smType: playlist
---

# Rest Music

Soothing music for tavern scenes, camp rests, and friendly social interactions.
`
    };
  }
});

// Presets/lib/plugin-presets.ts
var plugin_presets_exports = {};
__export(plugin_presets_exports, {
  importCalendarPresets: () => importCalendarPresets,
  importEquipmentPresets: () => importEquipmentPresets,
  importItemPresets: () => importItemPresets,
  importPlaylistPresets: () => importPlaylistPresets,
  importPluginPresets: () => importPluginPresets,
  importPresetsByCategory: () => importPresetsByCategory,
  importRegionPresets: () => importRegionPresets,
  importSpellPresets: () => importSpellPresets,
  importTerrainPresets: () => importTerrainPresets,
  registerPreset: () => registerPreset,
  shouldImportCalendarPresets: () => shouldImportCalendarPresets,
  shouldImportEquipmentPresets: () => shouldImportEquipmentPresets,
  shouldImportItemPresets: () => shouldImportItemPresets,
  shouldImportPlaylistPresets: () => shouldImportPlaylistPresets,
  shouldImportPluginPresets: () => shouldImportPluginPresets,
  shouldImportRegionPresets: () => shouldImportRegionPresets,
  shouldImportSpellPresets: () => shouldImportSpellPresets,
  shouldImportTerrainPresets: () => shouldImportTerrainPresets
});
async function ensureDir2(app, dir) {
  const normalizedDir = (0, import_obsidian52.normalizePath)(dir);
  const folder = app.vault.getAbstractFileByPath(normalizedDir);
  if (!folder) {
    await app.vault.createFolder(normalizedDir).catch(() => {
    });
  }
}
function registerPreset(fileName, content) {
  PRESET_FILES[fileName] = content;
}
async function importPresetsForDir(app, dir, presetKey, typeName, ensureDir3, force = false) {
  try {
    await ensureDir3(app);
    const normalizedDir = (0, import_obsidian52.normalizePath)(dir);
    const presetModule = await Promise.resolve().then(() => (init_preset_data(), preset_data_exports));
    const rawPresetFiles = presetModule[presetKey] || {};
    const presetEntries = Object.entries(rawPresetFiles).map(([fileName, content]) => [
      normalizeRelativePath(fileName),
      content
    ]).filter(([fileName]) => !isOrganizationalPresetFile(fileName));
    const fileNames = presetEntries.map(([fileName]) => fileName);
    if (fileNames.length === 0) {
      logger2.log(`No preset ${typeName} found in plugin`);
      return;
    }
    logger2.log(`Found ${fileNames.length} preset ${typeName} in plugin`);
    const existingFiles = /* @__PURE__ */ new Map();
    try {
      const existing = await app.vault.adapter.list(normalizedDir);
      const prefix = `${normalizedDir}/`;
      existing.files.forEach((file) => {
        const normalizedFile = (0, import_obsidian52.normalizePath)(file);
        if (normalizedFile.startsWith(prefix)) {
          const relativePath = normalizedFile.slice(prefix.length);
          if (relativePath) {
            existingFiles.set(relativePath.toLowerCase(), normalizedFile);
          }
        }
      });
    } catch {
    }
    let importedCount = 0;
    let skippedCount = 0;
    let errorCount = 0;
    const ensuredFolders = /* @__PURE__ */ new Set([normalizedDir]);
    for (const [fileName, content] of presetEntries) {
      const loweredName = fileName.toLowerCase();
      const targetPath = (0, import_obsidian52.normalizePath)(`${normalizedDir}/${fileName}`);
      const existingPath = existingFiles.get(loweredName);
      try {
        await ensureParentFolders(app, normalizedDir, fileName, ensuredFolders);
        if (force && existingPath) {
          const existingFile = app.vault.getAbstractFileByPath(existingPath);
          if (existingFile) {
            await app.vault.delete(existingFile);
            logger2.log(`Deleted existing ${typeName} preset: ${existingPath}`);
          }
          await app.vault.adapter.write(targetPath, content);
          importedCount++;
          logger2.log(`Re-imported ${typeName} preset: ${fileName}`);
        } else if (existingPath) {
          skippedCount++;
        } else {
          await app.vault.create(targetPath, content);
          importedCount++;
          logger2.log(`Imported ${typeName} preset: ${fileName}`);
        }
      } catch (err) {
        logger2.error(`Failed to import ${typeName} preset ${fileName}:`, err);
        errorCount++;
      }
    }
    if (importedCount > 0) {
      new import_obsidian52.Notice(`Imported ${importedCount} ${typeName} presets`);
      logger2.log(`${typeName} import complete: ${importedCount} imported, ${skippedCount} skipped, ${errorCount} errors`);
    } else if (skippedCount > 0) {
      logger2.log(`All ${skippedCount} ${typeName} presets already exist`);
    } else if (errorCount > 0) {
      new import_obsidian52.Notice(`Failed to import ${typeName} presets. Check console for details.`);
    }
  } catch (err) {
    logger2.error(`Failed to import ${typeName} presets:`, err);
    if (err instanceof Error && err.message.includes("Cannot find module")) {
      logger2.log(`No ${typeName} preset data found - skipping import`);
    } else {
      new import_obsidian52.Notice(`Failed to import ${typeName} presets. Check console for details.`);
    }
  }
}
function normalizeRelativePath(fileName) {
  return fileName.replace(/\\/g, "/");
}
async function ensureParentFolders(app, baseDir, relativePath, ensured) {
  const parts = normalizeRelativePath(relativePath).split("/");
  parts.pop();
  let current = baseDir;
  for (const part of parts) {
    current = (0, import_obsidian52.normalizePath)(`${current}/${part}`);
    if (ensured.has(current)) continue;
    ensured.add(current);
    if (!app.vault.getAbstractFileByPath(current)) {
      await app.vault.createFolder(current).catch(() => {
      });
    }
  }
}
function isOrganizationalPresetFile(fileName) {
  const normalized = fileName.toLowerCase();
  return normalized === "agents.md" || normalized.endsWith("/agents.md");
}
async function importPluginPresets(app) {
  return importPresetsForDir(app, ENTITY_REGISTRY.creatures.directory, "PRESET_CREATURES", "creature", ensureCreatureDir2);
}
async function shouldImportPresetsForDir(app, dir, markerName, label, ensureDir3) {
  const markerPath = (0, import_obsidian52.normalizePath)(`${dir}/${markerName}`);
  const markerFile = app.vault.getAbstractFileByPath(markerPath);
  if (markerFile) {
    return false;
  }
  try {
    await ensureDir3(app);
    await app.vault.create(markerPath, `${label} imported on ${(/* @__PURE__ */ new Date()).toISOString()}`);
  } catch (err) {
    logger2.log(`${label} already imported (marker exists)`);
    return false;
  }
  return true;
}
async function shouldImportPluginPresets(app) {
  return shouldImportPresetsForDir(app, ENTITY_REGISTRY.creatures.directory, ".plugin-presets-imported", "Plugin presets", ensureCreatureDir2);
}
async function importSpellPresets(app) {
  return importPresetsForDir(app, ENTITY_REGISTRY.spells.directory, "PRESET_SPELLS", "spell", ensureSpellDir2);
}
async function shouldImportSpellPresets(app) {
  return shouldImportPresetsForDir(app, ENTITY_REGISTRY.spells.directory, ".plugin-spells-imported", "Spell presets", ensureSpellDir2);
}
async function importItemPresets(app) {
  return importPresetsForDir(app, ENTITY_REGISTRY.items.directory, "PRESET_ITEMS", "item", ensureItemDir2);
}
async function shouldImportItemPresets(app) {
  return shouldImportPresetsForDir(app, ENTITY_REGISTRY.items.directory, ".plugin-items-imported", "Item presets", ensureItemDir2);
}
async function importEquipmentPresets(app) {
  return importPresetsForDir(app, ENTITY_REGISTRY.equipment.directory, "PRESET_EQUIPMENT", "equipment", ensureEquipmentDir2);
}
async function shouldImportEquipmentPresets(app) {
  return shouldImportPresetsForDir(app, ENTITY_REGISTRY.equipment.directory, ".plugin-equipment-imported", "Equipment presets", ensureEquipmentDir2);
}
async function importTerrainPresets(app) {
  return importPresetsForDir(app, ENTITY_REGISTRY.terrains.directory, "PRESET_TERRAINS", "terrain", ensureTerrainDir);
}
async function shouldImportTerrainPresets(app) {
  return shouldImportPresetsForDir(app, ENTITY_REGISTRY.terrains.directory, ".plugin-terrains-imported", "Terrain presets", ensureTerrainDir);
}
async function importRegionPresets(app) {
  return importPresetsForDir(app, ENTITY_REGISTRY.regions.directory, "PRESET_REGIONS", "region", ensureRegionDir);
}
async function shouldImportRegionPresets(app) {
  return shouldImportPresetsForDir(app, ENTITY_REGISTRY.regions.directory, ".plugin-regions-imported", "Region presets", ensureRegionDir);
}
async function importCalendarPresets(app) {
  return importPresetsForDir(app, ENTITY_REGISTRY.calendars.directory, "PRESET_CALENDARS", "calendar", ensureCalendarDir2);
}
async function shouldImportCalendarPresets(app) {
  return shouldImportPresetsForDir(app, ENTITY_REGISTRY.calendars.directory, ".plugin-calendars-imported", "Calendar presets", ensureCalendarDir2);
}
async function importPlaylistPresets(app) {
  return importPresetsForDir(app, ENTITY_REGISTRY.playlists.directory, "PRESET_PLAYLISTS", "playlist", ensurePlaylistDir);
}
async function shouldImportPlaylistPresets(app) {
  return shouldImportPresetsForDir(app, ENTITY_REGISTRY.playlists.directory, ".plugin-playlists-imported", "Playlist presets", ensurePlaylistDir);
}
async function importPresetsByCategory(app, category, force = false) {
  const categoryLower = category.toLowerCase();
  switch (categoryLower) {
    case "creatures":
      await importPresetsForDir(app, ENTITY_REGISTRY.creatures.directory, "PRESET_CREATURES", "creature", ensureCreatureDir2, force);
      return { imported: 0, category: "creatures" };
    case "spells":
      await importPresetsForDir(app, ENTITY_REGISTRY.spells.directory, "PRESET_SPELLS", "spell", ensureSpellDir2, force);
      return { imported: 0, category: "spells" };
    case "items":
      await importPresetsForDir(app, ENTITY_REGISTRY.items.directory, "PRESET_ITEMS", "item", ensureItemDir2, force);
      return { imported: 0, category: "items" };
    case "equipment":
      await importPresetsForDir(app, ENTITY_REGISTRY.equipment.directory, "PRESET_EQUIPMENT", "equipment", ensureEquipmentDir2, force);
      return { imported: 0, category: "equipment" };
    case "terrains":
      await importPresetsForDir(app, ENTITY_REGISTRY.terrains.directory, "PRESET_TERRAINS", "terrain", ensureTerrainDir, force);
      return { imported: 0, category: "terrains" };
    case "regions":
      await importPresetsForDir(app, ENTITY_REGISTRY.regions.directory, "PRESET_REGIONS", "region", ensureRegionDir, force);
      return { imported: 0, category: "regions" };
    case "calendars":
      await importPresetsForDir(app, ENTITY_REGISTRY.calendars.directory, "PRESET_CALENDARS", "calendar", ensureCalendarDir2, force);
      return { imported: 0, category: "calendars" };
    case "playlists":
      await importPresetsForDir(app, ENTITY_REGISTRY.playlists.directory, "PRESET_PLAYLISTS", "playlist", ensurePlaylistDir, force);
      return { imported: 0, category: "playlists" };
    case "all":
      await importPresetsForDir(app, ENTITY_REGISTRY.creatures.directory, "PRESET_CREATURES", "creature", ensureCreatureDir2, force);
      await importPresetsForDir(app, ENTITY_REGISTRY.spells.directory, "PRESET_SPELLS", "spell", ensureSpellDir2, force);
      await importPresetsForDir(app, ENTITY_REGISTRY.items.directory, "PRESET_ITEMS", "item", ensureItemDir2, force);
      await importPresetsForDir(app, ENTITY_REGISTRY.equipment.directory, "PRESET_EQUIPMENT", "equipment", ensureEquipmentDir2, force);
      await importPresetsForDir(app, ENTITY_REGISTRY.terrains.directory, "PRESET_TERRAINS", "terrain", ensureTerrainDir, force);
      await importPresetsForDir(app, ENTITY_REGISTRY.regions.directory, "PRESET_REGIONS", "region", ensureRegionDir, force);
      await importPresetsForDir(app, ENTITY_REGISTRY.calendars.directory, "PRESET_CALENDARS", "calendar", ensureCalendarDir2, force);
      await importPresetsForDir(app, ENTITY_REGISTRY.playlists.directory, "PRESET_PLAYLISTS", "playlist", ensurePlaylistDir, force);
      return { imported: 0, category: "all" };
    default:
      throw new Error(`Unknown preset category: ${category}. Valid categories: creatures, spells, items, equipment, terrains, regions, calendars, playlists, all`);
  }
}
var import_obsidian52, ensureCreatureDir2, ensureSpellDir2, ensureItemDir2, ensureEquipmentDir2, ensureTerrainDir, ensureRegionDir, ensureCalendarDir2, ensurePlaylistDir, PRESET_FILES;
var init_plugin_presets = __esm({
  "Presets/lib/plugin-presets.ts"() {
    "use strict";
    import_obsidian52 = require("obsidian");
    init_entity_registry();
    init_plugin_logger();
    ensureCreatureDir2 = (app) => ensureDir2(app, ENTITY_REGISTRY.creatures.directory);
    ensureSpellDir2 = (app) => ensureDir2(app, ENTITY_REGISTRY.spells.directory);
    ensureItemDir2 = (app) => ensureDir2(app, ENTITY_REGISTRY.items.directory);
    ensureEquipmentDir2 = (app) => ensureDir2(app, ENTITY_REGISTRY.equipment.directory);
    ensureTerrainDir = (app) => ensureDir2(app, ENTITY_REGISTRY.terrains.directory);
    ensureRegionDir = (app) => ensureDir2(app, ENTITY_REGISTRY.regions.directory);
    ensureCalendarDir2 = (app) => ensureDir2(app, ENTITY_REGISTRY.calendars.directory);
    ensurePlaylistDir = (app) => ensureDir2(app, ENTITY_REGISTRY.playlists.directory);
    PRESET_FILES = {};
  }
});

// src/workmodes/library/core/index-files.ts
var index_files_exports = {};
__export(index_files_exports, {
  generateAllIndexes: () => generateAllIndexes,
  generateCalendarsIndex: () => generateCalendarsIndex,
  generateCreaturesIndex: () => generateCreaturesIndex,
  generateEquipmentIndex: () => generateEquipmentIndex,
  generateItemsIndex: () => generateItemsIndex,
  generateLibraryHub: () => generateLibraryHub,
  generateSpellsIndex: () => generateSpellsIndex
});
async function createIndexFile(app, filePath, title, description, directory) {
  const folder = app.vault.getAbstractFileByPath(directory);
  if (!(folder instanceof import_obsidian53.TFolder)) {
    logger2.log(`[Index] Directory ${directory} not found, skipping index generation`);
    return;
  }
  const files = [];
  const collectFiles = (folder2) => {
    for (const child of folder2.children) {
      if (child instanceof import_obsidian53.TFile && child.extension === "md") {
        files.push(child);
      } else if (child instanceof import_obsidian53.TFolder) {
        collectFiles(child);
      }
    }
  };
  collectFiles(folder);
  files.sort((a, b) => a.basename.localeCompare(b.basename));
  const lines = [];
  lines.push(`# ${title}`);
  lines.push("");
  lines.push(description);
  lines.push("");
  lines.push(`**Total:** ${files.length} entries`);
  lines.push("");
  const groups = /* @__PURE__ */ new Map();
  for (const file of files) {
    const relativePath = file.path.substring(directory.length + 1);
    const slashIndex = relativePath.indexOf("/");
    const group = slashIndex !== -1 ? relativePath.substring(0, slashIndex) : "Other";
    if (!groups.has(group)) {
      groups.set(group, []);
    }
    groups.get(group).push(file);
  }
  const sortedGroups = Array.from(groups.entries()).sort((a, b) => a[0].localeCompare(b[0]));
  for (const [groupName, groupFiles] of sortedGroups) {
    if (sortedGroups.length > 1 && groupName !== "Other") {
      lines.push(`## ${groupName}`);
      lines.push("");
    }
    for (const file of groupFiles) {
      lines.push(`- [[${file.basename}]]`);
    }
    lines.push("");
  }
  const content = lines.join("\n");
  const existingFile = app.vault.getAbstractFileByPath(filePath);
  if (existingFile instanceof import_obsidian53.TFile) {
    await app.vault.modify(existingFile, content);
  } else {
    await app.vault.create(filePath, content);
  }
}
async function generateCreaturesIndex(app) {
  await createIndexFile(
    app,
    `${SALTMARCHER_DIR}/Creatures.md`,
    "Creatures",
    "Index of all creatures in the library.",
    ENTITY_REGISTRY.creatures.directory
  );
}
async function generateEquipmentIndex(app) {
  await createIndexFile(
    app,
    `${SALTMARCHER_DIR}/Equipment.md`,
    "Equipment",
    "Index of all equipment in the library.",
    ENTITY_REGISTRY.equipment.directory
  );
}
async function generateSpellsIndex(app) {
  await createIndexFile(
    app,
    `${SALTMARCHER_DIR}/Spells.md`,
    "Spells",
    "Index of all spells in the library.",
    ENTITY_REGISTRY.spells.directory
  );
}
async function generateItemsIndex(app) {
  await createIndexFile(
    app,
    `${SALTMARCHER_DIR}/Items.md`,
    "Items",
    "Index of all magic items in the library.",
    ENTITY_REGISTRY.items.directory
  );
}
async function generateCalendarsIndex(app) {
  await createIndexFile(
    app,
    `${SALTMARCHER_DIR}/Calendars.md`,
    "Calendars",
    "Index of all calendars in the library.",
    ENTITY_REGISTRY.calendars.directory
  );
}
async function generateLibraryHub(app) {
  const lines = [];
  lines.push("# Library");
  lines.push("");
  lines.push("Central hub for all Salt Marcher library content.");
  lines.push("");
  lines.push("## Categories");
  lines.push("");
  lines.push("- [[Creatures]] - Monsters, animals, and NPCs");
  lines.push("- [[Equipment]] - Weapons, armor, tools, and adventuring gear");
  lines.push("- [[Spells]] - Spell compendium");
  lines.push("- [[Items]] - Magic items and artifacts");
  lines.push("- [[Calendars]] - Calendar systems and timekeeping");
  lines.push("");
  const content = lines.join("\n");
  const filePath = `${SALTMARCHER_DIR}/Library.md`;
  const existingFile = app.vault.getAbstractFileByPath(filePath);
  if (existingFile instanceof import_obsidian53.TFile) {
    await app.vault.modify(existingFile, content);
  } else {
    await app.vault.create(filePath, content);
  }
}
async function generateAllIndexes(app) {
  logger2.log("[Index] Generating all library indexes...");
  const saltmarcherFolder = app.vault.getAbstractFileByPath(SALTMARCHER_DIR);
  if (!saltmarcherFolder) {
    await app.vault.createFolder(SALTMARCHER_DIR);
  }
  await Promise.all([
    generateCreaturesIndex(app),
    generateEquipmentIndex(app),
    generateSpellsIndex(app),
    generateItemsIndex(app),
    generateCalendarsIndex(app),
    generateLibraryHub(app)
  ]);
  logger2.log("[Index] All indexes generated successfully");
}
var import_obsidian53, SALTMARCHER_DIR;
var init_index_files = __esm({
  "src/workmodes/library/core/index-files.ts"() {
    "use strict";
    import_obsidian53 = require("obsidian");
    init_entity_registry();
    init_plugin_logger();
    SALTMARCHER_DIR = "SaltMarcher";
  }
});

// devkit/validation/dom-utils.ts
function findAncestor(element, selector) {
  let current = element;
  while (current && current !== document.body) {
    if (current.matches(selector)) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function extractLabel(container, selector) {
  const element = container.querySelector(selector);
  return element?.textContent?.trim() || "unknown";
}
function isVisible(element) {
  return element.offsetParent !== null;
}
function getComputedStyles(element, properties) {
  const computed = window.getComputedStyle(element);
  const result = {};
  for (const prop of properties) {
    result[prop] = computed.getPropertyValue(prop);
  }
  return result;
}
function getDimensions(element) {
  const bbox = element.getBoundingClientRect();
  return {
    width: bbox.width,
    height: bbox.height,
    x: bbox.x,
    y: bbox.y
  };
}
function groupByAncestor(elements, ancestorSelector, labelSelector) {
  const groups = /* @__PURE__ */ new Map();
  for (const element of elements) {
    const ancestor = findAncestor(element, ancestorSelector);
    if (!ancestor) continue;
    const label = extractLabel(ancestor, labelSelector);
    if (!groups.has(label)) {
      groups.set(label, []);
    }
    groups.get(label).push(element);
  }
  return groups;
}
function waitForAnimation(duration = 600) {
  return new Promise((resolve) => setTimeout(resolve, duration));
}
var init_dom_utils = __esm({
  "devkit/validation/dom-utils.ts"() {
    "use strict";
  }
});

// devkit/validation/measurement-api.ts
function measureElements(options) {
  const {
    selector,
    dimensions,
    filter = isVisible,
    root = document
  } = options;
  const elements = Array.from(root.querySelectorAll(selector)).filter(filter);
  return elements.map((element) => {
    const bbox = getDimensions(element);
    const computed = getComputedStyles(element, dimensions);
    const result = {
      element,
      dimensions: {},
      styles: computed
    };
    for (const dim of dimensions) {
      if (dim === "width") result.dimensions.width = bbox.width;
      else if (dim === "height") result.dimensions.height = bbox.height;
      else if (computed[dim]) {
        const value = parseFloat(computed[dim]);
        if (!isNaN(value)) result.dimensions[dim] = value;
      }
    }
    return result;
  });
}
function measureElementsGrouped(options) {
  if (!options.groupBy) {
    throw new Error("groupBy option required for grouped measurements");
  }
  const { groupBy } = options;
  const measurements = measureElements(options);
  const elements = measurements.map((m) => m.element);
  const groups = groupByAncestor(elements, groupBy.ancestorSelector, groupBy.extractLabel);
  const results = [];
  for (const [groupLabel, groupElements] of groups.entries()) {
    const groupMeasurements = measurements.filter((m) => groupElements.includes(m.element));
    groupMeasurements.forEach((m) => {
      m.group = groupLabel;
    });
    const summary = {
      count: groupMeasurements.length,
      dimensions: {}
    };
    for (const dim of options.dimensions) {
      const values = groupMeasurements.map((m) => m.dimensions[dim]).filter((v) => v !== void 0);
      if (values.length > 0) {
        const min = Math.min(...values);
        const max = Math.max(...values);
        const avg = values.reduce((a, b) => a + b, 0) / values.length;
        const variance = max - min;
        summary.dimensions[dim] = { min, max, avg, variance };
      }
    }
    results.push({
      group: groupLabel,
      measurements: groupMeasurements,
      summary
    });
  }
  return results;
}
var init_measurement_api = __esm({
  "devkit/validation/measurement-api.ts"() {
    "use strict";
    init_dom_utils();
  }
});

// devkit/validation/validation-engine.ts
function validateRule(rule) {
  try {
    const measureOptions = {
      selector: rule.selector,
      dimensions: [rule.dimension],
      groupBy: rule.groupBy,
      filter: rule.filter,
      root: rule.root
    };
    if (rule.groupBy && rule.expect === "synchronized") {
      return validateSynchronizedGroups(rule, measureOptions);
    } else {
      return validateGlobalRule(rule, measureOptions);
    }
  } catch (error) {
    return {
      rule,
      passed: false,
      message: `Validation error: ${error}`
    };
  }
}
function validateSynchronizedGroups(rule, options) {
  const groups = measureElementsGrouped(options);
  const tolerance = rule.tolerance ?? 1;
  const failedGroups = [];
  for (const group of groups) {
    const summary = group.summary.dimensions[rule.dimension];
    if (!summary) continue;
    if (summary.variance > tolerance) {
      failedGroups.push({
        group: group.group,
        variance: summary.variance
      });
    }
  }
  const passed = failedGroups.length === 0;
  return {
    rule,
    passed,
    message: passed ? `All groups have synchronized ${rule.dimension} (tolerance: ${tolerance}px)` : `${failedGroups.length} group(s) failed synchronization`,
    details: {
      groups: groups.map((g) => ({
        group: g.group,
        count: g.summary.count,
        ...g.summary.dimensions[rule.dimension]
      })),
      failedGroups
    }
  };
}
function validateGlobalRule(rule, options) {
  const measurements = measureElements(options);
  if (measurements.length === 0) {
    return {
      rule,
      passed: false,
      message: `No elements found matching selector: ${rule.selector}`
    };
  }
  const values = measurements.map((m) => m.dimensions[rule.dimension]).filter((v) => v !== void 0);
  switch (rule.expect) {
    case "synchronized": {
      const tolerance = rule.tolerance ?? 1;
      const min = Math.min(...values);
      const max = Math.max(...values);
      const variance = max - min;
      const passed = variance <= tolerance;
      return {
        rule,
        passed,
        message: passed ? `All ${values.length} elements have synchronized ${rule.dimension} (variance: ${variance.toFixed(2)}px, tolerance: ${tolerance}px)` : `Elements not synchronized (variance: ${variance.toFixed(2)}px, tolerance: ${tolerance}px)`,
        details: { min, max, variance, count: values.length }
      };
    }
    case "exact": {
      if (rule.value === void 0) {
        return { rule, passed: false, message: "Exact validation requires value parameter" };
      }
      const tolerance = rule.tolerance ?? 0;
      const failed = values.filter((v) => Math.abs(v - rule.value) > tolerance);
      const passed = failed.length === 0;
      return {
        rule,
        passed,
        message: passed ? `All ${values.length} elements have ${rule.dimension} = ${rule.value}px (tolerance: ${tolerance}px)` : `${failed.length} element(s) don't match expected value ${rule.value}px`,
        details: { expected: rule.value, failedCount: failed.length, totalCount: values.length }
      };
    }
    case "min": {
      if (rule.value === void 0) {
        return { rule, passed: false, message: "Min validation requires value parameter" };
      }
      const failed = values.filter((v) => v < rule.value);
      const passed = failed.length === 0;
      return {
        rule,
        passed,
        message: passed ? `All ${values.length} elements have ${rule.dimension} >= ${rule.value}px` : `${failed.length} element(s) below minimum ${rule.value}px`,
        details: { min: rule.value, failedCount: failed.length, totalCount: values.length }
      };
    }
    case "max": {
      if (rule.value === void 0) {
        return { rule, passed: false, message: "Max validation requires value parameter" };
      }
      const failed = values.filter((v) => v > rule.value);
      const passed = failed.length === 0;
      return {
        rule,
        passed,
        message: passed ? `All ${values.length} elements have ${rule.dimension} <= ${rule.value}px` : `${failed.length} element(s) above maximum ${rule.value}px`,
        details: { max: rule.value, failedCount: failed.length, totalCount: values.length }
      };
    }
    case "range": {
      if (rule.value === void 0 || rule.maxValue === void 0) {
        return { rule, passed: false, message: "Range validation requires value and maxValue parameters" };
      }
      const failed = values.filter((v) => v < rule.value || v > rule.maxValue);
      const passed = failed.length === 0;
      return {
        rule,
        passed,
        message: passed ? `All ${values.length} elements have ${rule.dimension} in range [${rule.value}, ${rule.maxValue}]px` : `${failed.length} element(s) outside range [${rule.value}, ${rule.maxValue}]px`,
        details: { min: rule.value, max: rule.maxValue, failedCount: failed.length, totalCount: values.length }
      };
    }
    default:
      return {
        rule,
        passed: false,
        message: `Unknown expectation type: ${rule.expect}`
      };
  }
}
function validateUI(rules) {
  const results = rules.map(validateRule);
  const passedRules = results.filter((r) => r.passed).length;
  const failedRules = results.filter((r) => !r.passed).length;
  return {
    totalRules: rules.length,
    passedRules,
    failedRules,
    results
  };
}
function formatReport(report) {
  const lines = [];
  lines.push(`
=== UI Validation Report ===`);
  lines.push(`Total Rules: ${report.totalRules}`);
  lines.push(`Passed: ${report.passedRules}`);
  lines.push(`Failed: ${report.failedRules}`);
  lines.push("");
  for (const result of report.results) {
    const icon = result.passed ? "\u2713" : "\u2717";
    lines.push(`${icon} ${result.rule.name}`);
    lines.push(`  ${result.message}`);
    if (result.details && !result.passed) {
      lines.push(`  Details: ${JSON.stringify(result.details, null, 2)}`);
    }
    lines.push("");
  }
  return lines.join("\n");
}
var init_validation_engine = __esm({
  "devkit/validation/validation-engine.ts"() {
    "use strict";
    init_measurement_api();
  }
});

// devkit/core/ipc/commands/dev-commands.ts
var validateGridLayout, debugStepperStyles, validateUILegacy, navigateToSection, measureUI, validateUIWithRules, validateUIWithConfig, clickElement, setInputValue, addTokenToField, toggleRepeatingCheckbox, getRepeatingEntryValues;
var init_dev_commands = __esm({
  "devkit/core/ipc/commands/dev-commands.ts"() {
    "use strict";
    init_plugin_logger();
    init_measurement_api();
    init_validation_engine();
    init_dom_utils();
    validateGridLayout = async (app, args) => {
      logger2.log("[IPC-CMD] Validating grid layout...");
      const modal = document.querySelector(".sm-cc-create-modal");
      if (!modal) {
        return { success: false, error: "No modal found" };
      }
      const tagEditors = modal.querySelectorAll(".sm-cc-setting--token-editor, .sm-cc-setting--structured-token-editor");
      const results = [];
      tagEditors.forEach((editor, index) => {
        const computed = window.getComputedStyle(editor);
        const label = editor.querySelector(".setting-item-info");
        const control = editor.querySelector(".setting-item-control");
        const chips = editor.querySelector(".sm-cc-chips");
        const validation = {
          index,
          fieldLabel: label?.textContent?.trim() || "unknown",
          isGrid: computed.display === "grid",
          gridTemplateColumns: computed.gridTemplateColumns,
          gridTemplateRows: computed.gridTemplateRows,
          gap: computed.gap,
          children: {
            hasLabel: !!label,
            hasControl: !!control,
            hasChips: !!chips
          },
          gridPositions: {}
        };
        if (label) {
          const labelComputed = window.getComputedStyle(label);
          validation.gridPositions.label = {
            row: labelComputed.gridRow,
            column: labelComputed.gridColumn
          };
        }
        if (control) {
          const controlComputed = window.getComputedStyle(control);
          validation.gridPositions.control = {
            row: controlComputed.gridRow,
            column: controlComputed.gridColumn
          };
        }
        if (chips) {
          const chipsComputed = window.getComputedStyle(chips);
          validation.gridPositions.chips = {
            row: chipsComputed.gridRow,
            column: chipsComputed.gridColumn
          };
        }
        const hasTwoColumns = validation.gridTemplateColumns.split(" ").length === 2;
        const hasTwoRows = validation.gridTemplateRows.split(" ").length === 2;
        validation.valid = validation.isGrid && hasTwoColumns && hasTwoRows && validation.gridPositions.label?.row === "1" && validation.gridPositions.label?.column === "1" && validation.gridPositions.control?.row === "1" && validation.gridPositions.control?.column === "2" && validation.gridPositions.chips?.row === "2" && validation.gridPositions.chips?.column === "2";
        results.push(validation);
      });
      logger2.log("[IPC-CMD] Grid validation complete:", JSON.stringify(results, null, 2));
      return {
        success: true,
        totalEditors: results.length,
        validEditors: results.filter((r) => r.valid).length,
        invalidEditors: results.filter((r) => !r.valid).length,
        results
      };
    };
    debugStepperStyles = async (app, args) => {
      logger2.log("[IPC-CMD] Debugging stepper styles...");
      const modal = document.querySelector(".sm-cc-create-modal");
      if (!modal) {
        return { success: false, error: "No modal found" };
      }
      const stepper = modal.querySelector('.sm-inline-number input[type="number"]');
      if (!stepper) {
        return { success: false, error: "No stepper found" };
      }
      const computed = window.getComputedStyle(stepper);
      const bbox = stepper.getBoundingClientRect();
      return {
        success: true,
        value: stepper.value,
        styles: {
          width: computed.width,
          minWidth: computed.minWidth,
          maxWidth: computed.maxWidth,
          padding: computed.padding,
          paddingLeft: computed.paddingLeft,
          paddingRight: computed.paddingRight,
          border: computed.border,
          borderWidth: computed.borderWidth,
          fontSize: computed.fontSize,
          fontFamily: computed.fontFamily,
          letterSpacing: computed.letterSpacing,
          boxSizing: computed.boxSizing
        },
        boundingBox: {
          width: bbox.width,
          height: bbox.height
        }
      };
    };
    validateUILegacy = async (app, args) => {
      const [mode] = args;
      logger2.log("[IPC-CMD] Validating UI layout (legacy)...", mode || "all");
      const modal = document.querySelector(".sm-cc-create-modal");
      if (!modal) {
        return { success: false, error: "No modal found" };
      }
      const result = { success: true };
      if (!mode || mode === "all" || mode === "labels") {
        const labels = Array.from(modal.querySelectorAll(".setting-item-info")).filter((label) => label.offsetParent);
        if (labels.length > 0) {
          const labelsBySection = /* @__PURE__ */ new Map();
          labels.forEach((label) => {
            let element = label;
            let sectionTitle = "unknown";
            while (element && element !== modal) {
              if (element.classList.contains("sm-cc-card")) {
                const titleEl = element.querySelector(".sm-cc-card__title");
                if (titleEl) sectionTitle = titleEl.textContent?.trim() || "unknown";
                break;
              }
              element = element.parentElement;
            }
            const width = label.getBoundingClientRect().width;
            const minWidth = window.getComputedStyle(label).minWidth;
            const labelText = label.textContent?.trim() || "unknown";
            if (!labelsBySection.has(sectionTitle)) {
              labelsBySection.set(sectionTitle, []);
            }
            labelsBySection.get(sectionTitle).push({ label: labelText, width, minWidth });
          });
          const sections = [];
          for (const [section, sectionLabels] of labelsBySection.entries()) {
            const widths = sectionLabels.map((l) => l.width);
            const maxWidth = Math.max(...widths);
            const minWidth = Math.min(...widths);
            const widthVariance = maxWidth - minWidth;
            const synchronized = widthVariance <= 1;
            sections.push({
              section,
              labelCount: sectionLabels.length,
              synchronized,
              maxWidth,
              minWidth,
              widthVariance,
              labels: sectionLabels
            });
          }
          result.labels = {
            sections,
            summary: {
              totalSections: sections.length,
              synchronizedSections: sections.filter((r) => r.synchronized).length,
              unsynchronizedSections: sections.filter((r) => !r.synchronized).length
            }
          };
        }
      }
      if (!mode || mode === "all" || mode === "steppers") {
        const steppers = Array.from(modal.querySelectorAll(".sm-inline-number")).filter((stepper) => stepper.offsetParent);
        if (steppers.length > 0) {
          const stepperResults = [];
          steppers.forEach((stepper, index) => {
            const input = stepper.querySelector('input[type="number"]');
            if (!input) return;
            const width = input.getBoundingClientRect().width;
            const computedWidth = window.getComputedStyle(input).width;
            const value = input.value;
            const min = input.min;
            const max = input.max;
            const mirror = stepper.querySelector(".sm-cc-number-stepper__mirror");
            let expectedWidth = 0;
            if (mirror && max) {
              mirror.textContent = max;
              expectedWidth = mirror.getBoundingClientRect().width + 8;
            }
            let label = "unknown";
            let element = stepper;
            while (element) {
              const setting = element.closest(".setting-item");
              if (setting) {
                const labelEl = setting.querySelector(".setting-item-info");
                if (labelEl) label = labelEl.textContent?.trim() || "unknown";
                break;
              }
              element = element.parentElement;
            }
            stepperResults.push({
              index,
              label,
              value,
              min,
              max,
              actualWidth: width,
              computedWidth,
              expectedWidth,
              widthMatch: expectedWidth > 0 ? Math.abs(width - expectedWidth) < 2 : void 0
            });
          });
          result.steppers = {
            items: stepperResults,
            summary: {
              totalSteppers: stepperResults.length,
              correctlySized: stepperResults.filter((r) => r.widthMatch === true).length,
              incorrectlySized: stepperResults.filter((r) => r.widthMatch === false).length
            }
          };
        }
      }
      logger2.log("[IPC-CMD] UI validation complete:", JSON.stringify(result, null, 2));
      return result;
    };
    navigateToSection = async (app, args) => {
      const [sectionId] = args;
      if (!sectionId) throw new Error("Section ID required");
      logger2.log("[IPC-CMD] Navigating to section:", sectionId);
      const modal = document.querySelector(".sm-cc-create-modal");
      if (!modal) {
        return { success: false, error: "No modal found" };
      }
      const sidebar = modal.querySelector(".sm-cc-shell__nav");
      if (!sidebar) {
        return { success: false, error: "No navigation sidebar found" };
      }
      const buttons = sidebar.querySelectorAll(".sm-cc-shell__nav-button");
      let targetButton = null;
      buttons.forEach((button) => {
        const buttonText = button.textContent?.trim().toUpperCase();
        const sectionName = sectionId.trim().toUpperCase();
        if (buttonText === sectionName) {
          targetButton = button;
        }
      });
      if (!targetButton) {
        const availableSections = Array.from(buttons).map((b) => b.textContent?.trim());
        return {
          success: false,
          error: `Section "${sectionId}" not found`,
          availableSections
        };
      }
      targetButton.click();
      await waitForAnimation(600);
      logger2.log("[IPC-CMD] Navigated to section:", sectionId);
      return {
        success: true,
        section: sectionId
      };
    };
    measureUI = async (app, args) => {
      const [selector, ...dimensions] = args;
      if (!selector) {
        return { success: false, error: "Selector required. Usage: measure-ui <selector> [dimension1] [dimension2] ..." };
      }
      const dims = dimensions.length > 0 ? dimensions : ["width", "height"];
      logger2.log("[IPC-CMD] Measuring UI elements:", { selector, dimensions: dims });
      try {
        const measurements = measureElements({
          selector,
          dimensions: dims
        });
        if (measurements.length === 0) {
          return { success: false, error: `No elements found matching selector: ${selector}` };
        }
        const summary = {
          count: measurements.length
        };
        for (const dim of dims) {
          const values = measurements.map((m) => m.dimensions[dim]).filter((v) => v !== void 0);
          if (values.length > 0) {
            summary[dim] = {
              min: Math.min(...values),
              max: Math.max(...values),
              avg: (values.reduce((a, b) => a + b, 0) / values.length).toFixed(2),
              variance: (Math.max(...values) - Math.min(...values)).toFixed(2)
            };
          }
        }
        return {
          success: true,
          selector,
          dimensions: dims,
          summary,
          measurements: measurements.map((m) => ({
            dimensions: m.dimensions,
            styles: m.styles
          }))
        };
      } catch (error) {
        logger2.error("[IPC-CMD] Measurement failed:", error);
        return { success: false, error: String(error) };
      }
    };
    validateUIWithRules = async (app, args) => {
      const rulesJson = args.join(" ");
      if (!rulesJson) {
        return {
          success: false,
          error: `Rules required. Usage: validate-ui-rule '[{"name":"...", "selector":"...", ...}]'`
        };
      }
      logger2.log("[IPC-CMD] Validating UI with rules...");
      try {
        const rules = JSON.parse(rulesJson);
        const report = validateUI(rules);
        const formatted = formatReport(report);
        logger2.log("[IPC-CMD] Validation complete:", formatted);
        return {
          success: report.failedRules === 0,
          report,
          formatted
        };
      } catch (error) {
        logger2.error("[IPC-CMD] Validation failed:", error);
        return { success: false, error: String(error) };
      }
    };
    validateUIWithConfig = async (app, args) => {
      const [configName] = args;
      if (!configName) {
        return {
          success: false,
          error: "Config name required. Usage: validate-ui-config <config-name>"
        };
      }
      logger2.log("[IPC-CMD] Validating UI with config:", configName);
      try {
        const configs = {
          "create-modal-labels": [
            {
              name: "Single-column label synchronization",
              selector: ".sm-cc-card:not(.sm-cc-card--multi-column) .setting-item-info",
              groupBy: {
                ancestorSelector: ".sm-cc-card",
                extractLabel: ".sm-cc-card__title"
              },
              dimension: "width",
              expect: "synchronized",
              tolerance: 1
            }
          ],
          "create-modal-steppers": [
            {
              name: "Number stepper minimum width",
              selector: '.sm-inline-number input[type="number"]',
              dimension: "width",
              expect: "min",
              value: 30
            }
          ]
        };
        const rules = configs[configName];
        if (!rules) {
          return {
            success: false,
            error: `Config not found: ${configName}. Available: ${Object.keys(configs).join(", ")}`
          };
        }
        const report = validateUI(rules);
        const formatted = formatReport(report);
        logger2.log("[IPC-CMD] Validation complete:", formatted);
        return {
          success: report.failedRules === 0,
          config: configName,
          report,
          formatted
        };
      } catch (error) {
        logger2.error("[IPC-CMD] Validation failed:", error);
        return { success: false, error: String(error) };
      }
    };
    clickElement = async (app, args) => {
      const [selector, waitTimeStr] = args;
      if (!selector) {
        return {
          success: false,
          error: "Selector required. Usage: click-element <selector> [wait-ms]"
        };
      }
      const waitTime = waitTimeStr ? parseInt(waitTimeStr, 10) : 300;
      logger2.log("[IPC-CMD] Clicking element:", selector);
      const element = document.querySelector(selector);
      if (!element) {
        return {
          success: false,
          error: `Element not found: ${selector}`
        };
      }
      try {
        if (element instanceof HTMLElement) {
          element.click();
          element.focus();
        }
        await waitForAnimation(waitTime);
        logger2.log("[IPC-CMD] Element clicked:", selector);
        return {
          success: true,
          selector,
          element: {
            tagName: element.tagName,
            classList: Array.from(element.classList)
          }
        };
      } catch (error) {
        logger2.error("[IPC-CMD] Click failed:", error);
        return { success: false, error: String(error) };
      }
    };
    setInputValue = async (app, args) => {
      const [selector, value] = args;
      if (!selector || value === void 0) {
        return {
          success: false,
          error: "Selector and value required. Usage: set-input-value <selector> <value>"
        };
      }
      logger2.log("[IPC-CMD] Setting input value:", { selector, value });
      const element = document.querySelector(selector);
      if (!element) {
        return {
          success: false,
          error: `Element not found: ${selector}`
        };
      }
      if (!(element instanceof HTMLInputElement) && !(element instanceof HTMLTextAreaElement)) {
        return {
          success: false,
          error: `Element is not an input or textarea: ${selector}`
        };
      }
      try {
        element.value = value;
        element.dispatchEvent(new Event("input", { bubbles: true }));
        element.dispatchEvent(new Event("change", { bubbles: true }));
        logger2.log("[IPC-CMD] Input value set:", { selector, value });
        return {
          success: true,
          selector,
          value
        };
      } catch (error) {
        logger2.error("[IPC-CMD] Set input value failed:", error);
        return { success: false, error: String(error) };
      }
    };
    addTokenToField = async (app, args) => {
      const [fieldLabel, tokenValue] = args;
      if (!fieldLabel || !tokenValue) {
        return {
          success: false,
          error: "Field label and token value required. Usage: add-token <field-label> <token-value>"
        };
      }
      logger2.log("[IPC-CMD] Adding token to field:", { fieldLabel, tokenValue });
      const modal = document.querySelector(".sm-cc-create-modal");
      if (!modal) {
        return { success: false, error: "No modal found" };
      }
      const settings = modal.querySelectorAll(".sm-cc-setting--token-editor");
      let targetSetting = null;
      for (const setting of settings) {
        const label = setting.querySelector(".setting-item-info");
        if (label && label.textContent?.trim() === fieldLabel) {
          targetSetting = setting;
          break;
        }
      }
      if (!targetSetting) {
        const availableLabels = Array.from(settings).map(
          (s) => s.querySelector(".setting-item-info")?.textContent?.trim()
        );
        return {
          success: false,
          error: `Field not found: "${fieldLabel}"`,
          availableFields: availableLabels
        };
      }
      try {
        const input = targetSetting.querySelector("input.sm-cc-token-field__input-el");
        const button = targetSetting.querySelector("button.mod-cta");
        if (!input || !button) {
          return {
            success: false,
            error: "Input or button not found in target field"
          };
        }
        input.value = tokenValue;
        input.dispatchEvent(new Event("input", { bubbles: true }));
        input.dispatchEvent(new Event("change", { bubbles: true }));
        await waitForAnimation(100);
        button.click();
        await waitForAnimation(300);
        logger2.log("[IPC-CMD] Token added successfully:", { fieldLabel, tokenValue });
        return {
          success: true,
          fieldLabel,
          tokenValue
        };
      } catch (error) {
        logger2.error("[IPC-CMD] Add token failed:", error);
        return { success: false, error: String(error) };
      }
    };
    toggleRepeatingCheckbox = async (app, args) => {
      const [abilityKey] = args;
      if (!abilityKey) {
        return {
          success: false,
          error: 'Ability key required. Usage: toggle-save-checkbox <ability-key> (e.g., "str", "dex")'
        };
      }
      logger2.log("[IPC-CMD] Toggling save checkbox for ability:", abilityKey);
      const modal = document.querySelector(".sm-cc-create-modal");
      if (!modal) {
        return { success: false, error: "No modal found" };
      }
      const repeatingField = modal.querySelector(".sm-cc-repeating-list");
      if (!repeatingField) {
        return { success: false, error: "No repeating field found" };
      }
      const entries = repeatingField.querySelectorAll(".sm-cc-repeating-item");
      let targetEntry = null;
      for (const entry of entries) {
        const heading = entry.querySelector(".sm-cc-field-heading");
        if (heading && heading.textContent?.trim().toUpperCase() === abilityKey.toUpperCase()) {
          targetEntry = entry;
          break;
        }
      }
      if (!targetEntry) {
        const availableKeys = Array.from(entries).map(
          (e) => e.querySelector(".sm-cc-field--heading")?.textContent?.trim()
        );
        return {
          success: false,
          error: `Ability not found: "${abilityKey}"`,
          availableAbilities: availableKeys
        };
      }
      try {
        const checkbox = targetEntry.querySelector('input[type="checkbox"]');
        if (!checkbox) {
          return {
            success: false,
            error: `Checkbox not found in entry for ability: ${abilityKey}`
          };
        }
        const wasChecked = checkbox.checked;
        checkbox.click();
        await waitForAnimation(300);
        logger2.log("[IPC-CMD] Checkbox toggled:", { abilityKey, wasChecked, nowChecked: checkbox.checked });
        return {
          success: true,
          abilityKey: abilityKey.toUpperCase(),
          wasChecked,
          nowChecked: checkbox.checked
        };
      } catch (error) {
        logger2.error("[IPC-CMD] Toggle checkbox failed:", error);
        return { success: false, error: String(error) };
      }
    };
    getRepeatingEntryValues = async (app, args) => {
      const [abilityKey] = args;
      if (!abilityKey) {
        return {
          success: false,
          error: 'Ability key required. Usage: get-ability-values <ability-key> (e.g., "str", "dex")'
        };
      }
      logger2.log("[IPC-CMD] Getting values for ability:", abilityKey);
      const modal = document.querySelector(".sm-cc-create-modal");
      if (!modal) {
        return { success: false, error: "No modal found" };
      }
      const repeatingField = modal.querySelector(".sm-cc-repeating-list");
      if (!repeatingField) {
        return { success: false, error: "No repeating field found" };
      }
      const entries = repeatingField.querySelectorAll(".sm-cc-repeating-item");
      let targetEntry = null;
      for (const entry of entries) {
        const heading = entry.querySelector(".sm-cc-field-heading");
        if (heading && heading.textContent?.trim().toUpperCase() === abilityKey.toUpperCase()) {
          targetEntry = entry;
          break;
        }
      }
      if (!targetEntry) {
        return {
          success: false,
          error: `Ability not found: "${abilityKey}"`
        };
      }
      try {
        const values = {
          ability: abilityKey.toUpperCase()
        };
        const scoreInput = targetEntry.querySelector('input[type="number"]');
        if (scoreInput) {
          values.score = parseInt(scoreInput.value, 10);
        }
        const modDisplay = targetEntry.querySelectorAll(".sm-cc-display-field")[0];
        if (modDisplay) {
          values.modifier = modDisplay.value?.trim();
        }
        const saveCheckbox = targetEntry.querySelector('input[type="checkbox"]');
        if (saveCheckbox) {
          values.saveProf = saveCheckbox.checked;
        }
        const saveModSteppers = targetEntry.querySelectorAll('input[type="number"]');
        if (saveModSteppers.length > 1) {
          const saveModInput = saveModSteppers[1];
          values.saveMod = parseInt(saveModInput.value, 10);
        }
        const saveFinalDisplay = targetEntry.querySelectorAll(".sm-cc-display-field")[1];
        if (saveFinalDisplay) {
          values.saveFinal = saveFinalDisplay.value?.trim();
        }
        logger2.log("[IPC-CMD] Ability values:", JSON.stringify(values, null, 2));
        return {
          success: true,
          ability: abilityKey.toUpperCase(),
          values
        };
      } catch (error) {
        logger2.error("[IPC-CMD] Get values failed:", error);
        return { success: false, error: String(error) };
      }
    };
  }
});

// devkit/testing/integration/test-context.ts
var TestContextManager, testContext;
var init_test_context = __esm({
  "devkit/testing/integration/test-context.ts"() {
    "use strict";
    init_plugin_logger();
    TestContextManager = class {
      constructor() {
        this.activeTest = null;
      }
      /**
       * Start a new test context
       */
      startTest(testId, testName) {
        this.activeTest = {
          testId,
          testName,
          startTime: Date.now(),
          markers: []
        };
        logger2.log(`[TEST:START] ID="${testId}" Name="${testName}"`);
      }
      /**
       * End the current test context
       */
      endTest() {
        if (!this.activeTest) {
          logger2.warn("[TEST:END] No active test to end");
          return null;
        }
        const duration = Date.now() - this.activeTest.startTime;
        logger2.log(`[TEST:END] ID="${this.activeTest.testId}" Duration=${duration}ms`);
        const context = this.activeTest;
        this.activeTest = null;
        return context;
      }
      /**
       * Add a marker to the current test
       */
      addMarker(marker) {
        if (!this.activeTest) {
          logger2.warn("[TEST:MARKER] No active test for marker:", marker);
          return;
        }
        this.activeTest.markers.push({
          timestamp: Date.now(),
          marker
        });
        logger2.log(`[TEST:MARKER] ID="${this.activeTest.testId}" Marker="${marker}"`);
      }
      /**
       * Get the current test context
       */
      getActiveTest() {
        return this.activeTest;
      }
      /**
       * Check if a test is currently active
       */
      isTestActive() {
        return this.activeTest !== null;
      }
    };
    testContext = new TestContextManager();
  }
});

// devkit/core/ipc/commands/test-commands.ts
var startTest, endTest, logMarker, setDebugConfig, getDebugConfig, getTestLogs, assertLogContains;
var init_test_commands = __esm({
  "devkit/core/ipc/commands/test-commands.ts"() {
    "use strict";
    init_plugin_logger();
    init_test_context();
    init_debug_logger();
    startTest = async (app, args) => {
      const [testId, testName] = args;
      if (!testId) {
        return {
          success: false,
          error: "Test ID required. Usage: start-test <test-id> [test-name]"
        };
      }
      testContext.startTest(testId, testName || testId);
      logger2.log("[IPC-TEST] Test started:", { testId, testName });
      return {
        success: true,
        testId,
        testName: testName || testId,
        message: "Test context started"
      };
    };
    endTest = async (app, args) => {
      const context = testContext.endTest();
      if (!context) {
        return {
          success: false,
          error: "No active test to end"
        };
      }
      logger2.log("[IPC-TEST] Test ended:", { testId: context.testId });
      return {
        success: true,
        testId: context.testId,
        testName: context.testName,
        duration: Date.now() - context.startTime,
        markerCount: context.markers.length,
        message: "Test context ended"
      };
    };
    logMarker = async (app, args) => {
      const marker = args.join(" ");
      if (!marker) {
        return {
          success: false,
          error: "Marker text required. Usage: log-marker <marker-text>"
        };
      }
      testContext.addMarker(marker);
      return {
        success: true,
        marker,
        message: "Marker logged"
      };
    };
    setDebugConfig = async (app, args) => {
      const configJson = args.join(" ");
      if (!configJson) {
        return {
          success: false,
          error: `Config JSON required. Usage: set-debug-config '{"enabled": true, ...}'`
        };
      }
      try {
        const newConfig = JSON.parse(configJson);
        debugLogger.config = newConfig;
        logger2.log("[IPC-TEST] Debug config updated:", newConfig);
        return {
          success: true,
          config: newConfig,
          message: "Debug configuration updated"
        };
      } catch (error) {
        logger2.error("[IPC-TEST] Failed to set debug config:", error);
        return {
          success: false,
          error: String(error)
        };
      }
    };
    getDebugConfig = async (app, args) => {
      const config = debugLogger.getConfig();
      logger2.log("[IPC-TEST] Debug config retrieved:", config);
      return {
        success: true,
        config
      };
    };
    getTestLogs = async (app, args) => {
      const [testId] = args;
      if (!testId) {
        return {
          success: false,
          error: "Test ID required. Usage: get-test-logs <test-id>"
        };
      }
      try {
        const fs = require("fs");
        const path = require("path");
        const logPath = path.join(app.vault.adapter.basePath, "CONSOLE_LOG.txt");
        const content = fs.readFileSync(logPath, "utf-8");
        const allLines = content.split("\n");
        const startMarker = `[TEST:START] ID="${testId}"`;
        const endMarker = `[TEST:END] ID="${testId}"`;
        let startIndex = -1;
        let endIndex = -1;
        for (let i = 0; i < allLines.length; i++) {
          if (allLines[i].includes(startMarker)) {
            startIndex = i;
          }
          if (startIndex !== -1 && allLines[i].includes(endMarker)) {
            endIndex = i;
            break;
          }
        }
        if (startIndex === -1) {
          return {
            success: false,
            error: `No logs found for test ID: ${testId}`
          };
        }
        const testLogs = allLines.slice(startIndex, endIndex !== -1 ? endIndex + 1 : void 0);
        logger2.log("[IPC-TEST] Test logs retrieved:", {
          testId,
          lineCount: testLogs.length,
          hasEnd: endIndex !== -1
        });
        return {
          success: true,
          testId,
          logCount: testLogs.length,
          logs: testLogs
        };
      } catch (error) {
        logger2.error("[IPC-TEST] Failed to get test logs:", error);
        return {
          success: false,
          error: String(error)
        };
      }
    };
    assertLogContains = async (app, args) => {
      const [testId, ...patterns] = args;
      if (!testId || patterns.length === 0) {
        return {
          success: false,
          error: "Test ID and pattern required. Usage: assert-log-contains <test-id> <pattern1> [pattern2] ..."
        };
      }
      try {
        const logsResult = await getTestLogs(app, [testId]);
        if (!logsResult.success) {
          return logsResult;
        }
        const logs = logsResult.logs;
        const results = [];
        for (const pattern of patterns) {
          const foundLine = logs.find((line) => line.includes(pattern));
          results.push({
            pattern,
            found: !!foundLine,
            line: foundLine
          });
        }
        const allPassed = results.every((r) => r.found);
        logger2.log("[IPC-TEST] Assertion result:", {
          testId,
          passed: allPassed,
          results
        });
        return {
          success: allPassed,
          testId,
          passed: allPassed,
          results,
          message: allPassed ? "All patterns found" : "Some patterns not found"
        };
      } catch (error) {
        logger2.error("[IPC-TEST] Assertion failed:", error);
        return {
          success: false,
          error: String(error)
        };
      }
    };
  }
});

// devkit/core/ipc/commands/field-inspection-commands.ts
async function getFieldState(app, args) {
  const [fieldId] = args;
  if (!fieldId) {
    throw new Error("Field ID required");
  }
  logger2.log(`[IPC-CMD] Getting field state for: ${fieldId}`);
  const modal = document.querySelector(".modal.sm-cc-create-modal-host");
  if (!modal) {
    throw new Error("No create modal is open");
  }
  const fieldContainer = modal.querySelector(`[data-field-id="${fieldId}"]`);
  if (!fieldContainer) {
    throw new Error(`Field "${fieldId}" not found`);
  }
  const fieldManager = window.saltMarcherFieldManager;
  const state = {
    fieldId,
    exists: true,
    container: {
      classes: Array.from(fieldContainer.classList),
      visible: fieldContainer.offsetParent !== null,
      dimensions: {
        width: fieldContainer.offsetWidth,
        height: fieldContainer.offsetHeight
      }
    }
  };
  const input = fieldContainer.querySelector("input, select, textarea");
  if (input) {
    state.input = {
      type: input.type,
      value: input.value,
      disabled: input.disabled,
      readonly: input.readOnly
    };
  }
  const chipsContainer = fieldContainer.querySelector(".sm-cc-chips");
  if (chipsContainer) {
    const chips = Array.from(chipsContainer.querySelectorAll(".sm-cc-chip"));
    state.chips = chips.map((chip) => ({
      text: chip.textContent?.trim(),
      classes: Array.from(chip.classList),
      editable: chip.querySelector(".sm-cc-chip__segment--editable") !== null
    }));
  }
  if (fieldManager && fieldManager.fields) {
    const instance = fieldManager.fields.get(fieldId);
    if (instance) {
      state.fieldManager = {
        hasInstance: true,
        type: instance.spec?.type,
        visible: instance.isVisible,
        value: instance.getValue?.()
      };
    }
  }
  logger2.log(`[IPC-CMD] Field state:`, state);
  return state;
}
async function dumpFieldStates(app, args) {
  const [modalType] = args;
  logger2.log(`[IPC-CMD] Dumping all field states for modal: ${modalType || "current"}`);
  const modal = document.querySelector(".modal.sm-cc-create-modal-host");
  if (!modal) {
    throw new Error("No create modal is open");
  }
  const fieldContainers = modal.querySelectorAll("[data-field-id]");
  const fields8 = [];
  for (const container of Array.from(fieldContainers)) {
    const fieldId = container.getAttribute("data-field-id");
    if (!fieldId) continue;
    const field = {
      id: fieldId,
      visible: container.offsetParent !== null
    };
    const input = container.querySelector("input, select, textarea");
    if (input) {
      field.value = input.value;
      field.type = input.type || input.tagName.toLowerCase();
    }
    const chipsContainer = container.querySelector(".sm-cc-chips");
    if (chipsContainer) {
      const chips = Array.from(chipsContainer.querySelectorAll(".sm-cc-chip"));
      field.chips = chips.map((chip) => chip.textContent?.trim());
      field.chipCount = chips.length;
    }
    fields8.push(field);
  }
  const result = {
    modalType: modalType || "unknown",
    fieldCount: fields8.length,
    fields: fields8
  };
  logger2.log(`[IPC-CMD] Dumped ${fields8.length} fields`);
  return result;
}
async function getModalData(app, args) {
  logger2.log(`[IPC-CMD] Getting current modal data`);
  const modalInstance = window.saltMarcherCurrentModal;
  if (!modalInstance) {
    throw new Error("No modal instance found");
  }
  const data = modalInstance.getData?.();
  logger2.log(`[IPC-CMD] Modal data:`, data);
  return data || {};
}
var init_field_inspection_commands = __esm({
  "devkit/core/ipc/commands/field-inspection-commands.ts"() {
    "use strict";
    init_plugin_logger();
  }
});

// devkit/core/ipc/commands/dom-dump-command.ts
function elementToInfo(element, maxDepth, currentDepth = 0) {
  const info = {
    tag: element.tagName.toLowerCase(),
    classes: Array.from(element.classList),
    children: []
  };
  const attrs = {};
  if (element.hasAttribute("placeholder")) attrs.placeholder = element.getAttribute("placeholder");
  if (element.hasAttribute("type")) attrs.type = element.getAttribute("type");
  if (element.hasAttribute("value") && element instanceof HTMLInputElement) {
    attrs.value = element.value;
  }
  if (element.hasAttribute("aria-expanded")) attrs["aria-expanded"] = element.getAttribute("aria-expanded");
  if (element.hasAttribute("title")) attrs.title = element.getAttribute("title");
  if (Object.keys(attrs).length > 0) {
    info.attrs = attrs;
  }
  const directText = Array.from(element.childNodes).filter((node) => node.nodeType === Node.TEXT_NODE).map((node) => node.textContent?.trim()).filter((text) => text && text.length > 0 && text.length < 50).join(" ");
  if (directText) {
    info.text = directText;
  }
  if (currentDepth < maxDepth) {
    Array.from(element.children).forEach((child) => {
      info.children.push(elementToInfo(child, maxDepth, currentDepth + 1));
    });
  }
  return info;
}
function infoToASCII(info, prefix = "", isLast = true) {
  const lines = [];
  const connector = isLast ? "\u2514\u2500 " : "\u251C\u2500 ";
  const nodePrefix = prefix + connector;
  let nodeLine = `${nodePrefix}<${info.tag}>`;
  if (info.classes.length > 0) {
    const classList = info.classes.map((c) => `.${c}`).join("");
    nodeLine += ` ${classList}`;
  }
  if (info.attrs) {
    const attrStr = Object.entries(info.attrs).map(([key, val]) => `${key}="${val}"`).join(" ");
    nodeLine += ` [${attrStr}]`;
  }
  if (info.text) {
    nodeLine += ` "${info.text}"`;
  }
  lines.push(nodeLine);
  const childPrefix = prefix + (isLast ? "   " : "\u2502  ");
  info.children.forEach((child, index) => {
    const childIsLast = index === info.children.length - 1;
    const childLines = infoToASCII(child, childPrefix, childIsLast);
    lines.push(...childLines);
  });
  return lines;
}
var dumpDOM;
var init_dom_dump_command = __esm({
  "devkit/core/ipc/commands/dom-dump-command.ts"() {
    "use strict";
    init_plugin_logger();
    dumpDOM = async (app, args) => {
      const [selector = ".sm-cc-entry-list", maxDepthStr = "5"] = args;
      const maxDepth = parseInt(maxDepthStr, 10);
      logger2.log("[IPC-CMD] Dumping DOM structure:", { selector, maxDepth });
      const element = document.querySelector(selector);
      if (!element) {
        return {
          success: false,
          error: `Element not found: ${selector}`
        };
      }
      try {
        const info = elementToInfo(element, maxDepth);
        const lines = infoToASCII(info);
        const ascii = lines.join("\n");
        logger2.log("[IPC-CMD] DOM structure:\n" + ascii);
        return {
          success: true,
          selector,
          maxDepth,
          ascii,
          info
          // Also return structured data for programmatic use
        };
      } catch (error) {
        logger2.error("[IPC-CMD] DOM dump failed:", error);
        return { success: false, error: String(error) };
      }
    };
  }
});

// devkit/core/ipc/commands/ui-inspect-command.ts
function getLayoutInfo(element, maxDepth, currentDepth = 0) {
  const rect = element.getBoundingClientRect();
  const computed = window.getComputedStyle(element);
  const info = {
    selector: getSelector(element),
    tag: element.tagName.toLowerCase(),
    classes: Array.from(element.classList),
    width: rect.width,
    height: rect.height,
    x: rect.x,
    y: rect.y,
    display: computed.display,
    position: computed.position,
    children: []
  };
  const directText = Array.from(element.childNodes).filter((node) => node.nodeType === Node.TEXT_NODE).map((node) => node.textContent?.trim()).filter((text) => text && text.length > 0 && text.length < 30).join(" ");
  if (directText) {
    info.text = directText;
  }
  if (computed.display.includes("flex")) {
    info.flex = computed.flex;
    info.flexDirection = computed.flexDirection;
    info.flexWrap = computed.flexWrap;
    info.justifyContent = computed.justifyContent;
    info.alignItems = computed.alignItems;
    info.gap = computed.gap;
  }
  if (computed.minWidth !== "0px") info.minWidth = computed.minWidth;
  if (computed.maxWidth !== "none") info.maxWidth = computed.maxWidth;
  if (computed.minHeight !== "0px") info.minHeight = computed.minHeight;
  if (computed.maxHeight !== "none") info.maxHeight = computed.maxHeight;
  const padding = computed.padding;
  if (padding !== "0px") info.padding = padding;
  const margin = computed.margin;
  if (margin !== "0px") info.margin = margin;
  if (computed.overflow !== "visible") info.overflow = computed.overflow;
  if (computed.whiteSpace !== "normal") info.whiteSpace = computed.whiteSpace;
  if (currentDepth < maxDepth) {
    Array.from(element.children).forEach((child) => {
      info.children.push(getLayoutInfo(child, maxDepth, currentDepth + 1));
    });
  }
  return info;
}
function getSelector(element) {
  const classes = Array.from(element.classList);
  if (classes.length > 0) {
    return `.${classes[0]}`;
  }
  return element.tagName.toLowerCase();
}
function formatLayout(info, indent = "") {
  const lines = [];
  let line = `${indent}${info.tag}`;
  if (info.classes.length > 0) {
    line += ` .${info.classes.join(".")}`;
  }
  if (info.text) {
    line += ` "${info.text}"`;
  }
  lines.push(line);
  lines.push(`${indent}  Size: ${Math.round(info.width)}\xD7${Math.round(info.height)}px`);
  lines.push(`${indent}  Position: (${Math.round(info.x)}, ${Math.round(info.y)})`);
  lines.push(`${indent}  Display: ${info.display}`);
  if (info.display.includes("flex")) {
    lines.push(`${indent}  Flex: direction=${info.flexDirection}, wrap=${info.flexWrap}`);
    if (info.justifyContent !== "normal") {
      lines.push(`${indent}        justify=${info.justifyContent}, align=${info.alignItems}`);
    }
    if (info.gap !== "normal 0px" && info.gap !== "0px") {
      lines.push(`${indent}        gap=${info.gap}`);
    }
  }
  const constraints = [];
  if (info.minWidth) constraints.push(`min-w: ${info.minWidth}`);
  if (info.maxWidth) constraints.push(`max-w: ${info.maxWidth}`);
  if (info.minHeight) constraints.push(`min-h: ${info.minHeight}`);
  if (info.maxHeight) constraints.push(`max-h: ${info.maxHeight}`);
  if (constraints.length > 0) {
    lines.push(`${indent}  Constraints: ${constraints.join(", ")}`);
  }
  if (info.padding && info.padding !== "0px") {
    lines.push(`${indent}  Padding: ${info.padding}`);
  }
  if (info.margin && info.margin !== "0px") {
    lines.push(`${indent}  Margin: ${info.margin}`);
  }
  if (info.overflow) {
    lines.push(`${indent}  Overflow: ${info.overflow}`);
  }
  if (info.whiteSpace) {
    lines.push(`${indent}  White-space: ${info.whiteSpace}`);
  }
  if (info.children.length > 0) {
    lines.push(`${indent}  Children (${info.children.length}):`);
    info.children.forEach((child) => {
      lines.push(...formatLayout(child, indent + "    "));
    });
  }
  return lines;
}
var inspectUI;
var init_ui_inspect_command = __esm({
  "devkit/core/ipc/commands/ui-inspect-command.ts"() {
    "use strict";
    init_plugin_logger();
    inspectUI = async (app, args) => {
      const [selector = ".sm-cc-entry-head", maxDepthStr = "2"] = args;
      const maxDepth = parseInt(maxDepthStr, 10);
      logger2.log("[IPC-CMD] Inspecting UI layout:", { selector, maxDepth });
      const element = document.querySelector(selector);
      if (!element) {
        return {
          success: false,
          error: `Element not found: ${selector}`
        };
      }
      try {
        const layout = getLayoutInfo(element, maxDepth);
        const formatted = formatLayout(layout);
        const report = formatted.join("\n");
        logger2.log("[IPC-CMD] UI Layout:\n" + report);
        return {
          success: true,
          selector,
          maxDepth,
          layout,
          report
        };
      } catch (error) {
        logger2.error("[IPC-CMD] UI inspect failed:", error);
        return { success: false, error: String(error) };
      }
    };
  }
});

// src/services/events/event-bus.ts
var EventTopic, EventBusImpl, eventBus;
var init_event_bus = __esm({
  "src/services/events/event-bus.ts"() {
    "use strict";
    init_plugin_logger();
    EventTopic = /* @__PURE__ */ ((EventTopic2) => {
      EventTopic2["ENCOUNTER"] = "encounter";
      EventTopic2["FACTION"] = "faction";
      EventTopic2["CALENDAR"] = "calendar";
      EventTopic2["AUDIO"] = "audio";
      EventTopic2["MAP"] = "map";
      EventTopic2["LIBRARY"] = "library";
      EventTopic2["TRAVEL"] = "travel";
      EventTopic2["WEATHER"] = "weather";
      return EventTopic2;
    })(EventTopic || {});
    EventBusImpl = class {
      constructor() {
        this.subscriptions = /* @__PURE__ */ new Map();
        this.topicIndex = /* @__PURE__ */ new Map();
        this.nextId = 1;
        this.isPaused = false;
        this.eventQueue = [];
        this.isProcessing = false;
        Object.values(EventTopic).forEach((topic) => {
          this.topicIndex.set(topic, /* @__PURE__ */ new Set());
        });
      }
      /**
       * Subscribe to events
       */
      subscribe(handler, options = {}) {
        const {
          topics = Object.values(EventTopic),
          filter,
          async = false,
          priority = 0,
          signal
        } = options;
        const id = `sub-${this.nextId++}`;
        const topicSet = new Set(
          Array.isArray(topics) ? topics : [topics]
        );
        const subscription = {
          id,
          topics: topicSet,
          handler,
          filter,
          async,
          priority
        };
        this.subscriptions.set(id, subscription);
        topicSet.forEach((topic) => {
          this.topicIndex.get(topic)?.add(id);
        });
        if (signal) {
          signal.addEventListener("abort", () => {
            this.unsubscribe(id);
          });
        }
        logger2.debug(`[EventBus] Subscribed ${id} to topics:`, Array.from(topicSet));
        return () => this.unsubscribe(id);
      }
      /**
       * Emit an event
       */
      async emit(event) {
        if (this.isPaused) {
          this.eventQueue.push(event);
          return;
        }
        logger2.debug(`[EventBus] Emitting ${event.topic} event:`, event);
        const subscriptionIds = this.topicIndex.get(event.topic) || /* @__PURE__ */ new Set();
        const subscriptions = Array.from(subscriptionIds).map((id) => this.subscriptions.get(id)).filter((sub) => !!sub).filter((sub) => !sub.filter || sub.filter(event)).sort((a, b) => b.priority - a.priority);
        const promises = [];
        for (const subscription of subscriptions) {
          try {
            if (subscription.async) {
              promises.push(
                Promise.resolve(subscription.handler(event)).catch((error) => {
                  logger2.error(
                    `[EventBus] Async handler error for ${subscription.id}:`,
                    error
                  );
                })
              );
            } else {
              await Promise.resolve(subscription.handler(event));
            }
          } catch (error) {
            logger2.error(
              `[EventBus] Handler error for ${subscription.id}:`,
              error
            );
          }
        }
        if (promises.length > 0) {
          await Promise.allSettled(promises);
        }
      }
      /**
       * Emit an event without waiting for handlers
       */
      emitAsync(event) {
        this.emit(event).catch((error) => {
          logger2.error("[EventBus] Async emit error:", error);
        });
      }
      /**
       * Remove a subscription
       */
      unsubscribe(id) {
        const subscription = this.subscriptions.get(id);
        if (!subscription) return;
        subscription.topics.forEach((topic) => {
          this.topicIndex.get(topic)?.delete(id);
        });
        this.subscriptions.delete(id);
        logger2.debug(`[EventBus] Unsubscribed ${id}`);
      }
      /**
       * Pause event processing (queue events)
       */
      pause() {
        this.isPaused = true;
        logger2.info("[EventBus] Paused");
      }
      /**
       * Resume event processing (flush queue)
       */
      async resume() {
        this.isPaused = false;
        logger2.info("[EventBus] Resumed");
        const queue = [...this.eventQueue];
        this.eventQueue = [];
        for (const event of queue) {
          await this.emit(event);
        }
      }
      /**
       * Clear all subscriptions
       */
      clear() {
        this.subscriptions.clear();
        this.topicIndex.forEach((set2) => set2.clear());
        this.eventQueue = [];
        logger2.info("[EventBus] Cleared all subscriptions");
      }
      /**
       * Get subscription count
       */
      getSubscriptionCount() {
        return this.subscriptions.size;
      }
      /**
       * Get topic subscription count
       */
      getTopicSubscriptionCount(topic) {
        return this.topicIndex.get(topic)?.size || 0;
      }
    };
    eventBus = new EventBusImpl();
  }
});

// src/services/events/index.ts
var init_events2 = __esm({
  "src/services/events/index.ts"() {
    "use strict";
    init_event_bus();
  }
});

// devkit/core/ipc/commands/state-commands.ts
async function listStores(app) {
  logger2.log("[IPC-CMD] Listing registered stores");
  const manager = getStoreManager();
  const storeNames = manager.list();
  const summaries = storeNames.map((name) => {
    const store = manager.get(name);
    return summarizeStore(name, store);
  }).filter((summary) => summary !== null);
  const stats = {
    totalStores: summaries.length,
    persistentStores: summaries.filter((summary) => summary.isPersistent).length,
    writableStores: summaries.filter((summary) => summary.isWritable).length,
    readableStores: summaries.filter((summary) => summary.type === "readable").length
  };
  const topics = Object.values(EventTopic).map((topic) => ({
    topic,
    subscriptions: eventBus.getTopicSubscriptionCount(topic)
  }));
  return {
    stores: summaries,
    stats,
    eventBus: {
      totalSubscriptions: eventBus.getSubscriptionCount(),
      topics
    }
  };
}
async function inspectStore(app, args) {
  const [storeName] = args;
  if (!storeName) {
    throw new Error("Store name required");
  }
  logger2.log(`[IPC-CMD] Inspecting store: ${storeName}`);
  const manager = getStoreManager();
  const store = manager.get(storeName);
  if (!store) {
    return {
      name: storeName,
      capabilities: [],
      type: "readable",
      isPersistent: false,
      isWritable: false,
      found: false,
      valuePreview: void 0
    };
  }
  const summary = summarizeStore(storeName, store, { includeValue: true });
  return {
    ...summary,
    found: true
  };
}
function summarizeStore(name, store, options = {}) {
  if (!store) return null;
  const isWritable = typeof store.set === "function";
  const isPersistent = typeof store.save === "function" && typeof store.load === "function";
  const hasMetadata = typeof store.getMetadata === "function";
  const capabilities = ["readable"];
  if (isWritable) capabilities.push("writable");
  if (isPersistent) capabilities.push("persistent");
  let metadata;
  if (hasMetadata) {
    try {
      metadata = sanitizeValue(store.getMetadata());
    } catch (error) {
      metadata = { error: `Failed to read metadata: ${error instanceof Error ? error.message : String(error)}` };
    }
  }
  let storageKey;
  if (isPersistent && typeof store.getStorageKey === "function") {
    try {
      storageKey = store.getStorageKey();
    } catch (error) {
      storageKey = `Error: ${error instanceof Error ? error.message : String(error)}`;
    }
  }
  let isDirty;
  if (isPersistent && typeof store.isDirty === "function") {
    try {
      isDirty = store.isDirty();
    } catch (error) {
      isDirty = void 0;
    }
  }
  let valueType;
  let valuePreview;
  let valueError;
  let serializedValue;
  try {
    const value = store.get();
    valueType = determineType(value);
    serializedValue = sanitizeValue(value);
    valuePreview = createPreview(serializedValue);
  } catch (error) {
    valueError = `Failed to read value: ${error instanceof Error ? error.message : String(error)}`;
  }
  if (options.includeValue) {
    return {
      name,
      capabilities,
      type: determineStoreType(isPersistent, isWritable),
      isPersistent,
      isWritable,
      isDirty,
      storageKey,
      metadata,
      valueType,
      valuePreview,
      valueError,
      value: serializedValue
    };
  }
  return {
    name,
    capabilities,
    type: determineStoreType(isPersistent, isWritable),
    isPersistent,
    isWritable,
    isDirty,
    storageKey,
    metadata,
    valueType,
    valuePreview,
    valueError
  };
}
function determineStoreType(isPersistent, isWritable) {
  if (isPersistent) return "persistent";
  if (isWritable) return "writable";
  return "readable";
}
function createPreview(value) {
  if (typeof value === "undefined") return void 0;
  try {
    const json2 = JSON.stringify(value);
    if (!json2) return void 0;
    if (json2.length <= MAX_PREVIEW_LENGTH) {
      return json2;
    }
    return `${json2.slice(0, MAX_PREVIEW_LENGTH - 1)}\u2026`;
  } catch (error) {
    return `[unserializable: ${error instanceof Error ? error.message : typeof value}]`;
  }
}
function determineType(value) {
  if (value === null) return "null";
  if (value === void 0) return "undefined";
  if (Array.isArray(value)) return "array";
  if (value instanceof Map) return "Map";
  if (value instanceof Set) return "Set";
  if (value instanceof Date) return "Date";
  if (value instanceof RegExp) return "RegExp";
  return typeof value;
}
function sanitizeValue(value, seen = /* @__PURE__ */ new WeakSet(), depth = 0) {
  if (value === null || typeof value !== "object") {
    if (typeof value === "function") {
      return `[Function ${value.name || "anonymous"}]`;
    }
    return value;
  }
  if (value instanceof Date) {
    return value.toISOString();
  }
  if (value instanceof RegExp) {
    return value.toString();
  }
  if (value instanceof Map) {
    const entries = Array.from(value.entries()).slice(0, MAX_ARRAY_ITEMS);
    return entries.map(([key, val]) => [
      sanitizeValue(key, seen, depth + 1),
      sanitizeValue(val, seen, depth + 1)
    ]);
  }
  if (value instanceof Set) {
    return Array.from(value.values()).slice(0, MAX_ARRAY_ITEMS).map((item) => sanitizeValue(item, seen, depth + 1));
  }
  if (seen.has(value)) {
    return "[Circular]";
  }
  seen.add(value);
  if (depth >= MAX_DEPTH) {
    const ctor = value.constructor;
    return `[Object ${ctor?.name || "Object"}]`;
  }
  const result = {};
  for (const [key, val] of Object.entries(value)) {
    result[key] = sanitizeValue(val, seen, depth + 1);
  }
  return result;
}
var MAX_PREVIEW_LENGTH, MAX_ARRAY_ITEMS, MAX_DEPTH;
var init_state_commands = __esm({
  "devkit/core/ipc/commands/state-commands.ts"() {
    "use strict";
    init_plugin_logger();
    init_store_manager();
    init_events2();
    MAX_PREVIEW_LENGTH = 200;
    MAX_ARRAY_ITEMS = 20;
    MAX_DEPTH = 3;
  }
});

// devkit/core/ipc/register-dev-commands.ts
var register_dev_commands_exports = {};
__export(register_dev_commands_exports, {
  registerDevCommands: () => registerDevCommands
});
function registerDevCommands(server) {
  server.registerCommand("navigate-to-section", navigateToSection);
  server.registerCommand("click-element", clickElement);
  server.registerCommand("set-input-value", setInputValue);
  server.registerCommand("add-token", addTokenToField);
  server.registerCommand("toggle-save-checkbox", toggleRepeatingCheckbox);
  server.registerCommand("get-ability-values", getRepeatingEntryValues);
  server.registerCommand("validate-grid-layout", validateGridLayout);
  server.registerCommand("debug-stepper-styles", debugStepperStyles);
  server.registerCommand("validate-ui", validateUILegacy);
  server.registerCommand("measure-ui", measureUI);
  server.registerCommand("validate-ui-rule", validateUIWithRules);
  server.registerCommand("validate-ui-config", validateUIWithConfig);
  server.registerCommand("start-test", startTest);
  server.registerCommand("end-test", endTest);
  server.registerCommand("log-marker", logMarker);
  server.registerCommand("set-debug-config", setDebugConfig);
  server.registerCommand("get-debug-config", getDebugConfig);
  server.registerCommand("get-test-logs", getTestLogs);
  server.registerCommand("assert-log-contains", assertLogContains);
  server.registerCommand("get-field-state", getFieldState);
  server.registerCommand("dump-field-states", dumpFieldStates);
  server.registerCommand("get-modal-data", getModalData);
  server.registerCommand("dump-dom", dumpDOM);
  server.registerCommand("inspect-ui", inspectUI);
  server.registerCommand("state-list", listStores);
  server.registerCommand("state-inspect", inspectStore);
}
var init_register_dev_commands = __esm({
  "devkit/core/ipc/register-dev-commands.ts"() {
    "use strict";
    init_dev_commands();
    init_test_commands();
    init_field_inspection_commands();
    init_dom_dump_command();
    init_ui_inspect_command();
    init_state_commands();
  }
});

// src/app/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SaltMarcherPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian54 = require("obsidian");
init_plugin_logger();

// src/workmodes/cartographer/index.ts
var import_obsidian32 = require("obsidian");

// src/workmodes/cartographer/controller.ts
var import_obsidian31 = require("obsidian");
init_options();
init_map_list();

// src/workmodes/session-runner/travel/ui/map-layer.ts
init_hex_render();
var keyOf3 = (r, c) => `${r},${c}`;
async function createMapLayer(app, host, mapFile, opts) {
  const handles = await renderHexMap(app, host, mapFile, opts);
  const polyToCoord = /* @__PURE__ */ new WeakMap();
  for (const [k, poly] of handles.polyByCoord) {
    if (!poly) continue;
    const [r, c] = k.split(",").map(Number);
    polyToCoord.set(poly, { r, c });
  }
  const ensureHandlesPolys = typeof handles.ensurePolys === "function" ? (coords) => handles.ensurePolys(coords) : null;
  function ensurePolys(coords) {
    ensureHandlesPolys?.(coords);
    for (const rc of coords) {
      const poly = handles.polyByCoord.get(keyOf3(rc.r, rc.c));
      if (poly) polyToCoord.set(poly, rc);
    }
  }
  function centerOf(rc) {
    let poly = handles.polyByCoord.get(keyOf3(rc.r, rc.c));
    if (!poly) {
      ensurePolys([rc]);
      poly = handles.polyByCoord.get(keyOf3(rc.r, rc.c));
      if (!poly) return null;
    }
    const bb = poly.getBBox();
    return { x: bb.x + bb.width / 2, y: bb.y + bb.height / 2 };
  }
  function destroy() {
    try {
      handles.destroy?.();
    } catch {
    }
  }
  return { handles, polyToCoord, ensurePolys, centerOf, destroy };
}

// src/ui/maps/workflows/map-manager.ts
var import_obsidian13 = require("obsidian");
init_plugin_logger();
init_map_workflows();

// src/ui/maps/components/confirm-delete-modal.ts
var import_obsidian12 = require("obsidian");
init_plugin_logger();
var ConfirmDeleteModal = class extends import_obsidian12.Modal {
  constructor(app, mapFile, onConfirm) {
    super(app);
    this.mapFile = mapFile;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const name = this.mapFile.basename;
    contentEl.createEl("h3", { text: "Delete map?" });
    const message = contentEl.createEl("p");
    message.textContent = `This will delete your map permanently. To continue, enter "${name}".`;
    const input = contentEl.createEl("input", {
      attr: {
        type: "text",
        placeholder: name,
        style: "width:100%;"
      }
    });
    const btnRow = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = btnRow.createEl("button", { text: "Cancel" });
    const confirmBtn = btnRow.createEl("button", { text: "Delete" });
    (0, import_obsidian12.setIcon)(confirmBtn, "trash");
    confirmBtn.classList.add("mod-warning");
    confirmBtn.disabled = true;
    input.addEventListener("input", () => {
      confirmBtn.disabled = input.value.trim() !== name;
    });
    cancelBtn.onclick = () => this.close();
    confirmBtn.onclick = async () => {
      confirmBtn.disabled = true;
      try {
        await this.onConfirm();
        new import_obsidian12.Notice("Map deleted.");
      } catch (e) {
        logger2.error(e);
        new import_obsidian12.Notice("Deleting map failed.");
      } finally {
        this.close();
      }
    };
    setTimeout(() => input.focus(), 0);
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/ui/maps/workflows/map-manager.ts
init_map_repository();
var MAP_MANAGER_COPY = {
  notices: {
    missingSelection: "Select a map before deleting.",
    deleteFailed: "Unable to delete the map. Check the developer console for details."
  },
  logs: {
    deleteFailed: "Map deletion failed"
  }
};
function createMapManager(app, options = {}) {
  const notices = {
    missingSelection: options.notices?.missingSelection ?? MAP_MANAGER_COPY.notices.missingSelection,
    deleteFailed: MAP_MANAGER_COPY.notices.deleteFailed
  };
  let current = options.initialFile ?? null;
  const applyChange = async (file) => {
    current = file;
    await options.onChange?.(file);
  };
  const setFile = async (file) => {
    await applyChange(file);
  };
  const open = async () => {
    await promptMapSelection(
      app,
      async (file) => {
        await applyChange(file);
      },
      options.selectOptions
    );
  };
  const create = () => {
    promptCreateMap(
      app,
      async (file) => {
        await applyChange(file);
      },
      options.createOptions
    );
  };
  const deleteCurrent = () => {
    const target = current;
    if (!target) {
      new import_obsidian13.Notice(notices.missingSelection);
      return;
    }
    new ConfirmDeleteModal(app, target, async () => {
      try {
        await deleteMapAndTiles(app, target);
        if (current && current.path === target.path) {
          await applyChange(null);
        }
      } catch (error) {
        logger2.error(MAP_MANAGER_COPY.logs.deleteFailed, error);
        new import_obsidian13.Notice(notices.deleteFailed);
      }
    }).open();
  };
  return {
    getFile: () => current,
    setFile,
    open,
    create,
    deleteCurrent
  };
}

// src/workmodes/cartographer/controller.ts
init_plugin_logger();

// src/ui/maps/components/map-header.ts
var import_obsidian14 = require("obsidian");
init_map_workflows();
init_search_dropdown();

// src/ui/maps/workflows/save.ts
init_plugin_logger();
async function saveMap(_app, file) {
  logger2.warn("[save] saveMap() not implemented. File:", file.path);
}
async function saveMapAs(_app, file) {
  logger2.warn("[save] saveMapAs() not implemented. File:", file.path);
}

// src/ui/maps/components/map-header.ts
init_plugin_logger();
function createMapHeader(app, host, options) {
  const labels = {
    open: options.labels?.open ?? "Open map",
    create: options.labels?.create ?? "Create",
    delete: options.labels?.delete ?? "Delete",
    save: options.labels?.save ?? "Save",
    saveAs: options.labels?.saveAs ?? "Save as",
    trigger: options.labels?.trigger ?? "Apply"
  };
  const notices = {
    missingFile: options.notices?.missingFile ?? "Select a map before continuing.",
    saveSuccess: options.notices?.saveSuccess ?? "Map saved.",
    saveError: options.notices?.saveError ?? "Saving the map failed."
  };
  let currentFile = options.initialFile ?? null;
  let destroyed = false;
  const root = host.createDiv({ cls: "sm-map-header" });
  root.classList.add("map-editor-header");
  Object.assign(root.style, { display: "flex", flexDirection: "column", gap: ".4rem" });
  const row1 = root.createDiv();
  Object.assign(row1.style, { display: "flex", alignItems: "center", gap: ".5rem" });
  const titleGroup = row1.createDiv({ cls: "sm-map-header__title-group" });
  Object.assign(titleGroup.style, {
    display: "flex",
    alignItems: "center",
    gap: ".5rem",
    marginRight: "auto"
  });
  const titleEl = titleGroup.createEl("h2", { text: options.title });
  Object.assign(titleEl.style, { margin: 0 });
  const titleRightSlot = titleGroup.createDiv({ cls: "sm-map-header__title-slot" });
  Object.assign(titleRightSlot.style, {
    display: "flex",
    alignItems: "center",
    gap: ".5rem"
  });
  if (options.titleRightSlot) {
    options.titleRightSlot(titleRightSlot);
  } else {
    titleRightSlot.style.display = "none";
  }
  const openBtn = row1.createEl("button", { text: labels.open, attr: { type: "button" } });
  (0, import_obsidian14.setIcon)(openBtn, "folder-open");
  applyMapButtonStyle(openBtn);
  openBtn.onclick = () => {
    if (destroyed) return;
    void promptMapSelection(app, async (file) => {
      if (destroyed) return;
      setFileLabel(file);
      await options.onOpen?.(file);
    });
  };
  const createBtn = row1.createEl("button", { text: labels.create, attr: { type: "button" } });
  (0, import_obsidian14.setIcon)(createBtn, "plus");
  applyMapButtonStyle(createBtn);
  createBtn.onclick = () => {
    if (destroyed) return;
    promptCreateMap(app, async (file) => {
      if (destroyed) return;
      setFileLabel(file);
      await options.onCreate?.(file);
    });
  };
  const deleteBtn = options.onDelete ? row1.createEl("button", { text: labels.delete, attr: { type: "button", "aria-label": labels.delete } }) : null;
  if (deleteBtn) {
    (0, import_obsidian14.setIcon)(deleteBtn, "trash");
    applyMapButtonStyle(deleteBtn);
    deleteBtn.onclick = () => {
      if (destroyed) return;
      if (!currentFile) {
        new import_obsidian14.Notice(notices.missingFile);
        return;
      }
      void options.onDelete?.(currentFile);
    };
  }
  const row2 = root.createDiv();
  Object.assign(row2.style, { display: "flex", alignItems: "center", gap: ".5rem" });
  const secondaryLeftSlot = row2.createDiv({ cls: "sm-map-header__secondary-left" });
  Object.assign(secondaryLeftSlot.style, {
    marginRight: "auto",
    display: "flex",
    alignItems: "center",
    gap: ".5rem"
  });
  let nameBox = null;
  if (options.secondaryLeftSlot) {
    options.secondaryLeftSlot(secondaryLeftSlot);
  } else {
    nameBox = secondaryLeftSlot.createEl("div", {
      text: options.initialFile?.basename ?? options.emptyLabel ?? "\u2014"
    });
    nameBox.style.opacity = ".85";
  }
  const select = row2.createEl("select");
  select.createEl("option", { text: labels.save }).value = "save";
  select.createEl("option", { text: labels.saveAs }).value = "saveAs";
  enhanceSelectToSearch(select, "Choose a save action\u2026");
  const triggerBtn = row2.createEl("button", { text: labels.trigger, attr: { type: "button" } });
  applyMapButtonStyle(triggerBtn);
  triggerBtn.onclick = async () => {
    if (destroyed) return;
    const mode = select.value ?? "save";
    const file = currentFile;
    if (!file) {
      await options.onSave?.(mode, null);
      new import_obsidian14.Notice(notices.missingFile);
      return;
    }
    try {
      const handled = await options.onSave?.(mode, file) === true;
      if (!handled) {
        if (mode === "save") await saveMap(app, file);
        else await saveMapAs(app, file);
      }
      new import_obsidian14.Notice(notices.saveSuccess);
    } catch (err) {
      logger2.error("[map-header] save failed", err);
      new import_obsidian14.Notice(notices.saveError);
    }
  };
  function setFileLabel(file) {
    currentFile = file;
    const label = file?.basename ?? options.emptyLabel ?? "\u2014";
    if (nameBox) {
      nameBox.textContent = label;
    }
    secondaryLeftSlot.dataset.fileLabel = label;
    if (deleteBtn) {
      deleteBtn.disabled = !file;
      deleteBtn.style.opacity = file ? "1" : "0.5";
    }
  }
  function setTitle(title) {
    titleEl.textContent = title;
  }
  function destroy() {
    if (destroyed) return;
    destroyed = true;
    openBtn.onclick = null;
    createBtn.onclick = null;
    triggerBtn.onclick = null;
    root.remove();
  }
  setFileLabel(currentFile);
  return { root, secondaryLeftSlot, titleRightSlot, setFileLabel, setTitle, destroy };
}

// src/ui/components/view-container.ts
var DEFAULT_CAMERA = {
  minScale: 0.25,
  maxScale: 4,
  zoomSpeed: 1.1
};
function createViewContainer(parent, options = {}) {
  const root = parent.createDiv({ cls: "sm-view-container" });
  if (options.className) root.addClass(options.className);
  const viewport = root.createDiv({ cls: "sm-view-container__viewport" });
  const stage = viewport.createDiv({ cls: "sm-view-container__stage" });
  const overlay = root.createDiv({ cls: "sm-view-container__overlay" });
  overlay.toggleClass("is-visible", false);
  let overlayMessageEl = null;
  const ensureOverlayMessage = () => {
    if (overlayMessageEl && overlayMessageEl.isConnected) return overlayMessageEl;
    overlay.empty();
    overlayMessageEl = overlay.createDiv({ cls: "sm-view-container__overlay-message" });
    return overlayMessageEl;
  };
  let cameraEnabled = options.camera !== false;
  const cameraConfig = {
    ...DEFAULT_CAMERA,
    ...typeof options.camera === "object" ? options.camera : {}
  };
  let camera = { x: 0, y: 0, scale: options.initialScale ?? 1 };
  const applyCamera = () => {
    stage.style.transform = `translate(${camera.x}px, ${camera.y}px) scale(${camera.scale})`;
  };
  applyCamera();
  let panPointer = null;
  let panStartX = 0;
  let panStartY = 0;
  let panOriginX = 0;
  let panOriginY = 0;
  const handlePointerDown = (ev) => {
    if (!cameraEnabled || ev.button !== 1) return;
    ev.preventDefault();
    ev.stopPropagation();
    panPointer = ev.pointerId;
    panStartX = ev.clientX;
    panStartY = ev.clientY;
    panOriginX = camera.x;
    panOriginY = camera.y;
    viewport.setPointerCapture(ev.pointerId);
    viewport.addClass("is-panning");
  };
  const handlePointerMove = (ev) => {
    if (panPointer === null || ev.pointerId !== panPointer) return;
    ev.preventDefault();
    ev.stopPropagation();
    const dx = ev.clientX - panStartX;
    const dy = ev.clientY - panStartY;
    camera = { ...camera, x: panOriginX + dx, y: panOriginY + dy };
    applyCamera();
  };
  const stopPan = (ev) => {
    if (panPointer === null) return;
    if (ev && ev.pointerId !== panPointer) return;
    if (ev) {
      ev.preventDefault();
      ev.stopPropagation();
      viewport.releasePointerCapture(ev.pointerId);
    }
    panPointer = null;
    viewport.removeClass("is-panning");
  };
  const handleWheel = (ev) => {
    if (!cameraEnabled) return;
    ev.preventDefault();
    ev.stopPropagation();
    const delta = ev.deltaY;
    const factor = Math.exp(-delta * 15e-4 * (cameraConfig.zoomSpeed ?? 1));
    const nextScale = Math.min(cameraConfig.maxScale, Math.max(cameraConfig.minScale, camera.scale * factor));
    if (Math.abs(nextScale - camera.scale) < 1e-4) return;
    const rect = viewport.getBoundingClientRect();
    const px = ev.clientX - rect.left;
    const py = ev.clientY - rect.top;
    const worldX = (px - camera.x) / camera.scale;
    const worldY = (py - camera.y) / camera.scale;
    camera = {
      scale: nextScale,
      x: px - worldX * nextScale,
      y: py - worldY * nextScale
    };
    applyCamera();
  };
  if (cameraEnabled) {
    viewport.style.touchAction = "none";
    viewport.addEventListener("pointerdown", handlePointerDown);
    viewport.addEventListener("pointermove", handlePointerMove);
    viewport.addEventListener("pointerup", stopPan);
    viewport.addEventListener("pointercancel", stopPan);
    viewport.addEventListener("pointerleave", stopPan);
    viewport.addEventListener("wheel", handleWheel, { passive: false });
  }
  const setOverlay = (message) => {
    if (!message) {
      overlay.toggleClass("is-visible", false);
      overlay.empty();
      overlayMessageEl = null;
      return;
    }
    const target = ensureOverlayMessage();
    target.setText(message);
    overlay.toggleClass("is-visible", true);
  };
  return {
    rootEl: root,
    viewportEl: viewport,
    stageEl: stage,
    overlayEl: overlay,
    setOverlay,
    clearOverlay() {
      setOverlay(null);
    },
    resetCamera() {
      camera = { x: 0, y: 0, scale: options.initialScale ?? 1 };
      applyCamera();
    },
    destroy() {
      stopPan();
      if (cameraEnabled) {
        viewport.removeEventListener("pointerdown", handlePointerDown);
        viewport.removeEventListener("pointermove", handlePointerMove);
        viewport.removeEventListener("pointerup", stopPan);
        viewport.removeEventListener("pointercancel", stopPan);
        viewport.removeEventListener("pointerleave", stopPan);
        viewport.removeEventListener("wheel", handleWheel);
      }
      root.remove();
    }
  };
}

// src/workmodes/cartographer/controller.ts
var DEFAULT_MODE_DESCRIPTORS = [
  {
    id: "editor",
    label: "Editor",
    async load() {
      const { createEditorMode: createEditorMode2 } = await Promise.resolve().then(() => (init_editor(), editor_exports));
      return createEditorMode2();
    }
  },
  {
    id: "inspector",
    label: "Inspector",
    async load() {
      const { createInspectorMode: createInspectorMode2 } = await Promise.resolve().then(() => (init_inspector(), inspector_exports));
      return createInspectorMode2();
    }
  }
];
var createDefaultDeps = (app) => ({
  createMapManager: (appInstance, options) => createMapManager(appInstance, options),
  createMapLayer: (appInstance, host, file, opts) => createMapLayer(appInstance, host, file, opts),
  loadHexOptions: async (appInstance, file) => {
    const block = await getFirstHexBlock(appInstance, file);
    return block ? parseOptions(block) : null;
  },
  modeDescriptors: DEFAULT_MODE_DESCRIPTORS
});
var MODE_PROVISION_OVERLAY_MESSAGE = "Cartographer-Modi konnten nicht geladen werden.";
var MODE_PROVISION_NOTICE_MESSAGE = "Cartographer-Modi konnten nicht geladen werden. Bitte die Konsole pr\xFCfen.";
var CartographerController = class {
  constructor(app, deps = {}) {
    this.view = null;
    this.host = null;
    this.mapManager = null;
    this.currentFile = null;
    this.requestedFile = null;
    this.currentOptions = null;
    this.mapLayer = null;
    this.isMounted = false;
    this.shellModes = [];
    this.activeMode = null;
    this.activeModeId = null;
    this.lifecycle = null;
    this.app = app;
    const defaults = createDefaultDeps(app);
    this.deps = {
      ...defaults,
      ...deps,
      modeDescriptors: deps.modeDescriptors ?? defaults.modeDescriptors
    };
    this.callbacks = {
      onModeSelect: (id, ctx) => this.setMode(id, ctx),
      onOpen: (file) => this.mapManager?.setFile(file),
      onCreate: (file) => this.mapManager?.setFile(file),
      onDelete: () => this.mapManager?.deleteCurrent(),
      onSave: (mode, file) => this.handleSave(mode, file),
      onHexClick: (coord, event) => this.handleHexClick(coord, event)
    };
  }
  async onOpen(host, fallbackFile) {
    await this.onClose();
    this.host = host;
    this.isMounted = true;
    const initialFile = this.requestedFile ?? fallbackFile ?? null;
    this.currentFile = initialFile;
    this.requestedFile = initialFile;
    const view = createControllerView({
      app: this.app,
      host,
      initialFile,
      modes: this.shellModes,
      callbacks: this.callbacks
    });
    this.view = view;
    this.mapManager = this.deps.createMapManager(this.app, {
      initialFile,
      onChange: async (file) => {
        await this.applyCurrentFile(file);
      }
    });
    view.setModes(this.shellModes, this.activeModeId);
    view.setFileLabel(initialFile);
    let initialMode = this.activeModeId;
    try {
      const modes = await this.loadModesOnce();
      if (!initialMode) {
        const first = modes.keys().next();
        initialMode = first.done ? null : first.value;
      }
    } catch {
    }
    if (initialMode) {
      await this.setMode(initialMode);
    }
    await this.mapManager.setFile(initialFile);
  }
  async onClose() {
    const lifecycle = this.lifecycle;
    const active = this.activeMode;
    this.lifecycle = null;
    this.activeModeId = null;
    this.activeMode = null;
    this.shellModes = [];
    if (lifecycle) lifecycle.controller.abort();
    if (active && lifecycle) {
      try {
        await active.onExit(lifecycle.ctx);
      } catch (error) {
        logger2.error("[cartographer] mode exit failed", error);
      }
    }
    if (this.view) {
      this.view.destroy();
      this.view = null;
    }
    this.host = null;
    this.renderAbort?.abort();
    this.renderAbort = void 0;
    this.destroyMapLayer();
    this.currentOptions = null;
    this.mapManager = null;
    this.isMounted = false;
  }
  async setFile(file) {
    this.requestedFile = file;
    if (!this.mapManager) return;
    await this.mapManager.setFile(file);
  }
  async loadModesOnce() {
    if (!this.modeLoad) {
      this.modeLoad = Promise.all(
        this.deps.modeDescriptors.map(async (descriptor) => ({
          descriptor,
          mode: await descriptor.load()
        }))
      ).then((entries) => {
        const map2 = /* @__PURE__ */ new Map();
        this.shellModes = entries.map(({ mode }) => {
          map2.set(mode.id, mode);
          return { id: mode.id, label: mode.label };
        });
        this.view?.setModes(this.shellModes, this.activeModeId);
        this.view?.setOverlay(null);
        return map2;
      }).catch((error) => {
        logger2.error("[cartographer] failed to load modes", error);
        this.view?.setOverlay(MODE_PROVISION_OVERLAY_MESSAGE);
        new import_obsidian31.Notice(MODE_PROVISION_NOTICE_MESSAGE);
        this.modeLoad = void 0;
        throw error;
      });
    }
    return this.modeLoad;
  }
  async setMode(id, ctx) {
    let modes;
    try {
      modes = await this.loadModesOnce();
    } catch {
      return;
    }
    const next = modes.get(id) ?? modes.values().next().value ?? null;
    if (!next) return;
    if (this.activeModeId === next.id) {
      this.view?.setModes(this.shellModes, next.id);
      return;
    }
    const previousLifecycle = this.lifecycle;
    if (previousLifecycle) previousLifecycle.controller.abort();
    const previous = this.activeMode;
    this.activeMode = null;
    this.lifecycle = null;
    this.activeModeId = null;
    if (previous && previousLifecycle) {
      try {
        await previous.onExit(previousLifecycle.ctx);
      } catch (error) {
        logger2.error("[cartographer] mode exit failed", error);
      }
    }
    if (!this.isMounted || !this.view) {
      this.activeMode = next;
      this.activeModeId = next.id;
      return;
    }
    const controller = new AbortController();
    if (ctx?.signal) {
      if (ctx.signal.aborted) controller.abort();
      else ctx.signal.addEventListener("abort", () => controller.abort(), { once: true });
    }
    const lifecycleCtx = this.createLifecycleContext(controller.signal);
    this.lifecycle = { controller, ctx: lifecycleCtx };
    this.activeMode = next;
    this.activeModeId = next.id;
    this.view.setModes(this.shellModes, next.id);
    try {
      await next.onEnter(lifecycleCtx);
    } catch (error) {
      if (!controller.signal.aborted) logger2.error("[cartographer] mode enter failed", error);
    }
    if (controller.signal.aborted) return;
    await this.applyCurrentFile(this.currentFile, lifecycleCtx);
  }
  async handleSave(mode, file) {
    if (!this.activeMode?.onSave || !this.lifecycle) return false;
    try {
      return await this.activeMode.onSave(mode, file, this.lifecycle.ctx) === true;
    } catch (error) {
      logger2.error("[cartographer] mode onSave failed", error);
      return false;
    }
  }
  async handleHexClick(coord, event) {
    if (!this.activeMode?.onHexClick || !this.lifecycle) return;
    try {
      await this.activeMode.onHexClick(coord, event, this.lifecycle.ctx);
    } catch (error) {
      logger2.error("[cartographer] mode onHexClick failed", error);
    }
  }
  get baseModeCtx() {
    if (!this.view || !this.host) throw new Error("CartographerController is not mounted.");
    return {
      app: this.app,
      host: this.host,
      mapHost: this.view.mapHost,
      sidebarHost: this.view.sidebarHost,
      getFile: () => this.currentFile,
      getMapLayer: () => this.mapLayer,
      getRenderHandles: () => this.mapLayer?.handles ?? null,
      getOptions: () => this.currentOptions
    };
  }
  createLifecycleContext(signal) {
    return { ...this.baseModeCtx, signal };
  }
  async applyCurrentFile(file = this.currentFile, lifecycleCtx = this.lifecycle?.ctx ?? null) {
    this.currentFile = file ?? null;
    this.requestedFile = file ?? null;
    const view = this.view;
    const ctx = lifecycleCtx;
    if (!view || !ctx || !this.activeMode) return;
    view.setFileLabel(this.currentFile);
    this.renderAbort?.abort();
    const controller = new AbortController();
    this.renderAbort = controller;
    const { signal } = controller;
    try {
      if (!this.currentFile) {
        this.destroyMapLayer();
        view.clearMap();
        this.currentOptions = null;
        view.setOverlay("Keine Karte ausgew\xE4hlt.");
        await this.safeFileChange(null, null, ctx);
        return;
      }
      let options = null;
      try {
        options = await this.deps.loadHexOptions(this.app, this.currentFile);
      } catch (error) {
        logger2.error("[cartographer] failed to parse map options", error);
      }
      if (signal.aborted || !this.view) return;
      if (!options) {
        this.destroyMapLayer();
        view.clearMap();
        this.currentOptions = null;
        view.setOverlay("Kein hex3x3-Block in dieser Datei.");
        await this.safeFileChange(this.currentFile, null, ctx);
        return;
      }
      let layer = null;
      try {
        layer = await this.deps.createMapLayer(this.app, view.mapHost, this.currentFile, options);
      } catch (error) {
        logger2.error("[cartographer] failed to render map", error);
        layer = null;
      }
      if (signal.aborted || !this.view) {
        layer?.destroy();
        return;
      }
      if (!layer) {
        this.destroyMapLayer();
        view.clearMap();
        this.currentOptions = null;
        view.setOverlay("Karte konnte nicht geladen werden.");
        await this.safeFileChange(this.currentFile, null, ctx);
        return;
      }
      this.destroyMapLayer();
      this.mapLayer = layer;
      this.currentOptions = options;
      view.setOverlay(null);
      await this.safeFileChange(this.currentFile, layer.handles, ctx);
    } finally {
      if (signal.aborted) {
        this.destroyMapLayer();
        this.currentOptions = null;
        view.clearMap();
      }
      if (this.renderAbort === controller) {
        this.renderAbort = void 0;
      }
    }
  }
  async safeFileChange(file, handles, ctx) {
    try {
      await this.activeMode?.onFileChange(file, handles, ctx);
    } catch (error) {
      logger2.error("[cartographer] mode onFileChange failed", error);
    }
  }
  destroyMapLayer() {
    const layer = this.mapLayer;
    this.mapLayer = null;
    if (!layer) return;
    try {
      layer.destroy();
    } catch (error) {
      logger2.error("[cartographer] failed to destroy map layer", error);
    }
  }
};
function createControllerView(options) {
  const { app, host, initialFile, modes, callbacks } = options;
  host.empty();
  host.addClass("sm-cartographer");
  const headerHost = host.createDiv({ cls: "sm-cartographer__header" });
  const bodyHost = host.createDiv({ cls: "sm-cartographer__body" });
  const mapWrapper = bodyHost.createDiv({ cls: "sm-cartographer__map" });
  const sidebarHost = bodyHost.createDiv({ cls: "sm-cartographer__sidebar" });
  const surface = createViewContainer(mapWrapper, { camera: false });
  let selectHandle = null;
  const headerHandle = createMapHeader(app, headerHost, {
    title: "Cartographer",
    initialFile,
    onOpen: (file) => callbacks.onOpen(file),
    onCreate: (file) => callbacks.onCreate(file),
    onDelete: (file) => callbacks.onDelete(file),
    onSave: (mode, file) => callbacks.onSave(mode, file),
    titleRightSlot: (slot) => {
      selectHandle = renderModeSelect(slot, modes, (id) => callbacks.onModeSelect(id));
    }
  });
  if (!selectHandle) {
    selectHandle = renderModeSelect(headerHandle.titleRightSlot, modes, (id) => callbacks.onModeSelect(id));
  }
  const hexListener = (event) => {
    if (!(event instanceof CustomEvent)) return;
    const detail = event.detail;
    if (!detail) return;
    event.stopPropagation();
    if (event.cancelable) event.preventDefault();
    void Promise.resolve(callbacks.onHexClick(detail, event)).catch((error) => {
      logger2.error("[cartographer] hex click handler failed", error);
    });
  };
  surface.stageEl.addEventListener("hex:click", hexListener, { passive: false });
  return {
    mapHost: surface.stageEl,
    sidebarHost,
    setFileLabel: (file) => headerHandle.setFileLabel(file),
    setModes: (nextModes, activeId) => selectHandle?.setModes(nextModes, activeId),
    setOverlay: (content) => surface.setOverlay(content),
    clearMap: () => surface.stageEl.empty(),
    destroy: () => {
      surface.stageEl.removeEventListener("hex:click", hexListener);
      selectHandle?.destroy();
      headerHandle.destroy();
      surface.destroy();
      host.empty();
      host.removeClass("sm-cartographer");
    }
  };
}
function renderModeSelect(slot, initialModes, onChange) {
  slot.empty();
  slot.addClass("sm-cartographer__mode-slot");
  const selectEl = slot.createEl("select", { cls: "sm-cartographer__mode-select" });
  selectEl.setAttribute("aria-label", "Cartographer mode");
  let modes = [...initialModes];
  const sync = (list, activeId) => {
    modes = [...list];
    selectEl.empty();
    if (modes.length === 0) {
      const option = selectEl.createEl("option", { text: "Keine Modi" });
      option.disabled = true;
      option.selected = true;
      selectEl.disabled = true;
      return;
    }
    for (const mode of modes) {
      const option = selectEl.createEl("option", { text: mode.label });
      option.value = mode.id;
    }
    selectEl.disabled = false;
    const requested = activeId && modes.some((mode) => mode.id === activeId) ? activeId : modes[0]?.id ?? "";
    selectEl.value = requested ?? "";
  };
  sync(modes);
  const handleChange = () => {
    const id = selectEl.value;
    if (!id) return;
    void Promise.resolve(onChange(id)).catch((error) => {
      logger2.error("[cartographer] failed to select mode", error);
    });
  };
  selectEl.addEventListener("change", handleChange);
  return {
    setModes: (nextModes, activeId) => sync(nextModes, activeId),
    destroy: () => {
      selectEl.removeEventListener("change", handleChange);
      slot.empty();
      modes = [];
    }
  };
}

// src/workmodes/cartographer/index.ts
var VIEW_TYPE_CARTOGRAPHER = "cartographer-view";
var VIEW_CARTOGRAPHER = VIEW_TYPE_CARTOGRAPHER;
var CartographerView = class extends import_obsidian32.ItemView {
  constructor(leaf) {
    super(leaf);
    this.hostEl = null;
    this.pendingFile = null;
    this.controller = new CartographerController(this.app);
    this.callbacks = this.controller.callbacks;
  }
  getViewType() {
    return VIEW_TYPE_CARTOGRAPHER;
  }
  getDisplayText() {
    return "Cartographer";
  }
  getIcon() {
    return "compass";
  }
  setFile(file) {
    this.pendingFile = file;
    void this.controller.setFile(file ?? null);
  }
  async onOpen() {
    const container = this.containerEl;
    const content = container.children[1];
    content.empty();
    this.hostEl = content.createDiv({ cls: "cartographer-host" });
    const fallbackFile = this.pendingFile ?? this.app.workspace.getActiveFile() ?? null;
    await this.controller.onOpen(this.hostEl, fallbackFile);
  }
  async onClose() {
    await this.controller.onClose();
    this.hostEl = null;
  }
};
function getExistingCartographerLeaves(app) {
  return app.workspace.getLeavesOfType(VIEW_TYPE_CARTOGRAPHER);
}
function getOrCreateCartographerLeaf(app) {
  const existing = getExistingCartographerLeaves(app);
  if (existing.length > 0) return existing[0];
  return app.workspace.getLeaf(false) ?? app.workspace.getLeaf(true);
}
async function openCartographer(app, file) {
  const leaf = getOrCreateCartographerLeaf(app);
  await leaf.setViewState({ type: VIEW_TYPE_CARTOGRAPHER, active: true });
  app.workspace.revealLeaf(leaf);
  if (file) {
    const view = leaf.view instanceof CartographerView ? leaf.view : null;
    view?.setFile(file);
  }
}
async function detachCartographerLeaves(app) {
  const leaves = getExistingCartographerLeaves(app);
  for (const leaf of leaves) {
    await leaf.detach();
  }
}

// src/workmodes/view-manifest.ts
init_view2();
init_view();

// src/workmodes/almanac/index.ts
var import_obsidian38 = require("obsidian");
init_ui();
init_event_editor_modal();
init_plugin_logger();
var VIEW_TYPE_ALMANAC = "almanac-view";
var VIEW_ALMANAC = VIEW_TYPE_ALMANAC;
var AlmanacView = class extends import_obsidian38.ItemView {
  constructor(leaf) {
    super(leaf);
  }
  getViewType() {
    return VIEW_TYPE_ALMANAC;
  }
  getDisplayText() {
    return "Almanac";
  }
  getIcon() {
    return "calendar";
  }
  async onOpen() {
    const content = this.contentEl;
    content.empty();
    content.addClass("sm-almanac");
    this.header = createWorkmodeHeader(content, {
      title: "Almanac",
      search: {
        placeholder: "Search events\u2026",
        disabled: false,
        onChange: (query) => {
          logger2.info("[almanac] Search query changed", { query });
          if (query.trim()) {
            new import_obsidian38.Notice("Event search coming soon in a future update");
          }
        }
      },
      action: {
        label: "Add event",
        disabled: false,
        onClick: () => {
          logger2.info("[almanac] Opening event editor for new event");
          openEventEditor(this.app, {
            onSave: (event) => {
              logger2.info("[almanac] Event saved", { eventId: event.id });
              new import_obsidian38.Notice("Event saved successfully");
            }
          });
        }
      }
    });
    const mainContent = content.createDiv({ cls: "sm-almanac__content" });
    const { renderAlmanacMVP: renderAlmanacMVP2 } = await Promise.resolve().then(() => (init_almanac_mvp(), almanac_mvp_exports));
    await renderAlmanacMVP2(this.app, mainContent);
  }
  async onClose() {
    this.header?.destroy();
    this.header = void 0;
    this.contentEl.removeClass("sm-almanac");
  }
};
async function openAlmanac(app) {
  const { workspace } = app;
  const existingLeaves = workspace.getLeavesOfType(VIEW_TYPE_ALMANAC);
  if (existingLeaves.length > 0) {
    workspace.revealLeaf(existingLeaves[0]);
    return;
  }
  const leaf = workspace.getLeaf(true);
  await leaf.setViewState({ type: VIEW_TYPE_ALMANAC, active: true });
  workspace.revealLeaf(leaf);
}

// src/workmodes/session-runner/index.ts
var import_obsidian47 = require("obsidian");

// src/workmodes/session-runner/controller.ts
var import_obsidian46 = require("obsidian");
init_options();
init_map_list();
init_plugin_logger();
var createDefaultDeps2 = (app) => ({
  createMapManager: (appInstance, options) => createMapManager(appInstance, options),
  createMapLayer: (appInstance, host, file, opts) => createMapLayer(appInstance, host, file, opts),
  loadHexOptions: async (appInstance, file) => {
    const block = await getFirstHexBlock(appInstance, file);
    return block ? parseOptions(block) : null;
  },
  loadExperience: async () => {
    const { createSessionRunnerExperience: createSessionRunnerExperience2 } = await Promise.resolve().then(() => (init_experience(), experience_exports));
    return createSessionRunnerExperience2();
  }
});
var EXPERIENCE_OVERLAY_MESSAGE = "Session Runner konnte nicht initialisiert werden.";
var EXPERIENCE_NOTICE_MESSAGE = "Session Runner konnte nicht geladen werden. Bitte die Konsole pruefen.";
var SessionRunnerController = class {
  constructor(app, deps = {}) {
    this.view = null;
    this.host = null;
    this.mapManager = null;
    this.currentFile = null;
    this.requestedFile = null;
    this.currentOptions = null;
    this.mapLayer = null;
    this.isMounted = false;
    this.baseCtx = null;
    this.lifecycle = null;
    this.experience = null;
    this.app = app;
    const defaults = createDefaultDeps2(app);
    this.deps = {
      ...defaults,
      ...deps,
      loadExperience: deps.loadExperience ?? defaults.loadExperience
    };
    this.callbacks = {
      onOpen: (file) => this.mapManager?.setFile(file),
      onCreate: (file) => this.mapManager?.setFile(file),
      onDelete: () => this.mapManager?.deleteCurrent(),
      onSave: (mode, file) => this.handleSave(mode, file),
      onHexClick: (coord, event) => this.handleHexClick(coord, event)
    };
  }
  async onOpen(host, fallbackFile) {
    await this.onClose();
    this.host = host;
    this.isMounted = true;
    const initialFile = this.requestedFile ?? fallbackFile ?? null;
    this.currentFile = initialFile;
    this.requestedFile = initialFile;
    const view = createSessionRunnerView({
      app: this.app,
      host,
      initialFile,
      callbacks: this.callbacks
    });
    this.view = view;
    this.baseCtx = {
      app: this.app,
      host,
      mapHost: view.mapHost,
      sidebarHost: view.sidebarHost,
      getFile: () => this.currentFile,
      getMapLayer: () => this.mapLayer,
      getRenderHandles: () => this.mapLayer?.handles ?? null,
      getOptions: () => this.currentOptions
    };
    this.mapManager = this.deps.createMapManager(this.app, {
      initialFile,
      onChange: async (file) => {
        await this.applyCurrentFile(file);
      }
    });
    view.setFileLabel(initialFile);
    try {
      const experience = await this.ensureExperience();
      if (!this.isMounted || !this.view) {
        return;
      }
      const controller = new AbortController();
      const lifecycleCtx = this.createLifecycleContext(controller.signal);
      this.lifecycle = { controller, ctx: lifecycleCtx };
      await experience.onEnter(lifecycleCtx);
      await this.applyCurrentFile(initialFile, lifecycleCtx);
    } catch (error) {
      logger2.error("[session-runner] failed to start experience", error);
      this.view?.setOverlay(EXPERIENCE_OVERLAY_MESSAGE);
      new import_obsidian46.Notice(EXPERIENCE_NOTICE_MESSAGE);
    }
    if (this.mapManager) {
      await this.mapManager.setFile(initialFile);
    }
  }
  async onClose() {
    const lifecycle = this.lifecycle;
    const experience = this.experience;
    this.lifecycle = null;
    this.experience = experience;
    if (lifecycle) lifecycle.controller.abort();
    if (experience && lifecycle) {
      try {
        await experience.onExit(lifecycle.ctx);
      } catch (error) {
        logger2.error("[session-runner] experience exit failed", error);
      }
    }
    if (this.view) {
      this.view.destroy();
      this.view = null;
    }
    this.host = null;
    this.renderAbort?.abort();
    this.renderAbort = void 0;
    this.destroyMapLayer();
    this.currentOptions = null;
    this.mapManager = null;
    this.baseCtx = null;
    this.isMounted = false;
  }
  async setFile(file) {
    this.requestedFile = file;
    if (!this.mapManager) return;
    await this.mapManager.setFile(file);
  }
  async ensureExperience() {
    if (!this.experienceLoad) {
      this.experienceLoad = this.deps.loadExperience().then((experience2) => {
        this.experience = experience2;
        this.view?.setOverlay(null);
        return experience2;
      }).catch((error) => {
        this.experienceLoad = void 0;
        throw error;
      });
    }
    const experience = await this.experienceLoad;
    this.experience = experience;
    return experience;
  }
  createLifecycleContext(signal) {
    if (!this.baseCtx) {
      throw new Error("Session Runner context not initialised");
    }
    return { ...this.baseCtx, signal };
  }
  async applyCurrentFile(file = this.currentFile, lifecycleCtx = this.lifecycle?.ctx ?? null) {
    this.currentFile = file ?? null;
    this.requestedFile = file ?? null;
    const view = this.view;
    const ctx = lifecycleCtx;
    if (!view || !ctx || !this.experience) return;
    view.setFileLabel(this.currentFile);
    this.renderAbort?.abort();
    const controller = new AbortController();
    this.renderAbort = controller;
    const { signal } = controller;
    try {
      if (!this.currentFile) {
        this.destroyMapLayer();
        view.clearMap();
        this.currentOptions = null;
        view.setOverlay("Keine Karte ausgewaehlt.");
        await this.safeFileChange(null, null, ctx);
        return;
      }
      let options = null;
      try {
        options = await this.deps.loadHexOptions(this.app, this.currentFile);
      } catch (error) {
        logger2.error("[session-runner] failed to parse map options", error);
      }
      if (signal.aborted || !this.view) return;
      if (!options) {
        this.destroyMapLayer();
        view.clearMap();
        this.currentOptions = null;
        view.setOverlay("Kein hex3x3-Block in dieser Datei.");
        await this.safeFileChange(this.currentFile, null, ctx);
        return;
      }
      let layer = null;
      try {
        layer = await this.deps.createMapLayer(this.app, view.mapHost, this.currentFile, options);
      } catch (error) {
        logger2.error("[session-runner] failed to render map", error);
        layer = null;
      }
      if (signal.aborted || !this.view) {
        layer?.destroy();
        return;
      }
      if (!layer) {
        this.destroyMapLayer();
        view.clearMap();
        this.currentOptions = null;
        view.setOverlay("Karte konnte nicht geladen werden.");
        await this.safeFileChange(this.currentFile, null, ctx);
        return;
      }
      this.destroyMapLayer();
      this.mapLayer = layer;
      this.currentOptions = options;
      view.setOverlay(null);
      await this.safeFileChange(this.currentFile, layer.handles, ctx);
    } finally {
      if (signal.aborted) {
        this.destroyMapLayer();
        this.currentOptions = null;
        view?.clearMap();
      }
      if (this.renderAbort === controller) {
        this.renderAbort = void 0;
      }
    }
  }
  async safeFileChange(file, handles, ctx) {
    try {
      await this.experience?.onFileChange(file, handles, ctx);
    } catch (error) {
      logger2.error("[session-runner] onFileChange failed", error);
    }
  }
  async handleSave(mode, file) {
    if (!this.experience || !this.lifecycle) return false;
    try {
      if (!this.experience.onSave) return false;
      return await this.experience.onSave(mode, file, this.lifecycle.ctx) ?? false;
    } catch (error) {
      logger2.error("[session-runner] onSave failed", error);
      return false;
    }
  }
  async handleHexClick(coord, event) {
    if (!this.experience || !this.lifecycle?.ctx || !this.experience.onHexClick) return;
    try {
      await this.experience.onHexClick(coord, event, this.lifecycle.ctx);
    } catch (error) {
      logger2.error("[session-runner] onHexClick failed", error);
    }
  }
  destroyMapLayer() {
    const layer = this.mapLayer;
    this.mapLayer = null;
    if (!layer) return;
    try {
      layer.destroy();
    } catch (error) {
      logger2.error("[session-runner] failed to destroy map layer", error);
    }
  }
};
function createSessionRunnerView(options) {
  const { app, host, initialFile, callbacks } = options;
  host.empty();
  host.addClass("sm-cartographer");
  const headerHost = host.createDiv({ cls: "sm-cartographer__header" });
  const bodyHost = host.createDiv({ cls: "sm-cartographer__body" });
  const mapWrapper = bodyHost.createDiv({ cls: "sm-cartographer__map" });
  const sidebarHost = bodyHost.createDiv({ cls: "sm-cartographer__sidebar" });
  const surface = createViewContainer(mapWrapper, { camera: false });
  const headerHandle = createMapHeader(app, headerHost, {
    title: "Session Runner",
    initialFile,
    onOpen: (file) => callbacks.onOpen(file),
    onCreate: (file) => callbacks.onCreate(file),
    onDelete: (file) => callbacks.onDelete(file),
    onSave: (mode, file) => callbacks.onSave(mode, file)
  });
  const hexListener = (event) => {
    if (!(event instanceof CustomEvent)) return;
    const detail = event.detail;
    if (!detail) return;
    event.stopPropagation();
    if (event.cancelable) event.preventDefault();
    void Promise.resolve(callbacks.onHexClick(detail, event)).catch((error) => {
      logger2.error("[session-runner] hex click handler failed", error);
    });
  };
  surface.stageEl.addEventListener("hex:click", hexListener, { passive: false });
  return {
    mapHost: surface.stageEl,
    sidebarHost,
    setFileLabel: (file) => headerHandle.setFileLabel(file),
    setOverlay: (content) => surface.setOverlay(content),
    clearMap: () => surface.stageEl.empty(),
    destroy: () => {
      surface.stageEl.removeEventListener("hex:click", hexListener);
      headerHandle.destroy();
      surface.destroy();
      host.empty();
      host.removeClass("sm-cartographer");
    }
  };
}

// src/workmodes/session-runner/index.ts
var VIEW_TYPE_SESSION_RUNNER = "session-runner-view";
var VIEW_SESSION_RUNNER = VIEW_TYPE_SESSION_RUNNER;
var SessionRunnerView = class extends import_obsidian47.ItemView {
  constructor(leaf) {
    super(leaf);
    this.hostEl = null;
    this.pendingFile = null;
    this.controller = new SessionRunnerController(this.app);
    this.callbacks = this.controller.callbacks;
  }
  getViewType() {
    return VIEW_TYPE_SESSION_RUNNER;
  }
  getDisplayText() {
    return "Session Runner";
  }
  getIcon() {
    return "play";
  }
  setFile(file) {
    this.pendingFile = file;
    void this.controller.setFile(file ?? null);
  }
  async onOpen() {
    const container = this.containerEl;
    const content = container.children[1];
    content.empty();
    this.hostEl = content.createDiv({ cls: "session-runner-host" });
    const fallbackFile = this.pendingFile ?? this.app.workspace.getActiveFile() ?? null;
    await this.controller.onOpen(this.hostEl, fallbackFile);
  }
  async onClose() {
    await this.controller.onClose();
    this.hostEl = null;
  }
};
function getExistingSessionRunnerLeaves(app) {
  return app.workspace.getLeavesOfType(VIEW_TYPE_SESSION_RUNNER);
}
function getOrCreateSessionRunnerLeaf(app) {
  const existing = getExistingSessionRunnerLeaves(app);
  if (existing.length > 0) return existing[0];
  return app.workspace.getLeaf(false) ?? app.workspace.getLeaf(true);
}
async function openSessionRunner(app, file) {
  const leaf = getOrCreateSessionRunnerLeaf(app);
  await leaf.setViewState({ type: VIEW_TYPE_SESSION_RUNNER, active: true });
  app.workspace.revealLeaf(leaf);
  if (file) {
    const view = leaf.view instanceof SessionRunnerView ? leaf.view : null;
    view?.setFile(file);
  }
}

// src/workmodes/library/locations/dungeon-view.ts
var import_obsidian49 = require("obsidian");

// src/features/dungeons/rendering/grid-renderer.ts
init_types3();
var DEFAULT_OPTIONS = {
  gridWidth: 30,
  gridHeight: 20,
  cellSize: 40,
  showGrid: true,
  showCoordinates: false
};
var GridRenderer = class {
  constructor(canvas, options = {}) {
    // Transform state for zoom/pan
    this.scale = 1;
    this.offsetX = 0;
    this.offsetY = 0;
    this.minScale = 0.5;
    this.maxScale = 3;
    // Pan state
    this.isPanning = false;
    this.lastMouseX = 0;
    this.lastMouseY = 0;
    // Highlight state
    this.highlightedRoomId = null;
    this.currentDungeon = null;
    // Hover state for tooltips
    this.hoveredElement = null;
    // Token selection state
    this.selectedTokenId = null;
    // Token placement mode
    this.tokenPlacementMode = false;
    /**
     * Handle mouse wheel for zoom
     */
    this.handleWheel = (event) => {
      event.preventDefault();
      const zoomFactor = 1 + event.deltaY * -1e-3;
      const newScale = this.scale * zoomFactor;
      this.scale = Math.max(this.minScale, Math.min(this.maxScale, newScale));
      this.onTransformChange?.();
    };
    /**
     * Handle mouse down for pan start
     */
    this.handleMouseDown = (event) => {
      if (event.button === 0) {
        this.isPanning = true;
        this.lastMouseX = event.clientX;
        this.lastMouseY = event.clientY;
        this.canvas.style.cursor = "grabbing";
      }
    };
    /**
     * Handle mouse move for pan and hover detection
     */
    this.handleMouseMove = (event) => {
      if (this.isPanning) {
        const deltaX = event.clientX - this.lastMouseX;
        const deltaY = event.clientY - this.lastMouseY;
        this.offsetX += deltaX;
        this.offsetY += deltaY;
        this.lastMouseX = event.clientX;
        this.lastMouseY = event.clientY;
        this.onTransformChange?.();
      } else {
        if (!this.currentDungeon || !isDungeonLocation(this.currentDungeon)) {
          return;
        }
        const rect = this.canvas.getBoundingClientRect();
        const canvasX = event.clientX - rect.left;
        const canvasY = event.clientY - rect.top;
        const worldX = (canvasX - this.offsetX) / this.scale;
        const worldY = (canvasY - this.offsetY) / this.scale;
        const gridCoord = this.pixelToGrid(worldX, worldY);
        const token = this.findTokenAtPosition(gridCoord.x, gridCoord.y);
        const door = !token ? this.findDoorAtPosition(gridCoord.x, gridCoord.y) : null;
        const feature = !token && !door ? this.findFeatureAtPosition(gridCoord.x, gridCoord.y) : null;
        let newHover = null;
        if (token) {
          newHover = { type: "token", data: token };
        } else if (door) {
          newHover = { type: "door", data: door };
        } else if (feature) {
          newHover = { type: "feature", data: feature };
        }
        const hoverChanged = this.hoveredElement === null && newHover !== null || this.hoveredElement !== null && newHover === null || this.hoveredElement !== null && newHover !== null && (this.hoveredElement.type !== newHover.type || this.hoveredElement.type === "token" && newHover.type === "token" && this.hoveredElement.data.id !== newHover.data.id || this.hoveredElement.type === "door" && newHover.type === "door" && this.hoveredElement.data.id !== newHover.data.id || this.hoveredElement.type === "feature" && newHover.type === "feature" && this.hoveredElement.data.id !== newHover.data.id);
        if (hoverChanged) {
          this.hoveredElement = newHover;
          if (newHover) {
            if (newHover.type === "token") {
              this.onHoverChange?.({ type: "token", data: newHover.data, canvasX, canvasY });
            } else if (newHover.type === "door") {
              this.onHoverChange?.({ type: "door", data: newHover.data, canvasX, canvasY });
            } else {
              this.onHoverChange?.({ type: "feature", data: newHover.data, canvasX, canvasY });
            }
          } else {
            this.onHoverChange?.(null);
          }
        }
      }
    };
    /**
     * Handle mouse up for pan end
     */
    this.handleMouseUp = () => {
      this.isPanning = false;
      this.canvas.style.cursor = "grab";
    };
    /**
     * Handle mouse leave to clear hover state
     */
    this.handleMouseLeave = () => {
      this.isPanning = false;
      this.canvas.style.cursor = "grab";
      if (this.hoveredElement !== null) {
        this.hoveredElement = null;
        this.onHoverChange?.(null);
      }
    };
    /**
     * Handle click for room selection or token placement
     */
    this.handleClick = (event) => {
      if (!this.currentDungeon || !isDungeonLocation(this.currentDungeon)) {
        return;
      }
      const rect = this.canvas.getBoundingClientRect();
      const canvasX = event.clientX - rect.left;
      const canvasY = event.clientY - rect.top;
      const worldX = (canvasX - this.offsetX) / this.scale;
      const worldY = (canvasY - this.offsetY) / this.scale;
      const gridCoord = this.pixelToGrid(worldX, worldY);
      if (this.tokenPlacementMode) {
        this.onTokenPlace?.(gridCoord.x, gridCoord.y);
        return;
      }
      const clickedToken = this.findTokenAtPosition(gridCoord.x, gridCoord.y);
      if (clickedToken) {
        if (this.selectedTokenId === clickedToken.id) {
          this.selectedTokenId = null;
          this.onTokenSelect?.(null);
        } else {
          this.selectedTokenId = clickedToken.id;
          this.onTokenSelect?.(clickedToken);
        }
        this.onTransformChange?.();
        return;
      }
      const clickedRoom = this.findRoomAtPosition(gridCoord.x, gridCoord.y);
      let selectedRoom = null;
      if (clickedRoom) {
        if (this.highlightedRoomId === clickedRoom.id) {
          this.highlightedRoomId = null;
          selectedRoom = null;
        } else {
          this.highlightedRoomId = clickedRoom.id;
          selectedRoom = clickedRoom;
        }
      } else {
        this.highlightedRoomId = null;
        selectedRoom = null;
      }
      this.onRoomSelect?.(selectedRoom);
      this.onTransformChange?.();
    };
    this.canvas = canvas;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      throw new Error("Failed to get 2D rendering context");
    }
    this.ctx = ctx;
    this.options = { ...DEFAULT_OPTIONS, ...options };
    this.updateCanvasSize();
    this.initializeEventListeners();
  }
  /**
   * Set callback for transform changes (zoom/pan)
   */
  setOnTransformChange(callback) {
    this.onTransformChange = callback;
  }
  /**
   * Set callback for hover changes (tooltips)
   */
  setOnHoverChange(callback) {
    this.onHoverChange = callback;
  }
  /**
   * Set callback for room selection changes (detail panel)
   */
  setOnRoomSelect(callback) {
    this.onRoomSelect = callback;
  }
  /**
   * Enable/disable token placement mode
   */
  setTokenPlacementMode(enabled) {
    this.tokenPlacementMode = enabled;
  }
  /**
   * Set callback for token placement (grid coordinates)
   */
  setOnTokenPlace(callback) {
    this.onTokenPlace = callback;
  }
  /**
   * Set callback for token selection
   */
  setOnTokenSelect(callback) {
    this.onTokenSelect = callback;
  }
  /**
   * Render a dungeon location onto the canvas
   */
  render(dungeon) {
    if (!isDungeonLocation(dungeon)) {
      throw new Error("Cannot render non-dungeon location");
    }
    this.currentDungeon = dungeon;
    this.options.gridWidth = dungeon.grid_width;
    this.options.gridHeight = dungeon.grid_height;
    if (dungeon.cell_size) {
      this.options.cellSize = dungeon.cell_size;
    }
    this.updateCanvasSize();
    this.clear();
    this.ctx.save();
    this.ctx.translate(this.offsetX, this.offsetY);
    this.ctx.scale(this.scale, this.scale);
    if (this.options.showGrid) {
      this.renderGrid();
    }
    if (this.options.showCoordinates) {
      this.renderCoordinates();
    }
    if (dungeon.rooms && dungeon.rooms.length > 0) {
      this.renderRooms(dungeon.rooms);
    }
    if (dungeon.tokens && dungeon.tokens.length > 0) {
      this.renderTokens(dungeon.tokens);
    }
    if (dungeon.rooms && dungeon.rooms.length > 0) {
      for (const room of dungeon.rooms) {
        if (room.doors && room.doors.length > 0) {
          this.renderDoors(room.doors);
        }
        if (room.features && room.features.length > 0) {
          this.renderFeatures(room.features);
        }
      }
    }
    this.ctx.restore();
  }
  /**
   * Clear the canvas
   */
  clear() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = "#ffffff";
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  }
  /**
   * Update renderer options
   */
  setOptions(options) {
    this.options = { ...this.options, ...options };
    this.updateCanvasSize();
  }
  /**
   * Get current canvas dimensions
   */
  getDimensions() {
    return {
      width: this.options.gridWidth * this.options.cellSize,
      height: this.options.gridHeight * this.options.cellSize
    };
  }
  /**
   * Get current zoom scale
   */
  getScale() {
    return this.scale;
  }
  /**
   * Reset view to default (scale=1, centered)
   */
  resetView() {
    this.scale = 1;
    this.offsetX = 0;
    this.offsetY = 0;
  }
  /**
   * Destroy renderer and remove event listeners
   */
  destroy() {
    this.canvas.removeEventListener("wheel", this.handleWheel);
    this.canvas.removeEventListener("mousedown", this.handleMouseDown);
    this.canvas.removeEventListener("mousemove", this.handleMouseMove);
    this.canvas.removeEventListener("mouseup", this.handleMouseUp);
    this.canvas.removeEventListener("mouseleave", this.handleMouseLeave);
    this.canvas.removeEventListener("click", this.handleClick);
  }
  // ========================================================================
  // PRIVATE HELPERS
  // ========================================================================
  /**
   * Update canvas size based on grid dimensions
   */
  updateCanvasSize() {
    const width = this.options.gridWidth * this.options.cellSize;
    const height = this.options.gridHeight * this.options.cellSize;
    this.canvas.width = width;
    this.canvas.height = height;
    this.canvas.style.width = `${width}px`;
    this.canvas.style.height = `${height}px`;
  }
  /**
   * Render grid lines
   */
  renderGrid() {
    const { gridWidth, gridHeight, cellSize } = this.options;
    const width = gridWidth * cellSize;
    const height = gridHeight * cellSize;
    this.ctx.strokeStyle = "#d0d0d0";
    this.ctx.lineWidth = 1;
    for (let x = 0; x <= gridWidth; x++) {
      const px = x * cellSize;
      this.ctx.beginPath();
      this.ctx.moveTo(px, 0);
      this.ctx.lineTo(px, height);
      this.ctx.stroke();
    }
    for (let y = 0; y <= gridHeight; y++) {
      const py = y * cellSize;
      this.ctx.beginPath();
      this.ctx.moveTo(0, py);
      this.ctx.lineTo(width, py);
      this.ctx.stroke();
    }
  }
  /**
   * Render cell coordinate labels
   */
  renderCoordinates() {
    const { gridWidth, gridHeight, cellSize } = this.options;
    this.ctx.fillStyle = "#999999";
    this.ctx.font = "10px sans-serif";
    this.ctx.textAlign = "left";
    this.ctx.textBaseline = "top";
    for (let x = 0; x < gridWidth; x += 5) {
      for (let y = 0; y < gridHeight; y += 5) {
        const px = x * cellSize + 2;
        const py = y * cellSize + 2;
        this.ctx.fillText(`${x},${y}`, px, py);
      }
    }
  }
  /**
   * Render room boundaries and labels
   */
  renderRooms(rooms) {
    const colors = [
      "#ffd8a8",
      // Warm beige
      "#c5f6fa",
      // Light cyan
      "#d0ebff",
      // Light blue
      "#e3fafc",
      // Very light cyan
      "#fff3bf",
      // Light yellow
      "#f3f0ff",
      // Light purple
      "#ffe3e3",
      // Light pink
      "#d3f9d8"
      // Light green
    ];
    rooms.forEach((room, index) => {
      const { x, y, width, height } = room.grid_bounds;
      const pixelPos = this.gridToPixel(x, y);
      const pixelWidth = width * this.options.cellSize;
      const pixelHeight = height * this.options.cellSize;
      const isHighlighted = room.id === this.highlightedRoomId;
      this.ctx.fillStyle = isHighlighted ? "#fffacd" : colors[index % colors.length];
      this.ctx.fillRect(pixelPos.x, pixelPos.y, pixelWidth, pixelHeight);
      if (isHighlighted) {
        this.ctx.shadowColor = "#ffd700";
        this.ctx.shadowBlur = 15;
        this.ctx.strokeStyle = "#ffd700";
        this.ctx.lineWidth = 4;
      } else {
        this.ctx.shadowBlur = 0;
        this.ctx.strokeStyle = "#666666";
        this.ctx.lineWidth = 2;
      }
      this.ctx.strokeRect(pixelPos.x, pixelPos.y, pixelWidth, pixelHeight);
      this.ctx.shadowBlur = 0;
      const centerX = pixelPos.x + pixelWidth / 2;
      const centerY = pixelPos.y + pixelHeight / 2;
      this.ctx.fillStyle = "#000000";
      this.ctx.font = "bold 16px sans-serif";
      this.ctx.textAlign = "center";
      this.ctx.textBaseline = "middle";
      this.ctx.fillText(room.id, centerX, centerY);
      if (room.name && pixelHeight > 50) {
        this.ctx.font = "12px sans-serif";
        this.ctx.fillText(room.name, centerX, centerY + 20);
      }
    });
  }
  /**
   * Render door markers
   */
  renderDoors(doors) {
    doors.forEach((door) => {
      const { x, y } = door.position;
      const pixelPos = this.gridToPixel(x, y);
      const centerX = pixelPos.x + this.options.cellSize / 2;
      const centerY = pixelPos.y + this.options.cellSize / 2;
      this.ctx.font = "20px sans-serif";
      this.ctx.textAlign = "center";
      this.ctx.textBaseline = "middle";
      this.ctx.fillText("\u{1F6AA}", centerX, centerY);
      if (door.locked) {
        this.ctx.font = "12px sans-serif";
        this.ctx.fillText("\u{1F512}", centerX + 10, centerY - 10);
      }
      this.ctx.font = "10px sans-serif";
      this.ctx.fillStyle = "#000000";
      this.ctx.fillText(door.id, centerX, centerY + 15);
    });
  }
  /**
   * Render feature markers
   */
  renderFeatures(features) {
    features.forEach((feature) => {
      const { x, y } = feature.position;
      const pixelPos = this.gridToPixel(x, y);
      const centerX = pixelPos.x + this.options.cellSize / 2;
      const centerY = pixelPos.y + this.options.cellSize / 2;
      let icon = "\u{1F4E6}";
      if (feature.type === "secret") {
        icon = "\u{1F50D}";
      } else if (feature.type === "trap" || feature.type === "hazard") {
        icon = "\u26A0\uFE0F";
      } else if (feature.type === "treasure") {
        icon = "\u{1F4B0}";
      }
      this.ctx.font = "18px sans-serif";
      this.ctx.textAlign = "center";
      this.ctx.textBaseline = "middle";
      this.ctx.fillText(icon, centerX, centerY);
      const prefix = getFeatureTypePrefix(feature.type);
      this.ctx.font = "bold 10px sans-serif";
      this.ctx.fillStyle = "#000000";
      this.ctx.fillText(`${prefix}${feature.id}`, centerX, centerY + 15);
    });
  }
  /**
   * Render token markers (players, NPCs, monsters, objects)
   */
  renderTokens(tokens) {
    tokens.forEach((token) => {
      const { x, y } = token.position;
      const pixelPos = this.gridToPixel(x, y);
      const centerX = pixelPos.x + this.options.cellSize / 2;
      const centerY = pixelPos.y + this.options.cellSize / 2;
      const color = token.color || getDefaultTokenColor(token.type);
      const baseRadius = this.options.cellSize * 0.4;
      const size = token.size || 1;
      const radius = baseRadius * size;
      const isSelected = token.id === this.selectedTokenId;
      this.ctx.fillStyle = color;
      this.ctx.beginPath();
      this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      this.ctx.fill();
      if (isSelected) {
        this.ctx.shadowColor = "#ffd700";
        this.ctx.shadowBlur = 15;
        this.ctx.strokeStyle = "#ffd700";
        this.ctx.lineWidth = 4;
      } else {
        this.ctx.shadowBlur = 0;
        this.ctx.strokeStyle = "#000000";
        this.ctx.lineWidth = 2;
      }
      this.ctx.stroke();
      this.ctx.shadowBlur = 0;
      this.ctx.font = "bold 10px sans-serif";
      this.ctx.fillStyle = "#000000";
      this.ctx.textAlign = "center";
      this.ctx.textBaseline = "top";
      this.ctx.fillText(token.label, centerX, centerY + radius + 2);
    });
  }
  /**
   * Initialize event listeners for zoom/pan/click/hover
   */
  initializeEventListeners() {
    this.canvas.addEventListener("wheel", this.handleWheel);
    this.canvas.addEventListener("mousedown", this.handleMouseDown);
    this.canvas.addEventListener("mousemove", this.handleMouseMove);
    this.canvas.addEventListener("mouseup", this.handleMouseUp);
    this.canvas.addEventListener("mouseleave", this.handleMouseLeave);
    this.canvas.addEventListener("click", this.handleClick);
  }
  /**
   * Find room at grid position
   */
  findRoomAtPosition(gridX, gridY) {
    if (!this.currentDungeon || !isDungeonLocation(this.currentDungeon) || !this.currentDungeon.rooms) {
      return null;
    }
    for (const room of this.currentDungeon.rooms) {
      const { x, y, width, height } = room.grid_bounds;
      if (gridX >= x && gridX < x + width && gridY >= y && gridY < y + height) {
        return room;
      }
    }
    return null;
  }
  /**
   * Find door at grid position (searches all rooms)
   */
  findDoorAtPosition(gridX, gridY) {
    if (!this.currentDungeon || !isDungeonLocation(this.currentDungeon) || !this.currentDungeon.rooms) {
      return null;
    }
    for (const room of this.currentDungeon.rooms) {
      if (!room.doors || room.doors.length === 0) continue;
      for (const door of room.doors) {
        if (door.position.x === gridX && door.position.y === gridY) {
          return door;
        }
      }
    }
    return null;
  }
  /**
   * Find feature at grid position (searches all rooms)
   */
  findFeatureAtPosition(gridX, gridY) {
    if (!this.currentDungeon || !isDungeonLocation(this.currentDungeon) || !this.currentDungeon.rooms) {
      return null;
    }
    for (const room of this.currentDungeon.rooms) {
      if (!room.features || room.features.length === 0) continue;
      for (const feature of room.features) {
        if (feature.position.x === gridX && feature.position.y === gridY) {
          return feature;
        }
      }
    }
    return null;
  }
  /**
   * Find token at grid position
   */
  findTokenAtPosition(gridX, gridY) {
    if (!this.currentDungeon || !isDungeonLocation(this.currentDungeon) || !this.currentDungeon.tokens) {
      return null;
    }
    for (const token of this.currentDungeon.tokens) {
      if (token.position.x === gridX && token.position.y === gridY) {
        return token;
      }
    }
    return null;
  }
  /**
   * Convert grid coordinates to pixel coordinates
   */
  gridToPixel(gridX, gridY) {
    return {
      x: gridX * this.options.cellSize,
      y: gridY * this.options.cellSize
    };
  }
  /**
   * Convert pixel coordinates to grid coordinates
   */
  pixelToGrid(pixelX, pixelY) {
    return {
      x: Math.floor(pixelX / this.options.cellSize),
      y: Math.floor(pixelY / this.options.cellSize)
    };
  }
};

// src/workmodes/library/locations/dungeon-view.ts
init_types3();
init_plugin_logger();
init_frontmatter_utils();

// src/features/dungeons/ui/token-creation-modal.ts
var import_obsidian48 = require("obsidian");
init_types3();
var TokenCreationModal = class extends import_obsidian48.Modal {
  constructor(app, onSubmit, initialData) {
    super(app);
    this.onSubmit = onSubmit;
    this.tokenType = "player";
    this.tokenLabel = "";
    this.tokenColor = "";
    this.tokenSize = 1;
    this.isEditMode = false;
    if (initialData) {
      this.isEditMode = true;
      this.tokenType = initialData.type;
      this.tokenLabel = initialData.label;
      this.tokenColor = initialData.color || "";
      this.tokenSize = initialData.size || 1;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h3", { text: this.isEditMode ? "Edit Token" : "Create Token" });
    new import_obsidian48.Setting(contentEl).setName("Token Type").setDesc("Select the type of token to create").addDropdown((dropdown) => {
      dropdown.addOption("player", "\u{1F9D9} Player").addOption("npc", "\u{1F642} NPC").addOption("monster", "\u{1F479} Monster").addOption("object", "\u{1F4E6} Object").setValue(this.tokenType).onChange((value) => {
        this.tokenType = value;
        this.tokenColor = getDefaultTokenColor(this.tokenType);
        this.renderColorPreview();
      });
    });
    let labelInput;
    new import_obsidian48.Setting(contentEl).setName("Label").setDesc("Display name for the token").addText((text) => {
      text.setPlaceholder("Gandalf").setValue(this.tokenLabel).onChange((value) => {
        this.tokenLabel = value.trim();
      });
      labelInput = text.inputEl;
    });
    new import_obsidian48.Setting(contentEl).setName("Color (Optional)").setDesc("Custom color in hex format (e.g., #ff0000). Leave empty for default.").addText((text) => {
      text.setPlaceholder(getDefaultTokenColor(this.tokenType)).setValue(this.tokenColor).onChange((value) => {
        this.tokenColor = value.trim();
        this.renderColorPreview();
      });
    });
    const colorPreviewContainer = contentEl.createDiv({ cls: "sm-token-color-preview-container" });
    colorPreviewContainer.style.marginTop = "8px";
    colorPreviewContainer.style.marginBottom = "16px";
    const colorPreviewLabel = colorPreviewContainer.createSpan({ text: "Preview: " });
    colorPreviewLabel.style.fontSize = "12px";
    colorPreviewLabel.style.color = "var(--text-muted)";
    const colorPreview = colorPreviewContainer.createEl("span", { cls: "sm-token-color-preview" });
    colorPreview.style.display = "inline-block";
    colorPreview.style.width = "24px";
    colorPreview.style.height = "24px";
    colorPreview.style.borderRadius = "50%";
    colorPreview.style.border = "2px solid var(--background-modifier-border)";
    colorPreview.style.marginLeft = "8px";
    colorPreview.style.verticalAlign = "middle";
    contentEl._colorPreview = colorPreview;
    this.tokenColor = getDefaultTokenColor(this.tokenType);
    this.renderColorPreview();
    new import_obsidian48.Setting(contentEl).setName("Size").setDesc("Token size multiplier (0.5 = small, 1.0 = normal, 2.0 = large)").addSlider((slider) => {
      slider.setLimits(0.5, 2, 0.1).setValue(this.tokenSize).setDynamicTooltip().onChange((value) => {
        this.tokenSize = value;
      });
    });
    new import_obsidian48.Setting(contentEl).addButton((button) => {
      button.setButtonText("Cancel").onClick(() => {
        this.close();
      });
    }).addButton((button) => {
      button.setButtonText(this.isEditMode ? "Update Token" : "Create Token").setCta().onClick(() => {
        this.submit();
      });
    });
    this.scope.register([], "Enter", () => this.submit());
    queueMicrotask(() => labelInput?.focus());
  }
  onClose() {
    this.contentEl.empty();
  }
  renderColorPreview() {
    const colorPreview = this.contentEl._colorPreview;
    if (!colorPreview) return;
    const color = this.tokenColor || getDefaultTokenColor(this.tokenType);
    colorPreview.style.backgroundColor = color;
  }
  submit() {
    if (!this.tokenLabel) {
      return;
    }
    const data = {
      type: this.tokenType,
      label: this.tokenLabel,
      color: this.tokenColor || void 0,
      size: this.tokenSize !== 1 ? this.tokenSize : void 0
    };
    this.close();
    this.onSubmit(data);
  }
};

// src/workmodes/library/locations/dungeon-view.ts
var VIEW_TYPE_DUNGEON = "salt-dungeon-view";
var DungeonView = class extends import_obsidian49.ItemView {
  // Currently selected token
  constructor(leaf) {
    super(leaf);
    this.dungeon = null;
    this.dungeonFile = null;
    // Track the file being edited
    this.renderer = null;
    this.canvas = null;
    this.controlsContainer = null;
    this.tooltipDiv = null;
    this.detailPanel = null;
    // View options
    this.showGrid = true;
    this.showCoordinates = false;
    this.tokenPlacementMode = false;
    // Toggle for token placement mode
    this.pendingToken = null;
    // Token waiting to be placed
    this.selectedToken = null;
  }
  getViewType() {
    return VIEW_TYPE_DUNGEON;
  }
  getDisplayText() {
    return this.dungeon?.name || "Dungeon";
  }
  getIcon() {
    return "map";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("sm-dungeon-view");
    this.controlsContainer = container.createDiv({ cls: "sm-dungeon-controls" });
    this.renderControls();
    const canvasContainer = container.createDiv({ cls: "sm-dungeon-canvas-container" });
    this.canvas = canvasContainer.createEl("canvas", { cls: "sm-dungeon-canvas" });
    this.canvas.style.cursor = "grab";
    this.tooltipDiv = container.createDiv({ cls: "sm-dungeon-tooltip" });
    this.tooltipDiv.style.display = "none";
    this.tooltipDiv.style.position = "absolute";
    this.tooltipDiv.style.pointerEvents = "none";
    this.tooltipDiv.style.background = "rgba(0, 0, 0, 0.85)";
    this.tooltipDiv.style.color = "white";
    this.tooltipDiv.style.padding = "8px 12px";
    this.tooltipDiv.style.borderRadius = "4px";
    this.tooltipDiv.style.fontSize = "12px";
    this.tooltipDiv.style.zIndex = "1000";
    this.tooltipDiv.style.maxWidth = "300px";
    this.tooltipDiv.style.whiteSpace = "pre-wrap";
    this.detailPanel = container.createDiv({ cls: "sm-dungeon-detail-panel" });
    this.detailPanel.style.display = "none";
    this.detailPanel.style.position = "absolute";
    this.detailPanel.style.right = "0";
    this.detailPanel.style.top = "0";
    this.detailPanel.style.width = "300px";
    this.detailPanel.style.height = "100%";
    this.detailPanel.style.background = "var(--background-primary)";
    this.detailPanel.style.borderLeft = "1px solid var(--background-modifier-border)";
    this.detailPanel.style.padding = "16px";
    this.detailPanel.style.overflowY = "auto";
    this.detailPanel.style.zIndex = "100";
    if (this.dungeon && isDungeonLocation(this.dungeon)) {
      this.initializeRenderer();
    }
    this.registerDomEvent(document, "keydown", (event) => {
      this.handleKeyDown(event);
    });
  }
  async onClose() {
    this.renderer = null;
    this.canvas = null;
    this.controlsContainer = null;
    this.tooltipDiv = null;
    this.detailPanel = null;
    this.dungeon = null;
    this.selectedToken = null;
  }
  /**
   * Set the dungeon data to display
   */
  setDungeon(dungeon, file) {
    if (!isDungeonLocation(dungeon)) {
      logger2.error("[dungeon-view] Cannot display non-dungeon location", { type: dungeon.type });
      return;
    }
    this.dungeon = dungeon;
    this.dungeonFile = file || null;
    if (this.canvas) {
      this.initializeRenderer();
    }
  }
  /**
   * Initialize the grid renderer with current dungeon data
   */
  initializeRenderer() {
    if (!this.canvas || !this.dungeon || !isDungeonLocation(this.dungeon)) {
      return;
    }
    try {
      this.renderer = new GridRenderer(this.canvas, {
        gridWidth: this.dungeon.grid_width,
        gridHeight: this.dungeon.grid_height,
        cellSize: this.dungeon.cell_size || 40,
        showGrid: this.showGrid,
        showCoordinates: this.showCoordinates
      });
      this.renderer.setOnTransformChange(() => {
        if (this.dungeon && isDungeonLocation(this.dungeon)) {
          this.renderer?.render(this.dungeon);
          this.renderControls();
        }
      });
      this.renderer.setOnHoverChange((element) => {
        this.updateTooltip(element);
      });
      this.renderer.setOnRoomSelect((room) => {
        this.updateDetailPanel(room);
      });
      this.renderer.setOnTokenPlace((gridX, gridY) => {
        this.placeToken(gridX, gridY);
      });
      this.renderer.setOnTokenSelect((token) => {
        this.updateTokenDetail(token);
      });
      this.renderer.render(this.dungeon);
    } catch (error) {
      logger2.error("[dungeon-view] Failed to initialize renderer", error);
    }
  }
  /**
   * Render view controls (toggle buttons)
   */
  renderControls() {
    if (!this.controlsContainer) return;
    this.controlsContainer.empty();
    const gridToggle = this.controlsContainer.createEl("button", {
      cls: this.showGrid ? "sm-dungeon-control-active" : "sm-dungeon-control",
      text: "\u{1F4CF} Grid"
    });
    gridToggle.addEventListener("click", () => {
      this.showGrid = !this.showGrid;
      this.updateRenderer();
      this.renderControls();
    });
    const coordsToggle = this.controlsContainer.createEl("button", {
      cls: this.showCoordinates ? "sm-dungeon-control-active" : "sm-dungeon-control",
      text: "\u{1F522} Coordinates"
    });
    coordsToggle.addEventListener("click", () => {
      this.showCoordinates = !this.showCoordinates;
      this.updateRenderer();
      this.renderControls();
    });
    const zoomIndicator = this.controlsContainer.createEl("span", {
      cls: "sm-dungeon-zoom-indicator"
    });
    zoomIndicator.style.padding = "4px 12px";
    zoomIndicator.style.fontSize = "12px";
    zoomIndicator.style.color = "var(--text-muted)";
    zoomIndicator.style.marginLeft = "8px";
    if (this.renderer) {
      const scale = this.renderer.getScale();
      zoomIndicator.textContent = `${Math.round(scale * 100)}%`;
    } else {
      zoomIndicator.textContent = "100%";
    }
    const resetBtn = this.controlsContainer.createEl("button", {
      cls: "sm-dungeon-control",
      text: "\u{1F504} Reset View"
    });
    resetBtn.addEventListener("click", () => {
      if (this.renderer && this.dungeon && isDungeonLocation(this.dungeon)) {
        this.renderer.resetView();
        this.renderer.render(this.dungeon);
        this.renderControls();
      }
    });
    const addTokenBtn = this.controlsContainer.createEl("button", {
      cls: this.tokenPlacementMode ? "sm-dungeon-control-active" : "sm-dungeon-control",
      text: "\u2795 Add Token"
    });
    addTokenBtn.addEventListener("click", () => {
      const modal = new TokenCreationModal(this.app, (data) => {
        this.pendingToken = data;
        this.tokenPlacementMode = true;
        this.renderControls();
        if (this.renderer) {
          this.renderer.setTokenPlacementMode(true);
        }
        if (this.canvas) {
          this.canvas.style.cursor = "crosshair";
        }
        logger2.info("[dungeon-view] Token ready for placement", { token: data });
      });
      modal.open();
    });
    const exportBtn = this.controlsContainer.createEl("button", {
      cls: "sm-dungeon-control",
      text: "\u{1F4BE} Export",
      attr: { disabled: "true", title: "Coming soon" }
    });
  }
  /**
   * Update renderer options and re-render
   */
  updateRenderer() {
    if (!this.renderer || !this.dungeon || !isDungeonLocation(this.dungeon)) {
      return;
    }
    this.renderer.setOptions({
      showGrid: this.showGrid,
      showCoordinates: this.showCoordinates
    });
    this.renderer.render(this.dungeon);
  }
  /**
   * Update tooltip visibility and content based on hovered element
   */
  updateTooltip(element) {
    if (!this.tooltipDiv) return;
    if (!element) {
      this.tooltipDiv.style.display = "none";
      return;
    }
    let content = "";
    if (element.type === "token") {
      const token = element.data;
      const typeEmoji = token.type === "player" ? "\u{1F9D9}" : token.type === "npc" ? "\u{1F642}" : token.type === "monster" ? "\u{1F479}" : "\u{1F4E6}";
      content = `${typeEmoji} ${token.label}
`;
      content += `Type: ${token.type}
`;
      content += `Position: (${token.position.x}, ${token.position.y})
`;
      if (token.size && token.size !== 1) {
        content += `Size: ${token.size}x
`;
      }
      content += "\nClick to select";
    } else if (element.type === "door") {
      const door = element.data;
      content = `\u{1F6AA} Door ${door.id}
`;
      if (door.leads_to) {
        content += `Leads to: ${door.leads_to}
`;
      }
      if (door.locked) {
        content += "\u{1F512} Locked\n";
      }
      if (door.description) {
        content += `
${door.description}`;
      }
    } else if (element.type === "feature") {
      const feature = element.data;
      const typeLabel = feature.type.charAt(0).toUpperCase() + feature.type.slice(1);
      content = `${this.getFeatureIcon(feature.type)} Feature ${feature.id} (${typeLabel})
`;
      if (feature.description) {
        content += `
${feature.description}`;
      }
    }
    this.tooltipDiv.textContent = content;
    const offsetX = 15;
    const offsetY = 15;
    this.tooltipDiv.style.left = `${element.canvasX + offsetX}px`;
    this.tooltipDiv.style.top = `${element.canvasY + offsetY}px`;
    this.tooltipDiv.style.display = "block";
  }
  /**
   * Get icon for feature type
   */
  getFeatureIcon(type2) {
    switch (type2) {
      case "secret":
        return "\u{1F50D}";
      case "trap":
      case "hazard":
        return "\u26A0\uFE0F";
      case "treasure":
        return "\u{1F4B0}";
      default:
        return "\u{1F4E6}";
    }
  }
  /**
   * Update detail panel with room information
   */
  updateDetailPanel(room) {
    if (!this.detailPanel) return;
    if (!room) {
      this.detailPanel.style.display = "none";
      return;
    }
    this.detailPanel.empty();
    const header = this.detailPanel.createDiv({ cls: "sm-dungeon-detail-header" });
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.marginBottom = "16px";
    const closeBtn = header.createEl("button", { text: "\u2715", cls: "sm-dungeon-detail-close" });
    closeBtn.style.background = "none";
    closeBtn.style.border = "none";
    closeBtn.style.fontSize = "20px";
    closeBtn.style.cursor = "pointer";
    closeBtn.style.padding = "0";
    closeBtn.style.marginLeft = "auto";
    closeBtn.addEventListener("click", () => {
      this.detailPanel.style.display = "none";
      if (this.dungeon && isDungeonLocation(this.dungeon)) {
        this.renderer?.render(this.dungeon);
      }
    });
    const title = this.detailPanel.createEl("h3", { text: `Room ${room.id}` });
    title.style.marginTop = "0";
    title.style.marginBottom = "8px";
    if (room.name) {
      const subtitle = this.detailPanel.createEl("h4", { text: room.name });
      subtitle.style.marginTop = "0";
      subtitle.style.marginBottom = "16px";
      subtitle.style.color = "var(--text-muted)";
    }
    const bounds = this.detailPanel.createEl("p");
    bounds.style.fontSize = "12px";
    bounds.style.color = "var(--text-muted)";
    bounds.style.marginBottom = "16px";
    bounds.textContent = `Bounds: (${room.grid_bounds.x},${room.grid_bounds.y}) \u2192 (${room.grid_bounds.width}\xD7${room.grid_bounds.height})`;
    if (room.description) {
      const descHeader = this.detailPanel.createEl("h5", { text: "Description" });
      descHeader.style.marginTop = "16px";
      descHeader.style.marginBottom = "8px";
      const desc = this.detailPanel.createEl("p", { text: room.description });
      desc.style.marginBottom = "16px";
    }
    if (room.doors && room.doors.length > 0) {
      const doorsHeader = this.detailPanel.createEl("h5", { text: "Doors" });
      doorsHeader.style.marginTop = "16px";
      doorsHeader.style.marginBottom = "8px";
      const doorsList = this.detailPanel.createEl("ul");
      doorsList.style.marginTop = "0";
      doorsList.style.paddingLeft = "20px";
      for (const door of room.doors) {
        const doorItem = doorsList.createEl("li");
        doorItem.style.marginBottom = "8px";
        let doorText = `\u{1F6AA} ${door.id} (${door.position.x},${door.position.y})`;
        if (door.leads_to) {
          doorText += ` \u2192 ${door.leads_to}`;
        }
        if (door.locked) {
          doorText += " \u{1F512}";
        }
        doorItem.textContent = doorText;
        if (door.description) {
          const doorDesc = doorItem.createDiv();
          doorDesc.style.fontSize = "11px";
          doorDesc.style.color = "var(--text-muted)";
          doorDesc.style.marginTop = "4px";
          doorDesc.textContent = door.description;
        }
      }
    }
    if (room.features && room.features.length > 0) {
      const featuresHeader = this.detailPanel.createEl("h5", { text: "Features" });
      featuresHeader.style.marginTop = "16px";
      featuresHeader.style.marginBottom = "8px";
      const featuresList = this.detailPanel.createEl("ul");
      featuresList.style.marginTop = "0";
      featuresList.style.paddingLeft = "20px";
      for (const feature of room.features) {
        const featureItem = featuresList.createEl("li");
        featureItem.style.marginBottom = "8px";
        const icon = this.getFeatureIcon(feature.type);
        const typeLabel = feature.type.charAt(0).toUpperCase() + feature.type.slice(1);
        let featureText = `${icon} ${feature.id} (${typeLabel}, ${feature.position.x},${feature.position.y})`;
        featureItem.textContent = featureText;
        if (feature.description) {
          const featureDesc = featureItem.createDiv();
          featureDesc.style.fontSize = "11px";
          featureDesc.style.color = "var(--text-muted)";
          featureDesc.style.marginTop = "4px";
          featureDesc.textContent = feature.description;
        }
      }
    }
    this.detailPanel.style.display = "block";
  }
  /**
   * Save dungeon data back to file
   */
  async saveDungeonToFile() {
    if (!this.dungeonFile || !this.dungeon || !isDungeonLocation(this.dungeon)) {
      logger2.warn("[dungeon-view] Cannot save: no file or invalid dungeon");
      return;
    }
    try {
      const content = await this.app.vault.read(this.dungeonFile);
      const fmMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
      if (!fmMatch) {
        logger2.error("[dungeon-view] File has no frontmatter");
        return;
      }
      const [, fmText, body] = fmMatch;
      const fmLines = fmText.split("\n");
      const updatedFmLines = [];
      let inTokensArray = false;
      let tokensInserted = false;
      for (const line of fmLines) {
        if (line.startsWith("tokens:")) {
          inTokensArray = true;
          continue;
        }
        if (inTokensArray) {
          if (line.startsWith("  ") || line.startsWith("- ")) {
            continue;
          } else {
            inTokensArray = false;
            if (!tokensInserted && this.dungeon.tokens && this.dungeon.tokens.length > 0) {
              updatedFmLines.push("tokens:");
              for (const token of this.dungeon.tokens) {
                updatedFmLines.push(`  - id: ${token.id}`);
                updatedFmLines.push(`    type: ${token.type}`);
                updatedFmLines.push(`    position:`);
                updatedFmLines.push(`      x: ${token.position.x}`);
                updatedFmLines.push(`      y: ${token.position.y}`);
                updatedFmLines.push(`    label: ${token.label}`);
                if (token.color) {
                  updatedFmLines.push(`    color: ${token.color}`);
                }
                if (token.size && token.size !== 1) {
                  updatedFmLines.push(`    size: ${token.size}`);
                }
              }
              tokensInserted = true;
            }
            updatedFmLines.push(line);
          }
        } else {
          updatedFmLines.push(line);
        }
      }
      if (!tokensInserted && this.dungeon.tokens && this.dungeon.tokens.length > 0) {
        updatedFmLines.push("tokens:");
        for (const token of this.dungeon.tokens) {
          updatedFmLines.push(`  - id: ${token.id}`);
          updatedFmLines.push(`    type: ${token.type}`);
          updatedFmLines.push(`    position:`);
          updatedFmLines.push(`      x: ${token.position.x}`);
          updatedFmLines.push(`      y: ${token.position.y}`);
          updatedFmLines.push(`    label: ${token.label}`);
          if (token.color) {
            updatedFmLines.push(`    color: ${token.color}`);
          }
          if (token.size && token.size !== 1) {
            updatedFmLines.push(`    size: ${token.size}`);
          }
        }
      }
      const newContent = `---
${updatedFmLines.join("\n")}
---
${body}`;
      await this.app.vault.modify(this.dungeonFile, newContent);
      logger2.info("[dungeon-view] Dungeon saved to file", { file: this.dungeonFile.path });
    } catch (error) {
      logger2.error("[dungeon-view] Failed to save dungeon", error);
    }
  }
  /**
   * Handle keyboard shortcuts
   */
  handleKeyDown(event) {
    if (event.key === "Delete" && this.selectedToken) {
      event.preventDefault();
      this.deleteToken(this.selectedToken.id);
    }
  }
  /**
   * Update token detail view
   */
  updateTokenDetail(token) {
    if (!this.detailPanel) return;
    this.selectedToken = token;
    if (!token) {
      this.detailPanel.style.display = "none";
      return;
    }
    this.detailPanel.empty();
    const header = this.detailPanel.createDiv({ cls: "sm-dungeon-detail-header" });
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.marginBottom = "16px";
    const closeBtn = header.createEl("button", { text: "\u2715", cls: "sm-dungeon-detail-close" });
    closeBtn.style.background = "none";
    closeBtn.style.border = "none";
    closeBtn.style.fontSize = "20px";
    closeBtn.style.cursor = "pointer";
    closeBtn.style.padding = "0";
    closeBtn.style.marginLeft = "auto";
    closeBtn.addEventListener("click", () => {
      this.detailPanel.style.display = "none";
      if (this.renderer && this.dungeon && isDungeonLocation(this.dungeon)) {
        this.renderer.render(this.dungeon);
      }
    });
    const typeEmoji = token.type === "player" ? "\u{1F9D9}" : token.type === "npc" ? "\u{1F642}" : token.type === "monster" ? "\u{1F479}" : "\u{1F4E6}";
    const title = this.detailPanel.createEl("h3", { text: `${typeEmoji} ${token.label}` });
    title.style.marginTop = "0";
    title.style.marginBottom = "8px";
    const typeLabel = this.detailPanel.createEl("h4", { text: token.type.charAt(0).toUpperCase() + token.type.slice(1) });
    typeLabel.style.marginTop = "0";
    typeLabel.style.marginBottom = "16px";
    typeLabel.style.color = "var(--text-muted)";
    const position = this.detailPanel.createEl("p");
    position.style.fontSize = "12px";
    position.style.color = "var(--text-muted)";
    position.style.marginBottom = "8px";
    position.textContent = `Position: (${token.position.x}, ${token.position.y})`;
    if (token.color) {
      const colorContainer = this.detailPanel.createDiv();
      colorContainer.style.fontSize = "12px";
      colorContainer.style.color = "var(--text-muted)";
      colorContainer.style.marginBottom = "8px";
      colorContainer.style.display = "flex";
      colorContainer.style.alignItems = "center";
      const colorLabel = colorContainer.createSpan({ text: "Color: " });
      const colorSwatch = colorContainer.createEl("span");
      colorSwatch.style.display = "inline-block";
      colorSwatch.style.width = "20px";
      colorSwatch.style.height = "20px";
      colorSwatch.style.borderRadius = "50%";
      colorSwatch.style.border = "1px solid var(--background-modifier-border)";
      colorSwatch.style.marginLeft = "8px";
      colorSwatch.style.backgroundColor = token.color;
    }
    if (token.size && token.size !== 1) {
      const size = this.detailPanel.createEl("p");
      size.style.fontSize = "12px";
      size.style.color = "var(--text-muted)";
      size.style.marginBottom = "16px";
      size.textContent = `Size: ${token.size}x`;
    }
    const actionsContainer = this.detailPanel.createDiv({ cls: "sm-token-actions" });
    actionsContainer.style.marginTop = "24px";
    actionsContainer.style.display = "flex";
    actionsContainer.style.gap = "8px";
    const deleteBtn = actionsContainer.createEl("button", { text: "\u{1F5D1}\uFE0F Delete", cls: "sm-dungeon-control" });
    deleteBtn.style.flex = "1";
    deleteBtn.addEventListener("click", () => {
      this.deleteToken(token.id);
    });
    const editBtn = actionsContainer.createEl("button", { text: "\u270F\uFE0F Edit", cls: "sm-dungeon-control" });
    editBtn.style.flex = "1";
    editBtn.addEventListener("click", () => {
      this.editToken(token);
    });
    this.detailPanel.style.display = "block";
  }
  /**
   * Delete a token by ID
   */
  deleteToken(tokenId) {
    if (!this.dungeon || !isDungeonLocation(this.dungeon)) {
      logger2.warn("[dungeon-view] Cannot delete token: invalid dungeon");
      return;
    }
    if (!this.dungeon.tokens || this.dungeon.tokens.length === 0) {
      logger2.warn("[dungeon-view] Cannot delete token: no tokens");
      return;
    }
    const tokenIndex = this.dungeon.tokens.findIndex((t) => t.id === tokenId);
    if (tokenIndex === -1) {
      logger2.warn("[dungeon-view] Token not found", { tokenId });
      return;
    }
    this.dungeon.tokens.splice(tokenIndex, 1);
    logger2.info("[dungeon-view] Token deleted", { tokenId });
    this.selectedToken = null;
    if (this.detailPanel) {
      this.detailPanel.style.display = "none";
    }
    if (this.renderer) {
      this.renderer.render(this.dungeon);
    }
    this.saveDungeonToFile();
  }
  /**
   * Edit a token's properties
   */
  editToken(token) {
    if (!this.dungeon || !isDungeonLocation(this.dungeon)) {
      logger2.warn("[dungeon-view] Cannot edit token: invalid dungeon");
      return;
    }
    const modal = new TokenCreationModal(
      this.app,
      (data) => {
        const tokenIndex = this.dungeon.tokens?.findIndex((t) => t.id === token.id);
        if (tokenIndex === void 0 || tokenIndex === -1) {
          logger2.warn("[dungeon-view] Token not found for edit", { tokenId: token.id });
          return;
        }
        const updatedToken = {
          ...token,
          type: data.type,
          label: data.label,
          color: data.color,
          size: data.size
        };
        this.dungeon.tokens[tokenIndex] = updatedToken;
        logger2.info("[dungeon-view] Token updated", { token: updatedToken });
        this.selectedToken = updatedToken;
        if (this.renderer) {
          this.renderer.render(this.dungeon);
        }
        this.updateTokenDetail(updatedToken);
        this.saveDungeonToFile();
      },
      {
        type: token.type,
        label: token.label,
        color: token.color,
        size: token.size
      }
    );
    modal.open();
  }
  /**
   * Place a token at the specified grid coordinates
   */
  placeToken(gridX, gridY) {
    if (!this.pendingToken || !this.dungeon || !isDungeonLocation(this.dungeon)) {
      logger2.warn("[dungeon-view] Cannot place token: no pending token or invalid dungeon");
      return;
    }
    const existingTokens = this.dungeon.tokens || [];
    const tokenId = `token-${existingTokens.length + 1}`;
    const newToken = {
      id: tokenId,
      type: this.pendingToken.type,
      position: { x: gridX, y: gridY },
      label: this.pendingToken.label,
      color: this.pendingToken.color,
      size: this.pendingToken.size
    };
    if (!this.dungeon.tokens) {
      this.dungeon.tokens = [];
    }
    this.dungeon.tokens.push(newToken);
    logger2.info("[dungeon-view] Token placed", { token: newToken });
    this.tokenPlacementMode = false;
    this.pendingToken = null;
    if (this.renderer) {
      this.renderer.setTokenPlacementMode(false);
    }
    if (this.canvas) {
      this.canvas.style.cursor = "grab";
    }
    if (this.renderer) {
      this.renderer.render(this.dungeon);
    }
    this.renderControls();
    this.saveDungeonToFile();
  }
};

// src/workmodes/view-manifest.ts
init_events();
var VIEW_MANIFEST = [
  {
    viewType: VIEW_CARTOGRAPHER,
    integrationId: "obsidian:cartographer-view",
    displayName: "Cartographer",
    viewIcon: "compass",
    createView: (leaf) => new CartographerView(leaf),
    activation: {
      open: (app) => openCartographer(app),
      ribbon: {
        icon: "compass",
        title: "Open Cartographer"
      },
      commands: [
        {
          id: "open-cartographer",
          name: "Open Cartographer"
        }
      ]
    }
  },
  {
    viewType: VIEW_SESSION_RUNNER,
    integrationId: "obsidian:session-runner-view",
    displayName: "Session Runner",
    viewIcon: "play",
    createView: (leaf) => new SessionRunnerView(leaf),
    activation: {
      open: (app) => openSessionRunner(app),
      ribbon: {
        icon: "play",
        title: "Open Session Runner"
      },
      commands: [
        {
          id: "open-session-runner",
          name: "Open Session Runner"
        }
      ]
    }
  },
  {
    viewType: VIEW_ENCOUNTER,
    integrationId: "obsidian:encounter-view",
    displayName: "Calculator",
    viewIcon: "calculator",
    createView: (leaf) => new EncounterView(leaf),
    activation: {
      open: (app) => openEncounter(app),
      ribbon: {
        icon: "calculator",
        title: "Open Calculator"
      },
      commands: [
        {
          id: "open-encounter",
          name: "Open Calculator"
        }
      ]
    }
  },
  {
    viewType: VIEW_LIBRARY,
    integrationId: "obsidian:library-view",
    displayName: "Library",
    viewIcon: "library",
    createView: (leaf) => new LibraryView(leaf),
    activation: {
      open: (app) => openLibrary(app),
      ribbon: {
        icon: "book",
        title: "Open Library"
      },
      commands: [
        {
          id: "open-library",
          name: "Open Library"
        }
      ]
    }
  },
  {
    viewType: VIEW_ALMANAC,
    integrationId: "obsidian:almanac-view",
    displayName: "Almanac",
    viewIcon: "calendar",
    createView: (leaf) => new AlmanacView(leaf),
    activation: {
      open: (app) => openAlmanac(app),
      ribbon: {
        icon: "calendar",
        title: "Open Almanac (MVP)"
      },
      commands: [
        {
          id: "open-almanac",
          name: "Open Almanac"
        }
      ]
    }
  },
  {
    viewType: VIEW_TYPE_DUNGEON,
    integrationId: "obsidian:dungeon-view",
    displayName: "Dungeon View",
    viewIcon: "map",
    createView: (leaf) => new DungeonView(leaf)
    // No activation - opened programmatically from Library
  },
  {
    viewType: VIEW_TYPE_TIMELINE,
    integrationId: "obsidian:timeline-view",
    displayName: "Event Timeline",
    viewIcon: "clock",
    createView: (leaf) => new TimelineView(leaf, globalEventHistoryStore),
    activation: {
      open: (app) => openTimelineView(app, globalEventHistoryStore),
      ribbon: {
        icon: "clock",
        title: "Open Event Timeline"
      },
      commands: [
        {
          id: "open-event-timeline",
          name: "Open Event Timeline"
        }
      ]
    }
  }
];

// src/app/css.ts
var viewContainerCss = `
/* === View Container === */
.sm-view-container {
    position: relative;
    display: flex;
    align-items: stretch;
    justify-content: stretch;
    border-radius: 12px;
    border: 1px solid var(--background-modifier-border);
    background: var(--background-primary);
    overflow: hidden;
}

.sm-view-container__viewport {
    position: relative;
    flex: 1;
    overflow: hidden;
    cursor: grab;
    touch-action: none;
    background: color-mix(in srgb, var(--background-secondary) 90%, transparent);
}

.sm-view-container__viewport.is-panning {
    cursor: grabbing;
}

.sm-view-container__stage {
    position: relative;
    width: 100%;
    height: 100%;
    transform-origin: top left;
    display: flex;
    align-items: stretch;
    justify-content: stretch;
}

.sm-view-container__stage > * {
    flex: 1 1 auto;
}

.sm-view-container__overlay {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 1.25rem;
    background: linear-gradient(180deg, rgba(15, 23, 42, 0.45), rgba(15, 23, 42, 0.65));
    color: #fff;
    opacity: 0;
    pointer-events: none;
    transition: opacity 160ms ease;
}

.sm-view-container__overlay.is-visible {
    opacity: 1;
    pointer-events: auto;
}

.sm-view-container__overlay-message {
    max-width: 480px;
    font-size: 0.95rem;
    line-height: 1.4;
}
`;
var mapAndPreviewCss = `
/* === Map-Container & SVG === */
.hex3x3-container {
    width: 100%;
    overflow: hidden;
}

.hex3x3-map {
    display: block;
    width: 100%;
    max-width: 700px;
    margin: .5rem 0;
    user-select: none;
    touch-action: none;
}

.hex3x3-map polygon {
    /* Basis: unbemalt transparent \u2014 Inline-Styles vom Renderer d\xFCrfen das \xFCberschreiben */
    fill: transparent;
    stroke: var(--text-muted);
    stroke-width: 2;
    cursor: pointer;
    transition: fill 120ms ease, fill-opacity 120ms ease, stroke 120ms ease;
}

/* Hover: nur den Rahmen highlighten */
.hex3x3-map polygon:hover { stroke: var(--interactive-accent); }

/* Optional: Hover-F\xFCllung nur f\xFCr unbemalte Tiles */
.hex3x3-map polygon:not([data-painted="1"]):hover { fill-opacity: .15; }

.hex3x3-map text {
    font-size: 12px;
    fill: var(--text-muted);
    pointer-events: none;
    user-select: none;
}

/* Brush-Widget (Kreis) */
.hex3x3-map circle {
    transition: opacity 120ms ease, r 120ms ease, cx 60ms ease, cy 60ms ease;
}

/* === Live-Preview: Interaktion im Codeblock erlauben (optional) === */
.markdown-source-view .cm-preview-code-block .hex3x3-container,
.markdown-source-view .cm-preview-code-block .hex3x3-map { pointer-events: auto; }
.markdown-source-view .cm-preview-code-block .edit-block-button { pointer-events: none; }
`;
var terrainEditorCss = `
/* === Terrain Editor === */
.sm-terrain-editor { padding:.5rem 0; }
.sm-terrain-editor .desc { color: var(--text-muted); margin-bottom:.25rem; }
.sm-terrain-editor .rows { margin-top:.5rem; }
.sm-terrain-editor .row { display:flex; gap:.5rem; align-items:center; margin:.25rem 0; }
.sm-terrain-editor .row input[type="text"] { flex:1; min-width:0; }
.sm-terrain-editor .addbar { display:flex; gap:.5rem; margin-top:.5rem; }
.sm-terrain-editor .addbar input[type="text"] { flex:1; min-width:0; }
`;
var libraryViewCss = `
/* Creature Compendium \u2013 nutzt die gleichen Layout-Hilfsklassen */
.sm-creature-compendium { padding:.5rem 0; }
.sm-creature-compendium .desc { color: var(--text-muted); margin-bottom:.25rem; }
.sm-creature-compendium .rows { margin-top:.5rem; }
.sm-creature-compendium .row { display:flex; gap:.5rem; align-items:center; margin:.25rem 0; }
.sm-creature-compendium .row input[type="text"] { flex:1; min-width:0; }
.sm-creature-compendium .addbar { display:flex; gap:.5rem; margin-top:.5rem; }
.sm-creature-compendium .addbar input[type="text"] { flex:1; min-width:0; }

/* Creature Compendium \u2013 Search, Lists & Filters */
.sm-cc-searchbar {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: .5rem;
    margin: .5rem 0;
}
.sm-cc-searchbar > * {
    flex: 1 1 200px;
    min-width: 160px;
}
.sm-cc-searchbar button {
    flex: 0 0 auto;
}

.sm-cc-entry-filter {
    display: inline-flex;
    flex-wrap: wrap;
    align-items: center;
    gap: .35rem;
    padding: .35rem;
    margin: .35rem 0 .65rem;
    border: 1px solid var(--background-modifier-border);
    border-radius: 999px;
    background: color-mix(in srgb, var(--background-secondary) 85%, transparent);
}
.sm-cc-entry-filter button {
    border: none;
    background: transparent;
    padding: .25rem .75rem;
    border-radius: 999px;
    font-size: .85em;
    letter-spacing: .04em;
    text-transform: uppercase;
    font-weight: 600;
    color: var(--text-muted);
    cursor: pointer;
    transition: background 120ms ease, color 120ms ease, box-shadow 120ms ease;
}
.sm-cc-entry-filter button:hover {
    color: var(--text-normal);
}
.sm-cc-entry-filter button.is-active {
    background: var(--interactive-accent);
    color: var(--text-on-accent, #fff);
    box-shadow: 0 0 0 1px color-mix(in srgb, var(--interactive-accent) 55%, transparent);
}

.sm-cc-list {
    display: flex;
    flex-direction: column;
    gap: .45rem;
    margin-top: .35rem;
}
.sm-cc-item {
    display: flex;
    gap: .5rem;
    align-items: center;
    justify-content: space-between;
    padding: .45rem .65rem;
    border: 1px solid var(--background-modifier-border);
    border-radius: 10px;
    background: var(--background-primary);
    box-shadow: 0 3px 10px rgba(15, 23, 42, .04);
}
.sm-cc-item__name { font-weight: 600; }
`;
var createModalCss = `
/* Creature Creator \u2013 Modal Layout */
.modal.sm-cc-create-modal-host {
    width: min(1120px, calc(100vw - 32px));
    max-width: min(1120px, calc(100vw - 32px));
    min-width: min(880px, calc(100vw - 32px));
}
.modal.sm-cc-create-modal-host .modal-content { max-height: calc(100vh - 96px); }
.sm-cc-modal-header { display:flex; flex-direction:column; gap:.35rem; margin-bottom:1rem; }
.sm-cc-modal-header h2 { margin:0; font-size:1.35rem; }
.sm-cc-modal-subtitle { margin:0; color: var(--text-muted); font-size:.95em; }
.sm-cc-shell { display:grid; grid-template-columns:minmax(0, 260px) minmax(0, 1fr); gap:1.5rem; align-items:flex-start; }
.sm-cc-shell__nav { position:sticky; top:0; align-self:start; display:flex; flex-direction:column; gap:.75rem; padding:1rem; border:1px solid var(--background-modifier-border); border-radius:16px; background:color-mix(in srgb, var(--background-secondary) 88%, transparent); box-shadow:0 12px 28px rgba(15,23,42,.08); }
.sm-cc-shell__nav-label { margin:0; font-size:.75rem; letter-spacing:.08em; text-transform:uppercase; color:var(--text-muted); }
.sm-cc-shell__nav-list { display:flex; flex-direction:column; gap:.4rem; }
.sm-cc-shell__nav-button { display:flex; align-items:center; gap:.45rem; width:100%; padding:.45rem .75rem; border-radius:999px; border:1px solid transparent; background:transparent; color:var(--text-muted); font-size:.82rem; letter-spacing:.06em; text-transform:uppercase; font-weight:600; cursor:pointer; transition:background 160ms ease, color 160ms ease, border 160ms ease, box-shadow 160ms ease; }
.sm-cc-shell__nav-button:hover { color:var(--text-normal); }
.sm-cc-shell__nav-button:focus-visible { outline:2px solid var(--interactive-accent); outline-offset:2px; }
.sm-cc-shell__nav-button.is-active { background:var(--interactive-accent); color:var(--text-on-accent, #fff); box-shadow:0 8px 20px color-mix(in srgb, var(--interactive-accent) 35%, transparent); }
.sm-cc-shell__content { display:flex; flex-direction:column; gap:1.5rem; min-width:0; }
.sm-cc-card {
    border:1px solid var(--background-modifier-border);
    border-radius:12px;
    background:var(--background-primary);
    box-shadow:0 6px 18px rgba(0,0,0,.06);
    display:flex;
    flex-direction:column;
    overflow:hidden;
}
.sm-cc-card__head { padding:.9rem 1rem .65rem; border-bottom:1px solid var(--background-modifier-border); display:flex; flex-direction:column; gap:.35rem; }
.sm-cc-card__heading { display:flex; align-items:flex-start; gap:.65rem; justify-content:space-between; }
.sm-cc-card__title { margin:0; font-size:1.05rem; }
.sm-cc-card__subtitle { margin:0; font-size:.9em; color: var(--text-muted); }
.sm-cc-card__status {
    display: inline-flex;
    align-items: center;
    gap: .35rem;
    padding: .25rem .65rem;
    border-radius: 999px;
    font-size: .75rem;
    font-weight: 600;
    letter-spacing: .08em;
    text-transform: uppercase;
    background: color-mix(in srgb, var(--color-red, #e11d48) 12%, var(--background-secondary));
    color: color-mix(in srgb, var(--color-red, #e11d48) 85%, var(--text-normal));
    border: 1px solid color-mix(in srgb, var(--color-red, #e11d48) 45%, transparent);
    white-space: nowrap;
    transition: background 120ms ease, color 120ms ease, border 120ms ease, box-shadow 120ms ease;
}
.sm-cc-card__status::before {
    content: "!";
    font-weight: 700;
    font-size: .85em;
    line-height: 1;
}
.sm-cc-card__status[hidden] { display:none; }
.sm-cc-card__status.is-active { box-shadow:0 0 0 1px color-mix(in srgb, var(--color-red, #e11d48) 35%, transparent); }
.sm-cc-card__validation { display:none; padding:.6rem .95rem; border-top:1px solid color-mix(in srgb, var(--color-red, #e11d48) 30%, transparent); background:color-mix(in srgb, var(--color-red, #e11d48) 12%, var(--background-secondary)); color: var(--color-red, #e11d48); font-size:.9em; }
.sm-cc-card__validation.is-visible { display:block; }
.sm-cc-card__validation-list { margin:0; padding-left:1.2rem; display:flex; flex-direction:column; gap:.25rem; }
.sm-cc-card__body {
    padding: .95rem;
    display: grid;
    /* Shared grid for label alignment across all fields */
    grid-template-columns: max-content 1fr;
    column-gap: 0.8rem;
    row-gap: 0.3rem;
    align-items: start;
}

/* Multi-column layout for composite/special fields */
.sm-cc-card__body--multi-column {
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1rem 1.5rem;
}
.sm-cc-card.is-invalid { border-color: color-mix(in srgb, var(--color-red, #e11d48) 35%, transparent); box-shadow:0 0 0 1px color-mix(in srgb, var(--color-red, #e11d48) 22%, transparent) inset; }
.sm-cc-modal-footer { margin-top:1.25rem; display:flex; justify-content:flex-end; }
.sm-cc-modal-footer .setting-item { margin:0; padding:0; border:none; background:none; }
.sm-cc-modal-footer .setting-item-control { margin-left:0; display:flex; gap:.6rem; }
.sm-cc-modal-footer button { min-width:120px; }
/* Keyboard Shortcut Flash Effect */
.sm-cc-shortcut-flash {
    animation: sm-cc-flash 300ms ease-out;
}

@keyframes sm-cc-flash {
    0% {
        box-shadow: 0 0 0 0 var(--interactive-accent);
        background: var(--background-primary);
    }
    50% {
        box-shadow: 0 0 0 4px color-mix(in srgb, var(--interactive-accent) 35%, transparent);
        background: color-mix(in srgb, var(--interactive-accent) 12%, var(--background-primary));
    }
    100% {
        box-shadow: 0 0 0 0 transparent;
        background: var(--background-primary);
    }
}


/* Creature Creator \u2013 Basics Section */
.sm-cc-card--basics {
    border: 1px solid var(--background-modifier-border);
    border-radius: 12px;
    background: color-mix(in srgb, var(--background-secondary) 78%, transparent);
    box-shadow: 0 6px 18px rgba(15, 23, 42, .05);
}
.sm-cc-card--basics + .sm-cc-card--basics {
    margin-top: 1.1rem;
}
.sm-cc-card--basics .sm-cc-card__head {
    padding: .85rem .95rem .4rem;
}
.sm-cc-card--basics .sm-cc-card__title {
    font-size: .95rem;
    letter-spacing: .02em;
}
.sm-cc-card--basics .sm-cc-card__subtitle {
    margin-top: .35rem;
    font-size: .78rem;
    letter-spacing: .04em;
    text-transform: uppercase;
    color: var(--text-muted);
}
.sm-cc-card__body--basics {
    display: flex;
    flex-direction: column;
    gap: 1.35rem;
    padding: .85rem .95rem 1.15rem;
}
.sm-cc-card__section--basics {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}
.sm-cc-field-grid {
    display: grid;
    gap: .75rem;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
}
.sm-cc-field-grid--basics {
    gap: 1rem;
}
.sm-cc-field-grid--summary { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
.sm-cc-field-grid--classification { grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); }
.sm-cc-field-grid--vitals { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
.sm-cc-field-grid--speeds { grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); }
.sm-cc-field-grid--irregular { grid-template-columns: initial; }
.sm-cc-repeating-grid { display: grid; gap: .75rem; align-items: stretch; }
/* Settings within card__body become part of the shared grid */
.sm-cc-card__body > .sm-cc-setting.setting-item {
    border: none;
    padding: 0;
    margin: 0;
    background: none;
    /* Use display: contents to make children part of parent grid */
    display: contents;
}

/* Label - auto-placed by grid */
.sm-cc-card__body > .sm-cc-setting .setting-item-info {
    display: block;
    min-width: fit-content;
    max-width: max-content;
    align-self: center;
}

/* Control - auto-placed by grid */
.sm-cc-card__body > .sm-cc-setting .setting-item-control {
    margin-left: 0;
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: .45rem;
}

/* Error messages span both columns */
.sm-cc-card__body > .sm-cc-setting .sm-cc-field__errors {
    grid-column: 1 / -1;
}

/* Ensure all input elements have consistent width */
.sm-cc-card__body > .sm-cc-setting .setting-item-control select,
.sm-cc-card__body > .sm-cc-setting .setting-item-control input:not([type="checkbox"]):not([type="radio"]),
.sm-cc-card__body > .sm-cc-setting .setting-item-control textarea {
    width: 100%;
    box-sizing: border-box;
}

/* Fallback for settings not in card__body */
.sm-cc-setting.setting-item {
    border: none;
    padding: 0;
    margin: 0;
    background: none;
    display: grid;
    grid-template-columns: max-content 1fr;
    column-gap: 0.8rem;
    row-gap: 0.3rem;
    align-items: center;
}

.sm-cc-setting .setting-item-info {
    display: block;
    min-width: fit-content;
    max-width: max-content;
}

.sm-cc-setting .setting-item-control {
    margin-left: 0;
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: .45rem;
}

.sm-cc-setting .sm-cc-field__errors {
    grid-column: 1 / -1;
}

.sm-cc-field__errors-list {
    margin: 0;
    padding-left: 1.2rem;
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.sm-cc-setting--hide-label .setting-item-info { display: none; }

.sm-cc-setting .setting-item-name {
    font-weight: 600;
    font-size: .88rem;
    color: var(--text-muted);
    white-space: nowrap;
}

/* Wide fields (textarea, tags, repeating, composite) span full width */
.sm-cc-card__body > .sm-cc-setting--wide.setting-item {
    /* Override display: contents for wide fields */
    /* Increased specificity to (0,3,0) to override .sm-cc-setting.setting-item */
    display: grid;
    grid-template-columns: 1fr;
    grid-column: 1 / -1;
    gap: 0.3rem;
}

.sm-cc-card__body > .sm-cc-setting--wide.setting-item .setting-item-info {
    grid-column: 1;
    margin-bottom: 0.3rem;
}

.sm-cc-card__body > .sm-cc-setting--wide.setting-item .setting-item-control {
    grid-column: 1;
    margin-left: 0;
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: .45rem;
}

/* Special layout for tags fields - horizontal with label on left */
.sm-cc-card__body > .sm-cc-setting--tags.setting-item {
    grid-template-columns: max-content 1fr;
    align-items: start;
    gap: 0.8rem;
}

.sm-cc-card__body > .sm-cc-setting--tags.setting-item .setting-item-info {
    align-self: center;
    margin-bottom: 0;
}

.sm-cc-card__body > .sm-cc-setting--tags.setting-item .setting-item-control {
    grid-column: 2;
}

/* Special layout for structured-tags fields - horizontal with label on left */
.sm-cc-card__body > .sm-cc-setting--structured-tags.setting-item {
    grid-template-columns: max-content 1fr;
    align-items: start;
    gap: 0.8rem;
}

.sm-cc-card__body > .sm-cc-setting--structured-tags.setting-item .setting-item-info {
    align-self: center;
    margin-bottom: 0;
}

.sm-cc-card__body > .sm-cc-setting--structured-tags.setting-item .setting-item-control {
    grid-column: 2;
}

/* Fallback for wide fields not in card__body */
.sm-cc-setting--wide {
    grid-template-columns: 1fr;
    gap: 0.3rem;
}

.sm-cc-setting--wide .setting-item-info {
    margin-bottom: 0.3rem;
}

.sm-cc-setting--wide .setting-item-control {
    margin-left: 0;
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: .45rem;
}
.sm-cc-setting--textarea .setting-item-control { align-items: stretch; }
.sm-cc-setting--textarea .sm-cc-textarea { min-height: 120px; }
.sm-cc-setting--show-name .setting-item-info {
    display: block;
    min-width: max-content;
}
.sm-cc-setting--show-name .setting-item-name {
    font-size: .75rem;
    letter-spacing: .06em;
    text-transform: uppercase;
    white-space: nowrap;
    overflow: visible;
    text-overflow: clip;
    line-height: 1.25;
    max-width: none;
    width: max-content;
}
.sm-cc-setting--span-2 { grid-column: 1 / -1; }
.sm-cc-setting--stack .setting-item-control {
    gap: .6rem;
}

/* Token editor 2x2 grid layout (both simple and structured) */
/* Higher specificity to override .sm-cc-setting--wide rules */
.sm-cc-card__body > .sm-cc-setting--token-editor.setting-item,
.sm-cc-card__body > .sm-cc-setting--structured-token-editor.setting-item {
    display: grid !important;
    grid-template-columns: auto 1fr;
    grid-template-rows: auto auto;
    gap: 0.5rem 1rem;
    align-items: start;
}

.sm-cc-card__body > .sm-cc-setting--token-editor.setting-item .setting-item-info,
.sm-cc-card__body > .sm-cc-setting--structured-token-editor.setting-item .setting-item-info {
    grid-row: 1;
    grid-column: 1;
}

.sm-cc-card__body > .sm-cc-setting--token-editor.setting-item .setting-item-control,
.sm-cc-card__body > .sm-cc-setting--structured-token-editor.setting-item .setting-item-control {
    grid-row: 1;
    grid-column: 2;
    display: flex !important;
    flex-direction: row !important;
    flex-wrap: nowrap;
    gap: 0.5rem;
}

.sm-cc-card__body > .sm-cc-setting--token-editor.setting-item .setting-item-control input,
.sm-cc-card__body > .sm-cc-setting--structured-token-editor.setting-item .setting-item-control input {
    flex: 1 1 auto;
    min-width: 0;
    width: 100% !important;
}

.sm-cc-card__body > .sm-cc-setting--token-editor.setting-item .setting-item-control button,
.sm-cc-card__body > .sm-cc-setting--structured-token-editor.setting-item .setting-item-control button {
    flex-shrink: 0;
    align-self: flex-start;
}

.sm-cc-card__body > .sm-cc-setting--token-editor.setting-item .sm-cc-chips,
.sm-cc-card__body > .sm-cc-setting--structured-token-editor.setting-item .sm-cc-chips {
    grid-row: 2;
    grid-column: 2;
    margin: 0;
}

/* Fallback for token editors not in card__body */
.sm-cc-setting--token-editor,
.sm-cc-setting--structured-token-editor {
    display: grid;
    grid-template-columns: auto 1fr;
    grid-template-rows: auto auto;
    gap: 0.5rem 1rem;
    align-items: start;
}

.sm-cc-setting--token-editor .setting-item-info,
.sm-cc-setting--structured-token-editor .setting-item-info {
    grid-row: 1;
    grid-column: 1;
}

.sm-cc-setting--token-editor .setting-item-control,
.sm-cc-setting--structured-token-editor .setting-item-control {
    grid-row: 1;
    grid-column: 2;
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    gap: 0.5rem;
}

.sm-cc-setting--token-editor .sm-cc-chips,
.sm-cc-setting--structured-token-editor .sm-cc-chips {
    grid-row: 2;
    grid-column: 2;
    margin: 0;
}

.sm-cc-input {
    width: 100%;
    min-height: 34px;
    padding: .3rem .55rem;
    box-sizing: border-box;
    border-radius: 8px;
}
.sm-cc-input--small { max-width: 120px; }
.sm-cc-select {
    width: 100%;
    min-height: 34px;
    box-sizing: border-box;
    border-radius: 8px;
}
.sm-cc-textarea {
    width: 100%;
    min-height: 140px;
    resize: vertical;
    padding: .45rem .6rem;
    border-radius: 8px;
}

/* Display field (computed/read-only values) */
.sm-cc-display-field {
    width: 100%;
    min-height: 34px;
    padding: .3rem .55rem;
    box-sizing: border-box;
    border-radius: 8px;
    background: var(--background-secondary);
    color: var(--text-muted);
    text-align: center;
    font-family: var(--font-monospace);
    font-weight: 500;
    cursor: default;
    opacity: 0.9;
}

/* Conditional visibility */
.sm-cc-composite-item.is-hidden,
.sm-cc-setting.is-hidden {
    display: none !important;
}

.sm-cc-setting--alignment-override {
    border-radius: 10px;
    border: 1px dashed var(--background-modifier-border);
    background: color-mix(in srgb, var(--background-secondary) 65%, transparent);
    padding: .5rem .65rem;
}
.sm-cc-setting--alignment-override .setting-item-info { margin-bottom: .35rem; }
.sm-cc-setting--alignment-override .setting-item-control {
    width: 100%;
}
.sm-cc-input--alignment-override {
    background: transparent;
}

/* Composite field grid (for abilities, speeds, etc.) */
.sm-cc-composite-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 0.75rem 1rem;
    align-items: start;
}

/* Composite field grouped layout (keeps groups of fields together) */
.sm-cc-composite-grouped {
    display: flex;
    flex-direction: column;
    gap: 0.65rem;
}

.sm-cc-composite-group {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 0.5rem 0.75rem;
    align-items: center;
    padding: 0.5rem 0.65rem;
    border-radius: 8px;
    background: color-mix(in srgb, var(--background-secondary) 40%, transparent);
}

.sm-cc-composite-item {
    display: flex;
    flex-direction: row;
    gap: 0.5rem;
    align-items: center;
}

.sm-cc-composite-item .sm-cc-field-label {
    min-width: fit-content;
    font-size: 0.85rem;
    font-weight: 500;
    color: var(--text-muted);
    white-space: nowrap;
}

.sm-cc-composite-item .sm-cc-field-control {
    flex: 1;
    min-width: 0;
}

/* Repeating field template-based rendering */
.sm-cc-repeating-list {
    /* Wide setting to span full width */
}

.sm-cc-repeating-fields {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.sm-cc-repeating-item {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 0.5rem 0.75rem;
    align-items: center;
    padding: 0.5rem 0.65rem;
    border-radius: 8px;
    border: 1px solid var(--background-modifier-border);
    background: color-mix(in srgb, var(--background-secondary) 40%, transparent);
}

.sm-cc-repeating-field {
    display: flex;
    flex-direction: row;
    gap: 0.35rem;
    align-items: center;
    min-width: fit-content;
}

.sm-cc-repeating-field.is-hidden {
    display: none !important;
}

.sm-cc-repeating-field .sm-cc-field-label {
    min-width: fit-content;
    font-size: 0.85rem;
    font-weight: 500;
    color: var(--text-muted);
    white-space: nowrap;
}

.sm-cc-repeating-field .sm-cc-field-control {
    display: flex;
    align-items: center;
    min-width: 0;
}

.sm-cc-field-heading {
    font-weight: 600;
    font-size: 0.95rem;
    color: var(--text-normal);
    white-space: nowrap;
}

/* Display field (read-only computed values) */
.sm-cc-display-field {
    font-weight: 500;
    color: var(--text-normal);
    text-align: center;
    min-width: 2.5ch;
}

/* Clickable icon field (e.g., star for expertise/proficiency) */
.sm-cc-clickable-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2em;
    color: var(--text-muted);
    cursor: pointer;
    user-select: none;
    transition: color 0.15s ease, transform 0.1s ease;
    min-width: 1.5ch;
    text-align: center;
}

.sm-cc-clickable-icon:hover {
    color: var(--text-normal);
    transform: scale(1.15);
}

.sm-cc-clickable-icon:active {
    transform: scale(0.95);
}

.sm-cc-clickable-icon:focus-visible {
    outline: 2px solid var(--interactive-accent);
    outline-offset: 2px;
    border-radius: 4px;
}

.sm-cc-clickable-icon--active {
    color: var(--color-yellow, #facc15);
}

.sm-cc-speeds-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
}
@media (max-width: 680px) {
    .sm-cc-speeds-grid { grid-template-columns: minmax(0, 1fr); }
}
.sm-cc-speed {
    display: flex;
    flex-direction: column;
    gap: .45rem;
    padding: .55rem .6rem;
    border-radius: 10px;
    border: 1px solid var(--background-modifier-border);
    background: var(--background-primary);
    box-shadow: 0 4px 12px rgba(15, 23, 42, .04);
}
.sm-cc-speed__head {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: .5rem;
}
.sm-cc-speed__label {
    font-size: .8rem;
    font-weight: 600;
    letter-spacing: .06em;
    text-transform: uppercase;
    color: var(--text-muted);
}
.sm-cc-speed__badge {
    border: 1px solid var(--background-modifier-border);
    border-radius: 999px;
    padding: .1rem .6rem;
    font-size: .7rem;
    letter-spacing: .08em;
    text-transform: uppercase;
    background: var(--background-secondary);
    color: var(--text-muted);
    cursor: pointer;
    transition: background 120ms ease, color 120ms ease, border 120ms ease, box-shadow 120ms ease;
}
.sm-cc-speed__badge.is-active {
    background: var(--interactive-accent);
    color: var(--text-on-accent, #fff);
    border-color: color-mix(in srgb, var(--interactive-accent) 55%, transparent);
    box-shadow: 0 4px 12px color-mix(in srgb, var(--interactive-accent) 35%, transparent);
}
.sm-cc-speed__input { width: 100%; }

/* Create Creature Modal helpers */
.sm-cc-create-modal .sm-cc-grid {
    display: grid;
    grid-template-columns: max-content 140px max-content;
    gap: .35rem .75rem;
    align-items: center;
    margin: .25rem 0 .5rem;
}
.sm-cc-grid__row { display: contents; }
.sm-cc-grid__save { display: flex; align-items: center; gap: .35rem; }
.sm-cc-component-grid { display: grid; grid-template-columns: repeat(6, max-content); gap: .35rem .5rem; align-items: center; }

.sm-cc-skills { margin-top: .5rem; }
.sm-cc-skill-group { border: 1px solid var(--background-modifier-border); border-radius: 8px; padding: .5rem; margin: .35rem 0; }
.sm-cc-skill-group__title { font-weight: 600; margin-bottom: .25rem; }
.sm-cc-skill { display: grid; grid-template-columns: 1fr max-content max-content; gap: .5rem; align-items: center; margin: .15rem 0; }

.sm-cc-chips { display:flex; gap:.4rem; flex-wrap:wrap; margin:.35rem 0 .6rem; }
.sm-cc-chip {
    display:inline-flex;
    align-items:center;
    gap:.3rem;
    border:1px solid var(--background-modifier-border);
    border-radius:999px;
    padding:.2rem .6rem;
    background: color-mix(in srgb, var(--background-secondary) 80%, transparent);
    font-size:.85em;
    color: var(--text-muted);
    box-shadow:0 3px 8px rgba(15,23,42,.04);
}

/* Modular Token System - Segmented Chips with Inline Editing */
.sm-cc-chip__segment {
    display: inline-flex;
    align-items: center;
    gap: .15rem;
}

.sm-cc-chip__segment--editable {
    cursor: pointer;
    padding: .1rem .3rem;
    margin: -.1rem -.3rem;
    border-radius: 4px;
    transition: background-color 0.15s ease;
}

.sm-cc-chip__segment--editable:hover {
    background: var(--background-modifier-hover);
}

.sm-cc-chip__label {
    font-weight: 500;
    color: var(--text-normal);
    font-size: .9em;
}

.sm-cc-chip__value {
    font-weight: 400;
    color: var(--text-muted);
}

/* Inline editor inputs within chips */
.sm-cc-inline-editor {
    min-width: 40px;
    padding: .15rem .35rem;
    border: 1px solid var(--interactive-accent);
    border-radius: 3px;
    background: var(--background-primary);
    font-size: .85em;
    color: var(--text-normal);
    box-shadow: 0 0 0 2px rgba(88, 101, 242, 0.15);
}

.sm-cc-inline-editor:focus {
    outline: none;
    border-color: var(--interactive-accent);
}

.sm-cc-inline-editor--text {
    min-width: 60px;
}

.sm-cc-inline-editor--number {
    min-width: 50px;
    max-width: 80px;
}

.sm-cc-inline-editor--select {
    min-width: 80px;
    cursor: pointer;
}

.sm-cc-tag-actions {
    display: flex;
    margin-top: .5rem;
}
.sm-cc-tag-actions button {
    border: 1px dashed var(--background-modifier-border);
    border-radius: 8px;
    background: transparent;
    padding: .35rem .75rem;
    cursor: pointer;
    font-weight: 600;
}
.sm-cc-damage-row { align-items:center; }
.sm-cc-damage-type { display:inline-flex; align-items:center; gap:.35rem; flex-wrap:wrap; justify-content:flex-start; }
.sm-cc-damage-type__label { font-size:.85em; color: var(--text-muted); }
.sm-cc-damage-type__buttons { display:inline-flex; border:1px solid var(--background-modifier-border); border-radius:999px; overflow:hidden; background: var(--background-primary); }
.sm-cc-damage-type__btn { border:none; background:transparent; padding:.2rem .75rem; font-size:.85em; color: var(--text-muted); cursor:pointer; transition: background 120ms ease, color 120ms ease; }
.sm-cc-damage-type__btn:hover { color: var(--text-normal); }
.sm-cc-damage-type__btn.is-active { background: var(--interactive-accent); color: var(--text-on-accent, #fff); }
.sm-cc-damage-type__btn.is-active:hover { color: var(--text-on-accent, #fff); }
.sm-cc-damage-chips { margin-top:.25rem; }
.sm-cc-damage-chip { align-items:center; gap:.4rem; padding-right:.5rem; }
.sm-cc-damage-chip__name { font-weight:500; }
.sm-cc-damage-chip__badge { font-size:.75em; font-weight:600; border-radius:999px; padding:.1rem .45rem; text-transform:uppercase; letter-spacing:.03em; }
.sm-cc-damage-chip--res {
    border-color: rgba(37,99,235,.45);
    background-color: rgba(37,99,235,.08);
    border-color: color-mix(in srgb, var(--interactive-accent) 45%, transparent);
    background-color: color-mix(in srgb, var(--interactive-accent) 12%, var(--background-secondary));
}
.sm-cc-damage-chip--res .sm-cc-damage-chip__badge {
    background-color: rgba(37,99,235,.18);
    color:#2563eb;
    background-color: color-mix(in srgb, var(--interactive-accent) 22%, transparent);
    color: var(--interactive-accent);
}
.sm-cc-damage-chip--imm {
    border-color: rgba(124,58,237,.45);
    background-color: rgba(124,58,237,.08);
    border-color: color-mix(in srgb, var(--color-purple, #7c3aed) 45%, transparent);
    background-color: color-mix(in srgb, var(--color-purple, #7c3aed) 12%, var(--background-secondary));
}
.sm-cc-damage-chip--imm .sm-cc-damage-chip__badge {
    background-color: rgba(124,58,237,.18);
    color:#7c3aed;
    background-color: color-mix(in srgb, var(--color-purple, #7c3aed) 22%, transparent);
    color: var(--color-purple, #7c3aed);
}
.sm-cc-damage-chip--vuln {
    border-color: rgba(234,88,12,.45);
    background-color: rgba(234,88,12,.08);
    border-color: color-mix(in srgb, var(--color-orange, #ea580c) 45%, transparent);
    background-color: color-mix(in srgb, var(--color-orange, #ea580c) 12%, var(--background-secondary));
}
.sm-cc-damage-chip--vuln .sm-cc-damage-chip__badge {
    background-color: rgba(234,88,12,.18);
    color:#ea580c;
    background-color: color-mix(in srgb, var(--color-orange, #ea580c) 22%, transparent);
    color: var(--color-orange, #ea580c);
}
.sm-cc-skill-editor { display:flex; flex-direction:column; gap:.35rem; }
.sm-cc-skill-search {
    display:flex;
    align-items:center;
    justify-content:flex-end;
    margin-left:auto;
    width:100%;
    max-width:420px;
}
.sm-cc-skill-search select,
.sm-cc-skill-search .sm-sd {
    flex:1 1 260px;
    min-width:220px;
}
.sm-cc-skill-search button {
    flex:0 0 auto;
}

.sm-cc-defenses .sm-cc-senses-block {
    border-top: 1px solid var(--background-modifier-border);
    margin-top: .65rem;
    padding-top: .65rem;
}
.sm-cc-defenses .sm-cc-senses-setting .setting-item-control {
    display: flex;
    justify-content: flex-end;
}
.sm-cc-defense-summary {
    display:flex;
    align-items:center;
    flex-wrap:wrap;
    gap:.4rem;
    margin:.35rem 0 .75rem;
}
.sm-cc-defense-pill {
    display:inline-flex;
    align-items:center;
    gap:.35rem;
    border:1px solid var(--background-modifier-border);
    border-radius:999px;
    padding:.2rem .7rem;
    background: color-mix(in srgb, var(--background-secondary) 80%, transparent);
    font-size:.85em;
    color: var(--text-muted);
    box-shadow:0 3px 8px rgba(15,23,42,.05);
    transition: background 120ms ease, border-color 120ms ease, color 120ms ease, box-shadow 120ms ease;
}
.sm-cc-defense-pill__label {
    font-weight:600;
    color: var(--text-normal);
}
.sm-cc-defense-pill__count {
    font-weight:700;
    font-variant-numeric: tabular-nums;
}
.sm-cc-defense-pill.is-empty {
    opacity:.65;
}
.sm-cc-defense-pill--res {
    border-color: color-mix(in srgb, var(--interactive-accent) 45%, transparent);
    background: color-mix(in srgb, var(--interactive-accent) 12%, var(--background-secondary));
}
.sm-cc-defense-pill--res .sm-cc-defense-pill__label,
.sm-cc-defense-pill--res .sm-cc-defense-pill__count {
    color: var(--interactive-accent);
}
.sm-cc-defense-pill--imm {
    border-color: color-mix(in srgb, var(--color-purple, #7c3aed) 45%, transparent);
    background: color-mix(in srgb, var(--color-purple, #7c3aed) 12%, var(--background-secondary));
}
.sm-cc-defense-pill--imm .sm-cc-defense-pill__label,
.sm-cc-defense-pill--imm .sm-cc-defense-pill__count {
    color: var(--color-purple, #7c3aed);
}
.sm-cc-defense-pill--vuln {
    border-color: color-mix(in srgb, var(--color-orange, #ea580c) 45%, transparent);
    background: color-mix(in srgb, var(--color-orange, #ea580c) 12%, var(--background-secondary));
}
.sm-cc-defense-pill--vuln .sm-cc-defense-pill__label,
.sm-cc-defense-pill--vuln .sm-cc-defense-pill__count {
    color: var(--color-orange, #ea580c);
}
.sm-cc-defense-pill--cond {
    border-color: color-mix(in srgb, var(--color-green, #10b981) 45%, transparent);
    background: color-mix(in srgb, var(--color-green, #10b981) 12%, var(--background-secondary));
}
.sm-cc-defense-pill--cond .sm-cc-defense-pill__label,
.sm-cc-defense-pill--cond .sm-cc-defense-pill__count {
    color: var(--color-green, #10b981);
}
.sm-cc-defense-pill__empty {
    font-size:.85em;
    color: var(--text-muted);
    font-style: italic;
}
.sm-cc-defenses .sm-cc-senses-search {
    display: flex;
    align-items: center;
    gap: .35rem;
    justify-content: flex-end;
    margin-left: 0;
    width: auto;
}
.sm-cc-defenses .sm-cc-senses-search select,
.sm-cc-defenses .sm-cc-senses-search .sm-sd {
    flex: 0 0 280px;
    min-width: 280px;
    max-width: 280px;
}
.sm-cc-defenses .sm-cc-senses-search button {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: .2rem .45rem;
    min-width: 1.9rem;
    height: 1.9rem;
    border-radius: 4px;
    font-size: .85em;
    border: 1px solid var(--background-modifier-border);
    background: var(--background-secondary);
}
.sm-cc-skill-chips { gap:.45rem; }
.sm-cc-skill-chip { align-items:center; gap:.4rem; padding-right:.5rem; }
.sm-cc-skill-chip__name { font-weight:500; }
.sm-cc-skill-chip__mod { font-weight:600; color: var(--text-normal); }
.sm-cc-skill-chip__exp { display:inline-flex; align-items:center; gap:.25rem; font-size:.85em; color: var(--text-muted); }
.sm-cc-skill-chip__exp input { margin:0; }
.sm-cc-chip__remove { background:none; border:none; cursor:pointer; font-size:.85rem; line-height:1; padding:0; color: var(--text-muted); }
.sm-cc-chip__remove:hover { color: var(--text-normal); }

/* Movement Editor */
.sm-cc-movement-row { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
.sm-cc-movement-select { flex:1 1 220px; min-width:200px; }
.sm-cc-movement-distance { flex:0 0 120px; min-width:100px; }
.sm-cc-movement-hover { display:inline-flex; align-items:center; gap:.35rem; flex:0 0 auto; }
.sm-cc-movement-hover input { margin:0; }
.sm-cc-movement-add { flex:0 0 auto; margin-left:auto; }
.sm-cc-movement-chips { gap:.45rem; }
.sm-cc-movement-chip { align-items:center; gap:.4rem; padding-right:.5rem; }
.sm-cc-movement-chip__label { font-weight:600; color: var(--text-normal); }
.sm-cc-movement-chip__distance { font-weight:500; }
.sm-cc-movement-chip__badge { font-size:.75em; font-weight:600; border-radius:999px; padding:.1rem .45rem; text-transform:uppercase; letter-spacing:.03em; background-color: color-mix(in srgb, var(--interactive-accent) 18%, transparent); color: var(--interactive-accent); }

/* Creature Spellcasting \u2013 Layout & Preview */
.sm-cc-spellcasting {
    display: grid;
    gap: 1.25rem;
}
@media (min-width: 1080px) {
    .sm-cc-spellcasting {
        grid-template-columns: minmax(0, 3fr) minmax(0, 2fr);
        align-items: start;
    }
}
.sm-cc-spellcasting__ability .setting-item-control {
    gap: .65rem;
    align-items: flex-start;
}
.sm-cc-spellcasting__computed {
    display: inline-flex;
    flex-wrap: wrap;
    gap: .35rem;
    align-items: center;
    margin-top: .25rem;
}
.sm-cc-spellcasting__computed-save,
.sm-cc-spellcasting__computed-attack {
    display: inline-flex;
    align-items: center;
    gap: .3rem;
    padding: .2rem .6rem;
    border-radius: 999px;
    font-size: .75rem;
    letter-spacing: .06em;
    text-transform: uppercase;
    font-weight: 600;
    background: color-mix(in srgb, var(--background-secondary) 85%, transparent);
    border: 1px solid var(--background-modifier-border);
    color: var(--text-muted);
}
.sm-cc-spellcasting__overrides {
    display: flex;
    flex-wrap: wrap;
    gap: .5rem;
    margin-top: .35rem;
}
.sm-cc-spellcasting__overrides .sm-cc-input--small {
    flex: 0 0 120px;
}

.sm-cc-spellcasting__toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: .5rem;
    align-items: center;
    margin: .75rem 0 .5rem;
}
.sm-cc-button {
    border: 1px solid var(--background-modifier-border);
    border-radius: 999px;
    padding: .35rem .9rem;
    background: var(--background-primary);
    font-weight: 600;
    font-size: .85em;
    letter-spacing: .04em;
    text-transform: uppercase;
    cursor: pointer;
    transition: background 120ms ease, color 120ms ease, border 120ms ease, box-shadow 120ms ease;
}
.sm-cc-button:hover { color: var(--text-normal); }
.sm-cc-button:focus-visible { outline: 2px solid var(--interactive-accent); outline-offset: 1px; }

.sm-cc-spellcasting__groups {
    display: flex;
    flex-direction: column;
    gap: .85rem;
}
.sm-cc-spellcasting__groups-empty {
    border: 1px dashed var(--background-modifier-border);
    border-radius: 10px;
    padding: .75rem;
    text-align: center;
    font-size: .9em;
    color: var(--text-muted);
    background: color-mix(in srgb, var(--background-secondary) 70%, transparent);
}
.sm-cc-spellcasting__preview {
    border: 1px solid var(--background-modifier-border);
    border-radius: 12px;
    padding: 1rem;
    background: color-mix(in srgb, var(--background-secondary) 80%, transparent);
    display: flex;
    flex-direction: column;
    gap: .75rem;
}
.sm-cc-spellcasting-preview__header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: .75rem;
}
.sm-cc-spellcasting-preview__header h4 { margin: 0; }
.sm-cc-spellcasting-preview__notes {
    margin: 0;
    padding-left: 1.2rem;
    display: flex;
    flex-direction: column;
    gap: .25rem;
}
.sm-cc-spellcasting-preview__groups {
    display: flex;
    flex-direction: column;
    gap: .65rem;
}
.sm-cc-spellcasting-preview__group {
    border: 1px solid var(--background-modifier-border);
    border-radius: 10px;
    padding: .6rem .75rem;
    background: var(--background-primary);
    display: flex;
    flex-direction: column;
    gap: .35rem;
}
.sm-cc-spellcasting-preview__group h5 { margin: 0; }
.sm-cc-spellcasting-preview__group ul {
    margin: 0;
    padding-left: 1.1rem;
    display: flex;
    flex-direction: column;
    gap: .25rem;
}
.sm-cc-spellcasting-preview__note {
    font-size: .85em;
    color: var(--text-muted);
}
.sm-cc-spellcasting-preview__empty {
    font-size: .9em;
    font-style: italic;
    color: var(--text-muted);
}

/* === Spell Groups - Improved UI === */
.sm-cc-spell-group {
    border: 1px solid var(--background-modifier-border);
    border-radius: 12px;
    background: color-mix(in srgb, var(--background-secondary) 75%, transparent);
    box-shadow: 0 6px 14px rgba(15, 23, 42, .05);
    padding: .95rem;
    display: flex;
    flex-direction: column;
    gap: .75rem;
    margin-bottom: .75rem;
}

.sm-cc-spell-group--at-will {
    background: color-mix(in srgb, var(--color-green, #10b981) 8%, var(--background-secondary));
    border-color: color-mix(in srgb, var(--color-green, #10b981) 25%, transparent);
}

.sm-cc-spell-group--per-day {
    background: color-mix(in srgb, var(--color-yellow, #f59e0b) 8%, var(--background-secondary));
    border-color: color-mix(in srgb, var(--color-yellow, #f59e0b) 25%, transparent);
}

.sm-cc-spell-group--level {
    background: color-mix(in srgb, var(--interactive-accent) 8%, var(--background-secondary));
    border-color: color-mix(in srgb, var(--interactive-accent) 25%, transparent);
}

.sm-cc-spell-group-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: .75rem;
    margin-bottom: .65rem;
    padding-bottom: .65rem;
    border-bottom: 1px solid var(--background-modifier-border);
}

.sm-cc-spell-group-header-left {
    display: flex;
    align-items: center;
    gap: .5rem;
    flex: 1;
    min-width: 0;
}

.sm-cc-spell-group-header-right {
    display: flex;
    align-items: center;
    gap: .65rem;
}

.sm-cc-spell-group-separator {
    color: var(--text-muted);
    font-weight: 400;
}

.sm-cc-spell-group-suffix {
    color: var(--text-muted);
    font-size: .9em;
}

.sm-cc-spell-count {
    opacity: 0.7;
    font-size: .85em;
    font-weight: 600;
    color: var(--text-muted);
    padding: .2rem .6rem;
    border-radius: 999px;
    background: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
}

/* Spell List Styles */
.sm-cc-spellcasting-spells-list {
    display: flex;
    flex-direction: column;
    gap: .45rem;
}

.sm-cc-spell-item {
    display: flex;
    align-items: center;
    gap: .5rem;
    padding: .5rem;
    border-radius: 8px;
    border: 1px solid var(--background-modifier-border);
    background: var(--background-primary);
    transition: background 120ms ease, box-shadow 120ms ease;
}

.sm-cc-spell-item:nth-child(even) {
    background: color-mix(in srgb, var(--background-secondary) 95%, transparent);
}

.sm-cc-spell-item:hover {
    background: color-mix(in srgb, var(--background-secondary) 100%, transparent);
    box-shadow: 0 2px 8px rgba(15, 23, 42, .08);
}

.sm-cc-spellcasting-spell-input {
    flex: 1;
    min-width: 0;
    padding: .35rem .5rem;
    border-radius: 6px;
    background: transparent;
    border: 1px solid transparent;
    transition: border-color 120ms ease, background 120ms ease;
}

.sm-cc-spellcasting-spell-input:focus {
    border-color: var(--interactive-accent);
    background: var(--background-primary);
}

.sm-cc-spellcasting-spell-input::placeholder {
    color: var(--text-muted);
    opacity: 0.6;
}

.sm-cc-spell-delete {
    flex: 0 0 auto;
    border: none;
    background: transparent;
    cursor: pointer;
    font-size: 1.1rem;
    padding: .25rem .35rem;
    border-radius: 6px;
    color: var(--text-muted);
    transition: background 120ms ease, color 120ms ease;
}

.sm-cc-spell-delete:hover {
    background: color-mix(in srgb, var(--color-red, #e11d48) 15%, var(--background-secondary));
    color: var(--color-red, #e11d48);
}

/* Inline Add Spell Button */
.sm-cc-spell-add-inline {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: 2px dashed var(--background-modifier-border);
    background: transparent;
    color: var(--text-muted);
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 1.1rem;
    font-weight: 600;
    margin-top: .25rem;
    transition: all 120ms ease;
}

.sm-cc-spell-add-inline:hover {
    border-color: var(--interactive-accent);
    background: color-mix(in srgb, var(--interactive-accent) 12%, transparent);
    color: var(--interactive-accent);
    border-style: solid;
    transform: scale(1.05);
}

.sm-cc-spell-add-inline:active {
    transform: scale(0.95);
}

/* Add Group Buttons */
.sm-cc-spellcasting-add-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: .5rem;
    margin-top: .5rem;
    padding-top: .75rem;
    border-top: 1px dashed var(--background-modifier-border);
}

.sm-cc-spellcasting-groups {
    display: flex;
    flex-direction: column;
    gap: 0;
}

/* Button Small Styles */
.sm-cc-button-small {
    border: 1px solid var(--background-modifier-border);
    border-radius: 6px;
    padding: .25rem .5rem;
    background: var(--background-secondary);
    font-size: .85em;
    cursor: pointer;
    transition: all 120ms ease;
}

.sm-cc-button-small:hover {
    background: var(--interactive-accent);
    color: var(--text-on-accent, #fff);
    border-color: var(--interactive-accent);
}


/* Creature modal layout improvements */
.sm-cc-create-modal .setting-item-control { flex: 1 1 auto; min-width: 0; }
.sm-cc-create-modal textarea { width: 100%; min-height: 140px; }
.sm-cc-create-modal .sm-cc-entry-text { min-height: 180px; }
.sm-cc-create-modal .sm-cc-skill-group { width: 100%; box-sizing: border-box; }
.sm-cc-create-modal .sm-cc-searchbar { flex-wrap: wrap; }
.sm-cc-create-modal .sm-cc-searchbar > * { flex: 1 1 160px; min-width: 140px; }
.sm-cc-create-modal .sm-cc-damage-row > label,
.sm-cc-create-modal .sm-cc-damage-row .sm-cc-damage-type,
.sm-cc-create-modal .sm-cc-damage-row .sm-cc-damage-add { flex:0 0 auto; min-width:auto; }
.sm-cc-create-modal .sm-cc-damage-row .sm-cc-damage-select { flex:1 1 240px; min-width:200px; }
.sm-cc-create-modal .sm-cc-entry-grid { grid-template-columns: max-content 1fr max-content 1fr; column-gap: .75rem; row-gap: .35rem; align-items: center; }
.sm-cc-create-modal .sm-cc-entry-grid input, .sm-cc-create-modal .sm-cc-entry-grid select { width: 100%; max-width: 220px; box-sizing: border-box; }
.sm-cc-create-modal .sm-cc-entry-grid input[type="number"] { max-width: 100px; }
.sm-cc-create-modal .sm-cc-entry-grid input.sm-auto-tohit { max-width: 72px; }

/* Inline labels kept compact */
.sm-cc-create-modal label { font-size: 0.9em; color: var(--text-muted); margin-right: .25rem; }
.sm-cc-entry-head label { margin-right: .35rem; }
.sm-cc-create-modal .sm-cc-searchbar label { align-self: center; }

/* Ensure entry and spell controls stack vertically */
.sm-cc-create-modal .sm-cc-entries { display: block; }
.sm-cc-create-modal .sm-cc-entries .setting-item-info { display: block; width: 100%; margin-bottom: .35rem; }
.sm-cc-create-modal .sm-cc-entries .setting-item-control { display: flex; flex-direction: column; align-items: stretch; gap: .5rem; width: 100%; }
.sm-cc-create-modal .sm-cc-entries .sm-cc-searchbar { width: 100%; }
.sm-cc-create-modal .setting-item-control > * { max-width: 100%; }

/* Spell Creator \u2013 Validierung f\xFCr h\xF6here Grade */
.sm-cc-create-modal .setting-item.is-invalid textarea {
    border-color: color-mix(in srgb, var(--color-red, #e11d48) 35%, transparent);
    box-shadow: 0 0 0 1px color-mix(in srgb, var(--color-red, #e11d48) 25%, transparent) inset;
}
.sm-setting-validation {
    display: none;
    margin-top: .35rem;
    padding: .45rem .6rem;
    border-radius: 6px;
    background: color-mix(in srgb, var(--color-red, #e11d48) 12%, var(--background-secondary));
    color: var(--color-red, #e11d48);
    font-size: .85em;
}
.sm-setting-validation.is-visible { display: block; }
.sm-setting-validation ul {
    margin: 0;
    padding-left: 1.2rem;
    display: flex;
    flex-direction: column;
    gap: .25rem;
}

/* Entry header layout moved to styles.css */
.sm-cc-create-modal .sm-cc-entry-head select { width: auto; }
.sm-cc-create-modal .sm-cc-entry-name { width: 100%; min-width: 0; }

/* Table-like layout for Skills */
.sm-cc-create-modal .sm-cc-table { display: grid; gap: .35rem .5rem; align-items: center; }
.sm-cc-create-modal .sm-cc-row { display: contents; }
.sm-cc-create-modal .sm-cc-cell { align-self: center; }
.sm-cc-create-modal .sm-cc-header .sm-cc-cell { font-weight: 600; color: var(--text-muted); }

/* Ability score cards */
.sm-cc-create-modal .sm-cc-stats { display: flex; flex-direction: column; width: 100%; min-width: 0; }
.sm-cc-create-modal .sm-cc-stats-section { display: flex; flex-direction: column; gap: .05rem; width: 100%; box-sizing: border-box; }
.sm-cc-create-modal .sm-cc-stats-section__title { margin: 0; line-height: 1.3; }
.sm-cc-create-modal .sm-cc-stats-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); grid-auto-rows: minmax(0, auto); align-items: stretch; gap: .12rem .4rem; margin: 0; width: 100%; box-sizing: border-box; }
.sm-cc-create-modal .sm-cc-stats-col { display: flex; flex-direction: column; gap: .12rem; min-width: 0; }
.sm-cc-create-modal .sm-cc-stats-col__header { display: flex; align-items: end; justify-content: flex-end; gap: .25rem; padding: 0 0 .15rem 0; margin: 0 0 .15rem 0; font-size: .85em; color: var(--text-muted); }
.sm-cc-create-modal .sm-cc-stats-col__header-cell { display: flex; align-items: center; justify-content: flex-end; gap: .2rem; font-weight: 600; }
.sm-cc-create-modal .sm-cc-stats-col__header-cell--save { gap: .25rem; }
.sm-cc-create-modal .sm-cc-stats-col__header-save-mod { font-size: .78em; letter-spacing: .06em; text-transform: uppercase; min-width: 3ch; text-align: right; }
.sm-cc-create-modal .sm-cc-stats-col__header-save-label { font-weight: 600; }
.sm-cc-create-modal .sm-cc-stat-row { display: flex; align-items: center; gap: .15rem; padding: .18rem .28rem; border-radius: 8px; border: 1px solid var(--background-modifier-border); background: var(--background-primary); width: 100%; box-sizing: border-box; }
.sm-cc-create-modal .sm-cc-stat-row__label { flex: 0 0 2.5rem; font-weight: 600; color: var(--text-normal); }
.sm-cc-create-modal .sm-cc-stat-row__score { flex: 0 0 auto; }
.sm-cc-create-modal .sm-cc-stat-row__mod-value { font-weight: 600; color: var(--text-normal); min-width: 3ch; text-align: right; margin-left: .08rem; }
.sm-cc-create-modal .sm-cc-stat-row__save { margin-left: .08rem; display: grid; grid-auto-flow: column; grid-auto-columns: max-content; align-items: center; gap: .1rem; }
.sm-cc-create-modal .sm-cc-stat-row__save-prof { display: inline-flex; align-items: center; justify-content: center; width: 1.25rem; height: 1.25rem; font-size: .85em; color: var(--text-muted); cursor: pointer; }
.sm-cc-create-modal .sm-cc-stat-row__save-prof input[type="checkbox"] { margin: 0; }
.sm-cc-create-modal .sm-cc-stat-row__save-mod { font-weight: 600; color: var(--text-normal); min-width: 3ch; text-align: right; }
@media (max-width: 700px) {
    .sm-cc-create-modal .sm-cc-stats-grid { grid-template-columns: minmax(0, 1fr); }
}

/* Compact inline number controls */
.sm-inline-number {
    display: inline-flex;
    align-items: stretch;
    gap: 0;
}
.sm-inline-number input[type="number"] {
    width: 84px;
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
}
.sm-cc-create-modal .sm-cc-stat-row .sm-inline-number { gap: 0; }
.sm-cc-create-modal .sm-cc-stat-row .sm-inline-number input[type="number"].sm-cc-stat-row__score-input {
    width: calc(2.2ch + 10px);
    min-width: calc(2.2ch + 10px);
    text-align: center;
    padding-inline: 0;
}

/* Vertical button group for number stepper */
.sm-number-stepper-buttons {
    display: flex;
    flex-direction: column;
    align-self: stretch;
}

.sm-number-stepper-buttons button {
    flex: 1;
    min-height: 0;
    padding: 0;
    min-width: 1.5rem;
    line-height: 1;
    border-radius: 0;
    font-size: 0.85rem;
    border-left: none;
    display: flex;
    align-items: center;
    justify-content: center;
}

.sm-number-stepper-buttons button:first-child {
    border-top-right-radius: var(--radius-s);
    border-bottom: 1px solid var(--background-modifier-border);
}

.sm-number-stepper-buttons button:last-child {
    border-bottom-right-radius: var(--radius-s);
}

.btn-compact { padding: 0 .4rem; min-width: 1.5rem; height: 1.6rem; line-height: 1.2; }

/* Movement row should not overflow; children stay compact */
.sm-cc-create-modal .sm-cc-move-ctl { display: flex; flex-direction: column; align-items: stretch; gap: .35rem; }
.sm-cc-create-modal .sm-cc-move-row { display:flex; align-items:center; gap:.5rem; flex-wrap:wrap; }
.sm-cc-create-modal .sm-cc-move-row .sm-sd { flex:1 1 220px; min-width:200px; }
.sm-cc-create-modal .sm-cc-move-row select { max-width: 220px; }
.sm-cc-create-modal .sm-cc-move-hover { display:inline-flex; align-items:center; gap:.35rem; flex:0 0 auto; }
.sm-cc-create-modal .sm-cc-move-hover input { margin:0; }
.sm-cc-create-modal .sm-cc-move-row .sm-inline-number { flex:0 0 auto; }
.sm-cc-create-modal .sm-cc-move-add { margin-left:auto; flex:0 0 auto; }

/* Entry auto compute groups */
.sm-cc-create-modal .sm-cc-auto { display: flex; flex-wrap: wrap; gap: .5rem 1rem; align-items: center; }
.sm-cc-create-modal .sm-auto-group { display: inline-flex; align-items: center; gap: .35rem; flex-wrap: wrap; }
.sm-cc-create-modal .sm-auto-tohit { width: 72px; }
.sm-cc-create-modal .sm-auto-dmg { width: 220px; }

/* Select with search */
.sm-cc-create-modal .sm-select-wrap { display: flex; flex-direction: column; gap: .25rem; min-width: 0; }
.sm-cc-create-modal .sm-select-search { width: 100%; }

/* Preset typeahead menu */
.sm-cc-create-modal .sm-preset-box { position: relative; }
.sm-cc-create-modal .sm-preset-input { width: 100%; }
.sm-cc-create-modal .sm-preset-menu {
    position: absolute; left: 0; right: 0; top: calc(100% + 4px);
    background: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 8px;
    padding: .25rem;
    display: none;
    max-height: 240px; overflow: auto; z-index: 1000;
}
.sm-cc-create-modal .sm-preset-box.is-open .sm-preset-menu { display: block; }
.sm-cc-create-modal .sm-preset-item { padding: .25rem .35rem; border-radius: 6px; cursor: pointer; }
.sm-cc-create-modal .sm-preset-item:hover { background: var(--background-secondary); }

/* Such-dropdown (SearchDropdown) */
.sm-sd { position: relative; display: inline-block; width: auto; min-width: 0; }
.sm-sd__input {
    width: 100%;
    min-height: 34px;  /* Match .sm-cc-input for consistent row heights */
}
.sm-sd__menu { position: absolute; left: 0; right: 0; top: calc(100% + 4px); background: var(--background-primary); border: 1px solid var(--background-modifier-border); border-radius: 8px; padding: .25rem; display: none; max-height: 240px; overflow: auto; z-index: 1000; }
.sm-sd.is-open .sm-sd__menu { display: block; }
.sm-sd__item { padding: .25rem .35rem; border-radius: 6px; cursor: pointer; }
.sm-sd__item.is-active, .sm-sd__item:hover { background: var(--background-secondary); }

/* Creature terrain picker */
.sm-cc-create-modal .sm-cc-auto { display: flex; flex-wrap: wrap; gap: .35rem; align-items: center; }
.sm-cc-create-modal .sm-cc-auto select { min-width: 160px; }
.sm-cc-create-modal .sm-cc-auto input[type="text"] { min-width: 160px; }

/* Creature terrain picker */
.sm-cc-terrains { position: relative; }
.sm-cc-terrains__trigger {
    border: 1px solid var(--background-modifier-border);
    background: var(--background-secondary);
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    cursor: pointer;
}
.sm-cc-terrains__menu {
    position: absolute;
    top: calc(100% + 4px);
    left: 0;
    background: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 8px;
    padding: 0.35rem 0.5rem;
    display: none;
    min-width: 220px;
    max-height: 220px;
    overflow: auto;
    z-index: 1000;
}
.sm-cc-terrains.is-open .sm-cc-terrains__menu { display: block; }
.sm-cc-terrains__item { display: flex; align-items: center; gap: .5rem; padding: .15rem 0; }

/* Region Compendium */
.sm-region-compendium { padding:.5rem 0; }
.sm-region-compendium .desc { color: var(--text-muted); margin-bottom:.25rem; }
.sm-region-compendium .rows { margin-top:.5rem; }
.sm-region-compendium .row { display:flex; gap:.5rem; align-items:center; margin:.25rem 0; }
.sm-region-compendium .row input[type="text"] { flex:1; min-width:0; }
.sm-region-compendium .addbar { display:flex; gap:.5rem; margin-top:.5rem; }
.sm-region-compendium .addbar input[type="text"] { flex:1; min-width:0; }

/* Eintr\xE4ge-Abschnitt: Verbesserte Button-Gruppe zum Hinzuf\xFCgen */
.sm-cc-entry-add-bar {
    display: flex;
    align-items: center;
    gap: .75rem;
    padding: .75rem;
    margin: .5rem 0;
    border: 1px solid var(--background-modifier-border);
    border-radius: 12px;
    background: color-mix(in srgb, var(--background-secondary) 85%, transparent);
}
.sm-cc-entry-add-label {
    font-size: .85rem;
    font-weight: 600;
    letter-spacing: .04em;
    text-transform: uppercase;
    color: var(--text-muted);
}
.sm-cc-entry-add-group {
    display: flex;
    flex-wrap: wrap;
    gap: .5rem;
}
.sm-cc-entry-host {
    display: flex;
    flex-direction: column;
}
.sm-cc-entry-add-btn {
    border: 1px solid var(--background-modifier-border);
    border-radius: 999px;
    padding: .35rem .85rem;
    background: var(--background-primary);
    font-weight: 600;
    font-size: .85em;
    letter-spacing: .04em;
    cursor: pointer;
    transition: all 120ms ease;
}
.sm-cc-entry-add-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(15, 23, 42, .12);
}

/* Farbcodierung f\xFCr Kategorien */
.sm-cc-entry-add-btn--trait {
    background: color-mix(in srgb, var(--color-green, #10b981) 12%, var(--background-primary));
    border-color: color-mix(in srgb, var(--color-green, #10b981) 35%, transparent);
    color: var(--color-green, #10b981);
}
.sm-cc-entry-add-btn--trait:hover {
    background: color-mix(in srgb, var(--color-green, #10b981) 18%, var(--background-primary));
}
.sm-cc-entry-add-btn--action {
    background: color-mix(in srgb, var(--interactive-accent) 12%, var(--background-primary));
    border-color: color-mix(in srgb, var(--interactive-accent) 35%, transparent);
    color: var(--interactive-accent);
}
.sm-cc-entry-add-btn--action:hover {
    background: color-mix(in srgb, var(--interactive-accent) 18%, var(--background-primary));
}
.sm-cc-entry-add-btn--bonus {
    background: color-mix(in srgb, var(--color-yellow, #f59e0b) 12%, var(--background-primary));
    border-color: color-mix(in srgb, var(--color-yellow, #f59e0b) 35%, transparent);
    color: var(--color-yellow, #f59e0b);
}
.sm-cc-entry-add-btn--bonus:hover {
    background: color-mix(in srgb, var(--color-yellow, #f59e0b) 18%, var(--background-primary));
}
.sm-cc-entry-add-btn--reaction {
    background: color-mix(in srgb, var(--color-orange, #ea580c) 12%, var(--background-primary));
    border-color: color-mix(in srgb, var(--color-orange, #ea580c) 35%, transparent);
    color: var(--color-orange, #ea580c);
}
.sm-cc-entry-add-btn--reaction:hover {
    background: color-mix(in srgb, var(--color-orange, #ea580c) 18%, var(--background-primary));
}
.sm-cc-entry-add-btn--legendary {
    background: color-mix(in srgb, var(--color-purple, #7c3aed) 12%, var(--background-primary));
    border-color: color-mix(in srgb, var(--color-purple, #7c3aed) 35%, transparent);
    color: var(--color-purple, #7c3aed);
}
.sm-cc-entry-add-btn--legendary:hover {
    background: color-mix(in srgb, var(--color-purple, #7c3aed) 18%, var(--background-primary));
}

/* Entry-Karten: Verbesserte Struktur */
.sm-cc-entry-card {
    border: 1px solid var(--background-modifier-border);
    border-radius: 12px;
    background: var(--background-primary);
    box-shadow: 0 4px 12px rgba(15, 23, 42, .06);
    padding: .85rem;
    margin: .65rem 0;
    display: flex;
    flex-direction: column;
    gap: .75rem;
}

.sm-cc-entry-card.sm-cc-entry-hidden {
    display: none;
}

/* Entry head styling moved to styles.css for better control */
.sm-cc-entry-badge {
    display: inline-flex;
    align-items: center;
    padding: .25rem .75rem;
    border-radius: 999px;
    font-size: .75rem;
    font-weight: 600;
    letter-spacing: .06em;
    text-transform: uppercase;
    border: 1px solid;
}
.sm-cc-entry-badge--trait {
    background: color-mix(in srgb, var(--color-green, #10b981) 12%, var(--background-secondary));
    color: var(--color-green, #10b981);
    border-color: color-mix(in srgb, var(--color-green, #10b981) 35%, transparent);
}
.sm-cc-entry-badge--action {
    background: color-mix(in srgb, var(--interactive-accent) 12%, var(--background-secondary));
    color: var(--interactive-accent);
    border-color: color-mix(in srgb, var(--interactive-accent) 35%, transparent);
}
.sm-cc-entry-badge--bonus {
    background: color-mix(in srgb, var(--color-yellow, #f59e0b) 12%, var(--background-secondary));
    color: var(--color-yellow, #f59e0b);
    border-color: color-mix(in srgb, var(--color-yellow, #f59e0b) 35%, transparent);
}
.sm-cc-entry-badge--reaction {
    background: color-mix(in srgb, var(--color-orange, #ea580c) 12%, var(--background-secondary));
    color: var(--color-orange, #ea580c);
    border-color: color-mix(in srgb, var(--color-orange, #ea580c) 35%, transparent);
}
.sm-cc-entry-badge--legendary {
    background: color-mix(in srgb, var(--color-purple, #7c3aed) 12%, var(--background-secondary));
    color: var(--color-purple, #7c3aed);
    border-color: color-mix(in srgb, var(--color-purple, #7c3aed) 35%, transparent);
}
.sm-cc-entry-name-box {
    position: relative;
    flex: 1;
    min-width: 0;
}
.sm-cc-entry-name {
    width: 100%;
    min-width: 0;
    padding: .35rem .55rem;
    border-radius: 8px;
    border: 1px solid var(--background-modifier-border);
    font-weight: 600;
}
.sm-cc-entry-name-box .sm-preset-menu {
    min-width: 320px;
}
.sm-cc-entry-delete {
    border: none;
    background: transparent;
    cursor: pointer;
    font-size: 1.1rem;
    padding: .25rem .35rem;
    border-radius: 6px;
    transition: background 120ms ease;
}
.sm-cc-entry-delete:hover {
    background: color-mix(in srgb, var(--color-red, #e11d48) 12%, var(--background-secondary));
}
.sm-cc-entry-section {
    display: flex;
    flex-direction: column;
    gap: .5rem;
    padding: .5rem;
    border-radius: 8px;
    background: color-mix(in srgb, var(--background-secondary) 65%, transparent);
}
.sm-cc-entry-section--details {
    background: transparent;
    padding: 0;
}
.sm-cc-entry-grid {
    display: grid;
    grid-template-columns: max-content 1fr;
    column-gap: .75rem;
    row-gap: .45rem;
    align-items: center;
}
.sm-cc-entry-grid label {
    font-size: .85em;
    color: var(--text-muted);
    font-weight: 600;
}
.sm-cc-entry-input {
    width: 100%;
    padding: .3rem .5rem;
    border-radius: 6px;
}
.sm-cc-entry-label {
    font-size: .85em;
    font-weight: 600;
    color: var(--text-muted);
    margin-bottom: .25rem;
}
.sm-cc-entry-text {
    width: 100%;
    min-height: 140px;
    resize: vertical;
    padding: .45rem .55rem;
    border-radius: 8px;
}

/* === Entry Section Collapsible Functionality === */
/* Entry Section Headers for Collapsible functionality */
.sm-cc-entry-section-header {
    font-size: .85em;
    font-weight: 600;
    color: var(--text-muted);
    margin-bottom: .5rem;
    padding: .35rem .5rem;
    border-radius: 6px;
    background: color-mix(in srgb, var(--background-secondary) 85%, transparent);
    transition: background 120ms ease;
}

/* Collapsible section styles */
.sm-cc-section--collapsible .sm-cc-entry-section-header {
    cursor: pointer;
    user-select: none;
}

.sm-cc-section--collapsible .sm-cc-entry-section-header:hover {
    background: color-mix(in srgb, var(--background-secondary) 95%, transparent);
}

.sm-cc-section--collapsible .section-header {
    display: flex;
    align-items: center;
    gap: .5rem;
}

.sm-cc-section--collapsed .section-content {
    display: none;
}

.sm-cc-section--collapsible .section-chevron {
    transition: transform 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
}

.sm-cc-section--collapsed .section-chevron {
    transform: rotate(-90deg);
}

.sm-cc-section--collapsible .section-header-text {
    flex: 1;
}


/* === Entry Type Color Coding === */
/* Entry type row styling */
.sm-cc-entry-type-row {
    display: flex;
    align-items: center;
    gap: .5rem;
    padding: .5rem;
    border-radius: 8px;
    background: color-mix(in srgb, var(--background-secondary) 75%, transparent);
    margin-bottom: .35rem;
}

.sm-cc-entry-type-label {
    font-size: .85em;
    font-weight: 600;
    color: var(--text-muted);
}

.sm-cc-entry-type-select {
    flex: 1;
    min-width: 180px;
}

/* Entry type badges */
.sm-cc-entry-type-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: .2rem .6rem;
    border-radius: 999px;
    font-size: .7rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: .06em;
    margin-left: auto;
    opacity: 0.85;
    transition: opacity 120ms ease, transform 120ms ease;
}

.sm-cc-entry-type-badge:hover {
    opacity: 1;
    transform: scale(1.05);
}

/* Entry type: Passive */
.sm-cc-entry-card--type-passive {
    border-left: 3px solid color-mix(in srgb, var(--text-muted) 75%, transparent);
}

.sm-cc-entry-type-badge--passive {
    background: color-mix(in srgb, var(--text-muted) 18%, var(--background-secondary));
    color: var(--text-muted);
}

/* Entry type: Attack */
.sm-cc-entry-card--type-attack {
    border-left: 3px solid color-mix(in srgb, var(--color-red, #dc3545) 85%, transparent);
    background: linear-gradient(90deg, color-mix(in srgb, var(--color-red, #dc3545) 4%, transparent) 0%, transparent 100%);
}

.sm-cc-entry-type-badge--attack {
    background: color-mix(in srgb, var(--color-red, #dc3545) 18%, var(--background-secondary));
    color: var(--color-red, #dc3545);
}

/* Entry type: Save Action */
.sm-cc-entry-card--type-save-action {
    border-left: 3px solid color-mix(in srgb, var(--color-orange, #fd7e14) 85%, transparent);
    background: linear-gradient(90deg, color-mix(in srgb, var(--color-orange, #fd7e14) 4%, transparent) 0%, transparent 100%);
}

.sm-cc-entry-type-badge--save-action {
    background: color-mix(in srgb, var(--color-orange, #fd7e14) 18%, var(--background-secondary));
    color: var(--color-orange, #fd7e14);
}

/* Entry type: Multiattack */
.sm-cc-entry-card--type-multiattack {
    border-left: 3px solid color-mix(in srgb, var(--color-purple, #6f42c1) 85%, transparent);
    background: linear-gradient(90deg, color-mix(in srgb, var(--color-purple, #6f42c1) 4%, transparent) 0%, transparent 100%);
}

.sm-cc-entry-type-badge--multiattack {
    background: color-mix(in srgb, var(--color-purple, #6f42c1) 18%, var(--background-secondary));
    color: var(--color-purple, #6f42c1);
}

/* Entry type: Spellcasting */
.sm-cc-entry-card--type-spellcasting {
    border-left: 3px solid color-mix(in srgb, var(--interactive-accent, #0d6efd) 85%, transparent);
    background: linear-gradient(90deg, color-mix(in srgb, var(--interactive-accent, #0d6efd) 4%, transparent) 0%, transparent 100%);
}

.sm-cc-entry-type-badge--spellcasting {
    background: color-mix(in srgb, var(--interactive-accent, #0d6efd) 18%, var(--background-secondary));
    color: var(--interactive-accent, #0d6efd);
}

/* Dark theme adjustments */
.theme-dark .sm-cc-entry-card--type-attack,
.theme-dark .sm-cc-entry-card--type-save-action,
.theme-dark .sm-cc-entry-card--type-multiattack,
.theme-dark .sm-cc-entry-card--type-spellcasting {
    background: linear-gradient(90deg, color-mix(in srgb, currentColor 6%, transparent) 0%, transparent 100%);
}

/* Ensure text readability on colored cards */
.sm-cc-entry-card--type-attack .sm-cc-entry-name,
.sm-cc-entry-card--type-save-action .sm-cc-entry-name,
.sm-cc-entry-card--type-multiattack .sm-cc-entry-name,
.sm-cc-entry-card--type-spellcasting .sm-cc-entry-name {
    background: var(--background-primary);
}

/* Entry card action buttons */
.sm-cc-entry-actions {
    display: flex;
    align-items: center;
    gap: .35rem;
}

.sm-cc-entry-move-btn {
    border: 1px solid var(--background-modifier-border);
    background: var(--background-secondary);
    cursor: pointer;
    font-size: .9rem;
    padding: .25rem .35rem;
    border-radius: 6px;
    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 1.8rem;
    min-height: 1.8rem;
}

.sm-cc-entry-move-btn:hover:not(:disabled) {
    background: var(--interactive-accent);
    color: var(--text-on-accent, #fff);
    border-color: var(--interactive-accent);
}

.sm-cc-entry-move-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
}

.sm-cc-entry-move-btn svg {
    width: 14px;
    height: 14px;
}


`;
var cartographerShellCss = `
/* === Cartographer Shell === */
.cartographer-host {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.sm-cartographer {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    width: 100%;
    height: 100%;
    min-height: 100%;
    gap: 1rem;
    padding: 1rem;
    box-sizing: border-box;
}

.sm-cartographer__header {
    padding-bottom: 0.25rem;
}

.sm-cartographer__header .sm-map-header {
    background: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 10px;
    padding: 0.75rem;
    gap: 0.5rem;
}

.sm-cartographer__header .sm-map-header h2 {
    margin: 0;
}

.sm-cartographer__header .sm-map-header .sm-map-header__secondary-left {
    margin-left: auto;
    margin-right: 0;
}

.sm-cartographer__body {
    display: flex;
    flex: 1 1 auto;
    gap: 1.25rem;
    align-items: stretch;
    width: 100%;
    min-height: 0;
}

.sm-cartographer__map {
    flex: 1 1 auto;
    min-width: 0;
    min-height: 0;
    position: relative;
    border: 1px solid var(--background-modifier-border);
    border-radius: 10px;
    background: var(--background-primary);
    padding: 0.75rem;
    box-sizing: border-box;
}

.sm-cartographer__map .sm-view-container {
    width: 100%;
    height: 100%;
}

.sm-cartographer__map .hex3x3-map {
    height: 100%;
    max-width: none;
}

.sm-cartographer__sidebar {
    flex: 0 0 280px;
    max-width: 320px;
    background: var(--background-secondary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 10px;
    padding: 1rem;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.sm-cartographer__mode-switch {
    display: inline-flex;
    gap: 0.4rem;
    align-items: center;
}

.sm-cartographer__mode-switch button {
    border: 1px solid var(--background-modifier-border);
    background: var(--background-secondary);
    padding: 0.25rem 0.75rem;
    border-radius: 6px;
    cursor: pointer;
    transition: background 120ms ease, color 120ms ease;
}

.sm-cartographer__mode-switch button.is-active {
    background: var(--interactive-accent, var(--color-accent));
    color: var(--text-on-accent, #fff);
}

/* Mode Dropdown */
.sm-mode-dropdown {
    position: relative;
}

.sm-mode-dropdown__trigger {
    border: 1px solid var(--background-modifier-border);
    background: var(--background-secondary);
    padding: 0.25rem 0.75rem;
    border-radius: 6px;
    cursor: pointer;
}

.sm-mode-dropdown__menu {
    position: absolute;
    top: calc(100% + 4px);
    right: 0;
    background: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 8px;
    padding: 0.25rem;
    min-width: 160px;
    display: none;
    flex-direction: column;
    gap: 0.25rem;
    z-index: 1000;
}

.sm-mode-dropdown.is-open .sm-mode-dropdown__menu {
    display: flex;
}

.sm-mode-dropdown__item {
    border: none;
    background: transparent;
    text-align: left;
    padding: 0.35rem 0.5rem;
    border-radius: 6px;
    cursor: pointer;
}

.sm-mode-dropdown__item:hover {
    background: var(--background-modifier-hover);
}

.sm-mode-dropdown__item.is-active {
    background: var(--interactive-accent, var(--color-accent));
    color: var(--text-on-accent, #fff);
}
`;
var cartographerPanelsCss = `
/* === Cartographer Panels (Editor & Inspector) === */

/* Library header */
.sm-library .sm-lib-header,
.sm-atlas .sm-lib-header,
.sm-almanac .sm-lib-header { display:flex; gap:.4rem; margin:.25rem 0 .25rem; }
.sm-library .sm-lib-header button,
.sm-atlas .sm-lib-header button,
.sm-almanac .sm-lib-header button { border: 1px solid var(--background-modifier-border); background: var(--background-secondary); padding:.25rem .75rem; border-radius:6px; cursor:pointer; }
.sm-library .sm-lib-header button.is-active,
.sm-atlas .sm-lib-header button.is-active,
.sm-almanac .sm-lib-header button.is-active { background: var(--interactive-accent); color: var(--text-on-accent,#fff); }
.sm-cartographer__panel {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.sm-cartographer__panel h3 {
    margin: 0;
}

.sm-cartographer__panel.is-disabled {
    opacity: 0.6;
    pointer-events: none;
}

.sm-cartographer__panel-info {
    font-size: 0.9rem;
    color: var(--text-muted);
}

.sm-cartographer__panel-file {
    font-size: 0.9rem;
    color: var(--text-muted);
}

.sm-cartographer__panel-tools {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.sm-cartographer__panel-tools label {
    font-weight: 600;
}

.sm-cartographer__panel-tools select {
    flex: 1 1 auto;
}

.sm-cartographer__panel-body {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.sm-cartographer__panel-status {
    font-size: 0.9rem;
    color: var(--text-muted);
}

.sm-cartographer__panel-row {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
}

.sm-cartographer__panel-row label {
    font-weight: 600;
}

.sm-cartographer__panel-row select,
.sm-cartographer__panel-row textarea {
    width: 100%;
    border-radius: 6px;
}

.sm-cartographer__panel-row textarea {
    resize: vertical;
}
`;
var travelModeCss = `
/* === Travel Mode (Cartographer & Legacy Shell) === */
.sm-cartographer--travel {
    --tg-color-token: var(--color-purple, #9c6dfb);
    --tg-color-user-anchor: var(--color-orange, #f59e0b);
    --tg-color-auto-point: var(--color-blue, #3b82f6);
}

.sm-cartographer__sidebar--travel {
    gap: 1rem;
}

.sm-cartographer__travel {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    width: 100%;
}

.sm-cartographer__travel-controls {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
}

.sm-cartographer__travel-buttons {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.5rem;
}

.sm-cartographer__travel-clock {
    font-weight: 600;
    margin-right: .5rem;
}

.sm-cartographer__travel-tempo {
    display: flex;
    align-items: center;
    gap: .35rem;
    margin-left: auto;
}

.sm-cartographer__travel-button {
    font-weight: 600;
}

.sm-cartographer__travel-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.75rem;
}

.sm-cartographer__travel-label {
    font-size: 0.9rem;
    color: var(--text-muted);
}

.sm-cartographer__travel-value {
    font-size: 1rem;
    font-weight: 600;
}

.sm-cartographer__travel-input {
    width: 100%;
    padding: 0.35rem 0.5rem;
    border-radius: 6px;
}

.sm-cartographer--travel .tg-token__circle {
    fill: var(--tg-color-token);
    opacity: 0.95;
    stroke: var(--background-modifier-border);
    stroke-width: 3;
    transition: opacity 120ms ease;
}

.sm-cartographer--travel .tg-route-dot {
    transition: opacity 120ms ease, r 120ms ease, stroke 120ms ease;
}

.sm-cartographer--travel .tg-route-dot--user {
    fill: var(--tg-color-user-anchor);
    opacity: 0.95;
}

.sm-cartographer--travel .tg-route-dot--auto {
    fill: var(--tg-color-auto-point);
    opacity: 0.55;
}

.sm-cartographer--travel .tg-route-dot-hitbox {
    fill: transparent;
    stroke: transparent;
}

.sm-cartographer--travel .tg-route-dot--user.is-highlighted {
    opacity: 1;
}

.sm-cartographer--travel .tg-route-dot--auto.is-highlighted {
    opacity: 0.9;
}

.sm-cartographer--travel .hex3x3-map circle[data-token] { opacity: .95; }
.sm-cartographer--travel .hex3x3-map polyline { pointer-events: none; }
`;
var presetsCss = `
/* === Presets & Autocomplete === */

/* Library separator */
.sm-cc-separator {
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 1.5rem 0;
  color: var(--text-muted);
  font-size: 0.85rem;
  font-weight: 600;
  letter-spacing: 0.05em;
  text-transform: uppercase;
}

/* Preset items in library */
.sm-cc-item--preset {
  opacity: 0.9;
  background: color-mix(in srgb, var(--interactive-accent) 5%, transparent);
  border-left: 3px solid var(--interactive-accent);
}

.sm-cc-item--preset:hover {
  opacity: 1;
  background: color-mix(in srgb, var(--interactive-accent) 10%, transparent);
}

/* Autocomplete dropdown */
.sm-cc-autocomplete {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  z-index: 1000;
  margin-top: 0.25rem;
  max-height: 300px;
  overflow-y: auto;
  background: var(--background-primary);
  border: 1px solid var(--background-modifier-border);
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
}

.sm-cc-autocomplete__item {
  padding: 0.75rem 1rem;
  cursor: pointer;
  transition: background 100ms ease;
  border-bottom: 1px solid var(--background-modifier-border);
}

.sm-cc-autocomplete__item:last-child {
  border-bottom: none;
}

.sm-cc-autocomplete__item:hover,
.sm-cc-autocomplete__item.is-selected {
  background: var(--background-modifier-hover);
}

.sm-cc-autocomplete__name {
  font-weight: 600;
  margin-bottom: 0.25rem;
}

.sm-cc-autocomplete__meta {
  font-size: 0.85rem;
  color: var(--text-muted);
}
`;
var dataManagerCss = `
/* === Data Manager Controls === */
/* Filter/Sort Controls Container */
.sm-cc-controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
    margin-bottom: 1.5rem;
}

/* Filter and Sorting Sections */
.sm-cc-filters,
.sm-cc-sorting {
    background-color: var(--background-secondary);
    border-radius: 8px;
    padding: 1rem;
    border: 1px solid var(--background-modifier-border);
}

/* Section Headers */
.sm-cc-section-header {
    margin: 0 0 0.75rem 0;
    font-size: 0.875rem;
    font-weight: 600;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* Filter and Sort Content Containers */
.sm-cc-filter-content,
.sm-cc-sort-content {
    display: flex;
    gap: 1rem;
    align-items: center;
    flex-wrap: wrap;
}

/* Individual Filter and Sort Items */
.sm-cc-filter,
.sm-cc-sort {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.sm-cc-filter label,
.sm-cc-sort label {
    font-weight: 500;
    color: var(--text-normal);
    white-space: nowrap;
}

.sm-cc-filter select,
.sm-cc-sort select {
    min-width: 120px;
    padding: 0.35rem 0.75rem;
    background-color: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 4px;
    color: var(--text-normal);
    cursor: pointer;
    transition: all 0.2s ease;
}

.sm-cc-filter select:hover,
.sm-cc-sort select:hover {
    border-color: var(--interactive-accent);
    background-color: var(--background-modifier-hover);
}

.sm-cc-filter select:focus,
.sm-cc-sort select:focus {
    outline: none;
    border-color: var(--interactive-accent);
    box-shadow: 0 0 0 2px rgba(88, 101, 242, 0.2);
}

/* Sort Direction Button */
.sm-cc-sort-direction {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    padding: 0;
    background-color: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 4px;
    color: var(--text-normal);
    font-size: 1.2rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.sm-cc-sort-direction:hover {
    background-color: var(--interactive-accent);
    color: var(--text-on-accent);
    border-color: var(--interactive-accent);
    transform: translateY(-1px);
}

.sm-cc-sort-direction:active {
    transform: translateY(0);
}

/* Clear Filters Button */
.sm-cc-clear-filters {
    margin-left: auto;
    padding: 0.35rem 0.75rem;
    background-color: var(--interactive-normal);
    border: none;
    border-radius: 4px;
    color: var(--text-normal);
    cursor: pointer;
    font-size: 0.9em;
    font-weight: 500;
    transition: all 0.2s ease;
}

.sm-cc-clear-filters:hover {
    background-color: var(--interactive-hover);
}

.sm-cc-clear-filters:active {
    background-color: var(--interactive-accent);
    color: var(--text-on-accent);
}

/* Responsive Design for Controls */
@media (max-width: 768px) {
    .sm-cc-controls {
        grid-template-columns: 1fr;
    }

    .sm-cc-filter-content,
    .sm-cc-sort-content {
        flex-direction: column;
        align-items: stretch;
    }

    .sm-cc-filter,
    .sm-cc-sort {
        width: 100%;
    }

    .sm-cc-filter select,
    .sm-cc-sort select {
        width: 100%;
    }
}

/* === List Items === */
.sm-cc-item {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 0.75rem 1rem;
    margin-bottom: 0.5rem;
    background-color: var(--background-secondary);
    border-radius: 6px;
    border: 1px solid var(--background-modifier-border);
    transition: all 0.2s ease;
}

.sm-cc-item:hover {
    background-color: var(--background-modifier-hover);
    border-color: var(--interactive-accent);
}

.sm-cc-item__name-container {
    flex: 1;
    min-width: 0;
}

.sm-cc-item__name {
    font-weight: 500;
    color: var(--text-normal);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.sm-cc-item__badge {
    display: inline-block;
    margin-left: 0.5rem;
    padding: 0.125rem 0.375rem;
    background-color: var(--interactive-accent);
    color: var(--text-on-accent);
    border-radius: 3px;
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
}

.sm-cc-item__info {
    display: flex;
    gap: 0.75rem;
    align-items: center;
}

.sm-cc-item__type,
.sm-cc-item__cr {
    padding: 0.25rem 0.5rem;
    background-color: var(--background-primary);
    border-radius: 3px;
    font-size: 0.875rem;
    color: var(--text-muted);
}

.sm-cc-item__actions {
    display: flex;
    gap: 0.5rem;
}

.sm-cc-item__action {
    padding: 0.35rem 0.75rem;
    background-color: var(--interactive-normal);
    border: none;
    border-radius: 4px;
    color: var(--text-normal);
    cursor: pointer;
    font-size: 0.875rem;
    font-weight: 500;
    transition: all 0.2s ease;
}

.sm-cc-item__action:hover {
    background-color: var(--interactive-hover);
}

.sm-cc-item__action--edit {
    background-color: var(--interactive-accent);
    color: var(--text-on-accent);
}

.sm-cc-item__action--edit:hover {
    background-color: var(--interactive-accent-hover, var(--interactive-accent));
}

/* List Container */
.sm-cc-list {
    display: flex;
    flex-direction: column;
}

/* === Suggestion Menu === */
.sm-cc-suggestion-menu {
    position: absolute;
    z-index: 1000;
    max-height: 200px;
    overflow-y: auto;
    background-color: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 4px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    margin-top: 4px;
    min-width: 200px;
}

.sm-cc-suggestion-item {
    padding: 0.5rem 0.75rem;
    cursor: pointer;
    transition: background-color 0.15s ease;
}

.sm-cc-suggestion-item:hover {
    background-color: var(--background-modifier-hover);
}

.sm-cc-suggestion-item.is-active {
    background-color: var(--interactive-accent);
    color: var(--text-on-accent);
}
`;
var encounterCss = `
/* === Encounter Workspace === */
.sm-encounter-view {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    padding: 1rem 0;
}

.sm-encounter-section {
    background-color: var(--background-secondary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 8px;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.sm-encounter-columns {
    display: flex;
    flex-wrap: wrap;
    gap: 1.5rem;
}

.sm-encounter-column {
    display: flex;
    flex-direction: column;
    flex: 1 1 320px;
    gap: 1.5rem;
}

.sm-encounter-header {
    gap: 0.5rem;
}

.sm-encounter-heading {
    margin: 0;
    font-size: 1.4rem;
}

.sm-encounter-status {
    color: var(--text-muted);
    font-size: 0.95rem;
}

.sm-encounter-summary {
    list-style: none;
    margin: 0;
    padding: 0;
    display: grid;
    gap: 0.25rem;
}

.sm-encounter-summary .label {
    font-weight: 600;
}

.sm-encounter-summary .value {
    color: var(--text-muted);
}

.sm-encounter-empty {
    font-style: italic;
    color: var(--text-muted);
}

.sm-encounter-section-title {
    margin: 0;
    font-size: 1.1rem;
}

.sm-encounter-subheading {
    margin: 0;
    font-size: 0.95rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-muted);
}

.sm-encounter-form {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.sm-encounter-form-grid {
    display: grid;
    gap: 0.75rem;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    align-items: end;
}

.sm-encounter-field {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.sm-encounter-field-inline {
    flex-direction: row;
    align-items: center;
    gap: 0.5rem;
}

.sm-encounter-field-toggle {
    flex-direction: row;
    align-items: center;
    gap: 0.5rem;
}

.sm-encounter-field label {
    font-size: 0.85rem;
    font-weight: 600;
}

.sm-encounter-field-inline label {
    margin-bottom: 0;
}

.sm-encounter-input {
    width: 100%;
    padding: 0.4rem 0.6rem;
    border-radius: 6px;
    border: 1px solid var(--background-modifier-border);
    background-color: var(--background-primary);
}

.sm-encounter-input:focus {
    border-color: var(--interactive-accent);
    outline: none;
    box-shadow: 0 0 0 2px var(--interactive-accent-hover, var(--interactive-accent));
}

.sm-encounter-field-inline .sm-encounter-input {
    width: auto;
    min-width: 8rem;
}

.sm-encounter-field-base-xp .sm-encounter-input {
    min-width: 6rem;
}

.sm-encounter-field-actions {
    display: flex;
    align-items: flex-end;
}

.sm-encounter-error {
    color: var(--text-error);
    font-size: 0.85rem;
}

.sm-encounter-inline-actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: nowrap;
    align-items: center;
}

.sm-encounter-inline-actions-left {
    justify-content: flex-start;
}

.sm-encounter-inline-actions-right {
    justify-content: flex-end;
}

.sm-encounter-preset-select {
    min-width: 10rem;
}

.sm-encounter-button {
    padding: 0.45rem 0.9rem;
    border-radius: 6px;
    border: 1px solid var(--background-modifier-border);
    background-color: var(--background-modifier-hover);
    color: var(--text-normal);
    font-size: 0.85rem;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.15s ease, color 0.15s ease, border-color 0.15s ease;
}

.sm-encounter-button:hover:not(:disabled) {
    background-color: var(--interactive-hover);
    border-color: var(--interactive-accent);
}

.sm-encounter-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.sm-encounter-button-primary {
    background-color: var(--interactive-accent);
    color: var(--text-on-accent);
    border-color: var(--interactive-accent);
}

.sm-encounter-button-primary:hover:not(:disabled) {
    background-color: var(--interactive-accent-hover, var(--interactive-accent));
}

.sm-encounter-button-secondary {
    background-color: var(--background-primary);
}

.sm-encounter-button-danger {
    background-color: var(--background-modifier-error);
    border-color: var(--background-modifier-error);
    color: var(--text-on-accent);
}

.sm-encounter-button-danger:hover:not(:disabled) {
    background-color: var(--background-modifier-error-hover, var(--background-modifier-error));
}

.sm-encounter-xp-row {
    display: flex;
    flex-wrap: nowrap;
    gap: 1rem;
    align-items: center;
}

.sm-encounter-xp-group {
    display: flex;
    flex-wrap: nowrap;
    gap: 0.75rem;
    align-items: center;
}

.sm-encounter-xp-group-right {
    margin-left: auto;
    justify-content: flex-end;
    align-items: center;
}

@media (max-width: 900px) {
    .sm-encounter-xp-row {
        flex-wrap: wrap;
        align-items: flex-start;
    }

    .sm-encounter-xp-group {
        flex-wrap: wrap;
    }

    .sm-encounter-inline-actions {
        flex-wrap: wrap;
    }
}

.sm-encounter-party-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.sm-encounter-rule-list {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 0.75rem;
    align-items: stretch;
}

.sm-encounter-party-item {
    display: grid;
    grid-template-columns: minmax(0, 1fr) minmax(120px, max-content) auto;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem;
    border-radius: 6px;
    border: 1px solid var(--background-modifier-border);
    background-color: var(--background-primary);
}

.sm-encounter-party-field {
    flex-direction: row;
    align-items: center;
    gap: 0.5rem;
}

.sm-encounter-party-field label {
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--text-muted);
}

.sm-encounter-party-remove {
    justify-self: end;
}

.sm-encounter-inline-label {
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--text-muted);
}

.sm-encounter-rule {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 0.75rem;
    border-radius: 6px;
    border: 1px solid var(--background-modifier-border);
    background-color: var(--background-primary);
    min-width: 0;
    height: 100%;
}

.sm-encounter-rule.is-disabled {
    opacity: 0.6;
}

.sm-encounter-rule-header {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    align-items: stretch;
}

.sm-encounter-rule-title {
    flex: 1 1 180px;
    min-width: 140px;
}

.sm-encounter-rule-toggle {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.4rem 0.6rem;
    border-radius: 6px;
    border: 1px solid var(--background-modifier-border);
    background-color: var(--background-modifier-hover);
    flex: 0 0 auto;
    align-self: stretch;
}

.sm-encounter-rule-toggle-input {
    width: 1.1rem;
    height: 1.1rem;
    margin: 0;
}

.sm-encounter-rule-scope {
    flex: 0 1 120px;
    min-width: 110px;
}

.sm-encounter-rule-range {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    flex: 0 1 210px;
    min-width: 160px;
}

.sm-encounter-rule-range-input {
    flex: 1 1 0;
    min-width: 60px;
}

.sm-encounter-rule-range-separator {
    color: var(--text-muted);
}

.sm-encounter-rule-range-result {
    font-size: 0.85rem;
    color: var(--text-muted);
    white-space: nowrap;
}

.sm-encounter-rule-type {
    flex: 0 1 160px;
    min-width: 140px;
}

.sm-encounter-rule-notes {
    flex: 1 1 100%;
}

.sm-encounter-rule-notes textarea {
    min-height: 0;
    resize: vertical;
}

.sm-encounter-rule-effect {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
}

.sm-encounter-rule-total {
    font-weight: 600;
}

.sm-encounter-rule-deltas {
    margin: 0;
    padding-left: 1.25rem;
}

.sm-encounter-callout {
    border-radius: 6px;
    border: 1px solid var(--background-modifier-border);
    background-color: var(--background-modifier-hover);
    padding: 0.75rem;
    font-size: 0.9rem;
}

.sm-encounter-callout p {
    margin: 0.25rem 0 0 0;
}

.sm-encounter-callout p:first-child {
    margin-top: 0;
}

.sm-encounter-result-totals {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
}

.sm-encounter-result-total {
    display: flex;
    gap: 0.35rem;
    align-items: baseline;
    font-weight: 600;
}

.sm-encounter-result-total .label {
    color: var(--text-muted);
    font-weight: 600;
}

.sm-encounter-breakdowns {
    display: grid;
    gap: 1rem;
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
}

.sm-encounter-result-party {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.sm-encounter-result-summary {
    margin: 0;
    padding: 0;
    list-style: none;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.sm-encounter-result-summary-item {
    display: flex;
    justify-content: space-between;
    gap: 0.5rem;
    align-items: baseline;
}

.sm-encounter-result-summary-item .label {
    font-weight: 600;
    color: var(--text-muted);
}

.sm-encounter-result-summary-item .value {
    font-weight: 600;
    font-variant-numeric: tabular-nums;
    text-align: right;
}

.sm-encounter-result-summary-item--modifiers {
    flex-direction: column;
    align-items: stretch;
    gap: 0.25rem;
}

.sm-encounter-result-summary-item--modifiers .label {
    margin-bottom: 0.25rem;
}

.sm-encounter-result-summary-item--modifiers .value {
    text-align: left;
}

.sm-encounter-result-modifier-list {
    margin: 0;
    padding: 0;
    list-style: none;
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.sm-encounter-result-modifier {
    display: flex;
    justify-content: space-between;
    gap: 0.5rem;
    font-variant-numeric: tabular-nums;
}

.sm-encounter-result-modifier .name {
    font-weight: 600;
}

.sm-encounter-result-modifier .delta {
    font-weight: 600;
}

.sm-encounter-result-modifier-empty {
    font-weight: 600;
    color: var(--text-muted);
}

.sm-encounter-debug-details {
    border: 1px solid var(--background-modifier-border);
    border-radius: 6px;
    background-color: var(--background-primary);
    padding: 0.75rem 1rem 1rem 1rem;
}

.sm-encounter-debug-summary {
    font-weight: 600;
    cursor: pointer;
    list-style: none;
    margin: -0.75rem -1rem 0 -1rem;
    padding: 0.75rem 1rem;
}

.sm-encounter-debug-summary::-webkit-details-marker {
    display: none;
}

.sm-encounter-debug-details[open] .sm-encounter-debug-summary {
    border-bottom: 1px solid var(--background-modifier-border);
    margin-bottom: 0.75rem;
}

.sm-encounter-debug-rule-effects {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.sm-encounter-result-party-member,
.sm-encounter-result-rule {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    border: 1px solid var(--background-modifier-border);
    border-radius: 6px;
    background-color: var(--background-primary);
    padding: 0.75rem;
}

.sm-encounter-result-party-member--xp-only {
    gap: 0.5rem;
}

.sm-encounter-result-party-member-row {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    gap: 0.5rem;
}

.sm-encounter-result-party-member-row .name {
    font-weight: 600;
}

.sm-encounter-result-party-member-row .xp {
    font-variant-numeric: tabular-nums;
    font-weight: 600;
}

.sm-encounter-result-party-summary {
    flex-direction: row;
    align-items: baseline;
    justify-content: space-between;
    gap: 0.5rem;
}

.sm-encounter-result-party-summary .label {
    color: var(--text-muted);
    font-weight: 600;
}

.sm-encounter-result-party-summary .value {
    font-variant-numeric: tabular-nums;
    font-weight: 600;
}

.sm-encounter-result-party-header {
    display: flex;
    justify-content: space-between;
    font-weight: 600;
}

.sm-encounter-result-stats {
    margin: 0;
    padding: 0;
    list-style: none;
    display: grid;
    gap: 0.25rem;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
}

.sm-encounter-result-stats .label {
    font-weight: 600;
}

.sm-encounter-result-rule-title {
    font-weight: 600;
}

.sm-encounter-result-rule-title.is-disabled {
    opacity: 0.6;
}

.sm-encounter-result-rule-total {
    display: flex;
    gap: 0.35rem;
    align-items: baseline;
    font-weight: 600;
}

.sm-encounter-rule-final-xp {
    margin: 0;
    padding: 0;
    list-style: none;
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.sm-encounter-rule-final-xp-item {
    display: flex;
    justify-content: space-between;
    gap: 0.5rem;
}

.sm-encounter-rule-final-xp-item .name {
    font-weight: 600;
}

.sm-encounter-rule-final-xp-item .xp {
    font-variant-numeric: tabular-nums;
    font-weight: 600;
}

.sm-encounter-notes {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
}

.sm-encounter-notes-label {
    font-weight: 600;
}

.sm-encounter-notes-input {
    width: 100%;
    border-radius: 6px;
    border: 1px solid var(--background-modifier-border);
    padding: 0.6rem;
    background-color: var(--background-primary);
}

.sm-encounter-notes-input:focus {
    border-color: var(--interactive-accent);
    outline: none;
    box-shadow: 0 0 0 2px var(--interactive-accent-hover, var(--interactive-accent));
}

.sm-encounter-actions {
    display: flex;
    justify-content: flex-end;
}

.sm-encounter-empty-row {
    padding: 0.75rem;
    border-radius: 6px;
    background-color: var(--background-primary);
    border: 1px dashed var(--background-modifier-border);
    color: var(--text-muted);
    font-style: italic;
}

.sm-encounter-result-warnings {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.sm-encounter-hidden {
    display: none !important;
}

@media (max-width: 720px) {
    .sm-encounter-column {
        flex-basis: 100%;
    }

    .sm-encounter-breakdowns {
        grid-template-columns: 1fr;
    }

    .sm-encounter-result-totals {
        flex-direction: column;
        align-items: flex-start;
    }
}
`;
var tabNavigationCss = `
/* ==================== Tab Navigation ==================== */

.sm-tab-nav {
    display: flex;
    gap: 4px;
    padding: 8px;
    border-bottom: 1px solid var(--background-modifier-border);
    background: var(--background-primary);
}

.sm-tab-nav__button {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    background: transparent;
    color: var(--text-muted);
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: none;
    position: relative;
}

.sm-tab-nav__button:hover:not(.is-disabled) {
    background: var(--background-modifier-hover);
    color: var(--text-normal);
}

.sm-tab-nav__button.is-active {
    background: var(--interactive-accent);
    color: var(--text-on-accent);
}

.sm-tab-nav__button.is-active:hover {
    background: var(--interactive-accent);
    color: var(--text-on-accent);
}

.sm-tab-nav__button.is-disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.sm-tab-nav__button:focus-visible {
    outline: 2px solid var(--interactive-accent);
    outline-offset: 2px;
}

.sm-tab-nav__icon {
    display: flex;
    align-items: center;
    font-size: 16px;
}

.sm-tab-nav__label {
    white-space: nowrap;
}

.sm-tab-nav__badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 18px;
    height: 18px;
    padding: 0 6px;
    border-radius: 9px;
    background: var(--background-modifier-error);
    color: var(--text-on-accent);
    font-size: 11px;
    font-weight: 600;
    line-height: 1;
}

.sm-tab-nav__button.is-active .sm-tab-nav__badge {
    background: var(--text-on-accent);
    color: var(--interactive-accent);
}

/* Responsive: Icon-only on narrow screens */
@media (max-width: 520px) {
    .sm-tab-nav {
        gap: 2px;
        padding: 4px;
    }

    .sm-tab-nav__button {
        padding: 8px;
    }

    .sm-tab-nav__label {
        display: none;
    }

    .sm-tab-nav__icon {
        font-size: 18px;
    }
}
`;
var HEX_PLUGIN_CSS_SECTIONS = {
  viewContainer: viewContainerCss,
  mapAndPreview: mapAndPreviewCss,
  terrainEditor: terrainEditorCss,
  libraryView: libraryViewCss,
  createModal: createModalCss,
  cartographerShell: cartographerShellCss,
  cartographerPanels: cartographerPanelsCss,
  travelMode: travelModeCss,
  presets: presetsCss,
  dataManager: dataManagerCss,
  encounter: encounterCss,
  tabNavigation: tabNavigationCss
};
var HEX_PLUGIN_CSS = Object.values(HEX_PLUGIN_CSS_SECTIONS).join("\n\n");

// src/app/integration-telemetry.ts
var import_obsidian51 = require("obsidian");
init_plugin_logger();
var notifiedOperations = /* @__PURE__ */ new Set();
function reportIntegrationIssue(payload) {
  const { integrationId, operation, error, userMessage } = payload;
  const logPrefix = `[salt-marcher] integration(${integrationId}) ${operation} failed`;
  logger2.error(logPrefix, error);
  const dedupeKey = `${integrationId}:${operation}`;
  if (notifiedOperations.has(dedupeKey)) return;
  notifiedOperations.add(dedupeKey);
  new import_obsidian51.Notice(userMessage);
}

// src/app/bootstrap-services.ts
init_plugin_logger();
init_terrain_repository();
init_terrain();
var defaultLogger = {
  info: (message, context) => {
    if (context) {
      logger2.info(`[salt-marcher] ${message}`, context);
    } else {
      logger2.info(`[salt-marcher] ${message}`);
    }
  },
  warn: (message, context) => {
    if (context) {
      logger2.warn(`[salt-marcher] ${message}`, context);
    } else {
      logger2.warn(`[salt-marcher] ${message}`);
    }
  },
  error: (message, context) => {
    if (context) {
      logger2.error(`[salt-marcher] ${message}`, context);
    } else {
      logger2.error(`[salt-marcher] ${message}`);
    }
  }
};
function createTerrainBootstrap(app, config = {}) {
  const deps = {
    ensureTerrainFile: config.ensureTerrainFile ?? ensureTerrainFile,
    loadTerrains: config.loadTerrains ?? loadTerrains2,
    setTerrains: config.setTerrains ?? setTerrains,
    watchTerrains: config.watchTerrains ?? watchTerrains2,
    logger: config.logger ?? defaultLogger
  };
  let disposeWatcher = null;
  const stop = () => {
    if (disposeWatcher) {
      try {
        disposeWatcher();
      } catch (error) {
        deps.logger.warn?.("Failed to dispose terrain watcher", { error });
      }
    }
    disposeWatcher = null;
  };
  const start = async () => {
    stop();
    let primeError;
    let watchError;
    try {
      await deps.ensureTerrainFile(app);
      const map2 = await deps.loadTerrains(app);
      deps.setTerrains(map2);
    } catch (error) {
      primeError = error;
      deps.logger.error?.("Failed to prime terrain palette from vault", { error });
    }
    try {
      disposeWatcher = deps.watchTerrains(app, {
        onError: (error, meta) => {
          deps.logger.error?.("Terrain watcher failed to apply vault change", {
            error,
            reason: meta.reason
          });
        }
      });
    } catch (error) {
      watchError = error;
      deps.logger.error?.("Failed to register terrain watcher", { error });
      disposeWatcher = null;
    }
    return {
      primed: !primeError && !watchError,
      primeError,
      watchError
    };
  };
  return {
    start,
    stop
  };
}

// src/app/ipc-server.ts
var net = __toESM(require("net"), 1);
init_plugin_logger();
var IPCServer = class {
  constructor(app) {
    this.app = app;
    this.server = null;
    this.handlers = /* @__PURE__ */ new Map();
    const vaultPath = app.vault.adapter.basePath;
    this.socketPath = `${vaultPath}/.obsidian/plugins/salt-marcher/ipc.sock`;
  }
  /**
   * Register a command handler
   */
  registerCommand(name, handler) {
    this.handlers.set(name, handler);
    logger2.log(`[IPC] Registered command: ${name}`);
  }
  /**
   * Start the IPC server
   */
  async start() {
    try {
      const fs = require("fs");
      fs.unlinkSync(this.socketPath);
    } catch (err) {
    }
    return new Promise((resolve, reject) => {
      this.server = net.createServer(async (socket) => {
        let buffer = "";
        socket.on("data", async (data) => {
          buffer += data.toString();
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";
          for (const line of lines) {
            if (!line.trim()) continue;
            try {
              const request = JSON.parse(line);
              const response = await this.handleCommand(request);
              socket.write(JSON.stringify(response) + "\n");
            } catch (error) {
              const errorResponse = {
                success: false,
                error: String(error),
                id: "unknown"
              };
              socket.write(JSON.stringify(errorResponse) + "\n");
            }
          }
        });
        socket.on("error", (err) => {
          logger2.error("[IPC] Client socket error:", err);
        });
      });
      this.server.on("error", (err) => {
        logger2.error("[IPC] Server error:", err);
        reject(err);
      });
      this.server.on("listening", () => {
        logger2.log(`[IPC] Server started on ${this.socketPath}`);
        resolve();
      });
      this.server.listen(this.socketPath);
    });
  }
  /**
   * Handle incoming command request
   */
  async handleCommand(request) {
    const { command, args, id } = request;
    logger2.log("[IPC] Received command:", command, args);
    const handler = this.handlers.get(command);
    if (!handler) {
      return {
        success: false,
        error: `Unknown command: ${command}`,
        id
      };
    }
    try {
      const data = await handler(this.app, args);
      logger2.log("[IPC] Command completed:", command);
      return { success: true, data, id };
    } catch (error) {
      logger2.error("[IPC] Command failed:", command, error);
      return {
        success: false,
        error: String(error),
        id
      };
    }
  }
  /**
   * Stop the IPC server
   */
  stop() {
    if (this.server) {
      this.server.close();
      this.server = null;
    }
    try {
      const fs = require("fs");
      fs.unlinkSync(this.socketPath);
    } catch (err) {
    }
    logger2.log("[IPC] Server stopped");
  }
};

// src/app/ipc-commands.ts
init_plugin_logger();
function closeAllModals() {
  const modals = document.querySelectorAll(".modal-container");
  modals.forEach((modal) => {
    const closeButton = modal.querySelector(".modal-close-button");
    if (closeButton) {
      closeButton.click();
    }
  });
}
function registerIPCCommands(server, plugin) {
  server.registerCommand("reload-plugin", async (app) => {
    logger2.log("[IPC-CMD] Reloading plugin...");
    await app.plugins.disablePlugin("salt-marcher");
    await new Promise((resolve) => setTimeout(resolve, 100));
    await app.plugins.enablePlugin("salt-marcher");
    logger2.log("[IPC-CMD] Plugin reloaded");
    return { status: "reloaded" };
  });
  server.registerCommand("edit-creature", async (app, args) => {
    const [creatureName] = args;
    logger2.log("[IPC-CMD] Opening creature editor:", creatureName || "new");
    closeAllModals();
    await new Promise((resolve) => setTimeout(resolve, 100));
    const { openLibraryModal: openLibraryModal2 } = await Promise.resolve().then(() => (init_library_mode_service_port(), library_mode_service_port_exports));
    openLibraryModal2(app, "creatures", creatureName).catch((err) => {
      logger2.error("[IPC-CMD] Failed to open creature modal:", err);
    });
    await new Promise((resolve) => setTimeout(resolve, 300));
    return { status: "opened", entity: creatureName || "new" };
  });
  server.registerCommand("edit-spell", async (app, args) => {
    const [spellName] = args;
    if (!spellName) throw new Error("Spell name required");
    logger2.log("[IPC-CMD] Opening spell editor:", spellName);
    closeAllModals();
    await new Promise((resolve) => setTimeout(resolve, 100));
    const { openLibraryModal: openLibraryModal2 } = await Promise.resolve().then(() => (init_library_mode_service_port(), library_mode_service_port_exports));
    openLibraryModal2(app, "spells", spellName).catch((err) => {
      logger2.error("[IPC-CMD] Failed to open spell modal:", err);
    });
    await new Promise((resolve) => setTimeout(resolve, 300));
    return { status: "opened", entity: spellName };
  });
  server.registerCommand("edit-item", async (app, args) => {
    const [itemName] = args;
    if (!itemName) throw new Error("Item name required");
    logger2.log("[IPC-CMD] Opening item editor:", itemName);
    closeAllModals();
    await new Promise((resolve) => setTimeout(resolve, 100));
    const { openLibraryModal: openLibraryModal2 } = await Promise.resolve().then(() => (init_library_mode_service_port(), library_mode_service_port_exports));
    openLibraryModal2(app, "items", itemName).catch((err) => {
      logger2.error("[IPC-CMD] Failed to open item modal:", err);
    });
    await new Promise((resolve) => setTimeout(resolve, 300));
    return { status: "opened", entity: itemName };
  });
  server.registerCommand("edit-equipment", async (app, args) => {
    const [equipmentName] = args;
    if (!equipmentName) throw new Error("Equipment name required");
    logger2.log("[IPC-CMD] Opening equipment editor:", equipmentName);
    closeAllModals();
    await new Promise((resolve) => setTimeout(resolve, 100));
    const { openLibraryModal: openLibraryModal2 } = await Promise.resolve().then(() => (init_library_mode_service_port(), library_mode_service_port_exports));
    openLibraryModal2(app, "equipments", equipmentName).catch((err) => {
      logger2.error("[IPC-CMD] Failed to open equipment modal:", err);
    });
    await new Promise((resolve) => setTimeout(resolve, 300));
    return { status: "opened", entity: equipmentName };
  });
  server.registerCommand("get-logs", async (app, args) => {
    const lines = parseInt(args[0]) || 50;
    const fs = require("fs");
    const path = require("path");
    const logPath = path.join(app.vault.adapter.basePath, "CONSOLE_LOG.txt");
    try {
      const content = fs.readFileSync(logPath, "utf-8");
      const allLines = content.split("\n");
      const recentLines = allLines.slice(-lines);
      return { lines: recentLines };
    } catch (error) {
      return { lines: [], error: String(error) };
    }
  });
  server.registerCommand("import-presets", async (app, args) => {
    const [category, ...flags] = args;
    const force = flags.includes("--force");
    if (!category) {
      throw new Error("Category required. Valid categories: creatures, spells, items, equipment, terrains, regions, calendars, all");
    }
    logger2.log(`[IPC-CMD] Importing ${category} presets (force: ${force})...`);
    const { importPresetsByCategory: importPresetsByCategory2 } = await Promise.resolve().then(() => (init_plugin_presets(), plugin_presets_exports));
    const result = await importPresetsByCategory2(app, category, force);
    logger2.log(`[IPC-CMD] Preset import complete: ${category}`);
    return {
      status: "imported",
      category: result.category,
      force,
      message: force ? `Re-imported ${category} presets (deleted and recreated existing files)` : `Imported ${category} presets (skipped existing files)`
    };
  });
  server.registerCommand("regenerate-indexes", async (app) => {
    logger2.log("[IPC-CMD] Regenerating library indexes...");
    const { generateAllIndexes: generateAllIndexes2 } = await Promise.resolve().then(() => (init_index_files(), index_files_exports));
    await generateAllIndexes2(app);
    logger2.log("[IPC-CMD] Index regeneration complete");
    return {
      status: "regenerated",
      message: "All library index files regenerated successfully"
    };
  });
}

// src/app/main.ts
var SaltMarcherPlugin = class extends import_obsidian54.Plugin {
  async onload() {
    await logger2.init(this.app);
    logger2.log("Plugin loading...");
    const { debugLogger: debugLogger2 } = await Promise.resolve().then(() => (init_debug_logger(), debug_logger_exports));
    await debugLogger2.loadConfig(this.app);
    this.injectCss();
    try {
      const { generateAllIndexes: generateAllIndexes2 } = await Promise.resolve().then(() => (init_index_files(), index_files_exports));
      await generateAllIndexes2(this.app);
    } catch (err) {
      logger2.error("Failed to generate library indexes:", err);
    }
    for (const manifestEntry of VIEW_MANIFEST) {
      try {
        this.registerView(manifestEntry.viewType, manifestEntry.createView);
      } catch (error) {
        this.failIntegration("register-view", manifestEntry.integrationId, error, `${manifestEntry.displayName}-Ansicht konnte nicht registriert werden. Bitte die Konsole pruefen.`);
      }
    }
    for (const manifestEntry of VIEW_MANIFEST) {
      const activation = manifestEntry.activation;
      if (!activation?.ribbon) continue;
      try {
        this.addRibbonIcon(activation.ribbon.icon, activation.ribbon.title, async () => {
          try {
            await activation.open(this.app);
          } catch (error) {
            this.failIntegration("activate-view", manifestEntry.integrationId, error, `${manifestEntry.displayName} konnte nicht geoeffnet werden. Bitte die Konsole pruefen.`);
          }
        });
      } catch (error) {
        this.failIntegration("register-ribbon", manifestEntry.integrationId, error, `${manifestEntry.displayName}-Ribbon konnte nicht erstellt werden. Bitte die Konsole pruefen.`);
      }
    }
    try {
      this.ipcServer = new IPCServer(this.app);
      registerIPCCommands(this.ipcServer, this);
      try {
        const { registerDevCommands: registerDevCommands2 } = await Promise.resolve().then(() => (init_register_dev_commands(), register_dev_commands_exports));
        registerDevCommands2(this.ipcServer);
        logger2.log("[IPC] Dev commands loaded - available: measure-ui, validate-ui-rule, validate-ui-config, dump-dom, navigate-to-section, validate-grid-layout, debug-stepper-styles, validate-ui, start-test, end-test, log-marker, set-debug-config, get-debug-config, get-test-logs, assert-log-contains, get-field-state, dump-field-states, get-modal-data");
      } catch (err) {
        logger2.log("[IPC] Dev commands not available:", err);
      }
      await this.ipcServer.start();
      logger2.log("[IPC] Server ready - production commands: reload-plugin, edit-creature, edit-spell, edit-item, edit-equipment, get-logs");
    } catch (err) {
      logger2.error("Failed to start IPC server:", err);
    }
    try {
      const { shouldImportPluginPresets: shouldImportPluginPresets2, importPluginPresets: importPluginPresets2 } = await Promise.resolve().then(() => (init_plugin_presets(), plugin_presets_exports));
      if (await shouldImportPluginPresets2(this.app)) {
        await importPluginPresets2(this.app);
      }
    } catch (err) {
      logger2.error("Failed to import preset creatures:", err);
    }
    try {
      const { shouldImportSpellPresets: shouldImportSpellPresets2, importSpellPresets: importSpellPresets2 } = await Promise.resolve().then(() => (init_plugin_presets(), plugin_presets_exports));
      if (await shouldImportSpellPresets2(this.app)) {
        await importSpellPresets2(this.app);
      }
    } catch (err) {
      logger2.error("Failed to import spell presets:", err);
    }
    try {
      const { shouldImportItemPresets: shouldImportItemPresets2, importItemPresets: importItemPresets2 } = await Promise.resolve().then(() => (init_plugin_presets(), plugin_presets_exports));
      if (await shouldImportItemPresets2(this.app)) {
        await importItemPresets2(this.app);
      }
    } catch (err) {
      logger2.error("Failed to import item presets:", err);
    }
    try {
      const { shouldImportEquipmentPresets: shouldImportEquipmentPresets2, importEquipmentPresets: importEquipmentPresets2 } = await Promise.resolve().then(() => (init_plugin_presets(), plugin_presets_exports));
      if (await shouldImportEquipmentPresets2(this.app)) {
        await importEquipmentPresets2(this.app);
      }
    } catch (err) {
      logger2.error("Failed to import equipment presets:", err);
    }
    try {
      const { shouldImportTerrainPresets: shouldImportTerrainPresets2, importTerrainPresets: importTerrainPresets2 } = await Promise.resolve().then(() => (init_plugin_presets(), plugin_presets_exports));
      if (await shouldImportTerrainPresets2(this.app)) {
        await importTerrainPresets2(this.app);
      }
    } catch (err) {
      logger2.error("Failed to import terrain presets:", err);
    }
    try {
      const { shouldImportRegionPresets: shouldImportRegionPresets2, importRegionPresets: importRegionPresets2 } = await Promise.resolve().then(() => (init_plugin_presets(), plugin_presets_exports));
      if (await shouldImportRegionPresets2(this.app)) {
        await importRegionPresets2(this.app);
      }
    } catch (err) {
      logger2.error("Failed to import region presets:", err);
    }
    try {
      const { shouldImportCalendarPresets: shouldImportCalendarPresets2, importCalendarPresets: importCalendarPresets2 } = await Promise.resolve().then(() => (init_plugin_presets(), plugin_presets_exports));
      if (await shouldImportCalendarPresets2(this.app)) {
        await importCalendarPresets2(this.app);
      }
    } catch (err) {
      logger2.error("Failed to import calendar presets:", err);
    }
    try {
      const { shouldImportPlaylistPresets: shouldImportPlaylistPresets2, importPlaylistPresets: importPlaylistPresets2 } = await Promise.resolve().then(() => (init_plugin_presets(), plugin_presets_exports));
      if (await shouldImportPlaylistPresets2(this.app)) {
        await importPlaylistPresets2(this.app);
      }
    } catch (err) {
      logger2.error("Failed to import playlist presets:", err);
    }
    try {
      const {
        generateCreaturesIndex: generateCreaturesIndex2,
        generateEquipmentIndex: generateEquipmentIndex2,
        generateSpellsIndex: generateSpellsIndex2,
        generateItemsIndex: generateItemsIndex2,
        generateCalendarsIndex: generateCalendarsIndex2,
        generateLibraryHub: generateLibraryHub2
      } = await Promise.resolve().then(() => (init_index_files(), index_files_exports));
      const createDebouncedIndexUpdater = (updateFn, delay = 1e3) => {
        let timeoutId = null;
        return () => {
          if (timeoutId) clearTimeout(timeoutId);
          timeoutId = setTimeout(async () => {
            try {
              await updateFn();
            } catch (err) {
              logger2.error("Failed to update index:", err);
            }
          }, delay);
        };
      };
      const creaturesWatcher = createDebouncedIndexUpdater(() => generateCreaturesIndex2(this.app));
      this.registerEvent(this.app.vault.on("create", (file) => {
        if (file.path.startsWith("SaltMarcher/Creatures/") && file.path !== "SaltMarcher/Creatures.md") creaturesWatcher();
      }));
      this.registerEvent(this.app.vault.on("delete", (file) => {
        if (file.path.startsWith("SaltMarcher/Creatures/") && file.path !== "SaltMarcher/Creatures.md") creaturesWatcher();
      }));
      this.registerEvent(this.app.vault.on("rename", (file) => {
        if (file.path.startsWith("SaltMarcher/Creatures/") && file.path !== "SaltMarcher/Creatures.md") creaturesWatcher();
      }));
      const equipmentWatcher = createDebouncedIndexUpdater(() => generateEquipmentIndex2(this.app));
      this.registerEvent(this.app.vault.on("create", (file) => {
        if (file.path.startsWith("SaltMarcher/Equipment/") && file.path !== "SaltMarcher/Equipment.md") equipmentWatcher();
      }));
      this.registerEvent(this.app.vault.on("delete", (file) => {
        if (file.path.startsWith("SaltMarcher/Equipment/") && file.path !== "SaltMarcher/Equipment.md") equipmentWatcher();
      }));
      this.registerEvent(this.app.vault.on("rename", (file) => {
        if (file.path.startsWith("SaltMarcher/Equipment/") && file.path !== "SaltMarcher/Equipment.md") equipmentWatcher();
      }));
      const spellsWatcher = createDebouncedIndexUpdater(() => generateSpellsIndex2(this.app));
      this.registerEvent(this.app.vault.on("create", (file) => {
        if (file.path.startsWith("SaltMarcher/Spells/") && file.path !== "SaltMarcher/Spells.md") spellsWatcher();
      }));
      this.registerEvent(this.app.vault.on("delete", (file) => {
        if (file.path.startsWith("SaltMarcher/Spells/") && file.path !== "SaltMarcher/Spells.md") spellsWatcher();
      }));
      this.registerEvent(this.app.vault.on("rename", (file) => {
        if (file.path.startsWith("SaltMarcher/Spells/") && file.path !== "SaltMarcher/Spells.md") spellsWatcher();
      }));
      const itemsWatcher = createDebouncedIndexUpdater(() => generateItemsIndex2(this.app));
      this.registerEvent(this.app.vault.on("create", (file) => {
        if (file.path.startsWith("SaltMarcher/Items/") && file.path !== "SaltMarcher/Items.md") itemsWatcher();
      }));
      this.registerEvent(this.app.vault.on("delete", (file) => {
        if (file.path.startsWith("SaltMarcher/Items/") && file.path !== "SaltMarcher/Items.md") itemsWatcher();
      }));
      this.registerEvent(this.app.vault.on("rename", (file) => {
        if (file.path.startsWith("SaltMarcher/Items/") && file.path !== "SaltMarcher/Items.md") itemsWatcher();
      }));
      const calendarsWatcher = createDebouncedIndexUpdater(() => generateCalendarsIndex2(this.app));
      this.registerEvent(this.app.vault.on("create", (file) => {
        if (file.path.startsWith("SaltMarcher/Calendars/") && file.path !== "SaltMarcher/Calendars.md") calendarsWatcher();
      }));
      this.registerEvent(this.app.vault.on("delete", (file) => {
        if (file.path.startsWith("SaltMarcher/Calendars/") && file.path !== "SaltMarcher/Calendars.md") calendarsWatcher();
      }));
      this.registerEvent(this.app.vault.on("rename", (file) => {
        if (file.path.startsWith("SaltMarcher/Calendars/") && file.path !== "SaltMarcher/Calendars.md") calendarsWatcher();
      }));
    } catch (err) {
      logger2.error("Failed to setup library index watchers:", err);
    }
    this.terrainBootstrap = createTerrainBootstrap(this.app);
    const terrainBootstrapResult = await this.terrainBootstrap.start();
    if (!terrainBootstrapResult.primed) {
      const operation = terrainBootstrapResult.primeError ? "prime-dataset" : "watch-dataset";
      const error = terrainBootstrapResult.primeError ?? terrainBootstrapResult.watchError ?? new Error("Terrain bootstrap failed");
      const userMessage = operation === "prime-dataset" ? "Terrain-Daten konnten nicht geladen werden. Bitte die Vault-Dateien pruefen." : "Terrain-Aenderungen koennen nicht ueberwacht werden. Bitte die Konsole pruefen.";
      this.failIntegration(operation, "obsidian:terrain-palette", error, userMessage);
    }
    for (const manifestEntry of VIEW_MANIFEST) {
      const activation = manifestEntry.activation;
      if (!activation?.commands?.length) continue;
      for (const command of activation.commands) {
        try {
          this.addCommand({
            id: command.id,
            name: command.name,
            callback: async () => {
              try {
                await activation.open(this.app);
              } catch (error) {
                this.failIntegration("activate-view", manifestEntry.integrationId, error, `${manifestEntry.displayName} konnte nicht geoeffnet werden. Bitte die Konsole pruefen.`);
              }
            }
          });
        } catch (error) {
          this.failIntegration("register-command", manifestEntry.integrationId, error, `${manifestEntry.displayName}-Kommando konnte nicht registriert werden. Bitte die Konsole pruefen.`);
        }
      }
    }
    try {
      const { createInboxStatusBar: createInboxStatusBar2, globalEventHistoryStore: globalEventHistoryStore2 } = await Promise.resolve().then(() => (init_events(), events_exports));
      const statusBarItem = this.addStatusBarItem();
      this.inboxStatusBar = createInboxStatusBar2(this.app, globalEventHistoryStore2, statusBarItem);
      logger2.log("[inbox-status-bar] Widget registered");
    } catch (error) {
      logger2.error("[inbox-status-bar] Failed to setup widget", error);
    }
  }
  async onunload() {
    logger2.log("Plugin unloading...");
    this.inboxStatusBar?.destroy();
    this.inboxStatusBar = void 0;
    this.ipcServer?.stop();
    this.terrainBootstrap?.stop();
    try {
      await detachCartographerLeaves(this.app);
    } catch (error) {
      this.failIntegration("detach-view", "obsidian:cartographer-view", error, "Cartographer-Ansichten konnten nicht geschlossen werden. Bitte die Konsole pruefen.");
    }
    this.removeCss();
    await logger2.shutdown();
  }
  failIntegration(operation, integrationId, error, userMessage) {
    reportIntegrationIssue({ integrationId, operation, error, userMessage });
    throw error;
  }
  injectCss() {
    document.querySelectorAll("#hex-css").forEach((existingStyle) => existingStyle.remove());
    const style = document.createElement("style");
    style.id = "hex-css";
    style.textContent = HEX_PLUGIN_CSS;
    document.head.appendChild(style);
  }
  removeCss() {
    document.getElementById("hex-css")?.remove();
  }
};
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
