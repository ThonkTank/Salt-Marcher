"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// src/core/options.ts
function parseOptions(src) {
  const blockMatch = src.match(/```[\t ]*hex3x3\b[\s\S]*?\n([\s\S]*?)\n```/i);
  const body = blockMatch ? blockMatch[1] : src;
  const d = { folder: "Hexes", folderPrefix: "Hex", prefix: "hex", radius: 42 };
  const lines = body.split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
  for (const line of lines) {
    const m = /^([A-Za-z][A-Za-z0-9_]*)\s*:\s*(.+)$/.exec(line);
    if (!m) continue;
    const k = m[1].toLowerCase();
    const v = m[2].trim();
    if (k === "folder") d.folder = v;
    else if (k === "folderprefix") d.folderPrefix = v;
    else if (k === "prefix") d.prefix = v;
    else if (k === "radius") {
      const n = Number(v);
      if (!Number.isNaN(n) && n > 10) d.radius = n;
    }
  }
  if (!d.folderPrefix && d.prefix) d.folderPrefix = d.prefix;
  if (!(d.radius > 0)) d.radius = 42;
  if (d.radius < 12) d.radius = 12;
  return d;
}
var init_options = __esm({
  "src/core/options.ts"() {
    "use strict";
  }
});

// src/ui/copy.ts
var SEARCH_DROPDOWN_COPY, MODAL_COPY, MAP_WORKFLOWS_COPY, MAP_HEADER_COPY, CONFIRM_DELETE_COPY;
var init_copy = __esm({
  "src/ui/copy.ts"() {
    "use strict";
    SEARCH_DROPDOWN_COPY = {
      placeholder: "Search\u2026"
    };
    MODAL_COPY = {
      nameInput: {
        placeholder: "New hex map",
        title: "Name the new map",
        cta: "Create"
      },
      mapSelect: {
        placeholder: "Search maps\u2026"
      }
    };
    MAP_WORKFLOWS_COPY = {
      notices: {
        emptyMaps: "No maps available.",
        createSuccess: "Map created.",
        missingHexBlock: "No hex3x3 block found in this file."
      }
    };
    MAP_HEADER_COPY = {
      labels: {
        open: "Open map",
        create: "Create",
        delete: "Delete",
        save: "Save",
        saveAs: "Save as",
        trigger: "Apply"
      },
      notices: {
        missingFile: "Select a map before continuing.",
        saveSuccess: "Map saved.",
        saveError: "Saving the map failed."
      },
      selectPlaceholder: "Choose a save action\u2026"
    };
    CONFIRM_DELETE_COPY = {
      title: "Delete map?",
      body: (name) => `This will delete your map permanently. To continue, enter \u201C${name}\u201D.`,
      inputPlaceholder: (name) => name,
      buttons: {
        cancel: "Cancel",
        confirm: "Delete"
      },
      notices: {
        success: "Map deleted.",
        error: "Deleting map failed."
      }
    };
  }
});

// src/ui/modals.ts
var import_obsidian, NameInputModal, MapSelectModal;
var init_modals = __esm({
  "src/ui/modals.ts"() {
    "use strict";
    import_obsidian = require("obsidian");
    init_copy();
    NameInputModal = class extends import_obsidian.Modal {
      constructor(app, onSubmit, options) {
        super(app);
        this.onSubmit = onSubmit;
        this.value = "";
        this.placeholder = options?.placeholder ?? MODAL_COPY.nameInput.placeholder;
        this.title = options?.title ?? MODAL_COPY.nameInput.title;
        this.ctaLabel = options?.cta ?? MODAL_COPY.nameInput.cta;
        if (options?.initialValue) {
          this.value = options.initialValue.trim();
        }
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h3", { text: this.title });
        let inputEl;
        new import_obsidian.Setting(contentEl).addText((t) => {
          t.setPlaceholder(this.placeholder).onChange((v) => this.value = v.trim());
          inputEl = t.inputEl;
          if (this.value) {
            inputEl.value = this.value;
          }
        }).addButton((b) => b.setButtonText(this.ctaLabel).setCta().onClick(() => this.submit()));
        this.scope.register([], "Enter", () => this.submit());
        queueMicrotask(() => inputEl?.focus());
      }
      onClose() {
        this.contentEl.empty();
      }
      submit() {
        const name = this.value || this.placeholder;
        this.close();
        this.onSubmit(name);
      }
    };
    MapSelectModal = class extends import_obsidian.FuzzySuggestModal {
      constructor(app, files, onChoose) {
        super(app);
        this.files = files;
        this.onChoose = onChoose;
        this.setPlaceholder(MODAL_COPY.mapSelect.placeholder);
      }
      getItems() {
        return this.files;
      }
      getItemText(f) {
        return f.basename;
      }
      onChooseItem(f) {
        this.onChoose(f);
      }
    };
  }
});

// src/core/map-list.ts
async function getAllMapFiles(app) {
  const mdFiles = app.vault.getMarkdownFiles();
  const results = [];
  const rx = /```[\t ]*hex3x3\b[\s\S]*?```/i;
  for (const f of mdFiles) {
    const content = await app.vault.cachedRead(f);
    if (rx.test(content)) results.push(f);
  }
  return results.sort((a, b) => (b.stat.mtime ?? 0) - (a.stat.mtime ?? 0));
}
async function getFirstHexBlock(app, file) {
  const content = await app.vault.cachedRead(file);
  const m = content.match(/```[\t ]*hex3x3\b\s*\n([\s\S]*?)\n```/i);
  return m ? m[1].trim() : null;
}
var init_map_list = __esm({
  "src/core/map-list.ts"() {
    "use strict";
    init_modals();
  }
});

// src/core/terrain.ts
function normalizeTerrainColor(input) {
  if (typeof input !== "string") return "";
  let color = input.trim();
  if (!color) return "";
  if (color.startsWith('"') && color.endsWith('"') || color.startsWith("'") && color.endsWith("'")) {
    color = color.slice(1, -1).trim();
  }
  color = color.replace(/^[\s:]+/, "");
  return color.trim();
}
function validateTerrainSchema(next) {
  const validated = {};
  const issues = [];
  for (const [rawName, rawValue] of Object.entries(next ?? {})) {
    const name = (rawName ?? "").trim();
    const color = normalizeTerrainColor(rawValue?.color);
    if (!name && rawName !== "") {
      issues.push(`Terrain name must not be empty (received: "${rawName}")`);
      continue;
    }
    if (name.length > TERRAIN_NAME_MAX_LENGTH) {
      issues.push(`Terrain name "${name}" exceeds ${TERRAIN_NAME_MAX_LENGTH} characters`);
      continue;
    }
    if (/[:\n\r]/.test(name)) {
      issues.push(`Terrain name "${name}" must not contain colons or line breaks`);
      continue;
    }
    if (!color) {
      issues.push(`Terrain "${name}" requires a color value`);
      continue;
    }
    if (color !== "transparent" && !HEX_COLOR_RE.test(color) && !CSS_VAR_RE.test(color) && !CSS_FUNCTION_RE.test(color)) {
      issues.push(`Terrain "${name}" uses unsupported color "${color}"`);
      continue;
    }
    let numericSpeed;
    if (rawValue?.speed === void 0) {
      numericSpeed = 1;
    } else {
      numericSpeed = Number(rawValue.speed);
    }
    if (!Number.isFinite(numericSpeed)) {
      issues.push(`Terrain "${name}" speed must be a finite number`);
      continue;
    }
    if (numericSpeed < REGION_SPEED_MIN || numericSpeed > REGION_SPEED_MAX) {
      issues.push(
        `Terrain "${name}" speed ${numericSpeed} must be between ${REGION_SPEED_MIN} and ${REGION_SPEED_MAX}`
      );
      continue;
    }
    validated[name] = { color, speed: numericSpeed };
  }
  if (!("" in validated)) {
    validated[""] = { color: "transparent", speed: 1 };
  }
  if (issues.length) {
    throw new TerrainValidationError(issues);
  }
  return validated;
}
function applyTerrainSchema(map) {
  const mergedColors = { ...DEFAULT_TERRAIN_COLORS, ...Object.fromEntries(
    Object.entries(map).map(([name, value]) => [name, value.color])
  ) };
  const mergedSpeeds = { ...DEFAULT_TERRAIN_SPEEDS, ...Object.fromEntries(
    Object.entries(map).map(([name, value]) => [name, value.speed])
  ) };
  mergedColors[""] = map[""]?.color ?? "transparent";
  mergedSpeeds[""] = map[""]?.speed ?? 1;
  for (const key of Object.keys(TERRAIN_COLORS)) {
    if (!(key in mergedColors)) delete TERRAIN_COLORS[key];
  }
  Object.assign(TERRAIN_COLORS, mergedColors);
  for (const key of Object.keys(TERRAIN_SPEEDS)) {
    if (!(key in mergedSpeeds)) delete TERRAIN_SPEEDS[key];
  }
  Object.assign(TERRAIN_SPEEDS, mergedSpeeds);
}
function setTerrains(next) {
  const validated = validateTerrainSchema(next ?? {});
  applyTerrainSchema(validated);
}
var DEFAULT_TERRAIN_COLORS, DEFAULT_TERRAIN_SPEEDS, TERRAIN_COLORS, TERRAIN_SPEEDS, TERRAIN_NAME_MAX_LENGTH, REGION_SPEED_MIN, REGION_SPEED_MAX, HEX_COLOR_RE, CSS_VAR_RE, CSS_FUNCTION_RE, TerrainValidationError;
var init_terrain = __esm({
  "src/core/terrain.ts"() {
    "use strict";
    DEFAULT_TERRAIN_COLORS = Object.freeze({
      "": "transparent",
      Wald: "#2e7d32",
      Meer: "#0288d1",
      Berg: "#6d4c41"
    });
    DEFAULT_TERRAIN_SPEEDS = Object.freeze({
      "": 1,
      // leeres Terrain = neutral
      Wald: 0.6,
      Meer: 0.5,
      Berg: 0.4
    });
    TERRAIN_COLORS = { ...DEFAULT_TERRAIN_COLORS };
    TERRAIN_SPEEDS = { ...DEFAULT_TERRAIN_SPEEDS };
    TERRAIN_NAME_MAX_LENGTH = 64;
    REGION_SPEED_MIN = 0;
    REGION_SPEED_MAX = 10;
    HEX_COLOR_RE = /^#(?:[0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
    CSS_VAR_RE = /^var\(--[a-z0-9_-]+\)$/i;
    CSS_FUNCTION_RE = /^(?:rgb|rgba|hsl|hsla)\(/i;
    TerrainValidationError = class extends Error {
      constructor(issues) {
        super(`Invalid terrain schema: ${issues.join(", ")}`);
        this.issues = issues;
        this.name = "TerrainValidationError";
      }
    };
  }
});

// src/core/hex-mapper/hex-geom.ts
function oddrToAxial(rc) {
  const parity = rc.r & 1;
  const q = rc.c - (rc.r - parity) / 2;
  return { q, r: rc.r };
}
function axialToOddr(ax) {
  const parity = ax.r & 1;
  const c = ax.q + (ax.r - parity) / 2;
  return { r: ax.r, c: Math.round(c) };
}
function axialToCube(ax) {
  return { q: ax.q, r: ax.r, s: -ax.q - ax.r };
}
function cubeToAxial(cu) {
  return { q: cu.q, r: cu.r };
}
function cubeDistance(a, b) {
  return (Math.abs(a.q - b.q) + Math.abs(a.r - b.r) + Math.abs(a.s - b.s)) / 2;
}
function cubeLerp(a, b, t) {
  return {
    q: a.q + (b.q - a.q) * t,
    r: a.r + (b.r - a.r) * t,
    s: a.s + (b.s - a.s) * t
  };
}
function cubeRound(fr) {
  let q = Math.round(fr.q), r = Math.round(fr.r), s = Math.round(fr.s);
  const qd = Math.abs(q - fr.q), rd = Math.abs(r - fr.r), sd = Math.abs(s - fr.s);
  if (qd > rd && qd > sd) q = -r - s;
  else if (rd > sd) r = -q - s;
  else s = -q - r;
  return { q, r, s };
}
function lineOddR(a, b) {
  const A = axialToCube(oddrToAxial(a));
  const B = axialToCube(oddrToAxial(b));
  const N = cubeDistance(A, B);
  const out = [];
  for (let i = 0; i <= N; i++) {
    const t = N === 0 ? 0 : i / N;
    const p = cubeRound(cubeLerp(A, B, t));
    out.push(axialToOddr(cubeToAxial(p)));
  }
  return out;
}
function hexPolygonPoints(cx, cy, r) {
  const pts = [];
  for (let i = 0; i < 6; i++) {
    const ang = (60 * i - 90) * Math.PI / 180;
    pts.push(`${cx + r * Math.cos(ang)},${cy + r * Math.sin(ang)}`);
  }
  return pts.join(" ");
}
var SQRT3;
var init_hex_geom = __esm({
  "src/core/hex-mapper/hex-geom.ts"() {
    "use strict";
    SQRT3 = Math.sqrt(3);
  }
});

// src/core/hex-mapper/render/scene.ts
function createHexScene(config) {
  const { host, radius, padding, base, initialCoords } = config;
  const hexW = Math.sqrt(3) * radius;
  const hexH = 2 * radius;
  const hStep = hexW;
  const vStep = 0.75 * hexH;
  const svg = document.createElementNS(SVG_NS, "svg");
  svg.setAttribute("class", "hex3x3-map");
  svg.setAttribute("width", "100%");
  svg.style.touchAction = "none";
  const overlay = document.createElementNS(SVG_NS, "rect");
  overlay.setAttribute("fill", "transparent");
  overlay.setAttribute("pointer-events", "all");
  overlay.style.touchAction = "none";
  const contentG = document.createElementNS(SVG_NS, "g");
  svg.appendChild(overlay);
  svg.appendChild(contentG);
  host.appendChild(svg);
  const polyByCoord = /* @__PURE__ */ new Map();
  const internals = {
    bounds: null,
    viewBoxInitialized: false,
    applyFrame(adjustViewBox) {
      if (!internals.bounds) return;
      const { minX, minY, maxX, maxY } = internals.bounds;
      const paddedMinX = Math.floor(minX - padding);
      const paddedMinY = Math.floor(minY - padding);
      const paddedMaxX = Math.ceil(maxX + padding);
      const paddedMaxY = Math.ceil(maxY + padding);
      const width = Math.max(1, paddedMaxX - paddedMinX);
      const height = Math.max(1, paddedMaxY - paddedMinY);
      if (adjustViewBox || !internals.viewBoxInitialized) {
        svg.setAttribute("viewBox", `${paddedMinX} ${paddedMinY} ${width} ${height}`);
        internals.viewBoxInitialized = true;
      }
      overlay.setAttribute("x", String(paddedMinX));
      overlay.setAttribute("y", String(paddedMinY));
      overlay.setAttribute("width", String(width));
      overlay.setAttribute("height", String(height));
    },
    centerOf(coord) {
      const { r, c } = coord;
      const cx = padding + (c - base.c) * hStep + (r % 2 ? hexW / 2 : 0);
      const cy = padding + (r - base.r) * vStep + hexH / 2;
      return { cx, cy };
    },
    bboxOf(coord) {
      const { cx, cy } = internals.centerOf(coord);
      return {
        minX: cx - hexW / 2,
        maxX: cx + hexW / 2,
        minY: cy - radius,
        maxY: cy + radius
      };
    }
  };
  function mergeBounds(next) {
    if (!internals.bounds) {
      internals.bounds = { ...next };
      return;
    }
    const current = internals.bounds;
    current.minX = Math.min(current.minX, next.minX);
    current.minY = Math.min(current.minY, next.minY);
    current.maxX = Math.max(current.maxX, next.maxX);
    current.maxY = Math.max(current.maxY, next.maxY);
  }
  function addHex(coord) {
    if (polyByCoord.has(keyOf(coord))) return false;
    const { cx, cy } = internals.centerOf(coord);
    const poly = document.createElementNS(SVG_NS, "polygon");
    poly.setAttribute("points", hexPolygonPoints(cx, cy, radius));
    poly.setAttribute("data-row", String(coord.r));
    poly.setAttribute("data-col", String(coord.c));
    poly.style.fill = "transparent";
    poly.style.stroke = "var(--text-muted)";
    poly.style.strokeWidth = "2";
    poly.style.transition = "fill 120ms ease, fill-opacity 120ms ease, stroke 120ms ease";
    contentG.appendChild(poly);
    polyByCoord.set(keyOf(coord), poly);
    const label = document.createElementNS(SVG_NS, "text");
    label.setAttribute("x", String(cx));
    label.setAttribute("y", String(cy + 4));
    label.setAttribute("text-anchor", "middle");
    label.setAttribute("pointer-events", "none");
    label.setAttribute("fill", "var(--text-muted)");
    label.textContent = `${coord.r},${coord.c}`;
    contentG.appendChild(label);
    mergeBounds(internals.bboxOf(coord));
    return true;
  }
  function ensurePolys(coords) {
    let added = false;
    for (const coord of coords) {
      const key = keyOf(coord);
      if (polyByCoord.has(key)) continue;
      const created = addHex(coord);
      added = added || created;
    }
    if (added) internals.applyFrame(false);
  }
  function setFill(coord, color) {
    const poly = polyByCoord.get(keyOf(coord));
    if (!poly) return;
    const fill = color ?? "transparent";
    poly.style.fill = fill;
    poly.style.fillOpacity = fill !== "transparent" ? "0.25" : "0";
    if (fill !== "transparent") {
      poly.setAttribute("data-painted", "1");
    } else {
      poly.removeAttribute("data-painted");
    }
  }
  const initial = initialCoords.length ? initialCoords : [];
  if (initial.length) {
    for (const coord of initial) addHex(coord);
    internals.applyFrame(true);
  }
  return {
    svg,
    contentG,
    overlay,
    polyByCoord,
    ensurePolys,
    setFill,
    getViewBox: () => {
      if (!internals.bounds) {
        return { minX: 0, minY: 0, width: 0, height: 0 };
      }
      const { minX, minY, maxX, maxY } = internals.bounds;
      return { minX, minY, width: maxX - minX, height: maxY - minY };
    },
    destroy: () => {
      polyByCoord.clear();
      svg.remove();
    }
  };
}
var SVG_NS, keyOf;
var init_scene = __esm({
  "src/core/hex-mapper/render/scene.ts"() {
    "use strict";
    init_hex_geom();
    SVG_NS = "http://www.w3.org/2000/svg";
    keyOf = (coord) => `${coord.r},${coord.c}`;
  }
});

// src/core/hex-mapper/camera.ts
function attachCameraControls(svg, contentG, opts, extraTargets = []) {
  let scale = 1;
  let tx = 0, ty = 0;
  let panning = false;
  let lastX = 0, lastY = 0;
  svg.style.touchAction = "none";
  const apply = () => {
    contentG.setAttribute("transform", `translate(${tx},${ty}) scale(${scale})`);
  };
  apply();
  const svgPoint = (clientX, clientY) => {
    const pt = svg.createSVGPoint();
    pt.x = clientX;
    pt.y = clientY;
    const ctm = svg.getScreenCTM();
    if (!ctm) return { x: clientX, y: clientY };
    const p = pt.matrixTransform(ctm.inverse());
    return { x: p.x, y: p.y };
  };
  const normalizeDelta = (ev) => ev.deltaMode === 1 ? ev.deltaY * 16 : ev.deltaMode === 2 ? ev.deltaY * 360 : ev.deltaY;
  const onWheel = (ev) => {
    ev.preventDefault();
    ev.stopPropagation();
    const dy = normalizeDelta(ev);
    const factor = Math.exp(-dy * 1e-3 * (opts.zoomSpeed || 1));
    const newScale = Math.max(opts.minScale, Math.min(opts.maxScale, scale * factor));
    if (newScale === scale) return;
    const { x: sx, y: sy } = svgPoint(ev.clientX, ev.clientY);
    const wx = (sx - tx) / scale, wy = (sy - ty) / scale;
    scale = newScale;
    tx = sx - wx * scale;
    ty = sy - wy * scale;
    apply();
  };
  const onPointerDown = (ev) => {
    if (ev.button !== 1) return;
    ev.preventDefault();
    ev.stopPropagation();
    panning = true;
    lastX = ev.clientX;
    lastY = ev.clientY;
    ev.target.setPointerCapture?.(ev.pointerId);
    svg.style.cursor = "grabbing";
  };
  const onPointerMove = (ev) => {
    if (!panning) return;
    ev.preventDefault();
    ev.stopPropagation();
    const dx = ev.clientX - lastX, dy = ev.clientY - lastY;
    lastX = ev.clientX;
    lastY = ev.clientY;
    tx += dx;
    ty += dy;
    apply();
  };
  const endPan = (ev) => {
    if (!panning) return;
    if (ev instanceof PointerEvent) {
      ev.preventDefault();
      ev.stopPropagation();
      ev.target.releasePointerCapture?.(ev.pointerId);
    }
    panning = false;
    svg.style.cursor = "";
  };
  const targets = [svg, ...extraTargets];
  for (const t of targets) {
    t.addEventListener("wheel", onWheel, { passive: false });
    t.addEventListener("pointerdown", onPointerDown);
    t.addEventListener("pointermove", onPointerMove);
    t.addEventListener("pointerup", endPan);
    t.addEventListener("pointercancel", endPan);
    t.addEventListener("pointerleave", endPan);
    t.style.touchAction = "none";
  }
  window.addEventListener("blur", endPan);
  return () => {
    for (const t of targets) {
      t.removeEventListener("wheel", onWheel);
      t.removeEventListener("pointerdown", onPointerDown);
      t.removeEventListener("pointermove", onPointerMove);
      t.removeEventListener("pointerup", endPan);
      t.removeEventListener("pointercancel", endPan);
      t.removeEventListener("pointerleave", endPan);
    }
    window.removeEventListener("blur", endPan);
  };
}
var init_camera = __esm({
  "src/core/hex-mapper/camera.ts"() {
    "use strict";
  }
});

// src/core/hex-mapper/render/camera-controller.ts
function createCameraController(svg, contentG, overlay, host, options) {
  const detach = attachCameraControls(svg, contentG, options, [overlay, host]);
  return {
    destroy() {
      try {
        detach?.();
      } catch (err) {
        console.error("[hex-render] camera cleanup failed", err);
      }
    }
  };
}
var init_camera_controller = __esm({
  "src/core/hex-mapper/render/camera-controller.ts"() {
    "use strict";
    init_camera();
  }
});

// src/core/hex-mapper/render/interactions.ts
function createInteractionController(config) {
  const { svg, overlay, toContentPoint, pointToCoord, delegateRef, onDefaultClick } = config;
  let painting = false;
  let visited = null;
  let raf = 0;
  let lastPointer = null;
  const getDelegate = () => delegateRef.current;
  function convert(ev) {
    const pt = toContentPoint(ev);
    if (!pt) return null;
    return pointToCoord(pt.x, pt.y);
  }
  async function executePaintStep(ev) {
    const coord = convert(ev);
    if (!coord) return { outcome: "handled", coord: null };
    if (painting && visited?.has(keyOf2(coord))) {
      return { outcome: "handled", coord };
    }
    const handler = getDelegate().onPaintStep;
    if (!handler) return { outcome: "default", coord };
    const outcome = await handler(coord, ev);
    return { outcome, coord };
  }
  const onClick = async (ev) => {
    ev.preventDefault();
    const coord = convert(ev);
    if (!coord) return;
    const handler = getDelegate().onClick;
    const outcome = handler ? await handler(coord, ev) : "default";
    if (outcome === "default") {
      await onDefaultClick(coord, ev);
    }
  };
  const onPointerDown = (ev) => {
    if (ev.button !== 0) return;
    if (!getDelegate().onPaintStep) return;
    lastPointer = ev;
    void (async () => {
      const { outcome, coord } = await executePaintStep(ev);
      if (outcome === "start-paint" && coord) {
        painting = true;
        visited = /* @__PURE__ */ new Set([keyOf2(coord)]);
        svg.setPointerCapture?.(ev.pointerId);
        ev.preventDefault();
      } else if (outcome !== "default") {
        ev.preventDefault();
      }
    })();
  };
  const runQueuedPaintStep = () => {
    if (!painting || !lastPointer) return;
    const ev = lastPointer;
    void (async () => {
      const { outcome, coord } = await executePaintStep(ev);
      if (!painting) return;
      if (coord && outcome !== "default") {
        visited?.add(keyOf2(coord));
      }
    })();
  };
  const onPointerMove = (ev) => {
    if (!painting) return;
    lastPointer = ev;
    if (!raf) {
      raf = requestAnimationFrame(() => {
        raf = 0;
        runQueuedPaintStep();
      });
    }
    ev.preventDefault();
  };
  const endPaint = (ev) => {
    if (!painting) return;
    painting = false;
    visited?.clear();
    visited = null;
    lastPointer = null;
    if (raf) {
      cancelAnimationFrame(raf);
      raf = 0;
    }
    svg.releasePointerCapture?.(ev.pointerId);
    getDelegate().onPaintEnd?.();
    ev.preventDefault();
  };
  const onPointerCancel = (ev) => {
    if (!painting) return;
    endPaint(ev);
  };
  svg.addEventListener("click", onClick, { passive: false });
  svg.addEventListener("pointerdown", onPointerDown, { capture: true });
  svg.addEventListener("pointermove", onPointerMove, { capture: true });
  svg.addEventListener("pointerup", endPaint, { capture: true });
  svg.addEventListener("pointercancel", onPointerCancel, { capture: true });
  overlay.addEventListener("pointerdown", onPointerDown, { capture: true });
  overlay.addEventListener("pointermove", onPointerMove, { capture: true });
  overlay.addEventListener("pointerup", endPaint, { capture: true });
  overlay.addEventListener("pointercancel", onPointerCancel, { capture: true });
  return {
    destroy() {
      svg.removeEventListener("click", onClick);
      svg.removeEventListener("pointerdown", onPointerDown);
      svg.removeEventListener("pointermove", onPointerMove);
      svg.removeEventListener("pointerup", endPaint);
      svg.removeEventListener("pointercancel", onPointerCancel);
      overlay.removeEventListener("pointerdown", onPointerDown);
      overlay.removeEventListener("pointermove", onPointerMove);
      overlay.removeEventListener("pointerup", endPaint);
      overlay.removeEventListener("pointercancel", onPointerCancel);
      if (raf) {
        cancelAnimationFrame(raf);
        raf = 0;
      }
      painting = false;
      visited?.clear();
      visited = null;
      lastPointer = null;
    }
  };
}
var keyOf2;
var init_interactions = __esm({
  "src/core/hex-mapper/render/interactions.ts"() {
    "use strict";
    keyOf2 = (coord) => `${coord.r},${coord.c}`;
  }
});

// src/core/hex-mapper/render/coordinates.ts
function createCoordinateTranslator(config) {
  const { svg, contentG, base, radius, padding } = config;
  const hexW = Math.sqrt(3) * radius;
  const hexH = 2 * radius;
  const hStep = hexW;
  const vStep = 0.75 * hexH;
  const svgPoint = svg.createSVGPoint();
  const toContentPoint = (ev) => {
    const matrix = contentG.getScreenCTM();
    if (!matrix) return null;
    svgPoint.x = ev.clientX;
    svgPoint.y = ev.clientY;
    return svgPoint.matrixTransform(matrix.inverse());
  };
  const pointToCoord = (px, py) => {
    const rFloat = (py - padding - hexH / 2) / vStep + base.r;
    let r = Math.round(rFloat);
    const isOdd = r % 2 !== 0;
    let c = Math.round((px - padding - (isOdd ? hexW / 2 : 0)) / hStep + base.c);
    let best = { r, c };
    let bestD2 = Infinity;
    for (let dr = -1; dr <= 1; dr++) {
      const rr = r + dr;
      const odd = rr % 2 !== 0;
      const cc = Math.round((px - padding - (odd ? hexW / 2 : 0)) / hStep + base.c);
      const cx = padding + (cc - base.c) * hStep + (rr % 2 ? hexW / 2 : 0);
      const cy = padding + (rr - base.r) * vStep + hexH / 2;
      const dx = px - cx;
      const dy = py - cy;
      const d2 = dx * dx + dy * dy;
      if (d2 < bestD2) {
        bestD2 = d2;
        best = { r: rr, c: cc };
      }
    }
    return best;
  };
  return {
    toContentPoint,
    pointToCoord
  };
}
var init_coordinates = __esm({
  "src/core/hex-mapper/render/coordinates.ts"() {
    "use strict";
  }
});

// src/core/layout.ts
var layout_exports = {};
__export(layout_exports, {
  getCenterLeaf: () => getCenterLeaf,
  getRightLeaf: () => getRightLeaf
});
function getRightLeaf(app) {
  console.log("[Layout] Requesting right leaf...");
  const leaf = app.workspace.getRightLeaf(false) ?? app.workspace.getRightLeaf(true) ?? app.workspace.getLeaf(true);
  console.log("[Layout] Right leaf resolved:", leaf);
  return leaf;
}
function getCenterLeaf(app) {
  const leaf = app.workspace.getMostRecentLeaf() ?? app.workspace.getLeaf(false) ?? app.workspace.getLeaf(true);
  console.log("[Layout] Center leaf resolved:", leaf);
  return leaf;
}
var init_layout = __esm({
  "src/core/layout.ts"() {
    "use strict";
  }
});

// src/core/hex-mapper/hex-notes.ts
var hex_notes_exports = {};
__export(hex_notes_exports, {
  TileValidationError: () => TileValidationError,
  deleteTile: () => deleteTile,
  initTilesForNewMap: () => initTilesForNewMap,
  listTilesForMap: () => listTilesForMap,
  loadTile: () => loadTile,
  saveTile: () => saveTile,
  validateTileData: () => validateTileData
});
function validateTileData(data, options = {}) {
  const { allowUnknownTerrain = false } = options;
  const issues = [];
  const terrain = typeof data.terrain === "string" ? data.terrain.trim() : "";
  if (terrain.length > TILE_TERRAIN_MAX_LENGTH) {
    issues.push(`terrain exceeds ${TILE_TERRAIN_MAX_LENGTH} characters`);
  }
  if (!allowUnknownTerrain && terrain && !(terrain in TERRAIN_COLORS)) {
    issues.push(`unknown terrain "${terrain}"`);
  }
  const regionRaw = typeof data.region === "string" ? data.region : "";
  const region = regionRaw.trim();
  if (region.length > TILE_REGION_MAX_LENGTH) {
    issues.push(`region exceeds ${TILE_REGION_MAX_LENGTH} characters`);
  }
  const noteRaw = typeof data.note === "string" ? data.note : void 0;
  const note = noteRaw?.trim();
  if (issues.length) {
    throw new TileValidationError(issues);
  }
  return {
    terrain,
    region,
    note: note || void 0
  };
}
function mapNameFromPath(mapPath) {
  const base = mapPath.replace(/\\/g, "/").split("/").pop() || "Map";
  return base.replace(/\.md$/i, "");
}
function safeBaseName(name) {
  return name.trim().replace(/[\\\/:*?"<>|]/g, "_").replace(/\s+/g, " ");
}
function fileNameForMap(mapFile, coord) {
  const base = safeBaseName(mapNameFromPath(mapFile.path));
  return `${base}-${coord.r},${coord.c}.md`;
}
function legacyFilenames(folderPrefix, coord) {
  return [
    `${folderPrefix} ${coord.r},${coord.c}.md`,
    // z.B. "Hex 1,2.md"
    `${folderPrefix}-r${coord.r}-c${coord.c}.md`
    // z.B. "Hex-r1-c2.md"
  ];
}
function escapeRegex(src) {
  return src.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function coordFromFrontmatter(fmc) {
  if (!fmc) return null;
  const r = Number(fmc.row);
  const c = Number(fmc.col);
  if (!Number.isInteger(r) || !Number.isInteger(c)) return null;
  return { r, c };
}
function coordFromLegacyName(file, folderPrefix) {
  const base = file.path.replace(/\\/g, "/").split("/").pop() ?? file.path;
  const prefix = folderPrefix.trim();
  if (!prefix) return null;
  const spaced = new RegExp(`^${escapeRegex(prefix)}s+(-?\\d+),(-?\\d+)\\.md$`, "i");
  const dashed = new RegExp(`^${escapeRegex(prefix)}-r(-?\\d+)-c(-?\\d+)\\.md$`, "i");
  let match = base.match(spaced);
  if (match) return { r: Number(match[1]), c: Number(match[2]) };
  match = base.match(dashed);
  if (match) return { r: Number(match[1]), c: Number(match[2]) };
  return null;
}
async function readOptions(app, mapFile) {
  const raw = await app.vault.read(mapFile);
  const opts = parseOptions(raw);
  const folder = (opts.folder ?? "Hexes").toString().trim();
  const folderPrefix = (opts.folderPrefix ?? "Hex").toString().trim();
  return { folder, folderPrefix };
}
async function ensureFolder(app, folderPath) {
  const path = (0, import_obsidian2.normalizePath)(folderPath);
  const existing = app.vault.getAbstractFileByPath(path);
  if (existing && existing instanceof import_obsidian2.TFolder) return existing;
  if (existing) throw new Error(`Pfad existiert, ist aber kein Ordner: ${path}`);
  await app.vault.createFolder(path);
  const created = app.vault.getAbstractFileByPath(path);
  if (!(created && created instanceof import_obsidian2.TFolder)) throw new Error(`Ordner konnte nicht erstellt werden: ${path}`);
  return created;
}
function fm(app, file) {
  return app.metadataCache.getFileCache(file)?.frontmatter ?? null;
}
function buildMarkdown(coord, mapPath, folderPrefix, data) {
  const validated = validateTileData(data, { allowUnknownTerrain: true });
  const terrain = validated.terrain ?? "";
  const region = (validated.region ?? "").trim();
  const mapName = mapNameFromPath(mapPath);
  const bodyNote = (validated.note ?? "Notizen hier \u2026").trim();
  return [
    "---",
    `type: ${FM_TYPE}`,
    `smHexTile: true`,
    `region: "${region}"`,
    `row: ${coord.r}`,
    `col: ${coord.c}`,
    `map_path: "${mapPath}"`,
    `terrain: "${terrain}"`,
    "---",
    `[[${mapName}|\u21A9 Zur Karte]]`,
    `# ${folderPrefix} r${coord.r} c${coord.c}`,
    "",
    bodyNote,
    ""
  ].join("\n");
}
async function resolveTilePath(app, mapFile, coord) {
  const { folder, folderPrefix } = await readOptions(app, mapFile);
  const folderPath = (0, import_obsidian2.normalizePath)(folder);
  const newName = fileNameForMap(mapFile, coord);
  const newPath = `${folderPath}/${newName}`;
  const legacy = legacyFilenames(folderPrefix, coord).map((n) => `${folderPath}/${n}`);
  let file = app.vault.getAbstractFileByPath(newPath);
  if (!file) {
    for (const oldPath of legacy) {
      const oldFile = app.vault.getAbstractFileByPath(oldPath);
      if (oldFile) {
        await app.fileManager.renameFile(oldFile, newPath);
        break;
      }
    }
    file = app.vault.getAbstractFileByPath(newPath);
  }
  return { folder: folderPath, newPath, file };
}
function parseFrontmatterBlock(src) {
  const m = src.match(/^---\s*([\s\S]*?)\s*---/m);
  if (!m) return null;
  const obj = {};
  for (const line of m[1].split(/\r?\n/)) {
    const mm = line.match(/^\s*([A-Za-z0-9_]+)\s*:\s*(.*)\s*$/);
    if (!mm) continue;
    let val = mm[2].trim();
    if (val.startsWith('"') && val.endsWith('"') || val.startsWith("'") && val.endsWith("'")) {
      val = val.slice(1, -1);
    }
    if (/^-?\d+$/.test(val)) obj[mm[1]] = Number(val);
    else obj[mm[1]] = val;
  }
  return obj;
}
async function fmFromFile(app, file) {
  const raw = await app.vault.read(file);
  return parseFrontmatterBlock(raw);
}
async function ensureTileSchema(app, mapFile, file, coord, cached) {
  const mapPath = mapFile.path;
  const current = cached ?? await fmFromFile(app, file) ?? {};
  const needsType = current.type !== FM_TYPE;
  const needsMarker = current.smHexTile !== true;
  const needsRow = Number(current.row) !== coord.r;
  const needsCol = Number(current.col) !== coord.c;
  const needsMap = current.map_path !== mapPath;
  if (needsType || needsMarker || needsRow || needsCol || needsMap) {
    await app.fileManager.processFrontMatter(file, (f) => {
      f.type = FM_TYPE;
      f.smHexTile = true;
      f.row = coord.r;
      f.col = coord.c;
      f.map_path = mapPath;
    });
    return await fmFromFile(app, file) ?? { type: FM_TYPE, row: coord.r, col: coord.c, map_path: mapPath };
  }
  return current;
}
async function adoptLegacyTile(app, mapFile, file, folderPath, folderPrefix, cached) {
  if (cached && typeof cached.map_path === "string") return null;
  let coord = coordFromFrontmatter(cached);
  if (!coord) {
    coord = coordFromLegacyName(file, folderPrefix);
  }
  if (!coord) return null;
  const raw = await app.vault.read(file);
  const mapName = mapNameFromPath(mapFile.path);
  const backlinkNeedle = `[[${mapName.toLowerCase()}|`;
  if (!raw.toLowerCase().includes(backlinkNeedle)) return null;
  const desiredPath = (0, import_obsidian2.normalizePath)(`${folderPath}/${fileNameForMap(mapFile, coord)}`);
  if ((0, import_obsidian2.normalizePath)(file.path) !== desiredPath) {
    const existing = app.vault.getAbstractFileByPath(desiredPath);
    if (existing && existing !== file) {
      return null;
    }
    await app.fileManager.renameFile(file, desiredPath);
    const renamed = app.vault.getAbstractFileByPath(desiredPath);
    if (renamed && renamed instanceof import_obsidian2.TFile) {
      file = renamed;
    }
  }
  const ensured = await ensureTileSchema(app, mapFile, file, coord, cached);
  return { file, fmc: ensured, coord };
}
async function listTilesForMap(app, mapFile) {
  const { folder, folderPrefix } = await readOptions(app, mapFile);
  const folderPath = (0, import_obsidian2.normalizePath)(folder);
  const folderPathLower = (folderPath.endsWith("/") ? folderPath : folderPath + "/").toLowerCase();
  const out = [];
  for (const file of app.vault.getFiles()) {
    let tileFile = file;
    const p = tileFile.path.toLowerCase();
    if (!p.startsWith(folderPathLower)) continue;
    if (!p.endsWith(".md")) continue;
    let fmc = fm(app, tileFile);
    if (!fmc || fmc.type !== FM_TYPE) {
      fmc = await fmFromFile(app, tileFile);
    }
    let coord = coordFromFrontmatter(fmc ?? null);
    const mapPath = mapFile.path;
    const hasTargetMap = !!(fmc && fmc.type === FM_TYPE && typeof fmc.map_path === "string" && fmc.map_path === mapPath);
    if (!hasTargetMap) {
      if (fmc && typeof fmc.map_path === "string" && fmc.map_path !== mapPath) {
        continue;
      }
      const adoption = await adoptLegacyTile(app, mapFile, tileFile, folderPath, folderPrefix, fmc ?? null);
      if (!adoption) continue;
      tileFile = adoption.file;
      fmc = adoption.fmc;
      coord = adoption.coord;
    } else if (coord) {
      fmc = await ensureTileSchema(app, mapFile, tileFile, coord, fmc ?? null);
    }
    if (!coord) coord = coordFromFrontmatter(fmc ?? null);
    if (!coord) continue;
    out.push({
      coord,
      file: tileFile,
      data: (() => {
        const terrain = typeof fmc?.terrain === "string" ? fmc.terrain : "";
        const region = typeof fmc?.region === "string" ? fmc.region : "";
        try {
          const validated = validateTileData({ terrain, region }, { allowUnknownTerrain: true });
          return { terrain: validated.terrain, region: validated.region ?? "" };
        } catch (error) {
          console.warn("[salt-marcher] Ignoring invalid tile data", error);
          return { terrain: terrain.trim(), region: region.trim() };
        }
      })()
    });
  }
  return out;
}
async function loadTile(app, mapFile, coord) {
  const { file } = await resolveTilePath(app, mapFile, coord);
  if (!file) return null;
  let fmc = fm(app, file);
  if (!fmc || fmc.type !== FM_TYPE) {
    fmc = await fmFromFile(app, file);
  }
  fmc = await ensureTileSchema(app, mapFile, file, coord, fmc ?? null);
  if (!fmc || fmc.type !== FM_TYPE) return null;
  const raw = await app.vault.read(file);
  const body = raw.replace(/^---[\s\S]*?---\s*/m, "");
  const note = (body.split(/\n{2,}/).map((s) => s.trim()).find(Boolean) ?? "").trim();
  const terrain = typeof fmc.terrain === "string" ? fmc.terrain : "";
  const region = typeof fmc.region === "string" ? fmc.region : "";
  try {
    const validated = validateTileData({ terrain, region, note }, { allowUnknownTerrain: true });
    return validated;
  } catch (error) {
    console.warn("[salt-marcher] Loaded tile contains invalid data", error);
    return { terrain: terrain.trim(), region: region.trim(), note: note || void 0 };
  }
}
async function saveTile(app, mapFile, coord, data) {
  const sanitized = validateTileData(data);
  const mapPath = mapFile.path;
  const { folder, newPath, file } = await resolveTilePath(app, mapFile, coord);
  await ensureFolder(app, folder);
  if (!file) {
    const { folderPrefix } = await readOptions(app, mapFile);
    const md = buildMarkdown(coord, mapPath, folderPrefix, sanitized);
    return await app.vault.create(newPath, md);
  }
  await app.fileManager.processFrontMatter(file, (f) => {
    f.type = FM_TYPE;
    f.smHexTile = true;
    f.row = coord.r;
    f.col = coord.c;
    f.map_path = mapPath;
    if (sanitized.region !== void 0) f.region = sanitized.region ?? "";
    if (sanitized.terrain !== void 0) f.terrain = sanitized.terrain ?? "";
    if (typeof f.terrain !== "string") f.terrain = "";
  });
  if (sanitized.note !== void 0) {
    const raw = await app.vault.read(file);
    const hasFM = /^---[\s\S]*?---/m.test(raw);
    const fmPart = hasFM ? (raw.match(/^---[\s\S]*?---/m) || [""])[0] : "";
    const body = hasFM ? raw.slice(fmPart.length).trimStart() : raw;
    const lines = body.split("\n");
    const keepBacklink = lines.find((l) => /\[\[.*\|\s*↩ Zur Karte\s*\]\]/.test(l));
    const newBody = [keepBacklink ?? "", sanitized.note.trim(), ""].filter(Boolean).join("\n");
    await app.vault.modify(file, `${fmPart}
${newBody}`.trim() + "\n");
  }
  return file;
}
async function deleteTile(app, mapFile, coord) {
  const { file } = await resolveTilePath(app, mapFile, coord);
  if (!file) return;
  await app.vault.delete(file);
}
async function initTilesForNewMap(app, mapFile) {
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      await saveTile(app, mapFile, { r, c }, { terrain: "" });
    }
  }
}
var import_obsidian2, TILE_TERRAIN_MAX_LENGTH, TILE_REGION_MAX_LENGTH, TileValidationError, FM_TYPE;
var init_hex_notes = __esm({
  "src/core/hex-mapper/hex-notes.ts"() {
    "use strict";
    import_obsidian2 = require("obsidian");
    init_terrain();
    init_options();
    TILE_TERRAIN_MAX_LENGTH = 64;
    TILE_REGION_MAX_LENGTH = 120;
    TileValidationError = class extends Error {
      constructor(issues) {
        super(`Invalid tile data: ${issues.join(", ")}`);
        this.issues = issues;
        this.name = "TileValidationError";
      }
    };
    FM_TYPE = "hex";
  }
});

// src/core/hex-mapper/render/interaction-delegate.ts
function dispatchInteraction(host, coord, phase, nativeEvent) {
  let outcome = null;
  const detail = {
    r: coord.r,
    c: coord.c,
    phase,
    nativeEvent,
    setOutcome(next) {
      outcome = next;
    }
  };
  const evt = new CustomEvent(EVENT_NAME, {
    detail,
    bubbles: true,
    cancelable: true
  });
  host.dispatchEvent(evt);
  if (outcome) return outcome;
  if (evt.defaultPrevented) {
    if (phase === "paint" && nativeEvent instanceof PointerEvent) {
      const pointer = nativeEvent;
      if (pointer.button === 0 || pointer.buttons === 1) {
        return "start-paint";
      }
    }
    return "handled";
  }
  return "default";
}
function createEventBackedInteractionDelegate(host) {
  return {
    onClick(coord, ev) {
      return dispatchInteraction(host, coord, "click", ev);
    },
    onPaintStep(coord, ev) {
      return dispatchInteraction(host, coord, "paint", ev);
    }
  };
}
var EVENT_NAME;
var init_interaction_delegate = __esm({
  "src/core/hex-mapper/render/interaction-delegate.ts"() {
    "use strict";
    EVENT_NAME = "hex:click";
  }
});

// src/core/hex-mapper/render/interaction-adapter.ts
function resolveMapFile(app, mapPath) {
  const abstract = app.vault.getAbstractFileByPath(mapPath);
  return abstract instanceof import_obsidian3.TFile ? abstract : null;
}
function createInteractionAdapter(config) {
  const { app, host, mapPath } = config;
  const defaultDelegate = createEventBackedInteractionDelegate(host);
  const delegateRef = { current: defaultDelegate };
  const handleDefaultClick = async (coord, _ev) => {
    const file = resolveMapFile(app, mapPath);
    if (!file) return;
    const tfile = await saveTile(app, file, coord, { terrain: "" });
    const leaf = getCenterLeaf(app);
    await leaf.openFile(tfile, { active: true });
  };
  const setDelegate = (delegate) => {
    delegateRef.current = delegate ?? defaultDelegate;
  };
  return {
    delegateRef,
    handleDefaultClick,
    setDelegate
  };
}
var import_obsidian3;
var init_interaction_adapter = __esm({
  "src/core/hex-mapper/render/interaction-adapter.ts"() {
    "use strict";
    import_obsidian3 = require("obsidian");
    init_layout();
    init_hex_notes();
    init_interaction_delegate();
  }
});

// src/core/hex-mapper/render/bootstrap.ts
function computeBounds(tiles) {
  if (!tiles.length) return null;
  let minR = Infinity;
  let maxR = -Infinity;
  let minC = Infinity;
  let maxC = -Infinity;
  for (const tile of tiles) {
    const { r, c } = tile.coord;
    if (r < minR) minR = r;
    if (r > maxR) maxR = r;
    if (c < minC) minC = c;
    if (c > maxC) maxC = c;
  }
  return { minR, maxR, minC, maxC };
}
function buildFallback(bounds) {
  const minR = bounds ? bounds.minR : 0;
  const maxR = bounds ? bounds.maxR : DEFAULT_FALLBACK_SPAN;
  const minC = bounds ? bounds.minC : 0;
  const maxC = bounds ? bounds.maxC : DEFAULT_FALLBACK_SPAN;
  const coords = [];
  for (let r = minR; r <= maxR; r++) {
    for (let c = minC; c <= maxC; c++) {
      coords.push({ r, c });
    }
  }
  return coords;
}
async function loadTiles(app, mapPath) {
  const file = app.vault.getAbstractFileByPath(mapPath);
  if (!(file instanceof import_obsidian4.TFile)) {
    return [];
  }
  try {
    return await listTilesForMap(app, file);
  } catch {
    return [];
  }
}
async function bootstrapHexTiles(app, mapPath) {
  const tiles = await loadTiles(app, mapPath);
  const bounds = computeBounds(tiles);
  const base = {
    r: bounds ? bounds.minR : 0,
    c: bounds ? bounds.minC : 0
  };
  const initialCoords = tiles.length ? tiles.map((tile) => tile.coord) : buildFallback(bounds);
  return {
    tiles,
    base,
    initialCoords
  };
}
var import_obsidian4, DEFAULT_FALLBACK_SPAN;
var init_bootstrap = __esm({
  "src/core/hex-mapper/render/bootstrap.ts"() {
    "use strict";
    import_obsidian4 = require("obsidian");
    init_hex_notes();
    DEFAULT_FALLBACK_SPAN = 2;
  }
});

// src/core/hex-mapper/render/surface.ts
function detectContext(canvas, type) {
  try {
    const ctx = canvas.getContext(type);
    return ctx != null;
  } catch {
    return false;
  }
}
function selectRenderSurface(options = {}) {
  const { preferGpu = true } = options;
  const canvas = document.createElement("canvas");
  const webgl2 = preferGpu ? detectContext(canvas, "webgl2") : false;
  const webgl = preferGpu ? !webgl2 && detectContext(canvas, "webgl") : false;
  const canvas2d = detectContext(canvas, "2d");
  let preferred = "svg";
  if (preferGpu && (webgl2 || webgl)) {
    preferred = webgl2 ? "webgl2" : "webgl";
  } else if (canvas2d) {
    preferred = "canvas2d";
  }
  return {
    preferred,
    actual: "svg",
    capabilities: { webgl2, webgl, canvas2d }
  };
}
var init_surface = __esm({
  "src/core/hex-mapper/render/surface.ts"() {
    "use strict";
  }
});

// src/core/hex-mapper/hex-render.ts
async function renderHexMap(app, host, opts, mapPath) {
  const radius = opts.radius;
  const padding = DEFAULT_PADDING;
  const { tiles, base, initialCoords } = await bootstrapHexTiles(app, mapPath);
  const surface = selectRenderSurface();
  const scene = createHexScene({
    host,
    radius,
    padding,
    base,
    initialCoords
  });
  const camera = createCameraController(
    scene.svg,
    scene.contentG,
    scene.overlay,
    host,
    { ...CAMERA_OPTIONS }
  );
  const coordinates = createCoordinateTranslator({
    svg: scene.svg,
    contentG: scene.contentG,
    base,
    radius,
    padding
  });
  const interactionAdapter = createInteractionAdapter({ app, host, mapPath });
  const interactions = createInteractionController({
    svg: scene.svg,
    overlay: scene.overlay,
    toContentPoint: coordinates.toContentPoint,
    pointToCoord: coordinates.pointToCoord,
    delegateRef: interactionAdapter.delegateRef,
    onDefaultClick: (coord, ev) => interactionAdapter.handleDefaultClick(coord, ev)
  });
  for (const { coord, data } of tiles) {
    const color = TERRAIN_COLORS[data.terrain] ?? "transparent";
    scene.setFill(coord, color);
  }
  const ensurePolys = (coords) => {
    if (!coords.length) return;
    scene.ensurePolys(coords);
  };
  return {
    svg: scene.svg,
    contentG: scene.contentG,
    overlay: scene.overlay,
    polyByCoord: scene.polyByCoord,
    surface,
    setFill: (coord, color) => scene.setFill(coord, color),
    ensurePolys,
    setInteractionDelegate: (delegate) => {
      interactionAdapter.setDelegate(delegate);
    },
    destroy: () => {
      interactions.destroy();
      camera.destroy();
      scene.destroy();
    }
  };
}
var DEFAULT_PADDING, CAMERA_OPTIONS;
var init_hex_render = __esm({
  "src/core/hex-mapper/hex-render.ts"() {
    "use strict";
    init_terrain();
    init_scene();
    init_camera_controller();
    init_interactions();
    init_coordinates();
    init_interaction_adapter();
    init_bootstrap();
    init_surface();
    init_interaction_delegate();
    DEFAULT_PADDING = 12;
    CAMERA_OPTIONS = { minScale: 0.15, maxScale: 16, zoomSpeed: 1.01 };
  }
});

// src/core/map-maker.ts
async function createHexMapFile(app, rawName, opts = { folder: "Hexes", folderPrefix: "Hex", radius: 42 }) {
  const name = sanitizeFileName(rawName) || "Neue Hex Map";
  const content = buildHexMapMarkdown(name, opts);
  const mapsFolder = "SaltMarcher/Maps";
  await app.vault.createFolder(mapsFolder).catch(() => {
  });
  const path = await ensureUniquePath(app, `${mapsFolder}/${name}.md`);
  const file = await app.vault.create(path, content);
  await initTilesForNewMap(app, file);
  return file;
}
function buildHexMapMarkdown(name, opts) {
  const folder = (opts.folder ?? "Hexes").toString();
  const folderPrefix = (opts.folderPrefix ?? opts.prefix ?? "Hex").toString();
  const radius = typeof opts.radius === "number" ? opts.radius : 42;
  return [
    "---",
    "smMap: true",
    "---",
    `# ${name}`,
    "",
    "```hex3x3",
    `folder: ${folder}`,
    `folderPrefix: ${folderPrefix}`,
    // neu: von hex-notes ausgewertet
    `prefix: ${folderPrefix}`,
    // legacy: mitschreiben für ältere Parser
    `radius: ${radius}`,
    "```",
    ""
  ].join("\n");
}
function sanitizeFileName(input) {
  return input.trim().replace(/[\\/:*?"<>|]/g, "-").replace(/\s+/g, " ").slice(0, 120);
}
async function ensureUniquePath(app, basePath) {
  if (!app.vault.getAbstractFileByPath(basePath)) return basePath;
  const dot = basePath.lastIndexOf(".");
  const stem = dot === -1 ? basePath : basePath.slice(0, dot);
  const ext = dot === -1 ? "" : basePath.slice(dot);
  for (let i = 2; i < 9999; i++) {
    const candidate = `${stem} (${i})${ext}`;
    if (!app.vault.getAbstractFileByPath(candidate)) return candidate;
  }
  return `${stem}-${Date.now()}${ext}`;
}
var init_map_maker = __esm({
  "src/core/map-maker.ts"() {
    "use strict";
    init_hex_notes();
  }
});

// src/ui/map-workflows.ts
function applyMapButtonStyle(button) {
  Object.assign(button.style, {
    display: "flex",
    alignItems: "center",
    gap: "0.4rem",
    padding: "6px 10px",
    cursor: "pointer"
  });
}
async function promptMapSelection(app, onSelect, options) {
  const files = await getAllMapFiles(app);
  if (!files.length) {
    new import_obsidian5.Notice(options?.emptyMessage ?? MAP_WORKFLOWS_COPY.notices.emptyMaps);
    return;
  }
  new MapSelectModal(app, files, async (file) => {
    await onSelect(file);
  }).open();
}
function promptCreateMap(app, onCreate, options) {
  new NameInputModal(app, async (name) => {
    const file = await createHexMapFile(app, name);
    new import_obsidian5.Notice(options?.successMessage ?? MAP_WORKFLOWS_COPY.notices.createSuccess);
    await onCreate(file);
  }).open();
}
var import_obsidian5;
var init_map_workflows = __esm({
  "src/ui/map-workflows.ts"() {
    "use strict";
    import_obsidian5 = require("obsidian");
    init_map_maker();
    init_map_list();
    init_options();
    init_hex_render();
    init_modals();
    init_copy();
  }
});

// src/ui/search-dropdown.ts
function enhanceSelectToSearch(select, placeholder = SEARCH_DROPDOWN_COPY.placeholder) {
  if (!select || select._smEnhanced) return;
  const wrap = document.createElement("div");
  wrap.className = "sm-sd";
  const input = document.createElement("input");
  input.type = "text";
  input.placeholder = placeholder;
  input.className = "sm-sd__input";
  const menu = document.createElement("div");
  menu.className = "sm-sd__menu";
  const parent = select.parentElement;
  parent.insertBefore(wrap, select);
  wrap.appendChild(input);
  wrap.appendChild(menu);
  select.style.display = "none";
  try {
    const rect = select.getBoundingClientRect();
    if (rect && rect.width) wrap.style.width = rect.width + "px";
  } catch {
  }
  let items;
  let active = -1;
  const readOptions2 = () => {
    items = Array.from(select.options).map((opt) => ({ label: opt.text, value: opt.value }));
  };
  const openMenu = () => {
    wrap.classList.add("is-open");
  };
  const closeMenu = () => {
    wrap.classList.remove("is-open");
    active = -1;
  };
  const render = (q = "") => {
    readOptions2();
    if (q === "__NOOPEN__") {
      menu.innerHTML = "";
      closeMenu();
      return;
    }
    const qq = q.toLowerCase();
    const matches = items.filter((it) => !qq || it.label.toLowerCase().includes(qq)).slice(0, 50);
    menu.innerHTML = "";
    matches.forEach((it, idx) => {
      const el = document.createElement("div");
      el.className = "sm-sd__item";
      el.textContent = it.label;
      it.el = el;
      el.onclick = () => {
        select.value = it.value;
        select.dispatchEvent(new Event("change"));
        input.value = it.label;
        closeMenu();
      };
      menu.appendChild(el);
    });
    if (matches.length) openMenu();
    else closeMenu();
  };
  input.addEventListener("focus", () => {
    input.select();
    render("");
  });
  input.addEventListener("input", () => render(input.value));
  input.addEventListener("keydown", (ev) => {
    if (!wrap.classList.contains("is-open")) return;
    const options = Array.from(menu.children);
    if (ev.key === "ArrowDown") {
      active = Math.min(options.length - 1, active + 1);
      highlight(options);
      ev.preventDefault();
    } else if (ev.key === "ArrowUp") {
      active = Math.max(0, active - 1);
      highlight(options);
      ev.preventDefault();
    } else if (ev.key === "Enter") {
      if (options[active]) {
        options[active].click();
        ev.preventDefault();
      }
    } else if (ev.key === "Escape") {
      closeMenu();
    }
  });
  const highlight = (options) => {
    options.forEach((el2, i) => el2.classList.toggle("is-active", i === active));
    const el = options[active];
    if (el) el.scrollIntoView({ block: "nearest" });
  };
  input.addEventListener("blur", () => {
    setTimeout(closeMenu, 120);
  });
  select._smEnhanced = true;
  select._smSearchInput = input;
}
var init_search_dropdown = __esm({
  "src/ui/search-dropdown.ts"() {
    "use strict";
    init_copy();
  }
});

// src/core/terrain-store.ts
async function ensureTerrainFile(app) {
  const p = (0, import_obsidian9.normalizePath)(TERRAIN_FILE);
  const existing = app.vault.getAbstractFileByPath(p);
  if (existing instanceof import_obsidian9.TFile) return existing;
  await app.vault.createFolder(p.split("/").slice(0, -1).join("/")).catch(() => {
  });
  const body = [
    "---",
    "smList: true",
    "---",
    "# Terrains",
    "",
    "```terrain",
    ": transparent, speed: 1",
    "Wald: #2e7d32, speed: 0.6",
    "Meer: #0288d1, speed: 0.5",
    "Berg: #6d4c41, speed: 0.4",
    "```",
    ""
  ].join("\n");
  return await app.vault.create(p, body);
}
function parseTerrainBlock(md) {
  const m = md.match(BLOCK_RE);
  if (!m) return {};
  const out = {};
  for (const raw of m[1].split(/\r?\n/)) {
    const line = raw.trim();
    if (!line || line.startsWith("#")) continue;
    const mm = line.match(/^("?)(.*?)(\1)\s*:\s*([^,]+?)(?:\s*,\s*speed\s*:\s*([-+]?\d*\.?\d+))?\s*$/i);
    if (!mm) continue;
    const name = mm[2].trim();
    const color = mm[4].trim();
    const speed = mm[5] !== void 0 ? parseFloat(mm[5]) : 1;
    out[name] = { color, speed: Number.isFinite(speed) ? speed : 1 };
  }
  if (!out[""]) out[""] = { color: "transparent", speed: 1 };
  return out;
}
function stringifyTerrainBlock(map) {
  const entries = Object.entries(map);
  entries.sort(([a], [b]) => a === "" ? -1 : b === "" ? 1 : a.localeCompare(b));
  const lines = entries.map(([k, v]) => `${k || ":"}: ${v.color}, speed: ${v.speed}`);
  return ["```terrain", ...lines, "```"].join("\n");
}
async function loadTerrains(app) {
  const f = await ensureTerrainFile(app);
  const md = await app.vault.read(f);
  return parseTerrainBlock(md);
}
async function saveTerrains(app, next) {
  const f = await ensureTerrainFile(app);
  const md = await app.vault.read(f);
  const block = stringifyTerrainBlock(next);
  const replaced = md.match(BLOCK_RE) ? md.replace(BLOCK_RE, block) : md + "\n\n" + block + "\n";
  await app.vault.modify(f, replaced);
}
function resolveWatcherOptions(maybeCallback) {
  if (typeof maybeCallback === "function") {
    return { onChange: maybeCallback };
  }
  return maybeCallback ?? {};
}
function watchTerrains(app, onChangeOrOptions) {
  const options = resolveWatcherOptions(onChangeOrOptions);
  const handleError = (error, reason) => {
    if (options.onError) {
      try {
        options.onError(error, { reason });
      } catch (loggingError) {
        console.error("[salt-marcher] Terrain watcher error handler threw", loggingError);
      }
    } else {
      console.error(`[salt-marcher] Terrain watcher failed after ${reason} event`, error);
    }
  };
  const update = async (reason) => {
    try {
      if (reason === "delete") {
        await ensureTerrainFile(app);
      }
      const map = await loadTerrains(app);
      setTerrains(map);
      app.workspace.trigger?.("salt:terrains-updated");
      await options.onChange?.();
    } catch (error) {
      handleError(error, reason);
    }
  };
  const maybeUpdate = (reason, file) => {
    if (!(file instanceof import_obsidian9.TFile) || file.path !== TERRAIN_FILE) return;
    void update(reason);
  };
  const refs = ["modify", "delete"].map(
    (event) => app.vault.on(event, (file) => maybeUpdate(event, file))
  );
  let disposed = false;
  return () => {
    if (disposed) return;
    disposed = true;
    for (const ref of refs) {
      app.vault.offref(ref);
    }
  };
}
var import_obsidian9, TERRAIN_FILE, BLOCK_RE;
var init_terrain_store = __esm({
  "src/core/terrain-store.ts"() {
    "use strict";
    import_obsidian9 = require("obsidian");
    init_terrain();
    TERRAIN_FILE = "SaltMarcher/Terrains.md";
    BLOCK_RE = /```terrain\s*([\s\S]*?)```/i;
  }
});

// src/apps/almanac/domain/calendar-schema.ts
function getTotalDaysInYear(schema) {
  return schema.months.reduce((sum, month) => sum + month.length, 0);
}
function getMonthById(schema, monthId) {
  return schema.months.find((m) => m.id === monthId) ?? null;
}
function getMonthIndex(schema, monthId) {
  return schema.months.findIndex((m) => m.id === monthId);
}
function getMonthByIndex(schema, index) {
  if (index < 0 || index >= schema.months.length) {
    return null;
  }
  return schema.months[index];
}
function getHoursPerDay(schema) {
  return schema.hoursPerDay ?? DEFAULT_HOURS_PER_DAY;
}
function getMinutesPerHour(schema) {
  return schema.minutesPerHour ?? DEFAULT_MINUTES_PER_HOUR;
}
function getSecondsPerMinute(schema) {
  return schema.secondsPerMinute ?? DEFAULT_SECONDS_PER_MINUTE;
}
function getMinuteStep(schema) {
  return schema.minuteStep ?? DEFAULT_MINUTE_STEP;
}
function getTimeDefinition(schema) {
  return {
    hoursPerDay: getHoursPerDay(schema),
    minutesPerHour: getMinutesPerHour(schema),
    secondsPerMinute: getSecondsPerMinute(schema),
    minuteStep: getMinuteStep(schema)
  };
}
var DEFAULT_HOURS_PER_DAY, DEFAULT_MINUTES_PER_HOUR, DEFAULT_SECONDS_PER_MINUTE, DEFAULT_MINUTE_STEP;
var init_calendar_schema = __esm({
  "src/apps/almanac/domain/calendar-schema.ts"() {
    "use strict";
    DEFAULT_HOURS_PER_DAY = 24;
    DEFAULT_MINUTES_PER_HOUR = 60;
    DEFAULT_SECONDS_PER_MINUTE = 60;
    DEFAULT_MINUTE_STEP = 1;
  }
});

// src/apps/almanac/domain/calendar-timestamp.ts
function createDayTimestamp(calendarId, year, monthId, day) {
  return {
    calendarId,
    year,
    monthId,
    day,
    precision: "day"
  };
}
function createHourTimestamp(calendarId, year, monthId, day, hour) {
  return {
    calendarId,
    year,
    monthId,
    day,
    hour,
    precision: "hour"
  };
}
function createMinuteTimestamp(calendarId, year, monthId, day, hour, minute) {
  return {
    calendarId,
    year,
    monthId,
    day,
    hour,
    minute,
    precision: "minute"
  };
}
function compareTimestampsWithSchema(schema, a, b) {
  if (a.year !== b.year) {
    return a.year - b.year;
  }
  if (a.monthId !== b.monthId) {
    const aMonthIndex = getMonthIndex(schema, a.monthId);
    const bMonthIndex = getMonthIndex(schema, b.monthId);
    if (aMonthIndex === -1 || bMonthIndex === -1) {
      return a.monthId.localeCompare(b.monthId);
    }
    return aMonthIndex - bMonthIndex;
  }
  if (a.day !== b.day) {
    return a.day - b.day;
  }
  const aHour = a.hour ?? 0;
  const bHour = b.hour ?? 0;
  if (aHour !== bHour) {
    return aHour - bHour;
  }
  const aMinute = a.minute ?? 0;
  const bMinute = b.minute ?? 0;
  return aMinute - bMinute;
}
function formatTimestamp(ts, monthName) {
  const month = monthName ?? ts.monthId;
  if (ts.precision === "day") {
    return `Year ${ts.year}, Day ${ts.day} of ${month}`;
  }
  if (ts.precision === "hour") {
    return `Year ${ts.year}, Day ${ts.day} of ${month}, ${String(ts.hour).padStart(2, "0")}:00`;
  }
  const hourStr = String(ts.hour ?? 0).padStart(2, "0");
  const minuteStr = String(ts.minute ?? 0).padStart(2, "0");
  return `Year ${ts.year}, Day ${ts.day} of ${month}, ${hourStr}:${minuteStr}`;
}
var init_calendar_timestamp = __esm({
  "src/apps/almanac/domain/calendar-timestamp.ts"() {
    "use strict";
    init_calendar_schema();
  }
});

// src/apps/almanac/mode/travel/travel-calendar-toolbar.ts
function createModeLabel(mode) {
  switch (mode) {
    case "day":
      return "Tag";
    case "week":
      return "Woche";
    case "month":
      return "Monat";
    default:
      return "N\xE4chste";
  }
}
var MODE_ORDER, TravelCalendarToolbar;
var init_travel_calendar_toolbar = __esm({
  "src/apps/almanac/mode/travel/travel-calendar-toolbar.ts"() {
    "use strict";
    MODE_ORDER = ["upcoming", "day", "week", "month"];
    TravelCalendarToolbar = class {
      constructor(options) {
        this.modeButtons = /* @__PURE__ */ new Map();
        this.disabled = false;
        this.options = options;
        this.mode = options.mode;
        this.root = document.createElement("div");
        this.root.classList.add("sm-almanac-travel__toolbar");
        const modeGroup = document.createElement("div");
        modeGroup.classList.add("sm-almanac-travel__toolbar-modes");
        this.root.appendChild(modeGroup);
        for (const mode of MODE_ORDER) {
          const button = document.createElement("button");
          button.type = "button";
          button.classList.add("sm-almanac-travel__toolbar-mode");
          button.dataset.mode = mode;
          button.textContent = createModeLabel(mode);
          button.addEventListener("click", () => {
            if (this.disabled || this.mode === mode) {
              return;
            }
            this.options.onChangeMode(mode);
          });
          modeGroup.appendChild(button);
          this.modeButtons.set(mode, button);
        }
        const actions = document.createElement("div");
        actions.classList.add("sm-almanac-travel__toolbar-actions");
        this.root.appendChild(actions);
        const createStepButton = (label, onClick, shortcut, direction) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.classList.add("sm-almanac-travel__toolbar-step");
          btn.dataset.direction = direction;
          btn.textContent = label;
          if (shortcut) {
            btn.setAttribute("aria-keyshortcuts", shortcut);
          }
          btn.addEventListener("click", () => {
            if (!this.disabled && this.canUseDirection(direction)) {
              onClick();
            }
          });
          actions.appendChild(btn);
          return btn;
        };
        createStepButton("\u2212Tag", () => this.options.onStepDay("backward"), "Ctrl+Alt+,", "backward");
        createStepButton("+Tag", () => this.options.onStepDay("forward"), "Ctrl+Alt+.", "forward");
        createStepButton("\u2212Std", () => this.options.onStepHour("backward"), "Ctrl+Alt+'", "backward");
        createStepButton("+Std", () => this.options.onStepHour("forward"), "Ctrl+Alt+;", "forward");
        createStepButton("\u2212Min", () => this.options.onStepMinute("backward"), "Ctrl+Alt+[", "backward");
        createStepButton("+Min", () => this.options.onStepMinute("forward"), "Ctrl+Alt+]", "forward");
        const jumpButton = createStepButton("Sprung", () => this.options.onJump(), void 0, "forward");
        jumpButton.classList.add("sm-almanac-travel__toolbar-jump");
        const closeButton = document.createElement("button");
        closeButton.type = "button";
        closeButton.classList.add("sm-almanac-travel__toolbar-close");
        closeButton.textContent = "Schlie\xDFen";
        closeButton.addEventListener("click", () => {
          if (!this.disabled) {
            this.options.onClose();
          }
        });
        this.root.appendChild(closeButton);
        this.setMode(options.mode);
        this.updateStepAvailability();
      }
      setMode(mode) {
        this.mode = mode;
        for (const [value, button] of this.modeButtons.entries()) {
          const active = value === mode;
          button.classList.toggle("is-active", active);
          button.setAttribute("aria-pressed", active ? "true" : "false");
        }
      }
      setDisabled(disabled) {
        this.disabled = disabled;
        this.root.classList.toggle("is-disabled", disabled);
        for (const button of this.modeButtons.values()) {
          button.toggleAttribute("disabled", disabled);
        }
        this.updateStepAvailability();
        const closeButton = this.root.querySelector(".sm-almanac-travel__toolbar-close");
        closeButton?.toggleAttribute("disabled", disabled);
      }
      destroy() {
        for (const button of this.modeButtons.values()) {
          button.replaceWith();
        }
        this.modeButtons.clear();
        this.root.replaceChildren();
      }
      updateStepAvailability() {
        for (const btn of this.root.querySelectorAll(".sm-almanac-travel__toolbar-step")) {
          const direction = btn.dataset.direction ?? "forward";
          const usable = !this.disabled && this.canUseDirection(direction);
          btn.toggleAttribute("disabled", !usable);
        }
      }
      canUseDirection(direction) {
        if (direction === "backward") {
          return this.options.canStepBackward;
        }
        return this.options.canStepForward;
      }
    };
    TravelCalendarToolbar.displayName = "TravelCalendarToolbar";
  }
});

// src/apps/almanac/mode/travel/travel-quick-step-group.ts
function formatStepLabel(step) {
  if (!step) {
    return "\u2014";
  }
  const sign = step.delta.amount >= 0 ? "+" : "";
  const base = `${sign}${step.delta.amount}`;
  const unit = step.delta.unit === "day" ? "Tag" : step.delta.unit === "hour" ? "Std" : "Min";
  return step.label ? `${step.label} (${base} ${unit})` : `${base} ${unit}`;
}
var BUTTON_PRESETS, TravelQuickStepGroup;
var init_travel_quick_step_group = __esm({
  "src/apps/almanac/mode/travel/travel-quick-step-group.ts"() {
    "use strict";
    BUTTON_PRESETS = [
      { label: "\u22121 Tag", amount: -1, unit: "day" },
      { label: "\u22121 Std", amount: -1, unit: "hour" },
      { label: "\u2212", amount: -1, unit: "minute" },
      { label: "+", amount: 1, unit: "minute" },
      { label: "+1 Std", amount: 1, unit: "hour" },
      { label: "+1 Tag", amount: 1, unit: "day" }
    ];
    TravelQuickStepGroup = class {
      constructor(options) {
        this.buttons = [];
        this.minuteStep = Math.max(1, Math.floor(options.minuteStep) || 1);
        this.disabled = Boolean(options.disabled);
        this.onAdvance = options.onAdvance;
        this.root = document.createElement("div");
        this.root.classList.add("sm-almanac-travel__quick-steps");
        const buttonGroup = document.createElement("div");
        buttonGroup.classList.add("sm-almanac-travel__quick-steps-group");
        this.root.appendChild(buttonGroup);
        for (const preset of BUTTON_PRESETS) {
          const button = document.createElement("button");
          button.type = "button";
          button.classList.add("sm-almanac-travel__quick-steps-button");
          button.textContent = preset.label;
          button.addEventListener("click", () => {
            if (this.disabled) {
              return;
            }
            const amount = preset.unit === "minute" ? preset.amount * this.minuteStep : preset.amount;
            this.onAdvance({ amount, unit: preset.unit });
          });
          buttonGroup.appendChild(button);
          this.buttons.push(button);
        }
        this.lastStepLabel = document.createElement("div");
        this.lastStepLabel.classList.add("sm-almanac-travel__quick-steps-last");
        this.root.appendChild(this.lastStepLabel);
        this.lastStepLabel.textContent = formatStepLabel(options.lastStep);
        this.updateDisabledState();
      }
      update(options) {
        if (typeof options.minuteStep === "number" && options.minuteStep > 0) {
          this.minuteStep = Math.max(1, Math.floor(options.minuteStep));
        }
        if (typeof options.disabled === "boolean") {
          this.disabled = options.disabled;
          this.updateDisabledState();
        }
        if (options.lastStep !== void 0) {
          this.lastStepLabel.textContent = formatStepLabel(options.lastStep);
        }
      }
      destroy() {
        for (const button of this.buttons) {
          button.replaceWith();
        }
        this.lastStepLabel.replaceWith();
        this.root.replaceChildren();
      }
      updateDisabledState() {
        for (const button of this.buttons) {
          button.toggleAttribute("disabled", this.disabled);
          button.setAttribute("aria-disabled", this.disabled ? "true" : "false");
        }
        if (this.disabled) {
          this.root.classList.add("sm-almanac-travel__quick-steps--disabled");
        } else {
          this.root.classList.remove("sm-almanac-travel__quick-steps--disabled");
        }
      }
    };
    TravelQuickStepGroup.displayName = "TravelQuickStepGroup";
  }
});

// src/apps/almanac/mode/travel/travel-calendar-leaf.ts
function formatAdvanceStep(step) {
  if (!step) {
    return "\u2014";
  }
  const sign = step.amount >= 0 ? "+" : "";
  const unit = step.unit === "day" ? "Tag" : step.unit === "hour" ? "Std" : "Min";
  return `${sign}${step.amount} ${unit}`;
}
var TravelCalendarLeaf;
var init_travel_calendar_leaf = __esm({
  "src/apps/almanac/mode/travel/travel-calendar-leaf.ts"() {
    "use strict";
    init_calendar_timestamp();
    init_travel_calendar_toolbar();
    init_travel_quick_step_group();
    TravelCalendarLeaf = class {
      constructor(options) {
        this.currentMode = options.mode;
        this.onFollowUp = options.onFollowUp;
        this.root = document.createElement("div");
        this.root.classList.add("sm-almanac-travel__leaf");
        if (!options.visible) {
          this.root.classList.add("is-hidden");
        }
        options.host.appendChild(this.root);
        const toolbarOptions = {
          mode: options.mode,
          canStepBackward: true,
          canStepForward: true,
          onChangeMode: options.onModeChange,
          onStepDay: (direction) => {
            const amount = direction === "forward" ? 1 : -1;
            options.onAdvance({ amount, unit: "day" });
          },
          onStepHour: (direction) => {
            const amount = direction === "forward" ? 1 : -1;
            options.onAdvance({ amount, unit: "hour" });
          },
          onStepMinute: (direction) => {
            const amount = direction === "forward" ? options.minuteStep : -options.minuteStep;
            options.onAdvance({ amount, unit: "minute" });
          },
          onJump: options.onJump,
          onClose: options.onClose
        };
        this.toolbar = new TravelCalendarToolbar(toolbarOptions);
        this.root.appendChild(this.toolbar.root);
        this.quickSteps = new TravelQuickStepGroup({
          minuteStep: options.minuteStep,
          onAdvance: options.onAdvance,
          lastStep: void 0
        });
        this.root.appendChild(this.quickSteps.root);
        const infoSection = document.createElement("div");
        infoSection.classList.add("sm-almanac-travel__leaf-info");
        this.root.appendChild(infoSection);
        this.timestampEl = document.createElement("div");
        this.timestampEl.classList.add("sm-almanac-travel__leaf-timestamp");
        this.timestampEl.textContent = options.currentTimestamp ? formatTimestamp(options.currentTimestamp) : "\u2014";
        infoSection.appendChild(this.timestampEl);
        this.messageEl = document.createElement("div");
        this.messageEl.classList.add("sm-almanac-travel__leaf-message");
        infoSection.appendChild(this.messageEl);
        this.summaryEl = document.createElement("div");
        this.summaryEl.classList.add("sm-almanac-travel__leaf-last-step");
        infoSection.appendChild(this.summaryEl);
        const listWrapper = document.createElement("div");
        listWrapper.classList.add("sm-almanac-travel__leaf-log");
        this.root.appendChild(listWrapper);
        this.logList = document.createElement("ul");
        this.logList.classList.add("sm-almanac-travel__leaf-log-list");
        listWrapper.appendChild(this.logList);
        if (options.isLoading) {
          this.root.classList.add("is-loading");
        }
      }
      setPanel(snapshot) {
        this.timestampEl.textContent = snapshot?.timestampLabel ?? "\u2014";
        this.messageEl.textContent = snapshot?.message ?? "";
        if (snapshot?.lastAdvanceStep) {
          this.quickSteps.update({
            lastStep: {
              delta: {
                amount: snapshot.lastAdvanceStep.amount,
                unit: snapshot.lastAdvanceStep.unit
              }
            }
          });
        } else {
          this.quickSteps.update({ lastStep: void 0 });
        }
        this.summaryEl.textContent = formatAdvanceStep(snapshot?.lastAdvanceStep);
        this.logList.replaceChildren();
        const entries = snapshot?.logEntries ?? [];
        if (entries.length === 0) {
          const item = document.createElement("li");
          item.classList.add("sm-almanac-travel__leaf-log-item", "sm-almanac-travel__leaf-log-item--empty");
          item.textContent = snapshot?.reason === "jump" ? "Keine \xFCbersprungenen Ereignisse" : "Keine neuen Hooks";
          this.logList.appendChild(item);
          return;
        }
        for (const entry of entries) {
          const item = document.createElement("li");
          item.classList.add("sm-almanac-travel__leaf-log-item");
          if (entry.skipped) {
            item.classList.add("sm-almanac-travel__leaf-log-item--skipped");
          }
          const kind = entry.kind === "event" ? "Ereignis" : "Ph\xE4nomen";
          item.textContent = `${kind}: ${entry.title} \u2022 ${entry.occurrenceLabel}${entry.skipped ? " \u2022 \xFCbersprungen" : ""}`;
          item.addEventListener("click", () => {
            if (entry.kind === "event") {
              this.onFollowUp(entry.id);
            }
          });
          this.logList.appendChild(item);
        }
      }
      setMode(mode) {
        this.currentMode = mode;
        this.toolbar.setMode(mode);
      }
      setLoading(loading) {
        this.root.classList.toggle("is-loading", loading);
        this.toolbar.setDisabled(loading);
        this.quickSteps.update({ disabled: loading });
      }
      setError(message) {
        this.root.classList.toggle("has-error", Boolean(message));
        this.messageEl.textContent = message ?? "";
      }
      setQuickStep(step) {
        this.quickSteps.update({ lastStep: step ? { label: step.label ?? void 0, delta: step.delta } : void 0 });
        this.summaryEl.textContent = step ? formatAdvanceStep({ amount: step.delta.amount, unit: step.delta.unit }) : "\u2014";
      }
      setMinuteStep(step) {
        this.quickSteps.update({ minuteStep: step });
      }
      setVisible(visible) {
        this.root.classList.toggle("is-hidden", !visible);
      }
      destroy() {
        this.toolbar.destroy();
        this.quickSteps.destroy();
        this.root.replaceChildren();
        this.root.remove();
      }
    };
    TravelCalendarLeaf.displayName = "TravelCalendarLeaf";
  }
});

// src/apps/almanac/mode/travel/index.ts
var init_travel = __esm({
  "src/apps/almanac/mode/travel/index.ts"() {
    "use strict";
    init_travel_calendar_leaf();
    init_travel_calendar_toolbar();
    init_travel_quick_step_group();
  }
});

// src/apps/cartographer/travel/ui/sidebar.ts
function createSidebar(host) {
  host.empty();
  host.classList.add("sm-cartographer__sidebar--travel");
  const root = host.createDiv({ cls: "sm-cartographer__travel" });
  const controlsHost = root.createDiv({ cls: "sm-cartographer__travel-controls" });
  const tileRow = root.createDiv({ cls: "sm-cartographer__travel-row" });
  tileRow.createSpan({ cls: "sm-cartographer__travel-label", text: "Aktuelles Hex" });
  const tileValue = tileRow.createSpan({
    cls: "sm-cartographer__travel-value",
    text: "\u2014"
  });
  const speedRow = root.createDiv({ cls: "sm-cartographer__travel-row" });
  speedRow.createSpan({ cls: "sm-cartographer__travel-label", text: "Party Speed (mph)" });
  const speedInput = speedRow.createEl("input", {
    type: "number",
    cls: "sm-cartographer__travel-input",
    attr: { step: "0.1", min: "0.1", value: "1" }
  });
  const leafHost = root.createDiv({ cls: "sm-cartographer__travel-leaf" });
  let travelHandlers = {
    onAdvance: () => {
    },
    onModeChange: () => {
    },
    onJump: () => {
    },
    onClose: () => {
    },
    onFollowUp: () => {
    }
  };
  const travelLeaf = new TravelCalendarLeaf({
    host: leafHost,
    mode: "upcoming",
    visible: false,
    minuteStep: 1,
    currentTimestamp: null,
    isLoading: false,
    onModeChange: (mode) => travelHandlers.onModeChange(mode),
    onAdvance: (payload) => travelHandlers.onAdvance(payload),
    onJump: () => travelHandlers.onJump(),
    onClose: () => travelHandlers.onClose(),
    onFollowUp: (eventId) => travelHandlers.onFollowUp(eventId)
  });
  let onChange = () => {
  };
  speedInput.onchange = () => {
    const v = parseFloat(speedInput.value);
    const val = Number.isFinite(v) && v > 0 ? v : 1;
    speedInput.value = String(val);
    onChange(val);
  };
  const setTile = (rc) => {
    tileValue.textContent = rc ? `${rc.r},${rc.c}` : "\u2014";
  };
  const setSpeed = (v) => {
    const next = String(v);
    if (speedInput.value !== next) speedInput.value = next;
  };
  const setTravelPanel = (panel) => {
    travelLeaf.setPanel(panel);
    travelLeaf.setVisible(Boolean(panel));
    travelLeaf.setLoading(false);
  };
  const setTitle = (title) => {
    if (title && title.trim().length > 0) {
      host.dataset.mapTitle = title;
    } else {
      delete host.dataset.mapTitle;
    }
  };
  return {
    root,
    setTitle,
    controlsHost,
    setTile,
    setSpeed,
    setTravelPanel,
    onSpeedChange: (fn) => onChange = fn,
    setTravelHandlers: (handlers) => {
      travelHandlers = {
        onAdvance: handlers.onAdvance ?? travelHandlers.onAdvance,
        onModeChange: handlers.onModeChange ?? travelHandlers.onModeChange,
        onJump: handlers.onJump ?? travelHandlers.onJump,
        onClose: handlers.onClose ?? travelHandlers.onClose,
        onFollowUp: handlers.onFollowUp ?? travelHandlers.onFollowUp
      };
    },
    destroy: () => {
      travelLeaf.destroy();
      host.empty();
      host.classList.remove("sm-cartographer__sidebar--travel");
      delete host.dataset.mapTitle;
    }
  };
}
var init_sidebar = __esm({
  "src/apps/cartographer/travel/ui/sidebar.ts"() {
    "use strict";
    init_travel();
  }
});

// src/apps/cartographer/travel/render/draw-route.ts
function drawRoute(args) {
  const { layer, route, centerOf, highlightIndex = null, start = null } = args;
  while (layer.firstChild) layer.removeChild(layer.firstChild);
  const pts = [];
  const startCtr = start ? centerOf(start) : null;
  if (startCtr) pts.push(`${startCtr.x},${startCtr.y}`);
  const centers = route.map((n) => centerOf(n));
  for (const p of centers) if (p) pts.push(`${p.x},${p.y}`);
  if (pts.length >= 2) {
    const pl = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
    pl.setAttribute("points", pts.join(" "));
    pl.setAttribute("fill", "none");
    pl.setAttribute("stroke", "var(--interactive-accent)");
    pl.setAttribute("stroke-width", "3");
    pl.setAttribute("stroke-linejoin", "round");
    pl.setAttribute("stroke-linecap", "round");
    pl.style.pointerEvents = "none";
    layer.appendChild(pl);
  }
  route.forEach((node, i) => {
    const ctr = centers[i];
    if (!ctr) return;
    const baseRadius = node.kind === "user" ? USER_RADIUS : AUTO_RADIUS;
    const hitRadius = baseRadius + HITBOX_PADDING;
    const hit = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    hit.setAttribute("cx", String(ctr.x));
    hit.setAttribute("cy", String(ctr.y));
    hit.setAttribute("r", String(hitRadius));
    hit.setAttribute("data-idx", String(i));
    hit.classList.add("tg-route-dot-hitbox");
    hit.style.fill = "transparent";
    hit.setAttribute("stroke", "transparent");
    hit.style.pointerEvents = "all";
    hit.style.cursor = "grab";
    layer.appendChild(hit);
    const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    dot.setAttribute("cx", String(ctr.x));
    dot.setAttribute("cy", String(ctr.y));
    dot.setAttribute("r", String(baseRadius));
    dot.setAttribute("data-radius", String(baseRadius));
    dot.setAttribute("data-kind", node.kind);
    dot.setAttribute("data-idx", String(i));
    dot.classList.add("tg-route-dot");
    dot.classList.add(node.kind === "user" ? "tg-route-dot--user" : "tg-route-dot--auto");
    dot.style.pointerEvents = "auto";
    dot.style.cursor = "grab";
    layer.appendChild(dot);
  });
  updateHighlight(layer, highlightIndex);
}
function updateHighlight(layer, highlightIndex) {
  const dots = Array.from(layer.querySelectorAll(".tg-route-dot"));
  dots.forEach((el, idx) => {
    const isHi = highlightIndex != null && idx === highlightIndex;
    const baseRadius = Number(el.dataset.radius || el.getAttribute("r") || (el.dataset.kind === "user" ? USER_RADIUS : AUTO_RADIUS));
    el.classList.toggle("is-highlighted", isHi);
    el.setAttribute("stroke", isHi ? "var(--background-modifier-border)" : "none");
    el.setAttribute("stroke-width", isHi ? "2" : "0");
    el.setAttribute("r", String(isHi ? baseRadius + HIGHLIGHT_OFFSET : baseRadius));
    el.style.removeProperty("opacity");
    el.style.cursor = "grab";
  });
}
var USER_RADIUS, AUTO_RADIUS, HIGHLIGHT_OFFSET, HITBOX_PADDING;
var init_draw_route = __esm({
  "src/apps/cartographer/travel/render/draw-route.ts"() {
    "use strict";
    USER_RADIUS = 7;
    AUTO_RADIUS = 5;
    HIGHLIGHT_OFFSET = 2;
    HITBOX_PADDING = 6;
  }
});

// src/apps/cartographer/travel/ui/route-layer.ts
function createRouteLayer(contentRoot, centerOf) {
  const el = document.createElementNS("http://www.w3.org/2000/svg", "g");
  el.classList.add("tg-route-layer");
  contentRoot.appendChild(el);
  function draw(route, highlightIndex = null, start) {
    drawRoute({ layer: el, route, centerOf, highlightIndex, start });
  }
  function highlight(i) {
    updateHighlight(el, i);
  }
  function destroy() {
    el.remove();
  }
  return { el, draw, highlight, destroy };
}
var init_route_layer = __esm({
  "src/apps/cartographer/travel/ui/route-layer.ts"() {
    "use strict";
    init_draw_route();
  }
});

// src/apps/cartographer/travel/ui/token-layer.ts
function createTokenLayer(contentG) {
  const el = document.createElementNS("http://www.w3.org/2000/svg", "g");
  el.classList.add("tg-token");
  el.style.pointerEvents = "auto";
  el.style.cursor = "grab";
  contentG.appendChild(el);
  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle.setAttribute("r", "14");
  circle.classList.add("tg-token__circle");
  el.appendChild(circle);
  let vx = 0, vy = 0;
  let rafId = null;
  let pendingReject = null;
  const makeCancelError = () => {
    const err = new Error("token-move-cancelled");
    err.name = "TokenMoveCancelled";
    return err;
  };
  const cancelActiveAnimation = (reason = makeCancelError()) => {
    if (rafId != null) {
      cancelAnimationFrame(rafId);
      rafId = null;
    }
    if (pendingReject) {
      const reject = pendingReject;
      pendingReject = null;
      reject(reason);
    }
  };
  function setPos(x, y) {
    vx = x;
    vy = y;
    el.setAttribute("transform", `translate(${x},${y})`);
  }
  function moveTo(x, y, durMs) {
    cancelActiveAnimation();
    if (durMs <= 0) {
      setPos(x, y);
      return Promise.resolve();
    }
    const x0 = vx;
    const y0 = vy;
    const dx = x - x0;
    const dy = y - y0;
    const t0 = performance.now();
    return new Promise((resolve, reject) => {
      pendingReject = reject;
      const step = () => {
        const t = (performance.now() - t0) / durMs;
        if (t >= 1) {
          setPos(x, y);
          rafId = null;
          pendingReject = null;
          resolve();
          return;
        }
        const k = t < 0 ? 0 : t;
        setPos(x0 + dx * k, y0 + dy * k);
        rafId = requestAnimationFrame(step);
      };
      rafId = requestAnimationFrame(step);
    });
  }
  function show() {
    el.style.display = "";
  }
  function hide() {
    el.style.display = "none";
  }
  function stop() {
    cancelActiveAnimation();
  }
  function destroy() {
    cancelActiveAnimation();
    el.remove();
  }
  hide();
  return { el, setPos, moveTo, stop, show, hide, destroy };
}
var init_token_layer = __esm({
  "src/apps/cartographer/travel/ui/token-layer.ts"() {
    "use strict";
  }
});

// src/apps/cartographer/travel/domain/state.store.ts
function createStore() {
  let state = {
    tokenRC: { r: 0, c: 0 },
    route: [],
    editIdx: null,
    tokenSpeed: 3,
    // mph default party speed
    currentTile: null,
    playing: false,
    tempo: 1,
    clockHours: 0
  };
  const subs = /* @__PURE__ */ new Set();
  const get = () => state;
  const set = (patch) => {
    state = { ...state, ...patch };
    emit();
  };
  const replace = (next) => {
    state = next;
    emit();
  };
  const subscribe = (fn) => {
    subs.add(fn);
    fn(state);
    return () => subs.delete(fn);
  };
  const emit = () => {
    for (const fn of subs) fn(state);
  };
  return { get, set, replace, subscribe, emit };
}
var init_state_store = __esm({
  "src/apps/cartographer/travel/domain/state.store.ts"() {
    "use strict";
  }
});

// src/apps/cartographer/travel/domain/expansion.ts
function expandCoords(a, b) {
  const seg = lineOddR(a, b);
  if (seg.length <= 1) return [];
  seg.shift();
  return seg;
}
function rebuildFromAnchors(tokenRC, anchors) {
  const route = [];
  let cur = tokenRC;
  for (let i = 0; i < anchors.length; i++) {
    const next = anchors[i];
    const seg = expandCoords(cur, next);
    const autos = seg.slice(0, Math.max(0, seg.length - 1)).map(asAutoNode);
    route.push(...autos);
    route.push(asUserNode(next));
    cur = next;
  }
  return route;
}
var asUserNode, asAutoNode;
var init_expansion = __esm({
  "src/apps/cartographer/travel/domain/expansion.ts"() {
    "use strict";
    init_hex_geom();
    asUserNode = (rc) => ({ ...rc, kind: "user" });
    asAutoNode = (rc) => ({ ...rc, kind: "auto" });
  }
});

// src/apps/cartographer/travel/domain/terrain.service.ts
async function loadTerrainSpeed(app, mapFile, rc) {
  try {
    const data = await loadTile(app, mapFile, rc);
    const t = data?.terrain ?? "";
    const s = TERRAIN_SPEEDS[t];
    return Number.isFinite(s) ? s : 1;
  } catch {
    return 1;
  }
}
var init_terrain_service = __esm({
  "src/apps/cartographer/travel/domain/terrain.service.ts"() {
    "use strict";
    init_terrain();
    init_hex_notes();
  }
});

// src/apps/cartographer/travel/domain/persistence.ts
async function loadTokenCoordFromMap(app, mapFile) {
  const tiles = await listTilesForMap(app, mapFile);
  for (const rc of tiles) {
    const data = await loadTile(app, mapFile, rc).catch(() => null);
    if (data && data[TOKEN_KEY] === true) return rc;
  }
  return null;
}
async function writeTokenToTiles(app, mapFile, rc) {
  const tiles = await listTilesForMap(app, mapFile);
  for (const t of tiles) {
    const data = await loadTile(app, mapFile, t).catch(() => null);
    if (data && data[TOKEN_KEY] === true && (t.r !== rc.r || t.c !== rc.c)) {
      await saveTile(app, mapFile, t, { ...data, [TOKEN_KEY]: false });
    }
  }
  const exists = tiles.some((t) => t.r === rc.r && t.c === rc.c);
  if (!exists) return;
  const cur = await loadTile(app, mapFile, rc).catch(() => ({}));
  await saveTile(app, mapFile, rc, { ...cur, [TOKEN_KEY]: true });
}
var TOKEN_KEY;
var init_persistence = __esm({
  "src/apps/cartographer/travel/domain/persistence.ts"() {
    "use strict";
    init_hex_notes();
    TOKEN_KEY = "token_travel";
  }
});

// src/core/regions-store.ts
var regions_store_exports = {};
__export(regions_store_exports, {
  REGIONS_FILE: () => REGIONS_FILE,
  ensureRegionsFile: () => ensureRegionsFile,
  loadRegions: () => loadRegions,
  parseRegionsBlock: () => parseRegionsBlock,
  saveRegions: () => saveRegions,
  stringifyRegionsBlock: () => stringifyRegionsBlock,
  watchRegions: () => watchRegions
});
async function ensureRegionsFile(app) {
  const p = (0, import_obsidian10.normalizePath)(REGIONS_FILE);
  const existing = app.vault.getAbstractFileByPath(p);
  if (existing instanceof import_obsidian10.TFile) return existing;
  await app.vault.createFolder(p.split("/").slice(0, -1).join("/")).catch(() => {
  });
  const body = [
    "---",
    "smList: true",
    "---",
    "# Regions",
    "",
    "```regions",
    "# Name: Terrain",
    "# Beispiel:",
    "# Saltmarsh: K\xFCste",
    "```",
    ""
  ].join("\n");
  return await app.vault.create(p, body);
}
function parseRegionsBlock(md) {
  const m = md.match(BLOCK_RE2);
  if (!m) return [];
  const out = [];
  for (const raw of m[1].split(/\r?\n/)) {
    const line = raw.trim();
    if (!line || line.startsWith("#")) continue;
    const mm = line.match(/^("?)(.*?)\1\s*:\s*(.*)$/);
    if (!mm) continue;
    const name = (mm[2] || "").trim();
    const rest = (mm[3] || "").trim();
    let terrain = rest;
    let encounterOdds = void 0;
    const em = rest.match(/,\s*encounter\s*:\s*([^,]+)\s*$/i);
    if (em) {
      terrain = rest.slice(0, em.index).trim();
      const spec = em[1].trim();
      const frac = spec.match(/^1\s*\/\s*(\d+)$/);
      if (frac) encounterOdds = parseInt(frac[1], 10) || void 0;
      else {
        const n = parseInt(spec, 10);
        if (Number.isFinite(n) && n > 0) encounterOdds = n;
      }
    }
    out.push({ name, terrain, encounterOdds });
  }
  return out;
}
function stringifyRegionsBlock(list) {
  const lines = list.map((r) => {
    const base = `${r.name}: ${r.terrain || ""}`;
    const n = r.encounterOdds;
    return n && n > 0 ? `${base}, encounter: 1/${n}` : base;
  });
  return ["```regions", ...lines, "```"].join("\n");
}
async function loadRegions(app) {
  const f = await ensureRegionsFile(app);
  const md = await app.vault.read(f);
  return parseRegionsBlock(md);
}
async function saveRegions(app, list) {
  const f = await ensureRegionsFile(app);
  const md = await app.vault.read(f);
  const block = stringifyRegionsBlock(list);
  const replaced = md.match(BLOCK_RE2) ? md.replace(BLOCK_RE2, block) : md + "\n\n" + block + "\n";
  await app.vault.modify(f, replaced);
}
function watchRegions(app, onChange) {
  const targetPath = (0, import_obsidian10.normalizePath)(REGIONS_FILE);
  const emitUpdate = () => {
    app.workspace.trigger?.("salt:regions-updated");
    onChange?.();
  };
  let notifyTimer = null;
  const scheduleUpdate = () => {
    if (notifyTimer) clearTimeout(notifyTimer);
    notifyTimer = setTimeout(() => {
      notifyTimer = null;
      emitUpdate();
    }, 200);
  };
  const handleModify = (file) => {
    if ((0, import_obsidian10.normalizePath)(file.path) !== targetPath) return;
    scheduleUpdate();
  };
  const handleDelete = async (file) => {
    if (!(file instanceof import_obsidian10.TFile) || (0, import_obsidian10.normalizePath)(file.path) !== targetPath) return;
    console.warn(
      "Salt Marcher regions store detected Regions.md deletion; attempting automatic recreation."
    );
    try {
      await ensureRegionsFile(app);
      new import_obsidian10.Notice("Regions.md wurde automatisch neu erstellt.");
    } catch (error) {
      console.error(
        "Salt Marcher regions store failed to recreate Regions.md automatically.",
        error
      );
      new import_obsidian10.Notice("Regions.md konnte nicht automatisch neu erstellt werden. Bitte manuell wiederherstellen.");
    }
    scheduleUpdate();
  };
  app.vault.on("modify", handleModify);
  app.vault.on("delete", handleDelete);
  return () => {
    if (notifyTimer) {
      clearTimeout(notifyTimer);
      notifyTimer = null;
    }
    app.vault.off("modify", handleModify);
    app.vault.off("delete", handleDelete);
  };
}
var import_obsidian10, REGIONS_FILE, BLOCK_RE2;
var init_regions_store = __esm({
  "src/core/regions-store.ts"() {
    "use strict";
    import_obsidian10 = require("obsidian");
    REGIONS_FILE = "SaltMarcher/Regions.md";
    BLOCK_RE2 = /```regions\s*([\s\S]*?)```/i;
  }
});

// src/apps/cartographer/travel/domain/playback.ts
function createPlayback(cfg) {
  const { app, getMapFile, adapter, store, minSecondsPerTile, onEncounter } = cfg;
  let playing = false;
  let currentRun = null;
  let clockTimer = null;
  let hourAcc = 0;
  function trimRoutePassed(token) {
    const cur = store.get();
    let i = 0;
    while (i < cur.route.length && cur.route[i].r === token.r && cur.route[i].c === token.c) i++;
    if (i > 0) store.set({ route: cur.route.slice(i) });
  }
  async function play() {
    if (playing) return;
    if (currentRun) {
      try {
        await currentRun;
      } catch {
      }
    }
    const mapFile = getMapFile();
    if (!mapFile) return;
    const s0 = store.get();
    if (s0.route.length === 0) return;
    const run = (async () => {
      playing = true;
      store.set({ playing: true });
      if (clockTimer == null) {
        clockTimer = window.setInterval(() => {
          const s = store.get();
          const tempo = Math.max(0.1, Math.min(10, s.tempo || 1));
          const nextHours = (s.clockHours || 0) + tempo;
          hourAcc += tempo;
          while (hourAcc >= 1) {
            hourAcc -= 1;
            void checkEncounter();
          }
          store.set({ clockHours: nextHours });
        }, 1e3);
      }
      try {
        while (playing) {
          const s = store.get();
          if (s.route.length === 0) break;
          const next = s.route[0];
          adapter.ensurePolys([{ r: next.r, c: next.c }]);
          const terr = await loadTerrainSpeed(app, mapFile, next);
          const mph = Math.max(0.1, s.tokenSpeed);
          const hoursPerTile = 3 / mph * terr;
          const tempo = Math.max(0.1, Math.min(10, s.tempo || 1));
          const seconds = Math.max(minSecondsPerTile, hoursPerTile / tempo);
          const dur = seconds * 1e3;
          const ctr = adapter.centerOf(next);
          let cancelled = false;
          if (ctr) {
            try {
              await adapter.token.moveTo(ctr.x, ctr.y, dur);
            } catch (err) {
              if (err instanceof Error && err.name === "TokenMoveCancelled") {
                cancelled = true;
              } else {
                throw err;
              }
            }
          }
          if (cancelled) break;
          const tokenRC = { r: next.r, c: next.c };
          store.set({ tokenRC, currentTile: tokenRC });
          await writeTokenToTiles(app, mapFile, tokenRC);
          trimRoutePassed(tokenRC);
          if (!playing) break;
        }
      } finally {
        playing = false;
        store.set({ playing: false });
        if (clockTimer != null) {
          clearInterval(clockTimer);
          clockTimer = null;
        }
      }
    })();
    currentRun = run;
    try {
      await run;
    } finally {
      if (currentRun === run) currentRun = null;
    }
  }
  function pause() {
    if (!playing && !currentRun) {
      adapter.token.stop?.();
      return;
    }
    playing = false;
    store.set({ playing: false });
    adapter.token.stop?.();
    if (clockTimer != null) {
      clearInterval(clockTimer);
      clockTimer = null;
    }
  }
  async function checkEncounter() {
    try {
      const mapFile = getMapFile();
      if (!mapFile) return;
      const s = store.get();
      const cur = s.currentTile || s.tokenRC;
      if (!cur) return;
      const { loadTile: loadTile2 } = await Promise.resolve().then(() => (init_hex_notes(), hex_notes_exports));
      const tile = await loadTile2(app, mapFile, cur).catch(() => null);
      const regionName = tile?.region;
      if (!regionName) return;
      const { loadRegions: loadRegions2 } = await Promise.resolve().then(() => (init_regions_store(), regions_store_exports));
      const regions = await loadRegions2(app);
      const region = regions.find((r) => (r.name || "").toLowerCase() === regionName.toLowerCase());
      const odds = region?.encounterOdds;
      const n = Number.isFinite(odds) && odds > 0 ? odds : void 0;
      if (!n) return;
      const roll = Math.floor(Math.random() * n) + 1;
      if (roll === 1) {
        onEncounter && await onEncounter();
      }
    } catch (err) {
      console.error("[travel] encounter check failed", err);
    }
  }
  return { play, pause };
}
var init_playback = __esm({
  "src/apps/cartographer/travel/domain/playback.ts"() {
    "use strict";
    init_terrain_service();
    init_persistence();
  }
});

// src/apps/cartographer/travel/domain/actions.ts
function createTravelLogic(cfg) {
  const store = createStore();
  let adapter = cfg.adapter;
  const unsub = store.subscribe((s) => {
    cfg.onChange?.(s);
    adapter.draw(s.route, s.tokenRC);
  });
  const playback = createPlayback({
    app: cfg.app,
    getMapFile: cfg.getMapFile,
    store,
    adapter,
    minSecondsPerTile: cfg.minSecondsPerTile,
    onEncounter: cfg.onEncounter
  });
  const getState = () => store.get();
  const bindAdapter = (a) => {
    adapter = a;
  };
  const selectDot = (idx) => {
    const len = store.get().route.length;
    const safe = idx == null ? null : Math.max(0, Math.min(idx, len - 1));
    store.set({ editIdx: safe });
  };
  const lastUserAnchor = () => {
    const r = store.get().route;
    for (let i = r.length - 1; i >= 0; i--) {
      if (r[i].kind === "user") return r[i];
    }
    return null;
  };
  const userIndices = () => {
    const out = [];
    store.get().route.forEach((n, i) => {
      if (n.kind === "user") out.push(i);
    });
    return out;
  };
  const ensurePolys = (coords) => adapter.ensurePolys(coords);
  const handleHexClick = (rc) => {
    const s = store.get();
    const source = lastUserAnchor() ?? s.tokenRC;
    if (source.r === rc.r && source.c === rc.c) return;
    const seg = expandCoords(source, rc);
    ensurePolys(seg);
    const autos = seg.slice(0, Math.max(0, seg.length - 1)).map(asAutoNode);
    const user = asUserNode(rc);
    const route = [...s.route, ...autos, user];
    store.set({ route });
  };
  const moveSelectedTo = (rc) => {
    const s = store.get();
    const i = s.editIdx;
    if (i == null || i < 0 || i >= s.route.length) return;
    const users = userIndices();
    const prevUserIdx = [...users].reverse().find((u) => u < i) ?? -1;
    const nextUserIdx = users.find((u) => u > i) ?? -1;
    const prevAnchor = prevUserIdx >= 0 ? s.route[prevUserIdx] : s.tokenRC;
    const head = prevUserIdx >= 0 ? s.route.slice(0, prevUserIdx + 1) : [];
    const leftSeg = expandCoords(prevAnchor, rc);
    const leftAutos = leftSeg.slice(0, Math.max(0, leftSeg.length - 1)).map(asAutoNode);
    const moved = asUserNode(rc);
    let rightAutos = [];
    let tail = [];
    if (nextUserIdx >= 0) {
      const nextAnchor = s.route[nextUserIdx];
      const rightSeg = expandCoords(rc, nextAnchor);
      rightAutos = rightSeg.slice(0, Math.max(0, rightSeg.length - 1)).map(asAutoNode);
      tail = s.route.slice(nextUserIdx);
    }
    const newRoute = [...head, ...leftAutos, moved, ...rightAutos, ...tail];
    ensurePolys([rc, ...leftSeg, ...rightAutos.map(({ r, c }) => ({ r, c }))]);
    const newIdx = newRoute.findIndex((n) => n.kind === "user" && n.r === rc.r && n.c === rc.c);
    store.set({ route: newRoute, editIdx: newIdx >= 0 ? newIdx : null });
  };
  async function moveTokenTo(rc) {
    if (!adapter) return;
    const prev = store.get();
    const anchors = prev.route.filter((n) => n.kind === "user").map(({ r, c }) => ({ r, c }));
    const route = rebuildFromAnchors(rc, anchors);
    const routeCoords = route.map(({ r, c }) => ({ r, c }));
    adapter.ensurePolys([rc, ...routeCoords]);
    const ctr = adapter.centerOf(rc);
    if (ctr) {
      adapter.token.setPos(ctr.x, ctr.y);
      adapter.token.show();
    }
    let editIdx = prev.editIdx;
    if (editIdx != null) {
      const prevNode = prev.route[editIdx];
      if (!prevNode) {
        editIdx = null;
      } else {
        const matchIdx = route.findIndex(
          (n) => n.kind === prevNode.kind && n.r === prevNode.r && n.c === prevNode.c
        );
        editIdx = matchIdx >= 0 ? matchIdx : null;
      }
    }
    store.set({ tokenRC: rc, route, editIdx });
    const mapFile = cfg.getMapFile();
    if (mapFile) await writeTokenToTiles(cfg.app, mapFile, rc);
  }
  const deleteUserAt = (idx) => {
    const s = store.get();
    if (idx < 0 || idx >= s.route.length) return;
    if (s.route[idx].kind !== "user") return;
    const users = userIndices();
    const myUserPos = users.indexOf(idx);
    const prevUserIdx = myUserPos > 0 ? users[myUserPos - 1] : -1;
    const nextUserIdx = myUserPos < users.length - 1 ? users[myUserPos + 1] : -1;
    const prevAnchor = prevUserIdx >= 0 ? s.route[prevUserIdx] : s.tokenRC;
    const nextAnchor = nextUserIdx >= 0 ? s.route[nextUserIdx] : null;
    const head = prevUserIdx >= 0 ? s.route.slice(0, prevUserIdx + 1) : [];
    const tail = nextUserIdx >= 0 ? s.route.slice(nextUserIdx) : [];
    let bridge = [];
    if (nextAnchor) {
      const seg = expandCoords(prevAnchor, nextAnchor);
      const autos = seg.slice(0, Math.max(0, seg.length - 1)).map(asAutoNode);
      bridge = [...autos];
      ensurePolys(seg);
    }
    const newRoute = [...head, ...bridge, ...tail];
    const newEdit = null;
    store.set({ route: newRoute, editIdx: newEdit });
  };
  const setTokenSpeed = (v) => {
    const val = Number.isFinite(v) && v > 0 ? v : 1;
    store.set({ tokenSpeed: val });
  };
  const setTempo = (v) => {
    const val = Number.isFinite(v) ? Math.max(0.1, Math.min(10, v)) : 1;
    store.set({ tempo: val });
  };
  const play = async () => playback.play();
  const pause = () => playback.pause();
  const reset = async () => {
    playback.pause();
    store.set({
      route: [],
      editIdx: null,
      currentTile: null,
      playing: false
    });
    await initTokenFromTiles();
  };
  async function initTokenFromTiles() {
    const mapFile = cfg.getMapFile();
    if (!mapFile || !adapter) return;
    const prev = store.get();
    const found = await loadTokenCoordFromMap(cfg.app, mapFile);
    const tokenRC = found ?? prev.tokenRC ?? { r: 0, c: 0 };
    const anchors = prev.route.filter((n) => n.kind === "user").map(({ r, c }) => ({ r, c }));
    const route = rebuildFromAnchors(tokenRC, anchors);
    const routeCoords = route.map(({ r, c }) => ({ r, c }));
    adapter.ensurePolys([tokenRC, ...routeCoords]);
    const ctr = adapter.centerOf(tokenRC);
    if (ctr) {
      adapter.token.setPos(ctr.x, ctr.y);
      adapter.token.show();
    }
    let editIdx = prev.editIdx;
    if (editIdx != null) {
      const prevNode = prev.route[editIdx];
      if (!prevNode) {
        editIdx = null;
      } else {
        const matchIdx = route.findIndex(
          (n) => n.kind === prevNode.kind && n.r === prevNode.r && n.c === prevNode.c
        );
        editIdx = matchIdx >= 0 ? matchIdx : null;
      }
    }
    store.set({ tokenRC, route, editIdx });
    if (!found) await writeTokenToTiles(cfg.app, mapFile, tokenRC);
  }
  const persistTokenToTiles = async () => {
    const mf = cfg.getMapFile();
    if (!mf) return;
    await writeTokenToTiles(cfg.app, mf, store.get().tokenRC);
  };
  return {
    getState: () => store.get(),
    selectDot,
    handleHexClick,
    moveSelectedTo,
    moveTokenTo,
    deleteUserAt,
    play,
    pause,
    reset,
    setTokenSpeed,
    setTempo,
    bindAdapter,
    initTokenFromTiles,
    persistTokenToTiles
  };
}
var init_actions = __esm({
  "src/apps/cartographer/travel/domain/actions.ts"() {
    "use strict";
    init_state_store();
    init_expansion();
    init_playback();
    init_persistence();
  }
});

// src/apps/almanac/domain/calendar-math.ts
function getMonthLength(schema, monthId) {
  const month = getMonthById(schema, monthId);
  return month?.length ?? null;
}
function getDayOfYear(schema, timestamp) {
  const monthIndex = getMonthIndex(schema, timestamp.monthId);
  if (monthIndex === -1) {
    throw new Error(`Month with id ${timestamp.monthId} not found in schema ${schema.id}`);
  }
  let days = 0;
  for (let index = 0; index < monthIndex; index++) {
    days += schema.months[index].length;
  }
  return days + timestamp.day;
}
function resolveMonthAndDayByDayOfYear(schema, dayOfYear) {
  if (dayOfYear < 1 || dayOfYear > getTotalDaysInYear(schema)) {
    throw new RangeError(`Day-of-year ${dayOfYear} is out of range for schema ${schema.id}`);
  }
  let remaining = dayOfYear;
  for (const month of schema.months) {
    if (remaining <= month.length) {
      return { monthId: month.id, day: remaining };
    }
    remaining -= month.length;
  }
  throw new RangeError(`Unable to resolve day-of-year ${dayOfYear} for schema ${schema.id}`);
}
function createTimestampFromDayOfYear(schema, calendarId, year, dayOfYear) {
  const { monthId, day } = resolveMonthAndDayByDayOfYear(schema, dayOfYear);
  return createDayTimestamp(calendarId, year, monthId, day);
}
function timestampToAbsoluteDay(schema, timestamp) {
  const daysPerYear = getTotalDaysInYear(schema);
  const dayOfYearIndex = getDayOfYear(schema, timestamp) - 1;
  const yearOffset = timestamp.year - schema.epoch.year;
  return yearOffset * daysPerYear + dayOfYearIndex;
}
function absoluteDayToTimestamp(schema, calendarId, absoluteDay) {
  const daysPerYear = getTotalDaysInYear(schema);
  let yearOffset = Math.floor(absoluteDay / daysPerYear);
  let dayOfYearIndex = absoluteDay - yearOffset * daysPerYear;
  if (dayOfYearIndex < 0) {
    dayOfYearIndex += daysPerYear;
    yearOffset -= 1;
  }
  const targetYear = schema.epoch.year + yearOffset;
  return createTimestampFromDayOfYear(schema, calendarId, targetYear, dayOfYearIndex + 1);
}
function clampDayToMonth(schema, monthId, day) {
  const monthLength = getMonthLength(schema, monthId);
  if (monthLength === null) {
    throw new Error(`Month with id ${monthId} not found in schema ${schema.id}`);
  }
  if (day < 1) return 1;
  if (day > monthLength) return monthLength;
  return day;
}
function mod(value, divisor) {
  return (value % divisor + divisor) % divisor;
}
var init_calendar_math = __esm({
  "src/apps/almanac/domain/calendar-math.ts"() {
    "use strict";
    init_calendar_schema();
    init_calendar_timestamp();
  }
});

// src/apps/almanac/domain/repeat-rule.ts
function calculateNextOccurrence(schema, calendarId, rule, start, options = {}, services = {}) {
  const includeStart = options.includeStart ?? false;
  switch (rule.type) {
    case "annual_offset":
      return resolveNextAnnualOccurrence(schema, calendarId, rule, start, includeStart);
    case "monthly_position":
      return resolveNextMonthlyOccurrence(schema, calendarId, rule, start, includeStart);
    case "weekly_dayIndex":
      return resolveNextWeeklyOccurrence(schema, calendarId, rule, start, includeStart);
    case "astronomical":
      return resolveNextAstronomicalOccurrence(schema, calendarId, rule, start, options, services);
    case "custom":
      throw new UnsupportedRepeatRuleError(rule.type);
    default: {
      const _never = rule;
      return _never;
    }
  }
}
function calculateOccurrencesInRange(schema, calendarId, rule, rangeStart, rangeEnd, options = {}, services = {}) {
  const limit = options.limit ?? 12;
  if (limit <= 0) return [];
  const compare = compareTimestampsWithSchema(schema, rangeStart, rangeEnd);
  const [start, end] = compare <= 0 ? [rangeStart, rangeEnd] : [rangeEnd, rangeStart];
  if (rule.type === "astronomical") {
    return resolveAstronomicalRange(schema, calendarId, rule, start, end, options, services).slice(0, limit);
  }
  const occurrences = [];
  let cursor = calculateNextOccurrence(schema, calendarId, rule, start, options, services);
  while (cursor && occurrences.length < limit && compareTimestampsWithSchema(schema, cursor, end) <= 0) {
    occurrences.push(cursor);
    cursor = calculateNextOccurrence(schema, calendarId, rule, cursor, { includeStart: false }, services);
    if (cursor && occurrences.length > 0) {
      const prev = occurrences[occurrences.length - 1];
      if (compareTimestampsWithSchema(schema, cursor, prev) === 0) {
        break;
      }
    }
  }
  return occurrences;
}
function resolveNextAnnualOccurrence(schema, calendarId, rule, start, includeStart) {
  const totalDays = getAnnualRange(schema);
  if (totalDays <= 0) {
    throw new InvalidRepeatRuleError(`Calendar schema ${schema.id} has no days configured.`);
  }
  const zeroBased = ((rule.offsetDayOfYear - 1) % totalDays + totalDays) % totalDays;
  const normalisedOffset = zeroBased + 1;
  const candidateCurrentYear = createTimestampFromDayOfYear(schema, calendarId, start.year, normalisedOffset);
  const comparison = compareTimestampsWithSchema(schema, candidateCurrentYear, start);
  if (comparison > 0 || comparison === 0 && includeStart) {
    return candidateCurrentYear;
  }
  return createTimestampFromDayOfYear(schema, calendarId, start.year + 1, normalisedOffset);
}
function resolveNextMonthlyOccurrence(schema, calendarId, rule, start, includeStart) {
  const monthLength = clampDayToMonth(schema, rule.monthId, rule.day);
  const initialCandidate = createDayTimestamp(calendarId, start.year, rule.monthId, monthLength);
  const comparison = compareTimestampsWithSchema(schema, initialCandidate, start);
  if (comparison > 0 || comparison === 0 && includeStart) {
    return initialCandidate;
  }
  return createDayTimestamp(calendarId, start.year + 1, rule.monthId, monthLength);
}
function resolveNextWeeklyOccurrence(schema, calendarId, rule, start, includeStart) {
  const daysPerWeek = schema.daysPerWeek;
  if (rule.dayIndex < 0 || rule.dayIndex >= daysPerWeek) {
    throw new InvalidRepeatRuleError(`dayIndex ${rule.dayIndex} is out of range for schema ${schema.id}`);
  }
  const interval = Math.max(1, rule.interval ?? 1);
  const absoluteStart = timestampToAbsoluteDay(schema, start);
  const currentDayIndex = mod(absoluteStart, daysPerWeek);
  let delta = mod(rule.dayIndex - currentDayIndex, daysPerWeek);
  if (delta === 0 && !includeStart) {
    delta = daysPerWeek * interval;
  }
  const intervalDays = daysPerWeek * interval;
  if (delta % daysPerWeek !== 0 && interval > 1) {
    delta += mod(intervalDays - delta % intervalDays, intervalDays);
  }
  const candidateAbsolute = absoluteStart + delta;
  return absoluteDayToTimestamp(schema, calendarId, candidateAbsolute);
}
function resolveNextAstronomicalOccurrence(schema, calendarId, rule, start, options, services) {
  const calculator = services.astronomicalCalculator;
  if (!calculator) {
    throw new UnsupportedRepeatRuleError(rule.type);
  }
  return calculator.resolveNextOccurrence(schema, calendarId, rule, start, options);
}
function resolveAstronomicalRange(schema, calendarId, rule, rangeStart, rangeEnd, options, services) {
  const calculator = services.astronomicalCalculator;
  if (!calculator) {
    throw new UnsupportedRepeatRuleError(rule.type);
  }
  return calculator.resolveOccurrencesInRange(schema, calendarId, rule, rangeStart, rangeEnd, options);
}
function getAnnualRange(schema) {
  return schema.months.reduce((sum, month) => sum + month.length, 0);
}
var UnsupportedRepeatRuleError, InvalidRepeatRuleError;
var init_repeat_rule = __esm({
  "src/apps/almanac/domain/repeat-rule.ts"() {
    "use strict";
    init_calendar_timestamp();
    init_calendar_math();
    UnsupportedRepeatRuleError = class extends Error {
      constructor(ruleType) {
        super(`Repeat rule type "${ruleType}" is not supported yet.`);
        this.name = "UnsupportedRepeatRuleError";
      }
    };
    InvalidRepeatRuleError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "InvalidRepeatRuleError";
      }
    };
  }
});

// src/apps/almanac/domain/time-arithmetic.ts
function advanceTime(schema, current, amount, unit) {
  if (unit === "day") {
    return advanceByDays(schema, current, amount);
  }
  if (unit === "hour") {
    return advanceByHours(schema, current, amount);
  }
  return advanceByMinutes(schema, current, amount);
}
function advanceByDays(schema, current, days) {
  let year = current.year;
  let monthId = current.monthId;
  let day = current.day;
  const hour = current.hour;
  let remainingDays = days;
  let normalized = false;
  while (remainingDays !== 0) {
    const month = getMonthById(schema, monthId);
    if (!month) {
      throw new Error(`Invalid month ID: ${monthId}`);
    }
    if (remainingDays > 0) {
      const daysLeftInMonth = month.length - day + 1;
      if (remainingDays < daysLeftInMonth) {
        day += remainingDays;
        remainingDays = 0;
      } else {
        remainingDays -= daysLeftInMonth;
        day = 1;
        const nextMonth = getNextMonth(schema, monthId);
        if (!nextMonth) {
          year += 1;
          monthId = schema.months[0].id;
          normalized = true;
        } else {
          monthId = nextMonth.id;
        }
      }
    } else {
      const daysToBoundary = day - 1;
      if (Math.abs(remainingDays) <= daysToBoundary) {
        day += remainingDays;
        remainingDays = 0;
      } else {
        remainingDays += daysToBoundary + 1;
        const prevMonth = getPreviousMonth(schema, monthId);
        if (!prevMonth) {
          year -= 1;
          const lastMonth = schema.months[schema.months.length - 1];
          monthId = lastMonth.id;
          day = lastMonth.length;
          normalized = true;
        } else {
          monthId = prevMonth.id;
          day = prevMonth.length;
        }
      }
    }
  }
  const result = hour !== void 0 ? createHourTimestamp(current.calendarId, year, monthId, day, hour) : createDayTimestamp(current.calendarId, year, monthId, day);
  return { timestamp: result, normalized };
}
function advanceByHours(schema, current, hours) {
  const hoursPerDay = getHoursPerDay(schema);
  const currentHour = current.hour ?? 0;
  let totalHours = currentHour + hours;
  let carriedDays = 0;
  let normalized = false;
  if (totalHours >= hoursPerDay) {
    carriedDays = Math.floor(totalHours / hoursPerDay);
    totalHours = totalHours % hoursPerDay;
    normalized = true;
  } else if (totalHours < 0) {
    const daysNeeded = Math.ceil(Math.abs(totalHours) / hoursPerDay);
    carriedDays = -daysNeeded;
    totalHours = totalHours + daysNeeded * hoursPerDay;
    normalized = true;
  }
  let baseTimestamp = current;
  if (carriedDays !== 0) {
    const dayResult = advanceByDays(schema, current, carriedDays);
    baseTimestamp = dayResult.timestamp;
    normalized = normalized || dayResult.normalized;
  }
  const result = createHourTimestamp(
    baseTimestamp.calendarId,
    baseTimestamp.year,
    baseTimestamp.monthId,
    baseTimestamp.day,
    totalHours
  );
  return { timestamp: result, normalized, carriedDays: carriedDays !== 0 ? carriedDays : void 0, carriedHours: hours };
}
function getNextMonth(schema, currentMonthId) {
  const index = getMonthIndex(schema, currentMonthId);
  if (index === -1) {
    throw new Error(`Month not found: ${currentMonthId}`);
  }
  if (index === schema.months.length - 1) {
    return null;
  }
  return getMonthByIndex(schema, index + 1);
}
function getPreviousMonth(schema, currentMonthId) {
  const index = getMonthIndex(schema, currentMonthId);
  if (index === -1) {
    throw new Error(`Month not found: ${currentMonthId}`);
  }
  if (index === 0) {
    return null;
  }
  return getMonthByIndex(schema, index - 1);
}
function advanceByMinutes(schema, current, minutes) {
  const minutesPerHour = getMinutesPerHour(schema);
  const currentMinute = current.minute ?? 0;
  const currentHour = current.hour ?? 0;
  let totalMinutes = currentMinute + minutes;
  let carriedHours = 0;
  let normalized = false;
  if (totalMinutes >= minutesPerHour) {
    carriedHours = Math.floor(totalMinutes / minutesPerHour);
    totalMinutes = totalMinutes % minutesPerHour;
    normalized = true;
  } else if (totalMinutes < 0) {
    const hoursNeeded = Math.ceil(Math.abs(totalMinutes) / minutesPerHour);
    carriedHours = -hoursNeeded;
    totalMinutes = totalMinutes + hoursNeeded * minutesPerHour;
    normalized = true;
  }
  let baseTimestamp = current;
  if (carriedHours !== 0) {
    const hourResult = advanceByHours(schema, current, carriedHours);
    baseTimestamp = hourResult.timestamp;
    normalized = normalized || hourResult.normalized;
  }
  const result = createMinuteTimestamp(
    baseTimestamp.calendarId,
    baseTimestamp.year,
    baseTimestamp.monthId,
    baseTimestamp.day,
    // The hour component might become undefined if the schema uses day precision only.
    // Fallback to zero in that case.
    baseTimestamp.hour ?? 0,
    totalMinutes
  );
  return { timestamp: result, normalized };
}
var init_time_arithmetic = __esm({
  "src/apps/almanac/domain/time-arithmetic.ts"() {
    "use strict";
    init_calendar_schema();
    init_calendar_schema();
    init_calendar_timestamp();
  }
});

// src/apps/almanac/domain/hook-descriptor.ts
function sortHooksByPriority(hooks) {
  return [...hooks].sort((a, b) => {
    const priorityA = a.priority ?? 0;
    const priorityB = b.priority ?? 0;
    if (priorityA !== priorityB) {
      return priorityB - priorityA;
    }
    return a.id.localeCompare(b.id);
  });
}
var init_hook_descriptor = __esm({
  "src/apps/almanac/domain/hook-descriptor.ts"() {
    "use strict";
  }
});

// src/apps/almanac/domain/calendar-event.ts
function isSingleEvent(event) {
  return event.kind === "single";
}
function isRecurringEvent(event) {
  return event.kind === "recurring";
}
function createSingleEvent(id, calendarId, title, date, options = {}) {
  return {
    kind: "single",
    id,
    calendarId,
    title,
    description: options.description,
    note: options.note,
    category: options.category,
    tags: options.tags,
    priority: options.priority,
    followUpPolicy: options.followUpPolicy,
    hooks: options.hooks,
    date,
    allDay: options.allDay ?? date.precision === "day",
    startTime: options.startTime,
    endTime: options.endTime,
    durationMinutes: options.durationMinutes,
    timePrecision: options.timePrecision ?? normalisePrecision(date.precision)
  };
}
function getEventAnchorTimestamp(event) {
  if (isSingleEvent(event)) {
    return event.date;
  }
  return event.bounds?.start ?? event.date ?? null;
}
function getEventPriority(event) {
  return event.priority ?? 0;
}
function getEventHooks(event) {
  return event.hooks ? sortHooksByPriority(event.hooks) : [];
}
function computeNextEventOccurrence(event, schema, calendarId, start, options = {}) {
  if (isSingleEvent(event)) {
    const includeStart2 = options.includeStart ?? false;
    const comparison = compareTimestampsWithSchema(schema, event.date, start);
    if (comparison > 0 || comparison === 0 && includeStart2) {
      return buildSingleEventOccurrence(event, schema);
    }
    return null;
  }
  const effectiveStart = resolveRecurringSearchStart(event, schema, start);
  if (!effectiveStart) {
    return null;
  }
  const { services, ...ruleOptions } = options;
  const includeStart = ruleOptions.includeStart ?? false;
  const next = calculateNextOccurrence(
    schema,
    calendarId,
    event.rule,
    effectiveStart,
    { ...ruleOptions, includeStart },
    services
  );
  if (!next) {
    return null;
  }
  if (!isWithinBounds(event.bounds, schema, next)) {
    const nextCursor = advanceCursorBeyondBounds(event, schema, next, ruleOptions, services, calendarId);
    return nextCursor ? buildRecurringEventOccurrence(event, schema, calendarId, nextCursor) : null;
  }
  return buildRecurringEventOccurrence(event, schema, calendarId, next);
}
function normalisePrecision(precision) {
  if (precision === "hour" || precision === "minute") {
    return precision;
  }
  return "day";
}
function buildSingleEventOccurrence(event, schema) {
  const { start, end, durationMinutes } = resolveSingleEventWindow(event, schema);
  return {
    eventId: event.id,
    calendarId: event.calendarId,
    eventType: "single",
    title: event.title,
    category: event.category,
    start,
    end,
    durationMinutes,
    allDay: event.allDay,
    priority: getEventPriority(event),
    hooks: getEventHooks(event),
    source: event
  };
}
function buildRecurringEventOccurrence(event, schema, calendarId, baseTimestamp) {
  const { start, end, durationMinutes } = applyRecurringTimePolicy(event, schema, calendarId, baseTimestamp);
  return {
    eventId: event.id,
    calendarId,
    eventType: "recurring",
    title: event.title,
    category: event.category,
    start,
    end,
    durationMinutes,
    allDay: event.timePolicy === "all_day",
    priority: getEventPriority(event),
    hooks: getEventHooks(event),
    source: event
  };
}
function resolveSingleEventWindow(event, schema) {
  const { minutesPerHour, hoursPerDay } = getTimeDefinition(schema);
  const minutesPerDay = hoursPerDay * minutesPerHour;
  const base = event.date;
  let start = base;
  if (!event.allDay) {
    const hour = event.startTime?.hour ?? base.hour ?? 0;
    const minute = event.startTime?.minute ?? base.minute ?? 0;
    start = createMinuteTimestamp(base.calendarId, base.year, base.monthId, base.day, hour, minute);
  }
  let duration = event.durationMinutes ?? 0;
  if (event.endTime) {
    duration = Math.max(duration, calculateDurationFromTimes(event.startTime, event.endTime, minutesPerHour, hoursPerDay));
  }
  if (duration <= 0) {
    duration = event.allDay ? minutesPerDay : 0;
  }
  const end = duration > 0 ? advanceTime(schema, start, duration, "minute").timestamp : start;
  return { start, end, durationMinutes: duration };
}
function applyRecurringTimePolicy(event, schema, calendarId, baseTimestamp) {
  const { minutesPerHour, hoursPerDay } = getTimeDefinition(schema);
  const minutesPerDay = hoursPerDay * minutesPerHour;
  if (event.timePolicy === "all_day") {
    const start2 = baseTimestamp;
    const duration2 = event.durationMinutes ?? minutesPerDay;
    const end2 = duration2 > 0 ? advanceTime(schema, start2, duration2, "minute").timestamp : start2;
    return { start: start2, end: end2, durationMinutes: duration2 };
  }
  if (event.timePolicy === "fixed") {
    const hour = event.startTime?.hour ?? 0;
    const minute = event.startTime?.minute ?? 0;
    const start2 = createMinuteTimestamp(calendarId, baseTimestamp.year, baseTimestamp.monthId, baseTimestamp.day, hour, minute);
    const duration2 = event.durationMinutes ?? 0;
    const end2 = duration2 > 0 ? advanceTime(schema, start2, duration2, "minute").timestamp : start2;
    return { start: start2, end: end2, durationMinutes: duration2 };
  }
  const offsetMinutes = event.offsetMinutes ?? 0;
  const start = advanceTime(schema, baseTimestamp, offsetMinutes, "minute").timestamp;
  const duration = event.durationMinutes ?? 0;
  const end = duration > 0 ? advanceTime(schema, start, duration, "minute").timestamp : start;
  return { start, end, durationMinutes: duration };
}
function calculateDurationFromTimes(startTime, endTime, minutesPerHour, hoursPerDay) {
  const startMinutes = timeOfDayToMinutes(startTime ?? { hour: 0, minute: 0 }, minutesPerHour);
  const endMinutes = timeOfDayToMinutes(endTime, minutesPerHour);
  const dailyMinutes = hoursPerDay * minutesPerHour;
  const raw = endMinutes - startMinutes;
  if (raw <= 0) {
    return dailyMinutes + raw;
  }
  return raw;
}
function timeOfDayToMinutes(time, minutesPerHour) {
  return time.hour * minutesPerHour + (time.minute ?? 0);
}
function resolveRecurringSearchStart(event, schema, start) {
  const boundsStart = event.bounds?.start;
  if (!boundsStart) {
    return start;
  }
  const comparison = compareTimestampsWithSchema(schema, start, boundsStart);
  if (comparison >= 0) {
    return start;
  }
  return boundsStart;
}
function isWithinBounds(bounds, schema, timestamp) {
  if (!bounds) {
    return true;
  }
  if (bounds.start && compareTimestampsWithSchema(schema, timestamp, bounds.start) < 0) {
    return false;
  }
  if (bounds.end && compareTimestampsWithSchema(schema, timestamp, bounds.end) > 0) {
    return false;
  }
  return true;
}
function advanceCursorBeyondBounds(event, schema, current, options, services, calendarId) {
  if (!event.bounds?.end) {
    return null;
  }
  if (compareTimestampsWithSchema(schema, current, event.bounds.end) >= 0) {
    return null;
  }
  return calculateNextOccurrence(
    schema,
    calendarId,
    event.rule,
    current,
    { ...options, includeStart: false },
    services
  );
}
var init_calendar_event = __esm({
  "src/apps/almanac/domain/calendar-event.ts"() {
    "use strict";
    init_calendar_schema();
    init_calendar_timestamp();
    init_repeat_rule();
    init_time_arithmetic();
    init_hook_descriptor();
  }
});

// src/apps/almanac/mode/cartographer-gateway.ts
function normaliseTravelKey(travelId) {
  return travelId ?? GLOBAL_TRAVEL_KEY;
}
function formatTimestampLabel(ts) {
  if (!ts) return void 0;
  const base = `${ts.year}-${ts.monthId}-${String(ts.day).padStart(2, "0")}`;
  if (typeof ts.hour === "number" && typeof ts.minute === "number") {
    const hh = String(ts.hour).padStart(2, "0");
    const mm = String(ts.minute).padStart(2, "0");
    return `${base} ${hh}:${mm}`;
  }
  return base;
}
function mapEvents(events, skipped = false) {
  if (!events || events.length === 0) {
    return [];
  }
  return events.map((event) => {
    const occurrence = getEventAnchorTimestamp(event) ?? event.date;
    return {
      kind: "event",
      id: event.id,
      title: event.title,
      occurrenceLabel: formatTimestampLabel(occurrence) ?? "\u2014",
      skipped
    };
  });
}
function mapPhenomena(phenomena, skipped = false) {
  if (!phenomena || phenomena.length === 0) {
    return [];
  }
  return phenomena.map((occurrence) => ({
    kind: "phenomenon",
    id: occurrence.phenomenonId,
    title: occurrence.title ?? occurrence.phenomenonId,
    occurrenceLabel: formatTimestampLabel(occurrence.timestamp) ?? "\u2014",
    skipped
  }));
}
var GLOBAL_TRAVEL_KEY, CartographerHookGateway, cartographerHookGateway;
var init_cartographer_gateway = __esm({
  "src/apps/almanac/mode/cartographer-gateway.ts"() {
    "use strict";
    init_calendar_event();
    GLOBAL_TRAVEL_KEY = "__global__";
    CartographerHookGateway = class {
      constructor() {
        this.hookListeners = /* @__PURE__ */ new Set();
        this.panelListeners = /* @__PURE__ */ new Map();
        this.lifecycleStart = /* @__PURE__ */ new Set();
        this.lifecycleEnd = /* @__PURE__ */ new Set();
        this.latestSnapshots = /* @__PURE__ */ new Map();
      }
      onHookDispatched(listener) {
        this.hookListeners.add(listener);
        return () => this.hookListeners.delete(listener);
      }
      onTravelStart(listener) {
        this.lifecycleStart.add(listener);
        return () => this.lifecycleStart.delete(listener);
      }
      onTravelEnd(listener) {
        this.lifecycleEnd.add(listener);
        return () => this.lifecycleEnd.delete(listener);
      }
      onPanelUpdate(travelId, listener) {
        const key = normaliseTravelKey(travelId);
        if (!this.panelListeners.has(key)) {
          this.panelListeners.set(key, /* @__PURE__ */ new Set());
        }
        const listeners2 = this.panelListeners.get(key);
        listeners2.add(listener);
        const snapshot = this.latestSnapshots.get(key);
        if (snapshot) {
          void listener(snapshot);
        }
        return () => {
          const set = this.panelListeners.get(key);
          set?.delete(listener);
          if (set && set.size === 0) {
            this.panelListeners.delete(key);
          }
        };
      }
      emitTravelStart(travelId) {
        const key = normaliseTravelKey(travelId);
        for (const listener of this.lifecycleStart) {
          void listener(key === GLOBAL_TRAVEL_KEY ? null : travelId);
        }
      }
      emitTravelEnd(travelId) {
        const key = normaliseTravelKey(travelId);
        for (const listener of this.lifecycleEnd) {
          void listener(key === GLOBAL_TRAVEL_KEY ? null : travelId);
        }
      }
      getPanelSnapshot(travelId) {
        const key = normaliseTravelKey(travelId);
        return this.latestSnapshots.get(key) ?? null;
      }
      reset() {
        this.latestSnapshots.clear();
        this.panelListeners.clear();
        this.hookListeners.clear();
        this.lifecycleStart.clear();
        this.lifecycleEnd.clear();
      }
      async dispatchHooks(events, phenomena, context) {
        if (this.hookListeners.size === 0) {
          return;
        }
        const payload = {
          scope: context.scope,
          travelId: context.travelId ?? null,
          reason: context.reason ?? "advance",
          events: events.map((event) => ({
            eventId: event.id,
            calendarId: event.calendarId,
            occurrence: getEventAnchorTimestamp(event) ?? event.date,
            title: event.title
          })),
          phenomena: phenomena.map((occurrence) => ({
            phenomenonId: occurrence.phenomenonId,
            occurrence: occurrence.timestamp,
            effects: occurrence.effects
          }))
        };
        for (const listener of this.hookListeners) {
          await listener(payload);
        }
      }
      async notifyTravelPanel(update) {
        const key = normaliseTravelKey(update.travelId);
        const snapshot = {
          travelId: key === GLOBAL_TRAVEL_KEY ? null : update.travelId ?? null,
          timestampLabel: formatTimestampLabel(update.currentTimestamp),
          message: update.message,
          reason: update.reason ?? "advance",
          lastAdvanceStep: update.lastAdvanceStep,
          logEntries: [
            ...mapEvents(update.triggeredEvents, false),
            ...mapPhenomena(update.triggeredPhenomena, false),
            ...mapEvents(update.skippedEvents, true),
            ...mapPhenomena(update.skippedPhenomena, true)
          ]
        };
        this.latestSnapshots.set(key, snapshot);
        const listeners2 = this.panelListeners.get(key);
        if (!listeners2 || listeners2.size === 0) {
          return;
        }
        for (const listener of listeners2) {
          await listener(snapshot);
        }
      }
    };
    cartographerHookGateway = new CartographerHookGateway();
  }
});

// src/apps/almanac/mode/cartographer-bridge.ts
function warnInactive(action) {
  console.warn(`[almanac] cartographer bridge ignored ${action} \u2013 no active dispatcher registered.`);
}
function logDispatchError(event, error) {
  console.error(`[almanac] cartographer bridge dispatch for ${event} failed`, error);
}
function registerCartographerBridge(machine, options = {}) {
  const dispatch = machine.dispatch.bind(machine);
  const getState = machine.getState.bind(machine);
  let released = false;
  let currentTravelId = null;
  const safeDispatch = async (event, label) => {
    if (released) {
      warnInactive(label);
      return;
    }
    try {
      await dispatch(event);
    } catch (error) {
      logDispatchError(label, error);
    }
  };
  let handle;
  const handlers = {
    async onAdvance(payload) {
      if (!currentTravelId) {
        warnInactive("travel advance");
        return;
      }
      await safeDispatch(
        { type: "TRAVEL_TIME_ADVANCE_REQUESTED", amount: payload.amount, unit: payload.unit },
        "travel advance"
      );
    },
    async onModeChange(mode) {
      if (!currentTravelId) {
        warnInactive("travel mode change");
        return;
      }
      await safeDispatch({ type: "TRAVEL_MODE_CHANGED", mode }, "travel mode change");
    },
    async onJump() {
      if (released) {
        warnInactive("time jump");
        return;
      }
      if (options.onRequestJump) {
        await options.onRequestJump();
        return;
      }
      const state = getState();
      const timestamp = state.travelLeafState.currentTimestamp ?? state.calendarState.currentTimestamp;
      if (!timestamp) {
        warnInactive("time jump");
        return;
      }
      await safeDispatch({ type: "TIME_JUMP_REQUESTED", timestamp }, "time jump");
    },
    async onClose() {
      if (released) {
        return;
      }
      if (options.onClose) {
        await options.onClose();
        return;
      }
      await handle.unmount();
    },
    async onFollowUp(eventId) {
      if (released) {
        warnInactive("event follow-up");
        return;
      }
      if (options.onFollowUp) {
        await options.onFollowUp(eventId);
        return;
      }
      await safeDispatch({ type: "ALMANAC_MODE_SELECTED", mode: "events" }, "event follow-up");
    }
  };
  handle = {
    handlers,
    async mount(travelId) {
      if (released) {
        warnInactive("travel mount");
        return;
      }
      if (!travelId) {
        currentTravelId = null;
        return;
      }
      if (currentTravelId === travelId) {
        return;
      }
      currentTravelId = travelId;
      await safeDispatch({ type: "TRAVEL_LEAF_MOUNTED", travelId }, "travel leaf mount");
    },
    async unmount() {
      currentTravelId = null;
    },
    async requestTimeJump(timestamp) {
      await safeDispatch({ type: "TIME_JUMP_REQUESTED", timestamp }, "time jump");
    },
    release() {
      if (released) {
        return;
      }
      released = true;
      currentTravelId = null;
      if (activeBridge === handle) {
        activeBridge = null;
      }
    }
  };
  activeBridge = handle;
  return handle;
}
function getCartographerBridge() {
  return activeBridge;
}
var activeBridge;
var init_cartographer_bridge = __esm({
  "src/apps/almanac/mode/cartographer-bridge.ts"() {
    "use strict";
    activeBridge = null;
  }
});

// src/apps/cartographer/travel/ui/controls.ts
function createPlaybackControls(host, callbacks) {
  const root = host.createDiv({ cls: "sm-cartographer__travel-buttons" });
  const clock = root.createEl("div", { cls: "sm-cartographer__travel-clock", text: "00h" });
  const playBtn = root.createEl("button", {
    cls: "sm-cartographer__travel-button sm-cartographer__travel-button--play",
    text: "Start"
  });
  (0, import_obsidian11.setIcon)(playBtn, "play");
  applyMapButtonStyle(playBtn);
  playBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    if (playBtn.disabled) return;
    void callbacks.onPlay?.();
  });
  const stopBtn = root.createEl("button", {
    cls: "sm-cartographer__travel-button sm-cartographer__travel-button--stop",
    text: "Stopp"
  });
  (0, import_obsidian11.setIcon)(stopBtn, "square");
  applyMapButtonStyle(stopBtn);
  stopBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    if (stopBtn.disabled) return;
    void callbacks.onStop?.();
  });
  const resetBtn = root.createEl("button", {
    cls: "sm-cartographer__travel-button sm-cartographer__travel-button--reset",
    text: "Reset"
  });
  (0, import_obsidian11.setIcon)(resetBtn, "rotate-ccw");
  applyMapButtonStyle(resetBtn);
  resetBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    if (resetBtn.disabled) return;
    void callbacks.onReset?.();
  });
  const tempoWrap = root.createDiv({ cls: "sm-cartographer__travel-tempo" });
  const tempoLabel = tempoWrap.createSpan({ text: "x1.0" });
  const tempoInput = tempoWrap.createEl("input", {
    type: "range",
    attr: { min: "0.1", max: "10", step: "0.1" }
  });
  tempoInput.value = "1";
  tempoInput.oninput = () => {
    const v = Math.max(0.1, Math.min(10, parseFloat(tempoInput.value) || 1));
    tempoLabel.setText(`x${v.toFixed(1)}`);
    callbacks.onTempoChange?.(v);
  };
  const setState = (state) => {
    const hasRoute = state.route.length > 0;
    playBtn.disabled = state.playing || !hasRoute;
    stopBtn.disabled = !state.playing;
    resetBtn.disabled = !hasRoute && !state.playing;
  };
  setState({ playing: false, route: [] });
  const setClock = (hours) => {
    const h = Math.floor(hours);
    clock.setText(`${h}h`);
  };
  const setTempo = (tempo) => {
    const v = Math.max(0.1, Math.min(10, tempo));
    tempoInput.value = String(v);
    tempoLabel.setText(`x${v.toFixed(1)}`);
  };
  const destroy = () => {
    playBtn.replaceWith();
    stopBtn.replaceWith();
    resetBtn.replaceWith();
    root.remove();
  };
  return {
    root,
    setState,
    destroy,
    setClock,
    setTempo
  };
}
var import_obsidian11;
var init_controls = __esm({
  "src/apps/cartographer/travel/ui/controls.ts"() {
    "use strict";
    import_obsidian11 = require("obsidian");
    init_map_workflows();
  }
});

// src/apps/cartographer/modes/travel-guide/playback-controller.ts
var TravelPlaybackController;
var init_playback_controller = __esm({
  "src/apps/cartographer/modes/travel-guide/playback-controller.ts"() {
    "use strict";
    init_controls();
    TravelPlaybackController = class {
      constructor() {
        this.handle = null;
      }
      mount(host, driver) {
        this.dispose();
        this.handle = createPlaybackControls(host.controlsHost, {
          onPlay: () => void driver.play(),
          onStop: () => void driver.pause(),
          onReset: () => void driver.reset(),
          onTempoChange: (value) => driver.setTempo?.(value)
        });
        this.reset();
      }
      sync(state) {
        if (!this.handle) return;
        this.handle.setState({ playing: state.playing, route: state.route });
        this.handle?.setClock?.(state.clockHours ?? 0);
        this.handle?.setTempo?.(state.tempo ?? 1);
      }
      reset() {
        this.handle?.setState({ playing: false, route: [] });
      }
      dispose() {
        this.handle?.destroy();
        this.handle = null;
      }
    };
  }
});

// src/apps/cartographer/travel/ui/drag.controller.ts
function createDragController(deps) {
  const { routeLayerEl, tokenEl, token, adapter, logic, polyToCoord } = deps;
  let isDragging = false;
  let dragKind = null;
  let lastDragRC = null;
  let suppressNextHexClick = false;
  let pointerCaptureOwner = null;
  let activePointerId = null;
  function disableLayerHit(on) {
    routeLayerEl.style.pointerEvents = on ? "none" : "";
  }
  function findPolygonAt(clientX, clientY) {
    const el = document.elementFromPoint(clientX, clientY);
    if (!el) return null;
    const poly1 = el.closest?.("polygon");
    if (poly1) return poly1;
    let cur = el;
    while (cur) {
      if (cur instanceof SVGPolygonElement) return cur;
      cur = cur.parentElement;
    }
    return null;
  }
  function getDotElements(idx) {
    const dot = routeLayerEl.querySelector(`.tg-route-dot[data-idx="${idx}"]`);
    const hit = routeLayerEl.querySelector(`.tg-route-dot-hitbox[data-idx="${idx}"]`);
    return { dot, hit };
  }
  function ghostMoveSelectedDot(rc) {
    const s = logic.getState();
    const idx = s.editIdx;
    if (idx == null) return;
    const { dot, hit } = getDotElements(idx);
    if (!dot) return;
    const ctr = adapter.centerOf(rc);
    if (!ctr) return;
    dot.setAttribute("cx", String(ctr.x));
    dot.setAttribute("cy", String(ctr.y));
    if (hit) {
      hit.setAttribute("cx", String(ctr.x));
      hit.setAttribute("cy", String(ctr.y));
    }
  }
  function ghostMoveToken(rc) {
    const ctr = adapter.centerOf(rc);
    if (!ctr) return;
    token.setPos(ctr.x, ctr.y);
    token.show();
  }
  function capturePointer(el, pointerId) {
    if (!el || typeof el.setPointerCapture !== "function") {
      pointerCaptureOwner = null;
      activePointerId = null;
      return;
    }
    try {
      el.setPointerCapture(pointerId);
      pointerCaptureOwner = el;
      activePointerId = pointerId;
    } catch {
      pointerCaptureOwner = null;
      activePointerId = null;
    }
  }
  function releasePointerCapture() {
    if (!pointerCaptureOwner || activePointerId == null) {
      pointerCaptureOwner = null;
      activePointerId = null;
      return;
    }
    const el = pointerCaptureOwner;
    try {
      el.releasePointerCapture?.(activePointerId);
    } catch {
    }
    pointerCaptureOwner = null;
    activePointerId = null;
  }
  const onGlobalPointerDownCapture = (ev) => {
    if (ev.button !== 0) return;
    const check = (el) => {
      if (!(el instanceof Element)) return false;
      if (el === tokenEl || tokenEl.contains(el)) return true;
      if (el instanceof SVGCircleElement && routeLayerEl.contains(el)) return true;
      return false;
    };
    const path = typeof ev.composedPath === "function" ? ev.composedPath() : [];
    if (Array.isArray(path) && path.length > 0) {
      for (const el of path) {
        if (check(el)) {
          suppressNextHexClick = true;
          return;
        }
      }
    } else if (check(ev.target)) {
      suppressNextHexClick = true;
    }
  };
  const onDotPointerDown = (ev) => {
    if (ev.button !== 0) return;
    const t = ev.target;
    if (!(t instanceof SVGCircleElement)) return;
    if (!t.classList.contains("tg-route-dot") && !t.classList.contains("tg-route-dot-hitbox")) return;
    const idxAttr = t.getAttribute("data-idx");
    const idx = idxAttr ? Number(idxAttr) : NaN;
    if (!Number.isFinite(idx) || idx < 0) return;
    logic.selectDot(idx);
    dragKind = "dot";
    isDragging = true;
    lastDragRC = null;
    suppressNextHexClick = true;
    disableLayerHit(true);
    const { dot } = getDotElements(idx);
    capturePointer(dot ?? t, ev.pointerId);
    ev.preventDefault();
    ev.stopImmediatePropagation?.();
    ev.stopPropagation();
  };
  const onTokenPointerDown = (ev) => {
    if (ev.button !== 0) return;
    dragKind = "token";
    isDragging = true;
    lastDragRC = null;
    suppressNextHexClick = true;
    disableLayerHit(true);
    capturePointer(tokenEl, ev.pointerId);
    ev.preventDefault();
    ev.stopImmediatePropagation?.();
    ev.stopPropagation();
  };
  const onPointerMove = (ev) => {
    if (!isDragging) return;
    if ((ev.buttons & 1) === 0) {
      endDrag();
      return;
    }
    const poly = findPolygonAt(ev.clientX, ev.clientY);
    if (!poly) return;
    const rc = polyToCoord.get(poly);
    if (!rc) return;
    if (lastDragRC && rc.r === lastDragRC.r && rc.c === lastDragRC.c) return;
    lastDragRC = rc;
    if (dragKind === "dot") ghostMoveSelectedDot(rc);
    else if (dragKind === "token") ghostMoveToken(rc);
  };
  function endDrag() {
    if (!isDragging) {
      releasePointerCapture();
      return;
    }
    isDragging = false;
    if (lastDragRC) {
      adapter.ensurePolys([lastDragRC]);
      if (dragKind === "dot") logic.moveSelectedTo(lastDragRC);
      else if (dragKind === "token") logic.moveTokenTo(lastDragRC);
      suppressNextHexClick = true;
    }
    lastDragRC = null;
    dragKind = null;
    disableLayerHit(false);
    releasePointerCapture();
  }
  const onPointerUp = () => endDrag();
  const onPointerCancel = () => endDrag();
  function bind() {
    window.addEventListener("pointerdown", onGlobalPointerDownCapture, { capture: true });
    routeLayerEl.addEventListener("pointerdown", onDotPointerDown, { capture: true });
    tokenEl.addEventListener("pointerdown", onTokenPointerDown, { capture: true });
    window.addEventListener("pointermove", onPointerMove, { passive: true });
    window.addEventListener("pointerup", onPointerUp, { passive: true });
    window.addEventListener("pointercancel", onPointerCancel, { passive: true });
  }
  function unbind() {
    window.removeEventListener("pointerdown", onGlobalPointerDownCapture, { capture: true });
    routeLayerEl.removeEventListener("pointerdown", onDotPointerDown, { capture: true });
    tokenEl.removeEventListener("pointerdown", onTokenPointerDown, { capture: true });
    window.removeEventListener("pointermove", onPointerMove);
    window.removeEventListener("pointerup", onPointerUp);
    window.removeEventListener("pointercancel", onPointerCancel);
    releasePointerCapture();
  }
  function consumeClickSuppression() {
    if (isDragging) return true;
    if (!suppressNextHexClick) return false;
    suppressNextHexClick = false;
    return true;
  }
  return { bind, unbind, consumeClickSuppression };
}
var init_drag_controller = __esm({
  "src/apps/cartographer/travel/ui/drag.controller.ts"() {
    "use strict";
  }
});

// src/apps/cartographer/travel/ui/context-menu.controller.ts
function bindContextMenu(routeLayerEl, logic) {
  const onContextMenu = (ev) => {
    const target = ev.target;
    if (!(target instanceof SVGElement)) return;
    const dot = target.closest(".tg-route-dot, .tg-route-dot-hitbox");
    if (!dot) return;
    const idxAttr = dot.getAttribute("data-idx");
    if (!idxAttr) return;
    const idx = Number(idxAttr);
    if (!Number.isFinite(idx) || idx < 0) return;
    const route = logic.getState().route;
    const node = route[idx];
    if (!node) return;
    const allowDelete = node.kind === "user";
    const canTriggerEncounter = typeof logic.triggerEncounterAt === "function";
    if (!allowDelete && !canTriggerEncounter) {
      return;
    }
    ev.preventDefault();
    ev.stopPropagation();
    const menu = new import_obsidian12.Menu();
    if (allowDelete) {
      menu.addItem(
        (item) => item.setTitle("Wegpunkt entfernen").setIcon("trash").onClick(() => {
          logic.deleteUserAt(idx);
        })
      );
    }
    if (canTriggerEncounter) {
      menu.addItem(
        (item) => item.setTitle("Encounter hier starten").setIcon("sparkles").onClick(() => {
          void logic.triggerEncounterAt?.(idx);
        })
      );
    }
    menu.showAtMouseEvent(ev);
  };
  routeLayerEl.addEventListener("contextmenu", onContextMenu, { capture: true });
  return () => routeLayerEl.removeEventListener("contextmenu", onContextMenu, { capture: true });
}
var import_obsidian12;
var init_context_menu_controller = __esm({
  "src/apps/cartographer/travel/ui/context-menu.controller.ts"() {
    "use strict";
    import_obsidian12 = require("obsidian");
  }
});

// src/apps/cartographer/travel/ui/contextmenue.ts
var init_contextmenue = __esm({
  "src/apps/cartographer/travel/ui/contextmenue.ts"() {
    "use strict";
    init_context_menu_controller();
  }
});

// src/apps/cartographer/modes/travel-guide/interaction-controller.ts
var TravelInteractionController;
var init_interaction_controller = __esm({
  "src/apps/cartographer/modes/travel-guide/interaction-controller.ts"() {
    "use strict";
    init_drag_controller();
    init_contextmenue();
    TravelInteractionController = class {
      constructor() {
        this.drag = null;
        this.unbindContext = null;
      }
      bind(env, logic) {
        this.dispose();
        this.drag = createDragController({
          routeLayerEl: env.routeLayerEl,
          tokenEl: env.tokenLayerEl,
          token: env.token,
          adapter: env.adapter,
          logic: {
            getState: () => logic.getState(),
            selectDot: (idx) => logic.selectDot(idx),
            moveSelectedTo: (rc) => logic.moveSelectedTo(rc),
            moveTokenTo: (rc) => logic.moveTokenTo(rc)
          },
          polyToCoord: env.polyToCoord
        });
        this.drag.bind();
        this.unbindContext = bindContextMenu(env.routeLayerEl, {
          getState: () => logic.getState(),
          deleteUserAt: (idx) => logic.deleteUserAt(idx),
          triggerEncounterAt: (idx) => logic.triggerEncounterAt?.(idx)
        });
      }
      consumeClickSuppression() {
        return this.drag?.consumeClickSuppression() ?? false;
      }
      dispose() {
        if (this.drag) {
          this.drag.unbind();
          this.drag = null;
        }
        if (this.unbindContext) {
          this.unbindContext();
          this.unbindContext = null;
        }
      }
    };
  }
});

// src/apps/encounter/session-store.ts
function createInitialEncounterXpState() {
  return {
    party: [],
    encounterXp: 0,
    rules: []
  };
}
function clonePartyMember(member) {
  return { ...member };
}
function cloneRule(rule) {
  return { ...rule };
}
function cloneMutableEncounterXpState(state) {
  return {
    party: state.party.map(clonePartyMember),
    encounterXp: state.encounterXp,
    rules: state.rules.map(cloneRule)
  };
}
function createImmutableEncounterXpState(state) {
  const party = Object.freeze(state.party.map(clonePartyMember));
  const rules = Object.freeze(state.rules.map(cloneRule));
  return {
    party,
    encounterXp: state.encounterXp,
    rules
  };
}
function emitEncounterXpState() {
  const snapshot = createImmutableEncounterXpState(encounterXpState);
  if (!xpStateListeners.size) {
    return snapshot;
  }
  for (const listener of [...xpStateListeners]) {
    try {
      listener(snapshot);
    } catch (err) {
      console.error("[encounter] xp listener failed", err);
    }
  }
  return snapshot;
}
function publishEncounterEvent(event) {
  latestEvent = event;
  for (const listener of [...listeners]) {
    try {
      listener(event);
    } catch (err) {
      console.error("[encounter] listener failed", err);
    }
  }
}
function subscribeToEncounterEvents(listener) {
  listeners.add(listener);
  if (latestEvent) {
    try {
      listener(latestEvent);
    } catch (err) {
      console.error("[encounter] listener failed", err);
    }
  }
  return () => {
    listeners.delete(listener);
  };
}
function peekLatestEncounterEvent() {
  return latestEvent;
}
function getEncounterXpState() {
  return createImmutableEncounterXpState(encounterXpState);
}
function subscribeEncounterXpState(listener) {
  xpStateListeners.add(listener);
  try {
    listener(getEncounterXpState());
  } catch (err) {
    console.error("[encounter] xp listener failed", err);
  }
  return () => {
    xpStateListeners.delete(listener);
  };
}
function updateEncounterXpState(mutator) {
  const next = cloneMutableEncounterXpState(encounterXpState);
  mutator(next);
  encounterXpState = next;
  return emitEncounterXpState();
}
function setEncounterXp(value) {
  return updateEncounterXpState((draft) => {
    draft.encounterXp = value;
  });
}
function addPartyMember(member) {
  return updateEncounterXpState((draft) => {
    draft.party.push(clonePartyMember(member));
  });
}
function updatePartyMember(id, patch) {
  return updateEncounterXpState((draft) => {
    const index = draft.party.findIndex((member) => member.id === id);
    if (index === -1) {
      return;
    }
    draft.party[index] = { ...draft.party[index], ...patch };
  });
}
function removePartyMember(id) {
  return updateEncounterXpState((draft) => {
    draft.party = draft.party.filter((member) => member.id !== id);
  });
}
function addRule(rule) {
  return updateEncounterXpState((draft) => {
    draft.rules.push(cloneRule(rule));
  });
}
function updateRule(id, patch) {
  return updateEncounterXpState((draft) => {
    const index = draft.rules.findIndex((rule) => rule.id === id);
    if (index === -1) {
      return;
    }
    draft.rules[index] = { ...draft.rules[index], ...patch };
  });
}
function replaceEncounterXpState(state) {
  encounterXpState = {
    party: state.party.map(clonePartyMember),
    encounterXp: state.encounterXp,
    rules: state.rules.map(cloneRule)
  };
  return emitEncounterXpState();
}
var DND5E_XP_THRESHOLDS, latestEvent, listeners, encounterXpState, xpStateListeners;
var init_session_store = __esm({
  "src/apps/encounter/session-store.ts"() {
    "use strict";
    DND5E_XP_THRESHOLDS = {
      1: 0,
      2: 300,
      3: 900,
      4: 2700,
      5: 6500,
      6: 14e3,
      7: 23e3,
      8: 34e3,
      9: 48e3,
      10: 64e3,
      11: 85e3,
      12: 1e5,
      13: 12e4,
      14: 14e4,
      15: 165e3,
      16: 195e3,
      17: 225e3,
      18: 265e3,
      19: 305e3,
      20: 355e3
    };
    latestEvent = null;
    listeners = /* @__PURE__ */ new Set();
    encounterXpState = createInitialEncounterXpState();
    xpStateListeners = /* @__PURE__ */ new Set();
  }
});

// src/apps/encounter/event-builder.ts
async function createEncounterEventFromTravel(app, ctx, options = {}) {
  const triggeredAt = options.triggeredAt ?? (/* @__PURE__ */ new Date()).toISOString();
  const coord = options.coordOverride ?? ctx?.state?.currentTile ?? ctx?.state?.tokenRC ?? null;
  const mapFile = ctx?.mapFile ?? null;
  let regionName;
  let encounterOdds;
  if (mapFile && coord) {
    try {
      const { loadTile: loadTile2 } = await Promise.resolve().then(() => (init_hex_notes(), hex_notes_exports));
      const tile = await loadTile2(app, mapFile, coord).catch(() => null);
      const tileRegion = typeof tile?.region === "string" ? tile.region : void 0;
      if (tileRegion) {
        regionName = tileRegion;
        try {
          const { loadRegions: loadRegions2 } = await Promise.resolve().then(() => (init_regions_store(), regions_store_exports));
          const regions = await loadRegions2(app);
          const region = regions.find((r) => typeof r?.name === "string" && r.name.toLowerCase() === tileRegion.toLowerCase());
          const odds = region?.encounterOdds;
          if (typeof odds === "number" && Number.isFinite(odds) && odds > 0) {
            encounterOdds = odds;
          }
        } catch (err) {
          console.error("[encounter] failed to resolve region odds", err);
        }
      }
    } catch (err) {
      console.error("[encounter] failed to read tile metadata", err);
    }
  }
  const travelClock = ctx?.state?.clockHours;
  const source = options.source ?? "travel";
  const idPrefix = options.idPrefix ?? source;
  const event = {
    id: `${idPrefix}-${Date.now()}`,
    source,
    triggeredAt,
    coord,
    regionName,
    mapPath: mapFile?.path,
    mapName: mapFile?.basename,
    encounterOdds,
    travelClockHours: typeof travelClock === "number" && Number.isFinite(travelClock) ? travelClock : void 0
  };
  return event;
}
var init_event_builder = __esm({
  "src/apps/encounter/event-builder.ts"() {
    "use strict";
  }
});

// src/apps/encounter/presenter.ts
function deriveEncounterXpView(state) {
  const party = state.party ?? [];
  const baseEncounterXp = sanitizeNonNegativeNumber(state.encounterXp ?? 0);
  const partyCount = party.length;
  const basePerMember = partyCount > 0 ? baseEncounterXp / partyCount : 0;
  const globalWarnings = [];
  if (partyCount === 0 && baseEncounterXp > 0) {
    pushWarning(globalWarnings, "Encounter XP assigned but no party members present.");
  }
  const members = party.map((member) => {
    const xpToNext = calculateXpToNextLevel(member.level, member.currentXp);
    const warnings = [];
    if (xpToNext === null) {
      const sanitizedLevel = sanitizeLevel(member.level);
      if (sanitizedLevel >= 20) {
        pushWarning(warnings, "Maximum level reached.");
      } else {
        pushWarning(warnings, "XP threshold for next level unavailable.");
      }
    }
    return {
      member,
      baseXp: basePerMember,
      modifiersDelta: 0,
      totalXp: basePerMember,
      xpToNextLevel: xpToNext,
      warnings
    };
  });
  const ruleViews = [];
  for (const rule of state.rules ?? []) {
    const ruleWarnings = [];
    const perMemberDeltas = [];
    let totalDelta = 0;
    if (!rule.enabled) {
      for (const member of members) {
        perMemberDeltas.push({
          memberId: member.member.id,
          memberName: member.member.name,
          delta: 0
        });
      }
      ruleViews.push({ rule, totalDelta, perMemberDeltas, warnings: ruleWarnings });
      continue;
    }
    if (!partyCount) {
      if (rule.modifierValue !== 0) {
        pushWarning(ruleWarnings, "Rule effect ignored because no party members are present.");
      }
      ruleViews.push({ rule, totalDelta, perMemberDeltas, warnings: ruleWarnings });
      for (const warning of ruleWarnings) {
        pushWarning(globalWarnings, warning);
      }
      continue;
    }
    const appendMemberDelta = (member, delta) => {
      member.modifiersDelta += delta;
      member.totalXp += delta;
      perMemberDeltas.push({
        memberId: member.member.id,
        memberName: member.member.name,
        delta
      });
      totalDelta += delta;
    };
    if (rule.scope === "overall") {
      switch (rule.modifierType) {
        case "flat": {
          const perMember = rule.modifierValue / partyCount;
          for (const member of members) {
            appendMemberDelta(member, perMember);
          }
          break;
        }
        case "percentTotal": {
          const percent = rule.modifierValue / 100;
          for (const member of members) {
            const delta = member.totalXp * percent;
            appendMemberDelta(member, delta);
          }
          break;
        }
        case "percentNextLevel": {
          let aggregateNext = 0;
          for (const member of members) {
            if (member.xpToNextLevel == null) {
              pushWarning(ruleWarnings, `${member.member.name} has no next-level XP threshold.`);
              continue;
            }
            aggregateNext += member.xpToNextLevel;
          }
          if (aggregateNext === 0) {
            for (const member of members) {
              perMemberDeltas.push({
                memberId: member.member.id,
                memberName: member.member.name,
                delta: 0
              });
            }
            break;
          }
          const total = aggregateNext * (rule.modifierValue / 100);
          const perMember = total / partyCount;
          for (const member of members) {
            appendMemberDelta(member, perMember);
          }
          break;
        }
      }
    } else {
      switch (rule.modifierType) {
        case "flat": {
          for (const member of members) {
            appendMemberDelta(member, rule.modifierValue);
          }
          break;
        }
        case "percentTotal": {
          const percent = rule.modifierValue / 100;
          for (const member of members) {
            const delta = member.totalXp * percent;
            appendMemberDelta(member, delta);
          }
          break;
        }
        case "percentNextLevel": {
          const percent = rule.modifierValue / 100;
          for (const member of members) {
            if (member.xpToNextLevel == null) {
              pushWarning(ruleWarnings, `${member.member.name} has no next-level XP threshold.`);
              perMemberDeltas.push({
                memberId: member.member.id,
                memberName: member.member.name,
                delta: 0
              });
              continue;
            }
            const delta = member.xpToNextLevel * percent;
            appendMemberDelta(member, delta);
          }
          break;
        }
      }
    }
    ruleViews.push({ rule, totalDelta, perMemberDeltas, warnings: ruleWarnings });
    for (const warning of ruleWarnings) {
      pushWarning(globalWarnings, warning);
    }
  }
  const finalParty = members.map((member) => ({
    member: member.member,
    baseXp: member.baseXp,
    modifiersDelta: member.modifiersDelta,
    totalXp: member.totalXp,
    xpToNextLevel: member.xpToNextLevel,
    warnings: member.warnings
  }));
  const totalEncounterXp = finalParty.reduce((sum, member) => sum + member.totalXp, 0);
  return {
    baseEncounterXp,
    totalEncounterXp,
    party: finalParty,
    rules: ruleViews,
    warnings: globalWarnings
  };
}
function calculateXpToNextLevel(level, currentXp) {
  const sanitizedLevel = sanitizeLevel(level);
  if (sanitizedLevel >= 20) {
    return null;
  }
  const currentThreshold = DND5E_XP_THRESHOLDS[sanitizedLevel];
  const nextThreshold = DND5E_XP_THRESHOLDS[sanitizedLevel + 1];
  if (typeof currentThreshold !== "number" || typeof nextThreshold !== "number") {
    return null;
  }
  const effectiveCurrentXp = sanitizeOptionalNonNegativeNumber(currentXp) ?? currentThreshold;
  if (effectiveCurrentXp >= nextThreshold) {
    return 0;
  }
  return nextThreshold - effectiveCurrentXp;
}
function sanitizeNumber(value) {
  if (typeof value !== "number" || !Number.isFinite(value)) {
    return 0;
  }
  return value;
}
function sanitizeNonNegativeNumber(value) {
  const numeric = sanitizeNumber(value);
  return numeric < 0 ? 0 : numeric;
}
function sanitizeOptionalNonNegativeNumber(value) {
  if (value === null || value === void 0) {
    return void 0;
  }
  return sanitizeNonNegativeNumber(value);
}
function sanitizeLevel(level) {
  const numeric = Math.floor(sanitizeNumber(level));
  return numeric < 1 ? 1 : numeric;
}
function clampPercentage(value) {
  if (!Number.isFinite(value)) {
    return 0;
  }
  if (value > 100) return 100;
  if (value < -100) return -100;
  return value;
}
function clampIndex(index, length) {
  if (length <= 0) return 0;
  if (!Number.isFinite(index)) return 0;
  const truncated = Math.trunc(index);
  if (truncated < 0) return 0;
  if (truncated >= length) return length - 1;
  return truncated;
}
function pushWarning(collection, warning) {
  if (!warning) return;
  if (!collection.includes(warning)) {
    collection.push(warning);
  }
}
function shallowEqualPartyMembers(a, b) {
  return a.id === b.id && a.name === b.name && a.level === b.level && (a.currentXp ?? void 0) === (b.currentXp ?? void 0);
}
function shallowEqualRules(a, b) {
  return a.id === b.id && a.title === b.title && a.scope === b.scope && a.modifierType === b.modifierType && a.modifierValue === b.modifierValue && a.enabled === b.enabled && (a.notes ?? "") === (b.notes ?? "");
}
var defaultDeps, EncounterPresenter;
var init_presenter = __esm({
  "src/apps/encounter/presenter.ts"() {
    "use strict";
    init_session_store();
    defaultDeps = {
      now: () => (/* @__PURE__ */ new Date()).toISOString()
    };
    EncounterPresenter = class _EncounterPresenter {
      constructor(initial, deps) {
        this.listeners = /* @__PURE__ */ new Set();
        this.deps = { ...defaultDeps, ...deps };
        this.persisted = _EncounterPresenter.normalise(initial);
        this.viewState = _EncounterPresenter.createViewState(this.persisted);
        this.unsubscribeStore = subscribeToEncounterEvents((event) => this.applyEvent(event));
        this.unsubscribeXpStore = subscribeEncounterXpState((xp) => this.applyXpState(xp));
        if (initial?.xp) {
          replaceEncounterXpState(this.persisted.xp);
        }
      }
      dispose() {
        this.unsubscribeStore?.();
        this.unsubscribeXpStore?.();
        this.listeners.clear();
      }
      /** Restores persisted state (e.g. when `setViewData` fires before `onOpen`). */
      restore(state) {
        const normalisedSession = _EncounterPresenter.normaliseSession(state?.session);
        this.persisted = {
          ...this.persisted,
          session: normalisedSession
        };
        if (state?.xp) {
          replaceEncounterXpState(_EncounterPresenter.normaliseXpState(state.xp));
        } else {
          this.emit();
        }
      }
      getState() {
        return this.viewState;
      }
      subscribe(listener) {
        this.listeners.add(listener);
        listener(this.viewState);
        return () => {
          this.listeners.delete(listener);
        };
      }
      setNotes(notes) {
        if (!this.persisted.session) return;
        if (this.persisted.session.notes === notes) return;
        this.persisted = {
          ...this.persisted,
          session: {
            ...this.persisted.session,
            notes
          }
        };
        this.emit();
      }
      markResolved() {
        const session = this.persisted.session;
        if (!session) return;
        if (session.status === "resolved") return;
        this.persisted = {
          ...this.persisted,
          session: {
            ...session,
            status: "resolved",
            resolvedAt: this.deps.now()
          }
        };
        this.emit();
      }
      reset() {
        if (!this.persisted.session) return;
        this.persisted = {
          ...this.persisted,
          session: null
        };
        this.emit();
      }
      setEncounterXp(value) {
        const sanitized = sanitizeNonNegativeNumber(value);
        if (sanitized === this.persisted.xp.encounterXp) return;
        setEncounterXp(sanitized);
      }
      addPartyMember(member) {
        const sanitized = _EncounterPresenter.normalisePartyMember(member);
        if (this.persisted.xp.party.some((existing) => existing.id === sanitized.id)) {
          this.updatePartyMember(sanitized.id, sanitized);
          return;
        }
        addPartyMember(sanitized);
      }
      updatePartyMember(id, patch) {
        const existing = this.persisted.xp.party.find((member) => member.id === id);
        if (!existing) return;
        const sanitizedPatch = _EncounterPresenter.normalisePartyMemberPatch(patch, existing);
        const next = { ...existing, ...sanitizedPatch };
        if (shallowEqualPartyMembers(existing, next)) return;
        updatePartyMember(id, sanitizedPatch);
      }
      removePartyMember(id) {
        if (!this.persisted.xp.party.some((member) => member.id === id)) return;
        removePartyMember(id);
      }
      addRule(rule) {
        const sanitized = _EncounterPresenter.normaliseRule(rule);
        if (this.persisted.xp.rules.some((existing) => existing.id === sanitized.id)) {
          this.updateRule(sanitized.id, sanitized);
          return;
        }
        addRule(sanitized);
      }
      updateRule(id, patch) {
        const existing = this.persisted.xp.rules.find((rule) => rule.id === id);
        if (!existing) return;
        const sanitizedPatch = _EncounterPresenter.normaliseRulePatch(patch, existing);
        const next = { ...existing, ...sanitizedPatch };
        if (shallowEqualRules(existing, next)) return;
        updateRule(id, sanitizedPatch);
      }
      toggleRule(id, enabled) {
        const existing = this.persisted.xp.rules.find((rule) => rule.id === id);
        if (!existing) return;
        const nextEnabled = enabled ?? !existing.enabled;
        if (existing.enabled === nextEnabled) return;
        updateRule(id, { enabled: nextEnabled });
      }
      moveRule(id, targetIndex) {
        updateEncounterXpState((draft) => {
          const currentIndex = draft.rules.findIndex((rule2) => rule2.id === id);
          if (currentIndex === -1) return;
          const normalisedIndex = clampIndex(targetIndex, draft.rules.length);
          if (normalisedIndex === currentIndex) return;
          const [rule] = draft.rules.splice(currentIndex, 1);
          draft.rules.splice(normalisedIndex, 0, rule);
        });
      }
      resetXpState() {
        replaceEncounterXpState({
          party: [],
          encounterXp: 0,
          rules: []
        });
      }
      applyEvent(event) {
        const prev = this.persisted.session;
        if (!prev || prev.event.id !== event.id) {
          this.persisted = {
            ...this.persisted,
            session: {
              event,
              notes: "",
              status: "pending"
            }
          };
        } else {
          this.persisted = {
            ...this.persisted,
            session: {
              ...prev,
              event
            }
          };
        }
        this.emit();
      }
      applyXpState(xp) {
        this.persisted = {
          ...this.persisted,
          xp: _EncounterPresenter.normaliseXpState(xp)
        };
        this.emit();
      }
      emit() {
        this.viewState = _EncounterPresenter.createViewState(this.persisted);
        for (const listener of [...this.listeners]) {
          listener(this.viewState);
        }
      }
      static normalise(initial) {
        return {
          session: _EncounterPresenter.normaliseSession(initial?.session),
          xp: _EncounterPresenter.normaliseXpState(initial?.xp ?? getEncounterXpState())
        };
      }
      static createViewState(persisted) {
        return {
          session: persisted.session,
          xp: persisted.xp,
          xpView: deriveEncounterXpView(persisted.xp)
        };
      }
      static normaliseSession(session) {
        if (!session || !session.event) {
          return null;
        }
        const status = session.status === "resolved" ? "resolved" : "pending";
        return {
          event: session.event,
          notes: session.notes ?? "",
          status,
          resolvedAt: session.resolvedAt ?? null
        };
      }
      static normaliseXpState(xp) {
        const baseEncounterXp = sanitizeNonNegativeNumber(xp?.encounterXp ?? 0);
        const party = Object.freeze((xp?.party ?? []).map((member) => ({
          ..._EncounterPresenter.normalisePartyMember(member)
        })));
        const rules = Object.freeze((xp?.rules ?? []).map((rule) => ({
          ..._EncounterPresenter.normaliseRule(rule)
        })));
        return {
          party,
          encounterXp: baseEncounterXp,
          rules
        };
      }
      static normalisePartyMember(member) {
        return {
          ...member,
          level: sanitizeLevel(member.level),
          currentXp: sanitizeOptionalNonNegativeNumber(member.currentXp)
        };
      }
      static normalisePartyMemberPatch(patch, existing) {
        const next = {};
        if (patch.name !== void 0) {
          next.name = patch.name;
        }
        if (patch.level !== void 0) {
          next.level = sanitizeLevel(patch.level);
        }
        if (patch.currentXp !== void 0) {
          next.currentXp = sanitizeOptionalNonNegativeNumber(patch.currentXp);
        }
        if (patch.currentXp === null) {
          next.currentXp = void 0;
        }
        if (patch.id !== void 0 && patch.id !== existing.id) {
          next.id = existing.id;
        }
        return next;
      }
      static normaliseRule(rule) {
        return {
          ...rule,
          modifierValue: _EncounterPresenter.normaliseRuleModifierValue(rule.modifierType, rule.modifierValue),
          enabled: rule.enabled !== false,
          notes: rule.notes ?? (rule.notes === "" ? "" : void 0)
        };
      }
      static normaliseRulePatch(patch, existing) {
        const next = {};
        if (patch.title !== void 0) {
          next.title = patch.title;
        }
        if (patch.scope !== void 0) {
          next.scope = patch.scope;
        }
        if (patch.modifierType !== void 0) {
          next.modifierType = patch.modifierType;
        }
        if (patch.modifierValue !== void 0) {
          const modifierType = patch.modifierType ?? existing.modifierType;
          next.modifierValue = _EncounterPresenter.normaliseRuleModifierValue(modifierType, patch.modifierValue);
        } else if (patch.modifierType !== void 0) {
          next.modifierValue = _EncounterPresenter.normaliseRuleModifierValue(
            patch.modifierType,
            existing.modifierValue
          );
        }
        if (patch.enabled !== void 0) {
          next.enabled = !!patch.enabled;
        }
        if (patch.notes !== void 0) {
          next.notes = patch.notes;
        }
        return next;
      }
      static normaliseRuleModifierValue(type, value) {
        if (type === "flat") {
          return sanitizeNumber(value);
        }
        return clampPercentage(sanitizeNumber(value));
      }
    };
  }
});

// src/apps/encounter/view.ts
var view_exports = {};
__export(view_exports, {
  EncounterView: () => EncounterView,
  VIEW_ENCOUNTER: () => VIEW_ENCOUNTER
});
function createSection(parent, className) {
  return parent.createDiv({ cls: `sm-encounter-section ${className}` });
}
function createTextInput(parent, options) {
  const field = createFieldContainer(parent);
  field.createEl("label", { attr: { for: options.id }, text: options.label });
  return field.createEl("input", {
    cls: "sm-encounter-input",
    attr: {
      id: options.id,
      type: "text",
      placeholder: options.placeholder ?? "",
      value: options.value != null ? String(options.value) : ""
    }
  });
}
function createNumberInput(parent, options) {
  const field = createFieldContainer(parent);
  field.createEl("label", { attr: { for: options.id }, text: options.label });
  const attrs = {
    id: options.id,
    type: "number"
  };
  if (options.min !== void 0) attrs.min = String(options.min);
  if (options.max !== void 0) attrs.max = String(options.max);
  if (options.step !== void 0) attrs.step = String(options.step);
  if (options.placeholder) attrs.placeholder = options.placeholder;
  if (options.value !== void 0) attrs.value = String(options.value);
  return field.createEl("input", {
    cls: "sm-encounter-input",
    attr: attrs
  });
}
function createSelect(parent, options) {
  const field = createFieldContainer(parent);
  field.createEl("label", { attr: { for: options.id }, text: options.label });
  const select = field.createEl("select", {
    cls: "sm-encounter-input",
    attr: { id: options.id }
  });
  for (const option of options.options) {
    select.createEl("option", { attr: { value: option.value }, text: option.label });
  }
  return select;
}
function createTextarea(parent, options) {
  const field = createFieldContainer(parent);
  field.createEl("label", { attr: { for: options.id }, text: options.label });
  return field.createEl("textarea", {
    cls: "sm-encounter-input",
    attr: {
      id: options.id,
      rows: options.rows != null ? String(options.rows) : "3",
      placeholder: options.placeholder ?? ""
    }
  });
}
function createFieldContainer(parent) {
  return parent.createDiv({ cls: "sm-encounter-field" });
}
function createStatItem(list, label, value) {
  const item = list.createEl("li");
  item.createEl("span", { cls: "label", text: `${label}:` });
  item.createEl("span", { cls: "value", text: value });
}
function formatNumber(value) {
  if (!Number.isFinite(value)) {
    return "0";
  }
  return numberFormatter.format(value);
}
function formatSignedNumber(value) {
  const formatted = formatNumber(Math.abs(value));
  if (value > 0) return `+${formatted}`;
  if (value < 0) return `-${formatted}`;
  return formatted;
}
function createId(prefix) {
  const globalCrypto = globalThis.crypto;
  if (globalCrypto?.randomUUID) {
    return `${prefix}-${globalCrypto.randomUUID()}`;
  }
  const random = Math.random().toString(36).slice(2, 8);
  return `${prefix}-${Date.now().toString(36)}-${random}`;
}
var import_obsidian13, VIEW_ENCOUNTER, EncounterView, numberFormatter;
var init_view = __esm({
  "src/apps/encounter/view.ts"() {
    "use strict";
    import_obsidian13 = require("obsidian");
    init_presenter();
    VIEW_ENCOUNTER = "salt-encounter";
    EncounterView = class extends import_obsidian13.ItemView {
      constructor(leaf) {
        super(leaf);
        this.presenter = null;
        this.pendingState = null;
      }
      getViewType() {
        return VIEW_ENCOUNTER;
      }
      getDisplayText() {
        return "Encounter";
      }
      getIcon() {
        return "swords";
      }
      async onOpen() {
        this.contentEl.addClass("sm-encounter-view");
        this.renderShell();
        this.presenter = new EncounterPresenter(this.pendingState);
        this.pendingState = null;
        this.detachPresenter = this.presenter.subscribe((state) => this.render(state));
      }
      async onClose() {
        this.detachPresenter?.();
        this.presenter?.dispose();
        this.detachPresenter = void 0;
        this.presenter = null;
        this.pendingState = null;
        this.contentEl.empty();
        this.contentEl.removeClass("sm-encounter-view");
      }
      getViewData() {
        return this.presenter?.getState() ?? this.pendingState;
      }
      setViewData(data) {
        if (this.presenter) {
          this.presenter.restore(data);
        } else {
          this.pendingState = data;
        }
      }
      renderShell() {
        this.contentEl.empty();
        const headerSection = createSection(this.contentEl, "sm-encounter-header");
        this.headerTitleEl = headerSection.createEl("h2", {
          cls: "sm-encounter-heading",
          text: "Encounter"
        });
        this.statusEl = headerSection.createDiv({
          cls: "sm-encounter-status",
          text: "Waiting for travel events\u2026"
        });
        const metaEl = headerSection.createDiv({ cls: "sm-encounter-meta" });
        this.summaryListEl = metaEl.createEl("ul", { cls: "sm-encounter-summary" });
        this.emptyStateEl = headerSection.createDiv({
          cls: "sm-encounter-empty",
          text: "No active encounter. Travel mode will populate this workspace when an encounter triggers."
        });
        const partySection = createSection(this.contentEl, "sm-encounter-party");
        partySection.createEl("h3", { cls: "sm-encounter-section-title", text: "Party" });
        const partyForm = partySection.createEl("form", { cls: "sm-encounter-form" });
        const partyFormGrid = partyForm.createDiv({ cls: "sm-encounter-form-grid" });
        this.partyFormNameEl = createTextInput(partyFormGrid, {
          id: "encounter-party-name",
          label: "Name",
          placeholder: "Character name"
        });
        this.partyFormLevelEl = createNumberInput(partyFormGrid, {
          id: "encounter-party-level",
          label: "Level",
          min: 1,
          step: 1,
          value: 1
        });
        this.partyFormCurrentXpEl = createNumberInput(partyFormGrid, {
          id: "encounter-party-current-xp",
          label: "Current XP",
          min: 0,
          step: 1,
          placeholder: "Optional"
        });
        const partySubmitWrapper = partyFormGrid.createDiv({ cls: "sm-encounter-field sm-encounter-field-actions" });
        const partySubmitButton = partySubmitWrapper.createEl("button", {
          cls: "sm-encounter-button",
          text: "Add party member"
        });
        partySubmitButton.type = "submit";
        this.partyFormErrorEl = partyForm.createDiv({ cls: "sm-encounter-error" });
        partyForm.addEventListener("submit", (event) => {
          event.preventDefault();
          this.handleAddPartyMember();
        });
        partyForm.addEventListener("input", () => {
          this.partyFormErrorEl.setText("");
        });
        this.partyListEl = partySection.createDiv({ cls: "sm-encounter-party-list" });
        const xpSection = createSection(this.contentEl, "sm-encounter-xp");
        xpSection.createEl("h3", { cls: "sm-encounter-section-title", text: "Encounter XP & Rules" });
        const xpRow = xpSection.createDiv({ cls: "sm-encounter-xp-row" });
        this.xpInputEl = createNumberInput(xpRow, {
          id: "encounter-base-xp",
          label: "Base encounter XP",
          min: 0,
          step: 1
        });
        this.xpInputEl.addEventListener("change", () => this.handleEncounterXpChange());
        this.xpInputEl.addEventListener("input", () => {
          this.xpErrorEl.setText("");
        });
        const xpControls = xpRow.createDiv({ cls: "sm-encounter-inline-actions" });
        this.resetXpButton = xpControls.createEl("button", {
          cls: "sm-encounter-button sm-encounter-button-secondary",
          text: "Reset XP state"
        });
        this.resetXpButton.type = "button";
        this.resetXpButton.addEventListener("click", () => {
          this.presenter?.resetXpState();
        });
        this.xpErrorEl = xpSection.createDiv({ cls: "sm-encounter-error" });
        this.ruleListEl = xpSection.createDiv({ cls: "sm-encounter-rule-list" });
        const addRuleHeading = xpSection.createEl("h4", {
          cls: "sm-encounter-subheading",
          text: "Add rule"
        });
        addRuleHeading.setAttr("aria-hidden", "true");
        const ruleForm = xpSection.createEl("form", { cls: "sm-encounter-form" });
        const ruleFormGrid = ruleForm.createDiv({ cls: "sm-encounter-form-grid" });
        this.ruleFormTitleEl = createTextInput(ruleFormGrid, {
          id: "encounter-rule-title",
          label: "Title",
          placeholder: "Rule description"
        });
        this.ruleFormScopeEl = createSelect(ruleFormGrid, {
          id: "encounter-rule-scope",
          label: "Scope",
          options: [
            { value: "overall", label: "Entire encounter" },
            { value: "perPlayer", label: "Per character" }
          ]
        });
        this.ruleFormScopeEl.value = "overall";
        this.ruleFormTypeEl = createSelect(ruleFormGrid, {
          id: "encounter-rule-type",
          label: "Modifier type",
          options: [
            { value: "flat", label: "Flat" },
            { value: "percentTotal", label: "% of total" },
            { value: "percentNextLevel", label: "% to next level" }
          ]
        });
        this.ruleFormTypeEl.value = "flat";
        this.ruleFormValueEl = createNumberInput(ruleFormGrid, {
          id: "encounter-rule-value",
          label: "Value",
          step: 1,
          value: 0
        });
        this.ruleFormValueEl.value = "0";
        this.ruleFormNotesEl = createTextarea(ruleFormGrid, {
          id: "encounter-rule-notes",
          label: "Notes",
          placeholder: "Optional notes",
          rows: 2
        });
        const ruleEnabledWrapper = ruleFormGrid.createDiv({ cls: "sm-encounter-field sm-encounter-field-toggle" });
        const enabledId = "encounter-rule-enabled";
        const enabledLabel = ruleEnabledWrapper.createEl("label", {
          attr: { for: enabledId },
          text: "Enabled"
        });
        enabledLabel.addClass("sm-encounter-toggle-label");
        this.ruleFormEnabledEl = ruleEnabledWrapper.createEl("input", {
          attr: { id: enabledId, type: "checkbox" }
        });
        this.ruleFormEnabledEl.checked = true;
        const ruleSubmitWrapper = ruleFormGrid.createDiv({ cls: "sm-encounter-field sm-encounter-field-actions" });
        const ruleSubmitButton = ruleSubmitWrapper.createEl("button", {
          cls: "sm-encounter-button",
          text: "Add rule"
        });
        ruleSubmitButton.type = "submit";
        this.ruleFormErrorEl = ruleForm.createDiv({ cls: "sm-encounter-error" });
        ruleForm.addEventListener("submit", (event) => {
          event.preventDefault();
          this.handleAddRule();
        });
        ruleForm.addEventListener("input", () => {
          this.ruleFormErrorEl.setText("");
        });
        const resultsSection = createSection(this.contentEl, "sm-encounter-results");
        resultsSection.createEl("h3", { cls: "sm-encounter-section-title", text: "Results" });
        this.resultTotalsEl = resultsSection.createDiv({ cls: "sm-encounter-result-totals" });
        this.resultWarningsEl = resultsSection.createDiv({ cls: "sm-encounter-result-warnings" });
        const breakdownWrapper = resultsSection.createDiv({ cls: "sm-encounter-breakdowns" });
        this.resultPartyEl = breakdownWrapper.createDiv({ cls: "sm-encounter-result-party" });
        this.resultRulesEl = breakdownWrapper.createDiv({ cls: "sm-encounter-result-rules" });
        const notesSection = resultsSection.createDiv({ cls: "sm-encounter-notes" });
        notesSection.createEl("label", {
          cls: "sm-encounter-notes-label",
          attr: { for: "encounter-notes" },
          text: "Notes"
        });
        this.notesEl = notesSection.createEl("textarea", {
          cls: "sm-encounter-notes-input",
          attr: {
            id: "encounter-notes",
            placeholder: "Record tactical notes, initiative order, or follow-up tasks\u2026",
            rows: "6"
          }
        });
        this.notesEl.disabled = true;
        this.notesEl.addEventListener("input", () => {
          if (!this.presenter) return;
          this.presenter.setNotes(this.notesEl.value);
        });
        const actionsRow = resultsSection.createDiv({ cls: "sm-encounter-actions" });
        this.resolveBtn = actionsRow.createEl("button", {
          cls: "sm-encounter-button sm-encounter-button-primary",
          text: "Mark encounter resolved"
        });
        this.resolveBtn.type = "button";
        this.resolveBtn.disabled = true;
        this.resolveBtn.addEventListener("click", () => {
          this.presenter?.markResolved();
        });
      }
      render(state) {
        this.renderHeader(state);
        this.renderParty(state);
        this.renderRules(state);
        this.renderResults(state);
      }
      renderHeader(state) {
        const session = state.session;
        if (!session) {
          this.headerTitleEl.setText("Encounter");
          this.statusEl.setText("Waiting for travel events\u2026");
          this.summaryListEl.empty();
          this.emptyStateEl.removeClass("sm-encounter-hidden");
          this.notesEl.value = "";
          this.notesEl.disabled = true;
          this.resolveBtn.disabled = true;
          this.resolveBtn.setText("Mark encounter resolved");
          return;
        }
        this.emptyStateEl.addClass("sm-encounter-hidden");
        const { event, status, resolvedAt } = session;
        const region = event.regionName ?? "Unknown region";
        this.headerTitleEl.setText(`Encounter \u2013 ${region}`);
        if (status === "resolved") {
          this.statusEl.setText(resolvedAt ? `Resolved ${resolvedAt}` : "Resolved");
        } else {
          this.statusEl.setText("Awaiting resolution");
        }
        this.summaryListEl.empty();
        const summaryEntries = [];
        if (event.coord) {
          summaryEntries.push(["Hex", `${event.coord.r}, ${event.coord.c}`]);
        }
        if (event.mapName) {
          summaryEntries.push(["Map", event.mapName]);
        }
        if (event.mapPath) {
          summaryEntries.push(["Map path", event.mapPath]);
        }
        summaryEntries.push(["Triggered", event.triggeredAt]);
        if (typeof event.travelClockHours === "number") {
          summaryEntries.push(["Travel clock", `${event.travelClockHours.toFixed(2)} h`]);
        }
        if (typeof event.encounterOdds === "number") {
          summaryEntries.push(["Encounter odds", `1 in ${event.encounterOdds}`]);
        }
        for (const [label, value] of summaryEntries) {
          const li = this.summaryListEl.createEl("li");
          li.createSpan({ cls: "label", text: `${label}: ` });
          li.createSpan({ cls: "value", text: value });
        }
        if (this.notesEl.value !== session.notes) {
          this.notesEl.value = session.notes;
        }
        this.notesEl.disabled = false;
        if (status === "resolved") {
          this.resolveBtn.disabled = true;
          this.resolveBtn.setText("Encounter resolved");
        } else {
          this.resolveBtn.disabled = false;
          this.resolveBtn.setText("Mark encounter resolved");
        }
      }
      renderParty(state) {
        const { party } = state.xp;
        this.partyListEl.empty();
        if (!party.length) {
          this.partyListEl.createDiv({
            cls: "sm-encounter-empty-row",
            text: "No party members added yet."
          });
        }
        for (const member of party) {
          const itemEl = this.partyListEl.createDiv({ cls: "sm-encounter-party-item" });
          const nameField = createFieldContainer(itemEl);
          const nameLabel = nameField.createEl("label", {
            attr: { for: `party-${member.id}-name` },
            text: "Name"
          });
          nameLabel.addClass("sm-encounter-inline-label");
          const nameInput = nameField.createEl("input", {
            cls: "sm-encounter-input",
            attr: {
              id: `party-${member.id}-name`,
              type: "text",
              value: member.name
            }
          });
          nameInput.addEventListener("change", () => {
            const presenter = this.presenter;
            if (!presenter) return;
            const nextName = nameInput.value.trim();
            presenter.updatePartyMember(member.id, { name: nextName });
          });
          const levelField = createFieldContainer(itemEl);
          const levelLabel = levelField.createEl("label", {
            attr: { for: `party-${member.id}-level` },
            text: "Level"
          });
          levelLabel.addClass("sm-encounter-inline-label");
          const levelInput = levelField.createEl("input", {
            cls: "sm-encounter-input",
            attr: {
              id: `party-${member.id}-level`,
              type: "number",
              min: "1",
              step: "1",
              value: String(member.level)
            }
          });
          const memberErrorEl = itemEl.createDiv({ cls: "sm-encounter-error" });
          levelInput.addEventListener("change", () => {
            const presenter = this.presenter;
            if (!presenter) return;
            const numeric = Number(levelInput.value);
            if (!Number.isFinite(numeric) || numeric < 1) {
              memberErrorEl.setText("Level must be 1 or greater.");
              return;
            }
            memberErrorEl.setText("");
            presenter.updatePartyMember(member.id, { level: Math.floor(numeric) });
          });
          const xpField = createFieldContainer(itemEl);
          const xpLabel = xpField.createEl("label", {
            attr: { for: `party-${member.id}-xp` },
            text: "Current XP"
          });
          xpLabel.addClass("sm-encounter-inline-label");
          const xpInput = xpField.createEl("input", {
            cls: "sm-encounter-input",
            attr: {
              id: `party-${member.id}-xp`,
              type: "number",
              min: "0",
              step: "1",
              value: member.currentXp != null ? String(member.currentXp) : ""
            }
          });
          xpInput.addEventListener("change", () => {
            const presenter = this.presenter;
            if (!presenter) return;
            const raw = xpInput.value.trim();
            if (raw === "") {
              memberErrorEl.setText("");
              presenter.updatePartyMember(member.id, { currentXp: void 0 });
              return;
            }
            const numeric = Number(raw);
            if (!Number.isFinite(numeric) || numeric < 0) {
              memberErrorEl.setText("Current XP must be a non-negative number.");
              return;
            }
            memberErrorEl.setText("");
            presenter.updatePartyMember(member.id, { currentXp: numeric });
          });
          const removeButton = itemEl.createEl("button", {
            cls: "sm-encounter-button sm-encounter-button-danger",
            text: "Remove"
          });
          removeButton.type = "button";
          removeButton.addEventListener("click", () => {
            this.presenter?.removePartyMember(member.id);
          });
        }
      }
      renderRules(state) {
        const rules = state.xp.rules;
        const ruleViews = new Map(state.xpView.rules.map((view) => [view.rule.id, view]));
        this.ruleListEl.empty();
        if (!rules.length) {
          this.ruleListEl.createDiv({
            cls: "sm-encounter-empty-row",
            text: "No rules configured yet."
          });
          return;
        }
        rules.forEach((rule, index) => {
          const ruleItem = this.ruleListEl.createDiv({ cls: "sm-encounter-rule" });
          if (!rule.enabled) {
            ruleItem.addClass("is-disabled");
          }
          const headerRow = ruleItem.createDiv({ cls: "sm-encounter-rule-header" });
          const titleInput = headerRow.createEl("input", {
            cls: "sm-encounter-input sm-encounter-rule-title",
            attr: {
              type: "text",
              value: rule.title
            }
          });
          titleInput.addEventListener("change", () => {
            const presenter = this.presenter;
            if (!presenter) return;
            presenter.updateRule(rule.id, { title: titleInput.value.trim() });
          });
          const toggleWrapper = headerRow.createDiv({ cls: "sm-encounter-rule-toggle" });
          const toggleId = `rule-${rule.id}-enabled`;
          toggleWrapper.createEl("label", {
            cls: "sm-encounter-toggle-label",
            attr: { for: toggleId },
            text: "Enabled"
          });
          const toggleInput = toggleWrapper.createEl("input", {
            attr: {
              id: toggleId,
              type: "checkbox",
              checked: rule.enabled ? "true" : void 0
            }
          });
          toggleInput.checked = rule.enabled;
          toggleInput.addEventListener("change", () => {
            const presenter = this.presenter;
            if (!presenter) return;
            presenter.toggleRule(rule.id, toggleInput.checked);
          });
          const controls = ruleItem.createDiv({ cls: "sm-encounter-rule-controls" });
          const scopeSelect = controls.createEl("select", {
            cls: "sm-encounter-input"
          });
          const scopeOptions = [
            { value: "overall", label: "Entire encounter" },
            { value: "perPlayer", label: "Per character" }
          ];
          for (const option of scopeOptions) {
            scopeSelect.createEl("option", {
              attr: { value: option.value, selected: option.value === rule.scope ? "true" : void 0 },
              text: option.label
            });
          }
          scopeSelect.addEventListener("change", () => {
            const presenter = this.presenter;
            if (!presenter) return;
            presenter.updateRule(rule.id, { scope: scopeSelect.value });
          });
          const typeSelect = controls.createEl("select", {
            cls: "sm-encounter-input"
          });
          const typeOptions = [
            { value: "flat", label: "Flat" },
            { value: "percentTotal", label: "% of total" },
            { value: "percentNextLevel", label: "% to next level" }
          ];
          for (const option of typeOptions) {
            typeSelect.createEl("option", {
              attr: { value: option.value, selected: option.value === rule.modifierType ? "true" : void 0 },
              text: option.label
            });
          }
          typeSelect.addEventListener("change", () => {
            const presenter = this.presenter;
            if (!presenter) return;
            presenter.updateRule(rule.id, { modifierType: typeSelect.value });
          });
          const valueInput = controls.createEl("input", {
            cls: "sm-encounter-input",
            attr: {
              type: "number",
              step: "1",
              value: String(rule.modifierValue)
            }
          });
          valueInput.addEventListener("change", () => {
            const presenter = this.presenter;
            if (!presenter) return;
            const numeric = Number(valueInput.value);
            if (!Number.isFinite(numeric)) {
              valueInput.value = String(rule.modifierValue);
              return;
            }
            presenter.updateRule(rule.id, { modifierValue: numeric });
          });
          const notesInput = controls.createEl("textarea", {
            cls: "sm-encounter-input sm-encounter-rule-notes",
            attr: {
              rows: "2",
              placeholder: "Notes"
            },
            text: rule.notes ?? ""
          });
          notesInput.addEventListener("change", () => {
            const presenter = this.presenter;
            if (!presenter) return;
            const trimmed = notesInput.value.trim();
            presenter.updateRule(rule.id, { notes: trimmed === "" ? "" : trimmed });
          });
          const buttonBar = ruleItem.createDiv({ cls: "sm-encounter-inline-actions" });
          const moveUpBtn = buttonBar.createEl("button", {
            cls: "sm-encounter-button sm-encounter-button-secondary",
            text: "Move up"
          });
          moveUpBtn.type = "button";
          moveUpBtn.disabled = index === 0;
          moveUpBtn.addEventListener("click", () => {
            this.presenter?.moveRule(rule.id, index - 1);
          });
          const moveDownBtn = buttonBar.createEl("button", {
            cls: "sm-encounter-button sm-encounter-button-secondary",
            text: "Move down"
          });
          moveDownBtn.type = "button";
          moveDownBtn.disabled = index === rules.length - 1;
          moveDownBtn.addEventListener("click", () => {
            this.presenter?.moveRule(rule.id, index + 1);
          });
          const deleteBtn = buttonBar.createEl("button", {
            cls: "sm-encounter-button sm-encounter-button-danger",
            text: "Delete"
          });
          deleteBtn.type = "button";
          deleteBtn.addEventListener("click", () => {
            this.presenter?.removeRule(rule.id);
          });
          const ruleView = ruleViews.get(rule.id);
          if (ruleView) {
            const effectEl = ruleItem.createDiv({ cls: "sm-encounter-rule-effect" });
            effectEl.createEl("div", {
              cls: "sm-encounter-rule-total",
              text: `Total delta: ${formatSignedNumber(ruleView.totalDelta)}`
            });
            if (ruleView.perMemberDeltas.length) {
              const perMemberList = effectEl.createEl("ul", { cls: "sm-encounter-rule-deltas" });
              for (const delta of ruleView.perMemberDeltas) {
                perMemberList.createEl("li", {
                  text: `${delta.memberName}: ${formatSignedNumber(delta.delta)}`
                });
              }
            }
            if (ruleView.warnings.length) {
              const warningEl = ruleItem.createDiv({ cls: "sm-encounter-callout" });
              ruleView.warnings.forEach((warning) => {
                warningEl.createEl("p", { text: warning });
              });
            }
          }
        });
      }
      renderResults(state) {
        const { xp, xpView } = state;
        const activeElement = this.xpInputEl.ownerDocument?.activeElement;
        if (activeElement !== this.xpInputEl) {
          this.xpInputEl.value = String(xp.encounterXp ?? 0);
        }
        this.resetXpButton.disabled = xp.party.length === 0 && xp.rules.length === 0 && (xp.encounterXp ?? 0) === 0;
        this.resultTotalsEl.empty();
        const baseSummary = this.resultTotalsEl.createDiv({ cls: "sm-encounter-result-total" });
        baseSummary.createEl("span", { cls: "label", text: "Base XP:" });
        baseSummary.createEl("span", { cls: "value", text: formatNumber(xpView.baseEncounterXp) });
        const totalSummary = this.resultTotalsEl.createDiv({ cls: "sm-encounter-result-total" });
        totalSummary.createEl("span", { cls: "label", text: "Total XP:" });
        totalSummary.createEl("span", { cls: "value", text: formatNumber(xpView.totalEncounterXp) });
        this.resultWarningsEl.empty();
        if (xpView.warnings.length) {
          const warningEl = this.resultWarningsEl.createDiv({ cls: "sm-encounter-callout" });
          xpView.warnings.forEach((warning) => {
            warningEl.createEl("p", { text: warning });
          });
        }
        this.resultPartyEl.empty();
        this.resultPartyEl.createEl("h4", {
          cls: "sm-encounter-subheading",
          text: "Party breakdown"
        });
        if (!xpView.party.length) {
          this.resultPartyEl.createDiv({
            cls: "sm-encounter-empty-row",
            text: "No party members configured."
          });
        } else {
          for (const memberView of xpView.party) {
            const memberEl = this.resultPartyEl.createDiv({ cls: "sm-encounter-result-party-member" });
            const header = memberEl.createDiv({ cls: "sm-encounter-result-party-header" });
            header.createEl("span", {
              cls: "name",
              text: `${memberView.member.name} (Level ${memberView.member.level})`
            });
            const stats = memberEl.createEl("ul", { cls: "sm-encounter-result-stats" });
            createStatItem(stats, "Base", formatNumber(memberView.baseXp));
            createStatItem(stats, "Modifiers", formatSignedNumber(memberView.modifiersDelta));
            createStatItem(stats, "Total", formatNumber(memberView.totalXp));
            createStatItem(
              stats,
              "XP to next level",
              memberView.xpToNextLevel == null ? "\u2014" : formatNumber(memberView.xpToNextLevel)
            );
            if (memberView.warnings.length) {
              const warningEl = memberEl.createDiv({ cls: "sm-encounter-callout" });
              memberView.warnings.forEach((warning) => {
                warningEl.createEl("p", { text: warning });
              });
            }
          }
        }
        this.resultRulesEl.empty();
        this.resultRulesEl.createEl("h4", {
          cls: "sm-encounter-subheading",
          text: "Rule effects"
        });
        if (!xpView.rules.length) {
          this.resultRulesEl.createDiv({
            cls: "sm-encounter-empty-row",
            text: "No rules applied."
          });
        } else {
          for (const ruleView of xpView.rules) {
            const ruleResult = this.resultRulesEl.createDiv({ cls: "sm-encounter-result-rule" });
            const title = ruleResult.createEl("div", {
              cls: "sm-encounter-result-rule-title",
              text: ruleView.rule.title
            });
            if (!ruleView.rule.enabled) {
              title.addClass("is-disabled");
            }
            const deltaSummary = ruleResult.createDiv({ cls: "sm-encounter-result-rule-total" });
            deltaSummary.createEl("span", { cls: "label", text: "Total delta:" });
            deltaSummary.createEl("span", { cls: "value", text: formatSignedNumber(ruleView.totalDelta) });
            if (ruleView.perMemberDeltas.length) {
              const perMemberList = ruleResult.createEl("ul", { cls: "sm-encounter-rule-deltas" });
              ruleView.perMemberDeltas.forEach((delta) => {
                perMemberList.createEl("li", {
                  text: `${delta.memberName}: ${formatSignedNumber(delta.delta)}`
                });
              });
            }
            if (ruleView.warnings.length) {
              const warningEl = ruleResult.createDiv({ cls: "sm-encounter-callout" });
              ruleView.warnings.forEach((warning) => {
                warningEl.createEl("p", { text: warning });
              });
            }
          }
        }
      }
      handleAddPartyMember() {
        const presenter = this.presenter;
        if (!presenter) return;
        const name = this.partyFormNameEl.value.trim();
        const levelValue = Number(this.partyFormLevelEl.value);
        const currentXpRaw = this.partyFormCurrentXpEl.value.trim();
        const errors = [];
        if (!name) {
          errors.push("Name is required.");
        }
        if (!Number.isFinite(levelValue) || levelValue < 1) {
          errors.push("Level must be 1 or greater.");
        }
        let currentXp;
        if (currentXpRaw !== "") {
          const numericCurrent = Number(currentXpRaw);
          if (!Number.isFinite(numericCurrent) || numericCurrent < 0) {
            errors.push("Current XP must be a non-negative number.");
          } else {
            currentXp = numericCurrent;
          }
        }
        if (errors.length) {
          this.partyFormErrorEl.setText(errors.join(" "));
          return;
        }
        const member = {
          id: createId("party"),
          name,
          level: Math.floor(levelValue)
        };
        if (currentXp !== void 0) {
          member.currentXp = currentXp;
        }
        presenter.addPartyMember(member);
        this.partyFormNameEl.value = "";
        this.partyFormLevelEl.value = "1";
        this.partyFormCurrentXpEl.value = "";
        this.partyFormErrorEl.setText("");
        this.partyFormNameEl.focus();
      }
      handleEncounterXpChange() {
        const presenter = this.presenter;
        if (!presenter) return;
        const raw = this.xpInputEl.value.trim();
        if (raw === "") {
          this.xpErrorEl.setText("");
          presenter.setEncounterXp(0);
          return;
        }
        const numeric = Number(raw);
        if (!Number.isFinite(numeric) || numeric < 0) {
          this.xpErrorEl.setText("Encounter XP must be a non-negative number.");
          return;
        }
        this.xpErrorEl.setText("");
        presenter.setEncounterXp(numeric);
      }
      handleAddRule() {
        const presenter = this.presenter;
        if (!presenter) return;
        const title = this.ruleFormTitleEl.value.trim();
        const scope = this.ruleFormScopeEl.value;
        const modifierType = this.ruleFormTypeEl.value;
        const valueRaw = this.ruleFormValueEl.value.trim();
        const notes = this.ruleFormNotesEl.value.trim();
        const enabled = this.ruleFormEnabledEl.checked;
        const numericValue = Number(valueRaw);
        const errors = [];
        if (!title) {
          errors.push("Title is required.");
        }
        if (!Number.isFinite(numericValue)) {
          errors.push("Modifier value must be a number.");
        }
        if (errors.length) {
          this.ruleFormErrorEl.setText(errors.join(" "));
          return;
        }
        const rule = {
          id: createId("rule"),
          title,
          scope,
          modifierType,
          modifierValue: numericValue,
          enabled
        };
        if (notes !== "") {
          rule.notes = notes;
        }
        presenter.addRule(rule);
        this.ruleFormTitleEl.value = "";
        this.ruleFormScopeEl.value = "overall";
        this.ruleFormTypeEl.value = "flat";
        this.ruleFormValueEl.value = "0";
        this.ruleFormNotesEl.value = "";
        this.ruleFormEnabledEl.checked = true;
        this.ruleFormErrorEl.setText("");
        this.ruleFormTitleEl.focus();
      }
    };
    numberFormatter = new Intl.NumberFormat(void 0, {
      maximumFractionDigits: 2,
      minimumFractionDigits: 0
    });
  }
});

// src/apps/cartographer/modes/travel-guide/encounter-gateway.ts
function loadEncounterModule() {
  return Promise.all([
    Promise.resolve().then(() => (init_layout(), layout_exports)),
    Promise.resolve().then(() => (init_view(), view_exports))
  ]).then(([layout, encounter]) => ({
    getRightLeaf: layout.getRightLeaf,
    VIEW_ENCOUNTER: encounter.VIEW_ENCOUNTER
  })).catch((err) => {
    console.error("[travel-mode] failed to load encounter module", err);
    new import_obsidian14.Notice("Encounter-Modul konnte nicht geladen werden.");
    return null;
  });
}
function ensureEncounterModule() {
  if (!encounterModule) {
    encounterModule = loadEncounterModule();
  }
  return encounterModule;
}
function preloadEncounterModule() {
  void ensureEncounterModule();
}
async function openEncounter(app, context) {
  const mod2 = await ensureEncounterModule();
  if (!mod2) return false;
  const issue = describeEncounterContextIssue(context);
  if (issue) {
    console.warn(`[travel-mode] ${issue.log}`, context);
    new import_obsidian14.Notice(issue.message);
  } else if (context) {
    try {
      const event = await createEncounterEventFromTravel(app, context);
      if (event) {
        publishEncounterEvent(event);
      }
    } catch (err) {
      console.error("[travel-mode] failed to publish encounter payload", err);
    }
  }
  const leaf = mod2.getRightLeaf(app);
  await leaf.setViewState({ type: mod2.VIEW_ENCOUNTER, active: true });
  app.workspace.revealLeaf(leaf);
  return true;
}
function describeEncounterContextIssue(context) {
  if (!context) {
    return {
      message: "Begegnung konnte nicht ge\xF6ffnet werden: Es liegen keine Reisedaten vor.",
      log: "missing travel context for encounter"
    };
  }
  if (!context.mapFile) {
    return {
      message: "Begegnung enth\xE4lt keine Kartendatei. \xD6ffne die Karte erneut und versuche es nochmal.",
      log: "missing map file for encounter context"
    };
  }
  if (!context.state) {
    return {
      message: "Begegnung enth\xE4lt keinen Reisezustand. Aktualisiere den Travel-Guide und versuche es erneut.",
      log: "missing travel state snapshot for encounter context"
    };
  }
  return null;
}
async function publishManualEncounter(app, context, options = {}) {
  try {
    const event = await createEncounterEventFromTravel(app, context, {
      source: "manual",
      idPrefix: options.idPrefix ?? "manual",
      coordOverride: options.coordOverride,
      triggeredAt: options.triggeredAt
    });
    if (event) {
      publishEncounterEvent(event);
    }
  } catch (err) {
    console.error("[travel-mode] failed to publish manual encounter", err);
  }
}
var import_obsidian14, encounterModule;
var init_encounter_gateway = __esm({
  "src/apps/cartographer/modes/travel-guide/encounter-gateway.ts"() {
    "use strict";
    import_obsidian14 = require("obsidian");
    init_session_store();
    init_event_builder();
    encounterModule = null;
  }
});

// src/apps/cartographer/travel/infra/encounter-sync.ts
function createEncounterSync(cfg) {
  let disposed = false;
  let lastHandledId = peekLatestEncounterEvent()?.id ?? null;
  const unsubscribe = subscribeToEncounterEvents((event) => {
    if (disposed) return;
    if (event.id === lastHandledId) return;
    lastHandledId = event.id;
    if (event.source === "travel") {
      return;
    }
    cfg.pausePlayback();
    const shouldOpen = cfg.onExternalEncounter?.(event);
    if (shouldOpen === false) {
      return;
    }
    void cfg.openEncounter();
  });
  return {
    async handleTravelEncounter() {
      cfg.pausePlayback();
      const context = {
        mapFile: cfg.getMapFile(),
        state: cfg.getState()
      };
      const ok = await cfg.openEncounter(context);
      if (!ok) return;
      const latest = peekLatestEncounterEvent();
      if (latest) {
        lastHandledId = latest.id;
      }
    },
    dispose() {
      if (disposed) return;
      disposed = true;
      unsubscribe();
    }
  };
}
var init_encounter_sync = __esm({
  "src/apps/cartographer/travel/infra/encounter-sync.ts"() {
    "use strict";
    init_session_store();
  }
});

// src/apps/cartographer/modes/travel-guide.ts
var travel_guide_exports = {};
__export(travel_guide_exports, {
  createTravelGuideMode: () => createTravelGuideMode
});
function createTravelGuideMode() {
  let sidebar = null;
  const playback = new TravelPlaybackController();
  let activeTravelId = null;
  let panelUnsubscribe = null;
  let logic = null;
  const interactions = new TravelInteractionController();
  let routeLayer = null;
  let tokenLayer = null;
  let cleanupFile = null;
  let hostEl = null;
  let terrainEvent = null;
  let lifecycleSignal = null;
  let encounterSync = null;
  let bridgeTravelId = null;
  const runBridge = (label, fn) => {
    const bridge = getCartographerBridge();
    if (!bridge) {
      console.warn(`[cartographer:travel] skipped ${label} \u2013 no Almanac bridge available`);
      return;
    }
    void Promise.resolve(fn(bridge)).catch((error) => {
      console.error(`[cartographer:travel] ${label} failed`, error);
    });
  };
  const isAborted = () => lifecycleSignal?.aborted ?? false;
  const bailIfAborted = async () => {
    if (!isAborted()) {
      return false;
    }
    await abortLifecycle();
    return true;
  };
  const handleStateChange = (state) => {
    if (routeLayer) {
      routeLayer.draw(state.route, state.editIdx ?? null, state.tokenRC ?? null);
    }
    sidebar?.setTile(state.currentTile ?? state.tokenRC ?? null);
    sidebar?.setSpeed(state.tokenSpeed);
    playback.sync(state);
  };
  const resetUi = () => {
    sidebar?.setTile(null);
    sidebar?.setSpeed(1);
    sidebar?.setTravelPanel(null);
    playback.reset();
  };
  const detachPanelSubscription = () => {
    if (!panelUnsubscribe) return;
    try {
      panelUnsubscribe();
    } finally {
      panelUnsubscribe = null;
    }
  };
  const pushPanelSnapshot = (panel) => {
    if (sidebar) {
      sidebar.setTravelPanel(panel);
    }
  };
  const updatePanelSnapshotFromGateway = (travelId) => {
    pushPanelSnapshot(cartographerHookGateway.getPanelSnapshot(travelId));
  };
  const updateTravelContext = (file) => {
    const nextId = file ? file.path : null;
    if (activeTravelId === nextId) {
      updatePanelSnapshotFromGateway(nextId);
      return;
    }
    if (activeTravelId) {
      cartographerHookGateway.emitTravelEnd(activeTravelId);
    }
    if (bridgeTravelId) {
      runBridge("travel unmount", (bridge) => bridge.unmount());
      bridgeTravelId = null;
    }
    detachPanelSubscription();
    activeTravelId = nextId;
    if (activeTravelId) {
      cartographerHookGateway.emitTravelStart(activeTravelId);
      panelUnsubscribe = cartographerHookGateway.onPanelUpdate(activeTravelId, (panel) => {
        if (!isAborted()) {
          pushPanelSnapshot(panel);
        }
      });
      updatePanelSnapshotFromGateway(activeTravelId);
      const travelIdToMount = activeTravelId;
      runBridge("travel mount", (bridge) => bridge.mount(travelIdToMount));
      bridgeTravelId = travelIdToMount;
    } else {
      pushPanelSnapshot(null);
      runBridge("travel unmount", (bridge) => bridge.unmount());
    }
  };
  const runCleanupFile = async () => {
    if (!cleanupFile) return;
    const fn = cleanupFile;
    cleanupFile = null;
    try {
      await fn();
    } catch (err) {
      console.error("[travel-mode] cleanupFile failed", err);
    }
  };
  const detachSidebar = () => {
    sidebar?.destroy();
    sidebar = null;
  };
  const releaseTerrainEvent = () => {
    terrainEvent?.off();
    terrainEvent = null;
  };
  const removeTravelClass = () => {
    hostEl?.classList?.remove?.("sm-cartographer--travel");
    hostEl = null;
  };
  const abortLifecycle = async () => {
    await runCleanupFile();
    disposeFile();
    resetUi();
    playback.dispose();
    detachSidebar();
    releaseTerrainEvent();
    removeTravelClass();
  };
  const disposeFile = () => {
    updateTravelContext(null);
    interactions.dispose();
    encounterSync?.dispose();
    encounterSync = null;
    if (tokenLayer) {
      tokenLayer.destroy?.();
      tokenLayer = null;
    }
    if (routeLayer) {
      routeLayer.destroy();
      routeLayer = null;
    }
    if (logic) {
      try {
        logic.pause();
      } catch (err) {
        console.error("[travel-mode] pause failed", err);
      }
      logic = null;
    }
  };
  const ensureTerrains = async (ctx) => {
    if (ctx.signal.aborted) return;
    await setTerrains(await loadTerrains(ctx.app));
  };
  const subscribeToTerrains = (ctx) => {
    if (ctx.signal.aborted) {
      return null;
    }
    const workspace = ctx.app.workspace;
    const ref = workspace.on?.("salt:terrains-updated", () => {
      void ensureTerrains(ctx);
    });
    if (!ref) {
      return null;
    }
    return {
      off: () => {
        workspace.offref?.(ref);
      }
    };
  };
  return {
    id: "travel",
    label: "Travel",
    async onEnter(ctx) {
      lifecycleSignal = ctx.signal;
      if (await bailIfAborted()) {
        return;
      }
      hostEl = ctx.host;
      hostEl.classList.add("sm-cartographer--travel");
      await ensureTerrains(ctx);
      if (await bailIfAborted()) {
        return;
      }
      terrainEvent = subscribeToTerrains(ctx);
      if (await bailIfAborted()) {
        return;
      }
      preloadEncounterModule();
      if (await bailIfAborted()) {
        return;
      }
      ctx.sidebarHost.empty();
      if (await bailIfAborted()) {
        return;
      }
      sidebar = createSidebar(ctx.sidebarHost);
      if (await bailIfAborted()) {
        return;
      }
      sidebar.setTitle?.(ctx.getFile()?.basename ?? "");
      sidebar.setTravelHandlers({
        onAdvance: (payload) => runBridge("travel advance", (bridge) => bridge.handlers.onAdvance(payload)),
        onModeChange: (mode) => runBridge("travel mode change", (bridge) => bridge.handlers.onModeChange(mode)),
        onJump: () => runBridge("time jump", (bridge) => bridge.handlers.onJump()),
        onClose: () => runBridge("travel close", (bridge) => bridge.handlers.onClose()),
        onFollowUp: (eventId) => runBridge("event follow-up", (bridge) => bridge.handlers.onFollowUp(eventId))
      });
      sidebar.onSpeedChange((value) => {
        if (!isAborted()) {
          logic?.setTokenSpeed(value);
        }
      });
      playback.mount(sidebar, {
        play: () => isAborted() ? void 0 : logic?.play() ?? void 0,
        pause: () => isAborted() ? void 0 : logic?.pause(),
        reset: () => isAborted() ? void 0 : logic?.reset(),
        setTempo: (value) => isAborted() ? void 0 : logic?.setTempo?.(value)
      });
      if (await bailIfAborted()) {
        return;
      }
      resetUi();
    },
    async onExit(ctx) {
      lifecycleSignal = ctx.signal;
      await abortLifecycle();
      lifecycleSignal = null;
    },
    async onFileChange(file, handles, ctx) {
      lifecycleSignal = ctx.signal;
      await runCleanupFile();
      disposeFile();
      sidebar?.setTitle?.(file?.basename ?? "");
      resetUi();
      if (await bailIfAborted()) {
        return;
      }
      if (!file || !handles) {
        return;
      }
      const mapLayer = ctx.getMapLayer();
      if (!mapLayer) {
        return;
      }
      updateTravelContext(file);
      routeLayer = createRouteLayer(handles.contentG, (rc) => mapLayer.centerOf(rc));
      tokenLayer = createTokenLayer(handles.contentG);
      const adapter = {
        ensurePolys: (coords) => mapLayer.ensurePolys(coords),
        centerOf: (rc) => mapLayer.centerOf(rc),
        draw: (route, tokenRC) => {
          if (routeLayer) routeLayer.draw(route, null, tokenRC);
        },
        token: tokenLayer
      };
      if (await bailIfAborted()) {
        return;
      }
      const activeLogic = createTravelLogic({
        app: ctx.app,
        minSecondsPerTile: 0.05,
        getMapFile: () => ctx.getFile(),
        adapter,
        onChange: (state) => handleStateChange(state),
        onEncounter: async () => {
          if (isAborted()) {
            return;
          }
          if (encounterSync) {
            await encounterSync.handleTravelEncounter();
          }
        }
      });
      logic = activeLogic;
      encounterSync = createEncounterSync({
        getMapFile: () => ctx.getFile?.() ?? null,
        getState: () => activeLogic.getState(),
        pausePlayback: () => {
          try {
            activeLogic.pause();
          } catch (err) {
            console.error("[travel-mode] pause during encounter sync failed", err);
          }
        },
        openEncounter: (context) => openEncounter(ctx.app, context),
        onExternalEncounter: () => !isAborted()
      });
      const triggerManualEncounterAt = async (idx) => {
        if (!encounterSync || isAborted()) {
          return;
        }
        const state = activeLogic.getState();
        const node = state.route[idx];
        if (!node) {
          return;
        }
        await publishManualEncounter(
          ctx.app,
          {
            mapFile: ctx.getFile?.() ?? null,
            state
          },
          {
            coordOverride: { r: node.r, c: node.c }
          }
        );
      };
      handleStateChange(activeLogic.getState());
      await activeLogic.initTokenFromTiles();
      if (isAborted() || logic !== activeLogic) {
        await runCleanupFile();
        disposeFile();
        return;
      }
      interactions.bind(
        {
          routeLayerEl: routeLayer.el,
          tokenLayerEl: tokenLayer.el,
          token: tokenLayer,
          adapter,
          polyToCoord: mapLayer.polyToCoord
        },
        {
          getState: () => activeLogic.getState(),
          selectDot: (idx) => activeLogic.selectDot(idx),
          moveSelectedTo: (rc) => activeLogic.moveSelectedTo(rc),
          moveTokenTo: (rc) => activeLogic.moveTokenTo(rc),
          deleteUserAt: (idx) => activeLogic.deleteUserAt(idx),
          triggerEncounterAt: (idx) => triggerManualEncounterAt(idx)
        }
      );
      cleanupFile = async () => {
        interactions.dispose();
        encounterSync?.dispose();
        encounterSync = null;
        if (logic === activeLogic) {
          logic = null;
        }
        try {
          activeLogic.pause();
        } catch (err) {
          console.error("[travel-mode] pause during cleanup failed", err);
        }
        tokenLayer?.destroy?.();
        tokenLayer = null;
        routeLayer?.destroy();
        routeLayer = null;
      };
      if (await bailIfAborted()) {
        return;
      }
    },
    async onHexClick(coord, event, ctx) {
      lifecycleSignal = ctx.signal;
      if (await bailIfAborted()) {
        return;
      }
      if (interactions.consumeClickSuppression()) {
        if (event.cancelable) event.preventDefault();
        event.stopPropagation();
        return;
      }
      const handles = ctx?.getRenderHandles?.();
      if (handles && !handles.polyByCoord?.has?.(`${coord.r},${coord.c}`)) {
        return;
      }
      if (!logic) return;
      if (event.cancelable) event.preventDefault();
      event.stopPropagation();
      logic.handleHexClick(coord);
    },
    async onSave(_mode, file, ctx) {
      lifecycleSignal = ctx.signal;
      if (await bailIfAborted()) {
        return false;
      }
      if (!logic || !file) return false;
      try {
        await logic.persistTokenToTiles();
      } catch (err) {
        console.error("[travel-mode] persistTokenToTiles failed", err);
      }
      return false;
    }
  };
}
var init_travel_guide = __esm({
  "src/apps/cartographer/modes/travel-guide.ts"() {
    "use strict";
    init_terrain_store();
    init_terrain();
    init_sidebar();
    init_route_layer();
    init_token_layer();
    init_actions();
    init_cartographer_gateway();
    init_cartographer_bridge();
    init_playback_controller();
    init_interaction_controller();
    init_encounter_gateway();
    init_encounter_sync();
  }
});

// src/apps/cartographer/editor/editor-telemetry.ts
function reportEditorToolIssue(payload) {
  const { stage, error } = payload;
  const toolId = payload.toolId ?? "unknown";
  const logPrefix = `[cartographer:editor] tool(${toolId}) stage(${stage}) failed`;
  console.error(logPrefix, error);
  const messageFactory = TOOL_STAGE_MESSAGES[stage];
  const userMessage = messageFactory(toolId);
  const dedupeKey = `${stage}:${toolId}`;
  if (!noticedIssues.has(dedupeKey)) {
    noticedIssues.add(dedupeKey);
    new import_obsidian15.Notice(userMessage);
  }
  return userMessage;
}
var import_obsidian15, noticedIssues, TOOL_STAGE_MESSAGES;
var init_editor_telemetry = __esm({
  "src/apps/cartographer/editor/editor-telemetry.ts"() {
    "use strict";
    import_obsidian15 = require("obsidian");
    noticedIssues = /* @__PURE__ */ new Set();
    TOOL_STAGE_MESSAGES = {
      resolve: () => "No editor tools are available right now. Please ensure at least one tool module loads correctly.",
      "mount-panel": (toolId) => `Failed to mount the panel for "${toolId}". Please check the developer console.`,
      activate: (toolId) => `The tool "${toolId}" could not be activated. Please check the developer console.`,
      render: (toolId) => `The tool "${toolId}" failed to react to the rendered map. Please check the developer console.`,
      deactivate: (toolId) => `The tool "${toolId}" could not be deactivated cleanly. Please check the developer console.`,
      cleanup: (toolId) => `The tool "${toolId}" failed to clean up its panel. Please check the developer console.`,
      operation: (toolId) => `Applying changes with "${toolId}" failed. Please check the developer console.`
    };
  }
});

// src/apps/cartographer/editor/tools/brush-circle.ts
function attachBrushCircle(handles, opts) {
  const { svg, contentG, overlay } = handles;
  const R = opts.hexRadiusPx;
  const vStep = 1.5 * R;
  const toPx = (d) => R + Math.max(0, d) * vStep;
  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle.setAttribute("cx", "0");
  circle.setAttribute("cy", "0");
  circle.setAttribute("r", String(toPx(opts.initialRadius)));
  circle.setAttribute("fill", "none");
  circle.setAttribute("stroke", "var(--interactive-accent)");
  circle.setAttribute("stroke-width", "2");
  circle.setAttribute("pointer-events", "none");
  circle.style.opacity = "0.6";
  contentG.appendChild(circle);
  const svgPt = svg.createSVGPoint();
  let lastEvt = null;
  let raf = 0;
  function toContent() {
    const m = contentG.getScreenCTM();
    if (!m) return null;
    return svgPt.matrixTransform(m.inverse());
  }
  function bringToFront() {
    contentG.appendChild(circle);
  }
  function tick() {
    raf = 0;
    if (!lastEvt) return;
    svgPt.x = lastEvt.clientX;
    svgPt.y = lastEvt.clientY;
    const pt = toContent();
    if (!pt) return;
    circle.setAttribute("cx", String(pt.x));
    circle.setAttribute("cy", String(pt.y));
    bringToFront();
  }
  function onPointerMove(ev) {
    lastEvt = ev;
    if (!raf) raf = requestAnimationFrame(tick);
  }
  function onPointerEnter() {
    circle.style.opacity = "0.6";
  }
  function onPointerLeave() {
    circle.style.opacity = "0";
  }
  svg.addEventListener("pointermove", onPointerMove, { passive: true });
  svg.addEventListener("pointerenter", onPointerEnter, { passive: true });
  svg.addEventListener("pointerleave", onPointerLeave, { passive: true });
  function updateRadius(hexDist) {
    circle.setAttribute("r", String(toPx(hexDist)));
    bringToFront();
  }
  function show() {
    circle.style.display = "";
    circle.style.opacity = "0.6";
    bringToFront();
  }
  function hide() {
    circle.style.opacity = "0";
  }
  function destroy() {
    svg.removeEventListener("pointermove", onPointerMove);
    svg.removeEventListener("pointerenter", onPointerEnter);
    svg.removeEventListener("pointerleave", onPointerLeave);
    if (raf) cancelAnimationFrame(raf);
    circle.remove();
  }
  return { updateRadius, show, hide, destroy };
}
var init_brush_circle = __esm({
  "src/apps/cartographer/editor/tools/brush-circle.ts"() {
    "use strict";
  }
});

// src/apps/cartographer/editor/tools/terrain-brush/brush-core.ts
async function applyBrush(app, mapFile, center, opts, handles, context) {
  const mode = opts.mode ?? "paint";
  const radius = Math.max(0, opts.radius | 0);
  const targets = /* @__PURE__ */ new Map();
  for (const coord of coordsInRadius(center, radius)) {
    targets.set(`${coord.r},${coord.c}`, coord);
  }
  const applied = [];
  const tool = context?.tool ?? null;
  const toolName = context?.toolName ?? "brush";
  const abortSignal = tool?.getAbortSignal?.() ?? null;
  const throwIfAborted = () => {
    if (!abortSignal) return;
    if (abortSignal.aborted) {
      throw createAbortError();
    }
  };
  const getFillSnapshot = (coord) => {
    const key = `${coord.r},${coord.c}`;
    const poly = handles.polyByCoord.get(key);
    if (!poly) return "transparent";
    const styleFill = poly.style?.fill;
    const attrFill = poly.getAttribute("fill");
    const value = styleFill ?? attrFill;
    return value && value.trim().length > 0 ? value : "transparent";
  };
  try {
    throwIfAborted();
    for (const coord of targets.values()) {
      throwIfAborted();
      const key = `${coord.r},${coord.c}`;
      const previousFill = getFillSnapshot(coord);
      const previousData = await loadTile(app, mapFile, coord).catch((error) => {
        console.error(`[terrain-brush] failed to load tile ${key} before applying brush`, error);
        return null;
      });
      throwIfAborted();
      if (mode === "erase") {
        await deleteTile(app, mapFile, coord);
        handles.setFill(coord, "transparent");
        applied.push({
          coord,
          rollback: async () => {
            if (!previousData) return;
            await saveTile(app, mapFile, coord, previousData);
          },
          restoreFill: () => {
            handles.setFill(coord, previousFill);
          }
        });
        continue;
      }
      const terrain = opts.terrain ?? "";
      const region = opts.region ?? "";
      await saveTile(app, mapFile, coord, { terrain, region });
      const color = TERRAIN_COLORS[terrain] ?? "transparent";
      handles.setFill(coord, color);
      applied.push({
        coord,
        rollback: async () => {
          if (!previousData) {
            await deleteTile(app, mapFile, coord);
            return;
          }
          await saveTile(app, mapFile, coord, previousData);
        },
        restoreFill: () => {
          handles.setFill(coord, previousFill);
        }
      });
      throwIfAborted();
    }
  } catch (error) {
    const aborted = isAbortError(error);
    if (!aborted) {
      console.error("[terrain-brush] applyBrush failed", error);
    }
    for (const step of applied.reverse()) {
      try {
        step.restoreFill();
      } catch (restoreErr) {
        console.error("[terrain-brush] failed to restore hex fill", restoreErr);
      }
      try {
        await step.rollback();
      } catch (rollbackErr) {
        console.error("[terrain-brush] failed to rollback tile changes", rollbackErr);
      }
    }
    if (!aborted) {
      const message = reportEditorToolIssue({
        stage: "operation",
        toolId: toolName ?? "brush",
        error
      });
      if (typeof error === "object" && error) {
        error.__smToolMessage = message;
      }
      try {
        tool?.setStatus?.(message);
      } catch (statusErr) {
        console.error("[terrain-brush] failed to publish tool status", statusErr);
      }
      throw error;
    }
  }
}
var oddRToAxial, axialDistance, hexDistanceOddR, coordsInRadius, ABORT_ERROR_NAME, createAbortError, isAbortError;
var init_brush_core = __esm({
  "src/apps/cartographer/editor/tools/terrain-brush/brush-core.ts"() {
    "use strict";
    init_hex_notes();
    init_terrain();
    init_editor_telemetry();
    oddRToAxial = (rc) => {
      const q = rc.c - (rc.r - (rc.r & 1) >> 1);
      return { q, r: rc.r };
    };
    axialDistance = (a, b) => {
      const dq = Math.abs(a.q - b.q);
      const dr = Math.abs(a.r - b.r);
      const ds = Math.abs(-a.q - a.r - (-b.q - b.r));
      return Math.max(dq, dr, ds);
    };
    hexDistanceOddR = (a, b) => {
      return axialDistance(oddRToAxial(a), oddRToAxial(b));
    };
    coordsInRadius = (center, radius) => {
      const out = [];
      for (let dr = -radius; dr <= radius; dr++) {
        for (let dc = -radius; dc <= radius; dc++) {
          const r = center.r + dr;
          const c = center.c + dc + (center.r & 1 ? Math.floor((dr + 1) / 2) : Math.floor(dr / 2));
          if (hexDistanceOddR(center, { r, c }) <= radius) {
            out.push({ r, c });
          }
        }
      }
      out.sort((A, B) => {
        const da = hexDistanceOddR(center, A);
        const db = hexDistanceOddR(center, B);
        if (da !== db) return da - db;
        if (A.r !== B.r) return A.r - B.r;
        return A.c - B.c;
      });
      return out;
    };
    ABORT_ERROR_NAME = "AbortError";
    createAbortError = () => {
      if (typeof DOMException === "function") {
        return new DOMException("Terrain brush application aborted", ABORT_ERROR_NAME);
      }
      const error = new Error("Terrain brush application aborted");
      error.name = ABORT_ERROR_NAME;
      return error;
    };
    isAbortError = (error) => {
      if (!error) return false;
      if (typeof DOMException === "function" && error instanceof DOMException) {
        return error.name === ABORT_ERROR_NAME;
      }
      return error instanceof Error && error.name === ABORT_ERROR_NAME;
    };
  }
});

// src/ui/form-builder.ts
function buildForm(root, config) {
  const controls = /* @__PURE__ */ new Map();
  const elements = /* @__PURE__ */ new Map();
  const containers = /* @__PURE__ */ new Map();
  const hints = /* @__PURE__ */ new Map();
  const statuses = /* @__PURE__ */ new Map();
  const cleanup = [];
  const createRow = (section) => {
    const row = createElement("div");
    applyClasses(row, section.rowCls ?? "sm-row");
    const label = createElement("label");
    label.textContent = section.label;
    applyClasses(label, section.labelCls);
    row.appendChild(label);
    section.controls.forEach((control, index) => {
      if (control.kind === "select") {
        const select = createElement("select", control.cls);
        applyAttributes(select, control.attr);
        if (control.options) {
          for (const option of control.options) {
            const opt = document.createElement("option");
            opt.text = option.label;
            opt.value = option.value;
            if (option.data) {
              for (const [key, value] of Object.entries(option.data)) {
                opt.dataset[key] = value;
              }
            }
            select.appendChild(opt);
          }
        }
        if (typeof control.value === "string") {
          select.value = control.value;
        }
        select.disabled = Boolean(control.disabled);
        select.id = control.id;
        const handler = (event) => {
          control.onChange?.({ value: select.value, element: select, event });
        };
        select.addEventListener("change", handler);
        cleanup.push(() => select.removeEventListener("change", handler));
        row.appendChild(select);
        control.enhance?.(select);
        const handle = {
          kind: "select",
          element: select,
          setOptions(options) {
            select.innerHTML = "";
            for (const option of options) {
              const opt = document.createElement("option");
              opt.text = option.label;
              opt.value = option.value;
              if (option.data) {
                for (const [key, value] of Object.entries(option.data)) {
                  opt.dataset[key] = value;
                }
              }
              select.appendChild(opt);
            }
          },
          setValue(value) {
            select.value = value;
          },
          getValue() {
            return select.value;
          },
          setDisabled(disabled) {
            select.disabled = disabled;
          }
        };
        controls.set(control.id, handle);
        if (index === 0) {
          label.htmlFor = control.id;
        }
      } else if (control.kind === "slider") {
        const input = createElement("input", control.cls);
        applyAttributes(input, control.attr);
        input.type = "range";
        input.min = String(control.min);
        input.max = String(control.max);
        input.step = String(control.step ?? 1);
        input.value = String(control.value);
        input.disabled = Boolean(control.disabled);
        input.id = control.id;
        const valueFormatter = control.valueFormatter ?? ((value) => String(value));
        let valueEl = null;
        const showValue = control.showValue !== false;
        if (showValue) {
          valueEl = createElement("span");
          valueEl.textContent = valueFormatter(Number(input.value));
        }
        const handleInput = (event) => {
          const value = Number(input.value);
          if (valueEl) valueEl.textContent = valueFormatter(value);
          control.onInput?.({ value, element: input, event });
        };
        const handleChange = (event) => {
          const value = Number(input.value);
          if (valueEl) valueEl.textContent = valueFormatter(value);
          control.onChange?.({ value, element: input, event });
        };
        input.addEventListener("input", handleInput);
        input.addEventListener("change", handleChange);
        cleanup.push(() => {
          input.removeEventListener("input", handleInput);
          input.removeEventListener("change", handleChange);
        });
        row.appendChild(input);
        if (valueEl) row.appendChild(valueEl);
        const handle = {
          kind: "slider",
          element: input,
          valueElement: valueEl,
          setValue(value) {
            input.value = String(value);
            if (valueEl) valueEl.textContent = valueFormatter(value);
          },
          getValue() {
            return Number(input.value);
          },
          setDisabled(disabled) {
            input.disabled = disabled;
          }
        };
        controls.set(control.id, handle);
        if (index === 0) {
          label.htmlFor = control.id;
        }
      } else if (control.kind === "textarea") {
        const textarea = createElement("textarea", control.cls);
        applyAttributes(textarea, control.attr);
        textarea.value = control.value ?? "";
        textarea.disabled = Boolean(control.disabled);
        if (control.rows) textarea.rows = control.rows;
        if (control.placeholder) textarea.placeholder = control.placeholder;
        textarea.id = control.id;
        const handleInput = (event) => {
          control.onInput?.({ value: textarea.value, element: textarea, event });
        };
        textarea.addEventListener("input", handleInput);
        cleanup.push(() => textarea.removeEventListener("input", handleInput));
        row.appendChild(textarea);
        const handle = {
          kind: "textarea",
          element: textarea,
          setValue(value) {
            textarea.value = value;
          },
          getValue() {
            return textarea.value;
          },
          setDisabled(disabled) {
            textarea.disabled = disabled;
          }
        };
        controls.set(control.id, handle);
        if (index === 0) {
          label.htmlFor = control.id;
        }
      } else if (control.kind === "button") {
        const button = createElement("button", control.cls);
        applyAttributes(button, control.attr);
        button.type = "button";
        button.textContent = control.label;
        button.disabled = Boolean(control.disabled);
        button.id = control.id;
        const handler = (event) => {
          control.onClick?.({ element: button, event });
        };
        button.addEventListener("click", handler);
        cleanup.push(() => button.removeEventListener("click", handler));
        row.appendChild(button);
        const handle = {
          kind: "button",
          element: button,
          setDisabled(disabled) {
            button.disabled = disabled;
          }
        };
        controls.set(control.id, handle);
      }
    });
    root.appendChild(row);
  };
  const createHint = (section) => {
    const hint = createElement("p", section.cls ?? "sm-inline-hint");
    const handle = {
      element: hint,
      set(details) {
        if (!details || !details.text) {
          hint.style.display = "none";
          hint.textContent = "";
          hint.removeAttribute("data-tone");
          return;
        }
        hint.style.display = "";
        hint.textContent = details.text;
        if (details.tone) {
          hint.setAttribute("data-tone", details.tone);
        } else {
          hint.removeAttribute("data-tone");
        }
      }
    };
    if (section.hidden !== false) {
      hint.style.display = "none";
    }
    if (section.tone) {
      hint.setAttribute("data-tone", section.tone);
    }
    root.appendChild(hint);
    hints.set(section.id, handle);
  };
  const createStatus = (section) => {
    const status = createElement("div", section.cls);
    const handle = {
      element: status,
      set(details) {
        const message = details?.message ?? "";
        status.textContent = message;
        status.classList.toggle("is-empty", !message);
        status.classList.toggle("is-loading", details?.tone === "loading");
        status.classList.toggle("is-error", details?.tone === "error");
      }
    };
    status.classList.add("is-empty");
    root.appendChild(status);
    statuses.set(section.id, handle);
  };
  for (const section of config.sections) {
    switch (section.kind) {
      case "header": {
        const level = section.level ?? 3;
        const header = createElement(`h${level}`, section.cls);
        header.textContent = section.text;
        root.appendChild(header);
        break;
      }
      case "row": {
        createRow(section);
        break;
      }
      case "static": {
        const tag = section.tag ?? "div";
        const el = createElement(tag, section.cls);
        if (section.text) el.textContent = section.text;
        root.appendChild(el);
        elements.set(section.id, el);
        break;
      }
      case "hint": {
        createHint(section);
        break;
      }
      case "status": {
        createStatus(section);
        break;
      }
      case "container": {
        const tag = section.tag ?? "div";
        const el = createElement(tag, section.cls);
        root.appendChild(el);
        containers.set(section.id, el);
        break;
      }
    }
  }
  return {
    root,
    getControl(id) {
      return controls.get(id) ?? null;
    },
    getElement(id) {
      return elements.get(id) ?? null;
    },
    getContainer(id) {
      return containers.get(id) ?? null;
    },
    getHint(id) {
      return hints.get(id) ?? null;
    },
    getStatus(id) {
      return statuses.get(id) ?? null;
    },
    destroy() {
      cleanup.forEach((fn) => {
        try {
          fn();
        } catch (err) {
          console.error("[form-builder] cleanup failed", err);
        }
      });
      cleanup.length = 0;
    }
  };
}
var applyClasses, createElement, applyAttributes;
var init_form_builder = __esm({
  "src/ui/form-builder.ts"() {
    "use strict";
    applyClasses = (el, cls) => {
      if (!cls) return;
      const values = Array.isArray(cls) ? cls : cls.split(/\s+/).filter(Boolean);
      for (const value of values) {
        el.classList.add(value);
      }
    };
    createElement = (tag, cls) => {
      const el = document.createElement(tag);
      applyClasses(el, cls);
      return el;
    };
    applyAttributes = (el, attr) => {
      if (!attr) return;
      for (const [key, value] of Object.entries(attr)) {
        el.setAttribute(key, value);
      }
    };
  }
});

// src/apps/cartographer/editor/tools/terrain-brush/brush-options.ts
function mountBrushPanel(root, ctx) {
  const state = {
    radius: 1,
    region: "",
    terrain: "",
    mode: "paint"
  };
  const effectiveRadius = () => Math.max(0, state.radius - 1);
  let disposed = false;
  let fillSeq = 0;
  let circle = null;
  let panelDisabled = false;
  let manageCommandAvailable = false;
  let radiusControl = null;
  let regionControl = null;
  let modeControl = null;
  let manageButton = null;
  let inlineHint = null;
  let manageHint = null;
  const setPanelDisabled = (disabled) => {
    panelDisabled = disabled;
    if (disabled) {
      root.classList.add("is-disabled");
    } else {
      root.classList.remove("is-disabled");
    }
    radiusControl?.setDisabled(disabled);
    regionControl?.setDisabled(disabled);
    modeControl?.setDisabled(disabled);
    manageButton?.setDisabled(disabled || !manageCommandAvailable);
  };
  const updateStatus = (message) => {
    try {
      ctx.setStatus(message);
    } catch (err) {
      console.error("[terrain-brush] failed to set status", err);
    }
  };
  const form = buildForm(root, {
    sections: [
      { kind: "header", text: "Region Brush" },
      { kind: "hint", id: "inline", cls: "sm-inline-hint", hidden: true },
      {
        kind: "row",
        label: "Radius:",
        controls: [
          {
            kind: "slider",
            id: "radius",
            min: 1,
            max: 6,
            step: 1,
            value: state.radius,
            valueFormatter: (value) => String(value),
            onInput: ({ value }) => {
              state.radius = value;
              circle?.updateRadius(effectiveRadius());
            }
          }
        ]
      },
      {
        kind: "row",
        label: "Region:",
        controls: [
          {
            kind: "select",
            id: "region",
            options: [],
            enhance: (select) => enhanceSelectToSearch(select, "Search dropdown\u2026"),
            onChange: ({ element }) => {
              state.region = element.value;
              const opt = element.selectedOptions[0];
              state.terrain = opt?.dataset?.terrain ?? "";
            }
          },
          {
            kind: "button",
            id: "manage",
            label: "Manage\u2026"
          }
        ]
      },
      { kind: "hint", id: "manageHint", cls: "sm-inline-hint", hidden: true },
      {
        kind: "row",
        label: "Mode:",
        controls: [
          {
            kind: "select",
            id: "mode",
            value: state.mode,
            options: [
              { label: "Paint", value: "paint" },
              { label: "Erase", value: "erase" }
            ],
            enhance: (select) => enhanceSelectToSearch(select, "Search dropdown\u2026"),
            onChange: ({ element }) => {
              state.mode = element.value;
            }
          }
        ]
      }
    ]
  });
  radiusControl = form.getControl("radius");
  regionControl = form.getControl("region");
  modeControl = form.getControl("mode");
  manageButton = form.getControl("manage");
  inlineHint = form.getHint("inline");
  manageHint = form.getHint("manageHint");
  const applyInlineHint = (details) => {
    inlineHint?.set(details ? { text: details.text, tone: details.tone } : null);
  };
  const applyManageHint = (details) => {
    manageHint?.set(details ? { text: details.text, tone: details.tone } : null);
  };
  const handleManageClick = () => {
    if (!manageCommandAvailable) {
      updateStatus("The Library command is unavailable. Follow the manual steps below to add regions.");
      return;
    }
    try {
      const result = ctx.app.commands?.executeCommandById?.(MANAGE_REGIONS_COMMAND_ID);
      if (result instanceof Promise) {
        result.catch((err) => handleManageError(err));
        updateStatus("Opening the Library to manage regions\u2026");
      } else if (result === false) {
        handleManageError();
      } else {
        updateStatus("Opening the Library to manage regions\u2026");
      }
    } catch (err) {
      handleManageError(err);
    }
  };
  const refreshManageCommandAvailability = () => {
    const commandsApi = ctx.app.commands;
    manageCommandAvailable = Boolean(
      commandsApi?.executeCommandById && commandsApi?.commands?.[MANAGE_REGIONS_COMMAND_ID]
    );
    manageButton?.setDisabled(panelDisabled || !manageCommandAvailable);
    if (manageButton) {
      manageButton.element.classList.toggle("is-missing-command", !manageCommandAvailable);
    }
    if (!manageCommandAvailable) {
      applyManageHint({
        text: "The \u201COpen Library\u201D command is unavailable. Open the Library view from the ribbon (book icon) and add Region entries under Library \u2192 Regions, then refresh this list.",
        tone: "warning"
      });
    } else {
      applyManageHint(null);
    }
  };
  const handleManageError = (err) => {
    if (err) {
      console.error("[terrain-brush] failed to open Library command", err);
    }
    applyManageHint({
      text: "Opening the Library command failed. Use the ribbon icon to open the Library manually and add Region entries under Library \u2192 Regions before refreshing.",
      tone: "error"
    });
    updateStatus("Failed to open the Library command. Check the console for details.");
  };
  if (manageButton) {
    manageButton.element.addEventListener("click", handleManageClick);
  }
  refreshManageCommandAvailability();
  const fillOptions = async (reason) => {
    const seq = ++fillSeq;
    setPanelDisabled(true);
    applyInlineHint({
      text: reason === "initial" ? "Loading regions\u2026" : "Refreshing regions\u2026",
      tone: "loading"
    });
    updateStatus(reason === "initial" ? "Loading regions\u2026" : "Refreshing regions\u2026");
    let regions = [];
    try {
      regions = await loadRegions(ctx.app);
    } catch (err) {
      console.error("[terrain-brush] failed to load regions", err);
      if (seq === fillSeq && !disposed && !ctx.getAbortSignal()?.aborted) {
        regionControl?.setOptions([]);
        state.region = "";
        state.terrain = "";
        applyInlineHint({
          text: "Regions could not be loaded. Please retry once your vault is synced.",
          tone: "error"
        });
        updateStatus("Failed to load regions. Check the console for details.");
      }
      return;
    } finally {
      if (seq === fillSeq && !disposed && !ctx.getAbortSignal()?.aborted) {
        setPanelDisabled(false);
        refreshManageCommandAvailability();
      }
    }
    if (disposed || ctx.getAbortSignal()?.aborted || seq !== fillSeq) {
      return;
    }
    regionControl?.setOptions([
      { label: "(none)", value: "" },
      ...regions.map((r) => ({
        label: r.name || "(unnamed)",
        value: r.name ?? "",
        data: r.terrain ? { terrain: r.terrain } : void 0
      }))
    ]);
    const regionSelect = regionControl?.element;
    if (!regionSelect) return;
    let matchedTerrain = state.terrain;
    let matchedRegion = state.region;
    let preservedSelection = false;
    for (const opt of Array.from(regionSelect.options)) {
      if (!opt.value) continue;
      if (opt.value === state.region) {
        matchedRegion = opt.value;
        matchedTerrain = opt.dataset.terrain ?? "";
        preservedSelection = true;
        break;
      }
    }
    if (state.region && !preservedSelection) {
      state.region = "";
      state.terrain = "";
      regionControl.setValue("");
      applyInlineHint({
        text: "The previously selected region is no longer available and was cleared.",
        tone: "warning"
      });
      updateStatus("Region selection cleared because the entry is missing.");
    } else {
      state.region = matchedRegion;
      state.terrain = matchedTerrain;
      regionControl.setValue(matchedRegion);
      if (regions.length === 0) {
        applyInlineHint({
          text: "No regions found. Open the Library (Manage\u2026 button or ribbon icon) and add Region entries before painting.",
          tone: "info"
        });
        updateStatus("No regions available yet.");
      } else {
        applyInlineHint(null);
        updateStatus("Regions loaded.");
      }
    }
  };
  void fillOptions("initial");
  const workspace = ctx.app.workspace;
  const unsubscribe = [];
  const subscribe = (event) => {
    const handler = () => {
      if (!disposed) void fillOptions("refresh");
    };
    const token = workspace?.on?.(event, handler);
    if (typeof workspace?.offref === "function" && token) {
      unsubscribe.push(() => workspace.offref(token));
    } else if (typeof token === "function") {
      unsubscribe.push(() => token());
    }
  };
  subscribe("salt:terrains-updated");
  subscribe("salt:regions-updated");
  const ensureCircle = (handles, options) => {
    if (!handles) return;
    circle?.destroy();
    circle = attachBrushCircle(
      { svg: handles.svg, contentG: handles.contentG, overlay: handles.overlay },
      { initialRadius: effectiveRadius(), hexRadiusPx: options?.radius ?? 42 }
    );
    circle.show();
  };
  const dispose = () => {
    disposed = true;
    fillSeq += 1;
    unsubscribe.forEach((off) => {
      try {
        off();
      } catch (err) {
        console.error("[terrain-brush] failed to unsubscribe", err);
      }
    });
    unsubscribe.length = 0;
    if (manageButton) {
      manageButton.element.removeEventListener("click", handleManageClick);
    }
    form.destroy();
    circle?.destroy();
    circle = null;
    while (root.firstChild) {
      root.removeChild(root.firstChild);
    }
  };
  const handleHexClick = async (rc) => {
    const file = ctx.getFile();
    const handles = ctx.getHandles();
    if (!file || !handles) return false;
    const raw = coordsInRadius(rc, effectiveRadius());
    const targets = [...new Map(raw.map((k) => [`${k.r},${k.c}`, k])).values()];
    if (state.mode === "paint") {
      const missing = targets.filter((k) => !handles.polyByCoord.has(`${k.r},${k.c}`));
      if (missing.length) handles.ensurePolys(missing);
    }
    await applyBrush(
      ctx.app,
      file,
      rc,
      {
        radius: effectiveRadius(),
        terrain: state.terrain,
        region: state.region,
        mode: state.mode
      },
      handles,
      {
        tool: {
          getAbortSignal: () => ctx.getAbortSignal(),
          setStatus: (message) => ctx.setStatus(message)
        },
        toolName: TOOL_LABEL
      }
    );
    return true;
  };
  return {
    activate() {
      ensureCircle(ctx.getHandles(), ctx.getOptions());
    },
    deactivate() {
      circle?.destroy();
      circle = null;
    },
    onMapRendered() {
      ensureCircle(ctx.getHandles(), ctx.getOptions());
    },
    async handleHexClick(coord) {
      return handleHexClick(coord);
    },
    setDisabled(disabled) {
      setPanelDisabled(disabled);
      if (disabled) {
        circle?.destroy();
        circle = null;
      } else {
        ensureCircle(ctx.getHandles(), ctx.getOptions());
      }
    },
    destroy() {
      dispose();
    }
  };
}
var MANAGE_REGIONS_COMMAND_ID, TOOL_LABEL;
var init_brush_options = __esm({
  "src/apps/cartographer/editor/tools/terrain-brush/brush-options.ts"() {
    "use strict";
    init_brush_circle();
    init_brush_core();
    init_regions_store();
    init_search_dropdown();
    init_form_builder();
    MANAGE_REGIONS_COMMAND_ID = "salt-marcher:open-library";
    TOOL_LABEL = "Brush";
  }
});

// src/apps/cartographer/modes/lifecycle.ts
function createModeLifecycle() {
  let signal = null;
  return {
    bind(ctx) {
      signal = ctx.signal;
      return signal;
    },
    get() {
      return signal;
    },
    isAborted() {
      return signal?.aborted ?? false;
    },
    reset() {
      signal = null;
    }
  };
}
var init_lifecycle = __esm({
  "src/apps/cartographer/modes/lifecycle.ts"() {
    "use strict";
  }
});

// src/apps/cartographer/modes/editor.ts
var editor_exports = {};
__export(editor_exports, {
  createEditorMode: () => createEditorMode
});
function createEditorMode() {
  let panel = null;
  let form = null;
  let fileLabel = null;
  let statusField = null;
  let toolBody = null;
  let brush = null;
  let brushActive = false;
  let state = {
    file: null,
    handles: null,
    options: null
  };
  const BASE_STATUS_READY = { message: "", tone: "info" };
  const BASE_STATUS_NO_MAP = { message: "No map selected.", tone: "info" };
  const BASE_STATUS_LOADING = { message: "Loading map\u2026", tone: "loading" };
  let baseStatus = BASE_STATUS_NO_MAP;
  let contextualStatus = null;
  let errorStatus = null;
  const lifecycle = createModeLifecycle();
  const applyStatus = () => {
    if (!statusField) return;
    const status = errorStatus ?? contextualStatus ?? baseStatus;
    statusField.set(status);
  };
  const setContextualStatus = (status) => {
    contextualStatus = status;
    refreshPanelState();
  };
  const setContextualMessage = (message, tone = "info") => {
    setContextualStatus(message ? { message, tone } : null);
  };
  const setErrorStatus = (status) => {
    errorStatus = status;
    if (status) {
      contextualStatus = null;
    }
    refreshPanelState();
  };
  const updateFileLabel = () => {
    if (!fileLabel) return;
    fileLabel.textContent = state.file ? state.file.basename : "No map";
  };
  const ensureBrush = (ctx) => {
    if (brush) return brush;
    if (!toolBody) return null;
    try {
      brush = mountBrushPanel(toolBody, {
        app: ctx.app,
        getFile: () => state.file,
        getHandles: () => state.handles,
        getOptions: () => state.options,
        getAbortSignal: () => lifecycle.get(),
        setStatus: (message) => setContextualMessage(message)
      });
      brush.setDisabled(!state.handles || !!errorStatus);
      return brush;
    } catch (error) {
      const message = reportEditorToolIssue({
        stage: "mount-panel",
        toolId: BRUSH_LABEL,
        error
      });
      setErrorStatus({ message, tone: "error" });
      return null;
    }
  };
  const refreshPanelState = () => {
    const hasHandles = !!state.handles;
    baseStatus = hasHandles ? BASE_STATUS_READY : state.file ? BASE_STATUS_LOADING : BASE_STATUS_NO_MAP;
    const toolsBlocked = !!errorStatus;
    panel?.classList.toggle("is-disabled", !hasHandles || toolsBlocked);
    panel?.classList.toggle("has-tool-error", toolsBlocked);
    brush?.setDisabled(!hasHandles || toolsBlocked);
    if (!brush || toolsBlocked || !hasHandles) {
      if (brushActive) {
        brush?.deactivate();
        brushActive = false;
      }
    } else if (!brushActive) {
      brush.activate();
      brushActive = true;
    }
    applyStatus();
  };
  const isAborted = () => lifecycle.isAborted();
  const clearHost = (host) => {
    while (host.firstChild) {
      host.removeChild(host.firstChild);
    }
  };
  return {
    id: "editor",
    label: "Editor",
    async onEnter(ctx) {
      lifecycle.bind(ctx);
      state = { ...state };
      clearHost(ctx.sidebarHost);
      panel = document.createElement("div");
      panel.className = "sm-cartographer__panel sm-cartographer__panel--editor";
      ctx.sidebarHost.appendChild(panel);
      form = buildForm(panel, {
        sections: [
          { kind: "header", text: "Map Editor" },
          { kind: "static", id: "file", cls: "sm-cartographer__panel-file" },
          {
            kind: "row",
            label: "Tool:",
            rowCls: "sm-cartographer__panel-tools",
            controls: [
              {
                kind: "select",
                id: "toolSelect",
                options: [{ value: "brush", label: BRUSH_LABEL }],
                value: "brush",
                disabled: true,
                enhance: (select) => enhanceSelectToSearch(select, "Search dropdown\u2026")
              }
            ]
          },
          { kind: "container", id: "toolBody", cls: "sm-cartographer__panel-body" },
          { kind: "status", id: "status", cls: "sm-cartographer__panel-status" }
        ]
      });
      fileLabel = form.getElement("file");
      statusField = form.getStatus("status");
      toolBody = form.getContainer("toolBody");
      const toolSelectHandle = form.getControl("toolSelect");
      toolSelectHandle?.setValue("brush");
      toolSelectHandle?.setDisabled(true);
      ensureBrush(ctx);
      updateFileLabel();
      refreshPanelState();
    },
    async onExit(ctx) {
      lifecycle.bind(ctx);
      brush?.destroy();
      brush = null;
      brushActive = false;
      contextualStatus = null;
      errorStatus = null;
      baseStatus = BASE_STATUS_NO_MAP;
      form?.destroy();
      form = null;
      if (panel && panel.parentElement) {
        panel.parentElement.removeChild(panel);
      }
      panel = null;
      fileLabel = null;
      statusField = null;
      toolBody = null;
      lifecycle.reset();
    },
    async onFileChange(file, handles, ctx) {
      lifecycle.bind(ctx);
      state.file = file;
      state.handles = handles;
      state.options = ctx.getOptions();
      updateFileLabel();
      ensureBrush(ctx);
      refreshPanelState();
      if (!handles || isAborted()) return;
      brush?.onMapRendered();
    },
    async onHexClick(coord, _event, ctx) {
      lifecycle.bind(ctx);
      if (isAborted()) return;
      const activeBrush = ensureBrush(ctx);
      if (!activeBrush) return;
      try {
        await activeBrush.handleHexClick(coord);
      } catch (err) {
        console.error("[editor-mode] brush interaction failed", err);
        const message = reportEditorToolIssue({
          stage: "operation",
          toolId: BRUSH_LABEL,
          error: err
        });
        setErrorStatus({ message, tone: "error" });
      }
    }
  };
}
var BRUSH_LABEL;
var init_editor = __esm({
  "src/apps/cartographer/modes/editor.ts"() {
    "use strict";
    init_editor_telemetry();
    init_brush_options();
    init_lifecycle();
    init_form_builder();
    init_search_dropdown();
    BRUSH_LABEL = "Brush";
  }
});

// src/apps/cartographer/modes/inspector.ts
var inspector_exports = {};
__export(inspector_exports, {
  createInspectorMode: () => createInspectorMode
});
function createInspectorMode() {
  let ui = {
    panel: null,
    form: null,
    fileLabel: null,
    message: null,
    terrain: null,
    note: null
  };
  let state = {
    file: null,
    handles: null,
    selection: null,
    saveTimer: null
  };
  const lifecycle = createModeLifecycle();
  const isAborted = () => lifecycle.isAborted();
  const clearSaveTimer = () => {
    if (state.saveTimer !== null) {
      window.clearTimeout(state.saveTimer);
      state.saveTimer = null;
    }
  };
  const resetInputs = () => {
    ui.terrain?.setValue("");
    ui.terrain?.setDisabled(true);
    ui.note?.setValue("");
    ui.note?.setDisabled(true);
  };
  const updateMessage = () => {
    if (!ui.message) return;
    if (!state.file || !state.handles) {
      ui.message.set({ message: state.file ? "Karte wird geladen \u2026" : "Keine Karte ausgew\xE4hlt.", tone: "info" });
    } else if (!state.selection) {
      ui.message.set({ message: "Hex anklicken, um Terrain & Notiz zu bearbeiten.", tone: "info" });
    } else {
      ui.message.set({ message: `Hex r${state.selection.r}, c${state.selection.c}`, tone: "info" });
    }
  };
  const updateFileLabel = () => {
    if (!ui.fileLabel) return;
    ui.fileLabel.textContent = state.file ? state.file.basename : "Keine Karte";
  };
  const updatePanelState = () => {
    const hasMap = !!state.file && !!state.handles;
    ui.panel?.classList.toggle("is-disabled", !hasMap);
    if (!hasMap) {
      state.selection = null;
      resetInputs();
    }
    updateMessage();
  };
  const scheduleSave = (ctx) => {
    if (ctx.signal.aborted) return;
    if (!state.selection) return;
    const file = ctx.getFile();
    if (!file) return;
    const handles = ctx.getRenderHandles();
    clearSaveTimer();
    state.saveTimer = window.setTimeout(async () => {
      if (ctx.signal.aborted) return;
      const terrain = ui.terrain?.getValue() ?? "";
      const note = ui.note?.getValue() ?? "";
      try {
        await saveTile(ctx.app, file, state.selection, { terrain, note });
      } catch (err) {
        console.error("[inspector-mode] saveTile failed", err);
      }
      const color = TERRAIN_COLORS[terrain] ?? "transparent";
      try {
        handles?.setFill(state.selection, color);
      } catch (err) {
        console.error("[inspector-mode] setFill failed", err);
      }
    }, 250);
  };
  const loadSelection = async (ctx) => {
    if (!state.selection) return;
    const file = ctx.getFile();
    if (!file) return;
    let data = null;
    try {
      data = await loadTile(ctx.app, file, state.selection);
    } catch (err) {
      console.error("[inspector-mode] loadTile failed", err);
      data = null;
    }
    if (ctx.signal.aborted) return;
    ui.terrain?.setValue(data?.terrain ?? "");
    ui.terrain?.setDisabled(false);
    ui.note?.setValue(data?.note ?? "");
    ui.note?.setDisabled(false);
    updateMessage();
  };
  const clearHost = (host) => {
    while (host.firstChild) {
      host.removeChild(host.firstChild);
    }
  };
  return {
    id: "inspector",
    label: "Inspector",
    async onEnter(ctx) {
      lifecycle.bind(ctx);
      ui = { panel: null, form: null, fileLabel: null, message: null, terrain: null, note: null };
      state = { ...state, selection: null };
      clearHost(ctx.sidebarHost);
      ui.panel = document.createElement("div");
      ui.panel.className = "sm-cartographer__panel sm-cartographer__panel--inspector";
      ctx.sidebarHost.appendChild(ui.panel);
      ui.form = buildForm(ui.panel, {
        sections: [
          { kind: "header", text: "Inspektor" },
          { kind: "static", id: "file", cls: "sm-cartographer__panel-file" },
          { kind: "status", id: "message", cls: "sm-cartographer__panel-info" },
          {
            kind: "row",
            label: "Terrain:",
            rowCls: "sm-cartographer__panel-row",
            controls: [
              {
                kind: "select",
                id: "terrain",
                options: Object.keys(TERRAIN_COLORS).map((key) => ({
                  value: key,
                  label: key || "(leer)"
                })),
                disabled: true,
                enhance: (select) => enhanceSelectToSearch(select, "Such-dropdown\u2026"),
                onChange: () => scheduleSave(ctx)
              }
            ]
          },
          {
            kind: "row",
            label: "Notiz:",
            rowCls: "sm-cartographer__panel-row",
            controls: [
              {
                kind: "textarea",
                id: "note",
                rows: 6,
                disabled: true,
                onInput: () => scheduleSave(ctx)
              }
            ]
          }
        ]
      });
      ui.fileLabel = ui.form.getElement("file");
      ui.message = ui.form.getStatus("message");
      ui.terrain = ui.form.getControl("terrain");
      ui.note = ui.form.getControl("note");
      updateFileLabel();
      updatePanelState();
    },
    async onExit(ctx) {
      lifecycle.bind(ctx);
      clearSaveTimer();
      ui.form?.destroy();
      ui.panel?.remove();
      ui = { panel: null, form: null, fileLabel: null, message: null, terrain: null, note: null };
      state = { file: null, handles: null, selection: null, saveTimer: null };
      lifecycle.reset();
    },
    async onFileChange(file, handles, ctx) {
      lifecycle.bind(ctx);
      state.file = file;
      state.handles = handles;
      clearSaveTimer();
      resetInputs();
      updateFileLabel();
      updatePanelState();
      if (state.selection && state.file && state.handles && !isAborted()) {
        await loadSelection(ctx);
      }
    },
    async onHexClick(coord, _event, ctx) {
      lifecycle.bind(ctx);
      if (isAborted()) return;
      if (!state.file || !state.handles) return;
      clearSaveTimer();
      state.selection = coord;
      updateMessage();
      if (isAborted()) return;
      await loadSelection(ctx);
    }
  };
}
var init_inspector = __esm({
  "src/apps/cartographer/modes/inspector.ts"() {
    "use strict";
    init_hex_notes();
    init_terrain();
    init_search_dropdown();
    init_lifecycle();
    init_form_builder();
  }
});

// src/apps/library/core/file-pipeline.ts
function sanitizeVaultFileName(name, fallback) {
  const trimmed = (name ?? "").trim();
  const safeFallback = fallback && fallback.trim() ? fallback.trim() : "Entry";
  if (!trimmed) return safeFallback;
  return trimmed.replace(/[\\/:*?"<>|]/g, "-").replace(/\s+/g, " ").replace(/^\.+$/, safeFallback).slice(0, 120);
}
function createVaultFilePipeline(options) {
  const normalizedDir = (0, import_obsidian18.normalizePath)(options.dir);
  const extension = (options.extension || "md").replace(/^\.+/, "");
  const sanitize = options.sanitizeName ? options.sanitizeName : (name) => sanitizeVaultFileName(name, options.defaultBaseName);
  async function ensure(app) {
    let file = app.vault.getAbstractFileByPath(normalizedDir);
    if (file instanceof import_obsidian18.TFolder) return file;
    await app.vault.createFolder(normalizedDir).catch(() => {
    });
    file = app.vault.getAbstractFileByPath(normalizedDir);
    if (file instanceof import_obsidian18.TFolder) return file;
    throw new Error(`Could not create directory ${normalizedDir}`);
  }
  async function list(app) {
    const dir = await ensure(app);
    const out = [];
    const walk = (folder) => {
      for (const child of folder.children) {
        if (child instanceof import_obsidian18.TFolder) walk(child);
        else if (child instanceof import_obsidian18.TFile && child.extension === extension) out.push(child);
      }
    };
    walk(dir);
    return out;
  }
  function watch(app, onChange) {
    const base = `${normalizedDir}/`;
    const isRelevant = (file) => {
      if (!(file instanceof import_obsidian18.TFile || file instanceof import_obsidian18.TFolder)) return false;
      const path = file.path.endsWith("/") ? file.path : `${file.path}/`;
      return path.startsWith(base);
    };
    const handler = (file) => {
      if (isRelevant(file)) onChange?.();
    };
    app.vault.on("create", handler);
    app.vault.on("delete", handler);
    app.vault.on("rename", handler);
    app.vault.on("modify", handler);
    return () => {
      app.vault.off("create", handler);
      app.vault.off("delete", handler);
      app.vault.off("rename", handler);
      app.vault.off("modify", handler);
    };
  }
  async function create(app, data) {
    const dir = await ensure(app);
    const baseName = sanitize(options.getBaseName(data) ?? options.defaultBaseName);
    let fileName = `${baseName}.${extension}`;
    let path = (0, import_obsidian18.normalizePath)(`${dir.path}/${fileName}`);
    let i = 2;
    while (app.vault.getAbstractFileByPath(path)) {
      fileName = `${baseName} (${i}).${extension}`;
      path = (0, import_obsidian18.normalizePath)(`${dir.path}/${fileName}`);
      i += 1;
    }
    const content = options.toContent(data);
    const file = await app.vault.create(path, content);
    return file;
  }
  return { ensure, list, watch, create };
}
var import_obsidian18;
var init_file_pipeline = __esm({
  "src/apps/library/core/file-pipeline.ts"() {
    "use strict";
    import_obsidian18 = require("obsidian");
  }
});

// src/apps/library/core/creature-files.ts
function yamlList(items) {
  if (!items || items.length === 0) return void 0;
  const safe = items.map((s) => `"${(s ?? "").replace(/"/g, '\\"')}"`).join(", ");
  return `[${safe}]`;
}
function formatSpeedExtra(entry) {
  const parts = [entry.label];
  if (entry.distance) parts.push(entry.distance);
  if (entry.note) parts.push(entry.note);
  if (entry.hover) parts.push("(hover)");
  return parts.map((p) => p?.trim()).filter((p) => Boolean(p && p.length)).join(" ");
}
function parseNumericValue(v) {
  if (!v) return null;
  const m = String(v).match(/-?\d+/);
  if (!m) return null;
  return Number(m[0]);
}
function abilityModifierFromScore(score) {
  const n = typeof score === "number" ? score : parseNumericValue(score);
  if (n == null || Number.isNaN(n)) return null;
  return Math.floor((n - 10) / 2);
}
function getAbilityModifier(data, ability) {
  const abilityScore = data.abilities?.find((a) => a.ability === ability);
  return abilityScore ? abilityModifierFromScore(abilityScore.score) : null;
}
function getProficiencyBonus(data) {
  return parseNumericValue(data.pb);
}
function calculateSaveDc({ abilityMod: abilityMod2, proficiencyBonus, override }) {
  if (override != null) return override;
  if (abilityMod2 == null || proficiencyBonus == null) return null;
  return 8 + abilityMod2 + proficiencyBonus;
}
function calculateAttackBonus({ abilityMod: abilityMod2, proficiencyBonus, override }) {
  if (override != null) return override;
  if (abilityMod2 == null || proficiencyBonus == null) return null;
  return abilityMod2 + proficiencyBonus;
}
function fmtSigned(n) {
  return (n >= 0 ? "+" : "") + n;
}
function composeAlignment(d) {
  const override = d.alignmentOverride?.trim();
  if (override) return override;
  const a = d.alignmentLawChaos?.trim();
  const b = d.alignmentGoodEvil?.trim();
  if (!a && !b) return void 0;
  if (a?.toLowerCase() === "neutral" && b?.toLowerCase() === "neutral") return "Neutral";
  return [a, b].filter(Boolean).join(" ");
}
function composeTypeLine(d) {
  const base = d.type?.trim();
  const tags = (d.typeTags ?? []).map((tag) => tag.trim()).filter(Boolean);
  if (base && tags.length) return `${base} (${tags.join(", ")})`;
  if (base) return base;
  if (tags.length) return tags.join(", ");
  return void 0;
}
function statblockToMarkdown(d) {
  var _a;
  const identity = [d.size?.trim(), composeTypeLine(d)].filter(Boolean).join(" ");
  const alignment = composeAlignment(d);
  const header = [identity, alignment].filter(Boolean).join(", ");
  const name = d.name || "Unnamed Creature";
  const lines = [];
  lines.push("---");
  lines.push("smType: creature");
  lines.push(`name: "${name.replace(/"/g, '\\"')}"`);
  if (d.size) lines.push(`size: "${d.size}"`);
  if (d.type) lines.push(`type: "${d.type}"`);
  const typeTagsYaml = yamlList((d.typeTags ?? []).map((tag) => tag?.trim()).filter((tag) => Boolean(tag && tag.length)));
  if (typeTagsYaml) lines.push(`type_tags: ${typeTagsYaml}`);
  if (alignment) lines.push(`alignment: "${alignment}"`);
  if (d.alignmentOverride) lines.push(`alignment_override: "${d.alignmentOverride.replace(/"/g, '\\"')}"`);
  if (d.ac) lines.push(`ac: "${d.ac}"`);
  if (d.initiative) lines.push(`initiative: "${d.initiative}"`);
  if (d.hp) lines.push(`hp: "${d.hp}"`);
  if (d.hitDice) lines.push(`hit_dice: "${d.hitDice}"`);
  const speeds = d.speeds;
  if (speeds) {
    const json = JSON.stringify(speeds).replace(/"/g, '\\"');
    lines.push(`speeds_json: "${json}"`);
  }
  if (d.abilities && d.abilities.length) {
    const json = JSON.stringify(d.abilities).replace(/"/g, '\\"');
    lines.push(`abilities_json: "${json}"`);
  }
  if (d.pb) lines.push(`pb: "${d.pb}"`);
  if (d.saves && d.saves.length) {
    const json = JSON.stringify(d.saves).replace(/"/g, '\\"');
    lines.push(`saves_json: "${json}"`);
  }
  if (d.skills && d.skills.length) {
    const json = JSON.stringify(d.skills).replace(/"/g, '\\"');
    lines.push(`skills_json: "${json}"`);
  }
  const sensesYaml = yamlList(d.sensesList);
  if (sensesYaml) lines.push(`senses: ${sensesYaml}`);
  const langsYaml = yamlList(d.languagesList);
  if (langsYaml) lines.push(`languages: ${langsYaml}`);
  const passivesYaml = yamlList(d.passivesList);
  if (passivesYaml) lines.push(`passives: ${passivesYaml}`);
  const vulnerabilitiesYaml = yamlList(d.damageVulnerabilitiesList);
  if (vulnerabilitiesYaml) lines.push(`damage_vulnerabilities: ${vulnerabilitiesYaml}`);
  const resistancesYaml = yamlList(d.damageResistancesList);
  if (resistancesYaml) lines.push(`damage_resistances: ${resistancesYaml}`);
  const immunitiesYaml = yamlList(d.damageImmunitiesList);
  if (immunitiesYaml) lines.push(`damage_immunities: ${immunitiesYaml}`);
  const conditionYaml = yamlList(d.conditionImmunitiesList);
  if (conditionYaml) lines.push(`condition_immunities: ${conditionYaml}`);
  const gearYaml = yamlList(d.gearList);
  if (gearYaml) lines.push(`gear: ${gearYaml}`);
  if (d.cr) lines.push(`cr: "${d.cr}"`);
  if (d.xp) lines.push(`xp: "${d.xp}"`);
  const entries = d.entries && d.entries.length ? d.entries : d.actionsList && d.actionsList.length ? d.actionsList.map((a) => ({ category: "action", ...a })) : void 0;
  if (entries && entries.length) {
    const json = JSON.stringify(entries).replace(/"/g, '\\"');
    lines.push(`entries_structured_json: "${json}"`);
  }
  const spellcasting = resolveSpellcastingData(d);
  if (spellcasting && spellcasting.groups.length) {
    const json = JSON.stringify(spellcasting).replace(/"/g, '\\"');
    lines.push(`spellcasting_json: "${json}"`);
  }
  lines.push("---\n");
  lines.push(`# ${name}`);
  if (header) lines.push(`*${header}*`);
  lines.push("");
  if (d.ac || d.initiative) lines.push(`AC ${d.ac ?? "-"}    Initiative ${d.initiative ?? "-"}`);
  if (d.hp || d.hitDice) lines.push(`HP ${d.hp ?? "-"}${d.hitDice ? ` (${d.hitDice})` : ""}`);
  if (speeds) {
    const speedParts = [];
    if (speeds.walk?.distance) speedParts.push(speeds.walk.distance);
    if (speeds.climb?.distance) speedParts.push(`climb ${speeds.climb.distance}`);
    if (speeds.swim?.distance) speedParts.push(`swim ${speeds.swim.distance}`);
    if (speeds.fly?.distance) speedParts.push(`fly ${speeds.fly.distance}${speeds.fly.hover ? " (hover)" : ""}`);
    if (speeds.burrow?.distance) speedParts.push(`burrow ${speeds.burrow.distance}`);
    if (speeds.extras) {
      for (const extra of speeds.extras) {
        speedParts.push(formatSpeedExtra(extra));
      }
    }
    if (speedParts.length) lines.push(`Speed ${speedParts.join(", ")}`);
  }
  lines.push("");
  if (d.abilities && d.abilities.length) {
    lines.push("| Ability | Score |");
    lines.push("| ------: | :---- |");
    const abilityLabels = { str: "STR", dex: "DEX", con: "CON", int: "INT", wis: "WIS", cha: "CHA" };
    const orderedAbilities = ["str", "dex", "con", "int", "wis", "cha"];
    for (const key of orderedAbilities) {
      const ability = d.abilities.find((a) => a.ability === key);
      if (ability) {
        lines.push(`| ${abilityLabels[key]} | ${ability.score} |`);
      }
    }
    lines.push("");
  }
  const pbValue = parseNumericValue(d.pb);
  if (d.saves && d.saves.length) {
    const abilityLabels = { str: "Str", dex: "Dex", con: "Con", int: "Int", wis: "Wis", cha: "Cha" };
    const parts = d.saves.map((save) => `${abilityLabels[save.ability]} ${fmtSigned(save.bonus)}`);
    lines.push(`Saves ${parts.join(", ")}`);
  }
  if (d.skills && d.skills.length) {
    const parts = d.skills.map((skill) => `${skill.name} ${fmtSigned(skill.bonus)}`);
    lines.push(`Skills ${parts.join(", ")}`);
  }
  const sensesParts = [];
  if (d.sensesList && d.sensesList.length) sensesParts.push(d.sensesList.join(", "));
  const passiveChunk = d.passivesList && d.passivesList.length ? d.passivesList.join("; ") : "";
  if (sensesParts.length || passiveChunk) {
    const tail = passiveChunk ? sensesParts.length ? `; ${passiveChunk}` : passiveChunk : "";
    lines.push(`Senses ${[sensesParts.join(", "), tail].filter(Boolean).join("")}`);
  }
  if (d.damageVulnerabilitiesList && d.damageVulnerabilitiesList.length) lines.push(`Vulnerabilities ${d.damageVulnerabilitiesList.join(", ")}`);
  if (d.damageResistancesList && d.damageResistancesList.length) lines.push(`Resistances ${d.damageResistancesList.join(", ")}`);
  if (d.damageImmunitiesList && d.damageImmunitiesList.length) lines.push(`Immunities ${d.damageImmunitiesList.join(", ")}`);
  if (d.conditionImmunitiesList && d.conditionImmunitiesList.length) lines.push(`Condition Immunities ${d.conditionImmunitiesList.join(", ")}`);
  if (d.languagesList && d.languagesList.length) lines.push(`Languages ${d.languagesList.join(", ")}`);
  if (d.gearList && d.gearList.length) lines.push(`Gear ${d.gearList.join(", ")}`);
  if (d.cr || d.pb || d.xp) {
    const bits = [];
    if (d.cr) bits.push(`CR ${d.cr}`);
    if (pbValue != null && !Number.isNaN(pbValue) && pbValue !== 0) bits.push(`PB ${fmtSigned(pbValue)}`);
    if (d.xp) bits.push(`XP ${d.xp}`);
    if (bits.length) lines.push(bits.join("; "));
  }
  lines.push("");
  if (entries && entries.length) {
    const groups = { trait: [], action: [], bonus: [], reaction: [], legendary: [] };
    for (const e of entries) {
      (groups[_a = e.category] || (groups[_a] = [])).push(e);
    }
    const renderGroup = (title, arr) => {
      if (!arr || arr.length === 0) return;
      lines.push(`## ${title}
`);
      for (const a of arr) {
        const headParts = [a.name, a.recharge].filter(Boolean).join(" ");
        lines.push(`- **${headParts}**`);
        const sub = [];
        if (a.kind) sub.push(a.kind);
        if (a.to_hit) sub.push(`to hit ${a.to_hit}`);
        else if (a.to_hit_from) {
          const abil = a.to_hit_from.ability;
          const abilMod = abil === "best_of_str_dex" ? Math.max(abilityModifierFromScore(d.str) ?? 0, abilityModifierFromScore(d.dex) ?? 0) : abilityModifierFromScore(d[abil]) ?? 0;
          const pb = parseNumericValue(d.pb) ?? 0;
          const total = abilMod + (a.to_hit_from.proficient ? pb : 0);
          sub.push(`to hit ${fmtSigned(total)}`);
        }
        if (a.range) sub.push(a.range);
        if (a.target) sub.push(a.target);
        if (a.damage) sub.push(a.damage);
        else if (a.damage_from) {
          const abilKey = a.damage_from.ability;
          const abilMod = abilKey ? abilKey === "best_of_str_dex" ? Math.max(abilityModifierFromScore(d.str) ?? 0, abilityModifierFromScore(d.dex) ?? 0) : abilityModifierFromScore(d[abilKey]) ?? 0 : 0;
          const bonus = a.damage_from.bonus ? ` ${a.damage_from.bonus}` : "";
          const modTxt = abilMod ? ` ${fmtSigned(abilMod)}` : "";
          sub.push(`${a.damage_from.dice}${modTxt}${bonus}`.trim());
        }
        if (a.save_ability) sub.push(`Save ${a.save_ability}${a.save_dc ? ` DC ${a.save_dc}` : ""}${a.save_effect ? ` (${a.save_effect})` : ""}`);
        if (sub.length) lines.push(`  - ${sub.join(", ")}`);
        if (a.text && a.text.trim()) lines.push(`  ${a.text.trim()}`);
      }
      lines.push("");
    };
    renderGroup("Traits", groups.trait);
    renderGroup("Actions", groups.action);
    renderGroup("Bonus Actions", groups.bonus);
    renderGroup("Reactions", groups.reaction);
    renderGroup("Legendary Actions", groups.legendary);
  } else {
    if (d.traits) {
      lines.push("## Traits\n");
      lines.push(d.traits.trim());
      lines.push("");
    }
    if (d.actions) {
      lines.push("## Actions\n");
      lines.push(d.actions.trim());
      lines.push("");
    }
    if (d.legendary) {
      lines.push("## Legendary Actions\n");
      lines.push(d.legendary.trim());
      lines.push("");
    }
  }
  if (spellcasting && spellcasting.groups.length) {
    renderSpellcasting(lines, d, spellcasting);
  }
  return lines.join("\n");
}
function resolveSpellcastingData(d) {
  if (!d.spellcasting) return void 0;
  return withComputedSpellcasting(d, d.spellcasting);
}
function withComputedSpellcasting(d, base) {
  const abilityMod2 = base.ability ? getAbilityModifier(d, base.ability) : null;
  const proficiencyBonus = getProficiencyBonus(d);
  const saveDc = calculateSaveDc({ abilityMod: abilityMod2, proficiencyBonus, override: base.saveDcOverride });
  const attackBonus = calculateAttackBonus({ abilityMod: abilityMod2, proficiencyBonus, override: base.attackBonusOverride });
  return {
    ...base,
    computed: {
      abilityMod: abilityMod2,
      proficiencyBonus,
      saveDc,
      attackBonus
    }
  };
}
function renderSpellcasting(lines, d, spellcasting) {
  const title = spellcasting.title?.trim() || "Spellcasting";
  lines.push(`## ${title}`);
  lines.push("");
  if (spellcasting.summary) {
    lines.push(spellcasting.summary.trim());
    lines.push("");
  }
  const saveDc = spellcasting.computed?.saveDc;
  const attackBonus = spellcasting.computed?.attackBonus;
  const summaryParts = [];
  if (saveDc != null) summaryParts.push(`Spell save DC ${saveDc}`);
  if (attackBonus != null) summaryParts.push(`${fmtSigned(attackBonus)} to hit with spell attacks`);
  if (summaryParts.length) {
    lines.push(`*${summaryParts.join(", ")}`);
    lines.push("");
  }
  if (spellcasting.notes && spellcasting.notes.length) {
    for (const note of spellcasting.notes) {
      if (note && note.trim()) {
        lines.push(note.trim());
      }
    }
    if (spellcasting.notes.some((note) => note && note.trim())) {
      lines.push("");
    }
  }
  for (const group of spellcasting.groups) {
    switch (group.type) {
      case "at-will":
        renderSpellGroup(lines, group.title ?? "At Will", group.spells);
        break;
      case "per-day": {
        const heading = group.title ?? group.uses;
        renderSpellGroup(lines, heading, group.spells, group.note);
        break;
      }
      case "level": {
        const base = group.title ?? formatSpellLevelHeading(group.level);
        const slots = group.slots == null ? void 0 : typeof group.slots === "number" ? `${group.slots} slot${group.slots === 1 ? "" : "s"}` : String(group.slots);
        const heading = slots ? `${base} (${slots})` : base;
        renderSpellGroup(lines, heading, group.spells, group.note);
        break;
      }
      case "custom": {
        renderSpellGroup(lines, group.title, group.spells ?? [], group.description);
        break;
      }
    }
  }
  if (lines[lines.length - 1] !== "") lines.push("");
}
function renderSpellGroup(lines, heading, spells, note) {
  lines.push(`### ${heading}`);
  lines.push("");
  if (note && note.trim()) {
    lines.push(note.trim());
    lines.push("");
  }
  if (!spells.length) {
    lines.push("- none");
    lines.push("");
    return;
  }
  for (const spell of spells) {
    const details = [];
    if (spell.prepared != null) details.push(spell.prepared ? "prepared" : "known");
    if (spell.notes) details.push(spell.notes);
    const suffix = details.length ? ` (${details.join(", ")})` : "";
    lines.push(`- ${spell.name}${suffix}`);
  }
  lines.push("");
}
function formatSpellLevelHeading(level) {
  if (level <= 0) return "Cantrips";
  const suffix = level === 1 ? "st" : level === 2 ? "nd" : level === 3 ? "rd" : "th";
  return `${level}${suffix} Level`;
}
async function createCreatureFile(app, d) {
  return CREATURE_PIPELINE.create(app, d);
}
var CREATURES_DIR, CREATURE_PIPELINE, ensureCreatureDir, listCreatureFiles, watchCreatureDir;
var init_creature_files = __esm({
  "src/apps/library/core/creature-files.ts"() {
    "use strict";
    init_file_pipeline();
    CREATURES_DIR = "SaltMarcher/Creatures";
    CREATURE_PIPELINE = createVaultFilePipeline({
      dir: CREATURES_DIR,
      defaultBaseName: "Creature",
      getBaseName: (data) => data.name,
      toContent: statblockToMarkdown,
      sanitizeName: (name) => sanitizeVaultFileName(name, "Creature")
    });
    ensureCreatureDir = CREATURE_PIPELINE.ensure;
    listCreatureFiles = CREATURE_PIPELINE.list;
    watchCreatureDir = CREATURE_PIPELINE.watch;
  }
});

// src/apps/library/core/spell-files.ts
function asStringArray(value) {
  if (!Array.isArray(value)) return void 0;
  return value.map((entry) => typeof entry === "string" ? entry : String(entry ?? ""));
}
function asBoolean(value) {
  if (typeof value === "boolean") return value;
  if (typeof value === "string") {
    const normalized = value.toLowerCase();
    if (normalized === "true") return true;
    if (normalized === "false") return false;
  }
  return void 0;
}
function yamlList2(items) {
  if (!items || items.length === 0) return void 0;
  const safe = items.map((s) => `"${(s ?? "").replace(/"/g, '\\"')}"`).join(", ");
  return `[${safe}]`;
}
function spellToMarkdown(d) {
  const lines = [];
  const name = d.name || "Unnamed Spell";
  lines.push("---");
  lines.push("smType: spell");
  lines.push(`name: "${name.replace(/"/g, '\\"')}"`);
  if (Number.isFinite(d.level)) lines.push(`level: ${d.level}`);
  if (d.school) lines.push(`school: "${d.school}"`);
  if (d.casting_time) lines.push(`casting_time: "${d.casting_time}"`);
  if (d.range) lines.push(`range: "${d.range}"`);
  const comps = yamlList2(d.components);
  if (comps) lines.push(`components: ${comps}`);
  if (d.materials) lines.push(`materials: "${d.materials.replace(/"/g, '\\"')}"`);
  if (d.duration) lines.push(`duration: "${d.duration}"`);
  if (d.concentration != null) lines.push(`concentration: ${!!d.concentration}`);
  if (d.ritual != null) lines.push(`ritual: ${!!d.ritual}`);
  const classes = yamlList2(d.classes);
  if (classes) lines.push(`classes: ${classes}`);
  if (d.save_ability) lines.push(`save_ability: "${d.save_ability}"`);
  if (d.save_effect) lines.push(`save_effect: "${d.save_effect.replace(/"/g, '\\"')}"`);
  if (d.attack) lines.push(`attack: "${d.attack}"`);
  if (d.damage) lines.push(`damage: "${d.damage}"`);
  if (d.damage_type) lines.push(`damage_type: "${d.damage_type}"`);
  lines.push("---\n");
  lines.push(`# ${name}`);
  const levelStr = d.level == null ? "" : d.level === 0 ? "Cantrip" : `Level ${d.level}`;
  const parts = [levelStr, d.school].filter(Boolean);
  if (parts.length) lines.push(parts.join(" "));
  lines.push("");
  const stat = (label, val) => {
    if (val) lines.push(`- ${label}: ${val}`);
  };
  stat("Casting Time", d.casting_time);
  stat("Range", d.range);
  const compLine = (d.components || []).join(", ") + (d.materials ? ` (${d.materials})` : "");
  if (d.components && d.components.length) stat("Components", compLine);
  stat("Duration", d.duration);
  if (d.concentration) lines.push("- Concentration: yes");
  if (d.ritual) lines.push("- Ritual: yes");
  if (d.classes && d.classes.length) stat("Classes", (d.classes || []).join(", "));
  if (d.attack) stat("Attack", d.attack);
  if (d.save_ability) stat("Save", `${d.save_ability}${d.save_effect ? ` (${d.save_effect})` : ""}`);
  if (d.damage) stat("Damage", `${d.damage}${d.damage_type ? ` ${d.damage_type}` : ""}`);
  lines.push("");
  if (d.description) {
    lines.push(d.description.trim());
    lines.push("");
  }
  if (d.higher_levels) {
    lines.push("## At Higher Levels\n");
    lines.push(d.higher_levels.trim());
    lines.push("");
  }
  return lines.join("\n");
}
async function createSpellFile(app, d) {
  return SPELL_PIPELINE.create(app, d);
}
async function loadSpellFile(app, file) {
  const cache = app.metadataCache.getFileCache(file);
  const frontmatter = cache?.frontmatter ?? {};
  const rawLevel = frontmatter.level;
  const level = typeof rawLevel === "number" ? rawLevel : typeof rawLevel === "string" ? Number(rawLevel) : void 0;
  const data = {
    name: typeof frontmatter.name === "string" && frontmatter.name.trim().length > 0 ? frontmatter.name.trim() : file.basename,
    level: Number.isFinite(level) ? level : void 0,
    school: typeof frontmatter.school === "string" ? frontmatter.school : void 0,
    casting_time: typeof frontmatter.casting_time === "string" ? frontmatter.casting_time : void 0,
    range: typeof frontmatter.range === "string" ? frontmatter.range : void 0,
    components: asStringArray(frontmatter.components),
    materials: typeof frontmatter.materials === "string" ? frontmatter.materials : void 0,
    duration: typeof frontmatter.duration === "string" ? frontmatter.duration : void 0,
    concentration: asBoolean(frontmatter.concentration),
    ritual: asBoolean(frontmatter.ritual),
    classes: asStringArray(frontmatter.classes),
    save_ability: typeof frontmatter.save_ability === "string" ? frontmatter.save_ability : void 0,
    save_effect: typeof frontmatter.save_effect === "string" ? frontmatter.save_effect : void 0,
    attack: typeof frontmatter.attack === "string" ? frontmatter.attack : void 0,
    damage: typeof frontmatter.damage === "string" ? frontmatter.damage : void 0,
    damage_type: typeof frontmatter.damage_type === "string" ? frontmatter.damage_type : void 0,
    description: typeof frontmatter.description === "string" ? frontmatter.description : void 0,
    higher_levels: typeof frontmatter.higher_levels === "string" ? frontmatter.higher_levels : void 0
  };
  return data;
}
var SPELLS_DIR, SPELL_PIPELINE, ensureSpellDir, listSpellFiles, watchSpellDir;
var init_spell_files = __esm({
  "src/apps/library/core/spell-files.ts"() {
    "use strict";
    init_file_pipeline();
    SPELLS_DIR = "SaltMarcher/Spells";
    SPELL_PIPELINE = createVaultFilePipeline({
      dir: SPELLS_DIR,
      defaultBaseName: "Spell",
      getBaseName: (data) => data.name,
      toContent: spellToMarkdown,
      sanitizeName: (name) => sanitizeVaultFileName(name, "Spell")
    });
    ensureSpellDir = SPELL_PIPELINE.ensure;
    listSpellFiles = SPELL_PIPELINE.list;
    watchSpellDir = SPELL_PIPELINE.watch;
  }
});

// src/apps/library/core/item-files.ts
function yamlList3(items) {
  if (!items || items.length === 0) return void 0;
  const safe = items.map((s) => `"${(s ?? "").replace(/"/g, '\\"')}"`).join(", ");
  return `[${safe}]`;
}
function escapeJson(obj) {
  return JSON.stringify(obj).replace(/"/g, '\\"');
}
function itemToMarkdown(d) {
  const lines = [];
  const name = d.name || "Unnamed Item";
  lines.push("---");
  lines.push("smType: item");
  lines.push(`name: "${name.replace(/"/g, '\\"')}"`);
  if (d.category) lines.push(`category: "${d.category}"`);
  if (d.type) lines.push(`type: "${d.type}"`);
  if (d.rarity) lines.push(`rarity: "${d.rarity}"`);
  if (d.attunement != null) lines.push(`attunement: ${!!d.attunement}`);
  if (d.attunement_req) lines.push(`attunement_req: "${d.attunement_req.replace(/"/g, '\\"')}"`);
  if (d.max_charges != null) lines.push(`max_charges: ${d.max_charges}`);
  if (d.recharge_formula) lines.push(`recharge_formula: "${d.recharge_formula}"`);
  if (d.recharge_time) lines.push(`recharge_time: "${d.recharge_time}"`);
  if (d.destruction_risk) lines.push(`destruction_risk: "${d.destruction_risk.replace(/"/g, '\\"')}"`);
  if (d.spells && d.spells.length > 0) {
    lines.push(`spells_json: "${escapeJson(d.spells)}"`);
  }
  if (d.spell_storage_capacity != null) {
    lines.push(`spell_storage_capacity: ${d.spell_storage_capacity}`);
  }
  if (d.bonuses && d.bonuses.length > 0) {
    lines.push(`bonuses_json: "${escapeJson(d.bonuses)}"`);
  }
  const resistancesYaml = yamlList3(d.resistances);
  if (resistancesYaml) lines.push(`resistances: ${resistancesYaml}`);
  const immunitiesYaml = yamlList3(d.immunities);
  if (immunitiesYaml) lines.push(`immunities: ${immunitiesYaml}`);
  if (d.ability_changes && d.ability_changes.length > 0) {
    lines.push(`ability_changes_json: "${escapeJson(d.ability_changes)}"`);
  }
  if (d.speed_changes && d.speed_changes.length > 0) {
    lines.push(`speed_changes_json: "${escapeJson(d.speed_changes)}"`);
  }
  if (d.properties && d.properties.length > 0) {
    lines.push(`properties_json: "${escapeJson(d.properties)}"`);
  }
  if (d.usage_limit) {
    lines.push(`usage_limit_json: "${escapeJson(d.usage_limit)}"`);
  }
  if (d.cursed != null) lines.push(`cursed: ${!!d.cursed}`);
  if (d.curse_description) lines.push(`curse_description: "${d.curse_description.replace(/"/g, '\\"')}"`);
  if (d.has_variants != null) lines.push(`has_variants: ${!!d.has_variants}`);
  if (d.variant_info) lines.push(`variant_info: "${d.variant_info.replace(/"/g, '\\"')}"`);
  if (d.tables && d.tables.length > 0) {
    lines.push(`tables_json: "${escapeJson(d.tables)}"`);
  }
  if (d.sentient != null) lines.push(`sentient: ${!!d.sentient}`);
  if (d.sentient_props) {
    lines.push(`sentient_props_json: "${escapeJson(d.sentient_props)}"`);
  }
  if (d.weight) lines.push(`weight: "${d.weight}"`);
  if (d.value) lines.push(`value: "${d.value}"`);
  lines.push("---\n");
  lines.push(`# ${name}`);
  const typeParts = [];
  if (d.category) typeParts.push(d.category);
  if (d.type) typeParts.push(`(${d.type})`);
  if (d.rarity) typeParts.push(d.rarity);
  if (d.attunement) {
    const attunementText = d.attunement_req ? `Requires Attunement ${d.attunement_req}` : "Requires Attunement";
    typeParts.push(`(${attunementText})`);
  }
  if (typeParts.length > 0) {
    lines.push(`*${typeParts.join(" ")}*`);
  }
  lines.push("");
  const stats = [];
  if (d.weight) stats.push(`- Weight: ${d.weight}`);
  if (d.value) stats.push(`- Value: ${d.value}`);
  if (stats.length > 0) {
    lines.push(...stats);
    lines.push("");
  }
  if (d.max_charges != null) {
    lines.push(`## Charges
`);
    lines.push(`This item has ${d.max_charges} charges.`);
    if (d.recharge_formula || d.recharge_time) {
      const rechargeParts = [];
      if (d.recharge_formula) rechargeParts.push(`regains ${d.recharge_formula} charges`);
      if (d.recharge_time) rechargeParts.push(`at ${d.recharge_time}`);
      lines.push(rechargeParts.join(" ") + ".");
    }
    if (d.destruction_risk) {
      lines.push(d.destruction_risk);
    }
    lines.push("");
  }
  if (d.spells && d.spells.length > 0) {
    lines.push(`## Spells
`);
    lines.push("This item can cast the following spells:");
    lines.push("");
    for (const spell of d.spells) {
      const parts = [spell.name];
      if (spell.charge_cost != null) parts.push(`(${spell.charge_cost} charge${spell.charge_cost === 1 ? "" : "s"})`);
      if (spell.level != null) parts.push(`[Level ${spell.level}]`);
      if (spell.save_dc != null) parts.push(`DC ${spell.save_dc}`);
      if (spell.uses_caster_dc) parts.push("(uses caster's DC)");
      lines.push(`- ${parts.join(" ")}`);
    }
    lines.push("");
  }
  if (d.spell_storage_capacity != null) {
    lines.push(`## Spell Storage
`);
    lines.push(`This item can store up to ${d.spell_storage_capacity} levels of spells.`);
    lines.push("");
  }
  if (d.bonuses && d.bonuses.length > 0) {
    lines.push(`## Bonuses
`);
    for (const bonus of d.bonuses) {
      const parts = [`${bonus.value} to ${bonus.type}`];
      if (bonus.applies_to) parts.push(`(${bonus.applies_to})`);
      lines.push(`- ${parts.join(" ")}`);
    }
    lines.push("");
  }
  if (d.resistances && d.resistances.length > 0) {
    lines.push(`- Resistances: ${d.resistances.join(", ")}`);
  }
  if (d.immunities && d.immunities.length > 0) {
    lines.push(`- Immunities: ${d.immunities.join(", ")}`);
  }
  if (d.resistances && d.resistances.length > 0 || d.immunities && d.immunities.length > 0) {
    lines.push("");
  }
  if (d.ability_changes && d.ability_changes.length > 0) {
    lines.push(`## Ability Changes
`);
    for (const change of d.ability_changes) {
      const parts = [`${change.ability.toUpperCase()} becomes ${change.value}`];
      if (change.condition) parts.push(`(${change.condition})`);
      lines.push(`- ${parts.join(" ")}`);
    }
    lines.push("");
  }
  if (d.speed_changes && d.speed_changes.length > 0) {
    lines.push(`## Speed Modifications
`);
    for (const speed of d.speed_changes) {
      const parts = [`${speed.type} ${speed.value}`];
      if (speed.condition) parts.push(`(${speed.condition})`);
      lines.push(`- ${parts.join(" ")}`);
    }
    lines.push("");
  }
  if (d.properties && d.properties.length > 0) {
    lines.push(`## Properties
`);
    for (const prop of d.properties) {
      lines.push(`**${prop.name}${prop.range ? ` (${prop.range})` : ""}**`);
      lines.push(prop.description);
      lines.push("");
    }
  }
  if (d.usage_limit) {
    lines.push(`## Usage
`);
    lines.push(`Can be used ${d.usage_limit.amount}, resets ${d.usage_limit.reset}.`);
    if (d.usage_limit.cumulative_failure) {
      lines.push(`${d.usage_limit.cumulative_failure.chance_per_use}% chance per use: ${d.usage_limit.cumulative_failure.on_failure}`);
    }
    lines.push("");
  }
  if (d.description) {
    lines.push(d.description.trim());
    lines.push("");
  }
  if (d.tables && d.tables.length > 0) {
    for (const table of d.tables) {
      lines.push(`## ${table.name}
`);
      if (table.description) {
        lines.push(table.description);
        lines.push("");
      }
      lines.push("| Roll | Result |");
      lines.push("| :--- | :----- |");
      for (const entry of table.entries) {
        lines.push(`| ${entry.roll} | ${entry.result} |`);
      }
      lines.push("");
    }
  }
  if (d.cursed && d.curse_description) {
    lines.push(`## Curse
`);
    lines.push(d.curse_description.trim());
    lines.push("");
  }
  if (d.sentient && d.sentient_props) {
    lines.push(`## Sentient Item
`);
    const sp = d.sentient_props;
    if (sp.intelligence != null || sp.wisdom != null || sp.charisma != null) {
      lines.push(`**Ability Scores:** INT ${sp.intelligence ?? "-"}, WIS ${sp.wisdom ?? "-"}, CHA ${sp.charisma ?? "-"}`);
    }
    if (sp.alignment) lines.push(`**Alignment:** ${sp.alignment}`);
    if (sp.senses) lines.push(`**Senses:** ${sp.senses}`);
    if (sp.communication) lines.push(`**Communication:** ${sp.communication}`);
    if (sp.languages && sp.languages.length > 0) {
      lines.push(`**Languages:** ${sp.languages.join(", ")}`);
    }
    if (sp.purpose) {
      lines.push(`**Purpose:** ${sp.purpose}`);
    }
    lines.push("");
  }
  if (d.has_variants && d.variant_info) {
    lines.push(`## Variants
`);
    lines.push(d.variant_info.trim());
    lines.push("");
  }
  if (d.notes) {
    lines.push(`## Notes
`);
    lines.push(d.notes.trim());
    lines.push("");
  }
  return lines.join("\n");
}
async function createItemFile(app, d) {
  return ITEM_PIPELINE.create(app, d);
}
async function loadItemFile(app, file) {
  const cache = app.metadataCache.getFileCache(file);
  const frontmatter = cache?.frontmatter || {};
  const data = {
    name: frontmatter.name || file.basename,
    category: frontmatter.category,
    type: frontmatter.type,
    rarity: frontmatter.rarity,
    attunement: frontmatter.attunement,
    attunement_req: frontmatter.attunement_req,
    max_charges: frontmatter.max_charges,
    recharge_formula: frontmatter.recharge_formula,
    recharge_time: frontmatter.recharge_time,
    destruction_risk: frontmatter.destruction_risk,
    spell_storage_capacity: frontmatter.spell_storage_capacity,
    resistances: frontmatter.resistances,
    immunities: frontmatter.immunities,
    cursed: frontmatter.cursed,
    curse_description: frontmatter.curse_description,
    has_variants: frontmatter.has_variants,
    variant_info: frontmatter.variant_info,
    sentient: frontmatter.sentient,
    weight: frontmatter.weight,
    value: frontmatter.value
  };
  if (frontmatter.spells_json) {
    try {
      data.spells = JSON.parse(frontmatter.spells_json);
    } catch {
    }
  }
  if (frontmatter.bonuses_json) {
    try {
      data.bonuses = JSON.parse(frontmatter.bonuses_json);
    } catch {
    }
  }
  if (frontmatter.ability_changes_json) {
    try {
      data.ability_changes = JSON.parse(frontmatter.ability_changes_json);
    } catch {
    }
  }
  if (frontmatter.speed_changes_json) {
    try {
      data.speed_changes = JSON.parse(frontmatter.speed_changes_json);
    } catch {
    }
  }
  if (frontmatter.properties_json) {
    try {
      data.properties = JSON.parse(frontmatter.properties_json);
    } catch {
    }
  }
  if (frontmatter.usage_limit_json) {
    try {
      data.usage_limit = JSON.parse(frontmatter.usage_limit_json);
    } catch {
    }
  }
  if (frontmatter.tables_json) {
    try {
      data.tables = JSON.parse(frontmatter.tables_json);
    } catch {
    }
  }
  if (frontmatter.sentient_props_json) {
    try {
      data.sentient_props = JSON.parse(frontmatter.sentient_props_json);
    } catch {
    }
  }
  const content = await app.vault.read(file);
  const bodyMatch = content.match(/^---[\s\S]*?---\s*\n([\s\S]*)/);
  if (bodyMatch) {
    data.description = bodyMatch[1].trim();
  }
  return data;
}
var ITEMS_DIR, ITEM_PIPELINE, ensureItemDir, listItemFiles, watchItemDir;
var init_item_files = __esm({
  "src/apps/library/core/item-files.ts"() {
    "use strict";
    init_file_pipeline();
    ITEMS_DIR = "SaltMarcher/Items";
    ITEM_PIPELINE = createVaultFilePipeline({
      dir: ITEMS_DIR,
      defaultBaseName: "Item",
      getBaseName: (data) => data.name,
      toContent: itemToMarkdown,
      sanitizeName: (name) => sanitizeVaultFileName(name, "Item")
    });
    ensureItemDir = ITEM_PIPELINE.ensure;
    listItemFiles = ITEM_PIPELINE.list;
    watchItemDir = ITEM_PIPELINE.watch;
  }
});

// src/apps/library/core/equipment-files.ts
function yamlList4(items) {
  if (!items || items.length === 0) return void 0;
  const safe = items.map((s) => `"${(s ?? "").replace(/"/g, '\\"')}"`).join(", ");
  return `[${safe}]`;
}
function equipmentToMarkdown(d) {
  const lines = [];
  const name = d.name || "Unnamed Equipment";
  lines.push("---");
  lines.push("smType: equipment");
  lines.push(`name: "${name.replace(/"/g, '\\"')}"`);
  lines.push(`type: "${d.type}"`);
  if (d.cost) lines.push(`cost: "${d.cost}"`);
  if (d.weight) lines.push(`weight: "${d.weight}"`);
  if (d.weapon_category) lines.push(`weapon_category: "${d.weapon_category}"`);
  if (d.weapon_type) lines.push(`weapon_type: "${d.weapon_type}"`);
  if (d.damage) lines.push(`damage: "${d.damage}"`);
  const propertiesYaml = yamlList4(d.properties);
  if (propertiesYaml) lines.push(`properties: ${propertiesYaml}`);
  if (d.mastery) lines.push(`mastery: "${d.mastery}"`);
  if (d.armor_category) lines.push(`armor_category: "${d.armor_category}"`);
  if (d.ac) lines.push(`ac: "${d.ac}"`);
  if (d.strength_requirement) lines.push(`strength_requirement: "${d.strength_requirement}"`);
  if (d.stealth_disadvantage != null) lines.push(`stealth_disadvantage: ${!!d.stealth_disadvantage}`);
  if (d.don_time) lines.push(`don_time: "${d.don_time}"`);
  if (d.doff_time) lines.push(`doff_time: "${d.doff_time}"`);
  if (d.tool_category) lines.push(`tool_category: "${d.tool_category}"`);
  if (d.ability) lines.push(`ability: "${d.ability}"`);
  const utilizeYaml = yamlList4(d.utilize);
  if (utilizeYaml) lines.push(`utilize: ${utilizeYaml}`);
  const craftYaml = yamlList4(d.craft);
  if (craftYaml) lines.push(`craft: ${craftYaml}`);
  const variantsYaml = yamlList4(d.variants);
  if (variantsYaml) lines.push(`variants: ${variantsYaml}`);
  if (d.gear_category) lines.push(`gear_category: "${d.gear_category}"`);
  if (d.special_use) lines.push(`special_use: "${d.special_use.replace(/"/g, '\\"')}"`);
  if (d.capacity) lines.push(`capacity: "${d.capacity}"`);
  if (d.duration) lines.push(`duration: "${d.duration}"`);
  lines.push("---\n");
  lines.push(`# ${name}`);
  const typeParts = [];
  if (d.type === "weapon") {
    if (d.weapon_category) typeParts.push(d.weapon_category);
    if (d.weapon_type) typeParts.push(d.weapon_type);
    typeParts.push("Weapon");
  } else if (d.type === "armor") {
    if (d.armor_category) typeParts.push(d.armor_category);
    typeParts.push("Armor");
  } else if (d.type === "tool") {
    if (d.tool_category) typeParts.push(d.tool_category);
    typeParts.push("Tool");
  } else if (d.type === "gear") {
    typeParts.push("Adventuring Gear");
    if (d.gear_category) typeParts.push(`(${d.gear_category})`);
  }
  if (typeParts.length > 0) {
    lines.push(`*${typeParts.join(" ")}*`);
  }
  lines.push("");
  const stats = [];
  if (d.cost) stats.push(`- **Cost:** ${d.cost}`);
  if (d.weight) stats.push(`- **Weight:** ${d.weight}`);
  if (stats.length > 0) {
    lines.push(...stats);
    lines.push("");
  }
  if (d.type === "weapon") {
    if (d.damage) {
      lines.push(`**Damage:** ${d.damage}`);
      lines.push("");
    }
    if (d.properties && d.properties.length > 0) {
      lines.push(`**Properties:** ${d.properties.join(", ")}`);
      lines.push("");
    }
    if (d.mastery) {
      lines.push(`**Mastery:** ${d.mastery}`);
      lines.push("");
    }
  }
  if (d.type === "armor") {
    if (d.ac) {
      lines.push(`**Armor Class (AC):** ${d.ac}`);
      lines.push("");
    }
    if (d.strength_requirement) {
      lines.push(`**Strength Requirement:** ${d.strength_requirement}`);
      lines.push("");
    }
    if (d.stealth_disadvantage) {
      lines.push(`**Stealth:** Disadvantage`);
      lines.push("");
    }
    if (d.don_time || d.doff_time) {
      const timeParts = [];
      if (d.don_time) timeParts.push(`Don: ${d.don_time}`);
      if (d.doff_time) timeParts.push(`Doff: ${d.doff_time}`);
      lines.push(`**Time:** ${timeParts.join(", ")}`);
      lines.push("");
    }
  }
  if (d.type === "tool") {
    if (d.ability) {
      lines.push(`**Ability:** ${d.ability}`);
      lines.push("");
    }
    if (d.utilize && d.utilize.length > 0) {
      lines.push(`## Utilize`);
      lines.push("");
      for (const use of d.utilize) {
        lines.push(`- ${use}`);
      }
      lines.push("");
    }
    if (d.craft && d.craft.length > 0) {
      lines.push(`## Craft`);
      lines.push("");
      lines.push(d.craft.join(", "));
      lines.push("");
    }
    if (d.variants && d.variants.length > 0) {
      lines.push(`## Variants`);
      lines.push("");
      for (const variant of d.variants) {
        lines.push(`- ${variant}`);
      }
      lines.push("");
    }
  }
  if (d.type === "gear") {
    if (d.capacity) {
      lines.push(`**Capacity:** ${d.capacity}`);
      lines.push("");
    }
    if (d.duration) {
      lines.push(`**Duration:** ${d.duration}`);
      lines.push("");
    }
    if (d.special_use) {
      lines.push(`## Special Use`);
      lines.push("");
      lines.push(d.special_use);
      lines.push("");
    }
  }
  if (d.description) {
    lines.push(d.description.trim());
    lines.push("");
  }
  return lines.join("\n");
}
async function createEquipmentFile(app, d) {
  return EQUIPMENT_PIPELINE.create(app, d);
}
async function loadEquipmentFile(app, file) {
  const cache = app.metadataCache.getFileCache(file);
  const frontmatter = cache?.frontmatter || {};
  const data = {
    name: frontmatter.name || file.basename,
    type: frontmatter.type || "weapon",
    cost: frontmatter.cost,
    weight: frontmatter.weight,
    weapon_category: frontmatter.weapon_category,
    weapon_type: frontmatter.weapon_type,
    damage: frontmatter.damage,
    properties: frontmatter.properties,
    mastery: frontmatter.mastery,
    armor_category: frontmatter.armor_category,
    ac: frontmatter.ac,
    strength_requirement: frontmatter.strength_requirement,
    stealth_disadvantage: frontmatter.stealth_disadvantage,
    don_time: frontmatter.don_time,
    doff_time: frontmatter.doff_time,
    tool_category: frontmatter.tool_category,
    ability: frontmatter.ability,
    utilize: frontmatter.utilize,
    craft: frontmatter.craft,
    variants: frontmatter.variants,
    gear_category: frontmatter.gear_category,
    special_use: frontmatter.special_use,
    capacity: frontmatter.capacity,
    duration: frontmatter.duration
  };
  const content = await app.vault.read(file);
  const bodyMatch = content.match(/^---[\s\S]*?---\s*\n([\s\S]*)/);
  if (bodyMatch) {
    data.description = bodyMatch[1].trim();
  }
  return data;
}
var EQUIPMENT_DIR, EQUIPMENT_PIPELINE, ensureEquipmentDir, listEquipmentFiles, watchEquipmentDir;
var init_equipment_files = __esm({
  "src/apps/library/core/equipment-files.ts"() {
    "use strict";
    init_file_pipeline();
    EQUIPMENT_DIR = "SaltMarcher/Equipment";
    EQUIPMENT_PIPELINE = createVaultFilePipeline({
      dir: EQUIPMENT_DIR,
      defaultBaseName: "Equipment",
      getBaseName: (data) => data.name,
      toContent: equipmentToMarkdown,
      sanitizeName: (name) => sanitizeVaultFileName(name, "Equipment")
    });
    ensureEquipmentDir = EQUIPMENT_PIPELINE.ensure;
    listEquipmentFiles = EQUIPMENT_PIPELINE.list;
    watchEquipmentDir = EQUIPMENT_PIPELINE.watch;
  }
});

// src/apps/library/create/creature/entry-model.ts
function inferEntryType(entry) {
  if (entry.entryType) return entry.entryType;
  if (entry.spellGroups || entry.spellAbility) return "spellcasting";
  if (entry.to_hit || entry.to_hit_from || entry.damage || entry.damage_from || entry.kind) {
    return "attack";
  }
  if (entry.save_ability && entry.save_dc) return "save-action";
  if (entry.name?.toLowerCase().includes("multiattack")) return "multiattack";
  if (entry.category === "trait") return "passive";
  return "passive";
}
function validateEntry(entry, index) {
  const issues = [];
  const label = entry.name?.trim() || `Eintrag ${index + 1}`;
  if (entry.save_ability && (entry.save_dc == null || Number.isNaN(entry.save_dc))) {
    issues.push(`${label}: Save-DC angeben, wenn ein Attribut gew\xE4hlt wurde.`);
  }
  if (entry.save_dc != null && !Number.isNaN(entry.save_dc) && !entry.save_ability) {
    issues.push(`${label}: Ein Save-DC ben\xF6tigt ein Attribut.`);
  }
  if (entry.save_effect && !entry.save_ability) {
    issues.push(`${label}: Save-Effekt ohne Attribut ist unklar.`);
  }
  if (entry.to_hit_from && !entry.to_hit_from.ability) {
    issues.push(`${label}: Automatische Attacke ben\xF6tigt ein Attribut.`);
  }
  if (entry.damage_from && !entry.damage_from.dice?.trim()) {
    issues.push(`${label}: Automatischer Schaden ben\xF6tigt W\xFCrfelangaben.`);
  }
  return issues;
}
function spellcastingDataToEntry(spellcastingData) {
  const groups = [];
  for (const group of spellcastingData.groups || []) {
    if (group.type === "at-will") {
      groups.push({
        type: "at-will",
        label: group.title || "At Will",
        spells: (group.spells || []).map((s) => s.name || s)
      });
    } else if (group.type === "per-day") {
      groups.push({
        type: "per-day",
        label: group.uses || "1/Day each",
        spells: (group.spells || []).map((s) => s.name || s)
      });
    } else if (group.type === "level") {
      groups.push({
        type: "level",
        level: group.level || 1,
        slots: group.slots,
        label: group.title,
        spells: (group.spells || []).map((s) => s.name || s)
      });
    }
  }
  return {
    category: "action",
    entryType: "spellcasting",
    name: spellcastingData.title || "Spellcasting",
    text: spellcastingData.summary,
    spellAbility: spellcastingData.ability,
    spellDcOverride: spellcastingData.saveDcOverride,
    spellAttackOverride: spellcastingData.attackBonusOverride,
    spellGroups: groups
  };
}
var init_entry_model = __esm({
  "src/apps/library/create/creature/entry-model.ts"() {
    "use strict";
  }
});

// src/apps/library/core/creature-presets.ts
var creature_presets_exports = {};
__export(creature_presets_exports, {
  PRESETS_DIR: () => PRESETS_DIR,
  ensurePresetDir: () => ensurePresetDir,
  findCreaturePresets: () => findCreaturePresets,
  getPresetCategories: () => getPresetCategories,
  listPresetFiles: () => listPresetFiles,
  loadCreaturePreset: () => loadCreaturePreset,
  watchPresetDir: () => watchPresetDir
});
function parseAlignment(text) {
  if (!text) return {};
  const normalized = text.toLowerCase().trim();
  if (normalized === "unaligned" || normalized === "any alignment") {
    return { override: text };
  }
  if (normalized === "neutral") {
    return { lawChaos: "Neutral", goodEvil: "Neutral" };
  }
  const words = text.split(/\s+/);
  if (words.length === 2) {
    return { lawChaos: words[0], goodEvil: words[1] };
  } else if (words.length === 1) {
    const word = words[0];
    if (["Good", "Evil"].some((w) => w.toLowerCase() === word.toLowerCase())) {
      return { goodEvil: word };
    } else if (["Lawful", "Chaotic"].some((w) => w.toLowerCase() === word.toLowerCase())) {
      return { lawChaos: word };
    }
  }
  return { override: text };
}
function calculatePBFromCR(cr) {
  if (!cr) return void 0;
  let crValue;
  if (cr.includes("/")) {
    const [num, denom] = cr.split("/").map(Number);
    crValue = num / denom;
  } else {
    crValue = Number(cr);
  }
  if (isNaN(crValue)) return void 0;
  if (crValue <= 4) return "+2";
  if (crValue <= 8) return "+3";
  if (crValue <= 12) return "+4";
  if (crValue <= 16) return "+5";
  if (crValue <= 20) return "+6";
  if (crValue <= 24) return "+7";
  if (crValue <= 28) return "+8";
  return "+9";
}
async function loadCreaturePreset(app, file) {
  const cache = app.metadataCache.getFileCache(file);
  if (!cache?.frontmatter) {
    throw new Error(`No frontmatter found in ${file.path}`);
  }
  const fm2 = cache.frontmatter;
  const parseJson = (value, fieldName) => {
    if (!value) return void 0;
    try {
      return JSON.parse(value);
    } catch (err) {
      console.warn(`Failed to parse ${fieldName}:`, err);
      return void 0;
    }
  };
  const alignmentParts = parseAlignment(fm2.alignment);
  const abilities = fm2.abilities_json ? parseJson(fm2.abilities_json, "abilities_json") : void 0;
  let initiative = fm2.initiative;
  if (!initiative && abilities) {
    const dexAbility = abilities.find((a) => a.ability === "dex");
    if (dexAbility) {
      const modifier = Math.floor((dexAbility.score - 10) / 2);
      initiative = modifier >= 0 ? `+${modifier}` : `${modifier}`;
    }
  }
  const data = {
    // Basic identity
    name: fm2.name ?? file.basename,
    size: fm2.size,
    type: fm2.type,
    typeTags: fm2.type_tags ?? fm2.typeTags,
    // Alignment (use explicit fields or parse from combined)
    alignmentLawChaos: fm2.alignmentLawChaos ?? alignmentParts.lawChaos,
    alignmentGoodEvil: fm2.alignmentGoodEvil ?? alignmentParts.goodEvil,
    alignmentOverride: fm2.alignmentOverride ?? alignmentParts.override,
    // Combat stats
    ac: fm2.ac,
    initiative,
    hp: fm2.hp,
    hitDice: fm2.hit_dice ?? fm2.hitDice,
    // Abilities
    abilities,
    pb: fm2.pb ?? calculatePBFromCR(fm2.cr),
    // Fallback: berechne aus CR
    // CR & XP
    cr: fm2.cr,
    xp: fm2.xp,
    // Speeds
    speeds: fm2.speeds_json ? parseJson(fm2.speeds_json, "speeds_json") : void 0,
    // Saves & Skills
    saves: fm2.saves_json ? parseJson(fm2.saves_json, "saves_json") : void 0,
    skills: fm2.skills_json ? parseJson(fm2.skills_json, "skills_json") : void 0,
    // Senses & Languages
    sensesList: fm2.senses,
    languagesList: fm2.languages,
    passivesList: fm2.passives,
    // Defenses
    damageVulnerabilitiesList: fm2.damage_vulnerabilities,
    damageResistancesList: fm2.damage_resistances,
    damageImmunitiesList: fm2.damage_immunities,
    conditionImmunitiesList: fm2.condition_immunities,
    gearList: fm2.gear,
    // Entries & Spellcasting (JSON fields)
    entries: fm2.entries_structured_json ? parseJson(fm2.entries_structured_json, "entries_structured_json") : void 0,
    spellcasting: fm2.spellcasting_json ? parseJson(fm2.spellcasting_json, "spellcasting_json") : void 0,
    // Legacy fields
    traits: fm2.traits,
    actions: fm2.actions,
    legendary: fm2.legendary
  };
  if (!data.speeds && (fm2.speed_walk || fm2.speed_fly || fm2.speed_swim || fm2.speed_climb || fm2.speed_burrow)) {
    data.speeds = {};
    if (fm2.speed_walk) data.speeds.walk = { distance: fm2.speed_walk };
    if (fm2.speed_fly) {
      data.speeds.fly = {
        distance: fm2.speed_fly,
        hover: fm2.speed_fly_hover === true || fm2.speed_fly_hover === "true"
      };
    }
    if (fm2.speed_swim) data.speeds.swim = { distance: fm2.speed_swim };
    if (fm2.speed_climb) data.speeds.climb = { distance: fm2.speed_climb };
    if (fm2.speed_burrow) data.speeds.burrow = { distance: fm2.speed_burrow };
  }
  if (data.spellcasting && !data.entries) {
    try {
      console.log(`[Preset Migration] Migrating spellcasting data for ${data.name}`);
      const spellEntry = spellcastingDataToEntry(data.spellcasting);
      if (!spellEntry.name) {
        spellEntry.name = "Spellcasting";
      }
      data.entries = [spellEntry];
      delete data.spellcasting;
      console.log(`[Preset Migration] Successfully migrated spellcasting for ${data.name}`);
    } catch (err) {
      console.error(`[Preset Migration] Failed to migrate spellcasting for ${data.name}:`, err);
    }
  } else if (data.spellcasting && data.entries) {
    const hasSpellcastingEntry = data.entries.some(
      (entry) => entry.entryType === "spellcasting" || entry.spellGroups || entry.spellAbility
    );
    if (!hasSpellcastingEntry) {
      try {
        console.log(`[Preset Migration] Adding missing spellcasting entry for ${data.name}`);
        const spellEntry = spellcastingDataToEntry(data.spellcasting);
        if (!spellEntry.name) {
          spellEntry.name = "Spellcasting";
        }
        data.entries.push(spellEntry);
        delete data.spellcasting;
        console.log(`[Preset Migration] Successfully added spellcasting entry for ${data.name}`);
      } catch (err) {
        console.error(`[Preset Migration] Failed to add spellcasting entry for ${data.name}:`, err);
      }
    } else {
      console.log(`[Preset Migration] Removing duplicate spellcasting_json for ${data.name}`);
      delete data.spellcasting;
    }
  }
  console.log("[Preset Loader] Loaded preset:", data.name, {
    type: data.type,
    size: data.size,
    typeTags: data.typeTags,
    alignmentLawChaos: data.alignmentLawChaos,
    alignmentGoodEvil: data.alignmentGoodEvil,
    alignmentOverride: data.alignmentOverride,
    initiative: data.initiative,
    pb: data.pb,
    hasEntries: !!data.entries,
    entriesCount: data.entries?.length ?? 0,
    hasSpellcasting: !!data.spellcasting,
    hasSpeeds: !!data.speeds,
    hasSaves: !!data.saves,
    hasSkills: !!data.skills,
    hasSenses: !!data.sensesList,
    hasLanguages: !!data.languagesList,
    hasPassives: !!data.passivesList
  });
  return data;
}
async function findCreaturePresets(app, query, options = {}) {
  const { limit = 10, category } = options;
  const files = await listPresetFiles(app);
  const results = [];
  for (const file of files) {
    if (category) {
      const inCategory = file.path.includes(`/${category}/`);
      if (!inCategory) continue;
    }
    const name = file.basename.toLowerCase();
    const q = query.toLowerCase();
    let score = 0;
    if (name === q) {
      score = 1e3;
    } else if (name.startsWith(q)) {
      score = 900 - Math.abs(name.length - q.length);
    } else if (name.includes(q)) {
      score = 700 - name.indexOf(q);
    } else {
      const tokens = name.split(/[\s-]/);
      for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].startsWith(q)) {
          score = 600 - i * 10;
          break;
        }
      }
    }
    if (score > 0) {
      try {
        const data = await loadCreaturePreset(app, file);
        results.push({ file, data, score });
      } catch (err) {
        console.warn(`Failed to load preset ${file.path}:`, err);
      }
    }
    if (results.length >= limit * 2) break;
  }
  results.sort((a, b) => b.score - a.score);
  return results.slice(0, limit);
}
async function getPresetCategories(app) {
  const files = await listPresetFiles(app);
  const categories = /* @__PURE__ */ new Set();
  for (const file of files) {
    const match = file.path.match(/\/Presets\/Creatures\/([^/]+)\//);
    if (match) {
      categories.add(match[1]);
    }
  }
  return Array.from(categories).sort();
}
var PRESETS_DIR, PRESET_PIPELINE, ensurePresetDir, listPresetFiles, watchPresetDir;
var init_creature_presets = __esm({
  "src/apps/library/core/creature-presets.ts"() {
    "use strict";
    init_file_pipeline();
    init_entry_model();
    PRESETS_DIR = "SaltMarcher/Presets/Creatures";
    PRESET_PIPELINE = createVaultFilePipeline({
      dir: PRESETS_DIR,
      defaultBaseName: "Preset",
      getBaseName: (data) => data.name,
      toContent: () => "",
      // Presets werden nicht geschrieben, nur gelesen
      sanitizeName: (name) => name.replace(/[\\/:*?"<>|]/g, "-")
    });
    ensurePresetDir = PRESET_PIPELINE.ensure;
    listPresetFiles = PRESET_PIPELINE.list;
    watchPresetDir = PRESET_PIPELINE.watch;
  }
});

// src/apps/library/core/preset-data.ts
var preset_data_exports = {};
__export(preset_data_exports, {
  PRESET_CREATURES: () => PRESET_CREATURES,
  PRESET_EQUIPMENT: () => PRESET_EQUIPMENT,
  PRESET_ITEMS: () => PRESET_ITEMS,
  PRESET_SPELLS: () => PRESET_SPELLS
});
var PRESET_CREATURES, PRESET_SPELLS, PRESET_ITEMS, PRESET_EQUIPMENT;
var init_preset_data = __esm({
  "src/apps/library/core/preset-data.ts"() {
    "use strict";
    PRESET_CREATURES = {
      "allosaurus.md": `---
smType: creature
name: "Allosaurus"
size: "Large"
type: "Beast"
type_tags: ["Dinosaur"]
alignment: "Unaligned"
ac: "13"
hp: "51"
hit_dice: "6d10 + 18"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 15 (2d10 + 4) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claws\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 8 (1d8 + 4) Slashing damage. If the target is a Large or smaller creature and the allosaurus moved 30+ feet straight toward it immediately before the hit, the target has the Prone condition, and the allosaurus can make one Bite attack against it.\\"}]"
---

# Allosaurus
*Large, Beast, Unaligned*

**AC** 13
**HP** 51 (6d10 + 18)
**Speed** 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 13 | 17 | 2 | 12 | 5 |

CR 2, PB +2, XP 450

## Actions

**Bite**
*Melee Attack Roll:* +6, reach 5 ft. 15 (2d10 + 4) Piercing damage.

**Claws**
*Melee Attack Roll:* +6, reach 5 ft. 8 (1d8 + 4) Slashing damage. If the target is a Large or smaller creature and the allosaurus moved 30+ feet straight toward it immediately before the hit, the target has the Prone condition, and the allosaurus can make one Bite attack against it.
`,
      "ankylosaurus.md": `---
smType: creature
name: "Ankylosaurus"
size: "Huge"
type: "Beast"
type_tags: ["Dinosaur"]
alignment: "Unaligned"
ac: "15"
hp: "68"
hit_dice: "8d12 + 16"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":6}]"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The ankylosaurus makes two Tail attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tail\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 10 ft. 9 (1d10 + 4) Bludgeoning damage. If the target is a Huge or smaller creature, it has the Prone condition.\\"}]"
---

# Ankylosaurus
*Huge, Beast, Unaligned*

**AC** 15
**HP** 68 (8d12 + 16)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 11 | 15 | 2 | 12 | 5 |

CR 3, PB +2, XP 700

## Actions

**Multiattack**
The ankylosaurus makes two Tail attacks.

**Tail**
*Melee Attack Roll:* +6, reach 10 ft. 9 (1d10 + 4) Bludgeoning damage. If the target is a Huge or smaller creature, it has the Prone condition.
`,
      "ape.md": `---
smType: creature
name: "Ape"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "19"
hit_dice: "3d8 + 6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The ape makes two Fist attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fist\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Bludgeoning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rock\\",\\"recharge\\":\\"Recharge 6\\",\\"text\\":\\"*Ranged Attack Roll:* +5, range 25/50 ft. 10 (2d6 + 3) Bludgeoning damage.\\"}]"
---

# Ape
*Medium, Beast, Unaligned*

**AC** 12
**HP** 19 (3d8 + 6)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 14 | 14 | 6 | 12 | 7 |

CR 1/2, PB +2, XP 100

## Actions

**Multiattack**
The ape makes two Fist attacks.

**Fist**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Bludgeoning damage.

**Rock (Recharge 6)**
*Ranged Attack Roll:* +5, range 25/50 ft. 10 (2d6 + 3) Bludgeoning damage.
`,
      "archelon.md": `---
smType: creature
name: "Archelon"
size: "Huge"
type: "Beast"
type_tags: ["Dinosaur"]
alignment: "Unaligned"
ac: "17"
hp: "90"
hit_dice: "12d12 + 12"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"swim\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":4},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "4"
xp: "1100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The archelon can breathe air and water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The archelon makes two Bite attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 14 (3d6 + 4) Piercing damage.\\"}]"
---

# Archelon
*Huge, Beast, Unaligned*

**AC** 17
**HP** 90 (12d12 + 12)
**Speed** 20 ft., swim 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 16 | 13 | 4 | 14 | 6 |

CR 4, PB +2, XP 1100

## Traits

**Amphibious**
The archelon can breathe air and water.

## Actions

**Multiattack**
The archelon makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +6, reach 5 ft. 14 (3d6 + 4) Piercing damage.
`,
      "baboon.md": `---
smType: creature
name: "Baboon"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "3"
hit_dice: "1d6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":8},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":4},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The baboon has Advantage on an attack roll against a creature if at least one of the baboon's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +1, reach 5 ft. 1 (1d4 - 1) Piercing damage.\\"}]"
---

# Baboon
*Small, Beast, Unaligned*

**AC** 12
**HP** 3 (1d6)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 8 | 14 | 11 | 4 | 12 | 6 |

CR 0, PB +2, XP 0

## Traits

**Pack Tactics**
The baboon has Advantage on an attack roll against a creature if at least one of the baboon's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Bite**
*Melee Attack Roll:* +1, reach 5 ft. 1 (1d4 - 1) Piercing damage.
`,
      "badger.md": `---
smType: creature
name: "Badger"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "11"
hp: "5"
hit_dice: "1d4 + 3"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"burrow\\":{\\"distance\\":\\"5 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +2, reach 5 ft. 1 Piercing damage.\\"}]"
---

# Badger
*Small, Beast, Unaligned*

**AC** 11
**HP** 5 (1d4 + 3)
**Speed** 20 ft., burrow 5 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 11 | 16 | 2 | 12 | 5 |

CR 0, PB +2, XP 0

## Actions

**Bite**
*Melee Attack Roll:* +2, reach 5 ft. 1 Piercing damage.
`,
      "bat.md": `---
smType: creature
name: "Bat"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "1"
hit_dice: "1d4 - 1"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"},\\"fly\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":2},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":8},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":4}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4 to hit, reach 5 ft. 1 Piercing damage.\\"}]"
---

# Bat
*Small, Beast, Unaligned*

**AC** 12
**HP** 1 (1d4 - 1)
**Speed** 5 ft., fly 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 2 | 15 | 8 | 2 | 12 | 4 |

CR 0, PB +2, XP 0

## Actions

**Bite**
*Melee Attack Roll:* +4 to hit, reach 5 ft. 1 Piercing damage.
`,
      "black-bear.md": `---
smType: creature
name: "Black Bear"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "11"
hp: "19"
hit_dice: "3d8 + 6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The bear makes two Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage.\\"}]"
---

# Black Bear
*Medium, Beast, Unaligned*

**AC** 11
**HP** 19 (3d8 + 6)
**Speed** 30 ft., climb 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 12 | 14 | 2 | 12 | 7 |

CR 1/2, PB +2, XP 100

## Actions

**Multiattack**
The bear makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage.
`,
      "blood-hawk.md": `---
smType: creature
name: "Blood Hawk"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "7"
hit_dice: "2d6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":6},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The hawk has Advantage on an attack roll against a creature if at least one of the hawk's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Beak\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage, or 6 (1d8 + 2) Piercing damage if the target is Bloodied.\\"}]"
---

# Blood Hawk
*Small, Beast, Unaligned*

**AC** 12
**HP** 7 (2d6)
**Speed** 10 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 6 | 14 | 10 | 3 | 14 | 5 |

CR 1/8, PB +2, XP 25

## Traits

**Pack Tactics**
The hawk has Advantage on an attack roll against a creature if at least one of the hawk's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Beak**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage, or 6 (1d8 + 2) Piercing damage if the target is Bloodied.
`,
      "boar.md": `---
smType: creature
name: "Boar"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "11"
hp: "13"
hit_dice: "2d8 + 4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":13},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":9},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Bloodied Fury\\",\\"text\\":\\"While Bloodied, the boar has Advantage on attack rolls.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Gore\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Piercing damage. If the target is a Medium or smaller creature and the boar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 3 (1d6) Piercing damage and has the Prone condition.\\"}]"
---

# Boar
*Medium, Beast, Unaligned*

**AC** 11
**HP** 13 (2d8 + 4)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 13 | 11 | 14 | 2 | 9 | 5 |

CR 1/4, PB +2, XP 50

## Traits

**Bloodied Fury**
While Bloodied, the boar has Advantage on attack rolls.

## Actions

**Gore**
*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Piercing damage. If the target is a Medium or smaller creature and the boar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 3 (1d6) Piercing damage and has the Prone condition.
`,
      "brown-bear.md": `---
smType: creature
name: "Brown Bear"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "11"
hp: "22"
hit_dice: "3d10 + 6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The bear makes one Bite attack and one Claw attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Slashing damage. If the target is a Large or smaller creature, it has the Prone condition.\\"}]"
---

# Brown Bear
*Large, Beast, Unaligned*

**AC** 11
**HP** 22 (3d10 + 6)
**Speed** 40 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 12 | 15 | 2 | 13 | 7 |

CR 1, PB +2, XP 200

## Actions

**Multiattack**
The bear makes one Bite attack and one Claw attack.

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage.

**Claw**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Slashing damage. If the target is a Large or smaller creature, it has the Prone condition.
`,
      "camel.md": `---
smType: creature
name: "Camel"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "10"
hp: "17"
hit_dice: "2d10 + 6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":8},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"con\\",\\"bonus\\":5}]"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Bludgeoning damage.\\"}]"
---

# Camel
*Large, Beast, Unaligned*

**AC** 10
**HP** 17 (2d10 + 6)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 8 | 17 | 2 | 11 | 5 |

CR 1/8, PB +2, XP 25

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Bludgeoning damage.
`,
      "cat.md": `---
smType: creature
name: "Cat"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "2"
hit_dice: "1d4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":3},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":4}]"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Jumper\\",\\"text\\":\\"The cat's jump distance is determined using its Dexterity rather than its Strength.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Scratch\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 1 Slashing damage.\\"}]"
---

# Cat
*Small, Beast, Unaligned*

**AC** 12
**HP** 2 (1d4)
**Speed** 40 ft., climb 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 3 | 15 | 10 | 3 | 12 | 7 |

CR 0, PB +2, XP 0

## Traits

**Jumper**
The cat's jump distance is determined using its Dexterity rather than its Strength.

## Actions

**Scratch**
*Melee Attack Roll:* +4, reach 5 ft. 1 Slashing damage.
`,
      "constrictor-snake.md": `---
smType: creature
name: "Constrictor Snake"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "13"
hit_dice: "2d10 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Constrict\\",\\"text\\":\\"*Strength Saving Throw*: DC 12, one Medium or smaller creature the snake can see within 5 feet. *Failure:*  7 (3d4) Bludgeoning damage, and the target has the Grappled condition (escape DC 12).\\"}]"
---

# Constrictor Snake
*Large, Beast, Unaligned*

**AC** 13
**HP** 13 (2d10 + 2)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 14 | 12 | 1 | 10 | 3 |

CR 1/4, PB +2, XP 50

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Piercing damage.

**Constrict**
*Strength Saving Throw*: DC 12, one Medium or smaller creature the snake can see within 5 feet. *Failure:*  7 (3d4) Bludgeoning damage, and the target has the Grappled condition (escape DC 12).
`,
      "crab.md": `---
smType: creature
name: "Crab"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "11"
hp: "3"
hit_dice: "1d4 + 1"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"swim\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":6},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":8},{\\"ability\\":\\"cha\\",\\"score\\":2}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The crab can breathe air and water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +2, reach 5 ft. 1 Bludgeoning damage.\\"}]"
---

# Crab
*Small, Beast, Unaligned*

**AC** 11
**HP** 3 (1d4 + 1)
**Speed** 20 ft., swim 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 6 | 11 | 12 | 1 | 8 | 2 |

CR 0, PB +2, XP 0

## Traits

**Amphibious**
The crab can breathe air and water.

## Actions

**Claw**
*Melee Attack Roll:* +2, reach 5 ft. 1 Bludgeoning damage.
`,
      "crocodile.md": `---
smType: creature
name: "Crocodile"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "13"
hit_dice: "2d10 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"con\\",\\"bonus\\":3}]"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Hold Breath\\",\\"text\\":\\"The crocodile can hold its breath for 1 hour.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Piercing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12). While Grappled, the target has the Restrained condition.\\"}]"
---

# Crocodile
*Large, Beast, Unaligned*

**AC** 12
**HP** 13 (2d10 + 2)
**Speed** 20 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 10 | 13 | 2 | 10 | 5 |

CR 1/2, PB +2, XP 100

## Traits

**Hold Breath**
The crocodile can hold its breath for 1 hour.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Piercing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12). While Grappled, the target has the Restrained condition.
`,
      "deer.md": `---
smType: creature
name: "Deer"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "4"
hit_dice: "1d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":11},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Agile\\",\\"text\\":\\"The deer doesn't provoke an Opportunity Attack when it moves out of an enemy's reach.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Ram\\",\\"text\\":\\"*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Bludgeoning damage.\\"}]"
---

# Deer
*Medium, Beast, Unaligned*

**AC** 13
**HP** 4 (1d8)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 11 | 16 | 11 | 2 | 14 | 5 |

CR 0, PB +2, XP 0

## Traits

**Agile**
The deer doesn't provoke an Opportunity Attack when it moves out of an enemy's reach.

## Actions

**Ram**
*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Bludgeoning damage.
`,
      "dire-wolf.md": `---
smType: creature
name: "Dire Wolf"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "14"
hp: "22"
hit_dice: "3d10 + 6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The wolf has Advantage on an attack roll against a creature if at least one of the wolf's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Piercing damage. If the target is a Large or smaller creature, it has the Prone condition.\\"}]"
---

# Dire Wolf
*Large, Beast, Unaligned*

**AC** 14
**HP** 22 (3d10 + 6)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 15 | 15 | 3 | 12 | 7 |

CR 1, PB +2, XP 200

## Traits

**Pack Tactics**
The wolf has Advantage on an attack roll against a creature if at least one of the wolf's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Piercing damage. If the target is a Large or smaller creature, it has the Prone condition.
`,
      "draft-horse.md": `---
smType: creature
name: "Draft Horse"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "10"
hp: "15"
hit_dice: "2d10 + 4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Hooves\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 6 (1d4 + 4) Bludgeoning damage.\\"}]"
---

# Draft Horse
*Large, Beast, Unaligned*

**AC** 10
**HP** 15 (2d10 + 4)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 10 | 15 | 2 | 11 | 7 |

CR 1/4, PB +2, XP 50

## Actions

**Hooves**
*Melee Attack Roll:* +6, reach 5 ft. 6 (1d4 + 4) Bludgeoning damage.
`,
      "eagle.md": `---
smType: creature
name: "Eagle"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "4"
hit_dice: "1d6 + 1"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":6},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Talons\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 feet. 4 (1d4 + 2) Slashing damage.\\"}]"
---

# Eagle
*Small, Beast, Unaligned*

**AC** 12
**HP** 4 (1d6 + 1)
**Speed** 10 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 6 | 15 | 12 | 2 | 14 | 7 |

CR 0, PB +2, XP 0

## Actions

**Talons**
*Melee Attack Roll:* +4, reach 5 feet. 4 (1d4 + 2) Slashing damage.
`,
      "elephant.md": `---
smType: creature
name: "Elephant"
size: "Huge"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "76"
hit_dice: "8d12 + 24"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":22},{\\"ability\\":\\"dex\\",\\"score\\":9},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "4"
xp: "1100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The elephant makes two Gore attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Gore\\",\\"text\\":\\"*Melee Attack Roll:* +8, reach 5 ft. 15 (2d8 + 6) Piercing damage. If the target is a Huge or smaller creature and the elephant moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Trample\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 16, one creature within 5 feet that has the Prone condition. *Failure:*  17 (2d10 + 6) Bludgeoning damage. *Success:*  Half damage.\\"}]"
---

# Elephant
*Huge, Beast, Unaligned*

**AC** 12
**HP** 76 (8d12 + 24)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 22 | 9 | 17 | 3 | 11 | 6 |

CR 4, PB +2, XP 1100

## Actions

**Multiattack**
The elephant makes two Gore attacks.

**Gore**
*Melee Attack Roll:* +8, reach 5 ft. 15 (2d8 + 6) Piercing damage. If the target is a Huge or smaller creature and the elephant moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.

## Bonus Actions

**Trample**
*Dexterity Saving Throw*: DC 16, one creature within 5 feet that has the Prone condition. *Failure:*  17 (2d10 + 6) Bludgeoning damage. *Success:*  Half damage.
`,
      "elk.md": `---
smType: creature
name: "Elk"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "10"
hp: "11"
hit_dice: "2d10"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Ram\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage. If the target is a Large or smaller creature and the elk moved 20+ feet straight toward it immediately before the hit, the target takes an extra 3 (1d6) Bludgeoning damage and has the Prone condition.\\"}]"
---

# Elk
*Large, Beast, Unaligned*

**AC** 10
**HP** 11 (2d10)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 10 | 11 | 2 | 10 | 6 |

CR 1/4, PB +2, XP 50

## Actions

**Ram**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage. If the target is a Large or smaller creature and the elk moved 20+ feet straight toward it immediately before the hit, the target takes an extra 3 (1d6) Bludgeoning damage and has the Prone condition.
`,
      "flying-snake.md": `---
smType: creature
name: "Flying Snake"
size: "Small"
type: "Monstrosity"
alignment: "Unaligned"
ac: "14"
hp: "5"
hit_dice: "2d4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":4},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Flyby\\",\\"text\\":\\"The snake doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 1 Piercing damage plus 5 (2d4) Poison damage.\\"}]"
---

# Flying Snake
*Small, Monstrosity, Unaligned*

**AC** 14
**HP** 5 (2d4)
**Speed** 30 ft., swim 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 4 | 15 | 11 | 2 | 12 | 5 |

CR 1/8, PB +2, XP 25

## Traits

**Flyby**
The snake doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 1 Piercing damage plus 5 (2d4) Poison damage.
`,
      "frog.md": `---
smType: creature
name: "Frog"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "11"
hp: "1"
hit_dice: "1d4 - 1"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"swim\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":1},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":8},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":8},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The frog can breathe air and water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Standing Leap\\",\\"text\\":\\"The frog's Long Jump is up to 10 feet and its High Jump is up to 5 feet with or without a running start.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 1 Piercing damage.\\"}]"
---

# Frog
*Small, Beast, Unaligned*

**AC** 11
**HP** 1 (1d4 - 1)
**Speed** 20 ft., swim 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 1 | 13 | 8 | 1 | 8 | 3 |

CR 0, PB +2, XP 0

## Traits

**Amphibious**
The frog can breathe air and water.

**Standing Leap**
The frog's Long Jump is up to 10 feet and its High Jump is up to 5 feet with or without a running start.

## Actions

**Bite**
*Melee Attack Roll:* +3, reach 5 ft. 1 Piercing damage.
`,
      "giant-ape.md": `---
smType: creature
name: "Giant Ape"
size: "Huge"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "168"
hit_dice: "16d12 + 64"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":23},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":5},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+3"
cr: "7"
xp: "2900"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The ape makes two Fist attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fist\\",\\"text\\":\\"*Melee Attack Roll:* +9, reach 10 ft. 22 (3d10 + 6) Bludgeoning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Boulder Toss\\",\\"recharge\\":\\"Recharge 6\\",\\"text\\":\\"The ape hurls a boulder at a point it can see within 90 feet. *Dexterity Saving Throw*: DC 17, each creature in a 5-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on that point. *Failure:*  24 (7d6) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition. *Success:*  Half damage only.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Leap\\",\\"text\\":\\"The ape jumps up to 30 feet by spending 10 feet of movement.\\"}]"
---

# Giant Ape
*Huge, Beast, Unaligned*

**AC** 12
**HP** 168 (16d12 + 64)
**Speed** 40 ft., climb 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 23 | 14 | 18 | 5 | 12 | 7 |

CR 7, PB +3, XP 2900

## Actions

**Multiattack**
The ape makes two Fist attacks.

**Fist**
*Melee Attack Roll:* +9, reach 10 ft. 22 (3d10 + 6) Bludgeoning damage.

**Boulder Toss (Recharge 6)**
The ape hurls a boulder at a point it can see within 90 feet. *Dexterity Saving Throw*: DC 17, each creature in a 5-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on that point. *Failure:*  24 (7d6) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition. *Success:*  Half damage only.

## Bonus Actions

**Leap**
The ape jumps up to 30 feet by spending 10 feet of movement.
`,
      "giant-badger.md": `---
smType: creature
name: "Giant Badger"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "15"
hit_dice: "2d8 + 6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"burrow\\":{\\"distance\\":\\"10 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":13},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 6 (2d4 + 1) Piercing damage.\\"}]"
---

# Giant Badger
*Medium, Beast, Unaligned*

**AC** 13
**HP** 15 (2d8 + 6)
**Speed** 30 ft., burrow 10 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 13 | 10 | 17 | 2 | 12 | 5 |

CR 1/4, PB +2, XP 50

## Actions

**Bite**
*Melee Attack Roll:* +3, reach 5 ft. 6 (2d4 + 1) Piercing damage.
`,
      "giant-bat.md": `---
smType: creature
name: "Giant Bat"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "22"
hit_dice: "4d10"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Piercing damage.\\"}]"
---

# Giant Bat
*Large, Beast, Unaligned*

**AC** 13
**HP** 22 (4d10)
**Speed** 10 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 16 | 11 | 2 | 12 | 6 |

CR 1/4, PB +2, XP 50

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Piercing damage.
`,
      "giant-boar.md": `---
smType: creature
name: "Giant Boar"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "42"
hit_dice: "5d10 + 15"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":7},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":5}]"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Bloodied Fury\\",\\"text\\":\\"The boar has Advantage on melee attack rolls while it is Bloodied.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Gore\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Piercing damage. If the target is a Large or smaller creature and the boar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 7 (2d6) Piercing damage and has the Prone condition.\\"}]"
---

# Giant Boar
*Large, Beast, Unaligned*

**AC** 13
**HP** 42 (5d10 + 15)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 10 | 16 | 2 | 7 | 5 |

CR 2, PB +2, XP 450

## Traits

**Bloodied Fury**
The boar has Advantage on melee attack rolls while it is Bloodied.

## Actions

**Gore**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Piercing damage. If the target is a Large or smaller creature and the boar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 7 (2d6) Piercing damage and has the Prone condition.
`,
      "giant-centipede.md": `---
smType: creature
name: "Giant Centipede"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "14"
hp: "9"
hit_dice: "2d6 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":5},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":7},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage, and the target has the Poisoned condition until the start of the centipede's next turn.\\"}]"
---

# Giant Centipede
*Small, Beast, Unaligned*

**AC** 14
**HP** 9 (2d6 + 2)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 5 | 14 | 12 | 1 | 7 | 3 |

CR 1/4, PB +2, XP 50

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage, and the target has the Poisoned condition until the start of the centipede's next turn.
`,
      "giant-constrictor-snake.md": `---
smType: creature
name: "Giant Constrictor Snake"
size: "Huge"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "60"
hit_dice: "8d12 + 8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The snake makes one Bite attack and uses Constrict.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 10 ft. 11 (2d6 + 4) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Constrict\\",\\"text\\":\\"*Strength Saving Throw*: DC 14, one Large or smaller creature the snake can see within 10 feet. *Failure:*  13 (2d8 + 4) Bludgeoning damage, and the target has the Grappled condition (escape DC 14).\\"}]"
---

# Giant Constrictor Snake
*Huge, Beast, Unaligned*

**AC** 12
**HP** 60 (8d12 + 8)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 14 | 12 | 1 | 10 | 3 |

CR 2, PB +2, XP 450

## Actions

**Multiattack**
The snake makes one Bite attack and uses Constrict.

**Bite**
*Melee Attack Roll:* +6, reach 10 ft. 11 (2d6 + 4) Piercing damage.

**Constrict**
*Strength Saving Throw*: DC 14, one Large or smaller creature the snake can see within 10 feet. *Failure:*  13 (2d8 + 4) Bludgeoning damage, and the target has the Grappled condition (escape DC 14).
`,
      "giant-crab.md": `---
smType: creature
name: "Giant Crab"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "15"
hp: "13"
hit_dice: "3d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":13},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":9},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The crab can breathe air and water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 11) from one of two claws.\\"}]"
---

# Giant Crab
*Medium, Beast, Unaligned*

**AC** 15
**HP** 13 (3d8)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 13 | 13 | 11 | 1 | 9 | 3 |

CR 1/8, PB +2, XP 25

## Traits

**Amphibious**
The crab can breathe air and water.

## Actions

**Claw**
*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 11) from one of two claws.
`,
      "giant-crocodile.md": `---
smType: creature
name: "Giant Crocodile"
size: "Huge"
type: "Beast"
alignment: "Unaligned"
ac: "14"
hp: "85"
hit_dice: "9d12 + 27"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":21},{\\"ability\\":\\"dex\\",\\"score\\":9},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Hold Breath\\",\\"text\\":\\"The crocodile can hold its breath for 1 hour.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The crocodile makes one Bite attack and one Tail attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +8, reach 5 ft. 21 (3d10 + 5) Piercing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 15). While Grappled, the target has the Restrained condition and can't be targeted by the crocodile's Tail.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tail\\",\\"text\\":\\"*Melee Attack Roll:* +8, reach 10 ft. 18 (3d8 + 5) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.\\"}]"
---

# Giant Crocodile
*Huge, Beast, Unaligned*

**AC** 14
**HP** 85 (9d12 + 27)
**Speed** 30 ft., swim 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 21 | 9 | 17 | 2 | 10 | 7 |

CR 5, PB +3, XP 1800

## Traits

**Hold Breath**
The crocodile can hold its breath for 1 hour.

## Actions

**Multiattack**
The crocodile makes one Bite attack and one Tail attack.

**Bite**
*Melee Attack Roll:* +8, reach 5 ft. 21 (3d10 + 5) Piercing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 15). While Grappled, the target has the Restrained condition and can't be targeted by the crocodile's Tail.

**Tail**
*Melee Attack Roll:* +8, reach 10 ft. 18 (3d8 + 5) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.
`,
      "giant-eagle.md": `---
smType: creature
name: "Giant Eagle"
size: "Large"
type: "Celestial"
alignment: "Neutral Good"
ac: "13"
hp: "26"
hit_dice: "4d10 + 4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":8},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The eagle makes two Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Slashing damage plus 3 (1d6) Radiant damage.\\"}]"
---

# Giant Eagle
*Large, Celestial, Neutral Good*

**AC** 13
**HP** 26 (4d10 + 4)
**Speed** 10 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 17 | 13 | 8 | 14 | 10 |

CR 1, PB +2, XP 200

## Actions

**Multiattack**
The eagle makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Slashing damage plus 3 (1d6) Radiant damage.
`,
      "giant-elk.md": `---
smType: creature
name: "Giant Elk"
size: "Huge"
type: "Celestial"
alignment: "Neutral Good"
ac: "14"
hp: "42"
hit_dice: "5d12 + 10"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":18},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":7},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":6},{\\"ability\\":\\"dex\\",\\"bonus\\":6}]"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Ram\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 10 ft. 11 (2d6 + 4) Bludgeoning damage plus 5 (2d4) Radiant damage. If the target is a Huge or smaller creature and the elk moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.\\"}]"
---

# Giant Elk
*Huge, Celestial, Neutral Good*

**AC** 14
**HP** 42 (5d12 + 10)
**Speed** 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 18 | 14 | 7 | 14 | 10 |

CR 2, PB +2, XP 450

## Actions

**Ram**
*Melee Attack Roll:* +6, reach 10 ft. 11 (2d6 + 4) Bludgeoning damage plus 5 (2d4) Radiant damage. If the target is a Huge or smaller creature and the elk moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.
`,
      "giant-fire-beetle.md": `---
smType: creature
name: "Giant Fire Beetle"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "4"
hit_dice: "1d6 + 1"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":8},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":7},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Illumination\\",\\"text\\":\\"The beetle sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +1, reach 5 ft. 1 Fire damage.\\"}]"
---

# Giant Fire Beetle
*Small, Beast, Unaligned*

**AC** 13
**HP** 4 (1d6 + 1)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 8 | 10 | 12 | 1 | 7 | 3 |

CR 0, PB +2, XP 0

## Traits

**Illumination**
The beetle sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.

## Actions

**Bite**
*Melee Attack Roll:* +1, reach 5 ft. 1 Fire damage.
`,
      "giant-frog.md": `---
smType: creature
name: "Giant Frog"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "11"
hp: "18"
hit_dice: "4d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":12},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The frog can breathe air and water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Standing Leap\\",\\"text\\":\\"The frog's Long Jump is up to 20 feet and its High Jump is up to 10 feet with or without a running start.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 5 (1d6 + 2) Piercing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 11).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Swallow\\",\\"text\\":\\"The frog swallows a Small or smaller target it is grappling. While swallowed, the target isn't Grappled but has the Blinded and Restrained conditions, and it has Cover|XPHB|Total Cover against attacks and other effects outside the frog. While swallowing the target, the frog can't use Bite, and if the frog dies, the swallowed target is no longer Restrained and can escape from the corpse using 5 feet of movement, exiting with the Prone condition. At the end of the frog's next turn, the swallowed target takes 5 (2d4) Acid damage. If that damage doesn't kill it, the frog disgorges it, causing it to exit Prone.\\"}]"
---

# Giant Frog
*Medium, Beast, Unaligned*

**AC** 11
**HP** 18 (4d8)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 12 | 13 | 11 | 2 | 10 | 3 |

CR 1/4, PB +2, XP 50

## Traits

**Amphibious**
The frog can breathe air and water.

**Standing Leap**
The frog's Long Jump is up to 20 feet and its High Jump is up to 10 feet with or without a running start.

## Actions

**Bite**
*Melee Attack Roll:* +3, reach 5 ft. 5 (1d6 + 2) Piercing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 11).

**Swallow**
The frog swallows a Small or smaller target it is grappling. While swallowed, the target isn't Grappled but has the Blinded and Restrained conditions, and it has Cover|XPHB|Total Cover against attacks and other effects outside the frog. While swallowing the target, the frog can't use Bite, and if the frog dies, the swallowed target is no longer Restrained and can escape from the corpse using 5 feet of movement, exiting with the Prone condition. At the end of the frog's next turn, the swallowed target takes 5 (2d4) Acid damage. If that damage doesn't kill it, the frog disgorges it, causing it to exit Prone.
`,
      "giant-goat.md": `---
smType: creature
name: "Giant Goat"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "11"
hp: "19"
hit_dice: "3d10 + 3"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":5}]"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Ram\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage. If the target is a Large or smaller creature and the goat moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.\\"}]"
---

# Giant Goat
*Large, Beast, Unaligned*

**AC** 11
**HP** 19 (3d10 + 3)
**Speed** 40 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 13 | 12 | 3 | 12 | 6 |

CR 1/2, PB +2, XP 100

## Actions

**Ram**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage. If the target is a Large or smaller creature and the goat moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.
`,
      "giant-hyena.md": `---
smType: creature
name: "Giant Hyena"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "45"
hit_dice: "6d10 + 12"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Piercing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Rampage (1/Day)\\",\\"text\\":\\"Immediately after dealing damage to a creature that was already Bloodied, the hyena can move up to half its Speed, and it makes one Bite attack.\\"}]"
---

# Giant Hyena
*Large, Beast, Unaligned*

**AC** 12
**HP** 45 (6d10 + 12)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 14 | 14 | 2 | 12 | 7 |

CR 1, PB +2, XP 200

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Piercing damage.

## Bonus Actions

**Rampage (1/Day)**
Immediately after dealing damage to a creature that was already Bloodied, the hyena can move up to half its Speed, and it makes one Bite attack.
`,
      "giant-lizard.md": `---
smType: creature
name: "Giant Lizard"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "19"
hit_dice: "3d10 + 3"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":3}]"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Spider Climb\\",\\"text\\":\\"The lizard can climb difficult surfaces, including along ceilings, without needing to make an ability check.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Piercing damage.\\"}]"
---

# Giant Lizard
*Large, Beast, Unaligned*

**AC** 12
**HP** 19 (3d10 + 3)
**Speed** 40 ft., climb 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 12 | 13 | 2 | 10 | 5 |

CR 1/4, PB +2, XP 50

## Traits

**Spider Climb**
The lizard can climb difficult surfaces, including along ceilings, without needing to make an ability check.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Piercing damage.
`,
      "giant-octopus.md": `---
smType: creature
name: "Giant Octopus"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "11"
hp: "45"
hit_dice: "7d10 + 7"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"swim\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":5},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":4}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Water Breathing\\",\\"text\\":\\"The octopus can breathe only underwater. It can hold its breath for 1 hour outside water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tentacles\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 10 ft. 10 (2d6 + 3) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 13) from all eight tentacles. While Grappled, the target has the Restrained condition.\\"}]"
---

# Giant Octopus
*Large, Beast, Unaligned*

**AC** 11
**HP** 45 (7d10 + 7)
**Speed** 10 ft., swim 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 13 | 13 | 5 | 10 | 4 |

CR 1, PB +2, XP 200

## Traits

**Water Breathing**
The octopus can breathe only underwater. It can hold its breath for 1 hour outside water.

## Actions

**Tentacles**
*Melee Attack Roll:* +5, reach 10 ft. 10 (2d6 + 3) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 13) from all eight tentacles. While Grappled, the target has the Restrained condition.
`,
      "giant-owl.md": `---
smType: creature
name: "Giant Owl"
size: "Large"
type: "Celestial"
alignment: "Neutral Neutral"
ac: "12"
hp: "19"
hit_dice: "3d10 + 3"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":13},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"wis\\",\\"bonus\\":4}]"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Flyby\\",\\"text\\":\\"The owl doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Talons\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The owl casts one of the following spells, requiring no spell components and using Wisdom as the spellcasting ability: - **At Will:** *Detect Evil and Good*, *Detect Magic* - **1/Day Each:** *Clairvoyance*\\"}]"
---

# Giant Owl
*Large, Celestial, Neutral Neutral*

**AC** 12
**HP** 19 (3d10 + 3)
**Speed** 5 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 13 | 15 | 12 | 10 | 14 | 10 |

CR 1/4, PB +2, XP 50

## Traits

**Flyby**
The owl doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.

## Actions

**Talons**
*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage.

**Spellcasting**
The owl casts one of the following spells, requiring no spell components and using Wisdom as the spellcasting ability: - **At Will:** *Detect Evil and Good*, *Detect Magic* - **1/Day Each:** *Clairvoyance*
`,
      "giant-rat.md": `---
smType: creature
name: "Giant Rat"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "7"
hit_dice: "2d6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":7},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":4}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":5}]"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The rat has Advantage on an attack roll against a creature if at least one of the rat's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 feet. 5 (1d4 + 3) Piercing damage.\\"}]"
---

# Giant Rat
*Small, Beast, Unaligned*

**AC** 13
**HP** 7 (2d6)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 7 | 16 | 11 | 2 | 10 | 4 |

CR 1/8, PB +2, XP 25

## Traits

**Pack Tactics**
The rat has Advantage on an attack roll against a creature if at least one of the rat's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 feet. 5 (1d4 + 3) Piercing damage.
`,
      "giant-scorpion.md": `---
smType: creature
name: "Giant Scorpion"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "15"
hp: "52"
hit_dice: "7d10 + 14"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":9},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The scorpion makes two Claw attacks and one Sting attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13) from one of two claws.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Sting\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage plus 11 (2d10) Poison damage.\\"}]"
---

# Giant Scorpion
*Large, Beast, Unaligned*

**AC** 15
**HP** 52 (7d10 + 14)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 13 | 15 | 1 | 9 | 3 |

CR 3, PB +2, XP 700

## Actions

**Multiattack**
The scorpion makes two Claw attacks and one Sting attack.

**Claw**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13) from one of two claws.

**Sting**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage plus 11 (2d10) Poison damage.
`,
      "giant-seahorse.md": `---
smType: creature
name: "Giant Seahorse"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "14"
hp: "16"
hit_dice: "3d10"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Water Breathing\\",\\"text\\":\\"The seahorse can breathe only underwater.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Ram\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 9 (2d6 + 2) Bludgeoning damage, or 11 (2d8 + 2) Bludgeoning damage if the seahorse moved 20+ feet straight toward the target immediately before the hit.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Bubble Dash\\",\\"text\\":\\"While underwater, the seahorse moves up to half its Swim Speed without provoking Opportunity Attacks.\\"}]"
---

# Giant Seahorse
*Large, Beast, Unaligned*

**AC** 14
**HP** 16 (3d10)
**Speed** 5 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 12 | 11 | 2 | 12 | 5 |

CR 1/2, PB +2, XP 100

## Traits

**Water Breathing**
The seahorse can breathe only underwater.

## Actions

**Ram**
*Melee Attack Roll:* +4, reach 5 ft. 9 (2d6 + 2) Bludgeoning damage, or 11 (2d8 + 2) Bludgeoning damage if the seahorse moved 20+ feet straight toward the target immediately before the hit.

## Bonus Actions

**Bubble Dash**
While underwater, the seahorse moves up to half its Swim Speed without provoking Opportunity Attacks.
`,
      "giant-shark.md": `---
smType: creature
name: "Giant Shark"
size: "Huge"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "92"
hit_dice: "8d12 + 40"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"},\\"swim\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":23},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":21},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Water Breathing\\",\\"text\\":\\"The shark can breathe only underwater.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The shark makes two Bite attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +9 (with Advantage if the target doesn't have all its Hit Points), reach 5 ft. 22 (3d10 + 6) Piercing damage.\\"}]"
---

# Giant Shark
*Huge, Beast, Unaligned*

**AC** 13
**HP** 92 (8d12 + 40)
**Speed** 5 ft., swim 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 23 | 11 | 21 | 1 | 10 | 5 |

CR 5, PB +3, XP 1800

## Traits

**Water Breathing**
The shark can breathe only underwater.

## Actions

**Multiattack**
The shark makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +9 (with Advantage if the target doesn't have all its Hit Points), reach 5 ft. 22 (3d10 + 6) Piercing damage.
`,
      "giant-spider.md": `---
smType: creature
name: "Giant Spider"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "14"
hp: "26"
hit_dice: "4d10 + 4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":14},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":4}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Spider Climb\\",\\"text\\":\\"The spider can climb difficult surfaces, including along ceilings, without needing to make an ability check.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Web Walker\\",\\"text\\":\\"The spider ignores movement restrictions caused by webs, and it knows the location of any other creature in contact with the same web.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage plus 7 (2d6) Poison damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Web (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 13, one creature the spider can see within 60 feet. *Failure:*  The target has the Restrained condition until the web is destroyed (AC 10; HP 5; Vulnerability to Fire damage; Immunity to Poison and Psychic damage).\\"}]"
---

# Giant Spider
*Large, Beast, Unaligned*

**AC** 14
**HP** 26 (4d10 + 4)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 14 | 16 | 12 | 2 | 11 | 4 |

CR 1, PB +2, XP 200

## Traits

**Spider Climb**
The spider can climb difficult surfaces, including along ceilings, without needing to make an ability check.

**Web Walker**
The spider ignores movement restrictions caused by webs, and it knows the location of any other creature in contact with the same web.

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage plus 7 (2d6) Poison damage.

**Web (Recharge 5-6)**
*Dexterity Saving Throw*: DC 13, one creature the spider can see within 60 feet. *Failure:*  The target has the Restrained condition until the web is destroyed (AC 10; HP 5; Vulnerability to Fire damage; Immunity to Poison and Psychic damage).
`,
      "giant-toad.md": `---
smType: creature
name: "Giant Toad"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "11"
hp: "39"
hit_dice: "6d10 + 6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The toad can breathe air and water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Standing Leap\\",\\"text\\":\\"The toad's Long Jump is up to 20 feet and its High Jump is up to 10 feet with or without a running start.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 5 (2d4) Poison damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Swallow\\",\\"text\\":\\"The toad swallows a Medium or smaller target it is grappling. While swallowed, the target isn't Grappled but has the Blinded and Restrained conditions, and it has Cover|XPHB|Total Cover against attacks and other effects outside the toad. In addition, the target takes 10 (3d6) Acid damage at the end of each of the toad's turns. The toad can have only one target swallowed at a time, and it can't use Bite while it has a swallowed target. If the toad dies, a swallowed creature is no longer Restrained and can escape from the corpse using 5 feet of movement, exiting with the Prone condition.\\"}]"
---

# Giant Toad
*Large, Beast, Unaligned*

**AC** 11
**HP** 39 (6d10 + 6)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 13 | 13 | 2 | 10 | 3 |

CR 1, PB +2, XP 200

## Traits

**Amphibious**
The toad can breathe air and water.

**Standing Leap**
The toad's Long Jump is up to 20 feet and its High Jump is up to 10 feet with or without a running start.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 5 (2d4) Poison damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12).

**Swallow**
The toad swallows a Medium or smaller target it is grappling. While swallowed, the target isn't Grappled but has the Blinded and Restrained conditions, and it has Cover|XPHB|Total Cover against attacks and other effects outside the toad. In addition, the target takes 10 (3d6) Acid damage at the end of each of the toad's turns. The toad can have only one target swallowed at a time, and it can't use Bite while it has a swallowed target. If the toad dies, a swallowed creature is no longer Restrained and can escape from the corpse using 5 feet of movement, exiting with the Prone condition.
`,
      "giant-venomous-snake.md": `---
smType: creature
name: "Giant Venomous Snake"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "14"
hp: "11"
hit_dice: "2d8 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":18},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 10 ft. 6 (1d4 + 4) Piercing damage plus 4 (1d8) Poison damage.\\"}]"
---

# Giant Venomous Snake
*Medium, Beast, Unaligned*

**AC** 14
**HP** 11 (2d8 + 2)
**Speed** 40 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 18 | 13 | 2 | 10 | 3 |

CR 1/4, PB +2, XP 50

## Actions

**Bite**
*Melee Attack Roll:* +6, reach 10 ft. 6 (1d4 + 4) Piercing damage plus 4 (1d8) Poison damage.
`,
      "giant-vulture.md": `---
smType: creature
name: "Giant Vulture"
size: "Large"
type: "Monstrosity"
alignment: "Neutral Evil"
ac: "10"
hp: "25"
hit_dice: "3d10 + 9"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The vulture has Advantage on an attack roll against a creature if at least one of the vulture's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Gouge\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 9 (2d6 + 2) Piercing damage, and the target has the Poisoned condition until the end of its next turn.\\"}]"
---

# Giant Vulture
*Large, Monstrosity, Neutral Evil*

**AC** 10
**HP** 25 (3d10 + 9)
**Speed** 10 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 10 | 16 | 6 | 12 | 7 |

CR 1, PB +2, XP 200

## Traits

**Pack Tactics**
The vulture has Advantage on an attack roll against a creature if at least one of the vulture's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Gouge**
*Melee Attack Roll:* +4, reach 5 ft. 9 (2d6 + 2) Piercing damage, and the target has the Poisoned condition until the end of its next turn.
`,
      "giant-wasp.md": `---
smType: creature
name: "Giant Wasp"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "22"
hit_dice: "5d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"fly\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Flyby\\",\\"text\\":\\"The wasp doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Sting\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 5 (2d4) Poison damage.\\"}]"
---

# Giant Wasp
*Medium, Beast, Unaligned*

**AC** 13
**HP** 22 (5d8)
**Speed** 10 ft., fly 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 14 | 10 | 1 | 10 | 3 |

CR 1/2, PB +2, XP 100

## Traits

**Flyby**
The wasp doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.

## Actions

**Sting**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 5 (2d4) Poison damage.
`,
      "giant-weasel.md": `---
smType: creature
name: "Giant Weasel"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "9"
hit_dice: "2d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":11},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":4},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Piercing damage.\\"}]"
---

# Giant Weasel
*Medium, Beast, Unaligned*

**AC** 13
**HP** 9 (2d8)
**Speed** 40 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 11 | 17 | 10 | 4 | 12 | 5 |

CR 1/8, PB +2, XP 25

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Piercing damage.
`,
      "giant-wolf-spider.md": `---
smType: creature
name: "Giant Wolf Spider"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "11"
hit_dice: "2d8 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":12},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":4}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Spider Climb\\",\\"text\\":\\"The spider can climb difficult surfaces, including along ceilings, without needing to make an ability check.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Piercing damage plus 5 (2d4) Poison damage.\\"}]"
---

# Giant Wolf Spider
*Medium, Beast, Unaligned*

**AC** 13
**HP** 11 (2d8 + 2)
**Speed** 40 ft., climb 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 12 | 16 | 13 | 3 | 12 | 4 |

CR 1/4, PB +2, XP 50

## Traits

**Spider Climb**
The spider can climb difficult surfaces, including along ceilings, without needing to make an ability check.

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Piercing damage plus 5 (2d4) Poison damage.
`,
      "goat.md": `---
smType: creature
name: "Goat"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "10"
hp: "4"
hit_dice: "1d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":11},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":2}]"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Ram\\",\\"text\\":\\"*Melee Attack Roll:* +2, reach 5 ft. 1 Bludgeoning damage, or 2 (1d4) Bludgeoning damage if the goat moved 20+ feet straight toward the target immediately before the hit.\\"}]"
---

# Goat
*Medium, Beast, Unaligned*

**AC** 10
**HP** 4 (1d8)
**Speed** 40 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 11 | 10 | 11 | 2 | 10 | 5 |

CR 0, PB +2, XP 0

## Actions

**Ram**
*Melee Attack Roll:* +2, reach 5 ft. 1 Bludgeoning damage, or 2 (1d4) Bludgeoning damage if the goat moved 20+ feet straight toward the target immediately before the hit.
`,
      "hawk.md": `---
smType: creature
name: "Hawk"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "1"
hit_dice: "1d4 - 1"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":5},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":8},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Talons\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 1 Slashing damage.\\"}]"
---

# Hawk
*Small, Beast, Unaligned*

**AC** 13
**HP** 1 (1d4 - 1)
**Speed** 10 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 5 | 16 | 8 | 2 | 14 | 6 |

CR 0, PB +2, XP 0

## Actions

**Talons**
*Melee Attack Roll:* +5, reach 5 ft. 1 Slashing damage.
`,
      "hippopotamus.md": `---
smType: creature
name: "Hippopotamus"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "14"
hp: "82"
hit_dice: "11d10 + 22"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":21},{\\"ability\\":\\"dex\\",\\"score\\":7},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":4}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":7}]"
cr: "4"
xp: "1100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Hold Breath\\",\\"text\\":\\"The hippopotamus can hold its breath for 10 minutes.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The hippopotamus makes two Bite attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 16 (2d10 + 5) Piercing damage.\\"}]"
---

# Hippopotamus
*Large, Beast, Unaligned*

**AC** 14
**HP** 82 (11d10 + 22)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 21 | 7 | 15 | 2 | 12 | 4 |

CR 4, PB +2, XP 1100

## Traits

**Hold Breath**
The hippopotamus can hold its breath for 10 minutes.

## Actions

**Multiattack**
The hippopotamus makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +7, reach 5 ft. 16 (2d10 + 5) Piercing damage.
`,
      "hunter-shark.md": `---
smType: creature
name: "Hunter Shark"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "45"
hit_dice: "6d10 + 12"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":4}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Water Breathing\\",\\"text\\":\\"The shark can breathe only underwater.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +6 (with Advantage if the target doesn't have all its Hit Points), reach 5 ft. 14 (3d6 + 4) Piercing damage.\\"}]"
---

# Hunter Shark
*Large, Beast, Unaligned*

**AC** 12
**HP** 45 (6d10 + 12)
**Speed** 5 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 14 | 15 | 1 | 10 | 4 |

CR 2, PB +2, XP 450

## Traits

**Water Breathing**
The shark can breathe only underwater.

## Actions

**Bite**
*Melee Attack Roll:* +6 (with Advantage if the target doesn't have all its Hit Points), reach 5 ft. 14 (3d6 + 4) Piercing damage.
`,
      "hyena.md": `---
smType: creature
name: "Hyena"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "11"
hp: "5"
hit_dice: "1d8 + 1"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":11},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The hyena has Advantage on an attack roll against a creature if at least one of the hyena's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +2, reach 5 ft. 3 (1d6) Piercing damage.\\"}]"
---

# Hyena
*Medium, Beast, Unaligned*

**AC** 11
**HP** 5 (1d8 + 1)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 11 | 13 | 12 | 2 | 12 | 5 |

CR 0, PB +2, XP 0

## Traits

**Pack Tactics**
The hyena has Advantage on an attack roll against a creature if at least one of the hyena's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Bite**
*Melee Attack Roll:* +2, reach 5 ft. 3 (1d6) Piercing damage.
`,
      "jackal.md": `---
smType: creature
name: "Jackal"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "3"
hit_dice: "1d6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":8},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +1, reach 5 ft. 1 (1d4 - 1) Piercing damage.\\"}]"
---

# Jackal
*Small, Beast, Unaligned*

**AC** 12
**HP** 3 (1d6)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 8 | 15 | 11 | 3 | 12 | 6 |

CR 0, PB +2, XP 0

## Actions

**Bite**
*Melee Attack Roll:* +1, reach 5 ft. 1 (1d4 - 1) Piercing damage.
`,
      "killer-whale.md": `---
smType: creature
name: "Killer Whale"
size: "Huge"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "90"
hit_dice: "12d12 + 12"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"},\\"swim\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Hold Breath\\",\\"text\\":\\"The whale can hold its breath for 30 minutes.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 21 (5d6 + 4) Piercing damage.\\"}]"
---

# Killer Whale
*Huge, Beast, Unaligned*

**AC** 12
**HP** 90 (12d12 + 12)
**Speed** 5 ft., swim 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 14 | 13 | 3 | 12 | 7 |

CR 3, PB +2, XP 700

## Traits

**Hold Breath**
The whale can hold its breath for 30 minutes.

## Actions

**Bite**
*Melee Attack Roll:* +6, reach 5 ft. 21 (5d6 + 4) Piercing damage.
`,
      "lion.md": `---
smType: creature
name: "Lion"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "22"
hit_dice: "4d10"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The lion has Advantage on an attack roll against a creature if at least one of the lion's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Running Leap\\",\\"text\\":\\"With a 10-foot running start, the lion can Long Jump up to 25 feet.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The lion makes two Rend attacks. It can replace one attack with a use of Roar.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Roar\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 11, one creature within 15 feet. *Failure:*  The target has the Frightened condition until the start of the lion's next turn.\\"}]"
---

# Lion
*Large, Beast, Unaligned*

**AC** 12
**HP** 22 (4d10)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 15 | 11 | 3 | 12 | 8 |

CR 1, PB +2, XP 200

## Traits

**Pack Tactics**
The lion has Advantage on an attack roll against a creature if at least one of the lion's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

**Running Leap**
With a 10-foot running start, the lion can Long Jump up to 25 feet.

## Actions

**Multiattack**
The lion makes two Rend attacks. It can replace one attack with a use of Roar.

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Slashing damage.

**Roar**
*Wisdom Saving Throw*: DC 11, one creature within 15 feet. *Failure:*  The target has the Frightened condition until the start of the lion's next turn.
`,
      "lizard.md": `---
smType: creature
name: "Lizard"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "10"
hp: "2"
hit_dice: "1d4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"climb\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":2},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":8},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Spider Climb\\",\\"text\\":\\"The lizard can climb difficult surfaces, including along ceilings, without needing to make an ability check.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +2, reach 5 ft. 1 Piercing damage.\\"}]"
---

# Lizard
*Small, Beast, Unaligned*

**AC** 10
**HP** 2 (1d4)
**Speed** 20 ft., climb 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 2 | 11 | 10 | 1 | 8 | 3 |

CR 0, PB +2, XP 0

## Traits

**Spider Climb**
The lizard can climb difficult surfaces, including along ceilings, without needing to make an ability check.

## Actions

**Bite**
*Melee Attack Roll:* +2, reach 5 ft. 1 Piercing damage.
`,
      "mammoth.md": `---
smType: creature
name: "Mammoth"
size: "Huge"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "126"
hit_dice: "11d12 + 55"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":24},{\\"ability\\":\\"dex\\",\\"score\\":9},{\\"ability\\":\\"con\\",\\"score\\":21},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":10},{\\"ability\\":\\"con\\",\\"bonus\\":8}]"
cr: "6"
xp: "2300"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The mammoth makes two Gore attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Gore\\",\\"text\\":\\"*Melee Attack Roll:* +10, reach 10 ft. 18 (2d10 + 7) Piercing damage. If the target is a Huge or smaller creature and the mammoth moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Trample\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 18, one creature within 5 feet that has the Prone condition. *Failure:*  29 (4d10 + 7) Bludgeoning damage. *Success:*  Half damage.\\"}]"
---

# Mammoth
*Huge, Beast, Unaligned*

**AC** 13
**HP** 126 (11d12 + 55)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 24 | 9 | 21 | 3 | 11 | 6 |

CR 6, PB +3, XP 2300

## Actions

**Multiattack**
The mammoth makes two Gore attacks.

**Gore**
*Melee Attack Roll:* +10, reach 10 ft. 18 (2d10 + 7) Piercing damage. If the target is a Huge or smaller creature and the mammoth moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.

## Bonus Actions

**Trample**
*Dexterity Saving Throw*: DC 18, one creature within 5 feet that has the Prone condition. *Failure:*  29 (4d10 + 7) Bludgeoning damage. *Success:*  Half damage.
`,
      "mastiff.md": `---
smType: creature
name: "Mastiff"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "5"
hit_dice: "1d8 + 1"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":13},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Piercing damage. If the target is a Medium or smaller creature, it has the Prone condition.\\"}]"
---

# Mastiff
*Medium, Beast, Unaligned*

**AC** 12
**HP** 5 (1d8 + 1)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 13 | 14 | 12 | 3 | 12 | 7 |

CR 1/8, PB +2, XP 25

## Actions

**Bite**
*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Piercing damage. If the target is a Medium or smaller creature, it has the Prone condition.
`,
      "mule.md": `---
smType: creature
name: "Mule"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "10"
hp: "11"
hit_dice: "2d8 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":14},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":4}]"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Beast of Burden\\",\\"text\\":\\"The mule counts as one size larger for the purpose of determining its carrying capacity.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Hooves\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Bludgeoning damage.\\"}]"
---

# Mule
*Medium, Beast, Unaligned*

**AC** 10
**HP** 11 (2d8 + 2)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 14 | 10 | 13 | 2 | 10 | 5 |

CR 1/8, PB +2, XP 25

## Traits

**Beast of Burden**
The mule counts as one size larger for the purpose of determining its carrying capacity.

## Actions

**Hooves**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Bludgeoning damage.
`,
      "owl.md": `---
smType: creature
name: "Owl"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "11"
hp: "1"
hit_dice: "1d4 - 1"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":3},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":8},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Flyby\\",\\"text\\":\\"The owl doesn't provoke Opportunity Attacks when it flies out of an enemy's reach.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Talons\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 1 Slashing damage.\\"}]"
---

# Owl
*Small, Beast, Unaligned*

**AC** 11
**HP** 1 (1d4 - 1)
**Speed** 5 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 3 | 13 | 8 | 2 | 12 | 7 |

CR 0, PB +2, XP 0

## Traits

**Flyby**
The owl doesn't provoke Opportunity Attacks when it flies out of an enemy's reach.

## Actions

**Talons**
*Melee Attack Roll:* +3, reach 5 ft. 1 Slashing damage.
`,
      "panther.md": `---
smType: creature
name: "Panther"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "13"
hit_dice: "3d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"},\\"climb\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":14},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Slashing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Nimble Escape\\",\\"text\\":\\"The panther takes the Disengage or Hide action.\\"}]"
---

# Panther
*Medium, Beast, Unaligned*

**AC** 13
**HP** 13 (3d8)
**Speed** 50 ft., climb 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 14 | 16 | 10 | 3 | 14 | 7 |

CR 1/4, PB +2, XP 50

## Actions

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Slashing damage.

## Bonus Actions

**Nimble Escape**
The panther takes the Disengage or Hide action.
`,
      "piranha.md": `---
smType: creature
name: "Piranha"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "1"
hit_dice: "1d4 - 1"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":2},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":9},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":7},{\\"ability\\":\\"cha\\",\\"score\\":2}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Water Breathing\\",\\"text\\":\\"The piranha can breathe only underwater.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5 (with Advantage if the target doesn't have all its Hit Points), reach 5 ft. 1 Piercing damage.\\"}]"
---

# Piranha
*Small, Beast, Unaligned*

**AC** 13
**HP** 1 (1d4 - 1)
**Speed** 5 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 2 | 16 | 9 | 1 | 7 | 2 |

CR 0, PB +2, XP 0

## Traits

**Water Breathing**
The piranha can breathe only underwater.

## Actions

**Bite**
*Melee Attack Roll:* +5 (with Advantage if the target doesn't have all its Hit Points), reach 5 ft. 1 Piercing damage.
`,
      "plesiosaurus.md": `---
smType: creature
name: "Plesiosaurus"
size: "Large"
type: "Beast"
type_tags: ["Dinosaur"]
alignment: "Unaligned"
ac: "13"
hp: "68"
hit_dice: "8d10 + 24"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Hold Breath\\",\\"text\\":\\"The plesiosaurus can hold its breath for 1 hour.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 10 ft. 11 (2d6 + 4) Piercing damage.\\"}]"
---

# Plesiosaurus
*Large, Beast, Unaligned*

**AC** 13
**HP** 68 (8d10 + 24)
**Speed** 20 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 15 | 16 | 2 | 12 | 5 |

CR 2, PB +2, XP 450

## Traits

**Hold Breath**
The plesiosaurus can hold its breath for 1 hour.

## Actions

**Bite**
*Melee Attack Roll:* +6, reach 10 ft. 11 (2d6 + 4) Piercing damage.
`,
      "polar-bear.md": `---
smType: creature
name: "Polar Bear"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "42"
hit_dice: "5d10 + 15"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":20},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The bear makes two Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 9 (1d8 + 5) Slashing damage.\\"}]"
---

# Polar Bear
*Large, Beast, Unaligned*

**AC** 12
**HP** 42 (5d10 + 15)
**Speed** 40 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 20 | 14 | 16 | 2 | 13 | 7 |

CR 2, PB +2, XP 450

## Actions

**Multiattack**
The bear makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +7, reach 5 ft. 9 (1d8 + 5) Slashing damage.
`,
      "pony.md": `---
smType: creature
name: "Pony"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "10"
hp: "11"
hit_dice: "2d8 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":4}]"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Hooves\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Bludgeoning damage.\\"}]"
---

# Pony
*Medium, Beast, Unaligned*

**AC** 10
**HP** 11 (2d8 + 2)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 10 | 13 | 2 | 11 | 7 |

CR 1/8, PB +2, XP 25

## Actions

**Hooves**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Bludgeoning damage.
`,
      "pteranodon.md": `---
smType: creature
name: "Pteranodon"
size: "Medium"
type: "Beast"
type_tags: ["Dinosaur"]
alignment: "Unaligned"
ac: "13"
hp: "13"
hit_dice: "3d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":12},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":9},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Flyby\\",\\"text\\":\\"The pteranodon doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Piercing damage.\\"}]"
---

# Pteranodon
*Medium, Beast, Unaligned*

**AC** 13
**HP** 13 (3d8)
**Speed** 10 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 12 | 15 | 10 | 2 | 9 | 5 |

CR 1/4, PB +2, XP 50

## Traits

**Flyby**
The pteranodon doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Piercing damage.
`,
      "rat.md": `---
smType: creature
name: "Rat"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "10"
hp: "1"
hit_dice: "1d4 - 1"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"climb\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":2},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":9},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":4}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Agile\\",\\"text\\":\\"The rat doesn't provoke Opportunity Attacks when it moves out of an enemy's reach.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +2, reach 5 ft. 1 Piercing damage.\\"}]"
---

# Rat
*Small, Beast, Unaligned*

**AC** 10
**HP** 1 (1d4 - 1)
**Speed** 20 ft., climb 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 2 | 11 | 9 | 2 | 10 | 4 |

CR 0, PB +2, XP 0

## Traits

**Agile**
The rat doesn't provoke Opportunity Attacks when it moves out of an enemy's reach.

## Actions

**Bite**
*Melee Attack Roll:* +2, reach 5 ft. 1 Piercing damage.
`,
      "raven.md": `---
smType: creature
name: "Raven"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "2"
hit_dice: "1d4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"fly\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":2},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":5},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Mimicry\\",\\"text\\":\\"The raven can mimic simple sounds it has heard, such as a whisper or chitter. A hearer can discern the sounds are imitations with a successful DC 10 Wisdom (Insight) check.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Beak\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 1 Piercing damage.\\"}]"
---

# Raven
*Small, Beast, Unaligned*

**AC** 12
**HP** 2 (1d4)
**Speed** 10 ft., fly 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 2 | 14 | 10 | 5 | 13 | 6 |

CR 0, PB +2, XP 0

## Traits

**Mimicry**
The raven can mimic simple sounds it has heard, such as a whisper or chitter. A hearer can discern the sounds are imitations with a successful DC 10 Wisdom (Insight) check.

## Actions

**Beak**
*Melee Attack Roll:* +4, reach 5 ft. 1 Piercing damage.
`,
      "reef-shark.md": `---
smType: creature
name: "Reef Shark"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "22"
hit_dice: "4d8 + 4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":14},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":4}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The shark has Advantage on an attack roll against a creature if at least one of the shark's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Water Breathing\\",\\"text\\":\\"The shark can breathe only underwater.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 7 (2d4 + 2) Piercing damage.\\"}]"
---

# Reef Shark
*Medium, Beast, Unaligned*

**AC** 12
**HP** 22 (4d8 + 4)
**Speed** 5 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 14 | 15 | 13 | 1 | 10 | 4 |

CR 1/2, PB +2, XP 100

## Traits

**Pack Tactics**
The shark has Advantage on an attack roll against a creature if at least one of the shark's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

**Water Breathing**
The shark can breathe only underwater.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 7 (2d4 + 2) Piercing damage.
`,
      "rhinoceros.md": `---
smType: creature
name: "Rhinoceros"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "45"
hit_dice: "6d10 + 12"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":21},{\\"ability\\":\\"dex\\",\\"score\\":8},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Gore\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 14 (2d8 + 5) Piercing damage. If target is a Large or smaller creature and the rhinoceros moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.\\"}]"
---

# Rhinoceros
*Large, Beast, Unaligned*

**AC** 13
**HP** 45 (6d10 + 12)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 21 | 8 | 15 | 2 | 12 | 6 |

CR 2, PB +2, XP 450

## Actions

**Gore**
*Melee Attack Roll:* +7, reach 5 ft. 14 (2d8 + 5) Piercing damage. If target is a Large or smaller creature and the rhinoceros moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.
`,
      "riding-horse.md": `---
smType: creature
name: "Riding Horse"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "11"
hp: "13"
hit_dice: "2d10 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Hooves\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Bludgeoning damage.\\"}]"
---

# Riding Horse
*Large, Beast, Unaligned*

**AC** 11
**HP** 13 (2d10 + 2)
**Speed** 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 13 | 12 | 2 | 11 | 7 |

CR 1/4, PB +2, XP 50

## Actions

**Hooves**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Bludgeoning damage.
`,
      "saber-toothed-tiger.md": `---
smType: creature
name: "Saber-Toothed Tiger"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "52"
hit_dice: "7d10 + 14"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":6},{\\"ability\\":\\"dex\\",\\"bonus\\":5}]"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Running Leap\\",\\"text\\":\\"With a 10-foot running start, the tiger can Long Jump up to 25 feet.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The tiger makes two Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 11 (2d6 + 4) Slashing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Nimble Escape\\",\\"text\\":\\"The tiger takes the Disengage or Hide action.\\"}]"
---

# Saber-Toothed Tiger
*Large, Beast, Unaligned*

**AC** 13
**HP** 52 (7d10 + 14)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 17 | 15 | 3 | 12 | 8 |

CR 2, PB +2, XP 450

## Traits

**Running Leap**
With a 10-foot running start, the tiger can Long Jump up to 25 feet.

## Actions

**Multiattack**
The tiger makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +6, reach 5 ft. 11 (2d6 + 4) Slashing damage.

## Bonus Actions

**Nimble Escape**
The tiger takes the Disengage or Hide action.
`,
      "scorpion.md": `---
smType: creature
name: "Scorpion"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "11"
hp: "1"
hit_dice: "1d4 - 1"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":2},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":8},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":8},{\\"ability\\":\\"cha\\",\\"score\\":2}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Sting\\",\\"text\\":\\"*Melee Attack Roll:* +2, reach 5 ft. 1 Piercing damage plus 3 (1d6) Poison damage.\\"}]"
---

# Scorpion
*Small, Beast, Unaligned*

**AC** 11
**HP** 1 (1d4 - 1)
**Speed** 10 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 2 | 11 | 8 | 1 | 8 | 2 |

CR 0, PB +2, XP 0

## Actions

**Sting**
*Melee Attack Roll:* +2, reach 5 ft. 1 Piercing damage plus 3 (1d6) Poison damage.
`,
      "seahorse.md": `---
smType: creature
name: "Seahorse"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "1"
hit_dice: "1d4 - 1"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"},\\"swim\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":1},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":8},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":2}]"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Water Breathing\\",\\"text\\":\\"The seahorse can breathe only underwater.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bubble Dash\\",\\"text\\":\\"While underwater, the seahorse moves up to its Swim Speed without provoking Opportunity Attacks.\\"}]"
---

# Seahorse
*Small, Beast, Unaligned*

**AC** 12
**HP** 1 (1d4 - 1)
**Speed** 5 ft., swim 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 1 | 12 | 8 | 1 | 10 | 2 |

CR 0, XP 0

## Traits

**Water Breathing**
The seahorse can breathe only underwater.

## Actions

**Bubble Dash**
While underwater, the seahorse moves up to its Swim Speed without provoking Opportunity Attacks.
`,
      "spider.md": `---
smType: creature
name: "Spider"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "1"
hit_dice: "1d4 - 1"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"climb\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":2},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":8},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":2}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Spider Climb\\",\\"text\\":\\"The spider can climb difficult surfaces, including along ceilings, without needing to make an ability check.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Web Walker\\",\\"text\\":\\"The spider ignores movement restrictions caused by webs, and the spider knows the location of any other creature in contact with the same web.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 1 Piercing damage plus 2 (1d4) Poison damage.\\"}]"
---

# Spider
*Small, Beast, Unaligned*

**AC** 12
**HP** 1 (1d4 - 1)
**Speed** 20 ft., climb 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 2 | 14 | 8 | 1 | 10 | 2 |

CR 0, PB +2, XP 0

## Traits

**Spider Climb**
The spider can climb difficult surfaces, including along ceilings, without needing to make an ability check.

**Web Walker**
The spider ignores movement restrictions caused by webs, and the spider knows the location of any other creature in contact with the same web.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 1 Piercing damage plus 2 (1d4) Poison damage.
`,
      "swarm-of-bats.md": `---
smType: creature
name: "Swarm of Bats"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "11"
hit_dice: "2d10"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"},\\"fly\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":5},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":4}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Swarm\\",\\"text\\":\\"The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny bat. The swarm can't regain Hit Points or gain Temporary Hit Points.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bites\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (2d4) Piercing damage, or 2 (1d4) Piercing damage if the swarm is Bloodied.\\"}]"
---

# Swarm of Bats
*Large, Beast, Unaligned*

**AC** 12
**HP** 11 (2d10)
**Speed** 5 ft., fly 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 5 | 15 | 10 | 2 | 12 | 4 |

CR 1/4, PB +2, XP 50

## Traits

**Swarm**
The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny bat. The swarm can't regain Hit Points or gain Temporary Hit Points.

## Actions

**Bites**
*Melee Attack Roll:* +4, reach 5 ft. 5 (2d4) Piercing damage, or 2 (1d4) Piercing damage if the swarm is Bloodied.
`,
      "swarm-of-insects.md": `---
smType: creature
name: "Swarm of Insects"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "11"
hp: "19"
hit_dice: "3d8 + 6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":3},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":7},{\\"ability\\":\\"cha\\",\\"score\\":1}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Spider Climb\\",\\"text\\":\\"If the swarm has a Climb Speed, the swarm can climb difficult surfaces, including along ceilings, without needing to make an ability check.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Swarm\\",\\"text\\":\\"The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny insect. The swarm can't regain Hit Points or gain Temporary Hit Points.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bites\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 6 (2d4 + 1) Poison damage, or 3 (1d4 + 1) Poison damage if the swarm is Bloodied.\\"}]"
---

# Swarm of Insects
*Medium, Beast, Unaligned*

**AC** 11
**HP** 19 (3d8 + 6)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 3 | 13 | 14 | 1 | 7 | 1 |

CR 1/2, PB +2, XP 100

## Traits

**Spider Climb**
If the swarm has a Climb Speed, the swarm can climb difficult surfaces, including along ceilings, without needing to make an ability check.

**Swarm**
The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny insect. The swarm can't regain Hit Points or gain Temporary Hit Points.

## Actions

**Bites**
*Melee Attack Roll:* +3, reach 5 ft. 6 (2d4 + 1) Poison damage, or 3 (1d4 + 1) Poison damage if the swarm is Bloodied.
`,
      "swarm-of-piranhas.md": `---
smType: creature
name: "Swarm of Piranhas"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "28"
hit_dice: "8d8 - 8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":13},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":9},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":7},{\\"ability\\":\\"cha\\",\\"score\\":2}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Swarm\\",\\"text\\":\\"The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny piranha. The swarm can't regain Hit Points or gain Temporary Hit Points.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Water Breathing\\",\\"text\\":\\"The swarm can breathe only underwater.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bites\\",\\"text\\":\\"*Melee Attack Roll:* +5 (with Advantage if the target doesn't have all its Hit Points), reach 5 ft. 8 (2d4 + 3) Piercing damage, or 5 (1d4 + 3) Piercing damage if the swarm is Bloodied.\\"}]"
---

# Swarm of Piranhas
*Medium, Beast, Unaligned*

**AC** 13
**HP** 28 (8d8 - 8)
**Speed** 5 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 13 | 16 | 9 | 1 | 7 | 2 |

CR 1, PB +2, XP 200

## Traits

**Swarm**
The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny piranha. The swarm can't regain Hit Points or gain Temporary Hit Points.

**Water Breathing**
The swarm can breathe only underwater.

## Actions

**Bites**
*Melee Attack Roll:* +5 (with Advantage if the target doesn't have all its Hit Points), reach 5 ft. 8 (2d4 + 3) Piercing damage, or 5 (1d4 + 3) Piercing damage if the swarm is Bloodied.
`,
      "swarm-of-rats.md": `---
smType: creature
name: "Swarm of Rats"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "10"
hp: "14"
hit_dice: "4d8 - 4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":9},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":9},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Swarm\\",\\"text\\":\\"The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny rat. The swarm can't regain Hit Points or gain Temporary Hit Points.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bites\\",\\"text\\":\\"*Melee Attack Roll:* +2, reach 5 ft. 5 (2d4) Piercing damage, or 2 (1d4) Piercing damage if the swarm is Bloodied.\\"}]"
---

# Swarm of Rats
*Medium, Beast, Unaligned*

**AC** 10
**HP** 14 (4d8 - 4)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 9 | 11 | 9 | 2 | 10 | 3 |

CR 1/4, PB +2, XP 50

## Traits

**Swarm**
The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny rat. The swarm can't regain Hit Points or gain Temporary Hit Points.

## Actions

**Bites**
*Melee Attack Roll:* +2, reach 5 ft. 5 (2d4) Piercing damage, or 2 (1d4) Piercing damage if the swarm is Bloodied.
`,
      "swarm-of-ravens.md": `---
smType: creature
name: "Swarm of Ravens"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "11"
hit_dice: "2d8 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"fly\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":6},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":5},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Swarm\\",\\"text\\":\\"The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny raven. The swarm can't regain Hit Points or gain Temporary Hit Points.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Beaks\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage, or 2 (1d4) Piercing damage if the swarm is Bloodied.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Cacophony\\",\\"recharge\\":\\"Recharge 6\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 10, one creature in the swarm's space. *Failure:*  The target has the Deafened condition until the start of the swarm's next turn. While Deafened, the target also has Disadvantage on ability checks and attack rolls.\\"}]"
---

# Swarm of Ravens
*Medium, Beast, Unaligned*

**AC** 12
**HP** 11 (2d8 + 2)
**Speed** 10 ft., fly 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 6 | 14 | 12 | 5 | 12 | 6 |

CR 1/4, PB +2, XP 50

## Traits

**Swarm**
The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny raven. The swarm can't regain Hit Points or gain Temporary Hit Points.

## Actions

**Beaks**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage, or 2 (1d4) Piercing damage if the swarm is Bloodied.

**Cacophony (Recharge 6)**
*Wisdom Saving Throw*: DC 10, one creature in the swarm's space. *Failure:*  The target has the Deafened condition until the start of the swarm's next turn. While Deafened, the target also has Disadvantage on ability checks and attack rolls.
`,
      "swarm-of-venomous-snakes.md": `---
smType: creature
name: "Swarm of Venomous Snakes"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "14"
hp: "36"
hit_dice: "8d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":8},{\\"ability\\":\\"dex\\",\\"score\\":18},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Swarm\\",\\"text\\":\\"The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny snake. The swarm can't regain Hit Points or gain Temporary Hit Points.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bites\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 8 (1d8 + 4) Piercing damage\u2014or 6 (1d4 + 4) Piercing damage if the swarm is Bloodied\u2014plus 10 (3d6) Poison damage.\\"}]"
---

# Swarm of Venomous Snakes
*Medium, Beast, Unaligned*

**AC** 14
**HP** 36 (8d8)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 8 | 18 | 11 | 1 | 10 | 3 |

CR 2, PB +2, XP 450

## Traits

**Swarm**
The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny snake. The swarm can't regain Hit Points or gain Temporary Hit Points.

## Actions

**Bites**
*Melee Attack Roll:* +6, reach 5 ft. 8 (1d8 + 4) Piercing damage\u2014or 6 (1d4 + 4) Piercing damage if the swarm is Bloodied\u2014plus 10 (3d6) Poison damage.
`,
      "tiger.md": `---
smType: creature
name: "Tiger"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "30"
hit_dice: "4d10 + 8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage. If the target is a Large or smaller creature, it has the Prone condition.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Nimble Escape\\",\\"text\\":\\"The tiger takes the Disengage or Hide action.\\"}]"
---

# Tiger
*Large, Beast, Unaligned*

**AC** 13
**HP** 30 (4d10 + 8)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 16 | 14 | 3 | 12 | 8 |

CR 1, PB +2, XP 200

## Actions

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage. If the target is a Large or smaller creature, it has the Prone condition.

## Bonus Actions

**Nimble Escape**
The tiger takes the Disengage or Hide action.
`,
      "triceratops.md": `---
smType: creature
name: "Triceratops"
size: "Huge"
type: "Beast"
type_tags: ["Dinosaur"]
alignment: "Unaligned"
ac: "14"
hp: "114"
hit_dice: "12d12 + 36"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":22},{\\"ability\\":\\"dex\\",\\"score\\":9},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The triceratops makes two Gore attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Gore\\",\\"text\\":\\"*Melee Attack Roll:* +9, reach 5 ft. 19 (2d12 + 6) Piercing damage. If the target is Huge or smaller and the triceratops moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.\\"}]"
---

# Triceratops
*Huge, Beast, Unaligned*

**AC** 14
**HP** 114 (12d12 + 36)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 22 | 9 | 17 | 2 | 11 | 5 |

CR 5, PB +3, XP 1800

## Actions

**Multiattack**
The triceratops makes two Gore attacks.

**Gore**
*Melee Attack Roll:* +9, reach 5 ft. 19 (2d12 + 6) Piercing damage. If the target is Huge or smaller and the triceratops moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.
`,
      "tyrannosaurus-rex.md": `---
smType: creature
name: "Tyrannosaurus Rex"
size: "Huge"
type: "Beast"
type_tags: ["Dinosaur"]
alignment: "Unaligned"
ac: "13"
hp: "136"
hit_dice: "13d12 + 52"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":25},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":19},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":9}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":10},{\\"ability\\":\\"wis\\",\\"bonus\\":4}]"
cr: "8"
xp: "3900"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The tyrannosaurus makes one Bite attack and one Tail attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +10, reach 10 ft. 33 (4d12 + 7) Piercing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 17). While Grappled, the target has the Restrained condition and can't be targeted by the tyrannosaurus's Tail.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tail\\",\\"text\\":\\"*Melee Attack Roll:* +10, reach 15 ft. 25 (4d8 + 7) Bludgeoning damage. If the target is a Huge or smaller creature, it has the Prone condition.\\"}]"
---

# Tyrannosaurus Rex
*Huge, Beast, Unaligned*

**AC** 13
**HP** 136 (13d12 + 52)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 25 | 10 | 19 | 2 | 12 | 9 |

CR 8, PB +3, XP 3900

## Actions

**Multiattack**
The tyrannosaurus makes one Bite attack and one Tail attack.

**Bite**
*Melee Attack Roll:* +10, reach 10 ft. 33 (4d12 + 7) Piercing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 17). While Grappled, the target has the Restrained condition and can't be targeted by the tyrannosaurus's Tail.

**Tail**
*Melee Attack Roll:* +10, reach 15 ft. 25 (4d8 + 7) Bludgeoning damage. If the target is a Huge or smaller creature, it has the Prone condition.
`,
      "venomous-snake.md": `---
smType: creature
name: "Venomous Snake"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "5"
hit_dice: "2d4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":2},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage plus 3 (1d6) Poison damage.\\"}]"
---

# Venomous Snake
*Small, Beast, Unaligned*

**AC** 12
**HP** 5 (2d4)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 2 | 15 | 11 | 1 | 10 | 3 |

CR 1/8, PB +2, XP 25

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage plus 3 (1d6) Poison damage.
`,
      "vulture.md": `---
smType: creature
name: "Vulture"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "10"
hp: "5"
hit_dice: "1d8 + 1"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"fly\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":7},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":4}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The vulture has Advantage on an attack roll against a creature if at least one of the vulture's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Beak\\",\\"text\\":\\"*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Piercing damage.\\"}]"
---

# Vulture
*Medium, Beast, Unaligned*

**AC** 10
**HP** 5 (1d8 + 1)
**Speed** 10 ft., fly 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 7 | 10 | 13 | 2 | 12 | 4 |

CR 0, PB +2, XP 0

## Traits

**Pack Tactics**
The vulture has Advantage on an attack roll against a creature if at least one of the vulture's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Beak**
*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Piercing damage.
`,
      "warhorse.md": `---
smType: creature
name: "Warhorse"
size: "Large"
type: "Beast"
alignment: "Unaligned"
ac: "11"
hp: "19"
hit_dice: "3d10 + 3"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"wis\\",\\"bonus\\":3}]"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Hooves\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 9 (2d4 + 4) Bludgeoning damage. If the target is a Large or smaller creature and the horse moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.\\"}]"
---

# Warhorse
*Large, Beast, Unaligned*

**AC** 11
**HP** 19 (3d10 + 3)
**Speed** 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 12 | 13 | 2 | 12 | 7 |

CR 1/2, PB +2, XP 100

## Actions

**Hooves**
*Melee Attack Roll:* +6, reach 5 ft. 9 (2d4 + 4) Bludgeoning damage. If the target is a Large or smaller creature and the horse moved 20+ feet straight toward it immediately before the hit, the target takes an extra 5 (2d4) Bludgeoning damage and has the Prone condition.
`,
      "weasel.md": `---
smType: creature
name: "Weasel"
size: "Small"
type: "Beast"
alignment: "Unaligned"
ac: "13"
hp: "1"
hit_dice: "1d4 - 1"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":3},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":8},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 1 Piercing damage.\\"}]"
---

# Weasel
*Small, Beast, Unaligned*

**AC** 13
**HP** 1 (1d4 - 1)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 3 | 16 | 8 | 2 | 12 | 3 |

CR 0, PB +2, XP 0

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 1 Piercing damage.
`,
      "wolf.md": `---
smType: creature
name: "Wolf"
size: "Medium"
type: "Beast"
alignment: "Unaligned"
ac: "12"
hp: "11"
hit_dice: "2d8 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":14},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The wolf has Advantage on attack rolls against a creature if at least one of the wolf's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage. If the target is a Medium or smaller creature, it has the Prone condition.\\"}]"
---

# Wolf
*Medium, Beast, Unaligned*

**AC** 12
**HP** 11 (2d8 + 2)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 14 | 15 | 12 | 3 | 12 | 6 |

CR 1/4, PB +2, XP 50

## Traits

**Pack Tactics**
The wolf has Advantage on attack rolls against a creature if at least one of the wolf's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage. If the target is a Medium or smaller creature, it has the Prone condition.
`,
      "aboleth.md": `---
smType: creature
name: "Aboleth"
size: "Large"
type: "Aberration"
alignment: "Lawful Evil"
ac: "17"
hp: "150"
hit_dice: "20d10 + 40"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":21},{\\"ability\\":\\"dex\\",\\"score\\":9},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":18},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":18}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":3},{\\"ability\\":\\"con\\",\\"bonus\\":6},{\\"ability\\":\\"int\\",\\"bonus\\":8},{\\"ability\\":\\"wis\\",\\"bonus\\":6}]"
cr: "10"
xp: "5900"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The aboleth can breathe air and water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Eldritch Restoration\\",\\"text\\":\\"If destroyed, the aboleth gains a new body in 5d10 days, reviving with all its Hit Points in the Far Realm or another location chosen by the DM.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day, or 4/Day in Lair)\\",\\"text\\":\\"If the aboleth fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Mucus Cloud\\",\\"text\\":\\"While underwater, the aboleth is surrounded by mucus. *Constitution Saving Throw*: DC 14, each creature in a 5-foot Emanation originating from the aboleth at the end of the aboleth's turn. *Failure:*  The target is cursed. Until the curse ends, the target's skin becomes slimy, the target can breathe air and water, and it can't regain Hit Points unless it is underwater. While the cursed creature is outside a body of water, the creature takes 6 (1d12) Acid damage at the end of every 10 minutes unless moisture is applied to its skin before those minutes have passed.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Probing Telepathy\\",\\"text\\":\\"If a creature the aboleth can see communicates telepathically with the aboleth, the aboleth learns the creature's greatest desires.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The aboleth makes two Tentacle attacks and uses either Consume Memories or Dominate Mind if available.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tentacle\\",\\"text\\":\\"*Melee Attack Roll:* +9, reach 15 ft. 12 (2d6 + 5) Bludgeoning damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of four tentacles.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Consume Memories\\",\\"text\\":\\"*Intelligence Saving Throw*: DC 16, one creature within 30 feet that is Charmed or Grappled by the aboleth. *Failure:*  10 (3d6) Psychic damage. *Success:*  Half damage. *Failure or Success*:  The aboleth gains the target's memories if the target is a Humanoid and is reduced to 0 Hit Points by this action.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Dominate Mind (2/Day)\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 16, one creature the aboleth can see within 30 feet. *Failure:*  The target has the Charmed condition until the aboleth dies or is on a different plane of existence from the target. While Charmed, the target acts as an ally to the aboleth and is under its control while within 60 feet of it. In addition, the aboleth and the target can communicate telepathically with each other over any distance. The target repeats the save whenever it takes damage as well as after every 24 hours it spends at least 1 mile away from the aboleth, ending the effect on itself on a success.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Lash\\",\\"text\\":\\"The aboleth makes one Tentacle attack.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Psychic Drain\\",\\"text\\":\\"If the aboleth has at least one creature Charmed or Grappled, it uses Consume Memories and regains 5 (1d10) Hit Points.\\"}]"
---

# Aboleth
*Large, Aberration, Lawful Evil*

**AC** 17
**HP** 150 (20d10 + 40)
**Speed** 10 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 21 | 9 | 15 | 18 | 15 | 18 |

CR 10, XP 5900

## Traits

**Amphibious**
The aboleth can breathe air and water.

**Eldritch Restoration**
If destroyed, the aboleth gains a new body in 5d10 days, reviving with all its Hit Points in the Far Realm or another location chosen by the DM.

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the aboleth fails a saving throw, it can choose to succeed instead.

**Mucus Cloud**
While underwater, the aboleth is surrounded by mucus. *Constitution Saving Throw*: DC 14, each creature in a 5-foot Emanation originating from the aboleth at the end of the aboleth's turn. *Failure:*  The target is cursed. Until the curse ends, the target's skin becomes slimy, the target can breathe air and water, and it can't regain Hit Points unless it is underwater. While the cursed creature is outside a body of water, the creature takes 6 (1d12) Acid damage at the end of every 10 minutes unless moisture is applied to its skin before those minutes have passed.

**Probing Telepathy**
If a creature the aboleth can see communicates telepathically with the aboleth, the aboleth learns the creature's greatest desires.

## Actions

**Multiattack**
The aboleth makes two Tentacle attacks and uses either Consume Memories or Dominate Mind if available.

**Tentacle**
*Melee Attack Roll:* +9, reach 15 ft. 12 (2d6 + 5) Bludgeoning damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of four tentacles.

**Consume Memories**
*Intelligence Saving Throw*: DC 16, one creature within 30 feet that is Charmed or Grappled by the aboleth. *Failure:*  10 (3d6) Psychic damage. *Success:*  Half damage. *Failure or Success*:  The aboleth gains the target's memories if the target is a Humanoid and is reduced to 0 Hit Points by this action.

**Dominate Mind (2/Day)**
*Wisdom Saving Throw*: DC 16, one creature the aboleth can see within 30 feet. *Failure:*  The target has the Charmed condition until the aboleth dies or is on a different plane of existence from the target. While Charmed, the target acts as an ally to the aboleth and is under its control while within 60 feet of it. In addition, the aboleth and the target can communicate telepathically with each other over any distance. The target repeats the save whenever it takes damage as well as after every 24 hours it spends at least 1 mile away from the aboleth, ending the effect on itself on a success.

## Legendary Actions

**Lash**
The aboleth makes one Tentacle attack.

**Psychic Drain**
If the aboleth has at least one creature Charmed or Grappled, it uses Consume Memories and regains 5 (1d10) Hit Points.
`,
      "adult-black-dragon.md": `---
smType: creature
name: "Adult Black Dragon"
size: "Huge"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Chaotic Evil"
ac: "19"
hp: "195"
hit_dice: "17d12 + 85"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":23},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":21},{\\"ability\\":\\"int\\",\\"score\\":14},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":19}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":7},{\\"ability\\":\\"wis\\",\\"bonus\\":6}]"
cr: "14"
xp: "11500"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day, or 4/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Acid Arrow* (level 3 version).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +11, reach 10 ft. 13 (2d6 + 6) Slashing damage plus 4 (1d8) Acid damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Acid Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 18, each creature in a 60-foot-long, 5-foot-wide Line. *Failure:*  54 (12d8) Acid damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17, +9 to hit with spell attacks): - **At Will:** *Detect Magic*, *Fear*, *Acid Arrow* - **1e/Day Each:** *Speak with Dead*, *Vitriolic Sphere*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Cloud of Insects\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 17, one creature the dragon can see within 120 feet. *Failure:*  22 (4d10) Poison damage, and the target has Disadvantage on saving throws to maintain  Concentration until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Frightful Presence\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Fear*. The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon can move up to half its Speed, and it makes one Rend attack.\\"}]"
---

# Adult Black Dragon
*Huge, Dragon, Chaotic Evil*

**AC** 19
**HP** 195 (17d12 + 85)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 23 | 14 | 21 | 14 | 13 | 19 |

CR 14, XP 11500

## Traits

**Amphibious**
The dragon can breathe air and water.

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Acid Arrow* (level 3 version).

**Rend**
*Melee Attack Roll:* +11, reach 10 ft. 13 (2d6 + 6) Slashing damage plus 4 (1d8) Acid damage.

**Acid Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 18, each creature in a 60-foot-long, 5-foot-wide Line. *Failure:*  54 (12d8) Acid damage. *Success:*  Half damage.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17, +9 to hit with spell attacks): - **At Will:** *Detect Magic*, *Fear*, *Acid Arrow* - **1e/Day Each:** *Speak with Dead*, *Vitriolic Sphere*

## Legendary Actions

**Cloud of Insects**
*Dexterity Saving Throw*: DC 17, one creature the dragon can see within 120 feet. *Failure:*  22 (4d10) Poison damage, and the target has Disadvantage on saving throws to maintain  Concentration until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Frightful Presence**
The dragon uses Spellcasting to cast *Fear*. The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon can move up to half its Speed, and it makes one Rend attack.
`,
      "adult-blue-dragon.md": `---
smType: creature
name: "Adult Blue Dragon"
size: "Huge"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Lawful Evil"
ac: "19"
hp: "212"
hit_dice: "17d12 + 102"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"burrow\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":25},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":23},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":20}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":5},{\\"ability\\":\\"wis\\",\\"bonus\\":7}]"
cr: "16"
xp: "15000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day, or 4/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Shatter*.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +12, reach 10 ft. 16 (2d8 + 7) Slashing damage plus 5 (1d10) Lightning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Lightning Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 19, each creature in a 90-foot-long, 5-foot-wide Line. *Failure:*  60 (11d10) Lightning damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 18): - **At Will:** *Detect Magic*, *Invisibility*, *Mage Hand*, *Shatter* - **1e/Day Each:** *Scrying*, *Sending*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Cloaked Flight\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Invisibility* on itself, and it can fly up to half its Fly Speed. The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Sonic Boom\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Shatter*. The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Tail Swipe\\",\\"text\\":\\"The dragon makes one Rend attack.\\"}]"
---

# Adult Blue Dragon
*Huge, Dragon, Lawful Evil*

**AC** 19
**HP** 212 (17d12 + 102)
**Speed** 40 ft., fly 80 ft., burrow 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 25 | 10 | 23 | 16 | 15 | 20 |

CR 16, XP 15000

## Traits

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Shatter*.

**Rend**
*Melee Attack Roll:* +12, reach 10 ft. 16 (2d8 + 7) Slashing damage plus 5 (1d10) Lightning damage.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 19, each creature in a 90-foot-long, 5-foot-wide Line. *Failure:*  60 (11d10) Lightning damage. *Success:*  Half damage.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 18): - **At Will:** *Detect Magic*, *Invisibility*, *Mage Hand*, *Shatter* - **1e/Day Each:** *Scrying*, *Sending*

## Legendary Actions

**Cloaked Flight**
The dragon uses Spellcasting to cast *Invisibility* on itself, and it can fly up to half its Fly Speed. The dragon can't take this action again until the start of its next turn.

**Sonic Boom**
The dragon uses Spellcasting to cast *Shatter*. The dragon can't take this action again until the start of its next turn.

**Tail Swipe**
The dragon makes one Rend attack.
`,
      "adult-brass-dragon.md": `---
smType: creature
name: "Adult Brass Dragon"
size: "Huge"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Chaotic Good"
ac: "18"
hp: "172"
hit_dice: "15d12 + 75"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"burrow\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":23},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":21},{\\"ability\\":\\"int\\",\\"score\\":14},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":17}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":5},{\\"ability\\":\\"wis\\",\\"bonus\\":6}]"
cr: "13"
xp: "10000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day, or 4/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of (A) Sleep Breath or (B) Spellcasting to cast *Scorching Ray*.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +11, reach 10 ft. 17 (2d10 + 6) Slashing damage plus 4 (1d8) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fire Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 18, each creature in a 60-foot-long, 5-foot-wide Line. *Failure:*  45 (10d8) Fire damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Sleep Breath\\",\\"text\\":\\"*Constitution Saving Throw*: DC 18, each creature in a 60-foot Cone. *Failure:*  The target has the Incapacitated condition until the end of its next turn, at which point it repeats the save. *Second Failure* The target has the Unconscious condition for 10 minutes. This effect ends for the target if it takes damage or a creature within 5 feet of it takes an action to wake it.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 16): - **At Will:** *Detect Magic*, *Minor Illusion*, *Scorching Ray*, *Shapechange*, *Speak with Animals* - **1e/Day Each:** *Detect Thoughts*, *Control Weather*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Blazing Light\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Scorching Ray*.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Scorching Sands\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 16, one creature the dragon can see within 120 feet. *Failure:*  27 (6d8) Fire damage, and the target's Speed is halved until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.\\"}]"
---

# Adult Brass Dragon
*Huge, Dragon, Chaotic Good*

**AC** 18
**HP** 172 (15d12 + 75)
**Speed** 40 ft., fly 80 ft., burrow 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 23 | 10 | 21 | 14 | 13 | 17 |

CR 13, XP 10000

## Traits

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Sleep Breath or (B) Spellcasting to cast *Scorching Ray*.

**Rend**
*Melee Attack Roll:* +11, reach 10 ft. 17 (2d10 + 6) Slashing damage plus 4 (1d8) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 18, each creature in a 60-foot-long, 5-foot-wide Line. *Failure:*  45 (10d8) Fire damage. *Success:*  Half damage.

**Sleep Breath**
*Constitution Saving Throw*: DC 18, each creature in a 60-foot Cone. *Failure:*  The target has the Incapacitated condition until the end of its next turn, at which point it repeats the save. *Second Failure* The target has the Unconscious condition for 10 minutes. This effect ends for the target if it takes damage or a creature within 5 feet of it takes an action to wake it.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 16): - **At Will:** *Detect Magic*, *Minor Illusion*, *Scorching Ray*, *Shapechange*, *Speak with Animals* - **1e/Day Each:** *Detect Thoughts*, *Control Weather*

## Legendary Actions

**Blazing Light**
The dragon uses Spellcasting to cast *Scorching Ray*.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.

**Scorching Sands**
*Dexterity Saving Throw*: DC 16, one creature the dragon can see within 120 feet. *Failure:*  27 (6d8) Fire damage, and the target's Speed is halved until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.
`,
      "adult-bronze-dragon.md": `---
smType: creature
name: "Adult Bronze Dragon"
size: "Huge"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Lawful Good"
ac: "18"
hp: "212"
hit_dice: "17d12 + 102"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":25},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":23},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":20}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":5},{\\"ability\\":\\"wis\\",\\"bonus\\":7}]"
cr: "15"
xp: "13000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day, or 4/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of (A) Repulsion Breath or (B) Spellcasting to cast *Guiding Bolt* (level 2 version).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +12, reach 10 ft. 16 (2d8 + 7) Slashing damage plus 5 (1d10) Lightning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Lightning Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 19, each creature in a 90-foot-long, 5-foot-wide Line. *Failure:*  55 (10d10) Lightning damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Repulsion Breath\\",\\"text\\":\\"*Strength Saving Throw*: DC 19, each creature in a 30-foot Cone. *Failure:*  The target is pushed up to 60 feet straight away from the dragon and has the Prone condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17, +10 to hit with spell attacks): - **At Will:** *Detect Magic*, *Guiding Bolt*, *Shapechange*, *Speak with Animals*, *Thaumaturgy* - **1e/Day Each:** *Detect Thoughts*, *Water Breathing*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Guiding Light\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Guiding Bolt* (level 2 version).\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Thunderclap\\",\\"text\\":\\"*Constitution Saving Throw*: DC 17, each creature in a 20-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 90 feet. *Failure:*  10 (3d6) Thunder damage, and the target has the Deafened condition until the end of its next turn.\\"}]"
---

# Adult Bronze Dragon
*Huge, Dragon, Lawful Good*

**AC** 18
**HP** 212 (17d12 + 102)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 25 | 10 | 23 | 16 | 15 | 20 |

CR 15, XP 13000

## Traits

**Amphibious**
The dragon can breathe air and water.

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Repulsion Breath or (B) Spellcasting to cast *Guiding Bolt* (level 2 version).

**Rend**
*Melee Attack Roll:* +12, reach 10 ft. 16 (2d8 + 7) Slashing damage plus 5 (1d10) Lightning damage.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 19, each creature in a 90-foot-long, 5-foot-wide Line. *Failure:*  55 (10d10) Lightning damage. *Success:*  Half damage.

**Repulsion Breath**
*Strength Saving Throw*: DC 19, each creature in a 30-foot Cone. *Failure:*  The target is pushed up to 60 feet straight away from the dragon and has the Prone condition.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17, +10 to hit with spell attacks): - **At Will:** *Detect Magic*, *Guiding Bolt*, *Shapechange*, *Speak with Animals*, *Thaumaturgy* - **1e/Day Each:** *Detect Thoughts*, *Water Breathing*

## Legendary Actions

**Guiding Light**
The dragon uses Spellcasting to cast *Guiding Bolt* (level 2 version).

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.

**Thunderclap**
*Constitution Saving Throw*: DC 17, each creature in a 20-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 90 feet. *Failure:*  10 (3d6) Thunder damage, and the target has the Deafened condition until the end of its next turn.
`,
      "adult-copper-dragon.md": `---
smType: creature
name: "Adult Copper Dragon"
size: "Huge"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Chaotic Good"
ac: "18"
hp: "184"
hit_dice: "16d12 + 80"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":23},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":21},{\\"ability\\":\\"int\\",\\"score\\":18},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":18}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":6},{\\"ability\\":\\"wis\\",\\"bonus\\":7}]"
cr: "14"
xp: "11500"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day, or 4/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of (A) Slowing Breath or (B) Spellcasting to cast *Mind Spike* (level 4 version).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +11, reach 10 ft. 17 (2d10 + 6) Slashing damage plus 4 (1d8) Acid damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Acid Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 18, each creature in an 60-foot-long, 5-foot-wide Line. *Failure:*  54 (12d8) Acid damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Slowing Breath\\",\\"text\\":\\"*Constitution Saving Throw*: DC 18, each creature in a 60-foot Cone. *Failure:*  The target can't take Reactions; its Speed is halved; and it can take either an action or a Bonus Action on its turn, not both. This effect lasts until the end of its next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Magic*, *Mind Spike*, *Minor Illusion*, *Shapechange* - **1e/Day Each:** *Greater Restoration*, *Major Image*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Giggling Magic\\",\\"text\\":\\"*Charisma Saving Throw*: DC 17, one creature the dragon can see within 90 feet. *Failure:*  24 (7d6) Psychic damage. Until the end of its next turn, the target rolls 1d6 whenever it makes an ability check or attack roll and subtracts the number rolled from the D20 Test. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Mind Jolt\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Mind Spike* (level 4 version). The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"}]"
---

# Adult Copper Dragon
*Huge, Dragon, Chaotic Good*

**AC** 18
**HP** 184 (16d12 + 80)
**Speed** 40 ft., climb 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 23 | 12 | 21 | 18 | 15 | 18 |

CR 14, XP 11500

## Traits

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Slowing Breath or (B) Spellcasting to cast *Mind Spike* (level 4 version).

**Rend**
*Melee Attack Roll:* +11, reach 10 ft. 17 (2d10 + 6) Slashing damage plus 4 (1d8) Acid damage.

**Acid Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 18, each creature in an 60-foot-long, 5-foot-wide Line. *Failure:*  54 (12d8) Acid damage. *Success:*  Half damage.

**Slowing Breath**
*Constitution Saving Throw*: DC 18, each creature in a 60-foot Cone. *Failure:*  The target can't take Reactions; its Speed is halved; and it can take either an action or a Bonus Action on its turn, not both. This effect lasts until the end of its next turn.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Magic*, *Mind Spike*, *Minor Illusion*, *Shapechange* - **1e/Day Each:** *Greater Restoration*, *Major Image*

## Legendary Actions

**Giggling Magic**
*Charisma Saving Throw*: DC 17, one creature the dragon can see within 90 feet. *Failure:*  24 (7d6) Psychic damage. Until the end of its next turn, the target rolls 1d6 whenever it makes an ability check or attack roll and subtracts the number rolled from the D20 Test. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Mind Jolt**
The dragon uses Spellcasting to cast *Mind Spike* (level 4 version). The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "adult-gold-dragon.md": `---
smType: creature
name: "Adult Gold Dragon"
size: "Huge"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Lawful Good"
ac: "19"
hp: "243"
hit_dice: "18d12 + 126"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":27},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":25},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":24}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":8},{\\"ability\\":\\"wis\\",\\"bonus\\":8}]"
cr: "17"
xp: "18000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day, or 4/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of (A) Spellcasting to cast *Guiding Bolt* (level 2 version) or (B) Weakening Breath.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +14, reach 10 ft. 17 (2d8 + 8) Slashing damage plus 4 (1d8) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fire Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 21, each creature in a 60-foot Cone. *Failure:*  66 (12d10) Fire damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Weakening Breath\\",\\"text\\":\\"*Strength Saving Throw*: DC 21, each creature that isn't currently affected by this breath in a 60-foot Cone. *Failure:*  The target has Disadvantage on Strength-based D20 Test and subtracts 3 (1d6) from its damage rolls. It repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21, +13 to hit with spell attacks): - **At Will:** *Detect Magic*, *Guiding Bolt*, *Shapechange* - **1e/Day Each:** *Flame Strike*, *Zone of Truth*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Banish\\",\\"text\\":\\"*Charisma Saving Throw*: DC 21, one creature the dragon can see within 120 feet. *Failure:*  10 (3d6) Force damage, and the target has the Incapacitated condition and is transported to a harmless demiplane until the start of the dragon's next turn, at which point it reappears in an unoccupied space of the dragon's choice within 120 feet of the dragon. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Guiding Light\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Guiding Bolt* (level 2 version).\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"}]"
---

# Adult Gold Dragon
*Huge, Dragon, Lawful Good*

**AC** 19
**HP** 243 (18d12 + 126)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 27 | 14 | 25 | 16 | 15 | 24 |

CR 17, XP 18000

## Traits

**Amphibious**
The dragon can breathe air and water.

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Spellcasting to cast *Guiding Bolt* (level 2 version) or (B) Weakening Breath.

**Rend**
*Melee Attack Roll:* +14, reach 10 ft. 17 (2d8 + 8) Slashing damage plus 4 (1d8) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 21, each creature in a 60-foot Cone. *Failure:*  66 (12d10) Fire damage. *Success:*  Half damage.

**Weakening Breath**
*Strength Saving Throw*: DC 21, each creature that isn't currently affected by this breath in a 60-foot Cone. *Failure:*  The target has Disadvantage on Strength-based D20 Test and subtracts 3 (1d6) from its damage rolls. It repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21, +13 to hit with spell attacks): - **At Will:** *Detect Magic*, *Guiding Bolt*, *Shapechange* - **1e/Day Each:** *Flame Strike*, *Zone of Truth*

## Legendary Actions

**Banish**
*Charisma Saving Throw*: DC 21, one creature the dragon can see within 120 feet. *Failure:*  10 (3d6) Force damage, and the target has the Incapacitated condition and is transported to a harmless demiplane until the start of the dragon's next turn, at which point it reappears in an unoccupied space of the dragon's choice within 120 feet of the dragon. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Guiding Light**
The dragon uses Spellcasting to cast *Guiding Bolt* (level 2 version).

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "adult-green-dragon.md": `---
smType: creature
name: "Adult Green Dragon"
size: "Huge"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Lawful Evil"
ac: "19"
hp: "207"
hit_dice: "18d12 + 90"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":23},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":21},{\\"ability\\":\\"int\\",\\"score\\":18},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":18}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":6},{\\"ability\\":\\"wis\\",\\"bonus\\":7}]"
cr: "15"
xp: "13000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day, or 4/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Mind Spike* (level 3 version).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +11, reach 10 ft. 15 (2d8 + 6) Slashing damage plus 7 (2d6) Poison damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Poison Breath (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 18, each creature in a 60-foot Cone. *Failure:*  56 (16d6) Poison damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Magic*, *Mind Spike* - **1/Day Each:** *Geas*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Mind Invasion\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Mind Spike* (level 3 version).\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Noxious Miasma\\",\\"text\\":\\"*Constitution Saving Throw*: DC 17, each creature in a 20-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 90 feet. *Failure:*  7 (2d6) Poison damage, and the target takes a -2 penalty to AC until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"}]"
---

# Adult Green Dragon
*Huge, Dragon, Lawful Evil*

**AC** 19
**HP** 207 (18d12 + 90)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 23 | 12 | 21 | 18 | 15 | 18 |

CR 15, XP 13000

## Traits

**Amphibious**
The dragon can breathe air and water.

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Mind Spike* (level 3 version).

**Rend**
*Melee Attack Roll:* +11, reach 10 ft. 15 (2d8 + 6) Slashing damage plus 7 (2d6) Poison damage.

**Poison Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 18, each creature in a 60-foot Cone. *Failure:*  56 (16d6) Poison damage. *Success:*  Half damage.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Magic*, *Mind Spike* - **1/Day Each:** *Geas*

## Legendary Actions

**Mind Invasion**
The dragon uses Spellcasting to cast *Mind Spike* (level 3 version).

**Noxious Miasma**
*Constitution Saving Throw*: DC 17, each creature in a 20-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 90 feet. *Failure:*  7 (2d6) Poison damage, and the target takes a -2 penalty to AC until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "adult-red-dragon.md": `---
smType: creature
name: "Adult Red Dragon"
size: "Huge"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Chaotic Evil"
ac: "19"
hp: "256"
hit_dice: "19d12 + 133"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":27},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":25},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":23}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":6},{\\"ability\\":\\"wis\\",\\"bonus\\":7}]"
cr: "17"
xp: "18000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day, or 4/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Scorching Ray*.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +14, reach 10 ft. 13 (1d10 + 8) Slashing damage plus 5 (2d4) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fire Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 21, each creature in a 60-foot Cone. *Failure:*  59 (17d6) Fire damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 20, +12 to hit with spell attacks): - **At Will:** *Command*, *Detect Magic*, *Scorching Ray* - **1/Day Each:** *Fireball*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Commanding Presence\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Command* (level 2 version). The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Fiery Rays\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Scorching Ray*. The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"}]"
---

# Adult Red Dragon
*Huge, Dragon, Chaotic Evil*

**AC** 19
**HP** 256 (19d12 + 133)
**Speed** 40 ft., climb 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 27 | 10 | 25 | 16 | 13 | 23 |

CR 17, XP 18000

## Traits

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Scorching Ray*.

**Rend**
*Melee Attack Roll:* +14, reach 10 ft. 13 (1d10 + 8) Slashing damage plus 5 (2d4) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 21, each creature in a 60-foot Cone. *Failure:*  59 (17d6) Fire damage. *Success:*  Half damage.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 20, +12 to hit with spell attacks): - **At Will:** *Command*, *Detect Magic*, *Scorching Ray* - **1/Day Each:** *Fireball*

## Legendary Actions

**Commanding Presence**
The dragon uses Spellcasting to cast *Command* (level 2 version). The dragon can't take this action again until the start of its next turn.

**Fiery Rays**
The dragon uses Spellcasting to cast *Scorching Ray*. The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "adult-silver-dragon.md": `---
smType: creature
name: "Adult Silver Dragon"
size: "Huge"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Lawful Good"
ac: "19"
hp: "216"
hit_dice: "16d12 + 112"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":27},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":25},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":22}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":5},{\\"ability\\":\\"wis\\",\\"bonus\\":6}]"
cr: "16"
xp: "15000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day, or 4/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of (A) Paralyzing Breath or (B) Spellcasting to cast *Ice Knife*.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +13, reach 10 ft. 17 (2d8 + 8) Slashing damage plus 4 (1d8) Cold damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Cold Breath (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 20, each creature in a 60-foot Cone. *Failure:*  54 (12d8) Cold damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Paralyzing Breath\\",\\"text\\":\\"*Constitution Saving Throw*: DC 20, each creature in a 60-foot Cone. *First Failure* The target has the Incapacitated condition until the end of its next turn, when it repeats the save. *Second Failure* The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 19, +11 to hit with spell attacks): - **At Will:** *Detect Magic*, *Hold Monster*, *Ice Knife*, *Shapechange* - **1e/Day Each:** *Ice Storm*, *Zone of Truth*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Chill\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Hold Monster*. The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Cold Gale\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 19, each creature in a 60-foot-long, 10-foot-wide Line. *Failure:*  14 (4d6) Cold damage, and the target is pushed up to 30 feet straight away from the dragon. *Success:*  Half damage only. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"}]"
---

# Adult Silver Dragon
*Huge, Dragon, Lawful Good*

**AC** 19
**HP** 216 (16d12 + 112)
**Speed** 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 27 | 10 | 25 | 16 | 13 | 22 |

CR 16, XP 15000

## Traits

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Paralyzing Breath or (B) Spellcasting to cast *Ice Knife*.

**Rend**
*Melee Attack Roll:* +13, reach 10 ft. 17 (2d8 + 8) Slashing damage plus 4 (1d8) Cold damage.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 20, each creature in a 60-foot Cone. *Failure:*  54 (12d8) Cold damage. *Success:*  Half damage.

**Paralyzing Breath**
*Constitution Saving Throw*: DC 20, each creature in a 60-foot Cone. *First Failure* The target has the Incapacitated condition until the end of its next turn, when it repeats the save. *Second Failure* The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 19, +11 to hit with spell attacks): - **At Will:** *Detect Magic*, *Hold Monster*, *Ice Knife*, *Shapechange* - **1e/Day Each:** *Ice Storm*, *Zone of Truth*

## Legendary Actions

**Chill**
The dragon uses Spellcasting to cast *Hold Monster*. The dragon can't take this action again until the start of its next turn.

**Cold Gale**
*Dexterity Saving Throw*: DC 19, each creature in a 60-foot-long, 10-foot-wide Line. *Failure:*  14 (4d6) Cold damage, and the target is pushed up to 30 feet straight away from the dragon. *Success:*  Half damage only. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "adult-white-dragon.md": `---
smType: creature
name: "Adult White Dragon"
size: "Huge"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Chaotic Evil"
ac: "18"
hp: "200"
hit_dice: "16d12 + 96"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"burrow\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":22},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":22},{\\"ability\\":\\"int\\",\\"score\\":8},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":12}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":5},{\\"ability\\":\\"wis\\",\\"bonus\\":6}]"
cr: "13"
xp: "10000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Ice Walk\\",\\"text\\":\\"The dragon can move across and climb icy surfaces without needing to make an ability check. Additionally, Difficult Terrain composed of ice or snow doesn't cost it extra movement.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day, or 4/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +11, reach 10 ft. 13 (2d6 + 6) Slashing damage plus 4 (1d8) Cold damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Cold Breath (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 19, each creature in a 60-foot Cone. *Failure:*  54 (12d8) Cold damage. *Success:*  Half damage.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Freezing Burst\\",\\"text\\":\\"*Constitution Saving Throw*: DC 14, each creature in a 30-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 120 feet. *Failure:*  7 (2d6) Cold damage, and the target's Speed is 0 until the end of the target's next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Frightful Presence\\",\\"text\\":\\"The dragon casts *Fear*, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 14). The dragon can't take this action again until the start of its next turn.\\"}]"
---

# Adult White Dragon
*Huge, Dragon, Chaotic Evil*

**AC** 18
**HP** 200 (16d12 + 96)
**Speed** 40 ft., swim 40 ft., fly 80 ft., burrow 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 22 | 10 | 22 | 8 | 12 | 12 |

CR 13, XP 10000

## Traits

**Ice Walk**
The dragon can move across and climb icy surfaces without needing to make an ability check. Additionally, Difficult Terrain composed of ice or snow doesn't cost it extra movement.

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +11, reach 10 ft. 13 (2d6 + 6) Slashing damage plus 4 (1d8) Cold damage.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 19, each creature in a 60-foot Cone. *Failure:*  54 (12d8) Cold damage. *Success:*  Half damage.

## Legendary Actions

**Freezing Burst**
*Constitution Saving Throw*: DC 14, each creature in a 30-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 120 feet. *Failure:*  7 (2d6) Cold damage, and the target's Speed is 0 until the end of the target's next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.

**Frightful Presence**
The dragon casts *Fear*, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 14). The dragon can't take this action again until the start of its next turn.
`,
      "air-elemental.md": `---
smType: creature
name: "Air Elemental"
size: "Large"
type: "Elemental"
alignment: "Neutral Neutral"
ac: "15"
hp: "90"
hit_dice: "12d10 + 24"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"fly\\":{\\"distance\\":\\"90 ft.\\",\\"hover\\":true}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":14},{\\"ability\\":\\"dex\\",\\"score\\":20},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Air Form\\",\\"text\\":\\"The elemental can enter a creature's space and stop there. It can move through a space as narrow as 1 inch without expending extra movement to do so.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The elemental makes two Thunderous Slam attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Thunderous Slam\\",\\"text\\":\\"*Melee Attack Roll:* +8, reach 10 ft. 14 (2d8 + 5) Thunder damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Whirlwind (Recharge 4-6)\\",\\"text\\":\\"*Strength Saving Throw*: DC 13, one Medium or smaller creature in the elemental's space. *Failure:*  24 (4d10 + 2) Thunder damage, and the target is pushed up to 20 feet straight away from the elemental and has the Prone condition. *Success:*  Half damage only.\\"}]"
---

# Air Elemental
*Large, Elemental, Neutral Neutral*

**AC** 15
**HP** 90 (12d10 + 24)
**Speed** 10 ft., fly 90 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 14 | 20 | 14 | 6 | 10 | 6 |

CR 5, PB +3, XP 1800

## Traits

**Air Form**
The elemental can enter a creature's space and stop there. It can move through a space as narrow as 1 inch without expending extra movement to do so.

## Actions

**Multiattack**
The elemental makes two Thunderous Slam attacks.

**Thunderous Slam**
*Melee Attack Roll:* +8, reach 10 ft. 14 (2d8 + 5) Thunder damage.

**Whirlwind (Recharge 4-6)**
*Strength Saving Throw*: DC 13, one Medium or smaller creature in the elemental's space. *Failure:*  24 (4d10 + 2) Thunder damage, and the target is pushed up to 20 feet straight away from the elemental and has the Prone condition. *Success:*  Half damage only.
`,
      "ancient-black-dragon.md": `---
smType: creature
name: "Ancient Black Dragon"
size: "Gargantuan"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Chaotic Evil"
ac: "22"
hp: "367"
hit_dice: "21d20 + 147"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":27},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":25},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":22}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":9},{\\"ability\\":\\"wis\\",\\"bonus\\":9}]"
cr: "21"
xp: "33000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (4/Day, or 5/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Acid Arrow* (level 4 version).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +15, reach 15 ft. 17 (2d8 + 8) Slashing damage plus 9 (2d8) Acid damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Acid Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 22, each creature in a 90-foot-long, 10-foot-wide Line. *Failure:*  67 (15d8) Acid damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21, +13 to hit with spell attacks): - **At Will:** *Detect Magic*, *Fear*, *Acid Arrow* - **1e/Day Each:** *Create Undead*, *Speak with Dead*, *Vitriolic Sphere*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Cloud of Insects\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 21, one creature the dragon can see within 120 feet. *Failure:*  33 (6d10) Poison damage, and the target has Disadvantage on saving throws to maintain  Concentration until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Frightful Presence\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Fear*. The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"}]"
---

# Ancient Black Dragon
*Gargantuan, Dragon, Chaotic Evil*

**AC** 22
**HP** 367 (21d20 + 147)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 27 | 14 | 25 | 16 | 15 | 22 |

CR 21, XP 33000

## Traits

**Amphibious**
The dragon can breathe air and water.

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Acid Arrow* (level 4 version).

**Rend**
*Melee Attack Roll:* +15, reach 15 ft. 17 (2d8 + 8) Slashing damage plus 9 (2d8) Acid damage.

**Acid Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 22, each creature in a 90-foot-long, 10-foot-wide Line. *Failure:*  67 (15d8) Acid damage. *Success:*  Half damage.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21, +13 to hit with spell attacks): - **At Will:** *Detect Magic*, *Fear*, *Acid Arrow* - **1e/Day Each:** *Create Undead*, *Speak with Dead*, *Vitriolic Sphere*

## Legendary Actions

**Cloud of Insects**
*Dexterity Saving Throw*: DC 21, one creature the dragon can see within 120 feet. *Failure:*  33 (6d10) Poison damage, and the target has Disadvantage on saving throws to maintain  Concentration until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Frightful Presence**
The dragon uses Spellcasting to cast *Fear*. The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "ancient-blue-dragon.md": `---
smType: creature
name: "Ancient Blue Dragon"
size: "Gargantuan"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Lawful Evil"
ac: "22"
hp: "481"
hit_dice: "26d20 + 208"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"burrow\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":29},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":27},{\\"ability\\":\\"int\\",\\"score\\":18},{\\"ability\\":\\"wis\\",\\"score\\":17},{\\"ability\\":\\"cha\\",\\"score\\":25}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":7},{\\"ability\\":\\"wis\\",\\"bonus\\":10}]"
cr: "23"
xp: "50000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (4/Day, or 5/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Shatter* (level 3 version).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +16, reach 15 ft. 18 (2d8 + 9) Slashing damage plus 11 (2d10) Lightning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Lightning Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 23, each creature in a 120-foot-long, 10-foot-wide Line. *Failure:*  88 (16d10) Lightning damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 22): - **At Will:** *Detect Magic*, *Invisibility*, *Mage Hand*, *Shatter* - **1e/Day Each:** *Scrying*, *Sending*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Cloaked Flight\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Invisibility* on itself, and it can fly up to half its Fly Speed. The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Sonic Boom\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Shatter* (level 3 version). The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Tail Swipe\\",\\"text\\":\\"The dragon makes one Rend attack.\\"}]"
---

# Ancient Blue Dragon
*Gargantuan, Dragon, Lawful Evil*

**AC** 22
**HP** 481 (26d20 + 208)
**Speed** 40 ft., fly 80 ft., burrow 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 29 | 10 | 27 | 18 | 17 | 25 |

CR 23, XP 50000

## Traits

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Shatter* (level 3 version).

**Rend**
*Melee Attack Roll:* +16, reach 15 ft. 18 (2d8 + 9) Slashing damage plus 11 (2d10) Lightning damage.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 23, each creature in a 120-foot-long, 10-foot-wide Line. *Failure:*  88 (16d10) Lightning damage. *Success:*  Half damage.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 22): - **At Will:** *Detect Magic*, *Invisibility*, *Mage Hand*, *Shatter* - **1e/Day Each:** *Scrying*, *Sending*

## Legendary Actions

**Cloaked Flight**
The dragon uses Spellcasting to cast *Invisibility* on itself, and it can fly up to half its Fly Speed. The dragon can't take this action again until the start of its next turn.

**Sonic Boom**
The dragon uses Spellcasting to cast *Shatter* (level 3 version). The dragon can't take this action again until the start of its next turn.

**Tail Swipe**
The dragon makes one Rend attack.
`,
      "ancient-brass-dragon.md": `---
smType: creature
name: "Ancient Brass Dragon"
size: "Gargantuan"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Chaotic Good"
ac: "20"
hp: "332"
hit_dice: "19d20 + 133"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"burrow\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":27},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":25},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":22}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":6},{\\"ability\\":\\"wis\\",\\"bonus\\":8}]"
cr: "20"
xp: "25000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (4/Day, or 5/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of (A) Sleep Breath or (B) Spellcasting to cast *Scorching Ray* (level 3 version).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +14, reach 15 ft. 19 (2d10 + 8) Slashing damage plus 7 (2d6) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fire Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 21, each creature in a 90-foot-long, 5-foot-wide Line. *Failure:*  58 (13d8) Fire damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Sleep Breath\\",\\"text\\":\\"*Constitution Saving Throw*: DC 21, each creature in a 90-foot Cone. *Failure:*  The target has the Incapacitated condition until the end of its next turn, at which point it repeats the save. *Second Failure* The target has the Unconscious condition for 10 minutes. This effect ends for the target if it takes damage or a creature within 5 feet of it takes an action to wake it.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 20): - **At Will:** *Detect Magic*, *Minor Illusion*, *Scorching Ray*, *Shapechange*, *Speak with Animals* - **1e/Day Each:** *Control Weather*, *Detect Thoughts*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Blazing Light\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Scorching Ray* (level 3 version).\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Scorching Sands\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 20, one creature the dragon can see within 120 feet. *Failure:*  36 (8d8) Fire damage, and the target's Speed is halved until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.\\"}]"
---

# Ancient Brass Dragon
*Gargantuan, Dragon, Chaotic Good*

**AC** 20
**HP** 332 (19d20 + 133)
**Speed** 40 ft., fly 80 ft., burrow 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 27 | 10 | 25 | 16 | 15 | 22 |

CR 20, XP 25000

## Traits

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Sleep Breath or (B) Spellcasting to cast *Scorching Ray* (level 3 version).

**Rend**
*Melee Attack Roll:* +14, reach 15 ft. 19 (2d10 + 8) Slashing damage plus 7 (2d6) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 21, each creature in a 90-foot-long, 5-foot-wide Line. *Failure:*  58 (13d8) Fire damage. *Success:*  Half damage.

**Sleep Breath**
*Constitution Saving Throw*: DC 21, each creature in a 90-foot Cone. *Failure:*  The target has the Incapacitated condition until the end of its next turn, at which point it repeats the save. *Second Failure* The target has the Unconscious condition for 10 minutes. This effect ends for the target if it takes damage or a creature within 5 feet of it takes an action to wake it.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 20): - **At Will:** *Detect Magic*, *Minor Illusion*, *Scorching Ray*, *Shapechange*, *Speak with Animals* - **1e/Day Each:** *Control Weather*, *Detect Thoughts*

## Legendary Actions

**Blazing Light**
The dragon uses Spellcasting to cast *Scorching Ray* (level 3 version).

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.

**Scorching Sands**
*Dexterity Saving Throw*: DC 20, one creature the dragon can see within 120 feet. *Failure:*  36 (8d8) Fire damage, and the target's Speed is halved until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.
`,
      "ancient-bronze-dragon.md": `---
smType: creature
name: "Ancient Bronze Dragon"
size: "Gargantuan"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Lawful Good"
ac: "22"
hp: "444"
hit_dice: "24d20 + 192"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":29},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":27},{\\"ability\\":\\"int\\",\\"score\\":18},{\\"ability\\":\\"wis\\",\\"score\\":17},{\\"ability\\":\\"cha\\",\\"score\\":25}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":7},{\\"ability\\":\\"wis\\",\\"bonus\\":10}]"
cr: "22"
xp: "41000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (4/Day, or 5/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of (A) Repulsion Breath or (B) Spellcasting to cast *Guiding Bolt* (level 2 version).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +16, reach 15 ft. 18 (2d8 + 9) Slashing damage plus 9 (2d8) Lightning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Lightning Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 23, each creature in a 120-foot-long, 10-foot-wide Line. *Failure:*  82 (15d10) Lightning damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Repulsion Breath\\",\\"text\\":\\"*Strength Saving Throw*: DC 23, each creature in a 30-foot Cone. *Failure:*  The target is pushed up to 60 feet straight away from the dragon and has the Prone condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 22, +14 to hit with spell attacks): - **At Will:** *Detect Magic*, *Guiding Bolt*, *Shapechange*, *Speak with Animals*, *Thaumaturgy* - **1e/Day Each:** *Detect Thoughts*, *Control Water*, *Scrying*, *Water Breathing*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Guiding Light\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Guiding Bolt* (level 2 version).\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Thunderclap\\",\\"text\\":\\"*Constitution Saving Throw*: DC 22, each creature in a 20-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 120 feet. *Failure:*  13 (3d8) Thunder damage, and the target has the Deafened condition until the end of its next turn.\\"}]"
---

# Ancient Bronze Dragon
*Gargantuan, Dragon, Lawful Good*

**AC** 22
**HP** 444 (24d20 + 192)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 29 | 10 | 27 | 18 | 17 | 25 |

CR 22, XP 41000

## Traits

**Amphibious**
The dragon can breathe air and water.

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Repulsion Breath or (B) Spellcasting to cast *Guiding Bolt* (level 2 version).

**Rend**
*Melee Attack Roll:* +16, reach 15 ft. 18 (2d8 + 9) Slashing damage plus 9 (2d8) Lightning damage.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 23, each creature in a 120-foot-long, 10-foot-wide Line. *Failure:*  82 (15d10) Lightning damage. *Success:*  Half damage.

**Repulsion Breath**
*Strength Saving Throw*: DC 23, each creature in a 30-foot Cone. *Failure:*  The target is pushed up to 60 feet straight away from the dragon and has the Prone condition.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 22, +14 to hit with spell attacks): - **At Will:** *Detect Magic*, *Guiding Bolt*, *Shapechange*, *Speak with Animals*, *Thaumaturgy* - **1e/Day Each:** *Detect Thoughts*, *Control Water*, *Scrying*, *Water Breathing*

## Legendary Actions

**Guiding Light**
The dragon uses Spellcasting to cast *Guiding Bolt* (level 2 version).

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.

**Thunderclap**
*Constitution Saving Throw*: DC 22, each creature in a 20-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 120 feet. *Failure:*  13 (3d8) Thunder damage, and the target has the Deafened condition until the end of its next turn.
`,
      "ancient-copper-dragon.md": `---
smType: creature
name: "Ancient Copper Dragon"
size: "Gargantuan"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Chaotic Good"
ac: "21"
hp: "367"
hit_dice: "21d20 + 147"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":27},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":25},{\\"ability\\":\\"int\\",\\"score\\":20},{\\"ability\\":\\"wis\\",\\"score\\":17},{\\"ability\\":\\"cha\\",\\"score\\":22}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":8},{\\"ability\\":\\"wis\\",\\"bonus\\":10}]"
cr: "21"
xp: "33000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (4/Day, or 5/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of (A) Slowing Breath or (B) Spellcasting to cast *Mind Spike* (level 5 version).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +15, reach 15 ft. 19 (2d10 + 8) Slashing damage plus 9 (2d8) Acid damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Acid Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 22, each creature in an 90-foot-long, 10-foot-wide Line. *Failure:*  63 (14d8) Acid damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Slowing Breath\\",\\"text\\":\\"*Constitution Saving Throw*: DC 22, each creature in a 90-foot Cone. *Failure:*  The target can't take Reactions; its Speed is halved; and it can take either an action or a Bonus Action on its turn, not both. This effect lasts until the end of its next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21): - **At Will:** *Detect Magic*, *Mind Spike*, *Minor Illusion*, *Shapechange* - **1e/Day Each:** *Greater Restoration*, *Major Image*, *Project Image*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Giggling Magic\\",\\"text\\":\\"*Charisma Saving Throw*: DC 21, one creature the dragon can see within 120 feet. *Failure:*  31 (9d6) Psychic damage. Until the end of its next turn, the target rolls 1d8 whenever it makes an ability check or attack roll and subtracts the number rolled from the D20 Test. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Mind Jolt\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Mind Spike* (level 5 version). The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"}]"
---

# Ancient Copper Dragon
*Gargantuan, Dragon, Chaotic Good*

**AC** 21
**HP** 367 (21d20 + 147)
**Speed** 40 ft., climb 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 27 | 12 | 25 | 20 | 17 | 22 |

CR 21, XP 33000

## Traits

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Slowing Breath or (B) Spellcasting to cast *Mind Spike* (level 5 version).

**Rend**
*Melee Attack Roll:* +15, reach 15 ft. 19 (2d10 + 8) Slashing damage plus 9 (2d8) Acid damage.

**Acid Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 22, each creature in an 90-foot-long, 10-foot-wide Line. *Failure:*  63 (14d8) Acid damage. *Success:*  Half damage.

**Slowing Breath**
*Constitution Saving Throw*: DC 22, each creature in a 90-foot Cone. *Failure:*  The target can't take Reactions; its Speed is halved; and it can take either an action or a Bonus Action on its turn, not both. This effect lasts until the end of its next turn.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21): - **At Will:** *Detect Magic*, *Mind Spike*, *Minor Illusion*, *Shapechange* - **1e/Day Each:** *Greater Restoration*, *Major Image*, *Project Image*

## Legendary Actions

**Giggling Magic**
*Charisma Saving Throw*: DC 21, one creature the dragon can see within 120 feet. *Failure:*  31 (9d6) Psychic damage. Until the end of its next turn, the target rolls 1d8 whenever it makes an ability check or attack roll and subtracts the number rolled from the D20 Test. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Mind Jolt**
The dragon uses Spellcasting to cast *Mind Spike* (level 5 version). The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "ancient-gold-dragon.md": `---
smType: creature
name: "Ancient Gold Dragon"
size: "Gargantuan"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Lawful Good"
ac: "22"
hp: "546"
hit_dice: "28d20 + 252"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":30},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":29},{\\"ability\\":\\"int\\",\\"score\\":18},{\\"ability\\":\\"wis\\",\\"score\\":17},{\\"ability\\":\\"cha\\",\\"score\\":28}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":9},{\\"ability\\":\\"wis\\",\\"bonus\\":10}]"
cr: "24"
xp: "62000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (4/Day, or 5/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of (A) Spellcasting to cast *Guiding Bolt* (level 4 version) or (B) Weakening Breath.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +17 to hit, reach 15 ft. 19 (2d8 + 10) Slashing damage plus 9 (2d8) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fire Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 24, each creature in a 90-foot Cone. *Failure:*  71 (13d10) Fire damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Weakening Breath\\",\\"text\\":\\"*Strength Saving Throw*: DC 24, each creature that isn't currently affected by this breath in a 90-foot Cone. *Failure:*  The target has Disadvantage on Strength-based D20 Test and subtracts 5 (1d10) from its damage rolls. It repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 24, +16 to hit with spell attacks): - **At Will:** *Detect Magic*, *Guiding Bolt*, *Shapechange* - **1e/Day Each:** *Flame Strike*, *Word of Recall*, *Zone of Truth*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Banish\\",\\"text\\":\\"*Charisma Saving Throw*: DC 24, one creature the dragon can see within 120 feet. *Failure:*  24 (7d6) Force damage, and the target has the Incapacitated condition and is transported to a harmless demiplane until the start of the dragon's next turn, at which point it reappears in an unoccupied space of the dragon's choice within 120 feet of the dragon. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Guiding Light\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Guiding Bolt* (level 4 version).\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"}]"
---

# Ancient Gold Dragon
*Gargantuan, Dragon, Lawful Good*

**AC** 22
**HP** 546 (28d20 + 252)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 30 | 14 | 29 | 18 | 17 | 28 |

CR 24, XP 62000

## Traits

**Amphibious**
The dragon can breathe air and water.

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Spellcasting to cast *Guiding Bolt* (level 4 version) or (B) Weakening Breath.

**Rend**
*Melee Attack Roll:* +17 to hit, reach 15 ft. 19 (2d8 + 10) Slashing damage plus 9 (2d8) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 24, each creature in a 90-foot Cone. *Failure:*  71 (13d10) Fire damage. *Success:*  Half damage.

**Weakening Breath**
*Strength Saving Throw*: DC 24, each creature that isn't currently affected by this breath in a 90-foot Cone. *Failure:*  The target has Disadvantage on Strength-based D20 Test and subtracts 5 (1d10) from its damage rolls. It repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 24, +16 to hit with spell attacks): - **At Will:** *Detect Magic*, *Guiding Bolt*, *Shapechange* - **1e/Day Each:** *Flame Strike*, *Word of Recall*, *Zone of Truth*

## Legendary Actions

**Banish**
*Charisma Saving Throw*: DC 24, one creature the dragon can see within 120 feet. *Failure:*  24 (7d6) Force damage, and the target has the Incapacitated condition and is transported to a harmless demiplane until the start of the dragon's next turn, at which point it reappears in an unoccupied space of the dragon's choice within 120 feet of the dragon. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Guiding Light**
The dragon uses Spellcasting to cast *Guiding Bolt* (level 4 version).

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "ancient-green-dragon.md": `---
smType: creature
name: "Ancient Green Dragon"
size: "Gargantuan"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Lawful Evil"
ac: "21"
hp: "402"
hit_dice: "23d20 + 161"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":27},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":25},{\\"ability\\":\\"int\\",\\"score\\":20},{\\"ability\\":\\"wis\\",\\"score\\":17},{\\"ability\\":\\"cha\\",\\"score\\":22}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":8},{\\"ability\\":\\"wis\\",\\"bonus\\":10}]"
cr: "22"
xp: "41000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (4/Day, or 5/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Mind Spike* (level 5 version).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +15, reach 15 ft. 17 (2d8 + 8) Slashing damage plus 10 (3d6) Poison damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Poison Breath (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 22, each creature in a 90-foot Cone. *Failure:*  77 (22d6) Poison damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21): - **At Will:** *Detect Magic*, *Mind Spike* - **1e/Day Each:** *Geas*, *Modify Memory*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Mind Invasion\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Mind Spike* (level 5 version).\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Noxious Miasma\\",\\"text\\":\\"*Constitution Saving Throw*: DC 21, each creature in a 30-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 90 feet. *Failure:*  17 (5d6) Poison damage, and the target takes a -2 penalty to AC until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"}]"
---

# Ancient Green Dragon
*Gargantuan, Dragon, Lawful Evil*

**AC** 21
**HP** 402 (23d20 + 161)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 27 | 12 | 25 | 20 | 17 | 22 |

CR 22, XP 41000

## Traits

**Amphibious**
The dragon can breathe air and water.

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Mind Spike* (level 5 version).

**Rend**
*Melee Attack Roll:* +15, reach 15 ft. 17 (2d8 + 8) Slashing damage plus 10 (3d6) Poison damage.

**Poison Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 22, each creature in a 90-foot Cone. *Failure:*  77 (22d6) Poison damage. *Success:*  Half damage.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21): - **At Will:** *Detect Magic*, *Mind Spike* - **1e/Day Each:** *Geas*, *Modify Memory*

## Legendary Actions

**Mind Invasion**
The dragon uses Spellcasting to cast *Mind Spike* (level 5 version).

**Noxious Miasma**
*Constitution Saving Throw*: DC 21, each creature in a 30-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 90 feet. *Failure:*  17 (5d6) Poison damage, and the target takes a -2 penalty to AC until the end of its next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "ancient-red-dragon.md": `---
smType: creature
name: "Ancient Red Dragon"
size: "Gargantuan"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Chaotic Evil"
ac: "22"
hp: "507"
hit_dice: "26d20 + 234"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":30},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":29},{\\"ability\\":\\"int\\",\\"score\\":18},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":27}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":7},{\\"ability\\":\\"wis\\",\\"bonus\\":9}]"
cr: "24"
xp: "62000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (4/Day, or 5/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Scorching Ray* (level 3 version).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +17, reach 15 ft. 19 (2d8 + 10) Slashing damage plus 10 (3d6) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fire Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 24, each creature in a 90-foot Cone. *Failure:*  91 (26d6) Fire damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 23, +15 to hit with spell attacks): - **At Will:** *Command*, *Detect Magic*, *Scorching Ray* - **1e/Day Each:** *Fireball*, *Scrying*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Commanding Presence\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Command* (level 2 version). The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Fiery Rays\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Scorching Ray* (level 3 version). The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"}]"
---

# Ancient Red Dragon
*Gargantuan, Dragon, Chaotic Evil*

**AC** 22
**HP** 507 (26d20 + 234)
**Speed** 40 ft., climb 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 30 | 10 | 29 | 18 | 15 | 27 |

CR 24, XP 62000

## Traits

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Spellcasting to cast *Scorching Ray* (level 3 version).

**Rend**
*Melee Attack Roll:* +17, reach 15 ft. 19 (2d8 + 10) Slashing damage plus 10 (3d6) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 24, each creature in a 90-foot Cone. *Failure:*  91 (26d6) Fire damage. *Success:*  Half damage.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 23, +15 to hit with spell attacks): - **At Will:** *Command*, *Detect Magic*, *Scorching Ray* - **1e/Day Each:** *Fireball*, *Scrying*

## Legendary Actions

**Commanding Presence**
The dragon uses Spellcasting to cast *Command* (level 2 version). The dragon can't take this action again until the start of its next turn.

**Fiery Rays**
The dragon uses Spellcasting to cast *Scorching Ray* (level 3 version). The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "ancient-silver-dragon.md": `---
smType: creature
name: "Ancient Silver Dragon"
size: "Gargantuan"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Lawful Good"
ac: "22"
hp: "468"
hit_dice: "24d20 + 216"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":30},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":29},{\\"ability\\":\\"int\\",\\"score\\":18},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":26}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":7},{\\"ability\\":\\"wis\\",\\"bonus\\":9}]"
cr: "23"
xp: "50000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (4/Day, or 5/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of (A) Paralyzing Breath or (B) Spellcasting to cast *Ice Knife* (level 2 version).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +17, reach 15 ft. 19 (2d8 + 10) Slashing damage plus 9 (2d8) Cold damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Cold Breath (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 24, each creature in a 90-foot Cone. *Failure:*  67 (15d8) Cold damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Paralyzing Breath\\",\\"text\\":\\"*Constitution Saving Throw*: DC 24, each creature in a 90-foot Cone. *First Failure* The target has the Incapacitated condition until the end of its next turn, when it repeats the save. *Second Failure* The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 23, +15 to hit with spell attacks): - **At Will:** *Detect Magic*, *Hold Monster*, *Ice Knife*, *Shapechange* - **1e/Day Each:** *Control Weather*, *Ice Storm*, *Teleport*, *Zone of Truth*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Chill\\",\\"text\\":\\"The dragon uses Spellcasting to cast *Hold Monster*. The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Cold Gale\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 23, each creature in a 60-foot-long, 10-foot-wide Line. *Failure:*  14 (4d6) Cold damage, and the target is pushed up to 30 feet straight away from the dragon. *Success:*  Half damage only. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"}]"
---

# Ancient Silver Dragon
*Gargantuan, Dragon, Lawful Good*

**AC** 22
**HP** 468 (24d20 + 216)
**Speed** 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 30 | 10 | 29 | 18 | 15 | 26 |

CR 23, XP 50000

## Traits

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of (A) Paralyzing Breath or (B) Spellcasting to cast *Ice Knife* (level 2 version).

**Rend**
*Melee Attack Roll:* +17, reach 15 ft. 19 (2d8 + 10) Slashing damage plus 9 (2d8) Cold damage.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 24, each creature in a 90-foot Cone. *Failure:*  67 (15d8) Cold damage. *Success:*  Half damage.

**Paralyzing Breath**
*Constitution Saving Throw*: DC 24, each creature in a 90-foot Cone. *First Failure* The target has the Incapacitated condition until the end of its next turn, when it repeats the save. *Second Failure* The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.

**Spellcasting**
The dragon casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 23, +15 to hit with spell attacks): - **At Will:** *Detect Magic*, *Hold Monster*, *Ice Knife*, *Shapechange* - **1e/Day Each:** *Control Weather*, *Ice Storm*, *Teleport*, *Zone of Truth*

## Legendary Actions

**Chill**
The dragon uses Spellcasting to cast *Hold Monster*. The dragon can't take this action again until the start of its next turn.

**Cold Gale**
*Dexterity Saving Throw*: DC 23, each creature in a 60-foot-long, 10-foot-wide Line. *Failure:*  14 (4d6) Cold damage, and the target is pushed up to 30 feet straight away from the dragon. *Success:*  Half damage only. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.
`,
      "ancient-white-dragon.md": `---
smType: creature
name: "Ancient White Dragon"
size: "Gargantuan"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Chaotic Evil"
ac: "20"
hp: "333"
hit_dice: "18d20 + 144"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"burrow\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":26},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":26},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":18}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":6},{\\"ability\\":\\"wis\\",\\"bonus\\":7}]"
cr: "20"
xp: "25000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Ice Walk\\",\\"text\\":\\"The dragon can move across and climb icy surfaces without needing to make an ability check. Additionally, Difficult Terrain composed of ice or snow doesn't cost it extra movement.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (4/Day, or 5/Day in Lair)\\",\\"text\\":\\"If the dragon fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +14, reach 15 ft. 17 (2d8 + 8) Slashing damage plus 7 (2d6) Cold damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Cold Breath (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 22, each creature in a 90-foot Cone. *Failure:*  63 (14d8) Cold damage. *Success:*  Half damage.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Freezing Burst\\",\\"text\\":\\"*Constitution Saving Throw*: DC 20, each creature in a 30-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 120 feet. *Failure:*  14 (4d6) Cold damage, and the target's Speed is 0 until the end of the target's next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Pounce\\",\\"text\\":\\"The dragon moves up to half its Speed, and it makes one Rend attack.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Frightful Presence\\",\\"text\\":\\"The dragon casts *Fear*, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 18). The dragon can't take this action again until the start of its next turn.\\"}]"
---

# Ancient White Dragon
*Gargantuan, Dragon, Chaotic Evil*

**AC** 20
**HP** 333 (18d20 + 144)
**Speed** 40 ft., swim 40 ft., fly 80 ft., burrow 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 26 | 10 | 26 | 10 | 13 | 18 |

CR 20, XP 25000

## Traits

**Ice Walk**
The dragon can move across and climb icy surfaces without needing to make an ability check. Additionally, Difficult Terrain composed of ice or snow doesn't cost it extra movement.

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the dragon fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The dragon makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +14, reach 15 ft. 17 (2d8 + 8) Slashing damage plus 7 (2d6) Cold damage.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 22, each creature in a 90-foot Cone. *Failure:*  63 (14d8) Cold damage. *Success:*  Half damage.

## Legendary Actions

**Freezing Burst**
*Constitution Saving Throw*: DC 20, each creature in a 30-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the dragon can see within 120 feet. *Failure:*  14 (4d6) Cold damage, and the target's Speed is 0 until the end of the target's next turn. *Failure or Success*:  The dragon can't take this action again until the start of its next turn.

**Pounce**
The dragon moves up to half its Speed, and it makes one Rend attack.

**Frightful Presence**
The dragon casts *Fear*, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 18). The dragon can't take this action again until the start of its next turn.
`,
      "animated-armor.md": `---
smType: creature
name: "Animated Armor"
size: "Medium"
type: "Construct"
alignment: "Unaligned"
ac: "18"
hp: "33"
hit_dice: "6d8 + 6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"25 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":14},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":3},{\\"ability\\":\\"cha\\",\\"score\\":1}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The armor makes two Slam attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Slam\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Bludgeoning damage.\\"}]"
---

# Animated Armor
*Medium, Construct, Unaligned*

**AC** 18
**HP** 33 (6d8 + 6)
**Speed** 25 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 14 | 11 | 13 | 1 | 3 | 1 |

CR 1, PB +2, XP 200

## Actions

**Multiattack**
The armor makes two Slam attacks.

**Slam**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Bludgeoning damage.
`,
      "animated-flying-sword.md": `---
smType: creature
name: "Animated Flying Sword"
size: "Small"
type: "Construct"
alignment: "Unaligned"
ac: "17"
hp: "14"
hit_dice: "4d6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"},\\"fly\\":{\\"distance\\":\\"50 ft.\\",\\"hover\\":true}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":12},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":5},{\\"ability\\":\\"cha\\",\\"score\\":1}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":4}]"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Slash\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Slashing damage.\\"}]"
---

# Animated Flying Sword
*Small, Construct, Unaligned*

**AC** 17
**HP** 14 (4d6)
**Speed** 5 ft., fly 50 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 12 | 15 | 11 | 1 | 5 | 1 |

CR 1/4, PB +2, XP 50

## Actions

**Slash**
*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Slashing damage.
`,
      "animated-rug-of-smothering.md": `---
smType: creature
name: "Animated Rug of Smothering"
size: "Large"
type: "Construct"
alignment: "Unaligned"
ac: "12"
hp: "27"
hit_dice: "5d10"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":3},{\\"ability\\":\\"cha\\",\\"score\\":1}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Smother\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Bludgeoning damage. If the target is a Medium or smaller creature, the rug can give it the Grappled condition (escape DC 13) instead of dealing damage. Until the grapple ends, the target has the Blinded and Restrained conditions, is suffocating, and takes 10 (2d6 + 3) Bludgeoning damage at the start of each of its turns. The rug can smother only one creature at a time. While grappling the target, the rug can't take this action, the rug halves the damage it takes (round down), and the target takes the same amount of damage.\\"}]"
---

# Animated Rug of Smothering
*Large, Construct, Unaligned*

**AC** 12
**HP** 27 (5d10)
**Speed** 10 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 14 | 10 | 1 | 3 | 1 |

CR 2, PB +2, XP 450

## Actions

**Smother**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Bludgeoning damage. If the target is a Medium or smaller creature, the rug can give it the Grappled condition (escape DC 13) instead of dealing damage. Until the grapple ends, the target has the Blinded and Restrained conditions, is suffocating, and takes 10 (2d6 + 3) Bludgeoning damage at the start of each of its turns. The rug can smother only one creature at a time. While grappling the target, the rug can't take this action, the rug halves the damage it takes (round down), and the target takes the same amount of damage.
`,
      "ankheg.md": `---
smType: creature
name: "Ankheg"
size: "Large"
type: "Monstrosity"
alignment: "Unaligned"
ac: "14"
hp: "45"
hit_dice: "6d10 + 12"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"burrow\\":{\\"distance\\":\\"10 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Tunneler\\",\\"text\\":\\"The ankheg can burrow through solid rock at half its Burrow Speed and leaves a 10-foot-diameter tunnel in its wake.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5 (with Advantage if the target is Grappled by the ankheg), reach 5 ft. 10 (2d6 + 3) Slashing damage plus 3 (1d6) Acid damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Acid Spray\\",\\"recharge\\":\\"Recharge 6\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 12, each creature in a 30-foot-long, 5-foot-wide Line. *Failure:*  14 (4d6) Acid damage. *Success:*  Half damage.\\"}]"
---

# Ankheg
*Large, Monstrosity, Unaligned*

**AC** 14
**HP** 45 (6d10 + 12)
**Speed** 30 ft., burrow 10 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 11 | 14 | 1 | 13 | 6 |

CR 2, PB +2, XP 450

## Traits

**Tunneler**
The ankheg can burrow through solid rock at half its Burrow Speed and leaves a 10-foot-diameter tunnel in its wake.

## Actions

**Bite**
*Melee Attack Roll:* +5 (with Advantage if the target is Grappled by the ankheg), reach 5 ft. 10 (2d6 + 3) Slashing damage plus 3 (1d6) Acid damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13).

**Acid Spray (Recharge 6)**
*Dexterity Saving Throw*: DC 12, each creature in a 30-foot-long, 5-foot-wide Line. *Failure:*  14 (4d6) Acid damage. *Success:*  Half damage.
`,
      "archmage.md": `---
smType: creature
name: "Archmage"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "17"
hp: "170"
hit_dice: "31d8 + 31"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":20},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":16}]"
pb: "+4"
saves_json: "[{\\"ability\\":\\"int\\",\\"bonus\\":9},{\\"ability\\":\\"wis\\",\\"bonus\\":6}]"
cr: "12"
xp: "8400"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The archmage has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The archmage makes four Arcane Burst attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Arcane Burst\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +9, reach 5 ft. or range 150 ft. 27 (4d10 + 5) Force damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The archmage casts one of the following spells, using Intelligence as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Magic*, *Detect Thoughts*, *Disguise Self*, *Invisibility*, *Light*, *Mage Armor*, *Mage Hand*, *Prestidigitation* - **2e/Day Each:** *Fly*, *Lightning Bolt* - **1e/Day Each:** *Cone of Cold*, *Mind Blank*, *Scrying*, *Teleport*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Misty Step (3/Day)\\",\\"text\\":\\"The mage casts *Misty Step*, using the same spellcasting ability as Spellcasting.\\"},{\\"category\\":\\"reaction\\",\\"name\\":\\"Protective Magic (3/Day)\\",\\"text\\":\\"The archmage casts *Counterspell* or *Shield* in response to the spell's trigger, using the same spellcasting ability as Spellcasting.\\"}]"
---

# Archmage
*Small, Humanoid, Neutral Neutral*

**AC** 17
**HP** 170 (31d8 + 31)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 14 | 12 | 20 | 15 | 16 |

CR 12, PB +4, XP 8400

## Traits

**Magic Resistance**
The archmage has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The archmage makes four Arcane Burst attacks.

**Arcane Burst**
*Melee or Ranged Attack Roll:* +9, reach 5 ft. or range 150 ft. 27 (4d10 + 5) Force damage.

**Spellcasting**
The archmage casts one of the following spells, using Intelligence as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Magic*, *Detect Thoughts*, *Disguise Self*, *Invisibility*, *Light*, *Mage Armor*, *Mage Hand*, *Prestidigitation* - **2e/Day Each:** *Fly*, *Lightning Bolt* - **1e/Day Each:** *Cone of Cold*, *Mind Blank*, *Scrying*, *Teleport*

## Bonus Actions

**Misty Step (3/Day)**
The mage casts *Misty Step*, using the same spellcasting ability as Spellcasting.

## Reactions

**Protective Magic (3/Day)**
The archmage casts *Counterspell* or *Shield* in response to the spell's trigger, using the same spellcasting ability as Spellcasting.
`,
      "assassin.md": `---
smType: creature
name: "Assassin"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "16"
hp: "97"
hit_dice: "15d8 + 30"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":11},{\\"ability\\":\\"dex\\",\\"score\\":18},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":7},{\\"ability\\":\\"int\\",\\"bonus\\":6}]"
cr: "8"
xp: "3900"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Evasion\\",\\"text\\":\\"If the assassin is subjected to an effect that allows it to make a Dexterity saving throw to take only half damage, the assassin instead takes no damage if it succeeds on the save and only half damage if it fails. It can't use this trait if it has the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The assassin makes three attacks, using Shortsword or Light Crossbow in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Shortsword\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 7 (1d6 + 4) Piercing damage plus 17 (5d6) Poison damage, and the target has the Poisoned condition until the start of the assassin's next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Light Crossbow\\",\\"text\\":\\"*Ranged Attack Roll:* +7, range 80/320 ft. 8 (1d8 + 4) Piercing damage plus 21 (6d6) Poison damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Cunning Action\\",\\"text\\":\\"The assassin takes the Dash, Disengage, or Hide action.\\"}]"
---

# Assassin
*Small, Humanoid, Neutral Neutral*

**AC** 16
**HP** 97 (15d8 + 30)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 11 | 18 | 14 | 16 | 11 | 10 |

CR 8, PB +3, XP 3900

## Traits

**Evasion**
If the assassin is subjected to an effect that allows it to make a Dexterity saving throw to take only half damage, the assassin instead takes no damage if it succeeds on the save and only half damage if it fails. It can't use this trait if it has the Incapacitated condition.

## Actions

**Multiattack**
The assassin makes three attacks, using Shortsword or Light Crossbow in any combination.

**Shortsword**
*Melee Attack Roll:* +7, reach 5 ft. 7 (1d6 + 4) Piercing damage plus 17 (5d6) Poison damage, and the target has the Poisoned condition until the start of the assassin's next turn.

**Light Crossbow**
*Ranged Attack Roll:* +7, range 80/320 ft. 8 (1d8 + 4) Piercing damage plus 21 (6d6) Poison damage.

## Bonus Actions

**Cunning Action**
The assassin takes the Dash, Disengage, or Hide action.
`,
      "awakened-shrub.md": `---
smType: creature
name: "Awakened Shrub"
size: "Small"
type: "Plant"
alignment: "Neutral Neutral"
ac: "9"
hp: "10"
hit_dice: "3d6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":3},{\\"ability\\":\\"dex\\",\\"score\\":8},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Rake\\",\\"text\\":\\"*Melee Attack Roll:* +1, reach 5 ft. 1 Slashing damage.\\"}]"
---

# Awakened Shrub
*Small, Plant, Neutral Neutral*

**AC** 9
**HP** 10 (3d6)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 3 | 8 | 11 | 10 | 10 | 6 |

CR 0, PB +2, XP 0

## Actions

**Rake**
*Melee Attack Roll:* +1, reach 5 ft. 1 Slashing damage.
`,
      "awakened-tree.md": `---
smType: creature
name: "Awakened Tree"
size: "Huge"
type: "Plant"
alignment: "Neutral Neutral"
ac: "13"
hp: "59"
hit_dice: "7d12 + 14"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":6},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Slam\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 10 ft. 13 (2d8 + 4) Bludgeoning damage.\\"}]"
---

# Awakened Tree
*Huge, Plant, Neutral Neutral*

**AC** 13
**HP** 59 (7d12 + 14)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 6 | 15 | 10 | 10 | 7 |

CR 2, PB +2, XP 450

## Actions

**Slam**
*Melee Attack Roll:* +6, reach 10 ft. 13 (2d8 + 4) Bludgeoning damage.
`,
      "axe-beak.md": `---
smType: creature
name: "Axe Beak"
size: "Large"
type: "Monstrosity"
alignment: "Unaligned"
ac: "11"
hp: "19"
hit_dice: "3d10 + 3"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":14},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Beak\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage.\\"}]"
---

# Axe Beak
*Large, Monstrosity, Unaligned*

**AC** 11
**HP** 19 (3d10 + 3)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 14 | 12 | 12 | 2 | 10 | 5 |

CR 1/4, PB +2, XP 50

## Actions

**Beak**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage.
`,
      "azer-sentinel.md": `---
smType: creature
name: "Azer Sentinel"
size: "Medium"
type: "Elemental"
alignment: "Lawful Neutral"
ac: "17"
hp: "39"
hit_dice: "6d8 + 12"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"con\\",\\"bonus\\":4}]"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Fire Aura\\",\\"text\\":\\"At the end of each of the azer's turns, each creature of the azer's choice in a 5-foot Emanation originating from the azer takes 5 (1d10) Fire damage unless the azer has the Incapacitated condition.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Illumination\\",\\"text\\":\\"The azer sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Burning Hammer\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Bludgeoning damage plus 3 (1d6) Fire damage.\\"}]"
---

# Azer Sentinel
*Medium, Elemental, Lawful Neutral*

**AC** 17
**HP** 39 (6d8 + 12)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 12 | 15 | 12 | 13 | 10 |

CR 2, PB +2, XP 450

## Traits

**Fire Aura**
At the end of each of the azer's turns, each creature of the azer's choice in a 5-foot Emanation originating from the azer takes 5 (1d10) Fire damage unless the azer has the Incapacitated condition.

**Illumination**
The azer sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.

## Actions

**Burning Hammer**
*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Bludgeoning damage plus 3 (1d6) Fire damage.
`,
      "balor.md": `---
smType: creature
name: "Balor"
size: "Huge"
type: "Fiend"
type_tags: ["Demon"]
alignment: "Chaotic Evil"
ac: "19"
hp: "287"
hit_dice: "23d12 + 138"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":26},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":22},{\\"ability\\":\\"int\\",\\"score\\":20},{\\"ability\\":\\"wis\\",\\"score\\":16},{\\"ability\\":\\"cha\\",\\"score\\":22}]"
pb: "+6"
saves_json: "[{\\"ability\\":\\"con\\",\\"bonus\\":12},{\\"ability\\":\\"wis\\",\\"bonus\\":9}]"
cr: "19"
xp: "22000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Death Throes\\",\\"text\\":\\"The balor explodes when it dies. *Dexterity Saving Throw*: DC 20, each creature in a 30-foot Emanation originating from the balor. *Failure:*  31 (9d6) Fire damage plus 31 (9d6) Force damage. *Success:*  Half damage. *Failure or Success*:  If the balor dies outside the Abyss, it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Fire Aura\\",\\"text\\":\\"At the end of each of the balor's turns, each creature in a 5-foot Emanation originating from the balor takes 13 (3d8) Fire damage.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day)\\",\\"text\\":\\"If the balor fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The balor has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The balor makes one Flame Whip attack and one Lightning Blade attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Flame Whip\\",\\"text\\":\\"*Melee Attack Roll:* +14, reach 30 ft. 18 (3d6 + 8) Force damage plus 17 (5d6) Fire damage. If the target is a Huge or smaller creature, the balor pulls the target up to 25 feet straight toward itself, and the target has the Prone condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Lightning Blade\\",\\"text\\":\\"*Melee Attack Roll:* +14, reach 10 ft. 21 (3d8 + 8) Force damage plus 22 (4d10) Lightning damage, and the target can't take Reactions until the start of the balor's next turn.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Teleport\\",\\"text\\":\\"The balor teleports itself or a willing demon within 10 feet of itself up to 60 feet to an unoccupied space the balor can see.\\"}]"
---

# Balor
*Huge, Fiend, Chaotic Evil*

**AC** 19
**HP** 287 (23d12 + 138)
**Speed** 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 26 | 15 | 22 | 20 | 16 | 22 |

CR 19, PB +6, XP 22000

## Traits

**Death Throes**
The balor explodes when it dies. *Dexterity Saving Throw*: DC 20, each creature in a 30-foot Emanation originating from the balor. *Failure:*  31 (9d6) Fire damage plus 31 (9d6) Force damage. *Success:*  Half damage. *Failure or Success*:  If the balor dies outside the Abyss, it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.

**Fire Aura**
At the end of each of the balor's turns, each creature in a 5-foot Emanation originating from the balor takes 13 (3d8) Fire damage.

**Legendary Resistance (3/Day)**
If the balor fails a saving throw, it can choose to succeed instead.

**Magic Resistance**
The balor has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The balor makes one Flame Whip attack and one Lightning Blade attack.

**Flame Whip**
*Melee Attack Roll:* +14, reach 30 ft. 18 (3d6 + 8) Force damage plus 17 (5d6) Fire damage. If the target is a Huge or smaller creature, the balor pulls the target up to 25 feet straight toward itself, and the target has the Prone condition.

**Lightning Blade**
*Melee Attack Roll:* +14, reach 10 ft. 21 (3d8 + 8) Force damage plus 22 (4d10) Lightning damage, and the target can't take Reactions until the start of the balor's next turn.

## Bonus Actions

**Teleport**
The balor teleports itself or a willing demon within 10 feet of itself up to 60 feet to an unoccupied space the balor can see.
`,
      "bandit-captain.md": `---
smType: creature
name: "Bandit Captain"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "15"
hp: "52"
hit_dice: "8d8 + 16"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":14},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":14}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":4},{\\"ability\\":\\"dex\\",\\"bonus\\":5},{\\"ability\\":\\"wis\\",\\"bonus\\":2}]"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The bandit makes two attacks, using Scimitar and Pistol in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Scimitar\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Pistol\\",\\"text\\":\\"*Ranged Attack Roll:* +5, range 30/90 ft. 8 (1d10 + 3) Piercing damage.\\"}]"
---

# Bandit Captain
*Small, Humanoid, Neutral Neutral*

**AC** 15
**HP** 52 (8d8 + 16)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 16 | 14 | 14 | 11 | 14 |

CR 2, PB +2, XP 450

## Actions

**Multiattack**
The bandit makes two attacks, using Scimitar and Pistol in any combination.

**Scimitar**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Slashing damage.

**Pistol**
*Ranged Attack Roll:* +5, range 30/90 ft. 8 (1d10 + 3) Piercing damage.
`,
      "bandit.md": `---
smType: creature
name: "Bandit"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "12"
hp: "11"
hit_dice: "2d8 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":11},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+2"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Scimitar\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Light Crossbow\\",\\"text\\":\\"*Ranged Attack Roll:* +3, range 80/320 ft. 5 (1d8 + 1) Piercing damage.\\"}]"
---

# Bandit
*Small, Humanoid, Neutral Neutral*

**AC** 12
**HP** 11 (2d8 + 2)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 11 | 12 | 12 | 10 | 10 | 10 |

CR 1/8, PB +2, XP 25

## Actions

**Scimitar**
*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Slashing damage.

**Light Crossbow**
*Ranged Attack Roll:* +3, range 80/320 ft. 5 (1d8 + 1) Piercing damage.
`,
      "barbed-devil.md": `---
smType: creature
name: "Barbed Devil"
size: "Medium"
type: "Fiend"
type_tags: ["Devil"]
alignment: "Lawful Evil"
ac: "15"
hp: "110"
hit_dice: "13d8 + 52"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":14}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":6},{\\"ability\\":\\"con\\",\\"bonus\\":7},{\\"ability\\":\\"wis\\",\\"bonus\\":5},{\\"ability\\":\\"cha\\",\\"bonus\\":5}]"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Barbed Hide\\",\\"text\\":\\"At the start of each of its turns, the devil deals 5 (1d10) Piercing damage to any creature it is grappling or any creature grappling it.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Diabolical Restoration\\",\\"text\\":\\"If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The devil has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The devil makes one Claws attack and one Tail attack, or it makes two Hurl Flame attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claws\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 10 (2d6 + 3) Piercing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13) from both claws.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tail\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 10 ft. 14 (2d10 + 3) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Hurl Flame\\",\\"text\\":\\"*Ranged Attack Roll:* +5, range 150 ft. 17 (5d6) Fire damage. If the target is a flammable object that isn't being worn or carried, it starts burning.\\"}]"
---

# Barbed Devil
*Medium, Fiend, Lawful Evil*

**AC** 15
**HP** 110 (13d8 + 52)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 17 | 18 | 12 | 14 | 14 |

CR 5, PB +3, XP 1800

## Traits

**Barbed Hide**
At the start of each of its turns, the devil deals 5 (1d10) Piercing damage to any creature it is grappling or any creature grappling it.

**Diabolical Restoration**
If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.

**Magic Resistance**
The devil has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The devil makes one Claws attack and one Tail attack, or it makes two Hurl Flame attacks.

**Claws**
*Melee Attack Roll:* +6, reach 5 ft. 10 (2d6 + 3) Piercing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13) from both claws.

**Tail**
*Melee Attack Roll:* +6, reach 10 ft. 14 (2d10 + 3) Slashing damage.

**Hurl Flame**
*Ranged Attack Roll:* +5, range 150 ft. 17 (5d6) Fire damage. If the target is a flammable object that isn't being worn or carried, it starts burning.
`,
      "basilisk.md": `---
smType: creature
name: "Basilisk"
size: "Medium"
type: "Monstrosity"
alignment: "Unaligned"
ac: "15"
hp: "52"
hit_dice: "8d8 + 16"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":8},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":8},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Piercing damage plus 7 (2d6) Poison damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Petrifying Gaze (Recharge 4-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 12, each creature in a 30-foot Cone. If the basilisk sees its reflection within the Cone, the basilisk must make this save. *First Failure* The target has the Restrained condition and repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition instead of the Restrained condition.\\"}]"
---

# Basilisk
*Medium, Monstrosity, Unaligned*

**AC** 15
**HP** 52 (8d8 + 16)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 8 | 15 | 2 | 8 | 7 |

CR 3, PB +2, XP 700

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Piercing damage plus 7 (2d6) Poison damage.

## Bonus Actions

**Petrifying Gaze (Recharge 4-6)**
*Constitution Saving Throw*: DC 12, each creature in a 30-foot Cone. If the basilisk sees its reflection within the Cone, the basilisk must make this save. *First Failure* The target has the Restrained condition and repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition instead of the Restrained condition.
`,
      "bearded-devil.md": `---
smType: creature
name: "Bearded Devil"
size: "Medium"
type: "Fiend"
type_tags: ["Devil"]
alignment: "Lawful Evil"
ac: "13"
hp: "58"
hit_dice: "9d8 + 18"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":9},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":14}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":5},{\\"ability\\":\\"con\\",\\"bonus\\":4},{\\"ability\\":\\"cha\\",\\"bonus\\":4}]"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The devil has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The devil makes one Beard attack and one Infernal Glaive attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Beard\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage, and the target has the Poisoned condition until the start of the devil's next turn. Until this poison ends, the target can't regain Hit Points.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Infernal Glaive\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 10 ft. 8 (1d10 + 3) Slashing damage. If the target is a creature and doesn't already have an infernal wound, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target receives an infernal wound. While wounded, the target loses 5 (1d10) Hit Points at the start of each of its turns. The wound closes after 1 minute, after a spell restores Hit Points to the target, or after the target or a creature within 5 feet of it takes an action to stanch the wound, doing so by succeeding on a DC 12 Wisdom (Medicine) check.\\"}]"
---

# Bearded Devil
*Medium, Fiend, Lawful Evil*

**AC** 13
**HP** 58 (9d8 + 18)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 15 | 15 | 9 | 11 | 14 |

CR 3, PB +2, XP 700

## Traits

**Magic Resistance**
The devil has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The devil makes one Beard attack and one Infernal Glaive attack.

**Beard**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage, and the target has the Poisoned condition until the start of the devil's next turn. Until this poison ends, the target can't regain Hit Points.

**Infernal Glaive**
*Melee Attack Roll:* +5, reach 10 ft. 8 (1d10 + 3) Slashing damage. If the target is a creature and doesn't already have an infernal wound, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target receives an infernal wound. While wounded, the target loses 5 (1d10) Hit Points at the start of each of its turns. The wound closes after 1 minute, after a spell restores Hit Points to the target, or after the target or a creature within 5 feet of it takes an action to stanch the wound, doing so by succeeding on a DC 12 Wisdom (Medicine) check.
`,
      "behir.md": `---
smType: creature
name: "Behir"
size: "Huge"
type: "Monstrosity"
alignment: "Neutral Evil"
ac: "17"
hp: "168"
hit_dice: "16d12 + 64"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"},\\"climb\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":23},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":7},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":12}]"
pb: "+4"
cr: "11"
xp: "7200"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The behir makes one Bite attack and uses Constrict.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +10, reach 10 ft. 19 (2d12 + 6) Piercing damage plus 11 (2d10) Lightning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Constrict\\",\\"text\\":\\"*Strength Saving Throw*: DC 18, one Large or smaller creature the behir can see within 5 feet. *Failure:*  28 (5d8 + 6) Bludgeoning damage. The target has the Grappled condition (escape DC 16), and it has the Restrained condition until the grapple ends.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Lightning Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 16, each creature in a 90-foot-long, 5-foot-wide Line. *Failure:*  66 (12d10) Lightning damage. *Success:*  Half damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Swallow\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 18, one Large or smaller creature Grappled by the behir (the behir can have only one creature swallowed at a time). *Failure:*  The behir swallows the target, which is no longer Grappled. While swallowed, a creature has the Blinded and Restrained conditions, has Cover|XPHB|Total Cover against attacks and other effects outside the behir, and takes 21 (6d6) Acid damage at the start of each of the behir's turns. If the behir takes 30 damage or more on a single turn from the swallowed creature, the behir must succeed on a DC 14 Constitution saving throw at the end of that turn or regurgitate the creature, which falls in a space within 10 feet of the behir and has the Prone condition. If the behir dies, a swallowed creature is no longer Restrained and can escape from the corpse by using 15 feet of movement, exiting Prone.\\"}]"
---

# Behir
*Huge, Monstrosity, Neutral Evil*

**AC** 17
**HP** 168 (16d12 + 64)
**Speed** 50 ft., climb 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 23 | 16 | 18 | 7 | 14 | 12 |

CR 11, PB +4, XP 7200

## Actions

**Multiattack**
The behir makes one Bite attack and uses Constrict.

**Bite**
*Melee Attack Roll:* +10, reach 10 ft. 19 (2d12 + 6) Piercing damage plus 11 (2d10) Lightning damage.

**Constrict**
*Strength Saving Throw*: DC 18, one Large or smaller creature the behir can see within 5 feet. *Failure:*  28 (5d8 + 6) Bludgeoning damage. The target has the Grappled condition (escape DC 16), and it has the Restrained condition until the grapple ends.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 16, each creature in a 90-foot-long, 5-foot-wide Line. *Failure:*  66 (12d10) Lightning damage. *Success:*  Half damage.

## Bonus Actions

**Swallow**
*Dexterity Saving Throw*: DC 18, one Large or smaller creature Grappled by the behir (the behir can have only one creature swallowed at a time). *Failure:*  The behir swallows the target, which is no longer Grappled. While swallowed, a creature has the Blinded and Restrained conditions, has Cover|XPHB|Total Cover against attacks and other effects outside the behir, and takes 21 (6d6) Acid damage at the start of each of the behir's turns. If the behir takes 30 damage or more on a single turn from the swallowed creature, the behir must succeed on a DC 14 Constitution saving throw at the end of that turn or regurgitate the creature, which falls in a space within 10 feet of the behir and has the Prone condition. If the behir dies, a swallowed creature is no longer Restrained and can escape from the corpse by using 15 feet of movement, exiting Prone.
`,
      "berserker.md": `---
smType: creature
name: "Berserker"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "13"
hp: "67"
hit_dice: "9d8 + 27"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":9},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":9}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Bloodied Frenzy\\",\\"text\\":\\"While Bloodied, the berserker has Advantage on attack rolls and saving throws.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Greataxe\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 9 (1d12 + 3) Slashing damage.\\"}]"
---

# Berserker
*Small, Humanoid, Neutral Neutral*

**AC** 13
**HP** 67 (9d8 + 27)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 12 | 17 | 9 | 11 | 9 |

CR 2, PB +2, XP 450

## Traits

**Bloodied Frenzy**
While Bloodied, the berserker has Advantage on attack rolls and saving throws.

## Actions

**Greataxe**
*Melee Attack Roll:* +5, reach 5 ft. 9 (1d12 + 3) Slashing damage.
`,
      "black-dragon-wyrmling.md": `---
smType: creature
name: "Black Dragon Wyrmling"
size: "Medium"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Chaotic Evil"
ac: "17"
hp: "33"
hit_dice: "6d8 + 6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":13}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":4},{\\"ability\\":\\"wis\\",\\"bonus\\":2}]"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes two Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage plus 2 (1d4) Acid damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Acid Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 11, each creature in a 15-foot-long, 5-foot-wide Line. *Failure:*  22 (5d8) Acid damage. *Success:*  Half damage.\\"}]"
---

# Black Dragon Wyrmling
*Medium, Dragon, Chaotic Evil*

**AC** 17
**HP** 33 (6d8 + 6)
**Speed** 30 ft., swim 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 14 | 13 | 10 | 11 | 13 |

CR 2, PB +2, XP 450

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage plus 2 (1d4) Acid damage.

**Acid Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 11, each creature in a 15-foot-long, 5-foot-wide Line. *Failure:*  22 (5d8) Acid damage. *Success:*  Half damage.
`,
      "black-pudding.md": `---
smType: creature
name: "Black Pudding"
size: "Large"
type: "Ooze"
alignment: "Unaligned"
ac: "7"
hp: "68"
hit_dice: "8d10 + 24"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"climb\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":5},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":6},{\\"ability\\":\\"cha\\",\\"score\\":1}]"
pb: "+2"
cr: "4"
xp: "1100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amorphous\\",\\"text\\":\\"The pudding can move through a space as narrow as 1 inch without expending extra movement to do so.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Corrosive Form\\",\\"text\\":\\"A creature that hits the pudding with a melee attack roll takes 4 (1d8) Acid damage. Nonmagical ammunition is destroyed immediately after hitting the pudding and dealing any damage. Any nonmagical weapon takes a cumulative -1 penalty to attack rolls immediately after dealing damage to the pudding and coming into contact with it. The weapon is destroyed if the penalty reaches -5. The penalty can be removed by casting the *Mending* spell on the weapon. In 1 minute, the pudding can eat through 2 feet of nonmagical wood or metal.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Spider Climb\\",\\"text\\":\\"The pudding can climb difficult surfaces, including along ceilings, without needing to make an ability check.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Dissolving Pseudopod\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 10 ft. 17 (4d6 + 3) Acid damage. Nonmagical armor worn by the target takes a -1 penalty to the AC it offers. The armor is destroyed if the penalty reduces its AC to 10. The penalty can be removed by casting the *Mending* spell on the armor.\\"}]"
---

# Black Pudding
*Large, Ooze, Unaligned*

**AC** 7
**HP** 68 (8d10 + 24)
**Speed** 20 ft., climb 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 5 | 16 | 1 | 6 | 1 |

CR 4, PB +2, XP 1100

## Traits

**Amorphous**
The pudding can move through a space as narrow as 1 inch without expending extra movement to do so.

**Corrosive Form**
A creature that hits the pudding with a melee attack roll takes 4 (1d8) Acid damage. Nonmagical ammunition is destroyed immediately after hitting the pudding and dealing any damage. Any nonmagical weapon takes a cumulative -1 penalty to attack rolls immediately after dealing damage to the pudding and coming into contact with it. The weapon is destroyed if the penalty reaches -5. The penalty can be removed by casting the *Mending* spell on the weapon. In 1 minute, the pudding can eat through 2 feet of nonmagical wood or metal.

**Spider Climb**
The pudding can climb difficult surfaces, including along ceilings, without needing to make an ability check.

## Actions

**Dissolving Pseudopod**
*Melee Attack Roll:* +5, reach 10 ft. 17 (4d6 + 3) Acid damage. Nonmagical armor worn by the target takes a -1 penalty to the AC it offers. The armor is destroyed if the penalty reduces its AC to 10. The penalty can be removed by casting the *Mending* spell on the armor.
`,
      "blink-dog.md": `---
smType: creature
name: "Blink Dog"
size: "Medium"
type: "Fey"
alignment: "Lawful Good"
ac: "13"
hp: "22"
hit_dice: "4d8 + 4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":12},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Piercing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Teleport (Recharge 4-6)\\",\\"text\\":\\"The dog teleports up to 40 feet to an unoccupied space it can see.\\"}]"
---

# Blink Dog
*Medium, Fey, Lawful Good*

**AC** 13
**HP** 22 (4d8 + 4)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 12 | 17 | 12 | 10 | 13 | 11 |

CR 1/4, PB +2, XP 50

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Piercing damage.

## Bonus Actions

**Teleport (Recharge 4-6)**
The dog teleports up to 40 feet to an unoccupied space it can see.
`,
      "blue-dragon-wyrmling.md": `---
smType: creature
name: "Blue Dragon Wyrmling"
size: "Medium"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Lawful Evil"
ac: "17"
hp: "65"
hit_dice: "10d8 + 20"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"burrow\\":{\\"distance\\":\\"15 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":15}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":2},{\\"ability\\":\\"wis\\",\\"bonus\\":2}]"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes two Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Slashing damage plus 3 (1d6) Lightning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Lightning Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 12, each creature in a 30-foot-long, 5-foot-wide Line. *Failure:*  21 (6d6) Lightning damage. *Success:*  Half damage.\\"}]"
---

# Blue Dragon Wyrmling
*Medium, Dragon, Lawful Evil*

**AC** 17
**HP** 65 (10d8 + 20)
**Speed** 30 ft., fly 60 ft., burrow 15 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 10 | 15 | 12 | 11 | 15 |

CR 3, PB +2, XP 700

## Actions

**Multiattack**
The dragon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Slashing damage plus 3 (1d6) Lightning damage.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 12, each creature in a 30-foot-long, 5-foot-wide Line. *Failure:*  21 (6d6) Lightning damage. *Success:*  Half damage.
`,
      "bone-devil.md": `---
smType: creature
name: "Bone Devil"
size: "Large"
type: "Fiend"
type_tags: ["Devil"]
alignment: "Lawful Evil"
ac: "16"
hp: "161"
hit_dice: "17d10 + 68"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":13},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":16}]"
pb: "+4"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":8},{\\"ability\\":\\"int\\",\\"bonus\\":5},{\\"ability\\":\\"wis\\",\\"bonus\\":6},{\\"ability\\":\\"cha\\",\\"bonus\\":7}]"
cr: "9"
xp: "5000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Diabolical Restoration\\",\\"text\\":\\"If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The devil has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The devil makes two Claw attacks and one Infernal Sting attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +8, reach 10 ft. 13 (2d8 + 4) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Infernal Sting\\",\\"text\\":\\"*Melee Attack Roll:* +8, reach 10 ft. 15 (2d10 + 4) Piercing damage plus 18 (4d8) Poison damage, and the target has the Poisoned condition until the start of the devil's next turn. While Poisoned, the target can't regain Hit Points.\\"}]"
---

# Bone Devil
*Large, Fiend, Lawful Evil*

**AC** 16
**HP** 161 (17d10 + 68)
**Speed** 40 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 16 | 18 | 13 | 14 | 16 |

CR 9, PB +4, XP 5000

## Traits

**Diabolical Restoration**
If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.

**Magic Resistance**
The devil has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The devil makes two Claw attacks and one Infernal Sting attack.

**Claw**
*Melee Attack Roll:* +8, reach 10 ft. 13 (2d8 + 4) Slashing damage.

**Infernal Sting**
*Melee Attack Roll:* +8, reach 10 ft. 15 (2d10 + 4) Piercing damage plus 18 (4d8) Poison damage, and the target has the Poisoned condition until the start of the devil's next turn. While Poisoned, the target can't regain Hit Points.
`,
      "brass-dragon-wyrmling.md": `---
smType: creature
name: "Brass Dragon Wyrmling"
size: "Medium"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Chaotic Good"
ac: "15"
hp: "22"
hit_dice: "4d8 + 4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"burrow\\":{\\"distance\\":\\"15 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":13}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":2},{\\"ability\\":\\"wis\\",\\"bonus\\":2}]"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fire Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 11, each creature in a 20-foot-long, 5-foot-wide Line. *Failure:*  14 (4d6) Fire damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Sleep Breath\\",\\"text\\":\\"*Constitution Saving Throw*: DC 11, each creature in a 15-foot Cone. *Failure:*  The target has the Incapacitated condition until the end of its next turn, at which point it repeats the save. *Second Failure* The target has the Unconscious condition for 1 minute. This effect ends for the target if it takes damage or a creature within 5 feet of it takes an action to wake it.\\"}]"
---

# Brass Dragon Wyrmling
*Medium, Dragon, Chaotic Good*

**AC** 15
**HP** 22 (4d8 + 4)
**Speed** 30 ft., fly 60 ft., burrow 15 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 10 | 13 | 10 | 11 | 13 |

CR 1, PB +2, XP 200

## Actions

**Rend**
*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 11, each creature in a 20-foot-long, 5-foot-wide Line. *Failure:*  14 (4d6) Fire damage. *Success:*  Half damage.

**Sleep Breath**
*Constitution Saving Throw*: DC 11, each creature in a 15-foot Cone. *Failure:*  The target has the Incapacitated condition until the end of its next turn, at which point it repeats the save. *Second Failure* The target has the Unconscious condition for 1 minute. This effect ends for the target if it takes damage or a creature within 5 feet of it takes an action to wake it.
`,
      "bronze-dragon-wyrmling.md": `---
smType: creature
name: "Bronze Dragon Wyrmling"
size: "Medium"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Lawful Good"
ac: "15"
hp: "39"
hit_dice: "6d8 + 12"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":15}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":2},{\\"ability\\":\\"wis\\",\\"bonus\\":2}]"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes two Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Lightning Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 12, each creature in a 40-foot-long, 5-foot-wide Line. *Failure:*  16 (3d10) Lightning damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Repulsion Breath\\",\\"text\\":\\"*Strength Saving Throw*: DC 12, each creature in a 30-foot Cone. *Failure:*  The target is pushed up to 30 feet straight away from the dragon and has the Prone condition.\\"}]"
---

# Bronze Dragon Wyrmling
*Medium, Dragon, Lawful Good*

**AC** 15
**HP** 39 (6d8 + 12)
**Speed** 30 ft., swim 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 10 | 15 | 12 | 11 | 15 |

CR 2, PB +2, XP 450

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Slashing damage.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 12, each creature in a 40-foot-long, 5-foot-wide Line. *Failure:*  16 (3d10) Lightning damage. *Success:*  Half damage.

**Repulsion Breath**
*Strength Saving Throw*: DC 12, each creature in a 30-foot Cone. *Failure:*  The target is pushed up to 30 feet straight away from the dragon and has the Prone condition.
`,
      "bugbear-stalker.md": `---
smType: creature
name: "Bugbear Stalker"
size: "Medium"
type: "Fey"
type_tags: ["Goblinoid"]
alignment: "Chaotic Evil"
ac: "15"
hp: "65"
hit_dice: "10d8 + 20"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"con\\",\\"bonus\\":4},{\\"ability\\":\\"wis\\",\\"bonus\\":3}]"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Abduct\\",\\"text\\":\\"The bugbear needn't spend extra movement to move a creature it is grappling.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The bugbear makes two Javelin or Morningstar attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Javelin\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +5, reach 10 ft. or range 30/120 ft. 13 (3d6 + 3) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Morningstar\\",\\"text\\":\\"*Melee Attack Roll:* +5 (with Advantage if the target is Grappled by the bugbear), reach 10 ft. 12 (2d8 + 3) Piercing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Quick Grapple\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 13, one Medium or smaller creature the bugbear can see within 10 feet. *Failure:*  The target has the Grappled condition (escape DC 13).\\"}]"
---

# Bugbear Stalker
*Medium, Fey, Chaotic Evil*

**AC** 15
**HP** 65 (10d8 + 20)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 14 | 14 | 11 | 12 | 11 |

CR 3, PB +2, XP 700

## Traits

**Abduct**
The bugbear needn't spend extra movement to move a creature it is grappling.

## Actions

**Multiattack**
The bugbear makes two Javelin or Morningstar attacks.

**Javelin**
*Melee or Ranged Attack Roll:* +5, reach 10 ft. or range 30/120 ft. 13 (3d6 + 3) Piercing damage.

**Morningstar**
*Melee Attack Roll:* +5 (with Advantage if the target is Grappled by the bugbear), reach 10 ft. 12 (2d8 + 3) Piercing damage.

## Bonus Actions

**Quick Grapple**
*Dexterity Saving Throw*: DC 13, one Medium or smaller creature the bugbear can see within 10 feet. *Failure:*  The target has the Grappled condition (escape DC 13).
`,
      "bugbear-warrior.md": `---
smType: creature
name: "Bugbear Warrior"
size: "Medium"
type: "Fey"
type_tags: ["Goblinoid"]
alignment: "Chaotic Evil"
ac: "14"
hp: "33"
hit_dice: "6d8 + 6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":8},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":9}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Abduct\\",\\"text\\":\\"The bugbear needn't spend extra movement to move a creature it is grappling.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Grab\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 10 ft. 9 (2d6 + 2) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Light Hammer\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +4 (with Advantage if the target is Grappled by the bugbear), reach 10 ft. or range 20/60 ft. 9 (3d4 + 2) Bludgeoning damage.\\"}]"
---

# Bugbear Warrior
*Medium, Fey, Chaotic Evil*

**AC** 14
**HP** 33 (6d8 + 6)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 14 | 13 | 8 | 11 | 9 |

CR 1, PB +2, XP 200

## Traits

**Abduct**
The bugbear needn't spend extra movement to move a creature it is grappling.

## Actions

**Grab**
*Melee Attack Roll:* +4, reach 10 ft. 9 (2d6 + 2) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12).

**Light Hammer**
*Melee or Ranged Attack Roll:* +4 (with Advantage if the target is Grappled by the bugbear), reach 10 ft. or range 20/60 ft. 9 (3d4 + 2) Bludgeoning damage.
`,
      "bulette.md": `---
smType: creature
name: "Bulette"
size: "Large"
type: "Monstrosity"
alignment: "Unaligned"
ac: "17"
hp: "94"
hit_dice: "9d10 + 45"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"burrow\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":21},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The bulette makes two Bite attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 17 (2d12 + 4) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Deadly Leap\\",\\"text\\":\\"The bulette spends 5 feet of movement to jump to a space within 15 feet that contains one or more Large or smaller creatures. *Dexterity Saving Throw*: DC 15, each creature in the bulette's destination space. *Failure:*  19 (3d12) Bludgeoning damage, and the target has the Prone condition. *Success:*  Half damage, and the target is pushed 5 feet straight away from the bulette.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Leap\\",\\"text\\":\\"The bulette jumps up to 30 feet by spending 10 feet of movement.\\"}]"
---

# Bulette
*Large, Monstrosity, Unaligned*

**AC** 17
**HP** 94 (9d10 + 45)
**Speed** 40 ft., burrow 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 11 | 21 | 2 | 10 | 5 |

CR 5, PB +3, XP 1800

## Actions

**Multiattack**
The bulette makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +7, reach 5 ft. 17 (2d12 + 4) Piercing damage.

**Deadly Leap**
The bulette spends 5 feet of movement to jump to a space within 15 feet that contains one or more Large or smaller creatures. *Dexterity Saving Throw*: DC 15, each creature in the bulette's destination space. *Failure:*  19 (3d12) Bludgeoning damage, and the target has the Prone condition. *Success:*  Half damage, and the target is pushed 5 feet straight away from the bulette.

## Bonus Actions

**Leap**
The bulette jumps up to 30 feet by spending 10 feet of movement.
`,
      "centaur-trooper.md": `---
smType: creature
name: "Centaur Trooper"
size: "Large"
type: "Fey"
alignment: "Neutral Good"
ac: "16"
hp: "45"
hit_dice: "6d10 + 12"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":9},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The centaur makes two attacks, using Pike or Longbow in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Pike\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 10 ft. 9 (1d10 + 4) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Longbow\\",\\"text\\":\\"*Ranged Attack Roll:* +4, range 150/600 ft. 6 (1d8 + 2) Piercing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Trampling Charge (Recharge 5-6)\\",\\"text\\":\\"The centaur moves up to its Speed without provoking Opportunity Attacks and can move through the spaces of Medium or smaller creatures. Each creature whose space the centaur enters is targeted once by the following effect. *Strength Saving Throw*: DC 14. *Failure:*  7 (1d6 + 4) Bludgeoning damage, and the target has the Prone condition.\\"}]"
---

# Centaur Trooper
*Large, Fey, Neutral Good*

**AC** 16
**HP** 45 (6d10 + 12)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 14 | 14 | 9 | 13 | 11 |

CR 2, PB +2, XP 450

## Actions

**Multiattack**
The centaur makes two attacks, using Pike or Longbow in any combination.

**Pike**
*Melee Attack Roll:* +6, reach 10 ft. 9 (1d10 + 4) Piercing damage.

**Longbow**
*Ranged Attack Roll:* +4, range 150/600 ft. 6 (1d8 + 2) Piercing damage.

## Bonus Actions

**Trampling Charge (Recharge 5-6)**
The centaur moves up to its Speed without provoking Opportunity Attacks and can move through the spaces of Medium or smaller creatures. Each creature whose space the centaur enters is targeted once by the following effect. *Strength Saving Throw*: DC 14. *Failure:*  7 (1d6 + 4) Bludgeoning damage, and the target has the Prone condition.
`,
      "chain-devil.md": `---
smType: creature
name: "Chain Devil"
size: "Medium"
type: "Fiend"
type_tags: ["Devil"]
alignment: "Lawful Evil"
ac: "15"
hp: "85"
hit_dice: "10d8 + 40"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":14}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"con\\",\\"bonus\\":7},{\\"ability\\":\\"wis\\",\\"bonus\\":4}]"
cr: "8"
xp: "3900"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Diabolical Restoration\\",\\"text\\":\\"If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The devil has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The devil makes two Chain attacks and uses Conjure Infernal Chain.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Chain\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Slashing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of two chains, and it has the Restrained condition until the grapple ends.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Conjure Infernal Chain\\",\\"text\\":\\"The devil conjures a fiery chain to bind a creature. *Dexterity Saving Throw*: DC 15, one creature the devil can see within 60 feet. *Failure:*  9 (2d4 + 4) Fire damage, and the target has the Restrained condition until the end of the devil's next turn, at which point the chain disappears. If the target is Large or smaller, the devil moves the target up to 30 feet straight toward itself. *Success:*  The chain disappears.\\"}]"
---

# Chain Devil
*Medium, Fiend, Lawful Evil*

**AC** 15
**HP** 85 (10d8 + 40)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 15 | 18 | 11 | 12 | 14 |

CR 8, PB +3, XP 3900

## Traits

**Diabolical Restoration**
If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.

**Magic Resistance**
The devil has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The devil makes two Chain attacks and uses Conjure Infernal Chain.

**Chain**
*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Slashing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of two chains, and it has the Restrained condition until the grapple ends.

**Conjure Infernal Chain**
The devil conjures a fiery chain to bind a creature. *Dexterity Saving Throw*: DC 15, one creature the devil can see within 60 feet. *Failure:*  9 (2d4 + 4) Fire damage, and the target has the Restrained condition until the end of the devil's next turn, at which point the chain disappears. If the target is Large or smaller, the devil moves the target up to 30 feet straight toward itself. *Success:*  The chain disappears.
`,
      "chimera.md": `---
smType: creature
name: "Chimera"
size: "Large"
type: "Monstrosity"
alignment: "Chaotic Evil"
ac: "14"
hp: "114"
hit_dice: "12d10 + 48"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":19},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+3"
cr: "6"
xp: "2300"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The chimera makes one Ram attack, one Bite attack, and one Claw attack. It can replace the Claw attack with a use of Fire Breath if available.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 11 (2d6 + 4) Piercing damage, or 18 (4d6 + 4) Piercing damage if the chimera had Advantage on the attack roll.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 7 (1d6 + 4) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Ram\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 10 (1d12 + 4) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Prone condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fire Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 15, each creature in a 15-foot Cone. *Failure:*  31 (7d8) Fire damage. *Success:*  Half damage.\\"}]"
---

# Chimera
*Large, Monstrosity, Chaotic Evil*

**AC** 14
**HP** 114 (12d10 + 48)
**Speed** 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 11 | 19 | 3 | 14 | 10 |

CR 6, PB +3, XP 2300

## Actions

**Multiattack**
The chimera makes one Ram attack, one Bite attack, and one Claw attack. It can replace the Claw attack with a use of Fire Breath if available.

**Bite**
*Melee Attack Roll:* +7, reach 5 ft. 11 (2d6 + 4) Piercing damage, or 18 (4d6 + 4) Piercing damage if the chimera had Advantage on the attack roll.

**Claw**
*Melee Attack Roll:* +7, reach 5 ft. 7 (1d6 + 4) Slashing damage.

**Ram**
*Melee Attack Roll:* +7, reach 5 ft. 10 (1d12 + 4) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Prone condition.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 15, each creature in a 15-foot Cone. *Failure:*  31 (7d8) Fire damage. *Success:*  Half damage.
`,
      "chuul.md": `---
smType: creature
name: "Chuul"
size: "Large"
type: "Aberration"
alignment: "Chaotic Evil"
ac: "16"
hp: "76"
hit_dice: "9d10 + 27"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":5},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "4"
xp: "1100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The chuul can breathe air and water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Sense Magic\\",\\"text\\":\\"The chuul senses magic within 120 feet of itself. This trait otherwise works like the *Detect Magic* spell but isn't itself magical.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The chuul makes two Pincer attacks and uses Paralyzing Tentacles.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Pincer\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 10 ft. 9 (1d10 + 4) Bludgeoning damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of two pincers.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Paralyzing Tentacles\\",\\"text\\":\\"*Constitution Saving Throw*: DC 13, one creature Grappled by the chuul. *Failure:*  The target has the Poisoned condition and repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically. While Poisoned, the target has the Paralyzed condition.\\"}]"
---

# Chuul
*Large, Aberration, Chaotic Evil*

**AC** 16
**HP** 76 (9d10 + 27)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 10 | 16 | 5 | 11 | 5 |

CR 4, PB +2, XP 1100

## Traits

**Amphibious**
The chuul can breathe air and water.

**Sense Magic**
The chuul senses magic within 120 feet of itself. This trait otherwise works like the *Detect Magic* spell but isn't itself magical.

## Actions

**Multiattack**
The chuul makes two Pincer attacks and uses Paralyzing Tentacles.

**Pincer**
*Melee Attack Roll:* +6, reach 10 ft. 9 (1d10 + 4) Bludgeoning damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of two pincers.

**Paralyzing Tentacles**
*Constitution Saving Throw*: DC 13, one creature Grappled by the chuul. *Failure:*  The target has the Poisoned condition and repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically. While Poisoned, the target has the Paralyzed condition.
`,
      "clay-golem.md": `---
smType: creature
name: "Clay Golem"
size: "Large"
type: "Construct"
alignment: "Unaligned"
ac: "14"
hp: "123"
hit_dice: "13d10 + 52"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":20},{\\"ability\\":\\"dex\\",\\"score\\":9},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":8},{\\"ability\\":\\"cha\\",\\"score\\":1}]"
pb: "+4"
cr: "9"
xp: "5000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Acid Absorption\\",\\"text\\":\\"Whenever the golem is subjected to Acid damage, it takes no damage and instead regains a number of Hit Points equal to the Acid damage dealt.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Berserk\\",\\"text\\":\\"Whenever the golem starts its turn Bloodied, roll 1d6. On a 6, the golem goes berserk. On each of its turns while berserk, the golem attacks the nearest creature it can see. If no creature is near enough to move to and attack, the golem attacks an object. Once the golem goes berserk, it continues to be berserk until it is destroyed or it is no longer Bloodied.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Immutable Form\\",\\"text\\":\\"The golem can't shape-shift.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The golem has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The golem makes two Slam attacks, or it makes three Slam attacks if it used Hasten this turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Slam\\",\\"text\\":\\"*Melee Attack Roll:* +9, reach 5 ft. 10 (1d10 + 5) Bludgeoning damage plus 6 (1d12) Acid damage, and the target's Hit Point maximum decreases by an amount equal to the Acid damage taken.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Hasten (Recharge 5-6)\\",\\"text\\":\\"The golem takes the Dash and Disengage actions.\\"}]"
---

# Clay Golem
*Large, Construct, Unaligned*

**AC** 14
**HP** 123 (13d10 + 52)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 20 | 9 | 18 | 3 | 8 | 1 |

CR 9, PB +4, XP 5000

## Traits

**Acid Absorption**
Whenever the golem is subjected to Acid damage, it takes no damage and instead regains a number of Hit Points equal to the Acid damage dealt.

**Berserk**
Whenever the golem starts its turn Bloodied, roll 1d6. On a 6, the golem goes berserk. On each of its turns while berserk, the golem attacks the nearest creature it can see. If no creature is near enough to move to and attack, the golem attacks an object. Once the golem goes berserk, it continues to be berserk until it is destroyed or it is no longer Bloodied.

**Immutable Form**
The golem can't shape-shift.

**Magic Resistance**
The golem has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The golem makes two Slam attacks, or it makes three Slam attacks if it used Hasten this turn.

**Slam**
*Melee Attack Roll:* +9, reach 5 ft. 10 (1d10 + 5) Bludgeoning damage plus 6 (1d12) Acid damage, and the target's Hit Point maximum decreases by an amount equal to the Acid damage taken.

## Bonus Actions

**Hasten (Recharge 5-6)**
The golem takes the Dash and Disengage actions.
`,
      "cloaker.md": `---
smType: creature
name: "Cloaker"
size: "Large"
type: "Aberration"
alignment: "Chaotic Neutral"
ac: "14"
hp: "91"
hit_dice: "14d10 + 14"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"fly\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":13},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+3"
cr: "8"
xp: "3900"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Light Sensitivity\\",\\"text\\":\\"While in Bright Light, the cloaker has Disadvantage on attack rolls.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The cloaker makes one Attach attack and two Tail attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Attach\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 13 (3d6 + 3) Piercing damage. If the target is a Large or smaller creature, the cloaker attaches to it. While the cloaker is attached, the target has the Blinded condition, and the cloaker can't make Attach attacks against other targets. In addition, the cloaker halves the damage it takes (round down), and the target takes the same amount of damage. The cloaker can detach itself by spending 5 feet of movement. The target or a creature within 5 feet of it can take an action to try to detach the cloaker, doing so by succeeding on a DC 14 Strength (Athletics) check.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tail\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 10 ft. 8 (1d10 + 3) Slashing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Moan\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 13, each creature in a 60-foot Emanation originating from the cloaker. *Failure:*  The target has the Frightened condition until the end of the cloaker's next turn. *Success:*  The target is immune to this cloaker's Moan for the next 24 hours.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Phantasms (Recharge after a Short or Long Rest)\\",\\"text\\":\\"The cloaker casts the *Mirror Image* spell, requiring no spell components and using Wisdom as the spellcasting ability. The spell ends early if the cloaker starts or ends its turn in Bright Light.\\"}]"
---

# Cloaker
*Large, Aberration, Chaotic Neutral*

**AC** 14
**HP** 91 (14d10 + 14)
**Speed** 10 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 15 | 12 | 13 | 14 | 7 |

CR 8, PB +3, XP 3900

## Traits

**Light Sensitivity**
While in Bright Light, the cloaker has Disadvantage on attack rolls.

## Actions

**Multiattack**
The cloaker makes one Attach attack and two Tail attacks.

**Attach**
*Melee Attack Roll:* +6, reach 5 ft. 13 (3d6 + 3) Piercing damage. If the target is a Large or smaller creature, the cloaker attaches to it. While the cloaker is attached, the target has the Blinded condition, and the cloaker can't make Attach attacks against other targets. In addition, the cloaker halves the damage it takes (round down), and the target takes the same amount of damage. The cloaker can detach itself by spending 5 feet of movement. The target or a creature within 5 feet of it can take an action to try to detach the cloaker, doing so by succeeding on a DC 14 Strength (Athletics) check.

**Tail**
*Melee Attack Roll:* +6, reach 10 ft. 8 (1d10 + 3) Slashing damage.

## Bonus Actions

**Moan**
*Wisdom Saving Throw*: DC 13, each creature in a 60-foot Emanation originating from the cloaker. *Failure:*  The target has the Frightened condition until the end of the cloaker's next turn. *Success:*  The target is immune to this cloaker's Moan for the next 24 hours.

**Phantasms (Recharge after a Short or Long Rest)**
The cloaker casts the *Mirror Image* spell, requiring no spell components and using Wisdom as the spellcasting ability. The spell ends early if the cloaker starts or ends its turn in Bright Light.
`,
      "cloud-giant.md": `---
smType: creature
name: "Cloud Giant"
size: "Huge"
type: "Giant"
alignment: "Neutral Neutral"
ac: "14"
hp: "200"
hit_dice: "16d12 + 96"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"20 ft.\\",\\"hover\\":true}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":27},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":22},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":16},{\\"ability\\":\\"cha\\",\\"score\\":16}]"
pb: "+4"
saves_json: "[{\\"ability\\":\\"con\\",\\"bonus\\":10},{\\"ability\\":\\"wis\\",\\"bonus\\":7}]"
cr: "9"
xp: "5000"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The giant makes two attacks, using Thunderous Mace or Thundercloud in any combination. It can replace one attack with a use of Spellcasting to cast *Fog Cloud*.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Thunderous Mace\\",\\"text\\":\\"*Melee Attack Roll:* +12, reach 10 ft. 21 (3d8 + 8) Bludgeoning damage plus 7 (2d6) Thunder damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Thundercloud\\",\\"text\\":\\"*Ranged Attack Roll:* +12, range 240 ft. 18 (3d6 + 8) Thunder damage, and the target has the Incapacitated condition until the end of its next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The giant casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 15): - **At Will:** *Detect Magic*, *Fog Cloud*, *Light* - **1e/Day Each:** *Control Weather*, *Gaseous Form*, *Telekinesis*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Misty Step\\",\\"text\\":\\"The giant casts the *Misty Step* spell, using the same spellcasting ability as Spellcasting.\\"}]"
---

# Cloud Giant
*Huge, Giant, Neutral Neutral*

**AC** 14
**HP** 200 (16d12 + 96)
**Speed** 40 ft., fly 20 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 27 | 10 | 22 | 12 | 16 | 16 |

CR 9, PB +4, XP 5000

## Actions

**Multiattack**
The giant makes two attacks, using Thunderous Mace or Thundercloud in any combination. It can replace one attack with a use of Spellcasting to cast *Fog Cloud*.

**Thunderous Mace**
*Melee Attack Roll:* +12, reach 10 ft. 21 (3d8 + 8) Bludgeoning damage plus 7 (2d6) Thunder damage.

**Thundercloud**
*Ranged Attack Roll:* +12, range 240 ft. 18 (3d6 + 8) Thunder damage, and the target has the Incapacitated condition until the end of its next turn.

**Spellcasting**
The giant casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 15): - **At Will:** *Detect Magic*, *Fog Cloud*, *Light* - **1e/Day Each:** *Control Weather*, *Gaseous Form*, *Telekinesis*

## Bonus Actions

**Misty Step**
The giant casts the *Misty Step* spell, using the same spellcasting ability as Spellcasting.
`,
      "cockatrice.md": `---
smType: creature
name: "Cockatrice"
size: "Small"
type: "Monstrosity"
alignment: "Unaligned"
ac: "11"
hp: "22"
hit_dice: "5d6 + 5"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"fly\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":6},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Petrifying Bite\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 3 (1d4 + 1) Piercing damage. If the target is a creature, it is subjected to the following effect. *Constitution Saving Throw*: DC 11. *First Failure* The target has the Restrained condition. The target repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition, instead of the Restrained condition, for 24 hours.\\"}]"
---

# Cockatrice
*Small, Monstrosity, Unaligned*

**AC** 11
**HP** 22 (5d6 + 5)
**Speed** 20 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 6 | 12 | 12 | 2 | 13 | 5 |

CR 1/2, PB +2, XP 100

## Actions

**Petrifying Bite**
*Melee Attack Roll:* +3, reach 5 ft. 3 (1d4 + 1) Piercing damage. If the target is a creature, it is subjected to the following effect. *Constitution Saving Throw*: DC 11. *First Failure* The target has the Restrained condition. The target repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition, instead of the Restrained condition, for 24 hours.
`,
      "commoner.md": `---
smType: creature
name: "Commoner"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "10"
hp: "4"
hit_dice: "1d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Training\\",\\"text\\":\\"The commoner has proficiency in one skill of the DM's choice and has Advantage whenever it makes an ability check using that skill.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Club\\",\\"text\\":\\"*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Bludgeoning damage.\\"}]"
---

# Commoner
*Small, Humanoid, Neutral Neutral*

**AC** 10
**HP** 4 (1d8)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 10 | 10 | 10 | 10 | 10 |

CR 0, PB +2, XP 0

## Traits

**Training**
The commoner has proficiency in one skill of the DM's choice and has Advantage whenever it makes an ability check using that skill.

## Actions

**Club**
*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Bludgeoning damage.
`,
      "copper-dragon-wyrmling.md": `---
smType: creature
name: "Copper Dragon Wyrmling"
size: "Medium"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Chaotic Good"
ac: "16"
hp: "22"
hit_dice: "4d8 + 4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":14},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":13}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":3},{\\"ability\\":\\"wis\\",\\"bonus\\":2}]"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Acid Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 11, each creature in a 20-foot-long, 5-foot-wide Line. *Failure:*  18 (4d8) Acid damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Slowing Breath\\",\\"text\\":\\"*Constitution Saving Throw*: DC 11, each creature in a 15-foot Cone. *Failure:*  The target can't take Reactions; its Speed is halved; and it can take either an action or a Bonus Action on its turn, not both. This effect lasts until the end of its next turn.\\"}]"
---

# Copper Dragon Wyrmling
*Medium, Dragon, Chaotic Good*

**AC** 16
**HP** 22 (4d8 + 4)
**Speed** 30 ft., climb 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 12 | 13 | 14 | 11 | 13 |

CR 1, PB +2, XP 200

## Actions

**Rend**
*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage.

**Acid Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 11, each creature in a 20-foot-long, 5-foot-wide Line. *Failure:*  18 (4d8) Acid damage. *Success:*  Half damage.

**Slowing Breath**
*Constitution Saving Throw*: DC 11, each creature in a 15-foot Cone. *Failure:*  The target can't take Reactions; its Speed is halved; and it can take either an action or a Bonus Action on its turn, not both. This effect lasts until the end of its next turn.
`,
      "couatl.md": `---
smType: creature
name: "Couatl"
size: "Medium"
type: "Celestial"
alignment: "Lawful Good"
ac: "19"
hp: "60"
hit_dice: "8d8 + 24"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"90 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":20},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":18},{\\"ability\\":\\"wis\\",\\"score\\":20},{\\"ability\\":\\"cha\\",\\"score\\":18}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"con\\",\\"bonus\\":5},{\\"ability\\":\\"wis\\",\\"bonus\\":7}]"
cr: "4"
xp: "1100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Shielded Mind\\",\\"text\\":\\"The couatl's thoughts can't be read by any means, and other creatures can communicate with it telepathically only if it allows them.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 11 (1d12 + 5) Piercing damage, and the target has the Poisoned condition until the end of the couatl's next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Constrict\\",\\"text\\":\\"*Strength Saving Throw*: DC 15, one Medium or smaller creature the couatl can see within 5 feet. *Failure:*  8 (1d6 + 5) Bludgeoning damage. The target has the Grappled condition (escape DC 13), and it has the Restrained condition until the grapple ends.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The couatl casts one of the following spells, requiring no spell components and using Wisdom as the spellcasting ability (spell save DC 15): - **At Will:** *Detect Evil and Good*, *Detect Magic*, *Detect Thoughts*, *Shapechange* - **1e/Day Each:** *Create Food and Water*, *Dream*, *Greater Restoration*, *Scrying*, *Sleep*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Divine Aid (2/Day)\\",\\"text\\":\\"The couatl casts *Bless*, *Lesser Restoration*, or *Sanctuary*, requiring no spell components and using the same spellcasting ability as Spellcasting.\\"}]"
---

# Couatl
*Medium, Celestial, Lawful Good*

**AC** 19
**HP** 60 (8d8 + 24)
**Speed** 30 ft., fly 90 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 20 | 17 | 18 | 20 | 18 |

CR 4, PB +2, XP 1100

## Traits

**Shielded Mind**
The couatl's thoughts can't be read by any means, and other creatures can communicate with it telepathically only if it allows them.

## Actions

**Bite**
*Melee Attack Roll:* +7, reach 5 ft. 11 (1d12 + 5) Piercing damage, and the target has the Poisoned condition until the end of the couatl's next turn.

**Constrict**
*Strength Saving Throw*: DC 15, one Medium or smaller creature the couatl can see within 5 feet. *Failure:*  8 (1d6 + 5) Bludgeoning damage. The target has the Grappled condition (escape DC 13), and it has the Restrained condition until the grapple ends.

**Spellcasting**
The couatl casts one of the following spells, requiring no spell components and using Wisdom as the spellcasting ability (spell save DC 15): - **At Will:** *Detect Evil and Good*, *Detect Magic*, *Detect Thoughts*, *Shapechange* - **1e/Day Each:** *Create Food and Water*, *Dream*, *Greater Restoration*, *Scrying*, *Sleep*

## Bonus Actions

**Divine Aid (2/Day)**
The couatl casts *Bless*, *Lesser Restoration*, or *Sanctuary*, requiring no spell components and using the same spellcasting ability as Spellcasting.
`,
      "cultist-fanatic.md": `---
smType: creature
name: "Cultist Fanatic"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "13"
hp: "44"
hit_dice: "8d8 + 8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":11},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":13}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"wis\\",\\"bonus\\":4}]"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Pact Blade\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Slashing damage plus 7 (2d6) Necrotic damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The cultist casts one of the following spells, using Wisdom as the spellcasting ability (spell save DC 12, +4 to hit with spell attacks): - **At Will:** *Light*, *Thaumaturgy* - **1/Day Each:** *Hold Person* - **2/Day Each:** *Command*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Spiritual Weapon (2/Day)\\",\\"text\\":\\"The cultist casts the *Spiritual Weapon* spell, using the same spellcasting ability as Spellcasting.\\"}]"
---

# Cultist Fanatic
*Small, Humanoid, Neutral Neutral*

**AC** 13
**HP** 44 (8d8 + 8)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 11 | 14 | 12 | 10 | 14 | 13 |

CR 2, PB +2, XP 450

## Actions

**Pact Blade**
*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Slashing damage plus 7 (2d6) Necrotic damage.

**Spellcasting**
The cultist casts one of the following spells, using Wisdom as the spellcasting ability (spell save DC 12, +4 to hit with spell attacks): - **At Will:** *Light*, *Thaumaturgy* - **1/Day Each:** *Hold Person* - **2/Day Each:** *Command*

## Bonus Actions

**Spiritual Weapon (2/Day)**
The cultist casts the *Spiritual Weapon* spell, using the same spellcasting ability as Spellcasting.
`,
      "cultist.md": `---
smType: creature
name: "Cultist"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "12"
hp: "9"
hit_dice: "2d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":11},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"wis\\",\\"bonus\\":2}]"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Ritual Sickle\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 3 (1d4 + 1) Slashing damage plus 1 Necrotic damage.\\"}]"
---

# Cultist
*Small, Humanoid, Neutral Neutral*

**AC** 12
**HP** 9 (2d8)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 11 | 12 | 10 | 10 | 11 | 10 |

CR 1/8, PB +2, XP 25

## Actions

**Ritual Sickle**
*Melee Attack Roll:* +3, reach 5 ft. 3 (1d4 + 1) Slashing damage plus 1 Necrotic damage.
`,
      "darkmantle.md": `---
smType: creature
name: "Darkmantle"
size: "Small"
type: "Aberration"
alignment: "Unaligned"
ac: "11"
hp: "22"
hit_dice: "5d6 + 5"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"fly\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Crush\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage, and the darkmantle attaches to the target. If the target is a Medium or smaller creature and the darkmantle had Advantage on the attack roll, it covers the target, which has the Blinded condition and is suffocating while the darkmantle is attached in this way. While attached to a target, the darkmantle can attack only the target but has Advantage on its attack rolls. Its Speed becomes 0, it can't benefit from any bonus to its Speed, and it moves with the target. A creature can take an action to try to detach the darkmantle from itself, doing so with a successful DC 13 Strength (Athletics) check. On its turn, the darkmantle can detach itself by using 5 feet of movement.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Darkness Aura (1/Day)\\",\\"text\\":\\"Magical darkness fills a 15-foot Emanation originating from the darkmantle. This effect lasts while the darkmantle maintains  Concentration on it, up to 10 minutes. Darkvision can't penetrate this area, and no light can illuminate it.\\"}]"
---

# Darkmantle
*Small, Aberration, Unaligned*

**AC** 11
**HP** 22 (5d6 + 5)
**Speed** 10 ft., fly 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 12 | 13 | 2 | 10 | 5 |

CR 1/2, PB +2, XP 100

## Actions

**Crush**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage, and the darkmantle attaches to the target. If the target is a Medium or smaller creature and the darkmantle had Advantage on the attack roll, it covers the target, which has the Blinded condition and is suffocating while the darkmantle is attached in this way. While attached to a target, the darkmantle can attack only the target but has Advantage on its attack rolls. Its Speed becomes 0, it can't benefit from any bonus to its Speed, and it moves with the target. A creature can take an action to try to detach the darkmantle from itself, doing so with a successful DC 13 Strength (Athletics) check. On its turn, the darkmantle can detach itself by using 5 feet of movement.

**Darkness Aura (1/Day)**
Magical darkness fills a 15-foot Emanation originating from the darkmantle. This effect lasts while the darkmantle maintains  Concentration on it, up to 10 minutes. Darkvision can't penetrate this area, and no light can illuminate it.
`,
      "death-dog.md": `---
smType: creature
name: "Death Dog"
size: "Medium"
type: "Monstrosity"
alignment: "Neutral Evil"
ac: "12"
hp: "39"
hit_dice: "6d8 + 12"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The death dog makes two Bite attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage. If the target is a creature, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *First Failure* The target has the Poisoned condition. While Poisoned, the target's Hit Point maximum doesn't return to normal when finishing a Long Rest, and it repeats the save every 24 hours that elapse, ending the effect on itself on a success. Subsequent Failures: The Poisoned target's Hit Point maximum decreases by 5 (1d10).\\"}]"
---

# Death Dog
*Medium, Monstrosity, Neutral Evil*

**AC** 12
**HP** 39 (6d8 + 12)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 14 | 14 | 3 | 13 | 6 |

CR 1, PB +2, XP 200

## Actions

**Multiattack**
The death dog makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage. If the target is a creature, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *First Failure* The target has the Poisoned condition. While Poisoned, the target's Hit Point maximum doesn't return to normal when finishing a Long Rest, and it repeats the save every 24 hours that elapse, ending the effect on itself on a success. Subsequent Failures: The Poisoned target's Hit Point maximum decreases by 5 (1d10).
`,
      "deva.md": `---
smType: creature
name: "Deva"
size: "Medium"
type: "Celestial"
type_tags: ["Angel"]
alignment: "Lawful Good"
ac: "17"
hp: "229"
hit_dice: "27d8 + 108"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"90 ft.\\",\\"hover\\":true}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":18},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":17},{\\"ability\\":\\"wis\\",\\"score\\":20},{\\"ability\\":\\"cha\\",\\"score\\":20}]"
pb: "+4"
saves_json: "[{\\"ability\\":\\"wis\\",\\"bonus\\":9},{\\"ability\\":\\"cha\\",\\"bonus\\":9}]"
cr: "10"
xp: "5900"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Exalted Restoration\\",\\"text\\":\\"If the deva dies outside Mount Celestia, its body disappears, and it gains a new body instantly, reviving with all its Hit Points somewhere in Mount Celestia.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The deva has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The deva makes two Holy Mace attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Holy Mace\\",\\"text\\":\\"*Melee Attack Roll:* +8, reach 5 ft. 7 (1d6 + 4) Bludgeoning damage plus 18 (4d8) Radiant damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The deva casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Evil and Good*, *Shapechange* - **1e/Day Each:** *Commune*, *Raise Dead*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Divine Aid (2/Day)\\",\\"text\\":\\"The deva casts *Cure Wounds*, *Lesser Restoration*, or *Remove Curse*, using the same spellcasting ability as Spellcasting.\\"}]"
---

# Deva
*Medium, Celestial, Lawful Good*

**AC** 17
**HP** 229 (27d8 + 108)
**Speed** 30 ft., fly 90 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 18 | 18 | 17 | 20 | 20 |

CR 10, PB +4, XP 5900

## Traits

**Exalted Restoration**
If the deva dies outside Mount Celestia, its body disappears, and it gains a new body instantly, reviving with all its Hit Points somewhere in Mount Celestia.

**Magic Resistance**
The deva has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The deva makes two Holy Mace attacks.

**Holy Mace**
*Melee Attack Roll:* +8, reach 5 ft. 7 (1d6 + 4) Bludgeoning damage plus 18 (4d8) Radiant damage.

**Spellcasting**
The deva casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Evil and Good*, *Shapechange* - **1e/Day Each:** *Commune*, *Raise Dead*

## Bonus Actions

**Divine Aid (2/Day)**
The deva casts *Cure Wounds*, *Lesser Restoration*, or *Remove Curse*, using the same spellcasting ability as Spellcasting.
`,
      "djinni.md": `---
smType: creature
name: "Djinni"
size: "Large"
type: "Elemental"
type_tags: ["Genie"]
alignment: "Chaotic Good"
ac: "17"
hp: "218"
hit_dice: "19d10 + 114"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"90 ft.\\",\\"hover\\":true}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":21},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":22},{\\"ability\\":\\"int\\",\\"score\\":15},{\\"ability\\":\\"wis\\",\\"score\\":16},{\\"ability\\":\\"cha\\",\\"score\\":20}]"
pb: "+4"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":6},{\\"ability\\":\\"wis\\",\\"bonus\\":7}]"
cr: "11"
xp: "7200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Elemental Restoration\\",\\"text\\":\\"If the djinni dies outside the Elemental Plane of Air, its body dissolves into mist, and it gains a new body in 1d4 days, reviving with all its Hit Points somewhere on the Plane of Air.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The djinni has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Wishes\\",\\"text\\":\\"The djinni has a 30 percent chance of knowing the *Wish* spell. If the djinni knows it, the djinni can cast it only on behalf of a non-genie creature who communicates a wish in a way the djinni can understand. If the djinni casts the spell for the creature, the djinni suffers none of the spell's stress. Once the djinni has cast it three times, the djinni can't do so again for 365 days.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The djinni makes three attacks, using Storm Blade or Storm Bolt in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Storm Blade\\",\\"text\\":\\"*Melee Attack Roll:* +9, reach 5 feet. 12 (2d6 + 5) Slashing damage plus 7 (2d6) Lightning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Storm Bolt\\",\\"text\\":\\"*Ranged Attack Roll:* +9, range 120 feet. 13 (3d8) Thunder damage. If the target is a Large or smaller creature, it has the Prone condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Create Whirlwind\\",\\"text\\":\\"The djinni conjures a whirlwind at a point it can see within 120 feet. The whirlwind fills a 20-foot-radius, 60-foot-high Cylinder [Area of Effect]|XPHB|Cylinder centered on that point. The whirlwind lasts until the djinni's  Concentration on it ends. The djinni can move the whirlwind up to 20 feet at the start of each of its turns. Whenever the whirlwind enters a creature's space or a creature enters the whirlwind, that creature is subjected to the following effect. *Strength Saving Throw*: DC 17 (a creature makes this save only once per turn, and the djinni is unaffected). *Failure:*  While in the whirlwind, the target has the Restrained condition and moves with the whirlwind. At the start of each of its turns, the Restrained target takes 21 (6d6) Thunder damage. At the end of each of its turns, the target repeats the save, ending the effect on itself on a success.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The djinni casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Evil and Good*, *Detect Magic* - **2e/Day Each:** *Create Food and Water*, *Tongues*, *Wind Walk* - **1e/Day Each:** *Creation*, *Gaseous Form*, *Invisibility*, *Major Image*, *Plane Shift*\\"}]"
---

# Djinni
*Large, Elemental, Chaotic Good*

**AC** 17
**HP** 218 (19d10 + 114)
**Speed** 30 ft., fly 90 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 21 | 15 | 22 | 15 | 16 | 20 |

CR 11, PB +4, XP 7200

## Traits

**Elemental Restoration**
If the djinni dies outside the Elemental Plane of Air, its body dissolves into mist, and it gains a new body in 1d4 days, reviving with all its Hit Points somewhere on the Plane of Air.

**Magic Resistance**
The djinni has Advantage on saving throws against spells and other magical effects.

**Wishes**
The djinni has a 30 percent chance of knowing the *Wish* spell. If the djinni knows it, the djinni can cast it only on behalf of a non-genie creature who communicates a wish in a way the djinni can understand. If the djinni casts the spell for the creature, the djinni suffers none of the spell's stress. Once the djinni has cast it three times, the djinni can't do so again for 365 days.

## Actions

**Multiattack**
The djinni makes three attacks, using Storm Blade or Storm Bolt in any combination.

**Storm Blade**
*Melee Attack Roll:* +9, reach 5 feet. 12 (2d6 + 5) Slashing damage plus 7 (2d6) Lightning damage.

**Storm Bolt**
*Ranged Attack Roll:* +9, range 120 feet. 13 (3d8) Thunder damage. If the target is a Large or smaller creature, it has the Prone condition.

**Create Whirlwind**
The djinni conjures a whirlwind at a point it can see within 120 feet. The whirlwind fills a 20-foot-radius, 60-foot-high Cylinder [Area of Effect]|XPHB|Cylinder centered on that point. The whirlwind lasts until the djinni's  Concentration on it ends. The djinni can move the whirlwind up to 20 feet at the start of each of its turns. Whenever the whirlwind enters a creature's space or a creature enters the whirlwind, that creature is subjected to the following effect. *Strength Saving Throw*: DC 17 (a creature makes this save only once per turn, and the djinni is unaffected). *Failure:*  While in the whirlwind, the target has the Restrained condition and moves with the whirlwind. At the start of each of its turns, the Restrained target takes 21 (6d6) Thunder damage. At the end of each of its turns, the target repeats the save, ending the effect on itself on a success.

**Spellcasting**
The djinni casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 17): - **At Will:** *Detect Evil and Good*, *Detect Magic* - **2e/Day Each:** *Create Food and Water*, *Tongues*, *Wind Walk* - **1e/Day Each:** *Creation*, *Gaseous Form*, *Invisibility*, *Major Image*, *Plane Shift*
`,
      "doppelganger.md": `---
smType: creature
name: "Doppelganger"
size: "Medium"
type: "Monstrosity"
alignment: "Neutral Neutral"
ac: "14"
hp: "52"
hit_dice: "8d8 + 16"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":11},{\\"ability\\":\\"dex\\",\\"score\\":18},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":14}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The doppelganger makes two Slam attacks and uses Unsettling Visage if available.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Slam\\",\\"text\\":\\"*Melee Attack Roll:* +6 (with Advantage during the first round of each combat), reach 5 ft. 11 (2d6 + 4) Bludgeoning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Unsettling Visage\\",\\"recharge\\":\\"Recharge 6\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 12, each creature in a 15-foot Emanation originating from the doppelganger that can see the doppelganger. *Failure:*  The target has the Frightened condition and repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Read Thoughts\\",\\"text\\":\\"The doppelganger casts *Detect Thoughts*, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 12). - **At Will:** *Detect Thoughts*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Shape-Shift\\",\\"text\\":\\"The doppelganger shape-shifts into a Medium or Small Humanoid, or it returns to its true form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.\\"}]"
---

# Doppelganger
*Medium, Monstrosity, Neutral Neutral*

**AC** 14
**HP** 52 (8d8 + 16)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 11 | 18 | 14 | 11 | 12 | 14 |

CR 3, PB +2, XP 700

## Actions

**Multiattack**
The doppelganger makes two Slam attacks and uses Unsettling Visage if available.

**Slam**
*Melee Attack Roll:* +6 (with Advantage during the first round of each combat), reach 5 ft. 11 (2d6 + 4) Bludgeoning damage.

**Unsettling Visage (Recharge 6)**
*Wisdom Saving Throw*: DC 12, each creature in a 15-foot Emanation originating from the doppelganger that can see the doppelganger. *Failure:*  The target has the Frightened condition and repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.

**Read Thoughts**
The doppelganger casts *Detect Thoughts*, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 12). - **At Will:** *Detect Thoughts*

## Bonus Actions

**Shape-Shift**
The doppelganger shape-shifts into a Medium or Small Humanoid, or it returns to its true form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
`,
      "dragon-turtle.md": `---
smType: creature
name: "Dragon Turtle"
size: "Gargantuan"
type: "Dragon"
alignment: "Neutral Neutral"
ac: "20"
hp: "356"
hit_dice: "23d20 + 115"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"swim\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":25},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":20},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":12}]"
pb: "+6"
saves_json: "[{\\"ability\\":\\"con\\",\\"bonus\\":11},{\\"ability\\":\\"wis\\",\\"bonus\\":7}]"
cr: "17"
xp: "18000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Bite attacks. It can replace one attack with a Tail attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +13, reach 15 ft. 23 (3d10 + 7) Piercing damage plus 7 (2d6) Fire damage. Being underwater doesn't grant Resistance to this Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tail\\",\\"text\\":\\"*Melee Attack Roll:* +13, reach 15 ft. 18 (2d10 + 7) Bludgeoning damage. If the target is a Huge or smaller creature, it has the Prone condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Steam Breath (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 19, each creature in a 60-foot Cone. *Failure:*  56 (16d6) Fire damage. *Success:*  Half damage. *Failure or Success*:  Being underwater doesn't grant Resistance to this Fire damage.\\"}]"
---

# Dragon Turtle
*Gargantuan, Dragon, Neutral Neutral*

**AC** 20
**HP** 356 (23d20 + 115)
**Speed** 20 ft., swim 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 25 | 10 | 20 | 10 | 12 | 12 |

CR 17, PB +6, XP 18000

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes three Bite attacks. It can replace one attack with a Tail attack.

**Bite**
*Melee Attack Roll:* +13, reach 15 ft. 23 (3d10 + 7) Piercing damage plus 7 (2d6) Fire damage. Being underwater doesn't grant Resistance to this Fire damage.

**Tail**
*Melee Attack Roll:* +13, reach 15 ft. 18 (2d10 + 7) Bludgeoning damage. If the target is a Huge or smaller creature, it has the Prone condition.

**Steam Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 19, each creature in a 60-foot Cone. *Failure:*  56 (16d6) Fire damage. *Success:*  Half damage. *Failure or Success*:  Being underwater doesn't grant Resistance to this Fire damage.
`,
      "dretch.md": `---
smType: creature
name: "Dretch"
size: "Small"
type: "Fiend"
type_tags: ["Demon"]
alignment: "Chaotic Evil"
ac: "11"
hp: "18"
hit_dice: "4d6 + 4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":12},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":5},{\\"ability\\":\\"wis\\",\\"score\\":8},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fetid Cloud (1/Day)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 11, each creature in a 10-foot Emanation originating from the dretch. *Failure:*  The target has the Poisoned condition until the end of its next turn. While Poisoned, the creature can take either an action or a Bonus Action on its turn, not both, and it can't take Reactions.\\"}]"
---

# Dretch
*Small, Fiend, Chaotic Evil*

**AC** 11
**HP** 18 (4d6 + 4)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 12 | 11 | 12 | 5 | 8 | 3 |

CR 1/4, PB +2, XP 50

## Actions

**Rend**
*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Slashing damage.

**Fetid Cloud (1/Day)**
*Constitution Saving Throw*: DC 11, each creature in a 10-foot Emanation originating from the dretch. *Failure:*  The target has the Poisoned condition until the end of its next turn. While Poisoned, the creature can take either an action or a Bonus Action on its turn, not both, and it can't take Reactions.
`,
      "drider.md": `---
smType: creature
name: "Drider"
size: "Large"
type: "Monstrosity"
alignment: "Chaotic Evil"
ac: "19"
hp: "123"
hit_dice: "13d10 + 52"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":19},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":13},{\\"ability\\":\\"wis\\",\\"score\\":16},{\\"ability\\":\\"cha\\",\\"score\\":12}]"
pb: "+3"
cr: "6"
xp: "2300"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Spider Climb\\",\\"text\\":\\"The drider can climb difficult surfaces, including along ceilings, without needing to make an ability check.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Sunlight Sensitivity\\",\\"text\\":\\"While in sunlight, the drider has Disadvantage on ability checks and attack rolls.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Web Walker\\",\\"text\\":\\"The drider ignores movement restrictions caused by webs, and the drider knows the location of any other creature in contact with the same web.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The drider makes three attacks, using Foreleg or Poison Burst in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Foreleg\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 10 ft. 13 (2d8 + 4) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Poison Burst\\",\\"text\\":\\"*Ranged Attack Roll:* +6, range 120 ft. 13 (3d6 + 3) Poison damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Magic of the Spider Queen (Recharge 5-6)\\",\\"text\\":\\"The drider casts *Darkness*, *Faerie Fire*, or *Web*, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 14).\\"}]"
---

# Drider
*Large, Monstrosity, Chaotic Evil*

**AC** 19
**HP** 123 (13d10 + 52)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 19 | 18 | 13 | 16 | 12 |

CR 6, PB +3, XP 2300

## Traits

**Spider Climb**
The drider can climb difficult surfaces, including along ceilings, without needing to make an ability check.

**Sunlight Sensitivity**
While in sunlight, the drider has Disadvantage on ability checks and attack rolls.

**Web Walker**
The drider ignores movement restrictions caused by webs, and the drider knows the location of any other creature in contact with the same web.

## Actions

**Multiattack**
The drider makes three attacks, using Foreleg or Poison Burst in any combination.

**Foreleg**
*Melee Attack Roll:* +7, reach 10 ft. 13 (2d8 + 4) Piercing damage.

**Poison Burst**
*Ranged Attack Roll:* +6, range 120 ft. 13 (3d6 + 3) Poison damage.

## Bonus Actions

**Magic of the Spider Queen (Recharge 5-6)**
The drider casts *Darkness*, *Faerie Fire*, or *Web*, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 14).
`,
      "druid.md": `---
smType: creature
name: "Druid"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "13"
hp: "44"
hit_dice: "8d8 + 8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":16},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The druid makes two attacks, using Vine Staff or Verdant Wisp in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Vine Staff\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Bludgeoning damage plus 2 (1d4) Poison damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Verdant Wisp\\",\\"text\\":\\"*Ranged Attack Roll:* +5, range 90 ft. 10 (3d6) Radiant damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The druid casts one of the following spells, using Wisdom as the spellcasting ability (spell save DC 13): - **At Will:** *Druidcraft*, *Speak with Animals* - **2e/Day Each:** *Entangle*, *Thunderwave* - **1e/Day Each:** *Animal Messenger*, *Longstrider*, *Moonbeam*\\"}]"
---

# Druid
*Small, Humanoid, Neutral Neutral*

**AC** 13
**HP** 44 (8d8 + 8)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 12 | 13 | 12 | 16 | 11 |

CR 2, PB +2, XP 450

## Actions

**Multiattack**
The druid makes two attacks, using Vine Staff or Verdant Wisp in any combination.

**Vine Staff**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Bludgeoning damage plus 2 (1d4) Poison damage.

**Verdant Wisp**
*Ranged Attack Roll:* +5, range 90 ft. 10 (3d6) Radiant damage.

**Spellcasting**
The druid casts one of the following spells, using Wisdom as the spellcasting ability (spell save DC 13): - **At Will:** *Druidcraft*, *Speak with Animals* - **2e/Day Each:** *Entangle*, *Thunderwave* - **1e/Day Each:** *Animal Messenger*, *Longstrider*, *Moonbeam*
`,
      "dryad.md": `---
smType: creature
name: "Dryad"
size: "Medium"
type: "Fey"
alignment: "Neutral Neutral"
ac: "16"
hp: "22"
hit_dice: "5d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":14},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":18}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The dryad has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Speak with Beasts and Plants\\",\\"text\\":\\"The dryad can communicate with Beasts and Plants as if they shared a language.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dryad makes one Vine Lash or Thorn Burst attack, and it can use Spellcasting to cast *Charm Monster*.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Vine Lash\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 10 ft. 8 (1d8 + 4) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Thorn Burst\\",\\"text\\":\\"*Ranged Attack Roll:* +6, range 60 ft. 7 (1d6 + 4) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The dryad casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 14): - **At Will:** *Animal Friendship*, *Charm Monster*, *Druidcraft* - **1e/Day Each:** *Entangle*, *Pass without Trace*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Tree Stride\\",\\"text\\":\\"If within 5 feet of a Large or bigger tree, the dryad teleports to an unoccupied space within 5 feet of a second Large or bigger tree that is within 60 feet of the previous tree.\\"}]"
---

# Dryad
*Medium, Fey, Neutral Neutral*

**AC** 16
**HP** 22 (5d8)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 12 | 11 | 14 | 15 | 18 |

CR 1, PB +2, XP 200

## Traits

**Magic Resistance**
The dryad has Advantage on saving throws against spells and other magical effects.

**Speak with Beasts and Plants**
The dryad can communicate with Beasts and Plants as if they shared a language.

## Actions

**Multiattack**
The dryad makes one Vine Lash or Thorn Burst attack, and it can use Spellcasting to cast *Charm Monster*.

**Vine Lash**
*Melee Attack Roll:* +6, reach 10 ft. 8 (1d8 + 4) Slashing damage.

**Thorn Burst**
*Ranged Attack Roll:* +6, range 60 ft. 7 (1d6 + 4) Piercing damage.

**Spellcasting**
The dryad casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 14): - **At Will:** *Animal Friendship*, *Charm Monster*, *Druidcraft* - **1e/Day Each:** *Entangle*, *Pass without Trace*

## Bonus Actions

**Tree Stride**
If within 5 feet of a Large or bigger tree, the dryad teleports to an unoccupied space within 5 feet of a second Large or bigger tree that is within 60 feet of the previous tree.
`,
      "dust-mephit.md": `---
smType: creature
name: "Dust Mephit"
size: "Small"
type: "Elemental"
alignment: "Neutral Evil"
ac: "12"
hp: "17"
hit_dice: "5d6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":5},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":9},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Death Burst\\",\\"text\\":\\"The mephit explodes when it dies. *Dexterity Saving Throw*: DC 10, each creature in a 5-foot Emanation originating from the mephit. *Failure:*  5 (2d4) Bludgeoning damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Blinding Breath\\",\\"recharge\\":\\"Recharge 6\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 10, each creature in a 15-foot Cone. *Failure:*  The target has the Blinded condition until the end of the mephit's next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Sleep (1/Day)\\",\\"text\\":\\"The mephit casts the *Sleep* spell, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 10). - **At Will:** - **1/Day Each:** *Sleep*\\"}]"
---

# Dust Mephit
*Small, Elemental, Neutral Evil*

**AC** 12
**HP** 17 (5d6)
**Speed** 30 ft., fly 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 5 | 14 | 10 | 9 | 11 | 10 |

CR 1/2, PB +2, XP 100

## Traits

**Death Burst**
The mephit explodes when it dies. *Dexterity Saving Throw*: DC 10, each creature in a 5-foot Emanation originating from the mephit. *Failure:*  5 (2d4) Bludgeoning damage. *Success:*  Half damage.

## Actions

**Claw**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Slashing damage.

**Blinding Breath (Recharge 6)**
*Dexterity Saving Throw*: DC 10, each creature in a 15-foot Cone. *Failure:*  The target has the Blinded condition until the end of the mephit's next turn.

**Sleep (1/Day)**
The mephit casts the *Sleep* spell, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 10). - **At Will:** - **1/Day Each:** *Sleep*
`,
      "earth-elemental.md": `---
smType: creature
name: "Earth Elemental"
size: "Large"
type: "Elemental"
alignment: "Neutral Neutral"
ac: "17"
hp: "147"
hit_dice: "14d10 + 70"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"burrow\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":20},{\\"ability\\":\\"dex\\",\\"score\\":8},{\\"ability\\":\\"con\\",\\"score\\":20},{\\"ability\\":\\"int\\",\\"score\\":5},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Earth Glide\\",\\"text\\":\\"The elemental can burrow through nonmagical, unworked earth and stone. While doing so, the elemental doesn't disturb the material it moves through.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Siege Monster\\",\\"text\\":\\"The elemental deals double damage to objects and structures.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The elemental makes two attacks, using Slam or Rock Launch in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Slam\\",\\"text\\":\\"*Melee Attack Roll:* +8, reach 10 ft. 14 (2d8 + 5) Bludgeoning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rock Launch\\",\\"text\\":\\"*Ranged Attack Roll:* +8, range 60 ft. 8 (1d6 + 5) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.\\"}]"
---

# Earth Elemental
*Large, Elemental, Neutral Neutral*

**AC** 17
**HP** 147 (14d10 + 70)
**Speed** 30 ft., burrow 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 20 | 8 | 20 | 5 | 10 | 5 |

CR 5, PB +3, XP 1800

## Traits

**Earth Glide**
The elemental can burrow through nonmagical, unworked earth and stone. While doing so, the elemental doesn't disturb the material it moves through.

**Siege Monster**
The elemental deals double damage to objects and structures.

## Actions

**Multiattack**
The elemental makes two attacks, using Slam or Rock Launch in any combination.

**Slam**
*Melee Attack Roll:* +8, reach 10 ft. 14 (2d8 + 5) Bludgeoning damage.

**Rock Launch**
*Ranged Attack Roll:* +8, range 60 ft. 8 (1d6 + 5) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.
`,
      "efreeti.md": `---
smType: creature
name: "Efreeti"
size: "Large"
type: "Elemental"
type_tags: ["Genie"]
alignment: "Neutral Neutral"
ac: "17"
hp: "212"
hit_dice: "17d10 + 119"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\",\\"hover\\":true}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":22},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":24},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":19}]"
pb: "+4"
saves_json: "[{\\"ability\\":\\"wis\\",\\"bonus\\":6},{\\"ability\\":\\"cha\\",\\"bonus\\":8}]"
cr: "11"
xp: "7200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Elemental Restoration\\",\\"text\\":\\"If the efreeti dies outside the Elemental Plane of Fire, its body dissolves into ash, and it gains a new body in 1d4 days, reviving with all its Hit Points somewhere on the Plane of Fire.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The efreeti has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Wishes\\",\\"text\\":\\"The efreeti has a 30 percent chance of knowing the *Wish* spell. If the efreeti knows it, the efreeti can cast it only on behalf of a non-genie creature who communicates a wish in a way the efreeti can understand. If the efreeti casts the spell for the creature, the efreeti suffers none of the spell's stress. Once the efreeti has cast it three times, the efreeti can't do so again for 365 days.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The efreeti makes three attacks, using Heated Blade or Hurl Flame in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Heated Blade\\",\\"text\\":\\"*Melee Attack Roll:* +10, reach 5 ft. 13 (2d6 + 6) Slashing damage plus 13 (2d12) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Hurl Flame\\",\\"text\\":\\"*Ranged Attack Roll:* +8, range 120 ft. 24 (7d6) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The efreeti casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 16): - **At Will:** *Detect Magic*, *Elementalism* - **1e/Day Each:** *Gaseous Form*, *Invisibility*, *Major Image*, *Plane Shift*, *Tongues*, *Wall of Fire*\\"}]"
---

# Efreeti
*Large, Elemental, Neutral Neutral*

**AC** 17
**HP** 212 (17d10 + 119)
**Speed** 40 ft., fly 60 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 22 | 12 | 24 | 16 | 15 | 19 |

CR 11, PB +4, XP 7200

## Traits

**Elemental Restoration**
If the efreeti dies outside the Elemental Plane of Fire, its body dissolves into ash, and it gains a new body in 1d4 days, reviving with all its Hit Points somewhere on the Plane of Fire.

**Magic Resistance**
The efreeti has Advantage on saving throws against spells and other magical effects.

**Wishes**
The efreeti has a 30 percent chance of knowing the *Wish* spell. If the efreeti knows it, the efreeti can cast it only on behalf of a non-genie creature who communicates a wish in a way the efreeti can understand. If the efreeti casts the spell for the creature, the efreeti suffers none of the spell's stress. Once the efreeti has cast it three times, the efreeti can't do so again for 365 days.

## Actions

**Multiattack**
The efreeti makes three attacks, using Heated Blade or Hurl Flame in any combination.

**Heated Blade**
*Melee Attack Roll:* +10, reach 5 ft. 13 (2d6 + 6) Slashing damage plus 13 (2d12) Fire damage.

**Hurl Flame**
*Ranged Attack Roll:* +8, range 120 ft. 24 (7d6) Fire damage.

**Spellcasting**
The efreeti casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 16): - **At Will:** *Detect Magic*, *Elementalism* - **1e/Day Each:** *Gaseous Form*, *Invisibility*, *Major Image*, *Plane Shift*, *Tongues*, *Wall of Fire*
`,
      "erinyes.md": `---
smType: creature
name: "Erinyes"
size: "Medium"
type: "Fiend"
type_tags: ["Devil"]
alignment: "Lawful Evil"
ac: "18"
hp: "178"
hit_dice: "21d8 + 84"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":14},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":18}]"
pb: "+4"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":7},{\\"ability\\":\\"con\\",\\"bonus\\":8},{\\"ability\\":\\"cha\\",\\"bonus\\":8}]"
cr: "12"
xp: "8400"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Diabolical Restoration\\",\\"text\\":\\"If the erinyes dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The erinyes has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Rope\\",\\"text\\":\\"The erinyes has a magic rope. While bearing it, the erinyes can use the Entangling Rope action. The rope has AC 20, HP 90, and Immunity to Poison and Psychic damage. The rope turns to dust if reduced to 0 Hit Points, if it is 5+ feet away from the erinyes for 1 hour or more, or if the erinyes dies. If the rope is damaged or destroyed, the erinyes can fully restore it when finishing a Short Rest|XPHB|Short or Long Rest.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The erinyes makes three Withering Sword attacks and can use Entangling Rope.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Withering Sword\\",\\"text\\":\\"*Melee Attack Roll:* +8, reach 5 ft. 13 (2d8 + 4) Slashing damage plus 11 (2d10) Necrotic damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Entangling Rope (Requires Magic Rope)\\",\\"text\\":\\"*Strength Saving Throw*: DC 16, one creature the erinyes can see within 120 feet. *Failure:*  14 (4d6) Force damage, and the target has the Restrained condition until the rope is destroyed, the erinyes uses a Bonus Action to release the target, or the erinyes uses Entangling Rope again.\\"}]"
---

# Erinyes
*Medium, Fiend, Lawful Evil*

**AC** 18
**HP** 178 (21d8 + 84)
**Speed** 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 16 | 18 | 14 | 14 | 18 |

CR 12, PB +4, XP 8400

## Traits

**Diabolical Restoration**
If the erinyes dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.

**Magic Resistance**
The erinyes has Advantage on saving throws against spells and other magical effects.

**Magic Rope**
The erinyes has a magic rope. While bearing it, the erinyes can use the Entangling Rope action. The rope has AC 20, HP 90, and Immunity to Poison and Psychic damage. The rope turns to dust if reduced to 0 Hit Points, if it is 5+ feet away from the erinyes for 1 hour or more, or if the erinyes dies. If the rope is damaged or destroyed, the erinyes can fully restore it when finishing a Short Rest|XPHB|Short or Long Rest.

## Actions

**Multiattack**
The erinyes makes three Withering Sword attacks and can use Entangling Rope.

**Withering Sword**
*Melee Attack Roll:* +8, reach 5 ft. 13 (2d8 + 4) Slashing damage plus 11 (2d10) Necrotic damage.

**Entangling Rope (Requires Magic Rope)**
*Strength Saving Throw*: DC 16, one creature the erinyes can see within 120 feet. *Failure:*  14 (4d6) Force damage, and the target has the Restrained condition until the rope is destroyed, the erinyes uses a Bonus Action to release the target, or the erinyes uses Entangling Rope again.
`,
      "ettercap.md": `---
smType: creature
name: "Ettercap"
size: "Medium"
type: "Monstrosity"
alignment: "Neutral Evil"
ac: "13"
hp: "44"
hit_dice: "8d8 + 8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":14},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":7},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Spider Climb\\",\\"text\\":\\"The ettercap can climb difficult surfaces, including along ceilings, without needing to make an ability check.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Web Walker\\",\\"text\\":\\"The ettercap ignores movement restrictions caused by webs, and the ettercap knows the location of any other creature in contact with the same web.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The ettercap makes one Bite attack and one Claw attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 2 (1d4) Poison damage, and the target has the Poisoned condition until the start of the ettercap's next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 7 (2d4 + 2) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Web Strand (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 12, one Large or smaller creature the ettercap can see within 30 feet. *Failure:*  The target has the Restrained condition until the web is destroyed (AC 10; HP 5; Vulnerability to Fire damage; Immunity to Bludgeoning, Poison, and Psychic damage).\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Reel\\",\\"text\\":\\"The ettercap pulls one creature within 30 feet of itself that is Restrained by its Web Strand up to 25 feet straight toward itself.\\"}]"
---

# Ettercap
*Medium, Monstrosity, Neutral Evil*

**AC** 13
**HP** 44 (8d8 + 8)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 14 | 15 | 13 | 7 | 12 | 8 |

CR 2, PB +2, XP 450

## Traits

**Spider Climb**
The ettercap can climb difficult surfaces, including along ceilings, without needing to make an ability check.

**Web Walker**
The ettercap ignores movement restrictions caused by webs, and the ettercap knows the location of any other creature in contact with the same web.

## Actions

**Multiattack**
The ettercap makes one Bite attack and one Claw attack.

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 2 (1d4) Poison damage, and the target has the Poisoned condition until the start of the ettercap's next turn.

**Claw**
*Melee Attack Roll:* +4, reach 5 ft. 7 (2d4 + 2) Slashing damage.

**Web Strand (Recharge 5-6)**
*Dexterity Saving Throw*: DC 12, one Large or smaller creature the ettercap can see within 30 feet. *Failure:*  The target has the Restrained condition until the web is destroyed (AC 10; HP 5; Vulnerability to Fire damage; Immunity to Bludgeoning, Poison, and Psychic damage).

## Bonus Actions

**Reel**
The ettercap pulls one creature within 30 feet of itself that is Restrained by its Web Strand up to 25 feet straight toward itself.
`,
      "ettin.md": `---
smType: creature
name: "Ettin"
size: "Large"
type: "Giant"
alignment: "Chaotic Evil"
ac: "12"
hp: "85"
hit_dice: "10d10 + 30"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":21},{\\"ability\\":\\"dex\\",\\"score\\":8},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "4"
xp: "1100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The ettin makes one Battleaxe attack and one Morningstar attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Battleaxe\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 14 (2d8 + 5) Slashing damage. If the target is a Large or smaller creature, it has the Prone condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Morningstar\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 14 (2d8 + 5) Piercing damage, and the target has Disadvantage on the next attack roll it makes before the end of its next turn.\\"}]"
---

# Ettin
*Large, Giant, Chaotic Evil*

**AC** 12
**HP** 85 (10d10 + 30)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 21 | 8 | 17 | 6 | 10 | 8 |

CR 4, PB +2, XP 1100

## Actions

**Multiattack**
The ettin makes one Battleaxe attack and one Morningstar attack.

**Battleaxe**
*Melee Attack Roll:* +7, reach 5 ft. 14 (2d8 + 5) Slashing damage. If the target is a Large or smaller creature, it has the Prone condition.

**Morningstar**
*Melee Attack Roll:* +7, reach 5 ft. 14 (2d8 + 5) Piercing damage, and the target has Disadvantage on the next attack roll it makes before the end of its next turn.
`,
      "fire-elemental.md": `---
smType: creature
name: "Fire Elemental"
size: "Large"
type: "Elemental"
alignment: "Neutral Neutral"
ac: "13"
hp: "93"
hit_dice: "11d10 + 33"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Fire Aura\\",\\"text\\":\\"At the end of each of the elemental's turns, each creature in a 10-foot Emanation originating from the elemental takes 5 (1d10) Fire damage. Creatures and flammable objects in the Emanation start Hitazard burning.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Fire Form\\",\\"text\\":\\"The elemental can move through a space as narrow as 1 inch without expending extra movement to do so, and it can enter a creature's space and stop there. The first time it enters a creature's space on a turn, that creature takes 5 (1d10) Fire damage.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Illumination\\",\\"text\\":\\"The elemental sheds Bright Light in a 30-foot radius and Dim Light for an additional 30 feet.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Water Susceptibility\\",\\"text\\":\\"The elemental takes 3 (1d6) Cold damage for every 5 feet the elemental moves in water or for every gallon of water splashed on it.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The elemental makes two Burn attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Burn\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 10 (2d6 + 3) Fire damage. If the target is a creature or a flammable object, it starts burning.\\"}]"
---

# Fire Elemental
*Large, Elemental, Neutral Neutral*

**AC** 13
**HP** 93 (11d10 + 33)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 17 | 16 | 6 | 10 | 7 |

CR 5, PB +3, XP 1800

## Traits

**Fire Aura**
At the end of each of the elemental's turns, each creature in a 10-foot Emanation originating from the elemental takes 5 (1d10) Fire damage. Creatures and flammable objects in the Emanation start Hitazard burning.

**Fire Form**
The elemental can move through a space as narrow as 1 inch without expending extra movement to do so, and it can enter a creature's space and stop there. The first time it enters a creature's space on a turn, that creature takes 5 (1d10) Fire damage.

**Illumination**
The elemental sheds Bright Light in a 30-foot radius and Dim Light for an additional 30 feet.

**Water Susceptibility**
The elemental takes 3 (1d6) Cold damage for every 5 feet the elemental moves in water or for every gallon of water splashed on it.

## Actions

**Multiattack**
The elemental makes two Burn attacks.

**Burn**
*Melee Attack Roll:* +6, reach 5 ft. 10 (2d6 + 3) Fire damage. If the target is a creature or a flammable object, it starts burning.
`,
      "fire-giant.md": `---
smType: creature
name: "Fire Giant"
size: "Huge"
type: "Giant"
alignment: "Lawful Evil"
ac: "18"
hp: "162"
hit_dice: "13d12 + 78"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":25},{\\"ability\\":\\"dex\\",\\"score\\":9},{\\"ability\\":\\"con\\",\\"score\\":23},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":13}]"
pb: "+4"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":3},{\\"ability\\":\\"con\\",\\"bonus\\":10},{\\"ability\\":\\"cha\\",\\"bonus\\":5}]"
cr: "9"
xp: "5000"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The giant makes two attacks, using Flame Sword or Hammer Throw in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Flame Sword\\",\\"text\\":\\"*Melee Attack Roll:* +11, reach 10 ft. 21 (4d6 + 7) Slashing damage plus 10 (3d6) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Hammer Throw\\",\\"text\\":\\"*Ranged Attack Roll:* +11, range 60/240 ft. 23 (3d10 + 7) Bludgeoning damage plus 4 (1d8) Fire damage, and the target is pushed up to 15 feet straight away from the giant and has Disadvantage on the next attack roll it makes before the end of its next turn.\\"}]"
---

# Fire Giant
*Huge, Giant, Lawful Evil*

**AC** 18
**HP** 162 (13d12 + 78)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 25 | 9 | 23 | 10 | 14 | 13 |

CR 9, PB +4, XP 5000

## Actions

**Multiattack**
The giant makes two attacks, using Flame Sword or Hammer Throw in any combination.

**Flame Sword**
*Melee Attack Roll:* +11, reach 10 ft. 21 (4d6 + 7) Slashing damage plus 10 (3d6) Fire damage.

**Hammer Throw**
*Ranged Attack Roll:* +11, range 60/240 ft. 23 (3d10 + 7) Bludgeoning damage plus 4 (1d8) Fire damage, and the target is pushed up to 15 feet straight away from the giant and has Disadvantage on the next attack roll it makes before the end of its next turn.
`,
      "flesh-golem.md": `---
smType: creature
name: "Flesh Golem"
size: "Medium"
type: "Construct"
alignment: "Neutral Neutral"
ac: "9"
hp: "127"
hit_dice: "15d8 + 60"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":9},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Aversion to Fire\\",\\"text\\":\\"If the golem takes Fire damage, it has Disadvantage on attack rolls and ability checks until the end of its next turn.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Berserk\\",\\"text\\":\\"Whenever the golem starts its turn Bloodied, roll 1d6. On a 6, the golem goes berserk. On each of its turns while berserk, the golem attacks the nearest creature it can see. If no creature is near enough to move to and attack, the golem attacks an object. Once the golem goes berserk, it remains so until it is destroyed or it is no longer Bloodied. The golem's creator, if within 60 feet of the berserk golem, can try to calm it by taking an action to make a DC 15 Charisma (Persuasion) check; the golem must be able to hear its creator. If this check succeeds, the golem ceases being berserk until the start of its next turn, at which point it resumes rolling for the Berserk trait again if it is still Bloodied.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Immutable Form\\",\\"text\\":\\"The golem can't shape-shift.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Lightning Absorption\\",\\"text\\":\\"Whenever the golem is subjected to Lightning damage, it regains a number of Hit Points equal to the Lightning damage dealt.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The golem has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The golem makes two Slam attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Slam\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage plus 4 (1d8) Lightning damage.\\"}]"
---

# Flesh Golem
*Medium, Construct, Neutral Neutral*

**AC** 9
**HP** 127 (15d8 + 60)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 9 | 18 | 6 | 10 | 5 |

CR 5, PB +3, XP 1800

## Traits

**Aversion to Fire**
If the golem takes Fire damage, it has Disadvantage on attack rolls and ability checks until the end of its next turn.

**Berserk**
Whenever the golem starts its turn Bloodied, roll 1d6. On a 6, the golem goes berserk. On each of its turns while berserk, the golem attacks the nearest creature it can see. If no creature is near enough to move to and attack, the golem attacks an object. Once the golem goes berserk, it remains so until it is destroyed or it is no longer Bloodied. The golem's creator, if within 60 feet of the berserk golem, can try to calm it by taking an action to make a DC 15 Charisma (Persuasion) check; the golem must be able to hear its creator. If this check succeeds, the golem ceases being berserk until the start of its next turn, at which point it resumes rolling for the Berserk trait again if it is still Bloodied.

**Immutable Form**
The golem can't shape-shift.

**Lightning Absorption**
Whenever the golem is subjected to Lightning damage, it regains a number of Hit Points equal to the Lightning damage dealt.

**Magic Resistance**
The golem has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The golem makes two Slam attacks.

**Slam**
*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage plus 4 (1d8) Lightning damage.
`,
      "frost-giant.md": `---
smType: creature
name: "Frost Giant"
size: "Huge"
type: "Giant"
alignment: "Neutral Evil"
ac: "15"
hp: "149"
hit_dice: "13d12 + 65"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":23},{\\"ability\\":\\"dex\\",\\"score\\":9},{\\"ability\\":\\"con\\",\\"score\\":21},{\\"ability\\":\\"int\\",\\"score\\":9},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":12}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"con\\",\\"bonus\\":8},{\\"ability\\":\\"wis\\",\\"bonus\\":3},{\\"ability\\":\\"cha\\",\\"bonus\\":4}]"
cr: "8"
xp: "3900"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The giant makes two attacks, using Frost Axe or Great Bow in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Frost Axe\\",\\"text\\":\\"*Melee Attack Roll:* +9, reach 10 ft. 19 (2d12 + 6) Slashing damage plus 9 (2d8) Cold damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Great Bow\\",\\"text\\":\\"*Ranged Attack Roll:* +9, range 150/600 ft. 17 (2d10 + 6) Piercing damage plus 7 (2d6) Cold damage, and the target's Speed decreases by 10 feet until the end of its next turn.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"War Cry (Recharge 5-6)\\",\\"text\\":\\"The giant or one creature of its choice that can see or hear it gains 16 (2d10 + 5) Temporary Hit Points and has Advantage on attack rolls until the start of the giant's next turn.\\"}]"
---

# Frost Giant
*Huge, Giant, Neutral Evil*

**AC** 15
**HP** 149 (13d12 + 65)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 23 | 9 | 21 | 9 | 10 | 12 |

CR 8, PB +3, XP 3900

## Actions

**Multiattack**
The giant makes two attacks, using Frost Axe or Great Bow in any combination.

**Frost Axe**
*Melee Attack Roll:* +9, reach 10 ft. 19 (2d12 + 6) Slashing damage plus 9 (2d8) Cold damage.

**Great Bow**
*Ranged Attack Roll:* +9, range 150/600 ft. 17 (2d10 + 6) Piercing damage plus 7 (2d6) Cold damage, and the target's Speed decreases by 10 feet until the end of its next turn.

## Bonus Actions

**War Cry (Recharge 5-6)**
The giant or one creature of its choice that can see or hear it gains 16 (2d10 + 5) Temporary Hit Points and has Advantage on attack rolls until the start of the giant's next turn.
`,
      "gargoyle.md": `---
smType: creature
name: "Gargoyle"
size: "Medium"
type: "Elemental"
alignment: "Chaotic Evil"
ac: "15"
hp: "67"
hit_dice: "9d8 + 27"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Flyby\\",\\"text\\":\\"The gargoyle doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The gargoyle makes two Claw attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 7 (2d4 + 2) Slashing damage.\\"}]"
---

# Gargoyle
*Medium, Elemental, Chaotic Evil*

**AC** 15
**HP** 67 (9d8 + 27)
**Speed** 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 11 | 16 | 6 | 11 | 7 |

CR 2, PB +2, XP 450

## Traits

**Flyby**
The gargoyle doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.

## Actions

**Multiattack**
The gargoyle makes two Claw attacks.

**Claw**
*Melee Attack Roll:* +4, reach 5 ft. 7 (2d4 + 2) Slashing damage.
`,
      "gelatinous-cube.md": `---
smType: creature
name: "Gelatinous Cube"
size: "Large"
type: "Ooze"
alignment: "Unaligned"
ac: "6"
hp: "63"
hit_dice: "6d10 + 30"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"15 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":14},{\\"ability\\":\\"dex\\",\\"score\\":3},{\\"ability\\":\\"con\\",\\"score\\":20},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":6},{\\"ability\\":\\"cha\\",\\"score\\":1}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Ooze Cube\\",\\"text\\":\\"The cube fills its entire space and is transparent. Other creatures can enter that space, but a creature that does so is subjected to the cube's Engulf and has Disadvantage on the saving throw. Creatures inside the cube have Cover|XPHB|Total Cover, and the cube can hold one Large creature or up to four Medium or Small creatures inside itself at a time. As an action, a creature within 5 feet of the cube can pull a creature or an object out of the cube by succeeding on a DC 12 Strength (Athletics) check, and the puller takes 10 (3d6) Acid damage.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Transparent\\",\\"text\\":\\"Even when the cube is in plain sight, a creature must succeed on a DC 15 Wisdom (Perception) check to notice the cube if the creature hasn't witnessed the cube move or otherwise act.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Pseudopod\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 12 (3d6 + 2) Acid damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Engulf\\",\\"text\\":\\"The cube moves up to its Speed without provoking Opportunity Attacks. The cube can move through the spaces of Large or smaller creatures if it has room inside itself to contain them (see the Ooze Cube [Area of Effect]|XPHB|Cube trait). *Dexterity Saving Throw*: DC 12, each creature whose space the cube enters for the first time during this move. *Failure:*  10 (3d6) Acid damage, and the target is engulfed. An engulfed target is suffocating, can't cast spells with a Verbal component, has the Restrained condition, and takes 10 (3d6) Acid damage at the start of each of the cube's turns. When the cube moves, the engulfed target moves with it. An engulfed target can try to escape by taking an action to make a DC 12 Strength (Athletics) check. On a successful check, the target escapes and enters the nearest unoccupied space. *Success:*  Half damage, and the target moves to an unoccupied space within 5 feet of the cube. If there is no unoccupied space, the target fails the save instead.\\"}]"
---

# Gelatinous Cube
*Large, Ooze, Unaligned*

**AC** 6
**HP** 63 (6d10 + 30)
**Speed** 15 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 14 | 3 | 20 | 1 | 6 | 1 |

CR 2, PB +2, XP 450

## Traits

**Ooze Cube**
The cube fills its entire space and is transparent. Other creatures can enter that space, but a creature that does so is subjected to the cube's Engulf and has Disadvantage on the saving throw. Creatures inside the cube have Cover|XPHB|Total Cover, and the cube can hold one Large creature or up to four Medium or Small creatures inside itself at a time. As an action, a creature within 5 feet of the cube can pull a creature or an object out of the cube by succeeding on a DC 12 Strength (Athletics) check, and the puller takes 10 (3d6) Acid damage.

**Transparent**
Even when the cube is in plain sight, a creature must succeed on a DC 15 Wisdom (Perception) check to notice the cube if the creature hasn't witnessed the cube move or otherwise act.

## Actions

**Pseudopod**
*Melee Attack Roll:* +4, reach 5 ft. 12 (3d6 + 2) Acid damage.

**Engulf**
The cube moves up to its Speed without provoking Opportunity Attacks. The cube can move through the spaces of Large or smaller creatures if it has room inside itself to contain them (see the Ooze Cube [Area of Effect]|XPHB|Cube trait). *Dexterity Saving Throw*: DC 12, each creature whose space the cube enters for the first time during this move. *Failure:*  10 (3d6) Acid damage, and the target is engulfed. An engulfed target is suffocating, can't cast spells with a Verbal component, has the Restrained condition, and takes 10 (3d6) Acid damage at the start of each of the cube's turns. When the cube moves, the engulfed target moves with it. An engulfed target can try to escape by taking an action to make a DC 12 Strength (Athletics) check. On a successful check, the target escapes and enters the nearest unoccupied space. *Success:*  Half damage, and the target moves to an unoccupied space within 5 feet of the cube. If there is no unoccupied space, the target fails the save instead.
`,
      "ghast.md": `---
smType: creature
name: "Ghast"
size: "Medium"
type: "Undead"
alignment: "Chaotic Evil"
ac: "13"
hp: "36"
hit_dice: "8d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"wis\\",\\"bonus\\":2}]"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Stench\\",\\"text\\":\\"*Constitution Saving Throw*: DC 10, any creature that starts its turn in a 5-foot Emanation originating from the ghast. *Failure:*  The target has the Poisoned condition until the start of its next turn. *Success:*  The target is immune to this ghast's Stench for 24 hours.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage plus 9 (2d8) Necrotic damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage. If the target is a non-Undead creature, it is subjected to the following effect. *Constitution Saving Throw*: DC 10. *Failure:*  The target has the Paralyzed condition until the end of its next turn.\\"}]"
---

# Ghast
*Medium, Undead, Chaotic Evil*

**AC** 13
**HP** 36 (8d8)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 17 | 10 | 11 | 10 | 8 |

CR 2, PB +2, XP 450

## Traits

**Stench**
*Constitution Saving Throw*: DC 10, any creature that starts its turn in a 5-foot Emanation originating from the ghast. *Failure:*  The target has the Poisoned condition until the start of its next turn. *Success:*  The target is immune to this ghast's Stench for 24 hours.

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage plus 9 (2d8) Necrotic damage.

**Claw**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage. If the target is a non-Undead creature, it is subjected to the following effect. *Constitution Saving Throw*: DC 10. *Failure:*  The target has the Paralyzed condition until the end of its next turn.
`,
      "ghost.md": `---
smType: creature
name: "Ghost"
size: "Medium"
type: "Undead"
alignment: "Neutral Neutral"
ac: "11"
hp: "45"
hit_dice: "10d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"},\\"fly\\":{\\"distance\\":\\"40 ft.\\",\\"hover\\":true}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":7},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":17}]"
pb: "+2"
cr: "4"
xp: "1100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Ethereal Sight\\",\\"text\\":\\"The ghost can see 60 feet into the Ethereal Plane when it is on the Material Plane.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Incorporeal Movement\\",\\"text\\":\\"The ghost can move through other creatures and objects as if they were Difficult Terrain. It takes 5 (1d10) Force damage if it ends its turn inside an object.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The ghost makes two Withering Touch attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Withering Touch\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 19 (3d10 + 3) Necrotic damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Horrific Visage\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 13, each creature in a 60-foot Cone that can see the ghost and isn't an Undead. *Failure:*  10 (2d6 + 3) Psychic damage, and the target has the Frightened condition until the start of the ghost's next turn. *Success:*  The target is immune to this ghost's Horrific Visage for 24 hours.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Possession\\",\\"recharge\\":\\"Recharge 6\\",\\"text\\":\\"*Charisma Saving Throw*: DC 13, one Humanoid the ghost can see within 5 feet. *Failure:*  The target is possessed by the ghost; the ghost disappears, and the target has the Incapacitated condition and loses control of its body. The ghost now controls the body, but the target retains awareness. The ghost can't be targeted by any attack, spell, or other effect, except ones that specifically target Undead. The ghost's game statistics are the same, except it uses the possessed target's Speed, as well as the target's Strength, Dexterity, and Constitution modifiers. The possession lasts until the body drops to 0 Hit Points or the ghost leaves as a Bonus Action. When the possession ends, the ghost appears in an unoccupied space within 5 feet of the target, and the target is immune to this ghost's Possession for 24 hours. *Success:*  The target is immune to this ghost's Possession for 24 hours.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Etherealness\\",\\"text\\":\\"The ghost casts the *Etherealness* spell, requiring no spell components and using Charisma as the spellcasting ability. The ghost is visible on the Material Plane while on the Border Ethereal and vice versa, but it can't affect or be affected by anything on the other plane. - **At Will:** *Etherealness*\\"}]"
---

# Ghost
*Medium, Undead, Neutral Neutral*

**AC** 11
**HP** 45 (10d8)
**Speed** 5 ft., fly 40 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 7 | 13 | 10 | 10 | 12 | 17 |

CR 4, PB +2, XP 1100

## Traits

**Ethereal Sight**
The ghost can see 60 feet into the Ethereal Plane when it is on the Material Plane.

**Incorporeal Movement**
The ghost can move through other creatures and objects as if they were Difficult Terrain. It takes 5 (1d10) Force damage if it ends its turn inside an object.

## Actions

**Multiattack**
The ghost makes two Withering Touch attacks.

**Withering Touch**
*Melee Attack Roll:* +5, reach 5 ft. 19 (3d10 + 3) Necrotic damage.

**Horrific Visage**
*Wisdom Saving Throw*: DC 13, each creature in a 60-foot Cone that can see the ghost and isn't an Undead. *Failure:*  10 (2d6 + 3) Psychic damage, and the target has the Frightened condition until the start of the ghost's next turn. *Success:*  The target is immune to this ghost's Horrific Visage for 24 hours.

**Possession (Recharge 6)**
*Charisma Saving Throw*: DC 13, one Humanoid the ghost can see within 5 feet. *Failure:*  The target is possessed by the ghost; the ghost disappears, and the target has the Incapacitated condition and loses control of its body. The ghost now controls the body, but the target retains awareness. The ghost can't be targeted by any attack, spell, or other effect, except ones that specifically target Undead. The ghost's game statistics are the same, except it uses the possessed target's Speed, as well as the target's Strength, Dexterity, and Constitution modifiers. The possession lasts until the body drops to 0 Hit Points or the ghost leaves as a Bonus Action. When the possession ends, the ghost appears in an unoccupied space within 5 feet of the target, and the target is immune to this ghost's Possession for 24 hours. *Success:*  The target is immune to this ghost's Possession for 24 hours.

**Etherealness**
The ghost casts the *Etherealness* spell, requiring no spell components and using Charisma as the spellcasting ability. The ghost is visible on the Material Plane while on the Border Ethereal and vice versa, but it can't affect or be affected by anything on the other plane. - **At Will:** *Etherealness*
`,
      "ghoul.md": `---
smType: creature
name: "Ghoul"
size: "Medium"
type: "Undead"
alignment: "Chaotic Evil"
ac: "12"
hp: "22"
hit_dice: "5d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":13},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":7},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The ghoul makes two Bite attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 3 (1d6) Necrotic damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Slashing damage. If the target is a creature that isn't an Undead or elf, it is subjected to the following effect. *Constitution Saving Throw*: DC 10. *Failure:*  The target has the Paralyzed condition until the end of its next turn.\\"}]"
---

# Ghoul
*Medium, Undead, Chaotic Evil*

**AC** 12
**HP** 22 (5d8)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 13 | 15 | 10 | 7 | 10 | 6 |

CR 1, PB +2, XP 200

## Actions

**Multiattack**
The ghoul makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 3 (1d6) Necrotic damage.

**Claw**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Slashing damage. If the target is a creature that isn't an Undead or elf, it is subjected to the following effect. *Constitution Saving Throw*: DC 10. *Failure:*  The target has the Paralyzed condition until the end of its next turn.
`,
      "gibbering-mouther.md": `---
smType: creature
name: "Gibbering Mouther"
size: "Medium"
type: "Aberration"
alignment: "Chaotic Neutral"
ac: "9"
hp: "52"
hit_dice: "7d8 + 21"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"swim\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":8},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Aberrant Ground\\",\\"text\\":\\"The ground in a 10-foot Emanation originating from the mouther is Difficult Terrain.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Gibbering\\",\\"text\\":\\"The mouther babbles incoherently while it doesn't have the Incapacitated condition. *Wisdom Saving Throw*: DC 10, any creature that starts its turn within 20 feet of the mouther while it is babbling. *Failure:*  The target rolls 1d8 to determine what it does during the current turn: - **1-4**: The target does nothing. - **5-6**: The target takes no action or Bonus Action and uses all its movement to move in a random direction. - **7-8**: The target makes a melee attack against a randomly determined creature within its reach or does nothing if it can't make such an attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +2, reach 5 ft. 7 (2d6) Piercing damage. If the target is a Medium or smaller creature, it has the Prone condition. The target dies if it is reduced to 0 Hit Points by this attack. Its body is then absorbed into the mouther, leaving only equipment behind.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Blinding Spittle (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 10, each creature in a 10-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point within 30 feet. *Failure:*  7 (2d6) Radiant damage, and the target has the Blinded condition until the end of the mouther's next turn.\\"}]"
---

# Gibbering Mouther
*Medium, Aberration, Chaotic Neutral*

**AC** 9
**HP** 52 (7d8 + 21)
**Speed** 20 ft., swim 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 8 | 16 | 3 | 10 | 6 |

CR 2, PB +2, XP 450

## Traits

**Aberrant Ground**
The ground in a 10-foot Emanation originating from the mouther is Difficult Terrain.

**Gibbering**
The mouther babbles incoherently while it doesn't have the Incapacitated condition. *Wisdom Saving Throw*: DC 10, any creature that starts its turn within 20 feet of the mouther while it is babbling. *Failure:*  The target rolls 1d8 to determine what it does during the current turn: - **1-4**: The target does nothing. - **5-6**: The target takes no action or Bonus Action and uses all its movement to move in a random direction. - **7-8**: The target makes a melee attack against a randomly determined creature within its reach or does nothing if it can't make such an attack.

## Actions

**Bite**
*Melee Attack Roll:* +2, reach 5 ft. 7 (2d6) Piercing damage. If the target is a Medium or smaller creature, it has the Prone condition. The target dies if it is reduced to 0 Hit Points by this attack. Its body is then absorbed into the mouther, leaving only equipment behind.

**Blinding Spittle (Recharge 5-6)**
*Dexterity Saving Throw*: DC 10, each creature in a 10-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point within 30 feet. *Failure:*  7 (2d6) Radiant damage, and the target has the Blinded condition until the end of the mouther's next turn.
`,
      "glabrezu.md": `---
smType: creature
name: "Glabrezu"
size: "Large"
type: "Fiend"
type_tags: ["Demon"]
alignment: "Chaotic Evil"
ac: "17"
hp: "189"
hit_dice: "18d10 + 90"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":20},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":21},{\\"ability\\":\\"int\\",\\"score\\":19},{\\"ability\\":\\"wis\\",\\"score\\":17},{\\"ability\\":\\"cha\\",\\"score\\":16}]"
pb: "+4"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":9},{\\"ability\\":\\"con\\",\\"bonus\\":9},{\\"ability\\":\\"wis\\",\\"bonus\\":7},{\\"ability\\":\\"cha\\",\\"bonus\\":7}]"
cr: "9"
xp: "5000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Demonic Restoration\\",\\"text\\":\\"If the glabrezu dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The glabrezu has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The glabrezu makes two Pincer attacks and uses Pummel or Spellcasting.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Pincer\\",\\"text\\":\\"*Melee Attack Roll:* +9, reach 10 ft. 16 (2d10 + 5) Slashing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 15) from one of two pincers.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Pummel\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 17, one creature Grappled by the glabrezu. *Failure:*  15 (3d6 + 5) Bludgeoning damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The glabrezu casts one of the following spells, requiring no Material components and using Intelligence as the spellcasting ability (spell save DC 16): - **At Will:** *Darkness*, *Detect Magic*, *Dispel Magic* - **1e/Day Each:** *Confusion*, *Fly*, *Power Word Stun*\\"}]"
---

# Glabrezu
*Large, Fiend, Chaotic Evil*

**AC** 17
**HP** 189 (18d10 + 90)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 20 | 15 | 21 | 19 | 17 | 16 |

CR 9, PB +4, XP 5000

## Traits

**Demonic Restoration**
If the glabrezu dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.

**Magic Resistance**
The glabrezu has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The glabrezu makes two Pincer attacks and uses Pummel or Spellcasting.

**Pincer**
*Melee Attack Roll:* +9, reach 10 ft. 16 (2d10 + 5) Slashing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 15) from one of two pincers.

**Pummel**
*Dexterity Saving Throw*: DC 17, one creature Grappled by the glabrezu. *Failure:*  15 (3d6 + 5) Bludgeoning damage. *Success:*  Half damage.

**Spellcasting**
The glabrezu casts one of the following spells, requiring no Material components and using Intelligence as the spellcasting ability (spell save DC 16): - **At Will:** *Darkness*, *Detect Magic*, *Dispel Magic* - **1e/Day Each:** *Confusion*, *Fly*, *Power Word Stun*
`,
      "gladiator.md": `---
smType: creature
name: "Gladiator"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "16"
hp: "112"
hit_dice: "15d8 + 45"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":15}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":7},{\\"ability\\":\\"dex\\",\\"bonus\\":5},{\\"ability\\":\\"con\\",\\"bonus\\":6},{\\"ability\\":\\"wis\\",\\"bonus\\":4}]"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The gladiator makes three Spear attacks. It can replace one attack with a use of Shield Bash.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spear\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +7, reach 5 ft. or range 20/60 ft. 11 (2d6 + 4) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Shield Bash\\",\\"text\\":\\"*Strength Saving Throw*: DC 15, one creature within 5 feet that the gladiator can see. *Failure:*  9 (2d4 + 4) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Prone condition.\\"}]"
---

# Gladiator
*Small, Humanoid, Neutral Neutral*

**AC** 16
**HP** 112 (15d8 + 45)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 15 | 16 | 10 | 12 | 15 |

CR 5, PB +3, XP 1800

## Actions

**Multiattack**
The gladiator makes three Spear attacks. It can replace one attack with a use of Shield Bash.

**Spear**
*Melee or Ranged Attack Roll:* +7, reach 5 ft. or range 20/60 ft. 11 (2d6 + 4) Piercing damage.

**Shield Bash**
*Strength Saving Throw*: DC 15, one creature within 5 feet that the gladiator can see. *Failure:*  9 (2d4 + 4) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Prone condition.
`,
      "gnoll-warrior.md": `---
smType: creature
name: "Gnoll Warrior"
size: "Medium"
type: "Fiend"
alignment: "Chaotic Evil"
ac: "15"
hp: "27"
hit_dice: "6d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":14},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bone Bow\\",\\"text\\":\\"*Ranged Attack Roll:* +3, range 150/600 ft. 6 (1d10 + 1) Piercing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Rampage (1/Day)\\",\\"text\\":\\"Immediately after dealing damage to a creature that is already Bloodied, the gnoll moves up to half its Speed, and it makes one Rend attack.\\"}]"
---

# Gnoll Warrior
*Medium, Fiend, Chaotic Evil*

**AC** 15
**HP** 27 (6d8)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 14 | 12 | 11 | 6 | 10 | 7 |

CR 1/2, PB +2, XP 100

## Actions

**Rend**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage.

**Bone Bow**
*Ranged Attack Roll:* +3, range 150/600 ft. 6 (1d10 + 1) Piercing damage.

## Bonus Actions

**Rampage (1/Day)**
Immediately after dealing damage to a creature that is already Bloodied, the gnoll moves up to half its Speed, and it makes one Rend attack.
`,
      "goblin-boss.md": `---
smType: creature
name: "Goblin Boss"
size: "Small"
type: "Fey"
type_tags: ["Goblinoid"]
alignment: "Chaotic Neutral"
ac: "17"
hp: "21"
hit_dice: "6d6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":8},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The goblin makes two attacks, using Scimitar or Shortbow in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Scimitar\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage, plus 2 (1d4) Slashing damage if the attack roll had Advantage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Shortbow\\",\\"text\\":\\"*Ranged Attack Roll:* +4, range 80/320 ft. 5 (1d6 + 2) Piercing damage, plus 2 (1d4) Piercing damage if the attack roll had Advantage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Nimble Escape\\",\\"text\\":\\"The goblin takes the Disengage or Hide action.\\"}]"
---

# Goblin Boss
*Small, Fey, Chaotic Neutral*

**AC** 17
**HP** 21 (6d6)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 15 | 10 | 10 | 8 | 10 |

CR 1, PB +2, XP 200

## Actions

**Multiattack**
The goblin makes two attacks, using Scimitar or Shortbow in any combination.

**Scimitar**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage, plus 2 (1d4) Slashing damage if the attack roll had Advantage.

**Shortbow**
*Ranged Attack Roll:* +4, range 80/320 ft. 5 (1d6 + 2) Piercing damage, plus 2 (1d4) Piercing damage if the attack roll had Advantage.

## Bonus Actions

**Nimble Escape**
The goblin takes the Disengage or Hide action.
`,
      "goblin-minion.md": `---
smType: creature
name: "Goblin Minion"
size: "Small"
type: "Fey"
type_tags: ["Goblinoid"]
alignment: "Chaotic Neutral"
ac: "12"
hp: "7"
hit_dice: "2d6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":8},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":8},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Dagger\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +4, reach 5 ft. or range 20/60 ft. 4 (1d4 + 2) Piercing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Nimble Escape\\",\\"text\\":\\"The goblin takes the Disengage or Hide action.\\"}]"
---

# Goblin Minion
*Small, Fey, Chaotic Neutral*

**AC** 12
**HP** 7 (2d6)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 8 | 15 | 10 | 10 | 8 | 8 |

CR 1/8, PB +2, XP 25

## Actions

**Dagger**
*Melee or Ranged Attack Roll:* +4, reach 5 ft. or range 20/60 ft. 4 (1d4 + 2) Piercing damage.

## Bonus Actions

**Nimble Escape**
The goblin takes the Disengage or Hide action.
`,
      "goblin-warrior.md": `---
smType: creature
name: "Goblin Warrior"
size: "Small"
type: "Fey"
type_tags: ["Goblinoid"]
alignment: "Chaotic Neutral"
ac: "15"
hp: "10"
hit_dice: "3d6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":8},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":8},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Scimitar\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage, plus 2 (1d4) Slashing damage if the attack roll had Advantage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Shortbow\\",\\"text\\":\\"*Ranged Attack Roll:* +4, range 80/320 ft. 5 (1d6 + 2) Piercing damage, plus 2 (1d4) Piercing damage if the attack roll had Advantage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Nimble Escape\\",\\"text\\":\\"The goblin takes the Disengage or Hide action.\\"}]"
---

# Goblin Warrior
*Small, Fey, Chaotic Neutral*

**AC** 15
**HP** 10 (3d6)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 8 | 15 | 10 | 10 | 8 | 8 |

CR 1/4, PB +2, XP 50

## Actions

**Scimitar**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Slashing damage, plus 2 (1d4) Slashing damage if the attack roll had Advantage.

**Shortbow**
*Ranged Attack Roll:* +4, range 80/320 ft. 5 (1d6 + 2) Piercing damage, plus 2 (1d4) Piercing damage if the attack roll had Advantage.

## Bonus Actions

**Nimble Escape**
The goblin takes the Disengage or Hide action.
`,
      "gold-dragon-wyrmling.md": `---
smType: creature
name: "Gold Dragon Wyrmling"
size: "Medium"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Lawful Good"
ac: "17"
hp: "60"
hit_dice: "8d8 + 24"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":14},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":16}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":4},{\\"ability\\":\\"wis\\",\\"bonus\\":2}]"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes two Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 9 (1d10 + 4) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fire Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 13, each creature in a 15-foot Cone. *Failure:*  22 (4d10) Fire damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Weakening Breath\\",\\"text\\":\\"*Strength Saving Throw*: DC 13, each creature that isn't currently affected by this breath in a 15-foot Cone. *Failure:*  The target has Disadvantage on Strength-based D20 Test and subtracts 2 (1d4) from its damage rolls. It repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.\\"}]"
---

# Gold Dragon Wyrmling
*Medium, Dragon, Lawful Good*

**AC** 17
**HP** 60 (8d8 + 24)
**Speed** 30 ft., swim 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 14 | 17 | 14 | 11 | 16 |

CR 3, PB +2, XP 700

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +6, reach 5 ft. 9 (1d10 + 4) Slashing damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 13, each creature in a 15-foot Cone. *Failure:*  22 (4d10) Fire damage. *Success:*  Half damage.

**Weakening Breath**
*Strength Saving Throw*: DC 13, each creature that isn't currently affected by this breath in a 15-foot Cone. *Failure:*  The target has Disadvantage on Strength-based D20 Test and subtracts 2 (1d4) from its damage rolls. It repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.
`,
      "gorgon.md": `---
smType: creature
name: "Gorgon"
size: "Large"
type: "Construct"
alignment: "Unaligned"
ac: "19"
hp: "114"
hit_dice: "12d10 + 48"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":20},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Gore\\",\\"text\\":\\"*Melee Attack Roll:* +8, reach 5 ft. 18 (2d12 + 5) Piercing damage. If the target is a Large or smaller creature and the gorgon moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Petrifying Breath (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 15, each creature in a 30-foot Cone. *First Failure* The target has the Restrained condition and repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition instead of the Restrained condition.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Trample\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 16, one creature within 5 feet that has the Prone condition. *Failure:*  16 (2d10 + 5) Bludgeoning damage. *Success:*  Half damage.\\"}]"
---

# Gorgon
*Large, Construct, Unaligned*

**AC** 19
**HP** 114 (12d10 + 48)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 20 | 11 | 18 | 2 | 12 | 7 |

CR 5, PB +3, XP 1800

## Actions

**Gore**
*Melee Attack Roll:* +8, reach 5 ft. 18 (2d12 + 5) Piercing damage. If the target is a Large or smaller creature and the gorgon moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.

**Petrifying Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 15, each creature in a 30-foot Cone. *First Failure* The target has the Restrained condition and repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition instead of the Restrained condition.

## Bonus Actions

**Trample**
*Dexterity Saving Throw*: DC 16, one creature within 5 feet that has the Prone condition. *Failure:*  16 (2d10 + 5) Bludgeoning damage. *Success:*  Half damage.
`,
      "gray-ooze.md": `---
smType: creature
name: "Gray Ooze"
size: "Medium"
type: "Ooze"
alignment: "Unaligned"
ac: "9"
hp: "22"
hit_dice: "3d8 + 9"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"climb\\":{\\"distance\\":\\"10 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":12},{\\"ability\\":\\"dex\\",\\"score\\":6},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":6},{\\"ability\\":\\"cha\\",\\"score\\":2}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amorphous\\",\\"text\\":\\"The ooze can move through a space as narrow as 1 inch without expending extra movement to do so.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Corrosive Form\\",\\"text\\":\\"Nonmagical ammunition is destroyed immediately after hitting the ooze and dealing any damage. Any nonmagical weapon takes a cumulative -1 penalty to attack rolls immediately after dealing damage to the ooze and coming into contact with it. The weapon is destroyed if the penalty reaches -5. The penalty can be removed by casting the *Mending* spell on the weapon. The ooze can eat through 2-inch-thick, nonmagical metal or wood in 1 round.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Pseudopod\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 10 (2d8 + 1) Acid damage. Nonmagical armor worn by the target takes a -1 penalty to the AC it offers. The armor is destroyed if the penalty reduces its AC to 10. The penalty can be removed by casting the *Mending* spell on the armor.\\"}]"
---

# Gray Ooze
*Medium, Ooze, Unaligned*

**AC** 9
**HP** 22 (3d8 + 9)
**Speed** 10 ft., climb 10 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 12 | 6 | 16 | 1 | 6 | 2 |

CR 1/2, PB +2, XP 100

## Traits

**Amorphous**
The ooze can move through a space as narrow as 1 inch without expending extra movement to do so.

**Corrosive Form**
Nonmagical ammunition is destroyed immediately after hitting the ooze and dealing any damage. Any nonmagical weapon takes a cumulative -1 penalty to attack rolls immediately after dealing damage to the ooze and coming into contact with it. The weapon is destroyed if the penalty reaches -5. The penalty can be removed by casting the *Mending* spell on the weapon. The ooze can eat through 2-inch-thick, nonmagical metal or wood in 1 round.

## Actions

**Pseudopod**
*Melee Attack Roll:* +3, reach 5 ft. 10 (2d8 + 1) Acid damage. Nonmagical armor worn by the target takes a -1 penalty to the AC it offers. The armor is destroyed if the penalty reduces its AC to 10. The penalty can be removed by casting the *Mending* spell on the armor.
`,
      "green-dragon-wyrmling.md": `---
smType: creature
name: "Green Dragon Wyrmling"
size: "Medium"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Lawful Evil"
ac: "17"
hp: "38"
hit_dice: "7d8 + 7"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":14},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":13}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":3},{\\"ability\\":\\"wis\\",\\"bonus\\":2}]"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes two Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage plus 3 (1d6) Poison damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Poison Breath (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 11, each creature in a 15-foot Cone. *Failure:*  21 (6d6) Poison damage. *Success:*  Half damage.\\"}]"
---

# Green Dragon Wyrmling
*Medium, Dragon, Lawful Evil*

**AC** 17
**HP** 38 (7d8 + 7)
**Speed** 30 ft., swim 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 12 | 13 | 14 | 11 | 13 |

CR 2, PB +2, XP 450

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage plus 3 (1d6) Poison damage.

**Poison Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 11, each creature in a 15-foot Cone. *Failure:*  21 (6d6) Poison damage. *Success:*  Half damage.
`,
      "green-hag.md": `---
smType: creature
name: "Green Hag"
size: "Medium"
type: "Fey"
alignment: "Neutral Evil"
ac: "17"
hp: "82"
hit_dice: "11d8 + 33"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":13},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":14}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The hag can breathe air and water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Mimicry\\",\\"text\\":\\"The hag can mimic animal sounds and humanoid voices. A creature that hears the sounds can tell they are imitations only with a successful DC 14 Wisdom (Insight) check.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The hag makes two Claw attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 8 (1d8 + 4) Slashing damage plus 3 (1d6) Poison damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The hag casts one of the following spells, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 12, +4 to hit with spell attacks): - **At Will:** *Dancing Lights*, *Disguise Self*, *Invisibility*, *Minor Illusion*, *Ray of Sickness*\\"}]"
---

# Green Hag
*Medium, Fey, Neutral Evil*

**AC** 17
**HP** 82 (11d8 + 33)
**Speed** 30 ft., swim 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 12 | 16 | 13 | 14 | 14 |

CR 3, PB +2, XP 700

## Traits

**Amphibious**
The hag can breathe air and water.

**Mimicry**
The hag can mimic animal sounds and humanoid voices. A creature that hears the sounds can tell they are imitations only with a successful DC 14 Wisdom (Insight) check.

## Actions

**Multiattack**
The hag makes two Claw attacks.

**Claw**
*Melee Attack Roll:* +6, reach 5 ft. 8 (1d8 + 4) Slashing damage plus 3 (1d6) Poison damage.

**Spellcasting**
The hag casts one of the following spells, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 12, +4 to hit with spell attacks): - **At Will:** *Dancing Lights*, *Disguise Self*, *Invisibility*, *Minor Illusion*, *Ray of Sickness*
`,
      "grick.md": `---
smType: creature
name: "Grick"
size: "Medium"
type: "Aberration"
alignment: "Unaligned"
ac: "14"
hp: "54"
hit_dice: "12d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":14},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The grick makes one Beak attack and one Tentacles attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Beak\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 9 (2d6 + 2) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tentacles\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12) from all four tentacles.\\"}]"
---

# Grick
*Medium, Aberration, Unaligned*

**AC** 14
**HP** 54 (12d8)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 14 | 14 | 11 | 3 | 14 | 5 |

CR 2, PB +2, XP 450

## Actions

**Multiattack**
The grick makes one Beak attack and one Tentacles attack.

**Beak**
*Melee Attack Roll:* +4, reach 5 ft. 9 (2d6 + 2) Piercing damage.

**Tentacles**
*Melee Attack Roll:* +4, reach 5 ft. 7 (1d10 + 2) Slashing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 12) from all four tentacles.
`,
      "griffon.md": `---
smType: creature
name: "Griffon"
size: "Large"
type: "Monstrosity"
alignment: "Unaligned"
ac: "12"
hp: "59"
hit_dice: "7d10 + 21"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The griffon makes two Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 8 (1d8 + 4) Piercing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 14) from both of the griffon's front claws.\\"}]"
---

# Griffon
*Large, Monstrosity, Unaligned*

**AC** 12
**HP** 59 (7d10 + 21)
**Speed** 30 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 15 | 16 | 2 | 13 | 8 |

CR 2, PB +2, XP 450

## Actions

**Multiattack**
The griffon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +6, reach 5 ft. 8 (1d8 + 4) Piercing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 14) from both of the griffon's front claws.
`,
      "grimlock.md": `---
smType: creature
name: "Grimlock"
size: "Medium"
type: "Aberration"
alignment: "Neutral Evil"
ac: "11"
hp: "11"
hit_dice: "2d8 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":9},{\\"ability\\":\\"wis\\",\\"score\\":8},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bone Cudgel\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage plus 2 (1d4) Psychic damage.\\"}]"
---

# Grimlock
*Medium, Aberration, Neutral Evil*

**AC** 11
**HP** 11 (2d8 + 2)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 12 | 12 | 9 | 8 | 6 |

CR 1/4, PB +2, XP 50

## Actions

**Bone Cudgel**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage plus 2 (1d4) Psychic damage.
`,
      "guard-captain.md": `---
smType: creature
name: "Guard Captain"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "18"
hp: "75"
hit_dice: "10d8 + 30"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":13}]"
pb: "+2"
cr: "4"
xp: "1100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The guard makes two attacks, using Javelin or Longsword in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Javelin\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +6, reach 5 ft. or range 30/120 ft. 14 (3d6 + 4) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Longsword\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 15 (2d10 + 4) Slashing damage.\\"}]"
---

# Guard Captain
*Small, Humanoid, Neutral Neutral*

**AC** 18
**HP** 75 (10d8 + 30)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 14 | 16 | 12 | 14 | 13 |

CR 4, PB +2, XP 1100

## Actions

**Multiattack**
The guard makes two attacks, using Javelin or Longsword in any combination.

**Javelin**
*Melee or Ranged Attack Roll:* +6, reach 5 ft. or range 30/120 ft. 14 (3d6 + 4) Piercing damage.

**Longsword**
*Melee Attack Roll:* +6, reach 5 ft. 15 (2d10 + 4) Slashing damage.
`,
      "guard.md": `---
smType: creature
name: "Guard"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "16"
hp: "11"
hit_dice: "2d8 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":13},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+2"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Spear\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +3, reach 5 ft. or range 20/60 ft. 4 (1d6 + 1) Piercing damage.\\"}]"
---

# Guard
*Small, Humanoid, Neutral Neutral*

**AC** 16
**HP** 11 (2d8 + 2)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 13 | 12 | 12 | 10 | 11 | 10 |

CR 1/8, PB +2, XP 25

## Actions

**Spear**
*Melee or Ranged Attack Roll:* +3, reach 5 ft. or range 20/60 ft. 4 (1d6 + 1) Piercing damage.
`,
      "guardian-naga.md": `---
smType: creature
name: "Guardian Naga"
size: "Large"
type: "Celestial"
alignment: "Lawful Good"
ac: "18"
hp: "136"
hit_dice: "16d10 + 48"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"40 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":18},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":19},{\\"ability\\":\\"cha\\",\\"score\\":18}]"
pb: "+4"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":8},{\\"ability\\":\\"con\\",\\"bonus\\":7},{\\"ability\\":\\"int\\",\\"bonus\\":7},{\\"ability\\":\\"wis\\",\\"bonus\\":8},{\\"ability\\":\\"cha\\",\\"bonus\\":8}]"
cr: "10"
xp: "5900"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Celestial Restoration\\",\\"text\\":\\"If the naga dies, it returns to life in 1d6 days and regains all its Hit Points unless *Dispel Evil and Good* is cast on its remains.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The naga makes two Bite attacks. It can replace any attack with a use of Poisonous Spittle.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +8, reach 10 ft. 17 (2d12 + 4) Piercing damage plus 22 (4d10) Poison damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Poisonous Spittle\\",\\"text\\":\\"*Constitution Saving Throw*: DC 16, one creature the naga can see within 60 feet. *Failure:*  31 (7d8) Poison damage, and the target has the Blinded condition until the start of the naga's next turn. *Success:*  Half damage only.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The naga casts one of the following spells, requiring no Somatic or Material components and using Wisdom as the spellcasting ability (spell save DC 16): - **At Will:** *Thaumaturgy* - **1e/Day Each:** *Clairvoyance*, *Cure Wounds*, *Flame Strike*, *Geas*, *True Seeing*\\"}]"
---

# Guardian Naga
*Large, Celestial, Lawful Good*

**AC** 18
**HP** 136 (16d10 + 48)
**Speed** 40 ft., climb 40 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 18 | 16 | 16 | 19 | 18 |

CR 10, PB +4, XP 5900

## Traits

**Celestial Restoration**
If the naga dies, it returns to life in 1d6 days and regains all its Hit Points unless *Dispel Evil and Good* is cast on its remains.

## Actions

**Multiattack**
The naga makes two Bite attacks. It can replace any attack with a use of Poisonous Spittle.

**Bite**
*Melee Attack Roll:* +8, reach 10 ft. 17 (2d12 + 4) Piercing damage plus 22 (4d10) Poison damage.

**Poisonous Spittle**
*Constitution Saving Throw*: DC 16, one creature the naga can see within 60 feet. *Failure:*  31 (7d8) Poison damage, and the target has the Blinded condition until the start of the naga's next turn. *Success:*  Half damage only.

**Spellcasting**
The naga casts one of the following spells, requiring no Somatic or Material components and using Wisdom as the spellcasting ability (spell save DC 16): - **At Will:** *Thaumaturgy* - **1e/Day Each:** *Clairvoyance*, *Cure Wounds*, *Flame Strike*, *Geas*, *True Seeing*
`,
      "half-dragon.md": `---
smType: creature
name: "Half-Dragon"
size: "Medium"
type: "Dragon"
alignment: "Neutral Neutral"
ac: "18"
hp: "105"
hit_dice: "14d8 + 42"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":14}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":5},{\\"ability\\":\\"wis\\",\\"bonus\\":5}]"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Draconic Origin\\",\\"text\\":\\"The half-dragon is related to a type of dragon associated with one of the following damage types (DM's choice): Acid, Cold, Fire, Lightning, or Poison. This choice affects other aspects of the stat block.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The half-dragon makes two Claw attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 10 ft. 6 (1d4 + 4) Slashing damage plus 7 (2d6) damage of the type chosen for the Draconic Origin trait.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Dragon's Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 14, each creature in a 30-foot Cone. *Failure:*  28 (8d6) damage of the type chosen for the Draconic Origin trait. *Success:*  Half damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Leap\\",\\"text\\":\\"The half-dragon jumps up to 30 feet by spending 10 feet of movement.\\"}]"
---

# Half-Dragon
*Medium, Dragon, Neutral Neutral*

**AC** 18
**HP** 105 (14d8 + 42)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 14 | 16 | 10 | 15 | 14 |

CR 5, PB +3, XP 1800

## Traits

**Draconic Origin**
The half-dragon is related to a type of dragon associated with one of the following damage types (DM's choice): Acid, Cold, Fire, Lightning, or Poison. This choice affects other aspects of the stat block.

## Actions

**Multiattack**
The half-dragon makes two Claw attacks.

**Claw**
*Melee Attack Roll:* +7, reach 10 ft. 6 (1d4 + 4) Slashing damage plus 7 (2d6) damage of the type chosen for the Draconic Origin trait.

**Dragon's Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 14, each creature in a 30-foot Cone. *Failure:*  28 (8d6) damage of the type chosen for the Draconic Origin trait. *Success:*  Half damage.

## Bonus Actions

**Leap**
The half-dragon jumps up to 30 feet by spending 10 feet of movement.
`,
      "harpy.md": `---
smType: creature
name: "Harpy"
size: "Medium"
type: "Monstrosity"
alignment: "Chaotic Evil"
ac: "11"
hp: "38"
hit_dice: "7d8 + 7"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"fly\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":12},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":7},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":13}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 6 (2d4 + 1) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Luring Song\\",\\"text\\":\\"The harpy sings a magical melody, which lasts until the harpy's  Concentration ends on it. *Wisdom Saving Throw*: DC 11, each Humanoid and Giant in a 300-foot Emanation originating from the harpy when the song starts. *Failure:*  The target has the Charmed condition until the song ends and repeats the save at the end of each of its turns. While Charmed, the target has the Incapacitated condition and ignores the Luring Song of other harpies. If the target is more than 5 feet from the harpy, the target moves on its turn toward the harpy by the most direct route, trying to get within 5 feet of the harpy. It doesn't avoid Opportunity Attacks; however, before moving into damaging terrain (such as lava or a pit) and whenever it takes damage from a source other than the harpy, the target repeats the save. *Success:*  The target is immune to this harpy's Luring Song for 24 hours.\\"}]"
---

# Harpy
*Medium, Monstrosity, Chaotic Evil*

**AC** 11
**HP** 38 (7d8 + 7)
**Speed** 20 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 12 | 13 | 12 | 7 | 10 | 13 |

CR 1, PB +2, XP 200

## Actions

**Claw**
*Melee Attack Roll:* +3, reach 5 ft. 6 (2d4 + 1) Slashing damage.

**Luring Song**
The harpy sings a magical melody, which lasts until the harpy's  Concentration ends on it. *Wisdom Saving Throw*: DC 11, each Humanoid and Giant in a 300-foot Emanation originating from the harpy when the song starts. *Failure:*  The target has the Charmed condition until the song ends and repeats the save at the end of each of its turns. While Charmed, the target has the Incapacitated condition and ignores the Luring Song of other harpies. If the target is more than 5 feet from the harpy, the target moves on its turn toward the harpy by the most direct route, trying to get within 5 feet of the harpy. It doesn't avoid Opportunity Attacks; however, before moving into damaging terrain (such as lava or a pit) and whenever it takes damage from a source other than the harpy, the target repeats the save. *Success:*  The target is immune to this harpy's Luring Song for 24 hours.
`,
      "hell-hound.md": `---
smType: creature
name: "Hell Hound"
size: "Medium"
type: "Fiend"
alignment: "Lawful Evil"
ac: "15"
hp: "58"
hit_dice: "9d8 + 18"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The hound has Advantage on an attack roll against a creature if at least one of the hound's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The hound makes two Bite attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage plus 3 (1d6) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fire Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 12, each creature in a 15-foot Cone. *Failure:*  17 (5d6) Fire damage. *Success:*  Half damage.\\"}]"
---

# Hell Hound
*Medium, Fiend, Lawful Evil*

**AC** 15
**HP** 58 (9d8 + 18)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 12 | 14 | 6 | 13 | 6 |

CR 3, PB +2, XP 700

## Traits

**Pack Tactics**
The hound has Advantage on an attack roll against a creature if at least one of the hound's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Multiattack**
The hound makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage plus 3 (1d6) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 12, each creature in a 15-foot Cone. *Failure:*  17 (5d6) Fire damage. *Success:*  Half damage.
`,
      "hezrou.md": `---
smType: creature
name: "Hezrou"
size: "Large"
type: "Fiend"
type_tags: ["Demon"]
alignment: "Chaotic Evil"
ac: "18"
hp: "157"
hit_dice: "15d10 + 75"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":20},{\\"ability\\":\\"int\\",\\"score\\":5},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":13}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":7},{\\"ability\\":\\"con\\",\\"bonus\\":8},{\\"ability\\":\\"wis\\",\\"bonus\\":4}]"
cr: "8"
xp: "3900"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Demonic Restoration\\",\\"text\\":\\"If the hezrou dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The hezrou has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Stench\\",\\"text\\":\\"*Constitution Saving Throw*: DC 16, any creature that starts its turn in a 10-foot Emanation originating from the hezrou. *Failure:*  The target has the Poisoned condition until the start of its next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The hezrou makes three Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 6 (1d4 + 4) Slashing damage plus 9 (2d8) Poison damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Leap\\",\\"text\\":\\"The hezrou jumps up to 30 feet by spending 10 feet of movement.\\"}]"
---

# Hezrou
*Large, Fiend, Chaotic Evil*

**AC** 18
**HP** 157 (15d10 + 75)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 17 | 20 | 5 | 12 | 13 |

CR 8, PB +3, XP 3900

## Traits

**Demonic Restoration**
If the hezrou dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.

**Magic Resistance**
The hezrou has Advantage on saving throws against spells and other magical effects.

**Stench**
*Constitution Saving Throw*: DC 16, any creature that starts its turn in a 10-foot Emanation originating from the hezrou. *Failure:*  The target has the Poisoned condition until the start of its next turn.

## Actions

**Multiattack**
The hezrou makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +7, reach 5 ft. 6 (1d4 + 4) Slashing damage plus 9 (2d8) Poison damage.

## Bonus Actions

**Leap**
The hezrou jumps up to 30 feet by spending 10 feet of movement.
`,
      "hill-giant.md": `---
smType: creature
name: "Hill Giant"
size: "Huge"
type: "Giant"
alignment: "Chaotic Evil"
ac: "13"
hp: "105"
hit_dice: "10d12 + 40"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":21},{\\"ability\\":\\"dex\\",\\"score\\":8},{\\"ability\\":\\"con\\",\\"score\\":19},{\\"ability\\":\\"int\\",\\"score\\":5},{\\"ability\\":\\"wis\\",\\"score\\":9},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The giant makes two attacks, using Tree Club or Trash Lob in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tree Club\\",\\"text\\":\\"*Melee Attack Roll:* +8, reach 10 ft. 18 (3d8 + 5) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Trash Lob\\",\\"text\\":\\"*Ranged Attack Roll:* +8, range 60/240 ft. 16 (2d10 + 5) Bludgeoning damage, and the target has the Poisoned condition until the end of its next turn.\\"}]"
---

# Hill Giant
*Huge, Giant, Chaotic Evil*

**AC** 13
**HP** 105 (10d12 + 40)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 21 | 8 | 19 | 5 | 9 | 6 |

CR 5, PB +3, XP 1800

## Actions

**Multiattack**
The giant makes two attacks, using Tree Club or Trash Lob in any combination.

**Tree Club**
*Melee Attack Roll:* +8, reach 10 ft. 18 (3d8 + 5) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.

**Trash Lob**
*Ranged Attack Roll:* +8, range 60/240 ft. 16 (2d10 + 5) Bludgeoning damage, and the target has the Poisoned condition until the end of its next turn.
`,
      "hippogriff.md": `---
smType: creature
name: "Hippogriff"
size: "Large"
type: "Monstrosity"
alignment: "Unaligned"
ac: "11"
hp: "26"
hit_dice: "4d10 + 4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Flyby\\",\\"text\\":\\"The hippogriff doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The hippogriff makes two Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Slashing damage.\\"}]"
---

# Hippogriff
*Large, Monstrosity, Unaligned*

**AC** 11
**HP** 26 (4d10 + 4)
**Speed** 40 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 13 | 13 | 2 | 12 | 8 |

CR 1, PB +2, XP 200

## Traits

**Flyby**
The hippogriff doesn't provoke an Opportunity Attack when it flies out of an enemy's reach.

## Actions

**Multiattack**
The hippogriff makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Slashing damage.
`,
      "hobgoblin-captain.md": `---
smType: creature
name: "Hobgoblin Captain"
size: "Medium"
type: "Fey"
type_tags: ["Goblinoid"]
alignment: "Lawful Evil"
ac: "17"
hp: "58"
hit_dice: "9d8 + 18"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":13}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Aura of Authority\\",\\"text\\":\\"While in a 10-foot Emanation originating from the hobgoblin, the hobgoblin and its allies have Advantage on attack rolls and saving throws, provided the hobgoblin doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The hobgoblin makes two attacks, using Greatsword or Longbow in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Greatsword\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 9 (2d6 + 2) Slashing damage plus 3 (1d6) Poison damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Longbow\\",\\"text\\":\\"*Ranged Attack Roll:* +4, range 150/600 ft. 6 (1d8 + 2) Piercing damage plus 5 (2d4) Poison damage.\\"}]"
---

# Hobgoblin Captain
*Medium, Fey, Lawful Evil*

**AC** 17
**HP** 58 (9d8 + 18)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 14 | 14 | 12 | 10 | 13 |

CR 3, PB +2, XP 700

## Traits

**Aura of Authority**
While in a 10-foot Emanation originating from the hobgoblin, the hobgoblin and its allies have Advantage on attack rolls and saving throws, provided the hobgoblin doesn't have the Incapacitated condition.

## Actions

**Multiattack**
The hobgoblin makes two attacks, using Greatsword or Longbow in any combination.

**Greatsword**
*Melee Attack Roll:* +4, reach 5 ft. 9 (2d6 + 2) Slashing damage plus 3 (1d6) Poison damage.

**Longbow**
*Ranged Attack Roll:* +4, range 150/600 ft. 6 (1d8 + 2) Piercing damage plus 5 (2d4) Poison damage.
`,
      "hobgoblin-warrior.md": `---
smType: creature
name: "Hobgoblin Warrior"
size: "Medium"
type: "Fey"
type_tags: ["Goblinoid"]
alignment: "Lawful Evil"
ac: "18"
hp: "11"
hit_dice: "2d8 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":13},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":9}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The hobgoblin has Advantage on an attack roll against a creature if at least one of the hobgoblin's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Longsword\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 12 (2d10 + 1) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Longbow\\",\\"text\\":\\"*Ranged Attack Roll:* +3, range 150/600 ft. 5 (1d8 + 1) Piercing damage plus 7 (3d4) Poison damage.\\"}]"
---

# Hobgoblin Warrior
*Medium, Fey, Lawful Evil*

**AC** 18
**HP** 11 (2d8 + 2)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 13 | 12 | 12 | 10 | 10 | 9 |

CR 1/2, PB +2, XP 100

## Traits

**Pack Tactics**
The hobgoblin has Advantage on an attack roll against a creature if at least one of the hobgoblin's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Longsword**
*Melee Attack Roll:* +3, reach 5 ft. 12 (2d10 + 1) Slashing damage.

**Longbow**
*Ranged Attack Roll:* +3, range 150/600 ft. 5 (1d8 + 1) Piercing damage plus 7 (3d4) Poison damage.
`,
      "homunculus.md": `---
smType: creature
name: "Homunculus"
size: "Small"
type: "Construct"
alignment: "Neutral Neutral"
ac: "13"
hp: "4"
hit_dice: "1d4 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"fly\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":4},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"wis\\",\\"bonus\\":2}]"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Telepathic Bond\\",\\"text\\":\\"While the homunculus is on the same plane of existence as its master, the two of them can communicate telepathically with each other.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 1 Piercing damage, and the target is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target has the Poisoned condition until the end of the homunculus's next turn. *Failure by 5 or More:* The target has the Poisoned condition for 1 minute. While Poisoned, the target has the Unconscious condition, which ends early if the target takes any damage.\\"}]"
---

# Homunculus
*Small, Construct, Neutral Neutral*

**AC** 13
**HP** 4 (1d4 + 2)
**Speed** 20 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 4 | 15 | 14 | 10 | 10 | 7 |

CR 0, PB +2, XP 0

## Traits

**Telepathic Bond**
While the homunculus is on the same plane of existence as its master, the two of them can communicate telepathically with each other.

## Actions

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 1 Piercing damage, and the target is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target has the Poisoned condition until the end of the homunculus's next turn. *Failure by 5 or More:* The target has the Poisoned condition for 1 minute. While Poisoned, the target has the Unconscious condition, which ends early if the target takes any damage.
`,
      "horned-devil.md": `---
smType: creature
name: "Horned Devil"
size: "Large"
type: "Fiend"
type_tags: ["Devil"]
alignment: "Lawful Evil"
ac: "18"
hp: "199"
hit_dice: "19d10 + 95"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":22},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":21},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":16},{\\"ability\\":\\"cha\\",\\"score\\":18}]"
pb: "+4"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":10},{\\"ability\\":\\"dex\\",\\"bonus\\":7},{\\"ability\\":\\"wis\\",\\"bonus\\":7},{\\"ability\\":\\"cha\\",\\"bonus\\":8}]"
cr: "11"
xp: "7200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Diabolical Restoration\\",\\"text\\":\\"If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The devil has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The devil makes three attacks, using Searing Fork or Hurl Flame in any combination. It can replace one attack with a use of Infernal Tail.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Searing Fork\\",\\"text\\":\\"*Melee Attack Roll:* +10, reach 10 ft. 15 (2d8 + 6) Piercing damage plus 9 (2d8) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Hurl Flame\\",\\"text\\":\\"*Ranged Attack Roll:* +8, range 150 ft. 26 (5d8 + 4) Fire damage. If the target is a flammable object that isn't being worn or carried, it starts burning.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Infernal Tail\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 17, one creature the devil can see within 10 feet. *Failure:*  10 (1d8 + 6) Necrotic damage, and the target receives an infernal wound if it doesn't have one. While wounded, the target loses 10 (3d6) Hit Points at the start of each of its turns. The wound closes after 1 minute, after a spell restores Hit Points to the target, or after the target or a creature within 5 feet of it takes an action to stanch the wound, doing so by succeeding on a DC 17 Wisdom (Medicine) check.\\"}]"
---

# Horned Devil
*Large, Fiend, Lawful Evil*

**AC** 18
**HP** 199 (19d10 + 95)
**Speed** 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 22 | 17 | 21 | 12 | 16 | 18 |

CR 11, PB +4, XP 7200

## Traits

**Diabolical Restoration**
If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.

**Magic Resistance**
The devil has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The devil makes three attacks, using Searing Fork or Hurl Flame in any combination. It can replace one attack with a use of Infernal Tail.

**Searing Fork**
*Melee Attack Roll:* +10, reach 10 ft. 15 (2d8 + 6) Piercing damage plus 9 (2d8) Fire damage.

**Hurl Flame**
*Ranged Attack Roll:* +8, range 150 ft. 26 (5d8 + 4) Fire damage. If the target is a flammable object that isn't being worn or carried, it starts burning.

**Infernal Tail**
*Dexterity Saving Throw*: DC 17, one creature the devil can see within 10 feet. *Failure:*  10 (1d8 + 6) Necrotic damage, and the target receives an infernal wound if it doesn't have one. While wounded, the target loses 10 (3d6) Hit Points at the start of each of its turns. The wound closes after 1 minute, after a spell restores Hit Points to the target, or after the target or a creature within 5 feet of it takes an action to stanch the wound, doing so by succeeding on a DC 17 Wisdom (Medicine) check.
`,
      "hydra.md": `---
smType: creature
name: "Hydra"
size: "Huge"
type: "Monstrosity"
alignment: "Unaligned"
ac: "15"
hp: "184"
hit_dice: "16d12 + 80"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":20},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":20},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+3"
cr: "8"
xp: "3900"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Hold Breath\\",\\"text\\":\\"The hydra can hold its breath for 1 hour.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Multiple Heads\\",\\"text\\":\\"The hydra has five heads. Whenever the hydra takes 25 damage or more on a single turn, one of its heads dies. The hydra dies if all its heads are dead. At the end of each of its turns when it has at least one living head, the hydra grows two heads for each of its heads that died since its last turn, unless it has taken Fire damage since its last turn. The hydra regains 20 Hit Points when it grows new heads.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Reactive Heads\\",\\"text\\":\\"For each head the hydra has beyond one, it gets an extra Reaction that can be used only for Opportunity Attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The hydra makes as many Bite attacks as it has heads.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +8, reach 10 ft. 10 (1d10 + 5) Piercing damage.\\"}]"
---

# Hydra
*Huge, Monstrosity, Unaligned*

**AC** 15
**HP** 184 (16d12 + 80)
**Speed** 40 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 20 | 12 | 20 | 2 | 10 | 7 |

CR 8, PB +3, XP 3900

## Traits

**Hold Breath**
The hydra can hold its breath for 1 hour.

**Multiple Heads**
The hydra has five heads. Whenever the hydra takes 25 damage or more on a single turn, one of its heads dies. The hydra dies if all its heads are dead. At the end of each of its turns when it has at least one living head, the hydra grows two heads for each of its heads that died since its last turn, unless it has taken Fire damage since its last turn. The hydra regains 20 Hit Points when it grows new heads.

**Reactive Heads**
For each head the hydra has beyond one, it gets an extra Reaction that can be used only for Opportunity Attacks.

## Actions

**Multiattack**
The hydra makes as many Bite attacks as it has heads.

**Bite**
*Melee Attack Roll:* +8, reach 10 ft. 10 (1d10 + 5) Piercing damage.
`,
      "ice-devil.md": `---
smType: creature
name: "Ice Devil"
size: "Large"
type: "Fiend"
type_tags: ["Devil"]
alignment: "Lawful Evil"
ac: "18"
hp: "228"
hit_dice: "24d10 + 96"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":21},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":18},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":18}]"
pb: "+5"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":7},{\\"ability\\":\\"con\\",\\"bonus\\":9},{\\"ability\\":\\"wis\\",\\"bonus\\":7},{\\"ability\\":\\"cha\\",\\"bonus\\":9}]"
cr: "14"
xp: "11500"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Diabolical Restoration\\",\\"text\\":\\"If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The devil has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The devil makes three Ice Spear attacks. It can replace one attack with a Tail attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Ice Spear\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +10, reach 5 ft. or range 30/120 ft. 14 (2d8 + 5) Piercing damage plus 10 (3d6) Cold damage. Until the end of its next turn, the target can't take a Bonus Action or Reaction, its Speed decreases by 10 feet, and it can move or take one action on its turn, not both. HitomThe spear magically returns to the devil's hand immediately after a ranged attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tail\\",\\"text\\":\\"*Melee Attack Roll:* +10, reach 10 ft. 15 (3d6 + 5) Bludgeoning damage plus 18 (4d8) Cold damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Ice Wall\\",\\"recharge\\":\\"Recharge 6\\",\\"text\\":\\"The devil casts *Wall of Ice* (level 8 version), requiring no spell components and using Intelligence as the spellcasting ability (spell save DC 17). - **At Will:**\\"}]"
---

# Ice Devil
*Large, Fiend, Lawful Evil*

**AC** 18
**HP** 228 (24d10 + 96)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 21 | 14 | 18 | 18 | 15 | 18 |

CR 14, PB +5, XP 11500

## Traits

**Diabolical Restoration**
If the devil dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.

**Magic Resistance**
The devil has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The devil makes three Ice Spear attacks. It can replace one attack with a Tail attack.

**Ice Spear**
*Melee or Ranged Attack Roll:* +10, reach 5 ft. or range 30/120 ft. 14 (2d8 + 5) Piercing damage plus 10 (3d6) Cold damage. Until the end of its next turn, the target can't take a Bonus Action or Reaction, its Speed decreases by 10 feet, and it can move or take one action on its turn, not both. HitomThe spear magically returns to the devil's hand immediately after a ranged attack.

**Tail**
*Melee Attack Roll:* +10, reach 10 ft. 15 (3d6 + 5) Bludgeoning damage plus 18 (4d8) Cold damage.

**Ice Wall (Recharge 6)**
The devil casts *Wall of Ice* (level 8 version), requiring no spell components and using Intelligence as the spellcasting ability (spell save DC 17). - **At Will:**
`,
      "ice-mephit.md": `---
smType: creature
name: "Ice Mephit"
size: "Small"
type: "Elemental"
alignment: "Neutral Evil"
ac: "11"
hp: "21"
hit_dice: "6d6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":7},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":9},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":12}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Death Burst\\",\\"text\\":\\"The mephit explodes when it dies. *Constitution Saving Throw*: DC 10, each creature in a 5-foot Emanation originating from the mephit. *Failure:*  5 (2d4) Cold damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 3 (1d4 + 1) Slashing damage plus 2 (1d4) Cold damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Frost Breath\\",\\"recharge\\":\\"Recharge 6\\",\\"text\\":\\"*Constitution Saving Throw*: DC 10, each creature in a 15-foot Cone. *Failure:*  7 (3d4) Cold damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fog Cloud (1/Day)\\",\\"text\\":\\"The mephit casts *Fog Cloud*, requiring no spell components and using Charisma as the spellcasting ability. - **At Will:** - **1/Day Each:** *Fog Cloud*\\"}]"
---

# Ice Mephit
*Small, Elemental, Neutral Evil*

**AC** 11
**HP** 21 (6d6)
**Speed** 30 ft., fly 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 7 | 13 | 10 | 9 | 11 | 12 |

CR 1/2, PB +2, XP 100

## Traits

**Death Burst**
The mephit explodes when it dies. *Constitution Saving Throw*: DC 10, each creature in a 5-foot Emanation originating from the mephit. *Failure:*  5 (2d4) Cold damage. *Success:*  Half damage.

## Actions

**Claw**
*Melee Attack Roll:* +3, reach 5 ft. 3 (1d4 + 1) Slashing damage plus 2 (1d4) Cold damage.

**Frost Breath (Recharge 6)**
*Constitution Saving Throw*: DC 10, each creature in a 15-foot Cone. *Failure:*  7 (3d4) Cold damage. *Success:*  Half damage.

**Fog Cloud (1/Day)**
The mephit casts *Fog Cloud*, requiring no spell components and using Charisma as the spellcasting ability. - **At Will:** - **1/Day Each:** *Fog Cloud*
`,
      "imp.md": `---
smType: creature
name: "Imp"
size: "Small"
type: "Fiend"
type_tags: ["Devil"]
alignment: "Lawful Evil"
ac: "13"
hp: "21"
hit_dice: "6d4 + 6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"fly\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":6},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":14}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The imp has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Sting\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Piercing damage plus 7 (2d6) Poison damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Shape-Shift\\",\\"text\\":\\"The imp shape-shifts to resemble a rat (Speed 20 ft.), a raven (20 ft., Fly 60 ft.), or a spider (20 ft., Climb 20 ft.), or it returns to its true form. Its statistics are the same in each form, except for its Speed. Any equipment it is wearing or carrying isn't transformed.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Invisibility\\",\\"text\\":\\"The imp casts *Invisibility* on itself, requiring no spell components and using Charisma as the spellcasting ability. - **At Will:** *Invisibility*\\"}]"
---

# Imp
*Small, Fiend, Lawful Evil*

**AC** 13
**HP** 21 (6d4 + 6)
**Speed** 20 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 6 | 17 | 13 | 11 | 12 | 14 |

CR 1, PB +2, XP 200

## Traits

**Magic Resistance**
The imp has Advantage on saving throws against spells and other magical effects.

## Actions

**Sting**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Piercing damage plus 7 (2d6) Poison damage.

**Shape-Shift**
The imp shape-shifts to resemble a rat (Speed 20 ft.), a raven (20 ft., Fly 60 ft.), or a spider (20 ft., Climb 20 ft.), or it returns to its true form. Its statistics are the same in each form, except for its Speed. Any equipment it is wearing or carrying isn't transformed.

**Invisibility**
The imp casts *Invisibility* on itself, requiring no spell components and using Charisma as the spellcasting ability. - **At Will:** *Invisibility*
`,
      "incubus.md": `---
smType: creature
name: "Incubus"
size: "Medium"
type: "Fiend"
alignment: "Neutral Evil"
ac: "15"
hp: "66"
hit_dice: "12d8 + 12"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":8},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":15},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":20}]"
pb: "+2"
cr: "4"
xp: "1100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Succubus Form\\",\\"text\\":\\"When the incubus finishes a Long Rest, it can shape-shift into a Succubus, using that stat block instead of this one. Any equipment it's wearing or carrying isn't transformed.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The incubus makes two Restless Touch attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Restless Touch\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 15 (3d6 + 5) Psychic damage, and the target is cursed for 24 hours or until the incubus dies. Until the curse ends, the target gains no benefit from finishing Short Rests.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The incubus casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 15): - **At Will:** *Disguise Self*, *Etherealness* - **1e/Day Each:** *Dream*, *Hypnotic Pattern*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Nightmare\\",\\"recharge\\":\\"Recharge 6\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 15, one creature the incubus can see within 60 feet. *Failure:*  If the target has 20 Hit Points or fewer, it has the Unconscious condition for 1 hour, until it takes damage, or until a creature within 5 feet of it takes an action to wake it. Otherwise, the target takes 18 (4d8) Psychic damage.\\"}]"
---

# Incubus
*Medium, Fiend, Neutral Evil*

**AC** 15
**HP** 66 (12d8 + 12)
**Speed** 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 8 | 17 | 13 | 15 | 12 | 20 |

CR 4, PB +2, XP 1100

## Traits

**Succubus Form**
When the incubus finishes a Long Rest, it can shape-shift into a Succubus, using that stat block instead of this one. Any equipment it's wearing or carrying isn't transformed.

## Actions

**Multiattack**
The incubus makes two Restless Touch attacks.

**Restless Touch**
*Melee Attack Roll:* +7, reach 5 ft. 15 (3d6 + 5) Psychic damage, and the target is cursed for 24 hours or until the incubus dies. Until the curse ends, the target gains no benefit from finishing Short Rests.

**Spellcasting**
The incubus casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 15): - **At Will:** *Disguise Self*, *Etherealness* - **1e/Day Each:** *Dream*, *Hypnotic Pattern*

## Bonus Actions

**Nightmare (Recharge 6)**
*Wisdom Saving Throw*: DC 15, one creature the incubus can see within 60 feet. *Failure:*  If the target has 20 Hit Points or fewer, it has the Unconscious condition for 1 hour, until it takes damage, or until a creature within 5 feet of it takes an action to wake it. Otherwise, the target takes 18 (4d8) Psychic damage.
`,
      "invisible-stalker.md": `---
smType: creature
name: "Invisible Stalker"
size: "Large"
type: "Elemental"
alignment: "Neutral Neutral"
ac: "14"
hp: "97"
hit_dice: "13d10 + 26"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"},\\"fly\\":{\\"distance\\":\\"50 ft.\\",\\"hover\\":true}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":19},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+3"
cr: "6"
xp: "2300"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Air Form\\",\\"text\\":\\"The stalker can enter an enemy's space and stop there. It can move through a space as narrow as 1 inch without expending extra movement to do so.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Invisibility\\",\\"text\\":\\"The stalker has the Invisible condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The stalker makes three Wind Swipe attacks. It can replace one attack with a use of Vortex.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Wind Swipe\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 11 (2d6 + 4) Force damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Vortex\\",\\"text\\":\\"*Constitution Saving Throw*: DC 14, one Large or smaller creature in the stalker's space. *Failure:*  7 (1d8 + 3) Thunder damage, and the target has the Grappled condition (escape DC 13). Until the grapple ends, the target can't cast spells with a Verbal component and takes 7 (2d6) Thunder damage at the start of each of the stalker's turns.\\"}]"
---

# Invisible Stalker
*Large, Elemental, Neutral Neutral*

**AC** 14
**HP** 97 (13d10 + 26)
**Speed** 50 ft., fly 50 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 19 | 14 | 10 | 15 | 11 |

CR 6, PB +3, XP 2300

## Traits

**Air Form**
The stalker can enter an enemy's space and stop there. It can move through a space as narrow as 1 inch without expending extra movement to do so.

**Invisibility**
The stalker has the Invisible condition.

## Actions

**Multiattack**
The stalker makes three Wind Swipe attacks. It can replace one attack with a use of Vortex.

**Wind Swipe**
*Melee Attack Roll:* +7, reach 5 ft. 11 (2d6 + 4) Force damage.

**Vortex**
*Constitution Saving Throw*: DC 14, one Large or smaller creature in the stalker's space. *Failure:*  7 (1d8 + 3) Thunder damage, and the target has the Grappled condition (escape DC 13). Until the grapple ends, the target can't cast spells with a Verbal component and takes 7 (2d6) Thunder damage at the start of each of the stalker's turns.
`,
      "iron-golem.md": `---
smType: creature
name: "Iron Golem"
size: "Large"
type: "Construct"
alignment: "Unaligned"
ac: "20"
hp: "252"
hit_dice: "24d10 + 120"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":24},{\\"ability\\":\\"dex\\",\\"score\\":9},{\\"ability\\":\\"con\\",\\"score\\":20},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":1}]"
pb: "+5"
cr: "16"
xp: "15000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Fire Absorption\\",\\"text\\":\\"Whenever the golem is subjected to Fire damage, it regains a number of Hit Points equal to the Fire damage dealt.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Immutable Form\\",\\"text\\":\\"The golem can't shape-shift.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The golem has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The golem makes two attacks, using Bladed Arm or Fiery Bolt in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bladed Arm\\",\\"text\\":\\"*Melee Attack Roll:* +12, reach 10 ft. 20 (3d8 + 7) Slashing damage plus 10 (3d6) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fiery Bolt\\",\\"text\\":\\"*Ranged Attack Roll:* +10, range 120 ft. 36 (8d8) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Poison Breath\\",\\"recharge\\":\\"Recharge 6\\",\\"text\\":\\"*Constitution Saving Throw*: DC 18, each creature in a 60-foot Cone. *Failure:*  55 (10d10) Poison damage. *Success:*  Half damage.\\"}]"
---

# Iron Golem
*Large, Construct, Unaligned*

**AC** 20
**HP** 252 (24d10 + 120)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 24 | 9 | 20 | 3 | 11 | 1 |

CR 16, PB +5, XP 15000

## Traits

**Fire Absorption**
Whenever the golem is subjected to Fire damage, it regains a number of Hit Points equal to the Fire damage dealt.

**Immutable Form**
The golem can't shape-shift.

**Magic Resistance**
The golem has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The golem makes two attacks, using Bladed Arm or Fiery Bolt in any combination.

**Bladed Arm**
*Melee Attack Roll:* +12, reach 10 ft. 20 (3d8 + 7) Slashing damage plus 10 (3d6) Fire damage.

**Fiery Bolt**
*Ranged Attack Roll:* +10, range 120 ft. 36 (8d8) Fire damage.

**Poison Breath (Recharge 6)**
*Constitution Saving Throw*: DC 18, each creature in a 60-foot Cone. *Failure:*  55 (10d10) Poison damage. *Success:*  Half damage.
`,
      "knight.md": `---
smType: creature
name: "Knight"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "18"
hp: "52"
hit_dice: "8d8 + 16"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":15}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"con\\",\\"bonus\\":4},{\\"ability\\":\\"wis\\",\\"bonus\\":2}]"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The knight makes two attacks, using Greatsword or Heavy Crossbow in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Greatsword\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage plus 4 (1d8) Radiant damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Heavy Crossbow\\",\\"text\\":\\"*Ranged Attack Roll:* +2, range 100/400 ft. 11 (2d10) Piercing damage plus 4 (1d8) Radiant damage.\\"}]"
---

# Knight
*Small, Humanoid, Neutral Neutral*

**AC** 18
**HP** 52 (8d8 + 16)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 11 | 14 | 11 | 11 | 15 |

CR 3, PB +2, XP 700

## Actions

**Multiattack**
The knight makes two attacks, using Greatsword or Heavy Crossbow in any combination.

**Greatsword**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage plus 4 (1d8) Radiant damage.

**Heavy Crossbow**
*Ranged Attack Roll:* +2, range 100/400 ft. 11 (2d10) Piercing damage plus 4 (1d8) Radiant damage.
`,
      "kobold-warrior.md": `---
smType: creature
name: "Kobold Warrior"
size: "Small"
type: "Dragon"
alignment: "Neutral Neutral"
ac: "14"
hp: "7"
hit_dice: "3d6 - 3"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":7},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":9},{\\"ability\\":\\"int\\",\\"score\\":8},{\\"ability\\":\\"wis\\",\\"score\\":7},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The kobold has Advantage on an attack roll against a creature if at least one of the kobold's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Sunlight Sensitivity\\",\\"text\\":\\"While in sunlight, the kobold has Disadvantage on ability checks and attack rolls.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Dagger\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +4, reach 5 ft. or range 20/60 ft. 4 (1d4 + 2) Piercing damage.\\"}]"
---

# Kobold Warrior
*Small, Dragon, Neutral Neutral*

**AC** 14
**HP** 7 (3d6 - 3)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 7 | 15 | 9 | 8 | 7 | 8 |

CR 1/8, PB +2, XP 25

## Traits

**Pack Tactics**
The kobold has Advantage on an attack roll against a creature if at least one of the kobold's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

**Sunlight Sensitivity**
While in sunlight, the kobold has Disadvantage on ability checks and attack rolls.

## Actions

**Dagger**
*Melee or Ranged Attack Roll:* +4, reach 5 ft. or range 20/60 ft. 4 (1d4 + 2) Piercing damage.
`,
      "kraken.md": `---
smType: creature
name: "Kraken"
size: "Gargantuan"
type: "Monstrosity"
type_tags: ["Titan"]
alignment: "Chaotic Evil"
ac: "18"
hp: "481"
hit_dice: "26d20 + 208"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"120 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":30},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":26},{\\"ability\\":\\"int\\",\\"score\\":22},{\\"ability\\":\\"wis\\",\\"score\\":18},{\\"ability\\":\\"cha\\",\\"score\\":20}]"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":17},{\\"ability\\":\\"dex\\",\\"bonus\\":7},{\\"ability\\":\\"con\\",\\"bonus\\":15},{\\"ability\\":\\"wis\\",\\"bonus\\":11}]"
cr: "23"
xp: "50000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The kraken can breathe air and water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (4/Day, or 5/Day in Lair)\\",\\"text\\":\\"If the kraken fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Siege Monster\\",\\"text\\":\\"The kraken deals double damage to objects and structures.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The kraken makes two Tentacle attacks and uses Fling, Lightning Strike, or Swallow.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tentacle\\",\\"text\\":\\"*Melee Attack Roll:* +17, reach 30 ft. 24 (4d6 + 10) Bludgeoning damage. The target has the Grappled condition (escape DC 20) from one of ten tentacles, and it has the Restrained condition until the grapple ends.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fling\\",\\"text\\":\\"The kraken throws a Large or smaller creature Grappled by it to a space it can see within 60 feet of itself that isn't in the air. *Dexterity Saving Throw*: DC 25, the creature thrown and each creature in the destination space. *Failure:*  18 (4d8) Bludgeoning damage, and the target has the Prone condition. *Success:*  Half damage only.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Lightning Strike\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 23, one creature the kraken can see within 120 feet. *Failure:*  33 (6d10) Lightning damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Swallow\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 25, one creature Grappled by the kraken (it can have up to four creatures swallowed at a time). *Failure:*  23 (3d8 + 10) Piercing damage. If the target is Large or smaller, it is swallowed and no longer Grappled. A swallowed creature has the Restrained condition, has Cover|XPHB|Total Cover against attacks and other effects outside the kraken, and takes 24 (7d6) Acid damage at the start of each of its turns. If the kraken takes 50 damage or more on a single turn from a creature inside it, the kraken must succeed on a DC 25 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, each of which falls in a space within 10 feet of the kraken with the Prone condition. If the kraken dies, any swallowed creature no longer has the Restrained condition and can escape from the corpse using 15 feet of movement, exiting Prone.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Storm Bolt\\",\\"text\\":\\"The kraken uses Lightning Strike.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Toxic Ink\\",\\"text\\":\\"*Constitution Saving Throw*: DC 23, each creature in a 15-foot Emanation originating from the kraken while it is underwater. *Failure:*  The target has the Blinded and Poisoned conditions until the end of the kraken's next turn. The kraken then moves up to its Speed. *Failure or Success*:  The kraken can't take this action again until the start of its next turn.\\"}]"
---

# Kraken
*Gargantuan, Monstrosity, Chaotic Evil*

**AC** 18
**HP** 481 (26d20 + 208)
**Speed** 30 ft., swim 120 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 30 | 11 | 26 | 22 | 18 | 20 |

CR 23, XP 50000

## Traits

**Amphibious**
The kraken can breathe air and water.

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the kraken fails a saving throw, it can choose to succeed instead.

**Siege Monster**
The kraken deals double damage to objects and structures.

## Actions

**Multiattack**
The kraken makes two Tentacle attacks and uses Fling, Lightning Strike, or Swallow.

**Tentacle**
*Melee Attack Roll:* +17, reach 30 ft. 24 (4d6 + 10) Bludgeoning damage. The target has the Grappled condition (escape DC 20) from one of ten tentacles, and it has the Restrained condition until the grapple ends.

**Fling**
The kraken throws a Large or smaller creature Grappled by it to a space it can see within 60 feet of itself that isn't in the air. *Dexterity Saving Throw*: DC 25, the creature thrown and each creature in the destination space. *Failure:*  18 (4d8) Bludgeoning damage, and the target has the Prone condition. *Success:*  Half damage only.

**Lightning Strike**
*Dexterity Saving Throw*: DC 23, one creature the kraken can see within 120 feet. *Failure:*  33 (6d10) Lightning damage. *Success:*  Half damage.

**Swallow**
*Dexterity Saving Throw*: DC 25, one creature Grappled by the kraken (it can have up to four creatures swallowed at a time). *Failure:*  23 (3d8 + 10) Piercing damage. If the target is Large or smaller, it is swallowed and no longer Grappled. A swallowed creature has the Restrained condition, has Cover|XPHB|Total Cover against attacks and other effects outside the kraken, and takes 24 (7d6) Acid damage at the start of each of its turns. If the kraken takes 50 damage or more on a single turn from a creature inside it, the kraken must succeed on a DC 25 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, each of which falls in a space within 10 feet of the kraken with the Prone condition. If the kraken dies, any swallowed creature no longer has the Restrained condition and can escape from the corpse using 15 feet of movement, exiting Prone.

## Legendary Actions

**Storm Bolt**
The kraken uses Lightning Strike.

**Toxic Ink**
*Constitution Saving Throw*: DC 23, each creature in a 15-foot Emanation originating from the kraken while it is underwater. *Failure:*  The target has the Blinded and Poisoned conditions until the end of the kraken's next turn. The kraken then moves up to its Speed. *Failure or Success*:  The kraken can't take this action again until the start of its next turn.
`,
      "lamia.md": `---
smType: creature
name: "Lamia"
size: "Large"
type: "Fiend"
alignment: "Chaotic Evil"
ac: "13"
hp: "97"
hit_dice: "13d10 + 26"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":14},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":16}]"
pb: "+2"
cr: "4"
xp: "1100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The lamia makes two Claw attacks. It can replace one attack with a use of Corrupting Touch.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Slashing damage plus 7 (2d6) Psychic damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Corrupting Touch\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 13, one creature the lamia can see within 5 feet. *Failure:*  13 (3d8) Psychic damage, and the target is cursed for 1 hour. Until the curse ends, the target has the Charmed and Poisoned conditions.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The lamia casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 13): - **At Will:** *Disguise Self*, *Minor Illusion* - **1e/Day Each:** *Geas*, *Major Image*, *Scrying*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Leap\\",\\"text\\":\\"The lamia jumps up to 30 feet by spending 10 feet of movement.\\"}]"
---

# Lamia
*Large, Fiend, Chaotic Evil*

**AC** 13
**HP** 97 (13d10 + 26)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 13 | 15 | 14 | 15 | 16 |

CR 4, PB +2, XP 1100

## Actions

**Multiattack**
The lamia makes two Claw attacks. It can replace one attack with a use of Corrupting Touch.

**Claw**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Slashing damage plus 7 (2d6) Psychic damage.

**Corrupting Touch**
*Wisdom Saving Throw*: DC 13, one creature the lamia can see within 5 feet. *Failure:*  13 (3d8) Psychic damage, and the target is cursed for 1 hour. Until the curse ends, the target has the Charmed and Poisoned conditions.

**Spellcasting**
The lamia casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 13): - **At Will:** *Disguise Self*, *Minor Illusion* - **1e/Day Each:** *Geas*, *Major Image*, *Scrying*

## Bonus Actions

**Leap**
The lamia jumps up to 30 feet by spending 10 feet of movement.
`,
      "lemure.md": `---
smType: creature
name: "Lemure"
size: "Medium"
type: "Fiend"
type_tags: ["Devil"]
alignment: "Lawful Evil"
ac: "9"
hp: "9"
hit_dice: "2d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":5},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+2"
cr: "0"
xp: "0"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Hellish Restoration\\",\\"text\\":\\"If the lemure dies in the Nine Hells, it revives with all its Hit Points in 1d10 days unless it is killed by a creature under the effects of a *Bless* spell or its remains are sprinkled with Holy Water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Vile Slime\\",\\"text\\":\\"*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Poison damage.\\"}]"
---

# Lemure
*Medium, Fiend, Lawful Evil*

**AC** 9
**HP** 9 (2d8)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 5 | 11 | 1 | 11 | 3 |

CR 0, PB +2, XP 0

## Traits

**Hellish Restoration**
If the lemure dies in the Nine Hells, it revives with all its Hit Points in 1d10 days unless it is killed by a creature under the effects of a *Bless* spell or its remains are sprinkled with Holy Water.

## Actions

**Vile Slime**
*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Poison damage.
`,
      "lich.md": `---
smType: creature
name: "Lich"
size: "Medium"
type: "Undead"
type_tags: ["Wizard"]
alignment: "Neutral Evil"
ac: "20"
hp: "315"
hit_dice: "42d8 + 126"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":11},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":21},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":16}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":10},{\\"ability\\":\\"con\\",\\"bonus\\":10},{\\"ability\\":\\"int\\",\\"bonus\\":12},{\\"ability\\":\\"wis\\",\\"bonus\\":9}]"
cr: "21"
xp: "33000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (4/Day, or 5/Day in Lair)\\",\\"text\\":\\"If the lich fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Spirit Jar\\",\\"text\\":\\"If destroyed, the lich reforms in 1d10 days if it has a spirit jar, reviving with all its Hit Points. The new body appears in an unoccupied space within the lich's lair.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The lich makes three attacks, using Eldritch Burst or Paralyzing Touch in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Eldritch Burst\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +12, reach 5 ft. or range 120 ft. 31 (4d12 + 5) Force damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Paralyzing Touch\\",\\"text\\":\\"*Melee Attack Roll:* +12, reach 5 ft. 15 (3d6 + 5) Cold damage, and the target has the Paralyzed condition until the start of the lich's next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The lich casts one of the following spells, using Intelligence as the spellcasting ability (spell save DC 20): - **At Will:** *Detect Magic*, *Detect Thoughts*, *Dispel Magic*, *Fireball*, *Invisibility*, *Lightning Bolt*, *Mage Hand*, *Prestidigitation* - **2e/Day Each:** *Animate Dead*, *Dimension Door*, *Plane Shift* - **1e/Day Each:** *Chain Lightning*, *Finger of Death*, *Power Word Kill*, *Scrying*\\"},{\\"category\\":\\"reaction\\",\\"name\\":\\"Protective Magic\\",\\"text\\":\\"The lich casts *Counterspell* or *Shield* in response to the spell's trigger, using the same spellcasting ability as Spellcasting.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Deathly Teleport\\",\\"text\\":\\"The lich teleports up to 60 feet to an unoccupied space it can see, and each creature within 10 feet of the space it left takes 11 (2d10) Necrotic damage.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Disrupt Life\\",\\"text\\":\\"*Constitution Saving Throw*: DC 20, each creature that isn't an Undead in a 20-foot Emanation originating from the lich. *Failure:*  31 (9d6) Necrotic damage. *Success:*  Half damage. *Failure or Success*:  The lich can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Frightening Gaze\\",\\"text\\":\\"The lich casts *Fear*, using the same spellcasting ability as Spellcasting. The lich can't take this action again until the start of its next turn.\\"}]"
---

# Lich
*Medium, Undead, Neutral Evil*

**AC** 20
**HP** 315 (42d8 + 126)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 11 | 16 | 16 | 21 | 14 | 16 |

CR 21, XP 33000

## Traits

**Legendary Resistance (4/Day, or 5/Day in Lair)**
If the lich fails a saving throw, it can choose to succeed instead.

**Spirit Jar**
If destroyed, the lich reforms in 1d10 days if it has a spirit jar, reviving with all its Hit Points. The new body appears in an unoccupied space within the lich's lair.

## Actions

**Multiattack**
The lich makes three attacks, using Eldritch Burst or Paralyzing Touch in any combination.

**Eldritch Burst**
*Melee or Ranged Attack Roll:* +12, reach 5 ft. or range 120 ft. 31 (4d12 + 5) Force damage.

**Paralyzing Touch**
*Melee Attack Roll:* +12, reach 5 ft. 15 (3d6 + 5) Cold damage, and the target has the Paralyzed condition until the start of the lich's next turn.

**Spellcasting**
The lich casts one of the following spells, using Intelligence as the spellcasting ability (spell save DC 20): - **At Will:** *Detect Magic*, *Detect Thoughts*, *Dispel Magic*, *Fireball*, *Invisibility*, *Lightning Bolt*, *Mage Hand*, *Prestidigitation* - **2e/Day Each:** *Animate Dead*, *Dimension Door*, *Plane Shift* - **1e/Day Each:** *Chain Lightning*, *Finger of Death*, *Power Word Kill*, *Scrying*

## Reactions

**Protective Magic**
The lich casts *Counterspell* or *Shield* in response to the spell's trigger, using the same spellcasting ability as Spellcasting.

## Legendary Actions

**Deathly Teleport**
The lich teleports up to 60 feet to an unoccupied space it can see, and each creature within 10 feet of the space it left takes 11 (2d10) Necrotic damage.

**Disrupt Life**
*Constitution Saving Throw*: DC 20, each creature that isn't an Undead in a 20-foot Emanation originating from the lich. *Failure:*  31 (9d6) Necrotic damage. *Success:*  Half damage. *Failure or Success*:  The lich can't take this action again until the start of its next turn.

**Frightening Gaze**
The lich casts *Fear*, using the same spellcasting ability as Spellcasting. The lich can't take this action again until the start of its next turn.
`,
      "mage.md": `---
smType: creature
name: "Mage"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "15"
hp: "81"
hit_dice: "18d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":9},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":17},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"int\\",\\"bonus\\":6},{\\"ability\\":\\"wis\\",\\"bonus\\":4}]"
cr: "6"
xp: "2300"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The mage makes three Arcane Burst attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Arcane Burst\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +6, reach 5 ft. or range 120 ft. 16 (3d8 + 3) Force damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The mage casts one of the following spells, using Intelligence as the spellcasting ability (spell save DC 14): - **At Will:** *Detect Magic*, *Light*, *Mage Armor*, *Mage Hand*, *Prestidigitation* - **2e/Day Each:** *Fireball*, *Invisibility* - **1e/Day Each:** *Cone of Cold*, *Fly*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Misty Step (3/Day)\\",\\"text\\":\\"The mage casts *Misty Step*, using the same spellcasting ability as Spellcasting.\\"},{\\"category\\":\\"reaction\\",\\"name\\":\\"Protective Magic (3/Day)\\",\\"text\\":\\"The mage casts *Counterspell* or *Shield* in response to the spell's trigger, using the same spellcasting ability as Spellcasting.\\"}]"
---

# Mage
*Small, Humanoid, Neutral Neutral*

**AC** 15
**HP** 81 (18d8)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 9 | 14 | 11 | 17 | 12 | 11 |

CR 6, PB +3, XP 2300

## Actions

**Multiattack**
The mage makes three Arcane Burst attacks.

**Arcane Burst**
*Melee or Ranged Attack Roll:* +6, reach 5 ft. or range 120 ft. 16 (3d8 + 3) Force damage.

**Spellcasting**
The mage casts one of the following spells, using Intelligence as the spellcasting ability (spell save DC 14): - **At Will:** *Detect Magic*, *Light*, *Mage Armor*, *Mage Hand*, *Prestidigitation* - **2e/Day Each:** *Fireball*, *Invisibility* - **1e/Day Each:** *Cone of Cold*, *Fly*

## Bonus Actions

**Misty Step (3/Day)**
The mage casts *Misty Step*, using the same spellcasting ability as Spellcasting.

## Reactions

**Protective Magic (3/Day)**
The mage casts *Counterspell* or *Shield* in response to the spell's trigger, using the same spellcasting ability as Spellcasting.
`,
      "magma-mephit.md": `---
smType: creature
name: "Magma Mephit"
size: "Small"
type: "Elemental"
alignment: "Neutral Evil"
ac: "11"
hp: "18"
hit_dice: "4d6 + 4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":8},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":7},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Death Burst\\",\\"text\\":\\"The mephit explodes when it dies. *Dexterity Saving Throw*: DC 11, each creature in a 5-foot Emanation originating from the mephit. *Failure:*  7 (2d6) Fire damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 3 (1d4 + 1) Slashing damage plus 3 (1d6) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fire Breath\\",\\"recharge\\":\\"Recharge 6\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 11, each creature in a 15-foot Cone. *Failure:*  7 (2d6) Fire damage. *Success:*  Half damage.\\"}]"
---

# Magma Mephit
*Small, Elemental, Neutral Evil*

**AC** 11
**HP** 18 (4d6 + 4)
**Speed** 30 ft., fly 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 8 | 12 | 12 | 7 | 10 | 10 |

CR 1/2, PB +2, XP 100

## Traits

**Death Burst**
The mephit explodes when it dies. *Dexterity Saving Throw*: DC 11, each creature in a 5-foot Emanation originating from the mephit. *Failure:*  7 (2d6) Fire damage. *Success:*  Half damage.

## Actions

**Claw**
*Melee Attack Roll:* +3, reach 5 ft. 3 (1d4 + 1) Slashing damage plus 3 (1d6) Fire damage.

**Fire Breath (Recharge 6)**
*Dexterity Saving Throw*: DC 11, each creature in a 15-foot Cone. *Failure:*  7 (2d6) Fire damage. *Success:*  Half damage.
`,
      "magmin.md": `---
smType: creature
name: "Magmin"
size: "Small"
type: "Elemental"
alignment: "Chaotic Neutral"
ac: "14"
hp: "13"
hit_dice: "3d6 + 3"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":7},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":8},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Death Burst\\",\\"text\\":\\"The magmin explodes when it dies. *Dexterity Saving Throw*: DC 11, each creature in a 10-foot Emanation originating from the magmin. *Failure:*  7 (2d6) Fire damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Touch\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 7 (2d4 + 2) Fire damage. If the target is a creature or a flammable object that isn't being worn or carried, it starts burning.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Ignited Illumination\\",\\"text\\":\\"The magmin sets itself ablaze or extinguishes its flames. While ablaze, the magmin sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.\\"}]"
---

# Magmin
*Small, Elemental, Chaotic Neutral*

**AC** 14
**HP** 13 (3d6 + 3)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 7 | 15 | 12 | 8 | 11 | 10 |

CR 1/2, PB +2, XP 100

## Traits

**Death Burst**
The magmin explodes when it dies. *Dexterity Saving Throw*: DC 11, each creature in a 10-foot Emanation originating from the magmin. *Failure:*  7 (2d6) Fire damage. *Success:*  Half damage.

## Actions

**Touch**
*Melee Attack Roll:* +4, reach 5 ft. 7 (2d4 + 2) Fire damage. If the target is a creature or a flammable object that isn't being worn or carried, it starts burning.

## Bonus Actions

**Ignited Illumination**
The magmin sets itself ablaze or extinguishes its flames. While ablaze, the magmin sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.
`,
      "manticore.md": `---
smType: creature
name: "Manticore"
size: "Large"
type: "Monstrosity"
alignment: "Lawful Evil"
ac: "14"
hp: "68"
hit_dice: "8d10 + 24"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":7},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The manticore makes three attacks, using Rend or Tail Spike in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tail Spike\\",\\"text\\":\\"*Ranged Attack Roll:* +5, range 100/200 ft. 7 (1d8 + 3) Piercing damage.\\"}]"
---

# Manticore
*Large, Monstrosity, Lawful Evil*

**AC** 14
**HP** 68 (8d10 + 24)
**Speed** 30 ft., fly 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 16 | 17 | 7 | 12 | 8 |

CR 3, PB +2, XP 700

## Actions

**Multiattack**
The manticore makes three attacks, using Rend or Tail Spike in any combination.

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Slashing damage.

**Tail Spike**
*Ranged Attack Roll:* +5, range 100/200 ft. 7 (1d8 + 3) Piercing damage.
`,
      "marilith.md": `---
smType: creature
name: "Marilith"
size: "Large"
type: "Fiend"
type_tags: ["Demon"]
alignment: "Chaotic Evil"
ac: "16"
hp: "220"
hit_dice: "21d10 + 105"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":20},{\\"ability\\":\\"con\\",\\"score\\":20},{\\"ability\\":\\"int\\",\\"score\\":18},{\\"ability\\":\\"wis\\",\\"score\\":16},{\\"ability\\":\\"cha\\",\\"score\\":20}]"
pb: "+5"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":9},{\\"ability\\":\\"con\\",\\"bonus\\":10},{\\"ability\\":\\"wis\\",\\"bonus\\":8},{\\"ability\\":\\"cha\\",\\"bonus\\":10}]"
cr: "16"
xp: "15000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Demonic Restoration\\",\\"text\\":\\"If the marilith dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The marilith has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Reactive\\",\\"text\\":\\"The marilith can take one Reaction on every turn of combat.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The marilith makes six Pact Blade attacks and uses Constrict.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Pact Blade\\",\\"text\\":\\"*Melee Attack Roll:* +10, reach 5 ft. 10 (1d10 + 5) Slashing damage plus 7 (2d6) Necrotic damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Constrict\\",\\"text\\":\\"*Strength Saving Throw*: DC 17, one Medium or smaller creature the marilith can see within 5 feet. *Failure:*  15 (2d10 + 4) Bludgeoning damage. The target has the Grappled condition (escape DC 14), and it has the Restrained condition until the grapple ends.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Teleport (Recharge 5-6)\\",\\"text\\":\\"The marilith teleports up to 120 feet to an unoccupied space it can see.\\"}]"
---

# Marilith
*Large, Fiend, Chaotic Evil*

**AC** 16
**HP** 220 (21d10 + 105)
**Speed** 40 ft., climb 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 20 | 20 | 18 | 16 | 20 |

CR 16, PB +5, XP 15000

## Traits

**Demonic Restoration**
If the marilith dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.

**Magic Resistance**
The marilith has Advantage on saving throws against spells and other magical effects.

**Reactive**
The marilith can take one Reaction on every turn of combat.

## Actions

**Multiattack**
The marilith makes six Pact Blade attacks and uses Constrict.

**Pact Blade**
*Melee Attack Roll:* +10, reach 5 ft. 10 (1d10 + 5) Slashing damage plus 7 (2d6) Necrotic damage.

**Constrict**
*Strength Saving Throw*: DC 17, one Medium or smaller creature the marilith can see within 5 feet. *Failure:*  15 (2d10 + 4) Bludgeoning damage. The target has the Grappled condition (escape DC 14), and it has the Restrained condition until the grapple ends.

## Bonus Actions

**Teleport (Recharge 5-6)**
The marilith teleports up to 120 feet to an unoccupied space it can see.
`,
      "medusa.md": `---
smType: creature
name: "Medusa"
size: "Medium"
type: "Monstrosity"
alignment: "Lawful Evil"
ac: "15"
hp: "127"
hit_dice: "17d8 + 51"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":15}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"wis\\",\\"bonus\\":4}]"
cr: "6"
xp: "2300"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The medusa makes two Claw attacks and one Snake Hair attack, or it makes three Poison Ray attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 10 (2d6 + 3) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Snake Hair\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 5 (1d4 + 3) Piercing damage plus 14 (4d6) Poison damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Poison Ray\\",\\"text\\":\\"*Ranged Attack Roll:* +5, range 150 ft. 11 (2d8 + 2) Poison damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Petrifying Gaze (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 13, each creature in a 30-foot Cone. If the medusa sees its reflection in the Cone, the medusa must make this save. *First Failure* The target has the Restrained condition and repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition instead of the Restrained condition.\\"}]"
---

# Medusa
*Medium, Monstrosity, Lawful Evil*

**AC** 15
**HP** 127 (17d8 + 51)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 17 | 16 | 12 | 13 | 15 |

CR 6, PB +3, XP 2300

## Actions

**Multiattack**
The medusa makes two Claw attacks and one Snake Hair attack, or it makes three Poison Ray attacks.

**Claw**
*Melee Attack Roll:* +6, reach 5 ft. 10 (2d6 + 3) Slashing damage.

**Snake Hair**
*Melee Attack Roll:* +6, reach 5 ft. 5 (1d4 + 3) Piercing damage plus 14 (4d6) Poison damage.

**Poison Ray**
*Ranged Attack Roll:* +5, range 150 ft. 11 (2d8 + 2) Poison damage.

## Bonus Actions

**Petrifying Gaze (Recharge 5-6)**
*Constitution Saving Throw*: DC 13, each creature in a 30-foot Cone. If the medusa sees its reflection in the Cone, the medusa must make this save. *First Failure* The target has the Restrained condition and repeats the save at the end of its next turn if it is still Restrained, ending the effect on itself on a success. *Second Failure* The target has the Petrified condition instead of the Restrained condition.
`,
      "merfolk-skirmisher.md": `---
smType: creature
name: "Merfolk Skirmisher"
size: "Medium"
type: "Elemental"
alignment: "Neutral Neutral"
ac: "11"
hp: "11"
hit_dice: "2d8 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":12}]"
pb: "+2"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The merfolk can breathe air and water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Ocean Spear\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +2, reach 5 ft. or range 20/60 ft. 3 (1d6) Piercing damage plus 2 (1d4) Cold damage. If the target is a creature, its Speed decreases by 10 feet until the end of its next turn. HitomThe spear magically returns to the merfolk's hand immediately after a ranged attack.\\"}]"
---

# Merfolk Skirmisher
*Medium, Elemental, Neutral Neutral*

**AC** 11
**HP** 11 (2d8 + 2)
**Speed** 10 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 13 | 12 | 11 | 14 | 12 |

CR 1/8, PB +2, XP 25

## Traits

**Amphibious**
The merfolk can breathe air and water.

## Actions

**Ocean Spear**
*Melee or Ranged Attack Roll:* +2, reach 5 ft. or range 20/60 ft. 3 (1d6) Piercing damage plus 2 (1d4) Cold damage. If the target is a creature, its Speed decreases by 10 feet until the end of its next turn. HitomThe spear magically returns to the merfolk's hand immediately after a ranged attack.
`,
      "merrow.md": `---
smType: creature
name: "Merrow"
size: "Large"
type: "Monstrosity"
alignment: "Chaotic Evil"
ac: "13"
hp: "45"
hit_dice: "6d10 + 12"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":8},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":9}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The merrow can breathe air and water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The merrow makes two attacks, using Bite, Claw, or Harpoon in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 6 (1d4 + 4) Piercing damage, and the target has the Poisoned condition until the end of the merrow's next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 9 (2d4 + 4) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Harpoon\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +6, reach 5 ft. or range 20/60 ft. 11 (2d6 + 4) Piercing damage. If the target is a Large or smaller creature, the merrow pulls the target up to 15 feet straight toward itself.\\"}]"
---

# Merrow
*Large, Monstrosity, Chaotic Evil*

**AC** 13
**HP** 45 (6d10 + 12)
**Speed** 10 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 15 | 15 | 8 | 10 | 9 |

CR 2, PB +2, XP 450

## Traits

**Amphibious**
The merrow can breathe air and water.

## Actions

**Multiattack**
The merrow makes two attacks, using Bite, Claw, or Harpoon in any combination.

**Bite**
*Melee Attack Roll:* +6, reach 5 ft. 6 (1d4 + 4) Piercing damage, and the target has the Poisoned condition until the end of the merrow's next turn.

**Claw**
*Melee Attack Roll:* +6, reach 5 ft. 9 (2d4 + 4) Slashing damage.

**Harpoon**
*Melee or Ranged Attack Roll:* +6, reach 5 ft. or range 20/60 ft. 11 (2d6 + 4) Piercing damage. If the target is a Large or smaller creature, the merrow pulls the target up to 15 feet straight toward itself.
`,
      "mimic.md": `---
smType: creature
name: "Mimic"
size: "Medium"
type: "Monstrosity"
alignment: "Neutral Neutral"
ac: "12"
hp: "58"
hit_dice: "9d8 + 18"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":5},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Adhesive (Object Form Only)\\",\\"text\\":\\"The mimic adheres to anything that touches it. A Huge or smaller creature adhered to the mimic has the Grappled condition (escape DC 13). Ability checks made to escape this grapple have Disadvantage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5 (with Advantage if the target is Grappled by the mimic), reach 5 ft. 7 (1d8 + 3) Piercing damage\u2014or 12 (2d8 + 3) Piercing damage if the target is Grappled by the mimic\u2014plus 4 (1d8) Acid damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Pseudopod\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Bludgeoning damage plus 4 (1d8) Acid damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13). Ability checks made to escape this grapple have Disadvantage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Shape-Shift\\",\\"text\\":\\"The mimic shape-shifts to resemble a Medium or Small object while retaining its game statistics, or it returns to its true blob form. Any equipment it is wearing or carrying isn't transformed.\\"}]"
---

# Mimic
*Medium, Monstrosity, Neutral Neutral*

**AC** 12
**HP** 58 (9d8 + 18)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 12 | 15 | 5 | 13 | 8 |

CR 2, PB +2, XP 450

## Traits

**Adhesive (Object Form Only)**
The mimic adheres to anything that touches it. A Huge or smaller creature adhered to the mimic has the Grappled condition (escape DC 13). Ability checks made to escape this grapple have Disadvantage.

## Actions

**Bite**
*Melee Attack Roll:* +5 (with Advantage if the target is Grappled by the mimic), reach 5 ft. 7 (1d8 + 3) Piercing damage\u2014or 12 (2d8 + 3) Piercing damage if the target is Grappled by the mimic\u2014plus 4 (1d8) Acid damage.

**Pseudopod**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Bludgeoning damage plus 4 (1d8) Acid damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 13). Ability checks made to escape this grapple have Disadvantage.

## Bonus Actions

**Shape-Shift**
The mimic shape-shifts to resemble a Medium or Small object while retaining its game statistics, or it returns to its true blob form. Any equipment it is wearing or carrying isn't transformed.
`,
      "minotaur-of-baphomet.md": `---
smType: creature
name: "Minotaur of Baphomet"
size: "Large"
type: "Monstrosity"
alignment: "Chaotic Evil"
ac: "14"
hp: "85"
hit_dice: "10d10 + 30"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":16},{\\"ability\\":\\"cha\\",\\"score\\":9}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Abyssal Glaive\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 10 ft. 10 (1d12 + 4) Slashing damage plus 10 (3d6) Necrotic damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Gore (Recharge 5-6)\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 18 (4d6 + 4) Piercing damage. If the target is a Large or smaller creature and the minotaur moved 10+ feet straight toward it immediately before the hit, the target takes an extra 10 (3d6) Piercing damage and has the Prone condition.\\"}]"
---

# Minotaur of Baphomet
*Large, Monstrosity, Chaotic Evil*

**AC** 14
**HP** 85 (10d10 + 30)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 11 | 16 | 6 | 16 | 9 |

CR 3, PB +2, XP 700

## Actions

**Abyssal Glaive**
*Melee Attack Roll:* +6, reach 10 ft. 10 (1d12 + 4) Slashing damage plus 10 (3d6) Necrotic damage.

**Gore (Recharge 5-6)**
*Melee Attack Roll:* +6, reach 5 ft. 18 (4d6 + 4) Piercing damage. If the target is a Large or smaller creature and the minotaur moved 10+ feet straight toward it immediately before the hit, the target takes an extra 10 (3d6) Piercing damage and has the Prone condition.
`,
      "minotaur-skeleton.md": `---
smType: creature
name: "Minotaur Skeleton"
size: "Large"
type: "Undead"
alignment: "Lawful Evil"
ac: "12"
hp: "45"
hit_dice: "6d10 + 12"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":8},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Gore\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 11 (2d6 + 4) Piercing damage. If the target is a Large or smaller creature and the skeleton moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Slam\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 15 (2d10 + 4) Bludgeoning damage.\\"}]"
---

# Minotaur Skeleton
*Large, Undead, Lawful Evil*

**AC** 12
**HP** 45 (6d10 + 12)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 11 | 15 | 6 | 8 | 5 |

CR 2, PB +2, XP 450

## Actions

**Gore**
*Melee Attack Roll:* +6, reach 5 ft. 11 (2d6 + 4) Piercing damage. If the target is a Large or smaller creature and the skeleton moved 20+ feet straight toward it immediately before the hit, the target takes an extra 9 (2d8) Piercing damage and has the Prone condition.

**Slam**
*Melee Attack Roll:* +6, reach 5 ft. 15 (2d10 + 4) Bludgeoning damage.
`,
      "mummy-lord.md": `---
smType: creature
name: "Mummy Lord"
size: "Small"
type: "Undead"
alignment: "Lawful Evil"
ac: "17"
hp: "187"
hit_dice: "25d8 + 75"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":19},{\\"ability\\":\\"cha\\",\\"score\\":16}]"
saves_json: "[{\\"ability\\":\\"int\\",\\"bonus\\":5},{\\"ability\\":\\"wis\\",\\"bonus\\":9}]"
cr: "15"
xp: "13000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day, or 4/Day in Lair)\\",\\"text\\":\\"If the mummy fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The mummy has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Undead Restoration\\",\\"text\\":\\"If destroyed, the mummy gains a new body in 24 hours if its heart is intact, reviving with all its Hit Points. The new body appears in an unoccupied space within the mummy's lair. The heart is a Tiny object that has AC 17, HP 10, and Immunity to all damage except Fire.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The mummy makes one Rotting Fist or Channel Negative Energy attack, and it uses Dreadful Glare.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rotting Fist\\",\\"text\\":\\"*Melee Attack Roll:* +9, reach 5 ft. 15 (2d10 + 4) Bludgeoning damage plus 10 (3d6) Necrotic damage. If the target is a creature, it is cursed. While cursed, the target can't regain Hit Points, it gains no benefit from finishing a Long Rest, and its Hit Point maximum decreases by 10 (3d6) every 24 hours that elapse. A creature dies and turns to dust if reduced to 0 Hit Points by this attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Channel Negative Energy\\",\\"text\\":\\"*Ranged Attack Roll:* +9, range 60 ft. 25 (6d6 + 4) Necrotic damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Dreadful Glare\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 17, one creature the mummy can see within 60 feet. *Failure:*  25 (6d6 + 4) Psychic damage, and the target has the Paralyzed condition until the end of the mummy's next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The mummy casts one of the following spells, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 17, +9 to hit with spell attacks): - **At Will:** *Dispel Magic*, *Thaumaturgy* - **1e/Day Each:** *Animate Dead*, *Harm*, *Insect Plague*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Glare\\",\\"text\\":\\"The mummy uses Dreadful Glare. The mummy can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Necrotic Strike\\",\\"text\\":\\"The mummy makes one Rotting Fist or Channel Negative Energy attack.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Dread Command\\",\\"text\\":\\"The mummy casts *Command* (level 2 version), using the same spellcasting ability as Spellcasting. The mummy can't take this action again until the start of its next turn.\\"}]"
---

# Mummy Lord
*Small, Undead, Lawful Evil*

**AC** 17
**HP** 187 (25d8 + 75)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 10 | 17 | 11 | 19 | 16 |

CR 15, XP 13000

## Traits

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the mummy fails a saving throw, it can choose to succeed instead.

**Magic Resistance**
The mummy has Advantage on saving throws against spells and other magical effects.

**Undead Restoration**
If destroyed, the mummy gains a new body in 24 hours if its heart is intact, reviving with all its Hit Points. The new body appears in an unoccupied space within the mummy's lair. The heart is a Tiny object that has AC 17, HP 10, and Immunity to all damage except Fire.

## Actions

**Multiattack**
The mummy makes one Rotting Fist or Channel Negative Energy attack, and it uses Dreadful Glare.

**Rotting Fist**
*Melee Attack Roll:* +9, reach 5 ft. 15 (2d10 + 4) Bludgeoning damage plus 10 (3d6) Necrotic damage. If the target is a creature, it is cursed. While cursed, the target can't regain Hit Points, it gains no benefit from finishing a Long Rest, and its Hit Point maximum decreases by 10 (3d6) every 24 hours that elapse. A creature dies and turns to dust if reduced to 0 Hit Points by this attack.

**Channel Negative Energy**
*Ranged Attack Roll:* +9, range 60 ft. 25 (6d6 + 4) Necrotic damage.

**Dreadful Glare**
*Wisdom Saving Throw*: DC 17, one creature the mummy can see within 60 feet. *Failure:*  25 (6d6 + 4) Psychic damage, and the target has the Paralyzed condition until the end of the mummy's next turn.

**Spellcasting**
The mummy casts one of the following spells, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 17, +9 to hit with spell attacks): - **At Will:** *Dispel Magic*, *Thaumaturgy* - **1e/Day Each:** *Animate Dead*, *Harm*, *Insect Plague*

## Legendary Actions

**Glare**
The mummy uses Dreadful Glare. The mummy can't take this action again until the start of its next turn.

**Necrotic Strike**
The mummy makes one Rotting Fist or Channel Negative Energy attack.

**Dread Command**
The mummy casts *Command* (level 2 version), using the same spellcasting ability as Spellcasting. The mummy can't take this action again until the start of its next turn.
`,
      "mummy.md": `---
smType: creature
name: "Mummy"
size: "Small"
type: "Undead"
alignment: "Lawful Evil"
ac: "11"
hp: "58"
hit_dice: "9d8 + 18"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":8},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":12}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"wis\\",\\"bonus\\":3}]"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The mummy makes two Rotting Fist attacks and uses Dreadful Glare.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rotting Fist\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Bludgeoning damage plus 10 (3d6) Necrotic damage. If the target is a creature, it is cursed. While cursed, the target can't regain Hit Points, its Hit Point maximum doesn't return to normal when finishing a Long Rest, and its Hit Point maximum decreases by 10 (3d6) every 24 hours that elapse. A creature dies and turns to dust if reduced to 0 Hit Points by this attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Dreadful Glare\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 11, one creature the mummy can see within 60 feet. *Failure:*  The target has the Frightened condition until the end of the mummy's next turn. *Success:*  The target is immune to this mummy's Dreadful Glare for 24 hours.\\"}]"
---

# Mummy
*Small, Undead, Lawful Evil*

**AC** 11
**HP** 58 (9d8 + 18)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 8 | 15 | 6 | 12 | 12 |

CR 3, PB +2, XP 700

## Actions

**Multiattack**
The mummy makes two Rotting Fist attacks and uses Dreadful Glare.

**Rotting Fist**
*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Bludgeoning damage plus 10 (3d6) Necrotic damage. If the target is a creature, it is cursed. While cursed, the target can't regain Hit Points, its Hit Point maximum doesn't return to normal when finishing a Long Rest, and its Hit Point maximum decreases by 10 (3d6) every 24 hours that elapse. A creature dies and turns to dust if reduced to 0 Hit Points by this attack.

**Dreadful Glare**
*Wisdom Saving Throw*: DC 11, one creature the mummy can see within 60 feet. *Failure:*  The target has the Frightened condition until the end of the mummy's next turn. *Success:*  The target is immune to this mummy's Dreadful Glare for 24 hours.
`,
      "nalfeshnee.md": `---
smType: creature
name: "Nalfeshnee"
size: "Large"
type: "Fiend"
type_tags: ["Demon"]
alignment: "Chaotic Evil"
ac: "18"
hp: "184"
hit_dice: "16d10 + 96"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"fly\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":21},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":22},{\\"ability\\":\\"int\\",\\"score\\":19},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":15}]"
pb: "+5"
saves_json: "[{\\"ability\\":\\"con\\",\\"bonus\\":11},{\\"ability\\":\\"int\\",\\"bonus\\":9},{\\"ability\\":\\"wis\\",\\"bonus\\":6},{\\"ability\\":\\"cha\\",\\"bonus\\":7}]"
cr: "13"
xp: "10000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Demonic Restoration\\",\\"text\\":\\"If the nalfeshnee dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The nalfeshnee has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The nalfeshnee makes three Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +10, reach 10 ft. 16 (2d10 + 5) Slashing damage plus 11 (2d10) Force damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Teleport\\",\\"text\\":\\"The nalfeshnee teleports up to 120 feet to an unoccupied space it can see.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Horror Nimbus (Recharge 5-6)\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 15, each creature in a 15-foot Emanation originating from the nalfeshnee. *Failure:*  28 (8d6) Psychic damage, and the target has the Frightened condition for 1 minute, until it takes damage, or until it ends its turn with the nalfeshnee out of line of sight. *Success:*  The target is immune to this nalfeshnee's Horror Nimbus for 24 hours.\\"}]"
---

# Nalfeshnee
*Large, Fiend, Chaotic Evil*

**AC** 18
**HP** 184 (16d10 + 96)
**Speed** 20 ft., fly 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 21 | 10 | 22 | 19 | 12 | 15 |

CR 13, PB +5, XP 10000

## Traits

**Demonic Restoration**
If the nalfeshnee dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.

**Magic Resistance**
The nalfeshnee has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The nalfeshnee makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +10, reach 10 ft. 16 (2d10 + 5) Slashing damage plus 11 (2d10) Force damage.

**Teleport**
The nalfeshnee teleports up to 120 feet to an unoccupied space it can see.

## Bonus Actions

**Horror Nimbus (Recharge 5-6)**
*Wisdom Saving Throw*: DC 15, each creature in a 15-foot Emanation originating from the nalfeshnee. *Failure:*  28 (8d6) Psychic damage, and the target has the Frightened condition for 1 minute, until it takes damage, or until it ends its turn with the nalfeshnee out of line of sight. *Success:*  The target is immune to this nalfeshnee's Horror Nimbus for 24 hours.
`,
      "night-hag.md": `---
smType: creature
name: "Night Hag"
size: "Medium"
type: "Fiend"
alignment: "Neutral Evil"
ac: "17"
hp: "112"
hit_dice: "15d8 + 45"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":16}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The hag has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Soul Bag\\",\\"text\\":\\"The hag has a soul bag. While holding or carrying the bag, the hag can use its Nightmare Haunting action. The bag has AC 15, HP 20, and Resistance to all damage. The bag turns to dust if reduced to 0 Hit Points. If the bag is destroyed, any souls the bag is holding are released. The hag can create a new bag after 7 days.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The hag makes two Claw attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The hag casts one of the following spells, requiring no Material components and using Intelligence as the spellcasting ability (spell save DC 14): - **At Will:** *Detect Magic*, *Etherealness*, *Magic Missile* - **2e/Day Each:** *Phantasmal Killer*, *Plane Shift*\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Nightmare Haunting (1/Day; Requires Soul Bag)\\",\\"text\\":\\"While on the Ethereal Plane, the hag casts *Dream*, using the same spellcasting ability as Spellcasting. Only the hag can serve as the spell's messenger, and the target must be a creature the hag can see on the Material Plane. The spell fails and is wasted if the target is under the effect of the *Protection from Evil and Good* spell or within a *Magic Circle* spell. If the target takes damage from the *Dream* spell, the target's Hit Point maximum decreases by an amount equal to that damage. If the spell kills the target, its soul is trapped in the hag's soul bag, and the target can't be raised from the dead until its soul is released. - **At Will:** - **1/Day Each:** *Dream*, *Protection from Evil and Good*, *Magic Circle*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Shape-Shift\\",\\"text\\":\\"The hag shape-shifts into a Small or Medium Humanoid, or it returns to its true form. Other than its size, its game statistics are the same in each form. Any equipment it is wearing or carrying isn't transformed.\\"}]"
---

# Night Hag
*Medium, Fiend, Neutral Evil*

**AC** 17
**HP** 112 (15d8 + 45)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 15 | 16 | 16 | 14 | 16 |

CR 5, PB +3, XP 1800

## Traits

**Magic Resistance**
The hag has Advantage on saving throws against spells and other magical effects.

**Soul Bag**
The hag has a soul bag. While holding or carrying the bag, the hag can use its Nightmare Haunting action. The bag has AC 15, HP 20, and Resistance to all damage. The bag turns to dust if reduced to 0 Hit Points. If the bag is destroyed, any souls the bag is holding are released. The hag can create a new bag after 7 days.

## Actions

**Multiattack**
The hag makes two Claw attacks.

**Claw**
*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Slashing damage.

**Spellcasting**
The hag casts one of the following spells, requiring no Material components and using Intelligence as the spellcasting ability (spell save DC 14): - **At Will:** *Detect Magic*, *Etherealness*, *Magic Missile* - **2e/Day Each:** *Phantasmal Killer*, *Plane Shift*

**Nightmare Haunting (1/Day; Requires Soul Bag)**
While on the Ethereal Plane, the hag casts *Dream*, using the same spellcasting ability as Spellcasting. Only the hag can serve as the spell's messenger, and the target must be a creature the hag can see on the Material Plane. The spell fails and is wasted if the target is under the effect of the *Protection from Evil and Good* spell or within a *Magic Circle* spell. If the target takes damage from the *Dream* spell, the target's Hit Point maximum decreases by an amount equal to that damage. If the spell kills the target, its soul is trapped in the hag's soul bag, and the target can't be raised from the dead until its soul is released. - **At Will:** - **1/Day Each:** *Dream*, *Protection from Evil and Good*, *Magic Circle*

## Bonus Actions

**Shape-Shift**
The hag shape-shifts into a Small or Medium Humanoid, or it returns to its true form. Other than its size, its game statistics are the same in each form. Any equipment it is wearing or carrying isn't transformed.
`,
      "nightmare.md": `---
smType: creature
name: "Nightmare"
size: "Large"
type: "Fiend"
alignment: "Neutral Evil"
ac: "13"
hp: "68"
hit_dice: "8d10 + 24"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"60 ft.\\"},\\"fly\\":{\\"distance\\":\\"90 ft.\\",\\"hover\\":true}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":15}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Confer Fire Resistance\\",\\"text\\":\\"The nightmare can grant Resistance to Fire damage to a rider while it is on the nightmare.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Illumination\\",\\"text\\":\\"The nightmare sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Hooves\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage plus 10 (3d6) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Ethereal Stride\\",\\"text\\":\\"The nightmare and up to three willing creatures within 5 feet of it teleport to the Ethereal Plane from the Material Plane or vice versa.\\"}]"
---

# Nightmare
*Large, Fiend, Neutral Evil*

**AC** 13
**HP** 68 (8d10 + 24)
**Speed** 60 ft., fly 90 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 15 | 16 | 10 | 13 | 15 |

CR 3, PB +2, XP 700

## Traits

**Confer Fire Resistance**
The nightmare can grant Resistance to Fire damage to a rider while it is on the nightmare.

**Illumination**
The nightmare sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.

## Actions

**Hooves**
*Melee Attack Roll:* +6, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage plus 10 (3d6) Fire damage.

**Ethereal Stride**
The nightmare and up to three willing creatures within 5 feet of it teleport to the Ethereal Plane from the Material Plane or vice versa.
`,
      "noble.md": `---
smType: creature
name: "Noble"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "15"
hp: "9"
hit_dice: "2d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":11},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":16}]"
pb: "+2"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Rapier\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 5 (1d8 + 1) Piercing damage.\\"}]"
---

# Noble
*Small, Humanoid, Neutral Neutral*

**AC** 15
**HP** 9 (2d8)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 11 | 12 | 11 | 12 | 14 | 16 |

CR 1/8, PB +2, XP 25

## Actions

**Rapier**
*Melee Attack Roll:* +3, reach 5 ft. 5 (1d8 + 1) Piercing damage.
`,
      "ochre-jelly.md": `---
smType: creature
name: "Ochre Jelly"
size: "Large"
type: "Ooze"
alignment: "Unaligned"
ac: "8"
hp: "52"
hit_dice: "7d10 + 14"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"climb\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":6},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":6},{\\"ability\\":\\"cha\\",\\"score\\":1}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amorphous\\",\\"text\\":\\"The jelly can move through a space as narrow as 1 inch without expending extra movement to do so.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Spider Climb\\",\\"text\\":\\"The jelly can climb difficult surfaces, including along ceilings, without needing to make an ability check.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Pseudopod\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 12 (3d6 + 2) Acid damage.\\"}]"
---

# Ochre Jelly
*Large, Ooze, Unaligned*

**AC** 8
**HP** 52 (7d10 + 14)
**Speed** 20 ft., climb 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 6 | 14 | 2 | 6 | 1 |

CR 2, PB +2, XP 450

## Traits

**Amorphous**
The jelly can move through a space as narrow as 1 inch without expending extra movement to do so.

**Spider Climb**
The jelly can climb difficult surfaces, including along ceilings, without needing to make an ability check.

## Actions

**Pseudopod**
*Melee Attack Roll:* +4, reach 5 ft. 12 (3d6 + 2) Acid damage.
`,
      "ogre-zombie.md": `---
smType: creature
name: "Ogre Zombie"
size: "Large"
type: "Undead"
alignment: "Neutral Evil"
ac: "8"
hp: "85"
hit_dice: "9d10 + 36"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":6},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":6},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Undead Fortitude\\",\\"text\\":\\"If damage reduces the zombie to 0 Hit Points, it makes a Constitution saving throw (DC 5 plus the damage taken) unless the damage is Radiant or from a Critical Hit. On a successful save, the zombie drops to 1 Hit Point instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Slam\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage.\\"}]"
---

# Ogre Zombie
*Large, Undead, Neutral Evil*

**AC** 8
**HP** 85 (9d10 + 36)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 6 | 18 | 3 | 6 | 5 |

CR 2, PB +2, XP 450

## Traits

**Undead Fortitude**
If damage reduces the zombie to 0 Hit Points, it makes a Constitution saving throw (DC 5 plus the damage taken) unless the damage is Radiant or from a Critical Hit. On a successful save, the zombie drops to 1 Hit Point instead.

## Actions

**Slam**
*Melee Attack Roll:* +6, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage.
`,
      "ogre.md": `---
smType: creature
name: "Ogre"
size: "Large"
type: "Giant"
alignment: "Chaotic Evil"
ac: "11"
hp: "68"
hit_dice: "8d10 + 24"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":8},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":5},{\\"ability\\":\\"wis\\",\\"score\\":7},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Greatclub\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Javelin\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +6, reach 5 ft. or range 30/120 ft. 11 (2d6 + 4) Piercing damage.\\"}]"
---

# Ogre
*Large, Giant, Chaotic Evil*

**AC** 11
**HP** 68 (8d10 + 24)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 8 | 16 | 5 | 7 | 7 |

CR 2, PB +2, XP 450

## Actions

**Greatclub**
*Melee Attack Roll:* +6, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage.

**Javelin**
*Melee or Ranged Attack Roll:* +6, reach 5 ft. or range 30/120 ft. 11 (2d6 + 4) Piercing damage.
`,
      "oni.md": `---
smType: creature
name: "Oni"
size: "Large"
type: "Fiend"
alignment: "Lawful Evil"
ac: "17"
hp: "119"
hit_dice: "14d10 + 42"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"30 ft.\\",\\"hover\\":true}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":14},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":15}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":3},{\\"ability\\":\\"con\\",\\"bonus\\":6},{\\"ability\\":\\"wis\\",\\"bonus\\":4},{\\"ability\\":\\"cha\\",\\"bonus\\":5}]"
cr: "7"
xp: "2900"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Regeneration\\",\\"text\\":\\"The oni regains 10 Hit Points at the start of each of its turns if it has at least 1 Hit Point.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The oni makes two Claw or Nightmare Ray attacks. It can replace one attack with a use of Spellcasting.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 10 ft. 10 (1d12 + 4) Slashing damage plus 9 (2d8) Necrotic damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Nightmare Ray\\",\\"text\\":\\"*Ranged Attack Roll:* +5, range 60 ft. 9 (2d6 + 2) Psychic damage, and the target has the Frightened condition until the start of the oni's next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Shape-Shift\\",\\"text\\":\\"The oni shape-shifts into a Small or Medium Humanoid or a Large Giant, or it returns to its true form. Other than its size, its game statistics are the same in each form. Any equipment it is wearing or carrying isn't transformed.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The oni casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 13): - **At Will:** - **1e/Day Each:** *Charm Person*, *Darkness*, *Gaseous Form*, *Sleep*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Invisibility\\",\\"text\\":\\"The oni casts *Invisibility* on itself, requiring no spell components and using the same spellcasting ability as Spellcasting.\\"}]"
---

# Oni
*Large, Fiend, Lawful Evil*

**AC** 17
**HP** 119 (14d10 + 42)
**Speed** 30 ft., fly 30 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 11 | 16 | 14 | 12 | 15 |

CR 7, PB +3, XP 2900

## Traits

**Regeneration**
The oni regains 10 Hit Points at the start of each of its turns if it has at least 1 Hit Point.

## Actions

**Multiattack**
The oni makes two Claw or Nightmare Ray attacks. It can replace one attack with a use of Spellcasting.

**Claw**
*Melee Attack Roll:* +7, reach 10 ft. 10 (1d12 + 4) Slashing damage plus 9 (2d8) Necrotic damage.

**Nightmare Ray**
*Ranged Attack Roll:* +5, range 60 ft. 9 (2d6 + 2) Psychic damage, and the target has the Frightened condition until the start of the oni's next turn.

**Shape-Shift**
The oni shape-shifts into a Small or Medium Humanoid or a Large Giant, or it returns to its true form. Other than its size, its game statistics are the same in each form. Any equipment it is wearing or carrying isn't transformed.

**Spellcasting**
The oni casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 13): - **At Will:** - **1e/Day Each:** *Charm Person*, *Darkness*, *Gaseous Form*, *Sleep*

## Bonus Actions

**Invisibility**
The oni casts *Invisibility* on itself, requiring no spell components and using the same spellcasting ability as Spellcasting.
`,
      "otyugh.md": `---
smType: creature
name: "Otyugh"
size: "Large"
type: "Aberration"
alignment: "Neutral Neutral"
ac: "14"
hp: "104"
hit_dice: "11d10 + 44"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":19},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"con\\",\\"bonus\\":7}]"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The otyugh makes one Bite attack and two Tentacle attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 12 (2d8 + 3) Piercing damage, and the target has the Poisoned condition. Whenever the Poisoned target finishes a Long Rest, it is subjected to the following effect. *Constitution Saving Throw*: DC 15. *Failure:*  The target's Hit Point maximum decreases by 5 (1d10) and doesn't return to normal until the Poisoned condition ends on the target. *Success:*  The Poisoned condition ends.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tentacle\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 10 ft. 12 (2d8 + 3) Piercing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 13) from one of two tentacles.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tentacle Slam\\",\\"text\\":\\"*Constitution Saving Throw*: DC 14, each creature Grappled by the otyugh. *Failure:*  16 (3d8 + 3) Bludgeoning damage, and the target has the Stunned condition until the start of the otyugh's next turn. *Success:*  Half damage only.\\"}]"
---

# Otyugh
*Large, Aberration, Neutral Neutral*

**AC** 14
**HP** 104 (11d10 + 44)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 11 | 19 | 6 | 13 | 6 |

CR 5, PB +3, XP 1800

## Actions

**Multiattack**
The otyugh makes one Bite attack and two Tentacle attacks.

**Bite**
*Melee Attack Roll:* +6, reach 5 ft. 12 (2d8 + 3) Piercing damage, and the target has the Poisoned condition. Whenever the Poisoned target finishes a Long Rest, it is subjected to the following effect. *Constitution Saving Throw*: DC 15. *Failure:*  The target's Hit Point maximum decreases by 5 (1d10) and doesn't return to normal until the Poisoned condition ends on the target. *Success:*  The Poisoned condition ends.

**Tentacle**
*Melee Attack Roll:* +6, reach 10 ft. 12 (2d8 + 3) Piercing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 13) from one of two tentacles.

**Tentacle Slam**
*Constitution Saving Throw*: DC 14, each creature Grappled by the otyugh. *Failure:*  16 (3d8 + 3) Bludgeoning damage, and the target has the Stunned condition until the start of the otyugh's next turn. *Success:*  Half damage only.
`,
      "owlbear.md": `---
smType: creature
name: "Owlbear"
size: "Large"
type: "Monstrosity"
alignment: "Unaligned"
ac: "13"
hp: "59"
hit_dice: "7d10 + 21"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":20},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The owlbear makes two Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 14 (2d8 + 5) Slashing damage.\\"}]"
---

# Owlbear
*Large, Monstrosity, Unaligned*

**AC** 13
**HP** 59 (7d10 + 21)
**Speed** 40 ft., climb 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 20 | 12 | 17 | 3 | 12 | 7 |

CR 3, PB +2, XP 700

## Actions

**Multiattack**
The owlbear makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +7, reach 5 ft. 14 (2d8 + 5) Slashing damage.
`,
      "pegasus.md": `---
smType: creature
name: "Pegasus"
size: "Large"
type: "Celestial"
alignment: "Chaotic Good"
ac: "12"
hp: "59"
hit_dice: "7d10 + 21"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"60 ft.\\"},\\"fly\\":{\\"distance\\":\\"90 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":13}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":4},{\\"ability\\":\\"con\\",\\"bonus\\":5},{\\"ability\\":\\"wis\\",\\"bonus\\":4},{\\"ability\\":\\"cha\\",\\"bonus\\":3}]"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Hooves\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 7 (1d6 + 4) Bludgeoning damage plus 5 (2d4) Radiant damage.\\"}]"
---

# Pegasus
*Large, Celestial, Chaotic Good*

**AC** 12
**HP** 59 (7d10 + 21)
**Speed** 60 ft., fly 90 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 15 | 16 | 10 | 15 | 13 |

CR 2, PB +2, XP 450

## Actions

**Hooves**
*Melee Attack Roll:* +6, reach 5 ft. 7 (1d6 + 4) Bludgeoning damage plus 5 (2d4) Radiant damage.
`,
      "phase-spider.md": `---
smType: creature
name: "Phase Spider"
size: "Large"
type: "Monstrosity"
alignment: "Unaligned"
ac: "14"
hp: "45"
hit_dice: "7d10 + 7"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Ethereal Sight\\",\\"text\\":\\"The spider can see 60 feet into the Ethereal Plane while on the Material Plane and vice versa.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Spider Climb\\",\\"text\\":\\"The spider can climb difficult surfaces, including along ceilings, without needing to make an ability check.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Web Walker\\",\\"text\\":\\"The spider ignores movement restrictions caused by webs, and the spider knows the location of any other creature in contact with the same web.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The spider makes two Bite attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Piercing damage plus 9 (2d8) Poison damage. If this damage reduces the target to 0 Hit Points, the target becomes Stable, and it has the Poisoned condition for 1 hour. While Poisoned, the target also has the Paralyzed condition.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Ethereal Jaunt\\",\\"text\\":\\"The spider teleports from the Material Plane to the Ethereal Plane or vice versa.\\"}]"
---

# Phase Spider
*Large, Monstrosity, Unaligned*

**AC** 14
**HP** 45 (7d10 + 7)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 16 | 12 | 6 | 10 | 6 |

CR 3, PB +2, XP 700

## Traits

**Ethereal Sight**
The spider can see 60 feet into the Ethereal Plane while on the Material Plane and vice versa.

**Spider Climb**
The spider can climb difficult surfaces, including along ceilings, without needing to make an ability check.

**Web Walker**
The spider ignores movement restrictions caused by webs, and the spider knows the location of any other creature in contact with the same web.

## Actions

**Multiattack**
The spider makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 8 (1d10 + 3) Piercing damage plus 9 (2d8) Poison damage. If this damage reduces the target to 0 Hit Points, the target becomes Stable, and it has the Poisoned condition for 1 hour. While Poisoned, the target also has the Paralyzed condition.

## Bonus Actions

**Ethereal Jaunt**
The spider teleports from the Material Plane to the Ethereal Plane or vice versa.
`,
      "pirate-captain.md": `---
smType: creature
name: "Pirate Captain"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "17"
hp: "84"
hit_dice: "13d8 + 26"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":18},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":17}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":3},{\\"ability\\":\\"dex\\",\\"bonus\\":7},{\\"ability\\":\\"wis\\",\\"bonus\\":5},{\\"ability\\":\\"cha\\",\\"bonus\\":6}]"
cr: "6"
xp: "2300"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The pirate makes three attacks, using Rapier or Pistol in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rapier\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Piercing damage, and the pirate has Advantage on the next attack roll it makes before the end of this turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Pistol\\",\\"text\\":\\"*Ranged Attack Roll:* +7, range 30/90 ft. 15 (2d10 + 4) Piercing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Captain's Charm\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 14, one creature the pirate can see within 30 feet. *Failure:*  The target has the Charmed condition until the start of the pirate's next turn.\\"}]"
---

# Pirate Captain
*Small, Humanoid, Neutral Neutral*

**AC** 17
**HP** 84 (13d8 + 26)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 18 | 14 | 10 | 14 | 17 |

CR 6, PB +3, XP 2300

## Actions

**Multiattack**
The pirate makes three attacks, using Rapier or Pistol in any combination.

**Rapier**
*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Piercing damage, and the pirate has Advantage on the next attack roll it makes before the end of this turn.

**Pistol**
*Ranged Attack Roll:* +7, range 30/90 ft. 15 (2d10 + 4) Piercing damage.

## Bonus Actions

**Captain's Charm**
*Wisdom Saving Throw*: DC 14, one creature the pirate can see within 30 feet. *Failure:*  The target has the Charmed condition until the start of the pirate's next turn.
`,
      "pirate.md": `---
smType: creature
name: "Pirate"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "14"
hp: "33"
hit_dice: "6d8 + 6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":8},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":14}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":5},{\\"ability\\":\\"cha\\",\\"bonus\\":4}]"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The pirate makes two Dagger attacks. It can replace one attack with a use of Enthralling Panache.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Dagger\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +5, reach 5 ft. or range 20/60 ft. 5 (1d4 + 3) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Enthralling Panache\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 12, one creature the pirate can see within 30 feet. *Failure:*  The target has the Charmed condition until the start of the pirate's next turn.\\"}]"
---

# Pirate
*Small, Humanoid, Neutral Neutral*

**AC** 14
**HP** 33 (6d8 + 6)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 16 | 12 | 8 | 12 | 14 |

CR 1, PB +2, XP 200

## Actions

**Multiattack**
The pirate makes two Dagger attacks. It can replace one attack with a use of Enthralling Panache.

**Dagger**
*Melee or Ranged Attack Roll:* +5, reach 5 ft. or range 20/60 ft. 5 (1d4 + 3) Piercing damage.

**Enthralling Panache**
*Wisdom Saving Throw*: DC 12, one creature the pirate can see within 30 feet. *Failure:*  The target has the Charmed condition until the start of the pirate's next turn.
`,
      "pit-fiend.md": `---
smType: creature
name: "Pit Fiend"
size: "Large"
type: "Fiend"
type_tags: ["Devil"]
alignment: "Lawful Evil"
ac: "21"
hp: "337"
hit_dice: "27d10 + 189"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":26},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":24},{\\"ability\\":\\"int\\",\\"score\\":22},{\\"ability\\":\\"wis\\",\\"score\\":18},{\\"ability\\":\\"cha\\",\\"score\\":24}]"
pb: "+6"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":8},{\\"ability\\":\\"wis\\",\\"bonus\\":10}]"
cr: "20"
xp: "25000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Diabolical Restoration\\",\\"text\\":\\"If the pit fiend dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Fear Aura\\",\\"text\\":\\"The pit fiend emanates an aura in a 20-foot Emanation while it doesn't have the Incapacitated condition. *Wisdom Saving Throw*: DC 21, any enemy that starts its turn in the aura. *Failure:*  The target has the Frightened condition until the start of its next turn. *Success:*  The target is immune to this pit fiend's aura for 24 hours.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (4/Day)\\",\\"text\\":\\"If the pit fiend fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The pit fiend has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The pit fiend makes one Bite attack, two Devilish Claw attacks, and one Fiery Mace attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +14, reach 10 ft. 18 (3d6 + 8) Piercing damage. If the target is a creature, it must make the following saving throw. *Constitution Saving Throw*: DC 21. *Failure:*  The target has the Poisoned condition. While Poisoned, the target can't regain Hit Points and takes 21 (6d6) Poison damage at the start of each of its turns, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Devilish Claw\\",\\"text\\":\\"*Melee Attack Roll:* +14, reach 10 ft. 26 (4d8 + 8) Necrotic damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fiery Mace\\",\\"text\\":\\"*Melee Attack Roll:* +14, reach 10 ft. 22 (4d6 + 8) Force damage plus 21 (6d6) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Hellfire Spellcasting (Recharge 4-6)\\",\\"text\\":\\"The pit fiend casts *Fireball* (level 5 version) twice, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21). It can replace one *Fireball* with *Hold Monster* (level 7 version) or *Wall of Fire*. - **At Will:**\\"}]"
---

# Pit Fiend
*Large, Fiend, Lawful Evil*

**AC** 21
**HP** 337 (27d10 + 189)
**Speed** 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 26 | 14 | 24 | 22 | 18 | 24 |

CR 20, PB +6, XP 25000

## Traits

**Diabolical Restoration**
If the pit fiend dies outside the Nine Hells, its body disappears in sulfurous smoke, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.

**Fear Aura**
The pit fiend emanates an aura in a 20-foot Emanation while it doesn't have the Incapacitated condition. *Wisdom Saving Throw*: DC 21, any enemy that starts its turn in the aura. *Failure:*  The target has the Frightened condition until the start of its next turn. *Success:*  The target is immune to this pit fiend's aura for 24 hours.

**Legendary Resistance (4/Day)**
If the pit fiend fails a saving throw, it can choose to succeed instead.

**Magic Resistance**
The pit fiend has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The pit fiend makes one Bite attack, two Devilish Claw attacks, and one Fiery Mace attack.

**Bite**
*Melee Attack Roll:* +14, reach 10 ft. 18 (3d6 + 8) Piercing damage. If the target is a creature, it must make the following saving throw. *Constitution Saving Throw*: DC 21. *Failure:*  The target has the Poisoned condition. While Poisoned, the target can't regain Hit Points and takes 21 (6d6) Poison damage at the start of each of its turns, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.

**Devilish Claw**
*Melee Attack Roll:* +14, reach 10 ft. 26 (4d8 + 8) Necrotic damage.

**Fiery Mace**
*Melee Attack Roll:* +14, reach 10 ft. 22 (4d6 + 8) Force damage plus 21 (6d6) Fire damage.

**Hellfire Spellcasting (Recharge 4-6)**
The pit fiend casts *Fireball* (level 5 version) twice, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 21). It can replace one *Fireball* with *Hold Monster* (level 7 version) or *Wall of Fire*. - **At Will:**
`,
      "planetar.md": `---
smType: creature
name: "Planetar"
size: "Large"
type: "Celestial"
type_tags: ["Angel"]
alignment: "Lawful Good"
ac: "19"
hp: "262"
hit_dice: "21d10 + 147"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"120 ft.\\",\\"hover\\":true}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":24},{\\"ability\\":\\"dex\\",\\"score\\":20},{\\"ability\\":\\"con\\",\\"score\\":24},{\\"ability\\":\\"int\\",\\"score\\":19},{\\"ability\\":\\"wis\\",\\"score\\":22},{\\"ability\\":\\"cha\\",\\"score\\":25}]"
pb: "+5"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":12},{\\"ability\\":\\"con\\",\\"bonus\\":12},{\\"ability\\":\\"wis\\",\\"bonus\\":11},{\\"ability\\":\\"cha\\",\\"bonus\\":12}]"
cr: "16"
xp: "15000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Divine Awareness\\",\\"text\\":\\"The planetar knows if it hears a lie.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Exalted Restoration\\",\\"text\\":\\"If the planetar dies outside Mount Celestia, its body disappears, and it gains a new body instantly, reviving with all its Hit Points somewhere in Mount Celestia.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The planetar has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The planetar makes three Radiant Sword attacks or uses Holy Burst twice.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Radiant Sword\\",\\"text\\":\\"*Melee Attack Roll:* +12, reach 10 ft. 14 (2d6 + 7) Slashing damage plus 18 (4d8) Radiant damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Holy Burst\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 20, each enemy in a 20-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the planetar can see within 120 feet. *Failure:*  24 (7d6) Radiant damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The planetar casts one of the following spells, requiring no Material components and using Charisma as spellcasting ability (spell save DC 20): - **At Will:** *Detect Evil and Good* - **1e/Day Each:** *Commune*, *Control Weather*, *Dispel Evil and Good*, *Raise Dead*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Divine Aid (2/Day)\\",\\"text\\":\\"The planetar casts *Cure Wounds*, *Invisibility*, *Lesser Restoration*, or *Remove Curse*, using the same spellcasting ability as Spellcasting.\\"}]"
---

# Planetar
*Large, Celestial, Lawful Good*

**AC** 19
**HP** 262 (21d10 + 147)
**Speed** 40 ft., fly 120 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 24 | 20 | 24 | 19 | 22 | 25 |

CR 16, PB +5, XP 15000

## Traits

**Divine Awareness**
The planetar knows if it hears a lie.

**Exalted Restoration**
If the planetar dies outside Mount Celestia, its body disappears, and it gains a new body instantly, reviving with all its Hit Points somewhere in Mount Celestia.

**Magic Resistance**
The planetar has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The planetar makes three Radiant Sword attacks or uses Holy Burst twice.

**Radiant Sword**
*Melee Attack Roll:* +12, reach 10 ft. 14 (2d6 + 7) Slashing damage plus 18 (4d8) Radiant damage.

**Holy Burst**
*Dexterity Saving Throw*: DC 20, each enemy in a 20-foot-radius Sphere [Area of Effect]|XPHB|Sphere centered on a point the planetar can see within 120 feet. *Failure:*  24 (7d6) Radiant damage. *Success:*  Half damage.

**Spellcasting**
The planetar casts one of the following spells, requiring no Material components and using Charisma as spellcasting ability (spell save DC 20): - **At Will:** *Detect Evil and Good* - **1e/Day Each:** *Commune*, *Control Weather*, *Dispel Evil and Good*, *Raise Dead*

## Bonus Actions

**Divine Aid (2/Day)**
The planetar casts *Cure Wounds*, *Invisibility*, *Lesser Restoration*, or *Remove Curse*, using the same spellcasting ability as Spellcasting.
`,
      "priest-acolyte.md": `---
smType: creature
name: "Priest Acolyte"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "13"
hp: "11"
hit_dice: "2d8 + 2"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":14},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Mace\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Bludgeoning damage plus 2 (1d4) Radiant damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Radiant Flame\\",\\"text\\":\\"*Ranged Attack Roll:* +4, range 60 ft. 7 (2d6) Radiant damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The priest casts one of the following spells, using Wisdom as the spellcasting ability: - **At Will:** *Light*, *Thaumaturgy*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Divine Aid (1/Day)\\",\\"text\\":\\"The priest casts *Bless*, *Healing Word*, or *Sanctuary*, using the same spellcasting ability as Spellcasting.\\"}]"
---

# Priest Acolyte
*Small, Humanoid, Neutral Neutral*

**AC** 13
**HP** 11 (2d8 + 2)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 14 | 10 | 12 | 10 | 14 | 11 |

CR 1/4, PB +2, XP 50

## Actions

**Mace**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Bludgeoning damage plus 2 (1d4) Radiant damage.

**Radiant Flame**
*Ranged Attack Roll:* +4, range 60 ft. 7 (2d6) Radiant damage.

**Spellcasting**
The priest casts one of the following spells, using Wisdom as the spellcasting ability: - **At Will:** *Light*, *Thaumaturgy*

## Bonus Actions

**Divine Aid (1/Day)**
The priest casts *Bless*, *Healing Word*, or *Sanctuary*, using the same spellcasting ability as Spellcasting.
`,
      "priest.md": `---
smType: creature
name: "Priest"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "13"
hp: "38"
hit_dice: "7d8 + 7"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":13},{\\"ability\\":\\"wis\\",\\"score\\":16},{\\"ability\\":\\"cha\\",\\"score\\":13}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The priest makes two attacks, using Mace or Radiant Flame in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Mace\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage plus 5 (2d4) Radiant damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Radiant Flame\\",\\"text\\":\\"*Ranged Attack Roll:* +5, range 60 ft. 11 (2d10) Radiant damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The priest casts one of the following spells, using Wisdom as the spellcasting ability: - **At Will:** *Light*, *Thaumaturgy* - **1/Day Each:** *Spirit Guardians*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Divine Aid (3/Day)\\",\\"text\\":\\"The priest casts *Bless*, *Dispel Magic*, *Healing Word*, or *Lesser Restoration*, using the same spellcasting ability as Spellcasting.\\"}]"
---

# Priest
*Small, Humanoid, Neutral Neutral*

**AC** 13
**HP** 38 (7d8 + 7)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 10 | 12 | 13 | 16 | 13 |

CR 2, PB +2, XP 450

## Actions

**Multiattack**
The priest makes two attacks, using Mace or Radiant Flame in any combination.

**Mace**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Bludgeoning damage plus 5 (2d4) Radiant damage.

**Radiant Flame**
*Ranged Attack Roll:* +5, range 60 ft. 11 (2d10) Radiant damage.

**Spellcasting**
The priest casts one of the following spells, using Wisdom as the spellcasting ability: - **At Will:** *Light*, *Thaumaturgy* - **1/Day Each:** *Spirit Guardians*

## Bonus Actions

**Divine Aid (3/Day)**
The priest casts *Bless*, *Dispel Magic*, *Healing Word*, or *Lesser Restoration*, using the same spellcasting ability as Spellcasting.
`,
      "pseudodragon.md": `---
smType: creature
name: "Pseudodragon"
size: "Small"
type: "Dragon"
alignment: "Neutral Good"
ac: "14"
hp: "10"
hit_dice: "3d4 + 3"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"15 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":6},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The pseudodragon has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The pseudodragon makes two Bite attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Sting\\",\\"text\\":\\"*Constitution Saving Throw*: DC 12, one creature the pseudodragon can see within 5 feet. *Failure:*  5 (2d4) Poison damage, and the target has the Poisoned condition for 1 hour. *Failure by 5 or More:* While Poisoned, the target also has the Unconscious condition, which ends early if the target takes damage or a creature within 5 feet of it takes an action to wake it.\\"}]"
---

# Pseudodragon
*Small, Dragon, Neutral Good*

**AC** 14
**HP** 10 (3d4 + 3)
**Speed** 15 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 6 | 15 | 13 | 10 | 12 | 10 |

CR 1/4, PB +2, XP 50

## Traits

**Magic Resistance**
The pseudodragon has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The pseudodragon makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +4, reach 5 ft. 4 (1d4 + 2) Piercing damage.

**Sting**
*Constitution Saving Throw*: DC 12, one creature the pseudodragon can see within 5 feet. *Failure:*  5 (2d4) Poison damage, and the target has the Poisoned condition for 1 hour. *Failure by 5 or More:* While Poisoned, the target also has the Unconscious condition, which ends early if the target takes damage or a creature within 5 feet of it takes an action to wake it.
`,
      "purple-worm.md": `---
smType: creature
name: "Purple Worm"
size: "Gargantuan"
type: "Monstrosity"
alignment: "Unaligned"
ac: "18"
hp: "247"
hit_dice: "15d20 + 90"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"},\\"burrow\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":28},{\\"ability\\":\\"dex\\",\\"score\\":7},{\\"ability\\":\\"con\\",\\"score\\":22},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":8},{\\"ability\\":\\"cha\\",\\"score\\":4}]"
pb: "+5"
saves_json: "[{\\"ability\\":\\"con\\",\\"bonus\\":11},{\\"ability\\":\\"wis\\",\\"bonus\\":4}]"
cr: "15"
xp: "13000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Tunneler\\",\\"text\\":\\"The worm can burrow through solid rock at half its Burrow Speed and leaves a 10-foot-diameter tunnel in its wake.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The worm makes one Bite attack and one Tail Stinger attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +14, reach 10 ft. 22 (3d8 + 9) Piercing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 19), and it has the Restrained condition until the grapple ends.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tail Stinger\\",\\"text\\":\\"*Melee Attack Roll:* +14, reach 10 ft. 16 (2d6 + 9) Piercing damage plus 35 (10d6) Poison damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Swallow\\",\\"text\\":\\"*Strength Saving Throw*: DC 19, one Large or smaller creature Grappled by the worm (it can have up to three creatures swallowed at a time). *Failure:*  The target is swallowed by the worm, and the Grappled condition ends. A swallowed creature has the Blinded and Restrained conditions, has Cover|XPHB|Total Cover against attacks and other effects outside the worm, and takes 17 (5d6) Acid damage at the start of each of the worm's turns. If the worm takes 30 damage or more on a single turn from a creature inside it, the worm must succeed on a DC 21 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, each of which falls in a space within 5 feet of the worm and has the Prone condition. If the worm dies, any swallowed creature no longer has the Restrained condition and can escape from the corpse using 20 feet of movement, exiting Prone.\\"}]"
---

# Purple Worm
*Gargantuan, Monstrosity, Unaligned*

**AC** 18
**HP** 247 (15d20 + 90)
**Speed** 50 ft., burrow 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 28 | 7 | 22 | 1 | 8 | 4 |

CR 15, PB +5, XP 13000

## Traits

**Tunneler**
The worm can burrow through solid rock at half its Burrow Speed and leaves a 10-foot-diameter tunnel in its wake.

## Actions

**Multiattack**
The worm makes one Bite attack and one Tail Stinger attack.

**Bite**
*Melee Attack Roll:* +14, reach 10 ft. 22 (3d8 + 9) Piercing damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 19), and it has the Restrained condition until the grapple ends.

**Tail Stinger**
*Melee Attack Roll:* +14, reach 10 ft. 16 (2d6 + 9) Piercing damage plus 35 (10d6) Poison damage.

## Bonus Actions

**Swallow**
*Strength Saving Throw*: DC 19, one Large or smaller creature Grappled by the worm (it can have up to three creatures swallowed at a time). *Failure:*  The target is swallowed by the worm, and the Grappled condition ends. A swallowed creature has the Blinded and Restrained conditions, has Cover|XPHB|Total Cover against attacks and other effects outside the worm, and takes 17 (5d6) Acid damage at the start of each of the worm's turns. If the worm takes 30 damage or more on a single turn from a creature inside it, the worm must succeed on a DC 21 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, each of which falls in a space within 5 feet of the worm and has the Prone condition. If the worm dies, any swallowed creature no longer has the Restrained condition and can escape from the corpse using 20 feet of movement, exiting Prone.
`,
      "quasit.md": `---
smType: creature
name: "Quasit"
size: "Small"
type: "Fiend"
type_tags: ["Demon"]
alignment: "Chaotic Evil"
ac: "13"
hp: "25"
hit_dice: "10d4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":5},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":7},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The quasit has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Slashing damage, and the target has the Poisoned condition until the start of the quasit's next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Scare (1/Day)\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 10, one creature within 20 feet. *Failure:*  The target has the Frightened condition. At the end of each of its turns, the target repeats the save, ending the effect on itself on a success. After 1 minute, it succeeds automatically.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Shape-Shift\\",\\"text\\":\\"The quasit shape-shifts to resemble a bat (Speed 10 ft., Fly 40 ft.), a centipede (40 ft., Climb 40 ft.), or a toad (40 ft., Swim 40 ft.), or it returns to its true form. Its game statistics are the same in each form, except for its Speed. Any equipment it is wearing or carrying isn't transformed.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Invisibility\\",\\"text\\":\\"The quasit casts *Invisibility* on itself, requiring no spell components and using Charisma as the spellcasting ability. - **At Will:** *Invisibility*\\"}]"
---

# Quasit
*Small, Fiend, Chaotic Evil*

**AC** 13
**HP** 25 (10d4)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 5 | 17 | 10 | 7 | 10 | 10 |

CR 1, PB +2, XP 200

## Traits

**Magic Resistance**
The quasit has Advantage on saving throws against spells and other magical effects.

## Actions

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Slashing damage, and the target has the Poisoned condition until the start of the quasit's next turn.

**Scare (1/Day)**
*Wisdom Saving Throw*: DC 10, one creature within 20 feet. *Failure:*  The target has the Frightened condition. At the end of each of its turns, the target repeats the save, ending the effect on itself on a success. After 1 minute, it succeeds automatically.

**Shape-Shift**
The quasit shape-shifts to resemble a bat (Speed 10 ft., Fly 40 ft.), a centipede (40 ft., Climb 40 ft.), or a toad (40 ft., Swim 40 ft.), or it returns to its true form. Its game statistics are the same in each form, except for its Speed. Any equipment it is wearing or carrying isn't transformed.

**Invisibility**
The quasit casts *Invisibility* on itself, requiring no spell components and using Charisma as the spellcasting ability. - **At Will:** *Invisibility*
`,
      "rakshasa.md": `---
smType: creature
name: "Rakshasa"
size: "Medium"
type: "Fiend"
alignment: "Lawful Evil"
ac: "17"
hp: "221"
hit_dice: "26d8 + 104"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":14},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":13},{\\"ability\\":\\"wis\\",\\"score\\":16},{\\"ability\\":\\"cha\\",\\"score\\":20}]"
pb: "+5"
cr: "13"
xp: "10000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Greater Magic Resistance\\",\\"text\\":\\"The rakshasa automatically succeeds on saving throws against spells and other magical effects, and the attack rolls of spells automatically miss it. Without the rakshasa's permission, no spell can observe the rakshasa remotely or detect its thoughts, creature type, or alignment.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Fiendish Restoration\\",\\"text\\":\\"If the rakshasa dies outside the Nine Hells, its body turns to ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The rakshasa makes three Cursed Touch attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Cursed Touch\\",\\"text\\":\\"*Melee Attack Roll:* +10, reach 5 ft. 12 (2d6 + 5) Slashing damage plus 19 (3d12) Necrotic damage. If the target is a creature, it is cursed. While cursed, the target gains no benefit from finishing a Short Rest|XPHB|Short or Long Rest.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Baleful Command (Recharge 5-6)\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 18, each enemy in a 30-foot Emanation originating from the rakshasa. *Failure:*  28 (8d6) Psychic damage, and the target has the Frightened and Incapacitated conditions until the start of the rakshasa's next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The rakshasa casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 18): - **At Will:** *Detect Magic*, *Detect Thoughts*, *Disguise Self*, *Mage Hand*, *Minor Illusion* - **1e/Day Each:** *Fly*, *Invisibility*, *Major Image*, *Plane Shift*\\"}]"
---

# Rakshasa
*Medium, Fiend, Lawful Evil*

**AC** 17
**HP** 221 (26d8 + 104)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 14 | 17 | 18 | 13 | 16 | 20 |

CR 13, PB +5, XP 10000

## Traits

**Greater Magic Resistance**
The rakshasa automatically succeeds on saving throws against spells and other magical effects, and the attack rolls of spells automatically miss it. Without the rakshasa's permission, no spell can observe the rakshasa remotely or detect its thoughts, creature type, or alignment.

**Fiendish Restoration**
If the rakshasa dies outside the Nine Hells, its body turns to ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Nine Hells.

## Actions

**Multiattack**
The rakshasa makes three Cursed Touch attacks.

**Cursed Touch**
*Melee Attack Roll:* +10, reach 5 ft. 12 (2d6 + 5) Slashing damage plus 19 (3d12) Necrotic damage. If the target is a creature, it is cursed. While cursed, the target gains no benefit from finishing a Short Rest|XPHB|Short or Long Rest.

**Baleful Command (Recharge 5-6)**
*Wisdom Saving Throw*: DC 18, each enemy in a 30-foot Emanation originating from the rakshasa. *Failure:*  28 (8d6) Psychic damage, and the target has the Frightened and Incapacitated conditions until the start of the rakshasa's next turn.

**Spellcasting**
The rakshasa casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 18): - **At Will:** *Detect Magic*, *Detect Thoughts*, *Disguise Self*, *Mage Hand*, *Minor Illusion* - **1e/Day Each:** *Fly*, *Invisibility*, *Major Image*, *Plane Shift*
`,
      "red-dragon-wyrmling.md": `---
smType: creature
name: "Red Dragon Wyrmling"
size: "Medium"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Chaotic Evil"
ac: "17"
hp: "75"
hit_dice: "10d8 + 30"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":15}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":2},{\\"ability\\":\\"wis\\",\\"bonus\\":2}]"
cr: "4"
xp: "1100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes two Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 9 (1d10 + 4) Slashing damage plus 3 (1d6) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fire Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 13, each creature in a 15-foot Cone. *Failure:*  24 (7d6) Fire damage. *Success:*  Half damage.\\"}]"
---

# Red Dragon Wyrmling
*Medium, Dragon, Chaotic Evil*

**AC** 17
**HP** 75 (10d8 + 30)
**Speed** 30 ft., climb 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 10 | 17 | 12 | 11 | 15 |

CR 4, PB +2, XP 1100

## Actions

**Multiattack**
The dragon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +6, reach 5 ft. 9 (1d10 + 4) Slashing damage plus 3 (1d6) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 13, each creature in a 15-foot Cone. *Failure:*  24 (7d6) Fire damage. *Success:*  Half damage.
`,
      "remorhaz.md": `---
smType: creature
name: "Remorhaz"
size: "Huge"
type: "Monstrosity"
alignment: "Unaligned"
ac: "17"
hp: "195"
hit_dice: "17d12 + 85"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"burrow\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":24},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":21},{\\"ability\\":\\"int\\",\\"score\\":4},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+4"
cr: "11"
xp: "7200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Heat Aura\\",\\"text\\":\\"At the end of each of the remorhaz's turns, each creature in a 5-foot Emanation originating from the remorhaz takes 16 (3d10) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +11, reach 10 ft. 18 (2d10 + 7) Piercing damage plus 14 (4d6) Fire damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 17), and it has the Restrained condition until the grapple ends.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Swallow\\",\\"text\\":\\"*Strength Saving Throw*: DC 19, one Large or smaller creature Grappled by the remorhaz (it can have up to two creatures swallowed at a time). *Failure:*  The target is swallowed by the remorhaz, and the Grappled condition ends. A swallowed creature has the Blinded and Restrained conditions, it has Cover|XPHB|Total Cover against attacks and other effects outside the remorhaz, and it takes 10 (3d6) Acid damage plus 10 (3d6) Fire damage at the start of each of the remorhaz's turns. If the remorhaz takes 30 damage or more on a single turn from a creature inside it, the remorhaz must succeed on a DC 15 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, each of which falls in a space within 5 feet of the remorhaz and has the Prone condition. If the remorhaz dies, any swallowed creature no longer has the Restrained condition and can escape from the corpse by using 15 feet of movement, exiting Prone.\\"}]"
---

# Remorhaz
*Huge, Monstrosity, Unaligned*

**AC** 17
**HP** 195 (17d12 + 85)
**Speed** 40 ft., burrow 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 24 | 13 | 21 | 4 | 10 | 5 |

CR 11, PB +4, XP 7200

## Traits

**Heat Aura**
At the end of each of the remorhaz's turns, each creature in a 5-foot Emanation originating from the remorhaz takes 16 (3d10) Fire damage.

## Actions

**Bite**
*Melee Attack Roll:* +11, reach 10 ft. 18 (2d10 + 7) Piercing damage plus 14 (4d6) Fire damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 17), and it has the Restrained condition until the grapple ends.

## Bonus Actions

**Swallow**
*Strength Saving Throw*: DC 19, one Large or smaller creature Grappled by the remorhaz (it can have up to two creatures swallowed at a time). *Failure:*  The target is swallowed by the remorhaz, and the Grappled condition ends. A swallowed creature has the Blinded and Restrained conditions, it has Cover|XPHB|Total Cover against attacks and other effects outside the remorhaz, and it takes 10 (3d6) Acid damage plus 10 (3d6) Fire damage at the start of each of the remorhaz's turns. If the remorhaz takes 30 damage or more on a single turn from a creature inside it, the remorhaz must succeed on a DC 15 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, each of which falls in a space within 5 feet of the remorhaz and has the Prone condition. If the remorhaz dies, any swallowed creature no longer has the Restrained condition and can escape from the corpse by using 15 feet of movement, exiting Prone.
`,
      "roc.md": `---
smType: creature
name: "Roc"
size: "Gargantuan"
type: "Monstrosity"
alignment: "Unaligned"
ac: "15"
hp: "248"
hit_dice: "16d20 + 80"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"fly\\":{\\"distance\\":\\"120 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":28},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":20},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":9}]"
pb: "+4"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":4},{\\"ability\\":\\"wis\\",\\"bonus\\":4}]"
cr: "11"
xp: "7200"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The roc makes two Beak attacks. It can replace one attack with a Talons attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Beak\\",\\"text\\":\\"*Melee Attack Roll:* +13, reach 10 ft. 28 (3d12 + 9) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Talons\\",\\"text\\":\\"*Melee Attack Roll:* +13, reach 5 ft. 23 (4d6 + 9) Slashing damage. If the target is a Huge or smaller creature, it has the Grappled condition (escape DC 19) from both talons, and it has the Restrained condition until the grapple ends.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Swoop (Recharge 5-6)\\",\\"text\\":\\"If the roc has a creature Grappled, the roc flies up to half its Fly Speed without provoking Opportunity Attacks and drops that creature.\\"}]"
---

# Roc
*Gargantuan, Monstrosity, Unaligned*

**AC** 15
**HP** 248 (16d20 + 80)
**Speed** 20 ft., fly 120 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 28 | 10 | 20 | 3 | 10 | 9 |

CR 11, PB +4, XP 7200

## Actions

**Multiattack**
The roc makes two Beak attacks. It can replace one attack with a Talons attack.

**Beak**
*Melee Attack Roll:* +13, reach 10 ft. 28 (3d12 + 9) Piercing damage.

**Talons**
*Melee Attack Roll:* +13, reach 5 ft. 23 (4d6 + 9) Slashing damage. If the target is a Huge or smaller creature, it has the Grappled condition (escape DC 19) from both talons, and it has the Restrained condition until the grapple ends.

## Bonus Actions

**Swoop (Recharge 5-6)**
If the roc has a creature Grappled, the roc flies up to half its Fly Speed without provoking Opportunity Attacks and drops that creature.
`,
      "roper.md": `---
smType: creature
name: "Roper"
size: "Large"
type: "Aberration"
alignment: "Neutral Evil"
ac: "20"
hp: "93"
hit_dice: "11d10 + 33"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"climb\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":8},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":7},{\\"ability\\":\\"wis\\",\\"score\\":16},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Spider Climb\\",\\"text\\":\\"The roper can climb difficult surfaces, including along ceilings, without needing to make an ability check.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The roper makes two Tentacle attacks, uses Reel, and makes two Bite attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 17 (3d8 + 4) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tentacle\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 60 ft. The target has the Grappled condition (escape DC 14) from one of six tentacles, and the target has the Poisoned condition until the grapple ends. The tentacle can be damaged, freeing a creature it has Grappled when destroyed (AC 20, HP 10, Immunity to Poison and Psychic damage). Damaging the tentacle deals no damage to the roper, and a destroyed tentacle regrows at the start of the roper's next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Reel\\",\\"text\\":\\"The roper pulls each creature Grappled by it up to 30 feet straight toward it.\\"}]"
---

# Roper
*Large, Aberration, Neutral Evil*

**AC** 20
**HP** 93 (11d10 + 33)
**Speed** 10 ft., climb 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 8 | 17 | 7 | 16 | 6 |

CR 5, PB +3, XP 1800

## Traits

**Spider Climb**
The roper can climb difficult surfaces, including along ceilings, without needing to make an ability check.

## Actions

**Multiattack**
The roper makes two Tentacle attacks, uses Reel, and makes two Bite attacks.

**Bite**
*Melee Attack Roll:* +7, reach 5 ft. 17 (3d8 + 4) Piercing damage.

**Tentacle**
*Melee Attack Roll:* +7, reach 60 ft. The target has the Grappled condition (escape DC 14) from one of six tentacles, and the target has the Poisoned condition until the grapple ends. The tentacle can be damaged, freeing a creature it has Grappled when destroyed (AC 20, HP 10, Immunity to Poison and Psychic damage). Damaging the tentacle deals no damage to the roper, and a destroyed tentacle regrows at the start of the roper's next turn.

**Reel**
The roper pulls each creature Grappled by it up to 30 feet straight toward it.
`,
      "rust-monster.md": `---
smType: creature
name: "Rust Monster"
size: "Medium"
type: "Monstrosity"
alignment: "Unaligned"
ac: "14"
hp: "33"
hit_dice: "6d8 + 6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":13},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Iron Scent\\",\\"text\\":\\"The rust monster can pinpoint the location of ferrous metal within 30 feet of itself.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The rust monster makes one Bite attack and uses Antennae twice.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 5 (1d8 + 1) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Antennae\\",\\"text\\":\\"The rust monster targets one nonmagical metal object\u2014armor or a weapon\u2014worn or carried by a creature within 5 feet of itself. *Dexterity Saving Throw*: DC 11, the creature with the object. *Failure:*  The object takes a -1 penalty to the AC it offers (armor) or to its attack rolls (weapon). Armor is destroyed if the penalty reduces its AC to 10, and a weapon is destroyed if its penalty reaches -5. The penalty can be removed by casting the *Mending* spell on the armor or weapon.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Destroy Metal\\",\\"text\\":\\"The rust monster touches a nonmagical metal object within 5 feet of itself that isn't being worn or carried. The touch destroys a 1-foot Cube [Area of Effect]|XPHB|Cube of the object.\\"}]"
---

# Rust Monster
*Medium, Monstrosity, Unaligned*

**AC** 14
**HP** 33 (6d8 + 6)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 13 | 12 | 13 | 2 | 13 | 6 |

CR 1/2, PB +2, XP 100

## Traits

**Iron Scent**
The rust monster can pinpoint the location of ferrous metal within 30 feet of itself.

## Actions

**Multiattack**
The rust monster makes one Bite attack and uses Antennae twice.

**Bite**
*Melee Attack Roll:* +3, reach 5 ft. 5 (1d8 + 1) Piercing damage.

**Antennae**
The rust monster targets one nonmagical metal object\u2014armor or a weapon\u2014worn or carried by a creature within 5 feet of itself. *Dexterity Saving Throw*: DC 11, the creature with the object. *Failure:*  The object takes a -1 penalty to the AC it offers (armor) or to its attack rolls (weapon). Armor is destroyed if the penalty reduces its AC to 10, and a weapon is destroyed if its penalty reaches -5. The penalty can be removed by casting the *Mending* spell on the armor or weapon.

**Destroy Metal**
The rust monster touches a nonmagical metal object within 5 feet of itself that isn't being worn or carried. The touch destroys a 1-foot Cube [Area of Effect]|XPHB|Cube of the object.
`,
      "sahuagin-warrior.md": `---
smType: creature
name: "Sahuagin Warrior"
size: "Medium"
type: "Fiend"
alignment: "Lawful Evil"
ac: "12"
hp: "22"
hit_dice: "4d8 + 4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":13},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":9}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Blood Frenzy\\",\\"text\\":\\"The sahuagin has Advantage on attack rolls against any creature that doesn't have all its Hit Points.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Limited Amphibiousness\\",\\"text\\":\\"The sahuagin can breathe air and water, but it must be submerged at least once every 4 hours to avoid suffocating outside water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Shark Telepathy\\",\\"text\\":\\"The sahuagin can magically control sharks within 120 feet of itself, using a special telepathy.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The sahuagin makes two Claw attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Slashing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Aquatic Charge\\",\\"text\\":\\"The sahuagin swims up to its Swim Speed straight toward an enemy it can see.\\"}]"
---

# Sahuagin Warrior
*Medium, Fiend, Lawful Evil*

**AC** 12
**HP** 22 (4d8 + 4)
**Speed** 30 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 13 | 11 | 12 | 12 | 13 | 9 |

CR 1/2, PB +2, XP 100

## Traits

**Blood Frenzy**
The sahuagin has Advantage on attack rolls against any creature that doesn't have all its Hit Points.

**Limited Amphibiousness**
The sahuagin can breathe air and water, but it must be submerged at least once every 4 hours to avoid suffocating outside water.

**Shark Telepathy**
The sahuagin can magically control sharks within 120 feet of itself, using a special telepathy.

## Actions

**Multiattack**
The sahuagin makes two Claw attacks.

**Claw**
*Melee Attack Roll:* +3, reach 5 ft. 4 (1d6 + 1) Slashing damage.

## Bonus Actions

**Aquatic Charge**
The sahuagin swims up to its Swim Speed straight toward an enemy it can see.
`,
      "salamander.md": `---
smType: creature
name: "Salamander"
size: "Large"
type: "Elemental"
alignment: "Neutral Evil"
ac: "15"
hp: "90"
hit_dice: "12d10 + 24"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":12}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Fire Aura\\",\\"text\\":\\"At the end of each of the salamander's turns, each creature of the salamander's choice in a 5-foot Emanation originating from the salamander takes 7 (2d6) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The salamander makes two Flame Spear attacks. It can replace one attack with a use of Constrict.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Flame Spear\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +7, reach 5 ft. or range 20/60 ft. 13 (2d8 + 4) Piercing damage plus 7 (2d6) Fire damage. HitomThe spear magically returns to the salamander's hand immediately after a ranged attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Constrict\\",\\"text\\":\\"*Strength Saving Throw*: DC 15, one Large or smaller creature the salamander can see within 10 feet. *Failure:*  11 (2d6 + 4) Bludgeoning damage plus 7 (2d6) Fire damage. The target has the Grappled condition (escape DC 14), and it has the Restrained condition until the grapple ends.\\"}]"
---

# Salamander
*Large, Elemental, Neutral Evil*

**AC** 15
**HP** 90 (12d10 + 24)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 14 | 15 | 11 | 10 | 12 |

CR 5, PB +3, XP 1800

## Traits

**Fire Aura**
At the end of each of the salamander's turns, each creature of the salamander's choice in a 5-foot Emanation originating from the salamander takes 7 (2d6) Fire damage.

## Actions

**Multiattack**
The salamander makes two Flame Spear attacks. It can replace one attack with a use of Constrict.

**Flame Spear**
*Melee or Ranged Attack Roll:* +7, reach 5 ft. or range 20/60 ft. 13 (2d8 + 4) Piercing damage plus 7 (2d6) Fire damage. HitomThe spear magically returns to the salamander's hand immediately after a ranged attack.

**Constrict**
*Strength Saving Throw*: DC 15, one Large or smaller creature the salamander can see within 10 feet. *Failure:*  11 (2d6 + 4) Bludgeoning damage plus 7 (2d6) Fire damage. The target has the Grappled condition (escape DC 14), and it has the Restrained condition until the grapple ends.
`,
      "satyr.md": `---
smType: creature
name: "Satyr"
size: "Medium"
type: "Fey"
alignment: "Chaotic Neutral"
ac: "13"
hp: "31"
hit_dice: "7d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":12},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":14}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The satyr has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Hooves\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Bludgeoning damage. If the target is a Medium or smaller creature, the satyr pushes the target up to 10 feet straight away from itself.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Mockery\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 12, one creature the satyr can see within 90 feet. *Failure:*  5 (1d6 + 2) Psychic damage.\\"}]"
---

# Satyr
*Medium, Fey, Chaotic Neutral*

**AC** 13
**HP** 31 (7d8)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 12 | 16 | 11 | 12 | 10 | 14 |

CR 1/2, PB +2, XP 100

## Traits

**Magic Resistance**
The satyr has Advantage on saving throws against spells and other magical effects.

## Actions

**Hooves**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Bludgeoning damage. If the target is a Medium or smaller creature, the satyr pushes the target up to 10 feet straight away from itself.

**Mockery**
*Wisdom Saving Throw*: DC 12, one creature the satyr can see within 90 feet. *Failure:*  5 (1d6 + 2) Psychic damage.
`,
      "scout.md": `---
smType: creature
name: "Scout"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "13"
hp: "16"
hit_dice: "3d8 + 3"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":11},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The scout makes two attacks, using Shortsword and Longbow in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Shortsword\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Longbow\\",\\"text\\":\\"*Ranged Attack Roll:* +4, range 150/600 ft. 6 (1d8 + 2) Piercing damage.\\"}]"
---

# Scout
*Small, Humanoid, Neutral Neutral*

**AC** 13
**HP** 16 (3d8 + 3)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 11 | 14 | 12 | 11 | 13 | 11 |

CR 1/2, PB +2, XP 100

## Actions

**Multiattack**
The scout makes two attacks, using Shortsword and Longbow in any combination.

**Shortsword**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage.

**Longbow**
*Ranged Attack Roll:* +4, range 150/600 ft. 6 (1d8 + 2) Piercing damage.
`,
      "sea-hag.md": `---
smType: creature
name: "Sea Hag"
size: "Medium"
type: "Fey"
alignment: "Chaotic Evil"
ac: "14"
hp: "52"
hit_dice: "7d8 + 21"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":13}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The hag can breathe air and water.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Vile Appearance\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 11, any Beast or Humanoid that starts its turn within 30 feet of the hag and can see the hag's true form. *Failure:*  The target has the Frightened condition until the start of its next turn. *Success:*  The target is immune to this hag's Vile Appearance for 24 hours.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Death Glare (Recharge 5-6)\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 11, one Frightened creature the hag can see within 30 feet. *Failure:*  If the target has 20 Hit Points or fewer, it drops to 0 Hit Points. Otherwise, the target takes 13 (3d8) Psychic damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Illusory Appearance\\",\\"text\\":\\"The hag casts *Disguise Self*, using Constitution as the spellcasting ability (spell save DC 13). The spell's duration is 24 hours. - **At Will:** *Disguise Self*\\"}]"
---

# Sea Hag
*Medium, Fey, Chaotic Evil*

**AC** 14
**HP** 52 (7d8 + 21)
**Speed** 30 ft., swim 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 13 | 16 | 12 | 12 | 13 |

CR 2, PB +2, XP 450

## Traits

**Amphibious**
The hag can breathe air and water.

**Vile Appearance**
*Wisdom Saving Throw*: DC 11, any Beast or Humanoid that starts its turn within 30 feet of the hag and can see the hag's true form. *Failure:*  The target has the Frightened condition until the start of its next turn. *Success:*  The target is immune to this hag's Vile Appearance for 24 hours.

## Actions

**Claw**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage.

**Death Glare (Recharge 5-6)**
*Wisdom Saving Throw*: DC 11, one Frightened creature the hag can see within 30 feet. *Failure:*  If the target has 20 Hit Points or fewer, it drops to 0 Hit Points. Otherwise, the target takes 13 (3d8) Psychic damage.

**Illusory Appearance**
The hag casts *Disguise Self*, using Constitution as the spellcasting ability (spell save DC 13). The spell's duration is 24 hours. - **At Will:** *Disguise Self*
`,
      "shadow.md": `---
smType: creature
name: "Shadow"
size: "Medium"
type: "Undead"
alignment: "Chaotic Evil"
ac: "12"
hp: "27"
hit_dice: "5d8 + 5"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":6},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amorphous\\",\\"text\\":\\"The shadow can move through a space as narrow as 1 inch without expending extra movement to do so.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Sunlight Weakness\\",\\"text\\":\\"While in sunlight, the shadow has Disadvantage on D20 Test.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Draining Swipe\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Necrotic damage, and the target's Strength score decreases by 1d4. The target dies if this reduces that score to 0. If a Humanoid is slain by this attack, a Shadow rises from the corpse 1d4 hours later.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Shadow Stealth\\",\\"text\\":\\"While in Dim Light or darkness, the shadow takes the Hide action.\\"}]"
---

# Shadow
*Medium, Undead, Chaotic Evil*

**AC** 12
**HP** 27 (5d8 + 5)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 6 | 14 | 13 | 6 | 10 | 8 |

CR 1/2, PB +2, XP 100

## Traits

**Amorphous**
The shadow can move through a space as narrow as 1 inch without expending extra movement to do so.

**Sunlight Weakness**
While in sunlight, the shadow has Disadvantage on D20 Test.

## Actions

**Draining Swipe**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Necrotic damage, and the target's Strength score decreases by 1d4. The target dies if this reduces that score to 0. If a Humanoid is slain by this attack, a Shadow rises from the corpse 1d4 hours later.

## Bonus Actions

**Shadow Stealth**
While in Dim Light or darkness, the shadow takes the Hide action.
`,
      "shambling-mound.md": `---
smType: creature
name: "Shambling Mound"
size: "Large"
type: "Plant"
alignment: "Unaligned"
ac: "15"
hp: "110"
hit_dice: "13d10 + 39"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":8},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":5},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Lightning Absorption\\",\\"text\\":\\"Whenever the shambling mound is subjected to Lightning damage, it regains a number of Hit Points equal to the Lightning damage dealt.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The shambling mound makes three Charged Tendril attacks. It can replace one attack with a use of Engulf.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Charged Tendril\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 10 ft. 7 (1d6 + 4) Bludgeoning damage plus 5 (2d4) Lightning damage. If the target is a Medium or smaller creature, the shambling mound pulls the target 5 feet straight toward itself.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Engulf\\",\\"text\\":\\"*Strength Saving Throw*: DC 15, one Medium or smaller creature within 5 feet. *Failure:*  The target is pulled into the shambling mound's space and has the Grappled condition (escape DC 14). Until the grapple ends, the target has the Blinded and Restrained conditions, and it takes 10 (3d6) Lightning damage at the start of each of its turns. When the shambling mound moves, the Grappled target moves with it, costing it no extra movement. The shambling mound can have only one creature Grappled by this action at a time.\\"}]"
---

# Shambling Mound
*Large, Plant, Unaligned*

**AC** 15
**HP** 110 (13d10 + 39)
**Speed** 30 ft., swim 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 8 | 16 | 5 | 10 | 5 |

CR 5, PB +3, XP 1800

## Traits

**Lightning Absorption**
Whenever the shambling mound is subjected to Lightning damage, it regains a number of Hit Points equal to the Lightning damage dealt.

## Actions

**Multiattack**
The shambling mound makes three Charged Tendril attacks. It can replace one attack with a use of Engulf.

**Charged Tendril**
*Melee Attack Roll:* +7, reach 10 ft. 7 (1d6 + 4) Bludgeoning damage plus 5 (2d4) Lightning damage. If the target is a Medium or smaller creature, the shambling mound pulls the target 5 feet straight toward itself.

**Engulf**
*Strength Saving Throw*: DC 15, one Medium or smaller creature within 5 feet. *Failure:*  The target is pulled into the shambling mound's space and has the Grappled condition (escape DC 14). Until the grapple ends, the target has the Blinded and Restrained conditions, and it takes 10 (3d6) Lightning damage at the start of each of its turns. When the shambling mound moves, the Grappled target moves with it, costing it no extra movement. The shambling mound can have only one creature Grappled by this action at a time.
`,
      "shield-guardian.md": `---
smType: creature
name: "Shield Guardian"
size: "Large"
type: "Construct"
alignment: "Unaligned"
ac: "17"
hp: "142"
hit_dice: "15d10 + 60"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":8},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":7},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":3}]"
pb: "+3"
cr: "7"
xp: "2900"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Bound\\",\\"text\\":\\"The guardian is magically bound to an amulet. While the guardian and its amulet are on the same plane of existence, the amulet's wearer can telepathically call the guardian to travel to it, and the guardian knows the distance and direction to the amulet. If the guardian is within 60 feet of the amulet's wearer, half of any damage the wearer takes (round up) is transferred to the guardian.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Regeneration\\",\\"text\\":\\"The guardian regains 10 Hit Points at the start of each of its turns if it has at least 1 Hit Point.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Spell Storing\\",\\"text\\":\\"A spellcaster who wears the guardian's amulet can cause the guardian to store one spell of level 4 or lower. To do so, the wearer must cast the spell on the guardian while within 5 feet of it. The spell has no effect but is stored within the guardian. Any previously stored spell is lost when a new spell is stored. The guardian can cast the spell stored with any parameters set by the original caster, requiring no spell components and using the caster's spellcasting ability. The stored spell is then lost.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The guardian makes two Fist attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fist\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Bludgeoning damage plus 7 (2d6) Force damage.\\"}]"
---

# Shield Guardian
*Large, Construct, Unaligned*

**AC** 17
**HP** 142 (15d10 + 60)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 8 | 18 | 7 | 10 | 3 |

CR 7, PB +3, XP 2900

## Traits

**Bound**
The guardian is magically bound to an amulet. While the guardian and its amulet are on the same plane of existence, the amulet's wearer can telepathically call the guardian to travel to it, and the guardian knows the distance and direction to the amulet. If the guardian is within 60 feet of the amulet's wearer, half of any damage the wearer takes (round up) is transferred to the guardian.

**Regeneration**
The guardian regains 10 Hit Points at the start of each of its turns if it has at least 1 Hit Point.

**Spell Storing**
A spellcaster who wears the guardian's amulet can cause the guardian to store one spell of level 4 or lower. To do so, the wearer must cast the spell on the guardian while within 5 feet of it. The spell has no effect but is stored within the guardian. Any previously stored spell is lost when a new spell is stored. The guardian can cast the spell stored with any parameters set by the original caster, requiring no spell components and using the caster's spellcasting ability. The stored spell is then lost.

## Actions

**Multiattack**
The guardian makes two Fist attacks.

**Fist**
*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Bludgeoning damage plus 7 (2d6) Force damage.
`,
      "shrieker-fungus.md": `---
smType: creature
name: "Shrieker Fungus"
size: "Medium"
type: "Plant"
alignment: "Unaligned"
ac: "5"
hp: "13"
hit_dice: "3d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":1},{\\"ability\\":\\"dex\\",\\"score\\":1},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":3},{\\"ability\\":\\"cha\\",\\"score\\":1}]"
cr: "0"
xp: "0"
---

# Shrieker Fungus
*Medium, Plant, Unaligned*

**AC** 5
**HP** 13 (3d8)
**Speed** 5 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 1 | 1 | 10 | 1 | 3 | 1 |

CR 0, XP 0
`,
      "silver-dragon-wyrmling.md": `---
smType: creature
name: "Silver Dragon Wyrmling"
size: "Medium"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Lawful Good"
ac: "17"
hp: "45"
hit_dice: "6d8 + 18"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":15}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":2},{\\"ability\\":\\"wis\\",\\"bonus\\":2}]"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes two Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 9 (1d10 + 4) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Cold Breath (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 13, each creature in a 15-foot Cone. *Failure:*  18 (4d8) Cold damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Paralyzing Breath\\",\\"text\\":\\"*Constitution Saving Throw*: DC 13, each creature in a 15-foot Cone. *First Failure* The target has the Incapacitated condition until the end of its next turn, when it repeats the save. *Second Failure* The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.\\"}]"
---

# Silver Dragon Wyrmling
*Medium, Dragon, Lawful Good*

**AC** 17
**HP** 45 (6d8 + 18)
**Speed** 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 10 | 17 | 12 | 11 | 15 |

CR 2, PB +2, XP 450

## Actions

**Multiattack**
The dragon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +6, reach 5 ft. 9 (1d10 + 4) Piercing damage.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 13, each creature in a 15-foot Cone. *Failure:*  18 (4d8) Cold damage. *Success:*  Half damage.

**Paralyzing Breath**
*Constitution Saving Throw*: DC 13, each creature in a 15-foot Cone. *First Failure* The target has the Incapacitated condition until the end of its next turn, when it repeats the save. *Second Failure* The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.
`,
      "skeleton.md": `---
smType: creature
name: "Skeleton"
size: "Medium"
type: "Undead"
alignment: "Lawful Evil"
ac: "14"
hp: "13"
hit_dice: "2d8 + 4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":8},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Shortsword\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Shortbow\\",\\"text\\":\\"*Ranged Attack Roll:* +5, range 80/320 ft. 6 (1d6 + 3) Piercing damage.\\"}]"
---

# Skeleton
*Medium, Undead, Lawful Evil*

**AC** 14
**HP** 13 (2d8 + 4)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 16 | 15 | 6 | 8 | 5 |

CR 1/4, PB +2, XP 50

## Actions

**Shortsword**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Piercing damage.

**Shortbow**
*Ranged Attack Roll:* +5, range 80/320 ft. 6 (1d6 + 3) Piercing damage.
`,
      "solar.md": `---
smType: creature
name: "Solar"
size: "Large"
type: "Celestial"
type_tags: ["Angel"]
alignment: "Lawful Good"
ac: "21"
hp: "297"
hit_dice: "22d10 + 176"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"},\\"fly\\":{\\"distance\\":\\"150 ft.\\",\\"hover\\":true}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":26},{\\"ability\\":\\"dex\\",\\"score\\":22},{\\"ability\\":\\"con\\",\\"score\\":26},{\\"ability\\":\\"int\\",\\"score\\":25},{\\"ability\\":\\"wis\\",\\"score\\":25},{\\"ability\\":\\"cha\\",\\"score\\":30}]"
pb: "+7"
cr: "21"
xp: "33000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Divine Awareness\\",\\"text\\":\\"The solar knows if it hears a lie.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Exalted Restoration\\",\\"text\\":\\"If the solar dies outside Mount Celestia, its body disappears, and it gains a new body instantly, reviving with all its Hit Points somewhere in Mount Celestia.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (4/Day)\\",\\"text\\":\\"If the solar fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The solar has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The solar makes two Flying Sword attacks. It can replace one attack with a use of Slaying Bow.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Flying Sword\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +15, reach 10 ft. or range 120 ft. 22 (4d6 + 8) Slashing damage plus 36 (8d8) Radiant damage. HitomThe sword magically returns to the solar's hand or hovers within 5 feet of the solar immediately after a ranged attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Slaying Bow\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 21, one creature the solar can see within 600 feet. *Failure:*  If the creature has 100 Hit Points or fewer, it dies. It otherwise takes 24 (4d8 + 6) Piercing damage plus 36 (8d8) Radiant damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The solar casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 25): - **At Will:** *Detect Evil and Good* - **1e/Day Each:** *Commune*, *Control Weather*, *Dispel Evil and Good*, *Resurrection*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Divine Aid (3/Day)\\",\\"text\\":\\"The solar casts *Cure Wounds* (level 2 version), *Lesser Restoration*, or *Remove Curse*, using the same spellcasting ability as Spellcasting.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Blinding Gaze\\",\\"text\\":\\"*Constitution Saving Throw*: DC 25, one creature the solar can see within 120 feet. *Failure:*  The target has the Blinded condition for 1 minute. *Failure or Success*:  The solar can't take this action again until the start of its next turn.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Radiant Teleport\\",\\"text\\":\\"The solar teleports up to 60 feet to an unoccupied space it can see. *Dexterity Saving Throw*: DC 25, each creature in a 10-foot Emanation originating from the solar at its destination space. *Failure:*  11 (2d10) Radiant damage. *Success:*  Half damage.\\"}]"
---

# Solar
*Large, Celestial, Lawful Good*

**AC** 21
**HP** 297 (22d10 + 176)
**Speed** 50 ft., fly 150 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 26 | 22 | 26 | 25 | 25 | 30 |

CR 21, PB +7, XP 33000

## Traits

**Divine Awareness**
The solar knows if it hears a lie.

**Exalted Restoration**
If the solar dies outside Mount Celestia, its body disappears, and it gains a new body instantly, reviving with all its Hit Points somewhere in Mount Celestia.

**Legendary Resistance (4/Day)**
If the solar fails a saving throw, it can choose to succeed instead.

**Magic Resistance**
The solar has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The solar makes two Flying Sword attacks. It can replace one attack with a use of Slaying Bow.

**Flying Sword**
*Melee or Ranged Attack Roll:* +15, reach 10 ft. or range 120 ft. 22 (4d6 + 8) Slashing damage plus 36 (8d8) Radiant damage. HitomThe sword magically returns to the solar's hand or hovers within 5 feet of the solar immediately after a ranged attack.

**Slaying Bow**
*Dexterity Saving Throw*: DC 21, one creature the solar can see within 600 feet. *Failure:*  If the creature has 100 Hit Points or fewer, it dies. It otherwise takes 24 (4d8 + 6) Piercing damage plus 36 (8d8) Radiant damage.

**Spellcasting**
The solar casts one of the following spells, requiring no Material components and using Charisma as the spellcasting ability (spell save DC 25): - **At Will:** *Detect Evil and Good* - **1e/Day Each:** *Commune*, *Control Weather*, *Dispel Evil and Good*, *Resurrection*

## Bonus Actions

**Divine Aid (3/Day)**
The solar casts *Cure Wounds* (level 2 version), *Lesser Restoration*, or *Remove Curse*, using the same spellcasting ability as Spellcasting.

## Legendary Actions

**Blinding Gaze**
*Constitution Saving Throw*: DC 25, one creature the solar can see within 120 feet. *Failure:*  The target has the Blinded condition for 1 minute. *Failure or Success*:  The solar can't take this action again until the start of its next turn.

**Radiant Teleport**
The solar teleports up to 60 feet to an unoccupied space it can see. *Dexterity Saving Throw*: DC 25, each creature in a 10-foot Emanation originating from the solar at its destination space. *Failure:*  11 (2d10) Radiant damage. *Success:*  Half damage.
`,
      "specter.md": `---
smType: creature
name: "Specter"
size: "Medium"
type: "Undead"
alignment: "Chaotic Evil"
ac: "12"
hp: "22"
hit_dice: "5d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"50 ft.\\",\\"hover\\":true}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":1},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Incorporeal Movement\\",\\"text\\":\\"The specter can move through other creatures and objects as if they were Difficult Terrain. It takes 5 (1d10) Force damage if it ends its turn inside an object.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Sunlight Sensitivity\\",\\"text\\":\\"While in sunlight, the specter has Disadvantage on ability checks and attack rolls.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Life Drain\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 7 (2d6) Necrotic damage. If the target is a creature, its Hit Point maximum decreases by an amount equal to the damage taken.\\"}]"
---

# Specter
*Medium, Undead, Chaotic Evil*

**AC** 12
**HP** 22 (5d8)
**Speed** 30 ft., fly 50 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 1 | 14 | 11 | 10 | 10 | 11 |

CR 1, PB +2, XP 200

## Traits

**Incorporeal Movement**
The specter can move through other creatures and objects as if they were Difficult Terrain. It takes 5 (1d10) Force damage if it ends its turn inside an object.

**Sunlight Sensitivity**
While in sunlight, the specter has Disadvantage on ability checks and attack rolls.

## Actions

**Life Drain**
*Melee Attack Roll:* +4, reach 5 ft. 7 (2d6) Necrotic damage. If the target is a creature, its Hit Point maximum decreases by an amount equal to the damage taken.
`,
      "sphinx-of-lore.md": `---
smType: creature
name: "Sphinx of Lore"
size: "Large"
type: "Celestial"
alignment: "Lawful Neutral"
ac: "17"
hp: "170"
hit_dice: "20d10 + 60"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":18},{\\"ability\\":\\"wis\\",\\"score\\":18},{\\"ability\\":\\"cha\\",\\"score\\":18}]"
cr: "11"
xp: "7200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Inscrutable\\",\\"text\\":\\"No magic can observe the sphinx remotely or detect its thoughts without its permission. Wisdom (Insight) checks made to ascertain its intentions or sincerity are made with Disadvantage.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day, or 4/Day in Lair)\\",\\"text\\":\\"If the sphinx fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The sphinx makes three Claw attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +8, reach 5 ft. 14 (3d6 + 4) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Mind-Rending Roar (Recharge 5-6)\\",\\"text\\":\\"*Wisdom Saving Throw*: DC 16, each enemy in a 300-foot Emanation originating from the sphinx. *Failure:*  35 (10d6) Psychic damage, and the target has the Incapacitated condition until the start of the sphinx's next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The sphinx casts one of the following spells, requiring no Material components and using Intelligence as the spellcasting ability (spell save DC 16): - **At Will:** *Detect Magic*, *Identify*, *Mage Hand*, *Minor Illusion*, *Prestidigitation* - **1e/Day Each:** *Dispel Magic*, *Legend Lore*, *Locate Object*, *Plane Shift*, *Remove Curse*, *Tongues*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Arcane Prowl\\",\\"text\\":\\"The sphinx can teleport up to 30 feet to an unoccupied space it can see, and it makes one Claw attack.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Weight of Years\\",\\"text\\":\\"*Constitution Saving Throw*: DC 16, one creature the sphinx can see within 120 feet. *Failure:*  The target gains 1 Exhaustion level. While the target has any Exhaustion levels, it appears 3d10 years older. *Failure or Success*:  The sphinx can't take this action again until the start of its next turn.\\"}]"
---

# Sphinx of Lore
*Large, Celestial, Lawful Neutral*

**AC** 17
**HP** 170 (20d10 + 60)
**Speed** 40 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 15 | 16 | 18 | 18 | 18 |

CR 11, XP 7200

## Traits

**Inscrutable**
No magic can observe the sphinx remotely or detect its thoughts without its permission. Wisdom (Insight) checks made to ascertain its intentions or sincerity are made with Disadvantage.

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the sphinx fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The sphinx makes three Claw attacks.

**Claw**
*Melee Attack Roll:* +8, reach 5 ft. 14 (3d6 + 4) Slashing damage.

**Mind-Rending Roar (Recharge 5-6)**
*Wisdom Saving Throw*: DC 16, each enemy in a 300-foot Emanation originating from the sphinx. *Failure:*  35 (10d6) Psychic damage, and the target has the Incapacitated condition until the start of the sphinx's next turn.

**Spellcasting**
The sphinx casts one of the following spells, requiring no Material components and using Intelligence as the spellcasting ability (spell save DC 16): - **At Will:** *Detect Magic*, *Identify*, *Mage Hand*, *Minor Illusion*, *Prestidigitation* - **1e/Day Each:** *Dispel Magic*, *Legend Lore*, *Locate Object*, *Plane Shift*, *Remove Curse*, *Tongues*

## Legendary Actions

**Arcane Prowl**
The sphinx can teleport up to 30 feet to an unoccupied space it can see, and it makes one Claw attack.

**Weight of Years**
*Constitution Saving Throw*: DC 16, one creature the sphinx can see within 120 feet. *Failure:*  The target gains 1 Exhaustion level. While the target has any Exhaustion levels, it appears 3d10 years older. *Failure or Success*:  The sphinx can't take this action again until the start of its next turn.
`,
      "sphinx-of-valor.md": `---
smType: creature
name: "Sphinx of Valor"
size: "Large"
type: "Celestial"
alignment: "Lawful Neutral"
ac: "17"
hp: "199"
hit_dice: "19d10 + 95"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":22},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":20},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":23},{\\"ability\\":\\"cha\\",\\"score\\":18}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":6},{\\"ability\\":\\"con\\",\\"bonus\\":11},{\\"ability\\":\\"int\\",\\"bonus\\":9},{\\"ability\\":\\"wis\\",\\"bonus\\":12}]"
cr: "17"
xp: "18000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Inscrutable\\",\\"text\\":\\"No magic can observe the sphinx remotely or detect its thoughts without its permission. Wisdom (Insight) checks made to ascertain its intentions or sincerity are made with Disadvantage.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day, or 4/Day in Lair)\\",\\"text\\":\\"If the sphinx fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The sphinx makes two Claw attacks and uses Roar.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +12, reach 5 ft. 20 (4d6 + 6) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Roar (3/Day)\\",\\"text\\":\\"The sphinx emits a magical roar. Whenever it roars, the roar has a different effect, as detailed below (the sequence resets when it takes a Long Rest): - **First Roar**: *Wisdom Saving Throw*: DC 20, each enemy in a 500-foot Emanation originating from the sphinx. *Failure:*  The target has the Frightened condition for 1 minute. - **Second Roar**: *Wisdom Saving Throw*: DC 20, each enemy in a 500-foot Emanation originating from the sphinx. *Failure:*  The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically. - **Third Roar**: *Constitution Saving Throw*: DC 20, each enemy in a 500-foot Emanation originating from the sphinx. *Failure:*  44 (8d10) Thunder damage, and the target has the Prone condition. *Success:*  Half damage only.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The sphinx casts one of the following spells, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 20): - **At Will:** *Detect Evil and Good*, *Thaumaturgy* - **1e/Day Each:** *Detect Magic*, *Dispel Magic*, *Greater Restoration*, *Heroes' Feast*, *Zone of Truth*\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Arcane Prowl\\",\\"text\\":\\"The sphinx can teleport up to 30 feet to an unoccupied space it can see, and it makes one Claw attack.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Weight of Years\\",\\"text\\":\\"*Constitution Saving Throw*: DC 16, one creature the sphinx can see within 120 feet. *Failure:*  The target gains 1 Exhaustion level. While the target has any Exhaustion levels, it appears 3d10 years older. *Failure or Success*:  The sphinx can't take this action again until the start of its next turn.\\"}]"
---

# Sphinx of Valor
*Large, Celestial, Lawful Neutral*

**AC** 17
**HP** 199 (19d10 + 95)
**Speed** 40 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 22 | 10 | 20 | 16 | 23 | 18 |

CR 17, XP 18000

## Traits

**Inscrutable**
No magic can observe the sphinx remotely or detect its thoughts without its permission. Wisdom (Insight) checks made to ascertain its intentions or sincerity are made with Disadvantage.

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the sphinx fails a saving throw, it can choose to succeed instead.

## Actions

**Multiattack**
The sphinx makes two Claw attacks and uses Roar.

**Claw**
*Melee Attack Roll:* +12, reach 5 ft. 20 (4d6 + 6) Slashing damage.

**Roar (3/Day)**
The sphinx emits a magical roar. Whenever it roars, the roar has a different effect, as detailed below (the sequence resets when it takes a Long Rest): - **First Roar**: *Wisdom Saving Throw*: DC 20, each enemy in a 500-foot Emanation originating from the sphinx. *Failure:*  The target has the Frightened condition for 1 minute. - **Second Roar**: *Wisdom Saving Throw*: DC 20, each enemy in a 500-foot Emanation originating from the sphinx. *Failure:*  The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically. - **Third Roar**: *Constitution Saving Throw*: DC 20, each enemy in a 500-foot Emanation originating from the sphinx. *Failure:*  44 (8d10) Thunder damage, and the target has the Prone condition. *Success:*  Half damage only.

**Spellcasting**
The sphinx casts one of the following spells, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 20): - **At Will:** *Detect Evil and Good*, *Thaumaturgy* - **1e/Day Each:** *Detect Magic*, *Dispel Magic*, *Greater Restoration*, *Heroes' Feast*, *Zone of Truth*

## Legendary Actions

**Arcane Prowl**
The sphinx can teleport up to 30 feet to an unoccupied space it can see, and it makes one Claw attack.

**Weight of Years**
*Constitution Saving Throw*: DC 16, one creature the sphinx can see within 120 feet. *Failure:*  The target gains 1 Exhaustion level. While the target has any Exhaustion levels, it appears 3d10 years older. *Failure or Success*:  The sphinx can't take this action again until the start of its next turn.
`,
      "sphinx-of-wonder.md": `---
smType: creature
name: "Sphinx of Wonder"
size: "Small"
type: "Celestial"
alignment: "Lawful Good"
ac: "13"
hp: "24"
hit_dice: "7d4 + 7"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"fly\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":6},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":15},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The sphinx has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Slashing damage plus 7 (2d6) Radiant damage.\\"}]"
---

# Sphinx of Wonder
*Small, Celestial, Lawful Good*

**AC** 13
**HP** 24 (7d4 + 7)
**Speed** 20 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 6 | 17 | 13 | 15 | 12 | 11 |

CR 1, PB +2, XP 200

## Traits

**Magic Resistance**
The sphinx has Advantage on saving throws against spells and other magical effects.

## Actions

**Rend**
*Melee Attack Roll:* +5, reach 5 ft. 5 (1d4 + 3) Slashing damage plus 7 (2d6) Radiant damage.
`,
      "spirit-naga.md": `---
smType: creature
name: "Spirit Naga"
size: "Large"
type: "Fiend"
alignment: "Chaotic Evil"
ac: "17"
hp: "135"
hit_dice: "18d10 + 36"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":16}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":6},{\\"ability\\":\\"con\\",\\"bonus\\":5},{\\"ability\\":\\"wis\\",\\"bonus\\":5},{\\"ability\\":\\"cha\\",\\"bonus\\":6}]"
cr: "8"
xp: "3900"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Fiendish Restoration\\",\\"text\\":\\"If it dies, the naga returns to life in 1d6 days and regains all its Hit Points. Only a *Wish* spell can prevent this trait from functioning.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The naga makes three attacks, using Bite or Necrotic Ray in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 10 ft. 7 (1d6 + 4) Piercing damage plus 14 (4d6) Poison damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Necrotic Ray\\",\\"text\\":\\"*Ranged Attack Roll:* +6, range 60 ft. 21 (6d6) Necrotic damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The naga casts one of the following spells, requiring no Somatic or Material components and using Intelligence as the spellcasting ability (spell save DC 14): - **At Will:** *Detect Magic*, *Mage Hand*, *Minor Illusion*, *Water Breathing* - **2e/Day Each:** *Detect Thoughts*, *Dimension Door*, *Hold Person*, *Lightning Bolt*\\"}]"
---

# Spirit Naga
*Large, Fiend, Chaotic Evil*

**AC** 17
**HP** 135 (18d10 + 36)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 17 | 14 | 16 | 15 | 16 |

CR 8, PB +3, XP 3900

## Traits

**Fiendish Restoration**
If it dies, the naga returns to life in 1d6 days and regains all its Hit Points. Only a *Wish* spell can prevent this trait from functioning.

## Actions

**Multiattack**
The naga makes three attacks, using Bite or Necrotic Ray in any combination.

**Bite**
*Melee Attack Roll:* +7, reach 10 ft. 7 (1d6 + 4) Piercing damage plus 14 (4d6) Poison damage.

**Necrotic Ray**
*Ranged Attack Roll:* +6, range 60 ft. 21 (6d6) Necrotic damage.

**Spellcasting**
The naga casts one of the following spells, requiring no Somatic or Material components and using Intelligence as the spellcasting ability (spell save DC 14): - **At Will:** *Detect Magic*, *Mage Hand*, *Minor Illusion*, *Water Breathing* - **2e/Day Each:** *Detect Thoughts*, *Dimension Door*, *Hold Person*, *Lightning Bolt*
`,
      "sprite.md": `---
smType: creature
name: "Sprite"
size: "Small"
type: "Fey"
alignment: "Neutral Good"
ac: "15"
hp: "10"
hit_dice: "4d4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"fly\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":3},{\\"ability\\":\\"dex\\",\\"score\\":18},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":14},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Needle Sword\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 6 (1d4 + 4) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Enchanting Bow\\",\\"text\\":\\"*Ranged Attack Roll:* +6, range 40/160 ft. 1 Piercing damage, and the target has the Charmed condition until the start of the sprite's next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Heart Sight\\",\\"text\\":\\"*Charisma Saving Throw*: DC 10, one creature within 5 feet the sprite can see (Celestials, Fiends, and Undead automatically fail the save). *Failure:*  The sprite knows the target's emotions and alignment.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Invisibility\\",\\"text\\":\\"The sprite casts *Invisibility* on itself, requiring no spell components and using Charisma as the spellcasting ability. - **At Will:** *Invisibility*\\"}]"
---

# Sprite
*Small, Fey, Neutral Good*

**AC** 15
**HP** 10 (4d4)
**Speed** 10 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 3 | 18 | 10 | 14 | 13 | 11 |

CR 1/4, PB +2, XP 50

## Actions

**Needle Sword**
*Melee Attack Roll:* +6, reach 5 ft. 6 (1d4 + 4) Piercing damage.

**Enchanting Bow**
*Ranged Attack Roll:* +6, range 40/160 ft. 1 Piercing damage, and the target has the Charmed condition until the start of the sprite's next turn.

**Heart Sight**
*Charisma Saving Throw*: DC 10, one creature within 5 feet the sprite can see (Celestials, Fiends, and Undead automatically fail the save). *Failure:*  The sprite knows the target's emotions and alignment.

**Invisibility**
The sprite casts *Invisibility* on itself, requiring no spell components and using Charisma as the spellcasting ability. - **At Will:** *Invisibility*
`,
      "spy.md": `---
smType: creature
name: "Spy"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "12"
hp: "27"
hit_dice: "6d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":16}]"
pb: "+2"
cr: "1"
xp: "200"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Shortsword\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 7 (2d6) Poison damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Hand Crossbow\\",\\"text\\":\\"*Ranged Attack Roll:* +4, range 30/120 ft. 5 (1d6 + 2) Piercing damage plus 7 (2d6) Poison damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Cunning Action\\",\\"text\\":\\"The spy takes the Dash, Disengage, or Hide action.\\"}]"
---

# Spy
*Small, Humanoid, Neutral Neutral*

**AC** 12
**HP** 27 (6d8)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 15 | 10 | 12 | 14 | 16 |

CR 1, PB +2, XP 200

## Actions

**Shortsword**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Piercing damage plus 7 (2d6) Poison damage.

**Hand Crossbow**
*Ranged Attack Roll:* +4, range 30/120 ft. 5 (1d6 + 2) Piercing damage plus 7 (2d6) Poison damage.

## Bonus Actions

**Cunning Action**
The spy takes the Dash, Disengage, or Hide action.
`,
      "steam-mephit.md": `---
smType: creature
name: "Steam Mephit"
size: "Small"
type: "Elemental"
alignment: "Neutral Evil"
ac: "10"
hp: "17"
hit_dice: "5d6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":5},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":12}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Blurred Form\\",\\"text\\":\\"Attack rolls against the mephit are made with Disadvantage unless the mephit has the Incapacitated condition.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Death Burst\\",\\"text\\":\\"The mephit explodes when it dies. *Dexterity Saving Throw*: DC 10, each creature in a 5-foot Emanation originating from the mephit. *Failure:*  5 (2d4) Fire damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Slashing damage plus 2 (1d4) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Steam Breath\\",\\"recharge\\":\\"Recharge 6\\",\\"text\\":\\"*Constitution Saving Throw*: DC 10, each creature in a 15-foot Cone. *Failure:*  5 (2d4) Fire damage, and the target's Speed decreases by 10 feet until the end of the mephit's next turn. *Success:*  Half damage only. *Failure or Success*:  Being underwater doesn't grant Resistance to this Fire damage.\\"}]"
---

# Steam Mephit
*Small, Elemental, Neutral Evil*

**AC** 10
**HP** 17 (5d6)
**Speed** 30 ft., fly 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 5 | 11 | 10 | 11 | 10 | 12 |

CR 1/4, PB +2, XP 50

## Traits

**Blurred Form**
Attack rolls against the mephit are made with Disadvantage unless the mephit has the Incapacitated condition.

**Death Burst**
The mephit explodes when it dies. *Dexterity Saving Throw*: DC 10, each creature in a 5-foot Emanation originating from the mephit. *Failure:*  5 (2d4) Fire damage. *Success:*  Half damage.

## Actions

**Claw**
*Melee Attack Roll:* +2, reach 5 ft. 2 (1d4) Slashing damage plus 2 (1d4) Fire damage.

**Steam Breath (Recharge 6)**
*Constitution Saving Throw*: DC 10, each creature in a 15-foot Cone. *Failure:*  5 (2d4) Fire damage, and the target's Speed decreases by 10 feet until the end of the mephit's next turn. *Success:*  Half damage only. *Failure or Success*:  Being underwater doesn't grant Resistance to this Fire damage.
`,
      "stirge.md": `---
smType: creature
name: "Stirge"
size: "Small"
type: "Monstrosity"
alignment: "Unaligned"
ac: "13"
hp: "5"
hit_dice: "2d4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"10 ft.\\"},\\"fly\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":4},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":8},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+2"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Proboscis\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Piercing damage, and the stirge attaches to the target. While attached, the stirge can't make Proboscis attacks, and the target takes 5 (2d4) Necrotic damage at the start of each of the stirge's turns. The stirge can detach itself by spending 5 feet of its movement. The target or a creature within 5 feet of it can detach the stirge as an action.\\"}]"
---

# Stirge
*Small, Monstrosity, Unaligned*

**AC** 13
**HP** 5 (2d4)
**Speed** 10 ft., fly 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 4 | 16 | 11 | 2 | 8 | 6 |

CR 1/8, PB +2, XP 25

## Actions

**Proboscis**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Piercing damage, and the stirge attaches to the target. While attached, the stirge can't make Proboscis attacks, and the target takes 5 (2d4) Necrotic damage at the start of each of the stirge's turns. The stirge can detach itself by spending 5 feet of its movement. The target or a creature within 5 feet of it can detach the stirge as an action.
`,
      "stone-giant.md": `---
smType: creature
name: "Stone Giant"
size: "Huge"
type: "Giant"
alignment: "Neutral Neutral"
ac: "17"
hp: "126"
hit_dice: "11d12 + 55"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":23},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":20},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":9}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":5},{\\"ability\\":\\"con\\",\\"bonus\\":8},{\\"ability\\":\\"wis\\",\\"bonus\\":4}]"
cr: "7"
xp: "2900"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The giant makes two attacks, using Stone Club or Boulder in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Stone Club\\",\\"text\\":\\"*Melee Attack Roll:* +9, reach 15 ft. 22 (3d10 + 6) Bludgeoning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Boulder\\",\\"text\\":\\"*Ranged Attack Roll:* +9, range 60/240 ft. 15 (2d8 + 6) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.\\"}]"
---

# Stone Giant
*Huge, Giant, Neutral Neutral*

**AC** 17
**HP** 126 (11d12 + 55)
**Speed** 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 23 | 15 | 20 | 10 | 12 | 9 |

CR 7, PB +3, XP 2900

## Actions

**Multiattack**
The giant makes two attacks, using Stone Club or Boulder in any combination.

**Stone Club**
*Melee Attack Roll:* +9, reach 15 ft. 22 (3d10 + 6) Bludgeoning damage.

**Boulder**
*Ranged Attack Roll:* +9, range 60/240 ft. 15 (2d8 + 6) Bludgeoning damage. If the target is a Large or smaller creature, it has the Prone condition.
`,
      "stone-golem.md": `---
smType: creature
name: "Stone Golem"
size: "Large"
type: "Construct"
alignment: "Unaligned"
ac: "18"
hp: "220"
hit_dice: "21d10 + 105"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":22},{\\"ability\\":\\"dex\\",\\"score\\":9},{\\"ability\\":\\"con\\",\\"score\\":20},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":1}]"
pb: "+4"
cr: "10"
xp: "5900"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Immutable Form\\",\\"text\\":\\"The golem can't shape-shift.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The golem has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The golem makes two attacks, using Slam or Force Bolt in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Slam\\",\\"text\\":\\"*Melee Attack Roll:* +10, reach 5 ft. 15 (2d8 + 6) Bludgeoning damage plus 9 (2d8) Force damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Force Bolt\\",\\"text\\":\\"*Ranged Attack Roll:* +9, range 120 ft. 22 (4d10) Force damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Slow (Recharge 5-6)\\",\\"text\\":\\"The golem casts the *Slow* spell, requiring no spell components and using Constitution as the spellcasting ability (spell save DC 17).\\"}]"
---

# Stone Golem
*Large, Construct, Unaligned*

**AC** 18
**HP** 220 (21d10 + 105)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 22 | 9 | 20 | 3 | 11 | 1 |

CR 10, PB +4, XP 5900

## Traits

**Immutable Form**
The golem can't shape-shift.

**Magic Resistance**
The golem has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The golem makes two attacks, using Slam or Force Bolt in any combination.

**Slam**
*Melee Attack Roll:* +10, reach 5 ft. 15 (2d8 + 6) Bludgeoning damage plus 9 (2d8) Force damage.

**Force Bolt**
*Ranged Attack Roll:* +9, range 120 ft. 22 (4d10) Force damage.

## Bonus Actions

**Slow (Recharge 5-6)**
The golem casts the *Slow* spell, requiring no spell components and using Constitution as the spellcasting ability (spell save DC 17).
`,
      "storm-giant.md": `---
smType: creature
name: "Storm Giant"
size: "Huge"
type: "Giant"
alignment: "Chaotic Good"
ac: "16"
hp: "230"
hit_dice: "20d12 + 100"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"},\\"fly\\":{\\"distance\\":\\"25 ft.\\",\\"hover\\":true},\\"swim\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":29},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":20},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":20},{\\"ability\\":\\"cha\\",\\"score\\":18}]"
pb: "+5"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":14},{\\"ability\\":\\"con\\",\\"bonus\\":10},{\\"ability\\":\\"wis\\",\\"bonus\\":10},{\\"ability\\":\\"cha\\",\\"bonus\\":9}]"
cr: "13"
xp: "10000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The giant can breathe air and water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The giant makes two attacks, using Storm Sword or Thunderbolt in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Storm Sword\\",\\"text\\":\\"*Melee Attack Roll:* +14, reach 10 ft. 23 (4d6 + 9) Slashing damage plus 13 (3d8) Lightning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Thunderbolt\\",\\"text\\":\\"*Ranged Attack Roll:* +14, range 500 ft. 22 (2d12 + 9) Lightning damage, and the target has the Blinded and Deafened conditions until the start of the giant's next turn.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Lightning Storm (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 18, each creature in a 10-foot-radius, 40-foot-high Cylinder [Area of Effect]|XPHB|Cylinder originating from a point the giant can see within 500 feet. *Failure:*  55 (10d10) Lightning damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The giant casts one of the following spells, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 18): - **At Will:** *Detect Magic*, *Light* - **1/Day Each:** *Control Weather*\\"}]"
---

# Storm Giant
*Huge, Giant, Chaotic Good*

**AC** 16
**HP** 230 (20d12 + 100)
**Speed** 50 ft., swim 50 ft., fly 25 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 29 | 14 | 20 | 16 | 20 | 18 |

CR 13, PB +5, XP 10000

## Traits

**Amphibious**
The giant can breathe air and water.

## Actions

**Multiattack**
The giant makes two attacks, using Storm Sword or Thunderbolt in any combination.

**Storm Sword**
*Melee Attack Roll:* +14, reach 10 ft. 23 (4d6 + 9) Slashing damage plus 13 (3d8) Lightning damage.

**Thunderbolt**
*Ranged Attack Roll:* +14, range 500 ft. 22 (2d12 + 9) Lightning damage, and the target has the Blinded and Deafened conditions until the start of the giant's next turn.

**Lightning Storm (Recharge 5-6)**
*Dexterity Saving Throw*: DC 18, each creature in a 10-foot-radius, 40-foot-high Cylinder [Area of Effect]|XPHB|Cylinder originating from a point the giant can see within 500 feet. *Failure:*  55 (10d10) Lightning damage. *Success:*  Half damage.

**Spellcasting**
The giant casts one of the following spells, requiring no Material components and using Wisdom as the spellcasting ability (spell save DC 18): - **At Will:** *Detect Magic*, *Light* - **1/Day Each:** *Control Weather*
`,
      "succubus.md": `---
smType: creature
name: "Succubus"
size: "Medium"
type: "Fiend"
alignment: "Neutral Evil"
ac: "15"
hp: "71"
hit_dice: "13d8 + 13"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":8},{\\"ability\\":\\"dex\\",\\"score\\":17},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":15},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":20}]"
pb: "+2"
cr: "4"
xp: "1100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Incubus Form\\",\\"text\\":\\"When the succubus finishes a Long Rest, it can shape-shift into an Incubus, using that stat block instead of this one.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The succubus makes one Fiendish Touch attack and uses Charm or Draining Kiss.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fiendish Touch\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 16 (2d10 + 5) Psychic damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Charm\\",\\"text\\":\\"The succubus casts *Dominate Person* (level 8 version), requiring no spell components and using Charisma as the spellcasting ability (spell save DC 15).\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Draining Kiss\\",\\"text\\":\\"*Constitution Saving Throw*: DC 15, one creature Charmed by the succubus within 5 feet. *Failure:*  13 (3d8) Psychic damage. *Success:*  Half damage. *Failure or Success*:  The target's Hit Point maximum decreases by an amount equal to the damage taken.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Shape-Shift\\",\\"text\\":\\"The succubus shape-shifts to resemble a Medium or Small Humanoid or back into its true form. Its game statistics are the same in each form, except its Fly Speed is available only in its true form. Any equipment it's wearing or carrying isn't transformed.\\"}]"
---

# Succubus
*Medium, Fiend, Neutral Evil*

**AC** 15
**HP** 71 (13d8 + 13)
**Speed** 30 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 8 | 17 | 13 | 15 | 12 | 20 |

CR 4, PB +2, XP 1100

## Traits

**Incubus Form**
When the succubus finishes a Long Rest, it can shape-shift into an Incubus, using that stat block instead of this one.

## Actions

**Multiattack**
The succubus makes one Fiendish Touch attack and uses Charm or Draining Kiss.

**Fiendish Touch**
*Melee Attack Roll:* +7, reach 5 ft. 16 (2d10 + 5) Psychic damage.

**Charm**
The succubus casts *Dominate Person* (level 8 version), requiring no spell components and using Charisma as the spellcasting ability (spell save DC 15).

**Draining Kiss**
*Constitution Saving Throw*: DC 15, one creature Charmed by the succubus within 5 feet. *Failure:*  13 (3d8) Psychic damage. *Success:*  Half damage. *Failure or Success*:  The target's Hit Point maximum decreases by an amount equal to the damage taken.

## Bonus Actions

**Shape-Shift**
The succubus shape-shifts to resemble a Medium or Small Humanoid or back into its true form. Its game statistics are the same in each form, except its Fly Speed is available only in its true form. Any equipment it's wearing or carrying isn't transformed.
`,
      "swarm-of-crawling-claws.md": `---
smType: creature
name: "Swarm of Crawling Claws"
size: "Medium"
type: "Undead"
alignment: "Neutral Evil"
ac: "12"
hp: "49"
hit_dice: "11d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":14},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":5},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":4}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Swarm\\",\\"text\\":\\"The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny creature. The swarm can't regain Hit Points or gain Temporary Hit Points.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Swarm of Grasping Hands\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 20 (4d8 + 2) Necrotic damage, or 11 (2d8 + 2) Necrotic damage if the swarm is Bloodied. If the target is a Medium or smaller creature, it has the Prone condition.\\"}]"
---

# Swarm of Crawling Claws
*Medium, Undead, Neutral Evil*

**AC** 12
**HP** 49 (11d8)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 14 | 14 | 11 | 5 | 10 | 4 |

CR 3, PB +2, XP 700

## Traits

**Swarm**
The swarm can occupy another creature's space and vice versa, and the swarm can move through any opening large enough for a Tiny creature. The swarm can't regain Hit Points or gain Temporary Hit Points.

## Actions

**Swarm of Grasping Hands**
*Melee Attack Roll:* +4, reach 5 ft. 20 (4d8 + 2) Necrotic damage, or 11 (2d8 + 2) Necrotic damage if the swarm is Bloodied. If the target is a Medium or smaller creature, it has the Prone condition.
`,
      "tarrasque.md": `---
smType: creature
name: "Tarrasque"
size: "Gargantuan"
type: "Monstrosity"
type_tags: ["Titan"]
alignment: "Unaligned"
ac: "25"
hp: "697"
hit_dice: "34d20 + 340"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"60 ft.\\"},\\"burrow\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":30},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":30},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+9"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":9},{\\"ability\\":\\"int\\",\\"bonus\\":5},{\\"ability\\":\\"wis\\",\\"bonus\\":9},{\\"ability\\":\\"cha\\",\\"bonus\\":9}]"
cr: "30"
xp: "155000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (6/Day)\\",\\"text\\":\\"If the tarrasque fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The tarrasque has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Reflective Carapace\\",\\"text\\":\\"If the tarrasque is targeted by a *Magic Missile* spell or a spell that requires a ranged attack roll, roll 1d6. On a 1-5, the tarrasque is unaffected. On a 6, the tarrasque is unaffected and reflects the spell, turning the caster into the target.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Siege Monster\\",\\"text\\":\\"The tarrasque deals double damage to objects and structures.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The tarrasque makes one Bite attack and three other attacks, using Claw or Tail in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +19, reach 15 ft. 36 (4d12 + 10) Piercing damage, and the target has the Grappled condition (escape DC 20). Until the grapple ends, the target has the Restrained condition and can't teleport.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +19, reach 15 ft. 28 (4d8 + 10) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tail\\",\\"text\\":\\"*Melee Attack Roll:* +19, reach 30 ft. 23 (3d8 + 10) Bludgeoning damage. If the target is a Huge or smaller creature, it has the Prone condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Thunderous Bellow (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 27, each creature and each object that isn't being worn or carried in a 150-foot Cone. *Failure:*  78 (12d12) Thunder damage, and the target has the Deafened and Frightened conditions until the end of its next turn. *Success:*  Half damage only.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Swallow\\",\\"text\\":\\"*Strength Saving Throw*: DC 27, one Large or smaller creature Grappled by the tarrasque (it can have up to six creatures swallowed at a time). *Failure:*  The target is swallowed, and the Grappled condition ends. A swallowed creature has the Blinded and Restrained conditions and can't teleport, it has Cover|XPHB|Total Cover against attacks and other effects outside the tarrasque, and it takes 56 (16d6) Acid damage at the start of each of the tarrasque's turns. If the tarrasque takes 60 damage or more on a single turn from a creature inside it, the tarrasque must succeed on a DC 20 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, each of which falls in a space within 10 feet of the tarrasque and has the Prone condition. If the tarrasque dies, any swallowed creature no longer has the Restrained condition and can escape from the corpse using 20 feet of movement, exiting Prone.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Onslaught\\",\\"text\\":\\"The tarrasque moves up to half its Speed, and it makes one Claw or Tail attack.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"World-Shaking Movement\\",\\"text\\":\\"The tarrasque moves up to its Speed. At the end of this movement, the tarrasque creates an instantaneous shock wave in a 60-foot Emanation originating from itself. Creatures in that area lose  Concentration and, if Medium or smaller, have the Prone condition. The tarrasque can't take this action again until the start of its next turn.\\"}]"
---

# Tarrasque
*Gargantuan, Monstrosity, Unaligned*

**AC** 25
**HP** 697 (34d20 + 340)
**Speed** 60 ft., climb 60 ft., burrow 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 30 | 11 | 30 | 3 | 11 | 11 |

CR 30, PB +9, XP 155000

## Traits

**Legendary Resistance (6/Day)**
If the tarrasque fails a saving throw, it can choose to succeed instead.

**Magic Resistance**
The tarrasque has Advantage on saving throws against spells and other magical effects.

**Reflective Carapace**
If the tarrasque is targeted by a *Magic Missile* spell or a spell that requires a ranged attack roll, roll 1d6. On a 1-5, the tarrasque is unaffected. On a 6, the tarrasque is unaffected and reflects the spell, turning the caster into the target.

**Siege Monster**
The tarrasque deals double damage to objects and structures.

## Actions

**Multiattack**
The tarrasque makes one Bite attack and three other attacks, using Claw or Tail in any combination.

**Bite**
*Melee Attack Roll:* +19, reach 15 ft. 36 (4d12 + 10) Piercing damage, and the target has the Grappled condition (escape DC 20). Until the grapple ends, the target has the Restrained condition and can't teleport.

**Claw**
*Melee Attack Roll:* +19, reach 15 ft. 28 (4d8 + 10) Slashing damage.

**Tail**
*Melee Attack Roll:* +19, reach 30 ft. 23 (3d8 + 10) Bludgeoning damage. If the target is a Huge or smaller creature, it has the Prone condition.

**Thunderous Bellow (Recharge 5-6)**
*Constitution Saving Throw*: DC 27, each creature and each object that isn't being worn or carried in a 150-foot Cone. *Failure:*  78 (12d12) Thunder damage, and the target has the Deafened and Frightened conditions until the end of its next turn. *Success:*  Half damage only.

## Bonus Actions

**Swallow**
*Strength Saving Throw*: DC 27, one Large or smaller creature Grappled by the tarrasque (it can have up to six creatures swallowed at a time). *Failure:*  The target is swallowed, and the Grappled condition ends. A swallowed creature has the Blinded and Restrained conditions and can't teleport, it has Cover|XPHB|Total Cover against attacks and other effects outside the tarrasque, and it takes 56 (16d6) Acid damage at the start of each of the tarrasque's turns. If the tarrasque takes 60 damage or more on a single turn from a creature inside it, the tarrasque must succeed on a DC 20 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, each of which falls in a space within 10 feet of the tarrasque and has the Prone condition. If the tarrasque dies, any swallowed creature no longer has the Restrained condition and can escape from the corpse using 20 feet of movement, exiting Prone.

## Legendary Actions

**Onslaught**
The tarrasque moves up to half its Speed, and it makes one Claw or Tail attack.

**World-Shaking Movement**
The tarrasque moves up to its Speed. At the end of this movement, the tarrasque creates an instantaneous shock wave in a 60-foot Emanation originating from itself. Creatures in that area lose  Concentration and, if Medium or smaller, have the Prone condition. The tarrasque can't take this action again until the start of its next turn.
`,
      "tough-boss.md": `---
smType: creature
name: "Tough Boss"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "16"
hp: "82"
hit_dice: "11d8 + 33"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"str\\",\\"bonus\\":5},{\\"ability\\":\\"con\\",\\"bonus\\":5},{\\"ability\\":\\"cha\\",\\"bonus\\":2}]"
cr: "4"
xp: "1100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The tough has Advantage on an attack roll against a creature if at least one of the tough's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The tough makes two attacks, using Warhammer or Heavy Crossbow in any combination.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Warhammer\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 12 (2d8 + 3) Bludgeoning damage. If the target is a Large or smaller creature, the tough pushes the target up to 10 feet straight away from itself.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Heavy Crossbow\\",\\"text\\":\\"*Ranged Attack Roll:* +4, range 100/400 ft. 13 (2d10 + 2) Piercing damage.\\"}]"
---

# Tough Boss
*Small, Humanoid, Neutral Neutral*

**AC** 16
**HP** 82 (11d8 + 33)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 14 | 16 | 11 | 10 | 11 |

CR 4, PB +2, XP 1100

## Traits

**Pack Tactics**
The tough has Advantage on an attack roll against a creature if at least one of the tough's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Multiattack**
The tough makes two attacks, using Warhammer or Heavy Crossbow in any combination.

**Warhammer**
*Melee Attack Roll:* +5, reach 5 ft. 12 (2d8 + 3) Bludgeoning damage. If the target is a Large or smaller creature, the tough pushes the target up to 10 feet straight away from itself.

**Heavy Crossbow**
*Ranged Attack Roll:* +4, range 100/400 ft. 13 (2d10 + 2) Piercing damage.
`,
      "tough.md": `---
smType: creature
name: "Tough"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "12"
hp: "32"
hit_dice: "5d8 + 10"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The tough has Advantage on an attack roll against a creature if at least one of the tough's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Mace\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Bludgeoning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Heavy Crossbow\\",\\"text\\":\\"*Ranged Attack Roll:* +3, range 100/400 ft. 6 (1d10 + 1) Piercing damage.\\"}]"
---

# Tough
*Small, Humanoid, Neutral Neutral*

**AC** 12
**HP** 32 (5d8 + 10)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 12 | 14 | 10 | 10 | 11 |

CR 1/2, PB +2, XP 100

## Traits

**Pack Tactics**
The tough has Advantage on an attack roll against a creature if at least one of the tough's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Mace**
*Melee Attack Roll:* +4, reach 5 ft. 5 (1d6 + 2) Bludgeoning damage.

**Heavy Crossbow**
*Ranged Attack Roll:* +3, range 100/400 ft. 6 (1d10 + 1) Piercing damage.
`,
      "treant.md": `---
smType: creature
name: "Treant"
size: "Huge"
type: "Plant"
alignment: "Chaotic Good"
ac: "16"
hp: "138"
hit_dice: "12d12 + 60"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":23},{\\"ability\\":\\"dex\\",\\"score\\":8},{\\"ability\\":\\"con\\",\\"score\\":21},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":16},{\\"ability\\":\\"cha\\",\\"score\\":12}]"
pb: "+4"
cr: "9"
xp: "5000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Siege Monster\\",\\"text\\":\\"The treant deals double damage to objects and structures.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The treant makes two Slam attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Slam\\",\\"text\\":\\"*Melee Attack Roll:* +10, reach 5 ft. 16 (3d6 + 6) Bludgeoning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Hail of Bark\\",\\"text\\":\\"*Ranged Attack Roll:* +10, range 180 ft. 28 (4d10 + 6) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Animate Trees (1/Day)\\",\\"text\\":\\"The treant magically animates up to two trees it can see within 60 feet of itself. Each tree uses the Treant stat block, except it has Intelligence and Charisma scores of 1, it can't speak, and it lacks this action. The tree takes its turn immediately after the treant on the same Initiative count, and it obeys the treant. A tree remains animate for 1 day or until it dies, the treant dies, or it is more than 120 feet from the treant. The tree then takes root if possible.\\"}]"
---

# Treant
*Huge, Plant, Chaotic Good*

**AC** 16
**HP** 138 (12d12 + 60)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 23 | 8 | 21 | 12 | 16 | 12 |

CR 9, PB +4, XP 5000

## Traits

**Siege Monster**
The treant deals double damage to objects and structures.

## Actions

**Multiattack**
The treant makes two Slam attacks.

**Slam**
*Melee Attack Roll:* +10, reach 5 ft. 16 (3d6 + 6) Bludgeoning damage.

**Hail of Bark**
*Ranged Attack Roll:* +10, range 180 ft. 28 (4d10 + 6) Piercing damage.

**Animate Trees (1/Day)**
The treant magically animates up to two trees it can see within 60 feet of itself. Each tree uses the Treant stat block, except it has Intelligence and Charisma scores of 1, it can't speak, and it lacks this action. The tree takes its turn immediately after the treant on the same Initiative count, and it obeys the treant. A tree remains animate for 1 day or until it dies, the treant dies, or it is more than 120 feet from the treant. The tree then takes root if possible.
`,
      "troll-limb.md": `---
smType: creature
name: "Troll Limb"
size: "Small"
type: "Giant"
alignment: "Chaotic Evil"
ac: "13"
hp: "14"
hit_dice: "4d6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":9},{\\"ability\\":\\"cha\\",\\"score\\":1}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Regeneration\\",\\"text\\":\\"The limb regains 5 Hit Points at the start of each of its turns. If the limb takes Acid or Fire damage, this trait doesn't function on the limb's next turn. The limb dies only if it starts its turn with 0 Hit Points and doesn't regenerate.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Troll Spawn\\",\\"text\\":\\"The limb uncannily has the same senses as a whole troll. If the limb isn't destroyed within 24 hours, roll 1d12. On a 12, the limb turns into a Troll. Otherwise, the limb withers away.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 9 (2d4 + 4) Slashing damage.\\"}]"
---

# Troll Limb
*Small, Giant, Chaotic Evil*

**AC** 13
**HP** 14 (4d6)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 12 | 10 | 1 | 9 | 1 |

CR 1/2, PB +2, XP 100

## Traits

**Regeneration**
The limb regains 5 Hit Points at the start of each of its turns. If the limb takes Acid or Fire damage, this trait doesn't function on the limb's next turn. The limb dies only if it starts its turn with 0 Hit Points and doesn't regenerate.

**Troll Spawn**
The limb uncannily has the same senses as a whole troll. If the limb isn't destroyed within 24 hours, roll 1d12. On a 12, the limb turns into a Troll. Otherwise, the limb withers away.

## Actions

**Rend**
*Melee Attack Roll:* +6, reach 5 ft. 9 (2d4 + 4) Slashing damage.
`,
      "troll.md": `---
smType: creature
name: "Troll"
size: "Large"
type: "Giant"
alignment: "Chaotic Evil"
ac: "15"
hp: "94"
hit_dice: "9d10 + 45"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":20},{\\"ability\\":\\"int\\",\\"score\\":7},{\\"ability\\":\\"wis\\",\\"score\\":9},{\\"ability\\":\\"cha\\",\\"score\\":7}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Loathsome Limbs (4/Day)\\",\\"text\\":\\"If the troll ends any turn Bloodied and took 15+ Slashing damage during that turn, one of the troll's limbs is severed, falls into the troll's space, and becomes a Troll Limb. The limb acts immediately after the troll's turn. The troll has 1 Exhaustion level for each missing limb, and it grows replacement limbs the next time it regains Hit Points.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Regeneration\\",\\"text\\":\\"The troll regains 15 Hit Points at the start of each of its turns. If the troll takes Acid or Fire damage, this trait doesn't function on the troll's next turn. The troll dies only if it starts its turn with 0 Hit Points and doesn't regenerate.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The troll makes three Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Slashing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Charge\\",\\"text\\":\\"The troll moves up to half its Speed straight toward an enemy it can see.\\"}]"
---

# Troll
*Large, Giant, Chaotic Evil*

**AC** 15
**HP** 94 (9d10 + 45)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 13 | 20 | 7 | 9 | 7 |

CR 5, PB +3, XP 1800

## Traits

**Loathsome Limbs (4/Day)**
If the troll ends any turn Bloodied and took 15+ Slashing damage during that turn, one of the troll's limbs is severed, falls into the troll's space, and becomes a Troll Limb. The limb acts immediately after the troll's turn. The troll has 1 Exhaustion level for each missing limb, and it grows replacement limbs the next time it regains Hit Points.

**Regeneration**
The troll regains 15 Hit Points at the start of each of its turns. If the troll takes Acid or Fire damage, this trait doesn't function on the troll's next turn. The troll dies only if it starts its turn with 0 Hit Points and doesn't regenerate.

## Actions

**Multiattack**
The troll makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Slashing damage.

## Bonus Actions

**Charge**
The troll moves up to half its Speed straight toward an enemy it can see.
`,
      "unicorn.md": `---
smType: creature
name: "Unicorn"
size: "Large"
type: "Celestial"
alignment: "Lawful Good"
ac: "12"
hp: "97"
hit_dice: "13d10 + 26"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":17},{\\"ability\\":\\"cha\\",\\"score\\":16}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day)\\",\\"text\\":\\"If the unicorn fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The unicorn has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The unicorn makes one Hooves attack and one Radiant Horn attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Hooves\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 11 (2d6 + 4) Bludgeoning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Radiant Horn\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 9 (1d10 + 4) Radiant damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spellcasting\\",\\"text\\":\\"The unicorn casts one of the following spells, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 14): - **At Will:** *Detect Evil and Good*, *Druidcraft* - **1e/Day Each:** *Calm Emotions*, *Dispel Evil and Good*, *Entangle*, *Pass without Trace*, *Word of Recall*\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Unicorn's Blessing (3/Day)\\",\\"text\\":\\"The unicorn touches another creature with its horn and casts *Cure Wounds* or *Lesser Restoration* on that creature, using the same spellcasting ability as Spellcasting.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Charging Horn\\",\\"text\\":\\"The unicorn moves up to half its Speed without provoking Opportunity Attacks, and it makes one Radiant Horn attack.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Shimmering Shield\\",\\"text\\":\\"The unicorn targets itself or one creature it can see within 60 feet of itself. The target gains 10 (3d6) Temporary Hit Points, and its AC increases by 2 until the end of the unicorn's next turn. The unicorn can't take this action again until the start of its next turn.\\"}]"
---

# Unicorn
*Large, Celestial, Lawful Good*

**AC** 12
**HP** 97 (13d10 + 26)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 14 | 15 | 11 | 17 | 16 |

CR 5, PB +3, XP 1800

## Traits

**Legendary Resistance (3/Day)**
If the unicorn fails a saving throw, it can choose to succeed instead.

**Magic Resistance**
The unicorn has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The unicorn makes one Hooves attack and one Radiant Horn attack.

**Hooves**
*Melee Attack Roll:* +7, reach 5 ft. 11 (2d6 + 4) Bludgeoning damage.

**Radiant Horn**
*Melee Attack Roll:* +7, reach 5 ft. 9 (1d10 + 4) Radiant damage.

**Spellcasting**
The unicorn casts one of the following spells, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 14): - **At Will:** *Detect Evil and Good*, *Druidcraft* - **1e/Day Each:** *Calm Emotions*, *Dispel Evil and Good*, *Entangle*, *Pass without Trace*, *Word of Recall*

## Bonus Actions

**Unicorn's Blessing (3/Day)**
The unicorn touches another creature with its horn and casts *Cure Wounds* or *Lesser Restoration* on that creature, using the same spellcasting ability as Spellcasting.

## Legendary Actions

**Charging Horn**
The unicorn moves up to half its Speed without provoking Opportunity Attacks, and it makes one Radiant Horn attack.

**Shimmering Shield**
The unicorn targets itself or one creature it can see within 60 feet of itself. The target gains 10 (3d6) Temporary Hit Points, and its AC increases by 2 until the end of the unicorn's next turn. The unicorn can't take this action again until the start of its next turn.
`,
      "vampire-familiar.md": `---
smType: creature
name: "Vampire Familiar"
size: "Small"
type: "Humanoid"
alignment: "Neutral Evil"
ac: "15"
hp: "65"
hit_dice: "10d8 + 20"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":14}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":5},{\\"ability\\":\\"wis\\",\\"bonus\\":2}]"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Vampiric Connection\\",\\"text\\":\\"While the familiar and its vampire master are on the same plane of existence, the vampire can communicate with the familiar telepathically, and the vampire can perceive through the familiar's senses.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The familiar makes two Umbral Dagger attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Umbral Dagger\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +5, reach 5 ft. or range 20/60 ft. 5 (1d4 + 3) Piercing damage plus 7 (3d4) Necrotic damage. If the target is reduced to 0 Hit Points by this attack, the target becomes Stable but has the Poisoned condition for 1 hour. While it has the Poisoned condition, the target has the Paralyzed condition.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Deathless Agility\\",\\"text\\":\\"The familiar takes the Dash or Disengage action.\\"}]"
---

# Vampire Familiar
*Small, Humanoid, Neutral Evil*

**AC** 15
**HP** 65 (10d8 + 20)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 16 | 15 | 10 | 10 | 14 |

CR 3, PB +2, XP 700

## Traits

**Vampiric Connection**
While the familiar and its vampire master are on the same plane of existence, the vampire can communicate with the familiar telepathically, and the vampire can perceive through the familiar's senses.

## Actions

**Multiattack**
The familiar makes two Umbral Dagger attacks.

**Umbral Dagger**
*Melee or Ranged Attack Roll:* +5, reach 5 ft. or range 20/60 ft. 5 (1d4 + 3) Piercing damage plus 7 (3d4) Necrotic damage. If the target is reduced to 0 Hit Points by this attack, the target becomes Stable but has the Poisoned condition for 1 hour. While it has the Poisoned condition, the target has the Paralyzed condition.

## Bonus Actions

**Deathless Agility**
The familiar takes the Dash or Disengage action.
`,
      "vampire-spawn.md": `---
smType: creature
name: "Vampire Spawn"
size: "Small"
type: "Undead"
alignment: "Neutral Evil"
ac: "16"
hp: "90"
hit_dice: "12d8 + 36"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":12}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":6},{\\"ability\\":\\"wis\\",\\"bonus\\":3}]"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Spider Climb\\",\\"text\\":\\"The vampire can climb difficult surfaces, including along ceilings, without needing to make an ability check.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Vampire Weakness\\",\\"text\\":\\"The vampire has these weaknesses: - **Forbiddance**: The vampire can't enter a residence without an invitation from an occupant. - **Running Water**: The vampire takes 20 Acid damage if it ends its turn in running water. - **Stake to the Heart**: The vampire is destroyed if a weapon that deals Piercing damage is driven into the vampire's heart while the vampire has the Incapacitated condition. - **Sunlight**: The vampire takes 20 Radiant damage if it starts its turn in sunlight. While in sunlight, it has Disadvantage on attack rolls and ability checks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The vampire makes two Claw attacks and uses Bite.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 8 (2d4 + 3) Slashing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 13) from one of two claws.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Constitution Saving Throw*: DC 14, one creature within 5 feet that is willing or that has the Grappled, Incapacitated, or Restrained condition. *Failure:*  5 (1d4 + 3) Piercing damage plus 10 (3d6) Necrotic damage. The target's Hit Point maximum decreases by an amount equal to the Necrotic damage taken, and the vampire regains Hit Points equal to that amount.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Deathless Agility\\",\\"text\\":\\"The vampire takes the Dash or Disengage action.\\"}]"
---

# Vampire Spawn
*Small, Undead, Neutral Evil*

**AC** 16
**HP** 90 (12d8 + 36)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 16 | 16 | 11 | 10 | 12 |

CR 5, PB +3, XP 1800

## Traits

**Spider Climb**
The vampire can climb difficult surfaces, including along ceilings, without needing to make an ability check.

**Vampire Weakness**
The vampire has these weaknesses: - **Forbiddance**: The vampire can't enter a residence without an invitation from an occupant. - **Running Water**: The vampire takes 20 Acid damage if it ends its turn in running water. - **Stake to the Heart**: The vampire is destroyed if a weapon that deals Piercing damage is driven into the vampire's heart while the vampire has the Incapacitated condition. - **Sunlight**: The vampire takes 20 Radiant damage if it starts its turn in sunlight. While in sunlight, it has Disadvantage on attack rolls and ability checks.

## Actions

**Multiattack**
The vampire makes two Claw attacks and uses Bite.

**Claw**
*Melee Attack Roll:* +6, reach 5 ft. 8 (2d4 + 3) Slashing damage. If the target is a Medium or smaller creature, it has the Grappled condition (escape DC 13) from one of two claws.

**Bite**
*Constitution Saving Throw*: DC 14, one creature within 5 feet that is willing or that has the Grappled, Incapacitated, or Restrained condition. *Failure:*  5 (1d4 + 3) Piercing damage plus 10 (3d6) Necrotic damage. The target's Hit Point maximum decreases by an amount equal to the Necrotic damage taken, and the vampire regains Hit Points equal to that amount.

## Bonus Actions

**Deathless Agility**
The vampire takes the Dash or Disengage action.
`,
      "vampire.md": `---
smType: creature
name: "Vampire"
size: "Small"
type: "Undead"
alignment: "Lawful Evil"
ac: "16"
hp: "195"
hit_dice: "23d8 + 92"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":18},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":17},{\\"ability\\":\\"wis\\",\\"score\\":15},{\\"ability\\":\\"cha\\",\\"score\\":18}]"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":9},{\\"ability\\":\\"con\\",\\"bonus\\":9},{\\"ability\\":\\"wis\\",\\"bonus\\":7},{\\"ability\\":\\"cha\\",\\"bonus\\":9}]"
cr: "13"
xp: "10000"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Legendary Resistance (3/Day, or 4/Day in Lair)\\",\\"text\\":\\"If the vampire fails a saving throw, it can choose to succeed instead.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Misty Escape\\",\\"text\\":\\"If the vampire drops to 0 Hit Points outside its resting place, the vampire uses Shape-Shift to become mist (no action required). If it can't use Shape-Shift, it is destroyed. While it has 0 Hit Points in mist form, it can't return to its vampire form, and it must reach its resting place within 2 hours or be destroyed. Once in its resting place, it returns to its vampire form and has the Paralyzed condition until it regains any Hit Points, and it regains 1 Hit Point after spending 1 hour there.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Spider Climb\\",\\"text\\":\\"The vampire can climb difficult surfaces, including along ceilings, without needing to make an ability check.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Vampire Weakness\\",\\"text\\":\\"The vampire has these weaknesses: - **Forbiddance**: The vampire can't enter a residence without an invitation from an occupant. - **Running Water**: The vampire takes 20 Acid damage if it ends its turn in running water. - **Stake to the Heart**: If a weapon that deals Piercing damage is driven into the vampire's heart while the vampire has the Incapacitated condition in its resting place, the vampire has the Paralyzed condition until the weapon is removed. - **Sunlight**: The vampire takes 20 Radiant damage if it starts its turn in sunlight. While in sunlight, it has Disadvantage on attack rolls and ability checks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack (Vampire Form Only)\\",\\"text\\":\\"The vampire makes two Grave Strike attacks and uses Bite.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Grave Strike (Vampire Form Only)\\",\\"text\\":\\"*Melee Attack Roll:* +9, reach 5 ft. 8 (1d8 + 4) Bludgeoning damage plus 7 (2d6) Necrotic damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of two hands.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite (Bat or Vampire Form Only)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 17, one creature within 5 feet that is willing or that has the Grappled, Incapacitated, or Restrained condition. *Failure:*  6 (1d4 + 4) Piercing damage plus 13 (3d8) Necrotic damage. The target's Hit Point maximum decreases by an amount equal to the Necrotic damage taken, and the vampire regains Hit Points equal to that amount. A Humanoid reduced to 0 Hit Points by this damage and then buried rises the following sunset as a Vampire Spawn under the vampire's control.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Shape-Shift\\",\\"text\\":\\"If the vampire isn't in sunlight or running water, it shape-shifts into a Tiny bat (Speed 5 ft., Fly Speed 30 ft.) or a Medium cloud of mist (Speed 5 ft., Fly Speed 20 ft. [hover]), or it returns to its vampire form. Anything it is wearing transforms with it. While in bat form, the vampire can't speak. Its game statistics, other than its size and Speed, are unchanged. While in mist form, the vampire can't take any actions, speak, or manipulate objects. It is weightless and can enter an enemy's space and stop there. If air can pass through a space, the mist can do so, but it can't pass through liquid. It has Resistance to all damage, except the damage it takes from sunlight.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Charm (Recharge 5-6)\\",\\"text\\":\\"The vampire casts *Charm Person*, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 17), and the duration is 24 hours. The Charmed target is a willing recipient of the vampire's Bite, the damage of which doesn't end the spell. When the spell ends, the target is unaware it was Charmed by the vampire.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Deathless Strike\\",\\"text\\":\\"The vampire moves up to half its Speed, and it makes one Grave Strike attack.\\"},{\\"category\\":\\"legendary\\",\\"name\\":\\"Beguile\\",\\"text\\":\\"The vampire casts *Command*, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 17). The vampire can't take this action again until the start of its next turn.\\"}]"
---

# Vampire
*Small, Undead, Lawful Evil*

**AC** 16
**HP** 195 (23d8 + 92)
**Speed** 40 ft., climb 40 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 18 | 18 | 17 | 15 | 18 |

CR 13, XP 10000

## Traits

**Legendary Resistance (3/Day, or 4/Day in Lair)**
If the vampire fails a saving throw, it can choose to succeed instead.

**Misty Escape**
If the vampire drops to 0 Hit Points outside its resting place, the vampire uses Shape-Shift to become mist (no action required). If it can't use Shape-Shift, it is destroyed. While it has 0 Hit Points in mist form, it can't return to its vampire form, and it must reach its resting place within 2 hours or be destroyed. Once in its resting place, it returns to its vampire form and has the Paralyzed condition until it regains any Hit Points, and it regains 1 Hit Point after spending 1 hour there.

**Spider Climb**
The vampire can climb difficult surfaces, including along ceilings, without needing to make an ability check.

**Vampire Weakness**
The vampire has these weaknesses: - **Forbiddance**: The vampire can't enter a residence without an invitation from an occupant. - **Running Water**: The vampire takes 20 Acid damage if it ends its turn in running water. - **Stake to the Heart**: If a weapon that deals Piercing damage is driven into the vampire's heart while the vampire has the Incapacitated condition in its resting place, the vampire has the Paralyzed condition until the weapon is removed. - **Sunlight**: The vampire takes 20 Radiant damage if it starts its turn in sunlight. While in sunlight, it has Disadvantage on attack rolls and ability checks.

## Actions

**Multiattack (Vampire Form Only)**
The vampire makes two Grave Strike attacks and uses Bite.

**Grave Strike (Vampire Form Only)**
*Melee Attack Roll:* +9, reach 5 ft. 8 (1d8 + 4) Bludgeoning damage plus 7 (2d6) Necrotic damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14) from one of two hands.

**Bite (Bat or Vampire Form Only)**
*Constitution Saving Throw*: DC 17, one creature within 5 feet that is willing or that has the Grappled, Incapacitated, or Restrained condition. *Failure:*  6 (1d4 + 4) Piercing damage plus 13 (3d8) Necrotic damage. The target's Hit Point maximum decreases by an amount equal to the Necrotic damage taken, and the vampire regains Hit Points equal to that amount. A Humanoid reduced to 0 Hit Points by this damage and then buried rises the following sunset as a Vampire Spawn under the vampire's control.

## Bonus Actions

**Shape-Shift**
If the vampire isn't in sunlight or running water, it shape-shifts into a Tiny bat (Speed 5 ft., Fly Speed 30 ft.) or a Medium cloud of mist (Speed 5 ft., Fly Speed 20 ft. [hover]), or it returns to its vampire form. Anything it is wearing transforms with it. While in bat form, the vampire can't speak. Its game statistics, other than its size and Speed, are unchanged. While in mist form, the vampire can't take any actions, speak, or manipulate objects. It is weightless and can enter an enemy's space and stop there. If air can pass through a space, the mist can do so, but it can't pass through liquid. It has Resistance to all damage, except the damage it takes from sunlight.

**Charm (Recharge 5-6)**
The vampire casts *Charm Person*, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 17), and the duration is 24 hours. The Charmed target is a willing recipient of the vampire's Bite, the damage of which doesn't end the spell. When the spell ends, the target is unaware it was Charmed by the vampire.

## Legendary Actions

**Deathless Strike**
The vampire moves up to half its Speed, and it makes one Grave Strike attack.

**Beguile**
The vampire casts *Command*, requiring no spell components and using Charisma as the spellcasting ability (spell save DC 17). The vampire can't take this action again until the start of its next turn.
`,
      "violet-fungus.md": `---
smType: creature
name: "Violet Fungus"
size: "Medium"
type: "Plant"
alignment: "Unaligned"
ac: "5"
hp: "18"
hit_dice: "4d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":3},{\\"ability\\":\\"dex\\",\\"score\\":1},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":1},{\\"ability\\":\\"wis\\",\\"score\\":3},{\\"ability\\":\\"cha\\",\\"score\\":1}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The fungus makes two Rotting Touch attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rotting Touch\\",\\"text\\":\\"*Melee Attack Roll:* +2, reach 10 ft. 4 (1d8) Necrotic damage.\\"}]"
---

# Violet Fungus
*Medium, Plant, Unaligned*

**AC** 5
**HP** 18 (4d8)
**Speed** 5 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 3 | 1 | 10 | 1 | 3 | 1 |

CR 1/4, PB +2, XP 50

## Actions

**Multiattack**
The fungus makes two Rotting Touch attacks.

**Rotting Touch**
*Melee Attack Roll:* +2, reach 10 ft. 4 (1d8) Necrotic damage.
`,
      "vrock.md": `---
smType: creature
name: "Vrock"
size: "Large"
type: "Fiend"
type_tags: ["Demon"]
alignment: "Chaotic Evil"
ac: "15"
hp: "152"
hit_dice: "16d10 + 64"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":8},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":5},{\\"ability\\":\\"wis\\",\\"bonus\\":4},{\\"ability\\":\\"cha\\",\\"bonus\\":2}]"
cr: "6"
xp: "2300"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Demonic Restoration\\",\\"text\\":\\"If the vrock dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Magic Resistance\\",\\"text\\":\\"The vrock has Advantage on saving throws against spells and other magical effects.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The vrock makes two Shred attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Shred\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 10 (2d6 + 3) Piercing damage plus 10 (3d6) Poison damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spores\\",\\"recharge\\":\\"Recharge 6\\",\\"text\\":\\"*Constitution Saving Throw*: DC 15, each creature in a 20-foot Emanation originating from the vrock. *Failure:*  The target has the Poisoned condition and repeats the save at the end of each of its turns, ending the effect on itself on a success. While Poisoned, the target takes 5 (1d10) Poison damage at the start of each of its turns. Emptying a flask of Holy Water on the target ends the effect early.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Stunning Screech (1/Day)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 15, each creature in a 20-foot Emanation originating from the vrock (demons succeed automatically). *Failure:*  10 (3d6) Thunder damage, and the target has the Stunned condition until the end of the vrock's next turn.\\"}]"
---

# Vrock
*Large, Fiend, Chaotic Evil*

**AC** 15
**HP** 152 (16d10 + 64)
**Speed** 40 ft., fly 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 15 | 18 | 8 | 13 | 8 |

CR 6, PB +3, XP 2300

## Traits

**Demonic Restoration**
If the vrock dies outside the Abyss, its body dissolves into ichor, and it gains a new body instantly, reviving with all its Hit Points somewhere in the Abyss.

**Magic Resistance**
The vrock has Advantage on saving throws against spells and other magical effects.

## Actions

**Multiattack**
The vrock makes two Shred attacks.

**Shred**
*Melee Attack Roll:* +6, reach 5 ft. 10 (2d6 + 3) Piercing damage plus 10 (3d6) Poison damage.

**Spores (Recharge 6)**
*Constitution Saving Throw*: DC 15, each creature in a 20-foot Emanation originating from the vrock. *Failure:*  The target has the Poisoned condition and repeats the save at the end of each of its turns, ending the effect on itself on a success. While Poisoned, the target takes 5 (1d10) Poison damage at the start of each of its turns. Emptying a flask of Holy Water on the target ends the effect early.

**Stunning Screech (1/Day)**
*Constitution Saving Throw*: DC 15, each creature in a 20-foot Emanation originating from the vrock (demons succeed automatically). *Failure:*  10 (3d6) Thunder damage, and the target has the Stunned condition until the end of the vrock's next turn.
`,
      "warhorse-skeleton.md": `---
smType: creature
name: "Warhorse Skeleton"
size: "Large"
type: "Undead"
alignment: "Lawful Evil"
ac: "13"
hp: "22"
hit_dice: "3d10 + 6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"60 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":2},{\\"ability\\":\\"wis\\",\\"score\\":8},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Hooves\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 7 (1d6 + 4) Bludgeoning damage. If the target is a Large or smaller creature and the skeleton moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.\\"}]"
---

# Warhorse Skeleton
*Large, Undead, Lawful Evil*

**AC** 13
**HP** 22 (3d10 + 6)
**Speed** 60 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 12 | 15 | 2 | 8 | 5 |

CR 1/2, PB +2, XP 100

## Actions

**Hooves**
*Melee Attack Roll:* +6, reach 5 ft. 7 (1d6 + 4) Bludgeoning damage. If the target is a Large or smaller creature and the skeleton moved 20+ feet straight toward it immediately before the hit, the target has the Prone condition.
`,
      "warrior-infantry.md": `---
smType: creature
name: "Warrior Infantry"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "13"
hp: "9"
hit_dice: "2d8"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":13},{\\"ability\\":\\"dex\\",\\"score\\":11},{\\"ability\\":\\"con\\",\\"score\\":11},{\\"ability\\":\\"int\\",\\"score\\":8},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "1/8"
xp: "25"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The warrior has Advantage on an attack roll against a creature if at least one of the warrior's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Spear\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +3, reach 5 ft. or range 20/60 ft. 4 (1d6 + 1) Piercing damage.\\"}]"
---

# Warrior Infantry
*Small, Humanoid, Neutral Neutral*

**AC** 13
**HP** 9 (2d8)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 13 | 11 | 11 | 8 | 11 | 8 |

CR 1/8, PB +2, XP 25

## Traits

**Pack Tactics**
The warrior has Advantage on an attack roll against a creature if at least one of the warrior's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Spear**
*Melee or Ranged Attack Roll:* +3, reach 5 ft. or range 20/60 ft. 4 (1d6 + 1) Piercing damage.
`,
      "warrior-veteran.md": `---
smType: creature
name: "Warrior Veteran"
size: "Small"
type: "Humanoid"
alignment: "Neutral Neutral"
ac: "17"
hp: "65"
hit_dice: "10d8 + 20"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The warrior makes two Greatsword or Heavy Crossbow attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Greatsword\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Heavy Crossbow\\",\\"text\\":\\"*Ranged Attack Roll:* +3, range 100/400 ft. 12 (2d10 + 1) Piercing damage.\\"}]"
---

# Warrior Veteran
*Small, Humanoid, Neutral Neutral*

**AC** 17
**HP** 65 (10d8 + 20)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 13 | 14 | 10 | 11 | 10 |

CR 3, PB +2, XP 700

## Actions

**Multiattack**
The warrior makes two Greatsword or Heavy Crossbow attacks.

**Greatsword**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage.

**Heavy Crossbow**
*Ranged Attack Roll:* +3, range 100/400 ft. 12 (2d10 + 1) Piercing damage.
`,
      "water-elemental.md": `---
smType: creature
name: "Water Elemental"
size: "Large"
type: "Elemental"
alignment: "Neutral Neutral"
ac: "14"
hp: "114"
hit_dice: "12d10 + 48"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"swim\\":{\\"distance\\":\\"90 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":5},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Freeze\\",\\"text\\":\\"If the elemental takes Cold damage, its Speed decreases by 20 feet until the end of its next turn.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Water Form\\",\\"text\\":\\"The elemental can enter an enemy's space and stop there. It can move through a space as narrow as 1 inch without expending extra movement to do so.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The elemental makes two Slam attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Slam\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Prone condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Whelm (Recharge 4-6)\\",\\"text\\":\\"*Strength Saving Throw*: DC 15, each creature in the elemental's space. *Failure:*  22 (4d8 + 4) Bludgeoning damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14). Until the grapple ends, the target has the Restrained condition, is suffocating unless it can breathe water, and takes 9 (2d8) Bludgeoning damage at the start of each of the elemental's turns. The elemental can grapple one Large creature or up to two Medium or smaller creatures at a time with Whelm. As an action, a creature within 5 feet of the elemental can pull a creature out of it by succeeding on a DC 14 Strength (Athletics) check. *Success:*  Half damage only.\\"}]"
---

# Water Elemental
*Large, Elemental, Neutral Neutral*

**AC** 14
**HP** 114 (12d10 + 48)
**Speed** 30 ft., swim 90 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 14 | 18 | 5 | 10 | 8 |

CR 5, PB +3, XP 1800

## Traits

**Freeze**
If the elemental takes Cold damage, its Speed decreases by 20 feet until the end of its next turn.

**Water Form**
The elemental can enter an enemy's space and stop there. It can move through a space as narrow as 1 inch without expending extra movement to do so.

## Actions

**Multiattack**
The elemental makes two Slam attacks.

**Slam**
*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Bludgeoning damage. If the target is a Medium or smaller creature, it has the Prone condition.

**Whelm (Recharge 4-6)**
*Strength Saving Throw*: DC 15, each creature in the elemental's space. *Failure:*  22 (4d8 + 4) Bludgeoning damage. If the target is a Large or smaller creature, it has the Grappled condition (escape DC 14). Until the grapple ends, the target has the Restrained condition, is suffocating unless it can breathe water, and takes 9 (2d8) Bludgeoning damage at the start of each of the elemental's turns. The elemental can grapple one Large creature or up to two Medium or smaller creatures at a time with Whelm. As an action, a creature within 5 feet of the elemental can pull a creature out of it by succeeding on a DC 14 Strength (Athletics) check. *Success:*  Half damage only.
`,
      "werebear.md": `---
smType: creature
name: "Werebear"
size: "Small"
type: "Monstrosity"
alignment: "Neutral Good"
ac: "15"
hp: "135"
hit_dice: "18d8 + 54"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":12}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The werebear makes two attacks, using Handaxe or Rend in any combination. It can replace one attack with a Bite attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite (Bear or Hybrid Form Only)\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 17 (2d12 + 4) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 14. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Werebear under the DM's control and has 10 Hit Points. *Success:*  The target is immune to this werebear's curse for 24 hours.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Handaxe (Humanoid or Hybrid Form Only)\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +7, reach 5 ft or range 20/60 ft. 14 (3d6 + 4) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend (Bear or Hybrid Form Only)\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Slashing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Shape-Shift\\",\\"text\\":\\"The werebear shape-shifts into a Large bear-humanoid hybrid form or a Large bear, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.\\"}]"
---

# Werebear
*Small, Monstrosity, Neutral Good*

**AC** 15
**HP** 135 (18d8 + 54)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 10 | 17 | 11 | 12 | 12 |

CR 5, PB +3, XP 1800

## Actions

**Multiattack**
The werebear makes two attacks, using Handaxe or Rend in any combination. It can replace one attack with a Bite attack.

**Bite (Bear or Hybrid Form Only)**
*Melee Attack Roll:* +7, reach 5 ft. 17 (2d12 + 4) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 14. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Werebear under the DM's control and has 10 Hit Points. *Success:*  The target is immune to this werebear's curse for 24 hours.

**Handaxe (Humanoid or Hybrid Form Only)**
*Melee or Ranged Attack Roll:* +7, reach 5 ft or range 20/60 ft. 14 (3d6 + 4) Slashing damage.

**Rend (Bear or Hybrid Form Only)**
*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Slashing damage.

## Bonus Actions

**Shape-Shift**
The werebear shape-shifts into a Large bear-humanoid hybrid form or a Large bear, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
`,
      "wereboar.md": `---
smType: creature
name: "Wereboar"
size: "Small"
type: "Monstrosity"
alignment: "Neutral Evil"
ac: "15"
hp: "97"
hit_dice: "15d8 + 30"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":15},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "4"
xp: "1100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The wereboar makes two attacks, using Javelin or Tusk in any combination. It can replace one attack with a Gore attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Gore (Boar or Hybrid Form Only)\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 12 (2d8 + 3) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Wereboar under the DM's control and has 10 Hit Points. *Success:*  The target is immune to this wereboar's curse for 24 hours.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Javelin (Humanoid or Hybrid Form Only)\\",\\"text\\":\\"*Melee or Ranged Attack Roll:* +5, reach 5 ft. or range 30/120 ft. 13 (3d6 + 3) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Tusk (Boar or Hybrid Form Only)\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Piercing damage. If the target is a Medium or smaller creature and the wereboar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 7 (2d6) Piercing damage and has the Prone condition.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Shape-Shift\\",\\"text\\":\\"The wereboar shape-shifts into a Medium boar-humanoid hybrid or a Small boar, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.\\"}]"
---

# Wereboar
*Small, Monstrosity, Neutral Evil*

**AC** 15
**HP** 97 (15d8 + 30)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 10 | 15 | 10 | 11 | 8 |

CR 4, PB +2, XP 1100

## Actions

**Multiattack**
The wereboar makes two attacks, using Javelin or Tusk in any combination. It can replace one attack with a Gore attack.

**Gore (Boar or Hybrid Form Only)**
*Melee Attack Roll:* +5, reach 5 ft. 12 (2d8 + 3) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Wereboar under the DM's control and has 10 Hit Points. *Success:*  The target is immune to this wereboar's curse for 24 hours.

**Javelin (Humanoid or Hybrid Form Only)**
*Melee or Ranged Attack Roll:* +5, reach 5 ft. or range 30/120 ft. 13 (3d6 + 3) Piercing damage.

**Tusk (Boar or Hybrid Form Only)**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Piercing damage. If the target is a Medium or smaller creature and the wereboar moved 20+ feet straight toward it immediately before the hit, the target takes an extra 7 (2d6) Piercing damage and has the Prone condition.

## Bonus Actions

**Shape-Shift**
The wereboar shape-shifts into a Medium boar-humanoid hybrid or a Small boar, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
`,
      "wererat.md": `---
smType: creature
name: "Wererat"
size: "Small"
type: "Monstrosity"
alignment: "Lawful Evil"
ac: "13"
hp: "60"
hit_dice: "11d8 + 11"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"climb\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":10},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":12},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The wererat makes two attacks, using Scratch or Hand Crossbow in any combination. It can replace one attack with a Bite attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite (Rat or Hybrid Form Only)\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 8 (2d4 + 3) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 11. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Wererat under the DM's control and has 10 Hit Points. *Success:*  The target is immune to this wererat's curse for 24 hours.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Scratch\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Hand Crossbow (Humanoid or Hybrid Form Only)\\",\\"text\\":\\"*Ranged Attack Roll:* +5, range 30/120 ft. 6 (1d6 + 3) Piercing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Shape-Shift\\",\\"text\\":\\"The wererat shape-shifts into a Medium rat-humanoid hybrid or a Small rat, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.\\"}]"
---

# Wererat
*Small, Monstrosity, Lawful Evil*

**AC** 13
**HP** 60 (11d8 + 11)
**Speed** 30 ft., climb 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 10 | 16 | 12 | 11 | 10 | 8 |

CR 2, PB +2, XP 450

## Actions

**Multiattack**
The wererat makes two attacks, using Scratch or Hand Crossbow in any combination. It can replace one attack with a Bite attack.

**Bite (Rat or Hybrid Form Only)**
*Melee Attack Roll:* +5, reach 5 ft. 8 (2d4 + 3) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 11. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Wererat under the DM's control and has 10 Hit Points. *Success:*  The target is immune to this wererat's curse for 24 hours.

**Scratch**
*Melee Attack Roll:* +5, reach 5 ft. 6 (1d6 + 3) Slashing damage.

**Hand Crossbow (Humanoid or Hybrid Form Only)**
*Ranged Attack Roll:* +5, range 30/120 ft. 6 (1d6 + 3) Piercing damage.

## Bonus Actions

**Shape-Shift**
The wererat shape-shifts into a Medium rat-humanoid hybrid or a Small rat, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
`,
      "weretiger.md": `---
smType: creature
name: "Weretiger"
size: "Small"
type: "Monstrosity"
alignment: "Neutral Neutral"
ac: "12"
hp: "120"
hit_dice: "16d8 + 48"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":15},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+2"
cr: "4"
xp: "1100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The weretiger makes two attacks, using Scratch or Longbow in any combination. It can replace one attack with a Bite attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite (Tiger or Hybrid Form Only)\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 12 (2d8 + 3) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 13. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Weretiger under the DM's control and has 10 Hit Points. *Success:*  The target is immune to this weretiger's curse for 24 hours.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Scratch\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Longbow (Humanoid or Hybrid Form Only)\\",\\"text\\":\\"*Ranged Attack Roll:* +4, range 150/600 ft. 11 (2d8 + 2) Piercing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Prowl (Tiger or Hybrid Form Only)\\",\\"text\\":\\"The weretiger moves up to its Speed without provoking Opportunity Attacks. At the end of this movement, the weretiger can take the Hide action.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Shape-Shift\\",\\"text\\":\\"The weretiger shape-shifts into a Large tiger-humanoid hybrid or a Large tiger, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.\\"}]"
---

# Weretiger
*Small, Monstrosity, Neutral Neutral*

**AC** 12
**HP** 120 (16d8 + 48)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 15 | 16 | 10 | 13 | 11 |

CR 4, PB +2, XP 1100

## Actions

**Multiattack**
The weretiger makes two attacks, using Scratch or Longbow in any combination. It can replace one attack with a Bite attack.

**Bite (Tiger or Hybrid Form Only)**
*Melee Attack Roll:* +5, reach 5 ft. 12 (2d8 + 3) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 13. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Weretiger under the DM's control and has 10 Hit Points. *Success:*  The target is immune to this weretiger's curse for 24 hours.

**Scratch**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage.

**Longbow (Humanoid or Hybrid Form Only)**
*Ranged Attack Roll:* +4, range 150/600 ft. 11 (2d8 + 2) Piercing damage.

## Bonus Actions

**Prowl (Tiger or Hybrid Form Only)**
The weretiger moves up to its Speed without provoking Opportunity Attacks. At the end of this movement, the weretiger can take the Hide action.

**Shape-Shift**
The weretiger shape-shifts into a Large tiger-humanoid hybrid or a Large tiger, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
`,
      "werewolf.md": `---
smType: creature
name: "Werewolf"
size: "Small"
type: "Monstrosity"
alignment: "Chaotic Evil"
ac: "15"
hp: "71"
hit_dice: "11d8 + 22"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":10}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The werewolf has Advantage on an attack roll against a creature if at least one of the werewolf's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The werewolf makes two attacks, using Scratch or Longbow in any combination. It can replace one attack with a Bite attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite (Wolf or Hybrid Form Only)\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 12 (2d8 + 3) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Werewolf under the DM's control and has 10 Hit Points. *Success:*  The target is immune to this werewolf's curse for 24 hours.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Scratch\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Longbow (Humanoid or Hybrid Form Only)\\",\\"text\\":\\"*Ranged Attack Roll:* +4, range 150/600 ft. 11 (2d8 + 2) Piercing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Shape-Shift\\",\\"text\\":\\"The werewolf shape-shifts into a Large wolf-humanoid hybrid or a Medium wolf, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.\\"}]"
---

# Werewolf
*Small, Monstrosity, Chaotic Evil*

**AC** 15
**HP** 71 (11d8 + 22)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 14 | 14 | 10 | 11 | 10 |

CR 3, PB +2, XP 700

## Traits

**Pack Tactics**
The werewolf has Advantage on an attack roll against a creature if at least one of the werewolf's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Multiattack**
The werewolf makes two attacks, using Scratch or Longbow in any combination. It can replace one attack with a Bite attack.

**Bite (Wolf or Hybrid Form Only)**
*Melee Attack Roll:* +5, reach 5 ft. 12 (2d8 + 3) Piercing damage. If the target is a Humanoid, it is subjected to the following effect. *Constitution Saving Throw*: DC 12. *Failure:*  The target is cursed. If the cursed target drops to 0 Hit Points, it instead becomes a Werewolf under the DM's control and has 10 Hit Points. *Success:*  The target is immune to this werewolf's curse for 24 hours.

**Scratch**
*Melee Attack Roll:* +5, reach 5 ft. 10 (2d6 + 3) Slashing damage.

**Longbow (Humanoid or Hybrid Form Only)**
*Ranged Attack Roll:* +4, range 150/600 ft. 11 (2d8 + 2) Piercing damage.

## Bonus Actions

**Shape-Shift**
The werewolf shape-shifts into a Large wolf-humanoid hybrid or a Medium wolf, or it returns to its true humanoid form. Its game statistics, other than its size, are the same in each form. Any equipment it is wearing or carrying isn't transformed.
`,
      "white-dragon-wyrmling.md": `---
smType: creature
name: "White Dragon Wyrmling"
size: "Medium"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Chaotic Evil"
ac: "16"
hp: "32"
hit_dice: "5d8 + 10"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"burrow\\":{\\"distance\\":\\"15 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\"},\\"swim\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":14},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":5},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+2"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":2},{\\"ability\\":\\"wis\\",\\"bonus\\":2}]"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Ice Walk\\",\\"text\\":\\"The dragon can move across and climb icy surfaces without needing to make an ability check. Additionally, Difficult Terrain composed of ice or snow doesn't cost it extra movement.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes two Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Slashing damage plus 2 (1d4) Cold damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Cold Breath (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 12, each creature in a 15-foot Cone. *Failure:*  22 (5d8) Cold damage. *Success:*  Half damage.\\"}]"
---

# White Dragon Wyrmling
*Medium, Dragon, Chaotic Evil*

**AC** 16
**HP** 32 (5d8 + 10)
**Speed** 30 ft., swim 30 ft., fly 60 ft., burrow 15 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 14 | 10 | 14 | 5 | 10 | 11 |

CR 2, PB +2, XP 450

## Traits

**Ice Walk**
The dragon can move across and climb icy surfaces without needing to make an ability check. Additionally, Difficult Terrain composed of ice or snow doesn't cost it extra movement.

## Actions

**Multiattack**
The dragon makes two Rend attacks.

**Rend**
*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Slashing damage plus 2 (1d4) Cold damage.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 12, each creature in a 15-foot Cone. *Failure:*  22 (5d8) Cold damage. *Success:*  Half damage.
`,
      "wight.md": `---
smType: creature
name: "Wight"
size: "Medium"
type: "Undead"
alignment: "Neutral Evil"
ac: "14"
hp: "82"
hit_dice: "11d8 + 33"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":15},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":10},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":15}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Sunlight Sensitivity\\",\\"text\\":\\"While in sunlight, the wight has Disadvantage on ability checks and attack rolls.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The wight makes two attacks, using Necrotic Sword or Necrotic Bow in any combination. It can replace one attack with a use of Life Drain.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Necrotic Sword\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Slashing damage plus 4 (1d8) Necrotic damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Necrotic Bow\\",\\"text\\":\\"*Ranged Attack Roll:* +4, range 150/600 ft. 6 (1d8 + 2) Piercing damage plus 4 (1d8) Necrotic damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Life Drain\\",\\"text\\":\\"*Constitution Saving Throw*: DC 13, one creature within 5 feet. *Failure:*  6 (1d8 + 2) Necrotic damage, and the target's Hit Point maximum decreases by an amount equal to the damage taken. A Humanoid slain by this attack rises 24 hours later as a Zombie under the wight's control, unless the Humanoid is restored to life or its body is destroyed. The wight can have no more than twelve zombies under its control at a time.\\"}]"
---

# Wight
*Medium, Undead, Neutral Evil*

**AC** 14
**HP** 82 (11d8 + 33)
**Speed** 30 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 15 | 14 | 16 | 10 | 13 | 15 |

CR 3, PB +2, XP 700

## Traits

**Sunlight Sensitivity**
While in sunlight, the wight has Disadvantage on ability checks and attack rolls.

## Actions

**Multiattack**
The wight makes two attacks, using Necrotic Sword or Necrotic Bow in any combination. It can replace one attack with a use of Life Drain.

**Necrotic Sword**
*Melee Attack Roll:* +4, reach 5 ft. 6 (1d8 + 2) Slashing damage plus 4 (1d8) Necrotic damage.

**Necrotic Bow**
*Ranged Attack Roll:* +4, range 150/600 ft. 6 (1d8 + 2) Piercing damage plus 4 (1d8) Necrotic damage.

**Life Drain**
*Constitution Saving Throw*: DC 13, one creature within 5 feet. *Failure:*  6 (1d8 + 2) Necrotic damage, and the target's Hit Point maximum decreases by an amount equal to the damage taken. A Humanoid slain by this attack rises 24 hours later as a Zombie under the wight's control, unless the Humanoid is restored to life or its body is destroyed. The wight can have no more than twelve zombies under its control at a time.
`,
      "will-o-wisp.md": `---
smType: creature
name: "Will-o'-Wisp"
size: "Small"
type: "Undead"
alignment: "Chaotic Evil"
ac: "19"
hp: "27"
hit_dice: "11d4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"},\\"fly\\":{\\"distance\\":\\"50 ft.\\",\\"hover\\":true}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":1},{\\"ability\\":\\"dex\\",\\"score\\":28},{\\"ability\\":\\"con\\",\\"score\\":10},{\\"ability\\":\\"int\\",\\"score\\":13},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+2"
cr: "2"
xp: "450"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Ephemeral\\",\\"text\\":\\"The wisp can't wear or carry anything.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Illumination\\",\\"text\\":\\"The wisp sheds Bright Light in a 20-foot radius and Dim Light for an additional 20 feet.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Incorporeal Movement\\",\\"text\\":\\"The wisp can move through other creatures and objects as if they were Difficult Terrain. It takes 5 (1d10) Force damage if it ends its turn inside an object.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Shock\\",\\"text\\":\\"*Melee Attack Roll:* +4, reach 5 ft. 11 (2d8 + 2) Lightning damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Consume Life\\",\\"text\\":\\"*Constitution Saving Throw*: DC 10, one living creature the wisp can see within 5 feet that has 0 Hit Points. *Failure:*  The target dies, and the wisp regains 10 (3d6) Hit Points.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Vanish\\",\\"text\\":\\"The wisp and its light have the Invisible condition until the wisp's  Concentration ends on this effect, which ends early immediately after the wisp makes an attack roll or uses Consume Life.\\"}]"
---

# Will-o'-Wisp
*Small, Undead, Chaotic Evil*

**AC** 19
**HP** 27 (11d4)
**Speed** 5 ft., fly 50 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 1 | 28 | 10 | 13 | 14 | 11 |

CR 2, PB +2, XP 450

## Traits

**Ephemeral**
The wisp can't wear or carry anything.

**Illumination**
The wisp sheds Bright Light in a 20-foot radius and Dim Light for an additional 20 feet.

**Incorporeal Movement**
The wisp can move through other creatures and objects as if they were Difficult Terrain. It takes 5 (1d10) Force damage if it ends its turn inside an object.

## Actions

**Shock**
*Melee Attack Roll:* +4, reach 5 ft. 11 (2d8 + 2) Lightning damage.

## Bonus Actions

**Consume Life**
*Constitution Saving Throw*: DC 10, one living creature the wisp can see within 5 feet that has 0 Hit Points. *Failure:*  The target dies, and the wisp regains 10 (3d6) Hit Points.

**Vanish**
The wisp and its light have the Invisible condition until the wisp's  Concentration ends on this effect, which ends early immediately after the wisp makes an attack roll or uses Consume Life.
`,
      "winter-wolf.md": `---
smType: creature
name: "Winter Wolf"
size: "Large"
type: "Monstrosity"
alignment: "Neutral Evil"
ac: "13"
hp: "75"
hit_dice: "10d10 + 20"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":14},{\\"ability\\":\\"int\\",\\"score\\":7},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "3"
xp: "700"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Pack Tactics\\",\\"text\\":\\"The wolf has Advantage on an attack roll against a creature if at least one of the wolf's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 11 (2d6 + 4) Piercing damage. If the target is a Large or smaller creature, it has the Prone condition.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Cold Breath (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 12, each creature in a 15-foot Cone. *Failure:*  18 (4d8) Cold damage. *Success:*  Half damage.\\"}]"
---

# Winter Wolf
*Large, Monstrosity, Neutral Evil*

**AC** 13
**HP** 75 (10d10 + 20)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 13 | 14 | 7 | 12 | 8 |

CR 3, PB +2, XP 700

## Traits

**Pack Tactics**
The wolf has Advantage on an attack roll against a creature if at least one of the wolf's allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition.

## Actions

**Bite**
*Melee Attack Roll:* +6, reach 5 ft. 11 (2d6 + 4) Piercing damage. If the target is a Large or smaller creature, it has the Prone condition.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 12, each creature in a 15-foot Cone. *Failure:*  18 (4d8) Cold damage. *Success:*  Half damage.
`,
      "worg.md": `---
smType: creature
name: "Worg"
size: "Large"
type: "Fey"
alignment: "Neutral Evil"
ac: "13"
hp: "26"
hit_dice: "4d10 + 4"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"50 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":16},{\\"ability\\":\\"dex\\",\\"score\\":13},{\\"ability\\":\\"con\\",\\"score\\":13},{\\"ability\\":\\"int\\",\\"score\\":7},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":8}]"
pb: "+2"
cr: "1/2"
xp: "100"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage, and the next attack roll made against the target before the start of the worg's next turn has Advantage.\\"}]"
---

# Worg
*Large, Fey, Neutral Evil*

**AC** 13
**HP** 26 (4d10 + 4)
**Speed** 50 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 16 | 13 | 13 | 7 | 11 | 8 |

CR 1/2, PB +2, XP 100

## Actions

**Bite**
*Melee Attack Roll:* +5, reach 5 ft. 7 (1d8 + 3) Piercing damage, and the next attack roll made against the target before the start of the worg's next turn has Advantage.
`,
      "wraith.md": `---
smType: creature
name: "Wraith"
size: "Small"
type: "Undead"
alignment: "Neutral Evil"
ac: "13"
hp: "67"
hit_dice: "9d8 + 27"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"5 ft.\\"},\\"fly\\":{\\"distance\\":\\"60 ft.\\",\\"hover\\":true}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":6},{\\"ability\\":\\"dex\\",\\"score\\":16},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":14},{\\"ability\\":\\"cha\\",\\"score\\":15}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Incorporeal Movement\\",\\"text\\":\\"The wraith can move through other creatures and objects as if they were Difficult Terrain. It takes 5 (1d10) Force damage if it ends its turn inside an object.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Sunlight Sensitivity\\",\\"text\\":\\"While in sunlight, the wraith has Disadvantage on ability checks and attack rolls.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Life Drain\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 21 (4d8 + 3) Necrotic damage. If the target is a creature, its Hit Point maximum decreases by an amount equal to the damage taken.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Create Specter\\",\\"text\\":\\"The wraith targets a Humanoid corpse within 10 feet of itself that has been dead for no longer than 1 minute. The target's spirit rises as a Specter in the space of its corpse or in the nearest unoccupied space. The specter is under the wraith's control. The wraith can have no more than seven specters under its control at a time.\\"}]"
---

# Wraith
*Small, Undead, Neutral Evil*

**AC** 13
**HP** 67 (9d8 + 27)
**Speed** 5 ft., fly 60 ft. (hover)

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 6 | 16 | 16 | 12 | 14 | 15 |

CR 5, PB +3, XP 1800

## Traits

**Incorporeal Movement**
The wraith can move through other creatures and objects as if they were Difficult Terrain. It takes 5 (1d10) Force damage if it ends its turn inside an object.

**Sunlight Sensitivity**
While in sunlight, the wraith has Disadvantage on ability checks and attack rolls.

## Actions

**Life Drain**
*Melee Attack Roll:* +6, reach 5 ft. 21 (4d8 + 3) Necrotic damage. If the target is a creature, its Hit Point maximum decreases by an amount equal to the damage taken.

**Create Specter**
The wraith targets a Humanoid corpse within 10 feet of itself that has been dead for no longer than 1 minute. The target's spirit rises as a Specter in the space of its corpse or in the nearest unoccupied space. The specter is under the wraith's control. The wraith can have no more than seven specters under its control at a time.
`,
      "wyvern.md": `---
smType: creature
name: "Wyvern"
size: "Large"
type: "Dragon"
alignment: "Unaligned"
ac: "14"
hp: "127"
hit_dice: "15d10 + 45"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"30 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":5},{\\"ability\\":\\"wis\\",\\"score\\":12},{\\"ability\\":\\"cha\\",\\"score\\":6}]"
pb: "+3"
cr: "6"
xp: "2300"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The wyvern makes one Bite attack and one Sting attack.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Sting\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Piercing damage plus 24 (7d6) Poison damage, and the target has the Poisoned condition until the start of the wyvern's next turn.\\"}]"
---

# Wyvern
*Large, Dragon, Unaligned*

**AC** 14
**HP** 127 (15d10 + 45)
**Speed** 30 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 10 | 16 | 5 | 12 | 6 |

CR 6, PB +3, XP 2300

## Actions

**Multiattack**
The wyvern makes one Bite attack and one Sting attack.

**Bite**
*Melee Attack Roll:* +7, reach 5 ft. 13 (2d8 + 4) Piercing damage.

**Sting**
*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Piercing damage plus 24 (7d6) Poison damage, and the target has the Poisoned condition until the start of the wyvern's next turn.
`,
      "xorn.md": `---
smType: creature
name: "Xorn"
size: "Medium"
type: "Elemental"
alignment: "Neutral Neutral"
ac: "19"
hp: "84"
hit_dice: "8d8 + 48"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"},\\"burrow\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":17},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":22},{\\"ability\\":\\"int\\",\\"score\\":11},{\\"ability\\":\\"wis\\",\\"score\\":10},{\\"ability\\":\\"cha\\",\\"score\\":11}]"
pb: "+3"
cr: "5"
xp: "1800"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Earth Glide\\",\\"text\\":\\"The xorn can burrow through nonmagical, unworked earth and stone. While doing so, the xorn doesn't disturb the material it moves through.\\"},{\\"category\\":\\"trait\\",\\"name\\":\\"Treasure Sense\\",\\"text\\":\\"The xorn can pinpoint the location of precious metals and stones within 60 feet of itself.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The xorn makes one Bite attack and three Claw attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Bite\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 17 (4d6 + 3) Piercing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Claw\\",\\"text\\":\\"*Melee Attack Roll:* +6, reach 5 ft. 8 (1d10 + 3) Slashing damage.\\"},{\\"category\\":\\"bonus\\",\\"name\\":\\"Charge\\",\\"text\\":\\"The xorn moves up to its Speed or Burrow Speed straight toward an enemy it can sense.\\"}]"
---

# Xorn
*Medium, Elemental, Neutral Neutral*

**AC** 19
**HP** 84 (8d8 + 48)
**Speed** 20 ft., burrow 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 17 | 10 | 22 | 11 | 10 | 11 |

CR 5, PB +3, XP 1800

## Traits

**Earth Glide**
The xorn can burrow through nonmagical, unworked earth and stone. While doing so, the xorn doesn't disturb the material it moves through.

**Treasure Sense**
The xorn can pinpoint the location of precious metals and stones within 60 feet of itself.

## Actions

**Multiattack**
The xorn makes one Bite attack and three Claw attacks.

**Bite**
*Melee Attack Roll:* +6, reach 5 ft. 17 (4d6 + 3) Piercing damage.

**Claw**
*Melee Attack Roll:* +6, reach 5 ft. 8 (1d10 + 3) Slashing damage.

## Bonus Actions

**Charge**
The xorn moves up to its Speed or Burrow Speed straight toward an enemy it can sense.
`,
      "young-black-dragon.md": `---
smType: creature
name: "Young Black Dragon"
size: "Large"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Chaotic Evil"
ac: "18"
hp: "127"
hit_dice: "15d10 + 45"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":15}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":5},{\\"ability\\":\\"wis\\",\\"bonus\\":3}]"
cr: "7"
xp: "2900"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 10 ft. 9 (2d4 + 4) Slashing damage plus 3 (1d6) Acid damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Acid Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 14, each creature in a 30-foot-long, 5-foot-wide Line. *Failure:*  49 (14d6) Acid damage. *Success:*  Half damage.\\"}]"
---

# Young Black Dragon
*Large, Dragon, Chaotic Evil*

**AC** 18
**HP** 127 (15d10 + 45)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 14 | 17 | 12 | 11 | 15 |

CR 7, PB +3, XP 2900

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +7, reach 10 ft. 9 (2d4 + 4) Slashing damage plus 3 (1d6) Acid damage.

**Acid Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 14, each creature in a 30-foot-long, 5-foot-wide Line. *Failure:*  49 (14d6) Acid damage. *Success:*  Half damage.
`,
      "young-blue-dragon.md": `---
smType: creature
name: "Young Blue Dragon"
size: "Large"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Lawful Evil"
ac: "18"
hp: "152"
hit_dice: "16d10 + 64"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"burrow\\":{\\"distance\\":\\"20 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":21},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":19},{\\"ability\\":\\"int\\",\\"score\\":14},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":17}]"
pb: "+4"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":4},{\\"ability\\":\\"wis\\",\\"bonus\\":5}]"
cr: "9"
xp: "5000"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +9, reach 10 ft. 12 (2d6 + 5) Slashing damage plus 5 (1d10) Lightning damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Lightning Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 16, each creature in a 60-foot-long, 5-foot-wide Line. *Failure:*  55 (10d10) Lightning damage. *Success:*  Half damage.\\"}]"
---

# Young Blue Dragon
*Large, Dragon, Lawful Evil*

**AC** 18
**HP** 152 (16d10 + 64)
**Speed** 40 ft., fly 80 ft., burrow 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 21 | 10 | 19 | 14 | 13 | 17 |

CR 9, PB +4, XP 5000

## Actions

**Multiattack**
The dragon makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +9, reach 10 ft. 12 (2d6 + 5) Slashing damage plus 5 (1d10) Lightning damage.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 16, each creature in a 60-foot-long, 5-foot-wide Line. *Failure:*  55 (10d10) Lightning damage. *Success:*  Half damage.
`,
      "young-brass-dragon.md": `---
smType: creature
name: "Young Brass Dragon"
size: "Large"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Chaotic Good"
ac: "17"
hp: "110"
hit_dice: "13d10 + 39"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"burrow\\":{\\"distance\\":\\"20 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":12},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":15}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":3},{\\"ability\\":\\"wis\\",\\"bonus\\":3}]"
cr: "6"
xp: "2300"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace two attacks with a use of Sleep Breath.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 10 ft. 15 (2d10 + 4) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fire Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 14, each creature in a 40-foot-long, 5-foot-wide Line. *Failure:*  38 (11d6) Fire damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Sleep Breath\\",\\"text\\":\\"*Constitution Saving Throw*: DC 14, each creature in a 30-foot Cone. *Failure:*  The target has the Incapacitated condition until the end of its next turn, at which point it repeats the save. *Second Failure* The target has the Unconscious condition for 1 minute. This effect ends for the target if it takes damage or a creature within 5 feet of it takes an action to wake it.\\"}]"
---

# Young Brass Dragon
*Large, Dragon, Chaotic Good*

**AC** 17
**HP** 110 (13d10 + 39)
**Speed** 40 ft., fly 80 ft., burrow 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 10 | 17 | 12 | 11 | 15 |

CR 6, PB +3, XP 2300

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace two attacks with a use of Sleep Breath.

**Rend**
*Melee Attack Roll:* +7, reach 10 ft. 15 (2d10 + 4) Slashing damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 14, each creature in a 40-foot-long, 5-foot-wide Line. *Failure:*  38 (11d6) Fire damage. *Success:*  Half damage.

**Sleep Breath**
*Constitution Saving Throw*: DC 14, each creature in a 30-foot Cone. *Failure:*  The target has the Incapacitated condition until the end of its next turn, at which point it repeats the save. *Second Failure* The target has the Unconscious condition for 1 minute. This effect ends for the target if it takes damage or a creature within 5 feet of it takes an action to wake it.
`,
      "young-bronze-dragon.md": `---
smType: creature
name: "Young Bronze Dragon"
size: "Large"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Lawful Good"
ac: "17"
hp: "142"
hit_dice: "15d10 + 60"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":21},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":19},{\\"ability\\":\\"int\\",\\"score\\":14},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":17}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":3},{\\"ability\\":\\"wis\\",\\"bonus\\":4}]"
cr: "8"
xp: "3900"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of Repulsion Breath.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +8, reach 10 ft. 16 (2d10 + 5) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Lightning Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 15, each creature in a 60-foot-long, 5-foot-wide Line. *Failure:*  49 (9d10) Lightning damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Repulsion Breath\\",\\"text\\":\\"*Strength Saving Throw*: DC 15, each creature in a 30-foot Cone. *Failure:*  The target is pushed up to 40 feet straight away from the dragon and has the Prone condition.\\"}]"
---

# Young Bronze Dragon
*Large, Dragon, Lawful Good*

**AC** 17
**HP** 142 (15d10 + 60)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 21 | 10 | 19 | 14 | 13 | 17 |

CR 8, PB +3, XP 3900

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Repulsion Breath.

**Rend**
*Melee Attack Roll:* +8, reach 10 ft. 16 (2d10 + 5) Slashing damage.

**Lightning Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 15, each creature in a 60-foot-long, 5-foot-wide Line. *Failure:*  49 (9d10) Lightning damage. *Success:*  Half damage.

**Repulsion Breath**
*Strength Saving Throw*: DC 15, each creature in a 30-foot Cone. *Failure:*  The target is pushed up to 40 feet straight away from the dragon and has the Prone condition.
`,
      "young-copper-dragon.md": `---
smType: creature
name: "Young Copper Dragon"
size: "Large"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Chaotic Good"
ac: "17"
hp: "119"
hit_dice: "14d10 + 42"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":15}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":4},{\\"ability\\":\\"wis\\",\\"bonus\\":4}]"
cr: "7"
xp: "2900"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of Slowing Breath.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 10 ft. 15 (2d10 + 4) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Acid Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 14, each creature in a 40-foot-long, 5-foot-wide Line. *Failure:*  40 (9d8) Acid damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Slowing Breath\\",\\"text\\":\\"*Constitution Saving Throw*: DC 14, each creature in a 30-foot Cone. *Failure:*  The target can't take Reactions; its Speed is halved; and it can take either an action or a Bonus Action on its turn, not both. This effect lasts until the end of its next turn.\\"}]"
---

# Young Copper Dragon
*Large, Dragon, Chaotic Good*

**AC** 17
**HP** 119 (14d10 + 42)
**Speed** 40 ft., climb 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 12 | 17 | 16 | 13 | 15 |

CR 7, PB +3, XP 2900

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Slowing Breath.

**Rend**
*Melee Attack Roll:* +7, reach 10 ft. 15 (2d10 + 4) Slashing damage.

**Acid Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 14, each creature in a 40-foot-long, 5-foot-wide Line. *Failure:*  40 (9d8) Acid damage. *Success:*  Half damage.

**Slowing Breath**
*Constitution Saving Throw*: DC 14, each creature in a 30-foot Cone. *Failure:*  The target can't take Reactions; its Speed is halved; and it can take either an action or a Bonus Action on its turn, not both. This effect lasts until the end of its next turn.
`,
      "young-gold-dragon.md": `---
smType: creature
name: "Young Gold Dragon"
size: "Large"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Lawful Good"
ac: "18"
hp: "178"
hit_dice: "17d10 + 85"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":23},{\\"ability\\":\\"dex\\",\\"score\\":14},{\\"ability\\":\\"con\\",\\"score\\":21},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":20}]"
pb: "+4"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":6},{\\"ability\\":\\"wis\\",\\"bonus\\":5}]"
cr: "10"
xp: "5900"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of Weakening Breath.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +10, reach 10 ft. 17 (2d10 + 6) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fire Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 17, each creature in a 30-foot Cone. *Failure:*  55 (10d10) Fire damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Weakening Breath\\",\\"text\\":\\"*Strength Saving Throw*: DC 17, each creature that isn't currently affected by this breath in a 30-foot Cone. *Failure:*  The target has Disadvantage on Strength-based D20 Test and subtracts 3 (1d6) from its damage rolls. It repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.\\"}]"
---

# Young Gold Dragon
*Large, Dragon, Lawful Good*

**AC** 18
**HP** 178 (17d10 + 85)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 23 | 14 | 21 | 16 | 13 | 20 |

CR 10, PB +4, XP 5900

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Weakening Breath.

**Rend**
*Melee Attack Roll:* +10, reach 10 ft. 17 (2d10 + 6) Slashing damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 17, each creature in a 30-foot Cone. *Failure:*  55 (10d10) Fire damage. *Success:*  Half damage.

**Weakening Breath**
*Strength Saving Throw*: DC 17, each creature that isn't currently affected by this breath in a 30-foot Cone. *Failure:*  The target has Disadvantage on Strength-based D20 Test and subtracts 3 (1d6) from its damage rolls. It repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.
`,
      "young-green-dragon.md": `---
smType: creature
name: "Young Green Dragon"
size: "Large"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Lawful Evil"
ac: "18"
hp: "136"
hit_dice: "16d10 + 48"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":19},{\\"ability\\":\\"dex\\",\\"score\\":12},{\\"ability\\":\\"con\\",\\"score\\":17},{\\"ability\\":\\"int\\",\\"score\\":16},{\\"ability\\":\\"wis\\",\\"score\\":13},{\\"ability\\":\\"cha\\",\\"score\\":15}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":4},{\\"ability\\":\\"wis\\",\\"bonus\\":4}]"
cr: "8"
xp: "3900"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Amphibious\\",\\"text\\":\\"The dragon can breathe air and water.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Slashing damage plus 7 (2d6) Poison damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Poison Breath (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 14, each creature in a 30-foot Cone. *Failure:*  42 (12d6) Poison damage. *Success:*  Half damage.\\"}]"
---

# Young Green Dragon
*Large, Dragon, Lawful Evil*

**AC** 18
**HP** 136 (16d10 + 48)
**Speed** 40 ft., swim 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 19 | 12 | 17 | 16 | 13 | 15 |

CR 8, PB +3, XP 3900

## Traits

**Amphibious**
The dragon can breathe air and water.

## Actions

**Multiattack**
The dragon makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +7, reach 10 ft. 11 (2d6 + 4) Slashing damage plus 7 (2d6) Poison damage.

**Poison Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 14, each creature in a 30-foot Cone. *Failure:*  42 (12d6) Poison damage. *Success:*  Half damage.
`,
      "young-red-dragon.md": `---
smType: creature
name: "Young Red Dragon"
size: "Large"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Chaotic Evil"
ac: "18"
hp: "178"
hit_dice: "17d10 + 85"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"climb\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":23},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":21},{\\"ability\\":\\"int\\",\\"score\\":14},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":19}]"
pb: "+4"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":4},{\\"ability\\":\\"wis\\",\\"bonus\\":4}]"
cr: "10"
xp: "5900"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +10, reach 10 ft. 13 (2d6 + 6) Slashing damage plus 3 (1d6) Fire damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Fire Breath (Recharge 5-6)\\",\\"text\\":\\"*Dexterity Saving Throw*: DC 17, each creature in a 30-foot Cone. *Failure:*  56 (16d6) Fire damage. *Success:*  Half damage.\\"}]"
---

# Young Red Dragon
*Large, Dragon, Chaotic Evil*

**AC** 18
**HP** 178 (17d10 + 85)
**Speed** 40 ft., climb 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 23 | 10 | 21 | 14 | 11 | 19 |

CR 10, PB +4, XP 5900

## Actions

**Multiattack**
The dragon makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +10, reach 10 ft. 13 (2d6 + 6) Slashing damage plus 3 (1d6) Fire damage.

**Fire Breath (Recharge 5-6)**
*Dexterity Saving Throw*: DC 17, each creature in a 30-foot Cone. *Failure:*  56 (16d6) Fire damage. *Success:*  Half damage.
`,
      "young-silver-dragon.md": `---
smType: creature
name: "Young Silver Dragon"
size: "Large"
type: "Dragon"
type_tags: ["Metallic"]
alignment: "Lawful Good"
ac: "18"
hp: "168"
hit_dice: "16d10 + 80"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":23},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":21},{\\"ability\\":\\"int\\",\\"score\\":14},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":19}]"
pb: "+4"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":4},{\\"ability\\":\\"wis\\",\\"bonus\\":4}]"
cr: "9"
xp: "5000"
entries_structured_json: "[{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks. It can replace one attack with a use of Paralyzing Breath.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +10, reach 10 ft. 15 (2d8 + 6) Slashing damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Cold Breath (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 17, each creature in a 30-foot Cone. *Failure:*  49 (11d8) Cold damage. *Success:*  Half damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Paralyzing Breath\\",\\"text\\":\\"*Constitution Saving Throw*: DC 17, each creature in a 30-foot Cone. *First Failure* The target has the Incapacitated condition until the end of its next turn, when it repeats the save. *Second Failure* The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.\\"}]"
---

# Young Silver Dragon
*Large, Dragon, Lawful Good*

**AC** 18
**HP** 168 (16d10 + 80)
**Speed** 40 ft., fly 80 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 23 | 10 | 21 | 14 | 11 | 19 |

CR 9, PB +4, XP 5000

## Actions

**Multiattack**
The dragon makes three Rend attacks. It can replace one attack with a use of Paralyzing Breath.

**Rend**
*Melee Attack Roll:* +10, reach 10 ft. 15 (2d8 + 6) Slashing damage.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 17, each creature in a 30-foot Cone. *Failure:*  49 (11d8) Cold damage. *Success:*  Half damage.

**Paralyzing Breath**
*Constitution Saving Throw*: DC 17, each creature in a 30-foot Cone. *First Failure* The target has the Incapacitated condition until the end of its next turn, when it repeats the save. *Second Failure* The target has the Paralyzed condition, and it repeats the save at the end of each of its turns, ending the effect on itself on a success. After 1 minute, it succeeds automatically.
`,
      "young-white-dragon.md": `---
smType: creature
name: "Young White Dragon"
size: "Large"
type: "Dragon"
type_tags: ["Chromatic"]
alignment: "Chaotic Evil"
ac: "17"
hp: "123"
hit_dice: "13d10 + 52"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"40 ft.\\"},\\"burrow\\":{\\"distance\\":\\"20 ft.\\"},\\"fly\\":{\\"distance\\":\\"80 ft.\\"},\\"swim\\":{\\"distance\\":\\"40 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":18},{\\"ability\\":\\"dex\\",\\"score\\":10},{\\"ability\\":\\"con\\",\\"score\\":18},{\\"ability\\":\\"int\\",\\"score\\":6},{\\"ability\\":\\"wis\\",\\"score\\":11},{\\"ability\\":\\"cha\\",\\"score\\":12}]"
pb: "+3"
saves_json: "[{\\"ability\\":\\"dex\\",\\"bonus\\":3},{\\"ability\\":\\"wis\\",\\"bonus\\":3}]"
cr: "6"
xp: "2300"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Ice Walk\\",\\"text\\":\\"The dragon can move across and climb icy surfaces without needing to make an ability check. Additionally, Difficult Terrain composed of ice or snow doesn't cost it extra movement.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Multiattack\\",\\"text\\":\\"The dragon makes three Rend attacks.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Rend\\",\\"text\\":\\"*Melee Attack Roll:* +7, reach 10 ft. 9 (2d4 + 4) Slashing damage plus 2 (1d4) Cold damage.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Cold Breath (Recharge 5-6)\\",\\"text\\":\\"*Constitution Saving Throw*: DC 15, each creature in a 30-foot Cone. *Failure:*  40 (9d8) Cold damage. *Success:*  Half damage.\\"}]"
---

# Young White Dragon
*Large, Dragon, Chaotic Evil*

**AC** 17
**HP** 123 (13d10 + 52)
**Speed** 40 ft., swim 40 ft., fly 80 ft., burrow 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 18 | 10 | 18 | 6 | 11 | 12 |

CR 6, PB +3, XP 2300

## Traits

**Ice Walk**
The dragon can move across and climb icy surfaces without needing to make an ability check. Additionally, Difficult Terrain composed of ice or snow doesn't cost it extra movement.

## Actions

**Multiattack**
The dragon makes three Rend attacks.

**Rend**
*Melee Attack Roll:* +7, reach 10 ft. 9 (2d4 + 4) Slashing damage plus 2 (1d4) Cold damage.

**Cold Breath (Recharge 5-6)**
*Constitution Saving Throw*: DC 15, each creature in a 30-foot Cone. *Failure:*  40 (9d8) Cold damage. *Success:*  Half damage.
`,
      "zombie.md": `---
smType: creature
name: "Zombie"
size: "Medium"
type: "Undead"
alignment: "Neutral Evil"
ac: "8"
hp: "15"
hit_dice: "2d8 + 6"
speeds_json: "{\\"walk\\":{\\"distance\\":\\"20 ft.\\"}}"
abilities_json: "[{\\"ability\\":\\"str\\",\\"score\\":13},{\\"ability\\":\\"dex\\",\\"score\\":6},{\\"ability\\":\\"con\\",\\"score\\":16},{\\"ability\\":\\"int\\",\\"score\\":3},{\\"ability\\":\\"wis\\",\\"score\\":6},{\\"ability\\":\\"cha\\",\\"score\\":5}]"
pb: "+2"
cr: "1/4"
xp: "50"
entries_structured_json: "[{\\"category\\":\\"trait\\",\\"name\\":\\"Undead Fortitude\\",\\"text\\":\\"If damage reduces the zombie to 0 Hit Points, it makes a Constitution saving throw (DC 5 plus the damage taken) unless the damage is Radiant or from a Critical Hit. On a successful save, the zombie drops to 1 Hit Point instead.\\"},{\\"category\\":\\"action\\",\\"name\\":\\"Slam\\",\\"text\\":\\"*Melee Attack Roll:* +3, reach 5 ft. 5 (1d8 + 1) Bludgeoning damage.\\"}]"
---

# Zombie
*Medium, Undead, Neutral Evil*

**AC** 8
**HP** 15 (2d8 + 6)
**Speed** 20 ft.

| STR | DEX | CON | INT | WIS | CHA |
| --- | --- | --- | --- | --- | --- |
| 13 | 6 | 16 | 3 | 6 | 5 |

CR 1/4, PB +2, XP 50

## Traits

**Undead Fortitude**
If damage reduces the zombie to 0 Hit Points, it makes a Constitution saving throw (DC 5 plus the damage taken) unless the damage is Radiant or from a Critical Hit. On a successful save, the zombie drops to 1 Hit Point instead.

## Actions

**Slam**
*Melee Attack Roll:* +3, reach 5 ft. 5 (1d8 + 1) Bludgeoning damage.
`
    };
    PRESET_SPELLS = {
      "Acid Arrow.md": `---
smType: spell
name: "Acid Arrow"
level: 2
school: "Evocation"
casting_time: "Action"
range: "90 feet"
components: ["V", "S", "M"]
materials: "powdered rhubarb leaf"
duration: "Instantaneous"
classes: ["Wizard"]
save_effect: "Half damage on success"
attack: "ranged spell attack"
damage: "4d4"
damage_type: "Acid"
---

# Acid Arrow
Level 2 Evocation

- Casting Time: Action
- Range: 90 feet
- Components: V, S, M (powdered rhubarb leaf)
- Duration: Instantaneous
- Classes: Wizard
- Attack: ranged spell attack
- Damage: 4d4 Acid

A shimmering green arrow streaks toward a target within range and bursts in a spray of acid. Make a ranged spell attack against the target. On a hit, the target takes 4d4 Acid damage and 2d4 Acid damage at the end of its next turn. On a miss, the arrow splashes the target with acid for half as much of the initial damage only.
`,
      "Acid Splash.md": `---
smType: spell
name: "Acid Splash"
level: 0
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
damage: "1d6"
damage_type: "Acid"
---

# Acid Splash
Cantrip Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Save: DEX
- Damage: 1d6 Acid

You create an acidic bubble at a point within range, where it explodes in a 5-foot-radius Sphere. Each creature in that Sphere must succeed on a Dexterity saving throw or take 1d6 Acid damage.
`,
      "Aid.md": `---
smType: spell
name: "Aid"
level: 2
school: "Abjuration"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a strip of white cloth"
duration: "8 hours"
classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger"]
---

# Aid
Level 2 Abjuration

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a strip of white cloth)
- Duration: 8 hours
- Classes: Bard, Cleric, Druid, Paladin, Ranger

Choose up to three creatures within range. Each target's Hit Point maximum and current Hit Points increase by 5 for the duration.
`,
      "Alarm.md": `---
smType: spell
name: "Alarm"
level: 1
school: "Abjuration"
casting_time: "1 minute or Ritual"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a bell and silver wire"
duration: "8 hours"
ritual: true
classes: ["Ranger", "Wizard"]
---

# Alarm
Level 1 Abjuration

- Casting Time: 1 minute or Ritual
- Range: 30 feet
- Components: V, S, M (a bell and silver wire)
- Duration: 8 hours
- Ritual: yes
- Classes: Ranger, Wizard

You set an alarm against intrusion. Choose a door, a window, or an area within range that is no larger than a 20-foot Cube. Until the spell ends, an alarm alerts you whenever a creature touches or enters the warded area. When you cast the spell, you can designate creatures that won't set off the alarm. You also choose whether the alarm is audible or mental:

**Audible Alarm.** The alarm produces the sound of a handbell for 10 seconds within 60 feet of the warded area.

**Mental Alarm.** You are alerted by a mental ping if you are within 1 mile of the warded area. This ping awakens you if you're asleep.
`,
      "Alter Self.md": `---
smType: spell
name: "Alter Self"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Sorcerer", "Wizard"]
---

# Alter Self
Level 2 Transmutation

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Sorcerer, Wizard

You alter your physical form. Choose one of the following options. Its effects last for the duration, during which you can take a Magic action to replace the option you chose with a different one.

**_Aquatic Adaptation._** You sprout gills and grow webs between your fingers. You can breathe underwater and gain a Swim Speed equal to your Speed.

**_Change Appearance._** You alter your appearance. You decide what you look like, including your height, weight, facial features, sound of your voice, hair length, coloration, and other distinguishing characteristics. You can make yourself appear as a member of another species, though none of your statistics change. You can't appear as a creature of a different size, and your basic shape stays the same; if you're bipedal, you can't use this spell to become quadrupedal, for instance. For the duration, you can take a Magic action to change your appearance in this way again.

**_Natural Weapons._** You grow claws (Slashing), fangs (Piercing), horns (Piercing), or hooves (Bludgeoning). When you use your Unarmed Strike to deal damage with that new growth, it deals 1d6 damage of the type in parentheses instead of dealing the normal damage for your Unarmed Strike, and you use your spellcasting ability modifier for the attack and damage rolls rather than using Strength.
`,
      "Animal Friendship.md": `---
smType: spell
name: "Animal Friendship"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a morsel of food"
duration: "24 hours"
classes: ["Bard", "Druid", "Ranger"]
save_ability: "WIS"
---

# Animal Friendship
Level 1 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a morsel of food)
- Duration: 24 hours
- Classes: Bard, Druid, Ranger
- Save: WIS

Target a Beast that you can see within range. The target must succeed on a Wisdom saving throw or have the Charmed condition for the duration. If you or one of your allies deals damage to the target, the spells ends.
`,
      "Animal Messenger.md": `---
smType: spell
name: "Animal Messenger"
level: 2
school: "Enchantment"
casting_time: "Action or Ritual"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a morsel of food"
duration: "24 hours"
ritual: true
classes: ["Bard", "Druid", "Ranger"]
save_ability: "CHA"
---

# Animal Messenger
Level 2 Enchantment

- Casting Time: Action or Ritual
- Range: 30 feet
- Components: V, S, M (a morsel of food)
- Duration: 24 hours
- Ritual: yes
- Classes: Bard, Druid, Ranger
- Save: CHA

A Tiny Beast of your choice that you can see within range must succeed on a Charisma saving throw, or it attempts to deliver a message for you (if the target's Challenge Rating isn't 0, it automatically succeeds). You specify a location you have visited and a recipient who matches a general description, such as "a person dressed in the uniform of the town guard" or "a red-haired dwarf wearing a pointed hat." You also communicate a message of up to twenty-five words. The Beast travels for the duration toward the specified location, covering about 25 miles per 24 hours or 50 miles if the Beast can fly.

When the Beast arrives, it delivers your message to the creature that you described, mimicking your communication. If the Beast doesn't reach its destination before the spell ends, the message is lost, and the Beast returns to where you cast the spell.
`,
      "Animal Shapes.md": `---
smType: spell
name: "Animal Shapes"
level: 8
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "24 hours"
classes: ["Druid"]
---

# Animal Shapes
Level 8 Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: 24 hours
- Classes: Druid

Choose any number of willing creatures that you can see within range. Each target shape-shifts into a Large or smaller Beast of your choice that has a Challenge Rating of 4 or lower. You can choose a different form for each target. On later turns, you can take a Magic action to transform the targets again.

A target's game statistics are replaced by the chosen Beast's statistics, but the target retains its creature type; Hit Points; Hit Point Dice; alignment; ability to communicate; and Intelligence, Wisdom, and Charisma scores. The target's actions are limited by the Beast form's anatomy, and it can't cast spells. The target's equipment melds into the new form, and the target can't use any of that equipment while in that form.

The target gains a number of Temporary Hit Points equal to the Hit Points of the first form into which it shape-shifts. These Temporary Hit Points vanish if any remain when the spell ends. The transformation lasts for the duration or until the target ends it as a Bonus Action.
`,
      "Animate Dead.md": `---
smType: spell
name: "Animate Dead"
level: 3
school: "Necromancy"
casting_time: "1 minute"
range: "10 feet"
components: ["V", "S", "M"]
materials: "a drop of blood, a piece of flesh, and a pinch of bone dust"
duration: "Instantaneous"
classes: ["Cleric", "Wizard"]
---

# Animate Dead
Level 3 Necromancy

- Casting Time: 1 minute
- Range: 10 feet
- Components: V, S, M (a drop of blood, a piece of flesh, and a pinch of bone dust)
- Duration: Instantaneous
- Classes: Cleric, Wizard

Choose a pile of bones or a corpse of a Medium or Small Humanoid within range. The target becomes an Undead creature: a **Skeleton** if you chose bones or a **Zombie** if you chose a corpse (see "Monsters" for the stat blocks).

On each of your turns, you can take a Bonus Action to mentally command any creature you made with this spell if the creature is within 60 feet of you (if you control multiple creatures, you can command any of them at the same time, issuing the same command to each one). You decide what action the creature will take and where it will move on its next turn, or you can issue a general command, such as to guard a chamber or corridor. If you issue no commands, the creature takes the Dodge action and moves only to avoid harm. Once given an order, the creature continues to follow it until its task is complete.

The creature is under your control for 24 hours, after which it stops obeying any command you've given it. To maintain control of the creature for another 24 hours, you must cast this spell on the creature again before the current 24-hour period ends. This use of the spell reasserts your control over up to four creatures you have animated with this spell rather than animating a new creature.
`,
      "Animate Objects.md": `---
smType: spell
name: "Animate Objects"
level: 5
school: "Transmutation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
---

# Animate Objects
Level 5 Transmutation

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard

Objects animate at your command. Choose a number of nonmagical objects within range that aren't being worn or carried, aren't fixed to a surface, and aren't Gargantuan. The maximum number of objects is equal to your spellcasting ability modifier; for this number, a Medium or smaller target counts as one object, a Large target counts as two, and a Huge target counts as three.

Each target animates, sprouts legs, and becomes a Construct that uses the **Animated Object** stat block; this creature is under your control until the spell ends or until it is reduced to 0 Hit Points. Each creature you make with this spell is an ally to you and your allies. In combat, it shares your Initiative count and takes its turn immediately after yours.

Until the spell ends, you can take a Bonus Action to mentally command any creature you made with this spell if the creature is within 500 feet of you (if you control multiple creatures, you can command any of them at the same time, issuing the same command to each one). If you issue no commands, the creature takes the Dodge action and moves only to avoid harm. When the creature drops to 0 Hit Points, it reverts to its object form, and any remaining damage carries over to that form.

## At Higher Levels

> #### Animated Object

>

> *Huge or Smaller Construct, Unaligned*

>

> **AC** 15

>

> **HP** 10 (Medium or smaller), 20 (Large), 40 (Huge)

>

> **Speed** 30 ft.

>

> | Attribute | Score | Mod | Save |

> |-----------|-------|-----|------|

> | Str       | 16    | +3  | +3   |

> | Dex       | 10    | +0  | +0   |

> | Con       | 10    | +0  | +0   |

> | Int       | 3     | -4  | -4   |

> | Wis       | 3     | -4  | -4   |

> | Cha       | 1     | -5  | -5   |

>

> **Immunities** Poison, Psychic; Charmed, Exhaustion, Frightened, Paralyzed, Poisoned

>

> **Senses** Blindsight 30 ft.; Passive Perception 6

>

> **Languages** Understands the languages you know

>

> **CR** None (XP 0; PB equals your Proficiency Bonus)

>

> #### Actions

>

> **Slam.** *Melee Attack Roll:* Bonus equals your spell attack modifier, reach 5 ft. *Hit:* Force damage equal to 1d4 + 3 (Medium or smaller), 2d6 + 3 + your spellcasting ability modifier (Large), or 2d12 + 3 + your spellcasting ability modifier (Huge).
`,
      "Antilife Shell.md": `---
smType: spell
name: "Antilife Shell"
level: 5
school: "Abjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Druid"]
---

# Antilife Shell
Level 5 Abjuration

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Druid

An aura extends from you in a 10-foot Emanation for the duration. The aura prevents creatures other than Constructs and Undead from passing or reaching through it. An affected creature can cast spells or make attacks with Ranged or Reach weapons through the barrier.

If you move so that an affected creature is forced to pass through the barrier, the spell ends.
`,
      "Antimagic Field.md": `---
smType: spell
name: "Antimagic Field"
level: 8
school: "Abjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "iron filings"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Cleric", "Wizard"]
---

# Antimagic Field
Level 8 Abjuration

- Casting Time: Action
- Range: Self
- Components: V, S, M (iron filings)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Cleric, Wizard

An aura of antimagic surrounds you in 10-foot Emanation. No one can cast spells, take Magic actions, or create other magical effects inside the aura, and those things can't target or otherwise affect anything inside it. Magical properties of magic items don't work inside the aura or on anything inside it.

Areas of effect created by spells or other magic can't extend into the aura, and no one can teleport into or out of it or use planar travel there. Portals close temporarily while in the aura.

Ongoing spells, except those cast by an Artifact or a deity, are suppressed in the area. While an effect is suppressed, it doesn't function, but the time it spends suppressed counts against its duration.

*Dispel Magic* has no effect on the aura, and the auras created by different *Antimagic Field* spells don't nullify each other.
`,
      "Antipathy-Sympathy.md": `---
smType: spell
name: "Antipathy/Sympathy"
level: 8
school: "Enchantment"
casting_time: "1 hour"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a mix of vinegar and honey"
duration: "10 days"
classes: ["Bard", "Druid", "Wizard"]
save_ability: "WIS"
---

# Antipathy/Sympathy
Level 8 Enchantment

- Casting Time: 1 hour
- Range: 60 feet
- Components: V, S, M (a mix of vinegar and honey)
- Duration: 10 days
- Classes: Bard, Druid, Wizard
- Save: WIS

As you cast the spell, choose whether it creates antipathy or sympathy, and target one creature or object that is Huge or smaller. Then specify a kind of creature, such as red dragons, goblins, or vampires. A creature of the chosen kind makes a Wisdom saving throw when it comes within 120 feet of the target. Your choice of antipathy or sympathy determines what happens to a creature when it fails that save:

**Antipathy.** The creature has the Frightened condition. The Frightened creature must use its movement on its turns to get as far away as possible from the target, moving by the safest route.

**Sympathy.** The creature has the Charmed condition. The Charmed creature must use its movement on its turns to get as close as possible to the target, moving by the safest route. If the creature is within 5 feet of the target, the creature can't willingly move away. If the target damages the Charmed creature, that creature can make a

Wisdom saving throw to end the effect, as described below.

**_Ending the Effect._** If the Frightened or Charmed creature ends its turn more than 120 feet away from the target, the creature makes a Wisdom saving throw. On a successful save, the creature is no longer affected by the target. A creature that successfully saves against this effect is immune to it for 1 minute, after which it can be affected again.
`,
      "Arcane Eye.md": `---
smType: spell
name: "Arcane Eye"
level: 4
school: "Divination"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a bit of bat fur"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Wizard"]
---

# Arcane Eye
Level 4 Divination

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a bit of bat fur)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Wizard

You create an Invisible, invulnerable eye within range that hovers for the duration. You mentally receive visual information from the eye, which can see in every direction. It also has Darkvision with a range of 30 feet.

As a Bonus Action, you can move the eye up to 30 feet in any direction. A solid barrier blocks the eye's movement, but the eye can pass through an opening as small as 1 inch in diameter.
`,
      "Arcane Hand.md": `---
smType: spell
name: "Arcane Hand"
level: 5
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "an eggshell and a glove"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Sorcerer", "Wizard"]
save_ability: "STR"
save_effect: "Half damage on success"
attack: "melee spell attack"
damage: "5d8"
damage_type: "Force"
---

# Arcane Hand
Level 5 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (an eggshell and a glove)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Sorcerer, Wizard
- Attack: melee spell attack
- Save: STR (Half damage on success)
- Damage: 5d8 Force

You create a Large hand of shimmering magical energy in an unoccupied space that you can see within range. The hand lasts for the duration, and it moves at your command, mimicking the movements of your own hand.

The hand is an object that has AC 20 and Hit Points equal to your Hit Point maximum. If it drops to 0 Hit Points, the spell ends. The hand doesn't occupy its space.

When you cast the spell and as a Bonus Action on your later turns, you can move the hand up to 60 feet and then cause one of the following effects:

**Clenched Fist.** The hand strikes a target within 5 feet of it. Make a melee spell attack. On a hit, the target takes 5d8 Force damage.

**Forceful Hand.** The hand attempts to push a Huge or smaller creature within 5 feet of it. The target must succeed on a Strength saving throw, or the hand pushes the target up to 5 feet plus a number of feet equal to five times your spellcasting ability modifier. The hand moves with the target, remaining within 5 feet of it.

**Grasping Hand.** The hand attempts to grapple a Huge or smaller creature within 5 feet of it. The target must succeed on a Dexterity saving throw, or the target has the Grappled condition, with an escape DC equal to your spell save DC. While the hand grapples the target, you can take a Bonus Action to cause the hand to crush it, dealing Bludgeoning damage to the target equal to 4d6 plus your spellcasting ability modifier.

**Interposing Hand.** The hand grants you Half Cover against attacks and other effects that originate from its space or that pass through it. In addition, its space counts as Difficult Terrain for your enemies.
`,
      "Arcane Lock.md": `---
smType: spell
name: "Arcane Lock"
level: 2
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "gold dust worth 25+ GP, which the spell consumes"
duration: "Until dispelled"
classes: ["Wizard"]
---

# Arcane Lock
Level 2 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S, M (gold dust worth 25+ GP, which the spell consumes)
- Duration: Until dispelled
- Classes: Wizard

You touch a closed door, window, gate, container, or hatch and magically lock it for the duration. This lock can't be unlocked by any nonmagical means. You and any creatures you designate when you cast the spell can open and close the object despite the lock. You can also set a password that, when spoken within 5 feet of the object, unlocks it for 1 minute.
`,
      "Arcane Sword.md": `---
smType: spell
name: "Arcane Sword"
level: 7
school: "Evocation"
casting_time: "Action"
range: "90 feet"
components: ["V", "S", "M"]
materials: "a miniature sword worth 250+ GP"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Wizard"]
attack: "melee spell attack"
---

# Arcane Sword
Level 7 Evocation

- Casting Time: Action
- Range: 90 feet
- Components: V, S, M (a miniature sword worth 250+ GP)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Wizard
- Attack: melee spell attack

You create a spectral sword that hovers within range. It lasts for the duration.

When the sword appears, you make a melee spell attack against a target within 5 feet of the sword. On a hit, the target takes Force damage equal to 4d12 plus your spellcasting ability modifier.

On your later turns, you can take a Bonus Action to move the sword up to 30 feet to a spot you can see and repeat the attack against the same target or a different one.
`,
      "Arcanist's Magic Aura.md": `---
smType: spell
name: "Arcanist's Magic Aura"
level: 2
school: "Illusion"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a small square of silk"
duration: "24 hours"
classes: ["Wizard"]
---

# Arcanist's Magic Aura
Level 2 Illusion

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a small square of silk)
- Duration: 24 hours
- Classes: Wizard

With a touch, you place an illusion on a willing creature or an object that isn't being worn or carried. A creature gains the Mask effect below, and an object gains the False Aura effect below. The effect lasts for the duration. If you cast the spell on the same target every day for 30 days, the illusion lasts until dispelled.

**_Mask (Creature)._** Choose a creature type other than the target's actual type. Spells and other magical effects treat the target as if it were a creature of the chosen type.

**_False Aura (Object)._** You change the way the target appears to spells and magical effects that detect magical auras, such as *Detect Magic*. You can make a nonmagical object appear magical, make a magic item appear nonmagical, or change the object's aura so that it appears to belong to a school of magic you choose.
`,
      "Astral Projection.md": `---
smType: spell
name: "Astral Projection"
level: 9
school: "Necromancy"
casting_time: "1 hour"
range: "10 feet"
components: ["V", "S", "M"]
materials: "for each of the spell's targets, one jacinth worth 1,000+ GP and one silver bar worth 100+ GP, all of which the spell consumes"
duration: "Until dispelled"
classes: ["Cleric", "Warlock", "Wizard"]
---

# Astral Projection
Level 9 Necromancy

- Casting Time: 1 hour
- Range: 10 feet
- Components: V, S, M (for each of the spell's targets, one jacinth worth 1,000+ GP and one silver bar worth 100+ GP, all of which the spell consumes)
- Duration: Until dispelled
- Classes: Cleric, Warlock, Wizard

You and up to eight willing creatures within range project your astral bodies into the Astral Plane (the spell ends instantly if you are already on that plane). Each target's body is left behind in a state of suspended animation; it has the Unconscious condition, doesn't need food or air, and doesn't age.

A target's astral form resembles its body in almost every way, replicating its game statistics and possessions. The principal difference is the addition of a silvery cord that trails from between the shoulder blades of the astral form. The cord fades from view after 1 foot. If the cord is cut\u2014which happens only when an effect states that it does so\u2014the target's body and astral form both die.

A target's astral form can travel through the Astral Plane. The moment an astral form leaves that plane, the target's body and possessions travel along the silver cord, causing the target to re-enter its body on the new plane.

Any damage or other effects that apply to an astral form have no effect on the target's body and vice versa. If a target's body or astral form drops to 0 Hit Points, the spell ends for that target. The spell ends for all the targets if you take a Magic action to dismiss it.

When the spell ends for a target who isn't dead, the target reappears in its body and exits the state of suspended animation.
`,
      "Augury.md": `---
smType: spell
name: "Augury"
level: 2
school: "Divination"
casting_time: "1 minute or Ritual"
range: "Self"
components: ["V", "S", "M"]
materials: "specially marked sticks, bones, cards, or other divinatory tokens worth 25+ GP"
duration: "Instantaneous"
ritual: true
classes: ["Cleric", "Druid", "Wizard"]
---

# Augury
Level 2 Divination

- Casting Time: 1 minute or Ritual
- Range: Self
- Components: V, S, M (specially marked sticks, bones, cards, or other divinatory tokens worth 25+ GP)
- Duration: Instantaneous
- Ritual: yes
- Classes: Cleric, Druid, Wizard

You receive an omen from an otherworldly entity about the results of a course of action that you plan to take within the next 30 minutes. The GM chooses the omen from the Omens table.

Table: Omens

| Omen         | For Results That Will Be \u2026 |

|--------------|----------------------------|

| Weal         | Good                       |

| Woe          | Bad                        |

| Weal and woe | Good and bad               |

| Indifference | Neither good nor bad       |

The spell doesn't account for circumstances, such as other spells, that might change the results.

If you cast the spell more than once before finishing a Long Rest, there is a cumulative 25 percent chance for each casting after the first that you get no answer.
`,
      "Aura of Life.md": `---
smType: spell
name: "Aura of Life"
level: 4
school: "Abjuration"
casting_time: "Action"
range: "Self"
components: ["V"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Cleric", "Paladin"]
---

# Aura of Life
Level 4 Abjuration

- Casting Time: Action
- Range: Self
- Components: V
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Cleric, Paladin

An aura radiates from you in a 30-foot Emanation for the duration. While in the aura, you and your allies have Resistance to Necrotic damage, and your Hit Point maximums can't be reduced. If an ally with 0 Hit Points starts its turn in the aura, that ally regains 1 Hit Point.
`,
      "Awaken.md": `---
smType: spell
name: "Awaken"
level: 5
school: "Transmutation"
casting_time: "8 hours"
range: "Touch"
components: ["V", "S", "M"]
materials: "an agate worth 1,000+ GP, which the spell consumes"
duration: "Instantaneous"
classes: ["Bard", "Druid"]
---

# Awaken
Level 5 Transmutation

- Casting Time: 8 hours
- Range: Touch
- Components: V, S, M (an agate worth 1,000+ GP, which the spell consumes)
- Duration: Instantaneous
- Classes: Bard, Druid

You spend the casting time tracing magical pathways within a precious gemstone, and then touch the target. The target must be either a Beast or Plant creature with an Intelligence of 3 or less or a natural plant that isn't a creature. The target gains an Intelligence of 10 and the ability to speak one language you know. If the target is a natural plant, it becomes a Plant creature and gains the ability to move its limbs, roots, vines, creepers, and so forth, and it gains senses similar to a human's. The GM chooses statistics appropriate for the awakened Plant, such as the statistics for the **Awakened Shrub** or **Awakened Tree** in "Monsters."

The awakened target has the Charmed condition for 30 days or until you or your allies deal damage to it. When that condition ends, the awakened creature chooses its attitude toward you.

### B Spells
`,
      "Bane.md": `---
smType: spell
name: "Bane"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a drop of blood"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Cleric", "Warlock"]
save_ability: "CHA"
---

# Bane
Level 1 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a drop of blood)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Cleric, Warlock
- Save: CHA

Up to three creatures of your choice that you can see within range must each make a Charisma saving throw. Whenever a target that fails this save makes an attack roll or a saving throw before the spell ends, the target must subtract 1d4 from the attack roll or save.
`,
      "Banishment.md": `---
smType: spell
name: "Banishment"
level: 4
school: "Abjuration"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a pentacle"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric", "Paladin", "Sorcerer", "Warlock", "Wizard"]
save_ability: "CHA"
---

# Banishment
Level 4 Abjuration

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a pentacle)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric, Paladin, Sorcerer, Warlock, Wizard
- Save: CHA

One creature that you can see within range must succeed on a Charisma saving throw or be transported to a harmless demiplane for the duration. While there, the target has the Incapacitated condition. When the spell ends, the target reappears in the space it left or in the nearest unoccupied space if that space is occupied.

If the target is an Aberration, a Celestial, an Elemental, a Fey, or a Fiend, the target doesn't return if the spell lasts for 1 minute. The target is instead transported to a random location on a plane (GM's choice) associated with its creature type.
`,
      "Barkskin.md": `---
smType: spell
name: "Barkskin"
level: 2
school: "Transmutation"
casting_time: "Bonus Action"
range: "Touch"
duration: "1 hour"
classes: ["Druid", "Ranger"]
---

# Barkskin
Level 2 Transmutation

- Casting Time: Bonus Action
- Range: Touch
- Duration: 1 hour
- Classes: Druid, Ranger

You touch a willing creature. Until the spell ends, the target's skin assumes a bark-like appearance, and the target has an Armor Class of 17 if its AC is lower than that.
`,
      "Beacon of Hope.md": `---
smType: spell
name: "Beacon of Hope"
level: 3
school: "Abjuration"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric"]
save_ability: "WIS"
---

# Beacon of Hope
Level 3 Abjuration

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric
- Save: WIS

Choose any number of creatures within range. For the duration, each target has Advantage on Wisdom saving throws and Death Saving Throws and regains the maximum number of Hit Points possible from any healing.
`,
      "Befuddlement.md": `---
smType: spell
name: "Befuddlement"
level: 8
school: "Enchantment"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "a key ring with no keys"
duration: "Instantaneous"
classes: ["Bard", "Druid", "Warlock", "Wizard"]
save_ability: "INT"
save_effect: "Half damage on success"
damage: "10d12"
damage_type: "Psychic"
---

# Befuddlement
Level 8 Enchantment

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (a key ring with no keys)
- Duration: Instantaneous
- Classes: Bard, Druid, Warlock, Wizard
- Save: INT (Half damage on success)
- Damage: 10d12 Psychic

You blast the mind of a creature that you can see within range. The target makes an Intelligence saving throw.

On a failed save, the target takes 10d12 Psychic damage and can't cast spells or take the Magic action. At the end of every 30 days, the target repeats the save, ending the effect on a success. The effect can also be ended by the *Greater Restoration*, *Heal*, or *Wish* spell.

On a successful save, the target takes half as much damage only.
`,
      "Bestow Curse.md": `---
smType: spell
name: "Bestow Curse"
level: 3
school: "Necromancy"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Cleric", "Wizard"]
save_ability: "WIS"
damage: "1d8"
damage_type: "Necrotic"
---

# Bestow Curse
Level 3 Necromancy

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Cleric, Wizard
- Save: WIS
- Damage: 1d8 Necrotic

You touch a creature, which must succeed on a Wisdom saving throw or become cursed for the duration. Until the curse ends, the target suffers one of the following effects of your choice:

- Choose one ability. The target has Disadvantage on ability checks and saving throws made with that ability.

- The target has Disadvantage on attack rolls against you.

- In combat, the target must succeed on a Wisdom saving throw at the start of each of its turns or be forced to take the Dodge action on that turn.

- If you deal damage to the target with an attack roll or a spell, the target takes an extra 1d8 Necrotic damage.
`,
      "Black Tentacles.md": `---
smType: spell
name: "Black Tentacles"
level: 4
school: "Conjuration"
casting_time: "Action"
range: "90 feet"
components: ["V", "S", "M"]
materials: "a tentacle"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Wizard"]
save_ability: "STR"
damage: "3d6"
damage_type: "Bludgeoning"
---

# Black Tentacles
Level 4 Conjuration

- Casting Time: Action
- Range: 90 feet
- Components: V, S, M (a tentacle)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Wizard
- Save: STR
- Damage: 3d6 Bludgeoning

Squirming, ebony tentacles fill a 20-foot square on ground that you can see within range. For the duration, these tentacles turn the ground in that area into Difficult Terrain.

Each creature in that area makes a Strength saving throw. On a failed save, it takes 3d6 Bludgeoning damage, and it has the Restrained condition until the spell ends. A creature also makes that save if it enters the area or ends it turn there. A creature makes that save only once per turn.

A Restrained creature can take an action to make a Strength (Athletics) check against your spell save DC, ending the condition on itself on a success.
`,
      "Blade Barrier.md": `---
smType: spell
name: "Blade Barrier"
level: 6
school: "Evocation"
casting_time: "Action"
range: "90 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Cleric"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "6d10"
damage_type: "Force"
---

# Blade Barrier
Level 6 Evocation

- Casting Time: Action
- Range: 90 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Cleric
- Save: DEX (Half damage on success)
- Damage: 6d10 Force

You create a wall of whirling blades made of magical energy. The wall appears within range and lasts for the duration. You make a straight wall up to 100 feet long, 20 feet high, and 5 feet thick, or a ringed wall up to 60 feet in diameter, 20 feet high, and 5 feet thick. The wall provides Three-Quarters Cover, and its space is Difficult Terrain.

Any creature in the wall's space makes a Dexterity saving throw, taking 6d10 Force damage on a failed save or half as much damage on a successful one. A creature also makes that save if it enters the wall's space or ends it turn there. A creature makes that save only once per turn.
`,
      "Bless.md": `---
smType: spell
name: "Bless"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a Holy Symbol worth 5+ GP"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric", "Paladin"]
---

# Bless
Level 1 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a Holy Symbol worth 5+ GP)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric, Paladin

You bless up to three creatures within range. Whenever a target makes an attack roll or a saving throw before the spell ends, the target adds 1d4 to the attack roll or save.
`,
      "Blight.md": `---
smType: spell
name: "Blight"
level: 4
school: "Necromancy"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Druid", "Sorcerer", "Warlock", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "8d8"
damage_type: "Necrotic"
---

# Blight
Level 4 Necromancy

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Druid, Sorcerer, Warlock, Wizard
- Save: CON (Half damage on success)
- Damage: 8d8 Necrotic

A creature that you can see within range makes a Constitution saving throw, taking 8d8 Necrotic damage on a failed save or half as much damage on a successful one. A Plant creature automatically fails the save.

Alternatively, target a nonmagical plant that isn't a creature, such as a tree or shrub. It doesn't make a save; it simply withers and dies.
`,
      "Blindness-Deafness.md": `---
smType: spell
name: "Blindness/Deafness"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "120 feet"
components: ["V"]
duration: "1 minute"
classes: ["Bard", "Cleric", "Sorcerer", "Wizard"]
save_ability: "CON"
---

# Blindness/Deafness
Level 2 Transmutation

- Casting Time: Action
- Range: 120 feet
- Components: V
- Duration: 1 minute
- Classes: Bard, Cleric, Sorcerer, Wizard
- Save: CON

One creature that you can see within range must succeed on a Constitution saving throw, or it has the Blinded or Deafened condition (your choice) for the duration. At the end of each of its turns, the target repeats the save, ending the spell on itself on a success.
`,
      "Blink.md": `---
smType: spell
name: "Blink"
level: 3
school: "Transmutation"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "1 minute"
classes: ["Sorcerer", "Wizard"]
---

# Blink
Level 3 Transmutation

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: 1 minute
- Classes: Sorcerer, Wizard

Roll 1d6 at the end of each of your turns for the duration. On a roll of 4\u20136, you vanish from your current plane of existence and appear in the Ethereal Plane (the spell ends instantly if you are already on that plane). While on the Ethereal Plane, you can

perceive the plane you left, which is cast in shades of gray, but you can't see anything there more than 60 feet away. You can affect and be affected only by other creatures on the Ethereal Plane, and creatures on the other plane can't perceive you unless they have a special ability that lets them perceive things on the Ethereal Plane.

You return to the other plane at the start of your next turn and when the spell ends if you are on the Ethereal Plane. You return to an unoccupied space of your choice that you can see within 10 feet of the space you left. If no unoccupied space is available within that range, you appear in the nearest unoccupied space.
`,
      "Blur.md": `---
smType: spell
name: "Blur"
level: 2
school: "Illusion"
casting_time: "Action"
range: "Self"
components: ["V"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Sorcerer", "Wizard"]
---

# Blur
Level 2 Illusion

- Casting Time: Action
- Range: Self
- Components: V
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Sorcerer, Wizard

Your body becomes blurred. For the duration, any creature has Disadvantage on attack rolls against you. An attacker is immune to this effect if it perceives you with Blindsight or Truesight.
`,
      "Burning Hands.md": `---
smType: spell
name: "Burning Hands"
level: 1
school: "Evocation"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "3d6"
damage_type: "Fire"
---

# Burning Hands
Level 1 Evocation

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 3d6 Fire

A thin sheet of flames shoots forth from you. Each creature in a 15-foot Cone makes a Dexterity saving throw, taking 3d6 Fire damage on a failed save or half as much damage on a successful one.

Flammable objects in the Cone that aren't being worn or carried start burning.

## At Higher Levels

### C Spells
`,
      "Call Lightning.md": `---
smType: spell
name: "Call Lightning"
level: 3
school: "Conjuration"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "3d10"
damage_type: "Lightning"
---

# Call Lightning
Level 3 Conjuration

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid
- Save: DEX (Half damage on success)
- Damage: 3d10 Lightning

A storm cloud appears at a point within range that you can see above yourself. It takes the shape of a Cylinder that is 10 feet tall with a 60-foot radius.

When you cast the spell, choose a point you can see under the cloud. A lightning bolt shoots from the cloud to that point. Each creature within 5 feet of that point makes a Dexterity saving throw, taking 3d10 Lightning damage on a failed save or half as much damage on a successful one.

Until the spell ends, you can take a Magic action to call down lightning in that way again, targeting the same point or a different one.

If you're outdoors in a storm when you cast this spell, the spell gives you control over that storm instead of creating a new one. Under such conditions, the spell's damage increases by 1d10.
`,
      "Calm Emotions.md": `---
smType: spell
name: "Calm Emotions"
level: 2
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Cleric"]
save_ability: "CHA"
---

# Calm Emotions
Level 2 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Cleric
- Save: CHA

Each Humanoid in a 20-foot-radius Sphere centered on a point you choose within range must succeed on a Charisma saving throw or be affected by one of the following effects (choose for each creature):

- The creature has Immunity to the Charmed and Frightened conditions until the spell ends. If the creature was already Charmed or Frightened, those conditions are suppressed for the duration.

- The creature becomes Indifferent about creatures of your choice that it's Hostile toward. This indifference ends if the target takes damage or witnesses its allies taking damage. When the spell ends, the creature's attitude returns to normal.
`,
      "Chain Lightning.md": `---
smType: spell
name: "Chain Lightning"
level: 6
school: "Evocation"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "three silver pins"
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "10d8"
damage_type: "Lightning"
---

# Chain Lightning
Level 6 Evocation

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (three silver pins)
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 10d8 Lightning

You launch a lightning bolt toward a target you can see within range. Three bolts then leap from that target to as many as three other targets of your choice, each of which must be within 30 feet of the first target. A target can be a creature or an object and can be targeted by only one of the bolts.

Each target makes a Dexterity saving throw, taking 10d8 Lightning damage on a failed save or half as much damage on a successful one.

*Using a Higher-Level Spell Slot.* One additional bolt leaps from the first target to another target for each spell slot level above 6.
`,
      "Charm Monster.md": `---
smType: spell
name: "Charm Monster"
level: 4
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "1 hour"
classes: ["Bard", "Druid", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Charm Monster
Level 4 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: 1 hour
- Classes: Bard, Druid, Sorcerer, Warlock, Wizard
- Save: WIS

One creature you can see within range makes a Wisdom saving throw. It does so with Advantage if you or your allies are fighting it. On a failed save, the target has the Charmed condition until the spell ends or until you or your allies damage it. The Charmed creature is Friendly to you. When the spell ends, the target knows it was Charmed by you.
`,
      "Charm Person.md": `---
smType: spell
name: "Charm Person"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "1 hour"
classes: ["Bard", "Druid", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Charm Person
Level 1 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: 1 hour
- Classes: Bard, Druid, Sorcerer, Warlock, Wizard
- Save: WIS

One Humanoid you can see within range makes a Wisdom saving throw. It does so with Advantage if you or your allies are fighting it. On a failed save, the target has the Charmed condition until the spell ends or until you or your allies damage it. The Charmed creature is Friendly to you. When the spell ends, the target knows it was Charmed by you.
`,
      "Chill Touch.md": `---
smType: spell
name: "Chill Touch"
level: 0
school: "Necromancy"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Warlock", "Wizard"]
attack: "melee spell attack"
damage: "1d10"
damage_type: "Necrotic"
---

# Chill Touch
Cantrip Necromancy

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Warlock, Wizard
- Attack: melee spell attack
- Damage: 1d10 Necrotic

Channeling the chill of the grave, make a melee spell attack against a target within reach. On a hit, the target takes 1d10 Necrotic damage, and it can't regain Hit Points until the end of your next turn.
`,
      "Chromatic Orb.md": `---
smType: spell
name: "Chromatic Orb"
level: 1
school: "Evocation"
casting_time: "Action"
range: "90 feet"
components: ["V", "S", "M"]
materials: "a diamond worth 50+ GP"
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
attack: "ranged spell attack"
---

# Chromatic Orb
Level 1 Evocation

- Casting Time: Action
- Range: 90 feet
- Components: V, S, M (a diamond worth 50+ GP)
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Attack: ranged spell attack

You hurl an orb of energy at a target within range. Choose Acid, Cold, Fire, Lightning, Poison, or Thunder for the type of orb you create, and then make a ranged spell attack against the target. On a hit, the target takes 3d8 damage of the chosen type.

If you roll the same number on two or more of the d8s, the orb leaps to a different target of your choice within 30 feet of the target. Make an attack roll against the new target, and make a new damage roll. The orb can't leap again unless you cast the spell with a level 2+ spell slot.
`,
      "Circle of Death.md": `---
smType: spell
name: "Circle of Death"
level: 6
school: "Necromancy"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "the powder of a crushed black pearl worth 500+ GP"
duration: "Instantaneous"
classes: ["Sorcerer", "Warlock", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "8d8"
damage_type: "Necrotic"
---

# Circle of Death
Level 6 Necromancy

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (the powder of a crushed black pearl worth 500+ GP)
- Duration: Instantaneous
- Classes: Sorcerer, Warlock, Wizard
- Save: CON (Half damage on success)
- Damage: 8d8 Necrotic

Negative energy ripples out in a 60-foot-radius Sphere from a point you choose within range. Each creature in that area makes a Constitution saving throw, taking 8d8 Necrotic damage on a failed save or half as much damage on a successful one.
`,
      "Clairvoyance.md": `---
smType: spell
name: "Clairvoyance"
level: 3
school: "Divination"
casting_time: "10 minutes"
range: "1 mile"
components: ["V", "S", "M"]
materials: "a focus worth 100+ GP, either a jeweled horn for hearing or a glass eye for seeing"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Bard", "Cleric", "Sorcerer", "Wizard"]
---

# Clairvoyance
Level 3 Divination

- Casting Time: 10 minutes
- Range: 1 mile
- Components: V, S, M (a focus worth 100+ GP, either a jeweled horn for hearing or a glass eye for seeing)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Bard, Cleric, Sorcerer, Wizard

You create an Invisible sensor within range in a location familiar to you (a place you have visited or seen before) or in an obvious location that is unfamiliar to you (such as behind a door, around a corner, or in a grove of trees). The intangible, invulnerable sensor remains in place for the duration.

When you cast the spell, choose seeing or hearing. You can use the chosen sense through the sensor as if you were in its space. As a Bonus Action, you can switch between seeing and hearing.

A creature that sees the sensor (such as a creature benefiting from *See Invisibility* or Truesight) sees a luminous orb about the size of your fist.
`,
      "Clone.md": `---
smType: spell
name: "Clone"
level: 8
school: "Necromancy"
casting_time: "1 hour"
range: "Touch"
components: ["V", "S", "M"]
materials: "a diamond worth 1,000+ GP, which the spell consumes, and a sealable vessel worth 2,000+ GP that is large enough to hold the creature being cloned"
duration: "Instantaneous"
classes: ["Wizard"]
---

# Clone
Level 8 Necromancy

- Casting Time: 1 hour
- Range: Touch
- Components: V, S, M (a diamond worth 1,000+ GP, which the spell consumes, and a sealable vessel worth 2,000+ GP that is large enough to hold the creature being cloned)
- Duration: Instantaneous
- Classes: Wizard

You touch a creature or at least 1 cubic inch of its flesh. An inert duplicate of that creature forms inside the vessel used in the spell's casting and finishes growing after 120 days; you choose whether the finished clone is the same age as the creature or younger. The clone remains inert and endures indefinitely while its vessel remains undisturbed.

If the original creature dies after the clone finishes forming, the creature's soul transfers to the clone if the soul is free and willing to return. The clone is physically identical to the original and has the same personality, memories, and abilities, but none of the original's equipment. The creature's original remains, if any, become inert and can't be revived, since the creature's soul is elsewhere.
`,
      "Cloudkill.md": `---
smType: spell
name: "Cloudkill"
level: 5
school: "Conjuration"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Sorcerer", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "5d8"
damage_type: "Poison"
---

# Cloudkill
Level 5 Conjuration

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Sorcerer, Wizard
- Save: CON (Half damage on success)
- Damage: 5d8 Poison

You create a 20-foot-radius Sphere of yellow-green fog centered on a point within range. The fog lasts for the duration or until strong wind (such as the one created by *Gust of Wind*) disperses it, ending the spell. Its area is Heavily Obscured.

Each creature in the Sphere makes a Constitution saving throw, taking 5d8 Poison damage on a failed save or half as much damage on a successful one. A creature must also make this save when the Sphere moves into its space and when it enters the Sphere or ends its turn there. A creature makes this save only once per turn.

The Sphere moves 10 feet away from you at the start of each of your turns.
`,
      "Color Spray.md": `---
smType: spell
name: "Color Spray"
level: 1
school: "Illusion"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a pinch of colorful sand"
duration: "Instantaneous"
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "CON"
---

# Color Spray
Level 1 Illusion

- Casting Time: Action
- Range: Self
- Components: V, S, M (a pinch of colorful sand)
- Duration: Instantaneous
- Classes: Bard, Sorcerer, Wizard
- Save: CON

You launch a dazzling array of flashing, colorful light. Each creature in a 15-foot Cone originating from you must succeed on a Constitution saving throw or have the Blinded condition until the end of your next turn.
`,
      "Command.md": `---
smType: spell
name: "Command"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Paladin"]
save_ability: "WIS"
---

# Command
Level 1 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V
- Duration: Instantaneous
- Classes: Bard, Cleric, Paladin
- Save: WIS

You speak a one-word command to a creature you can see within range. The target must succeed on a Wisdom saving throw or follow the command on its next turn. Choose the command from these options:

**Approach.** The target moves toward you by the shortest and most direct route, ending its turn if it moves within 5 feet of you.

**Drop.** The target drops whatever it is holding and then ends its turn.

**Flee.** The target spends its turn moving away from you by the fastest available means.

**Grovel.** The target has the Prone condition and then ends its turn.

**Halt.** On its turn, the target doesn't move and takes no action or Bonus Action.
`,
      "Commune with Nature.md": `---
smType: spell
name: "Commune with Nature"
level: 5
school: "Divination"
casting_time: "1 minute or Ritual"
range: "Self"
components: ["V", "S"]
duration: "Instantaneous"
ritual: true
classes: ["Druid", "Ranger"]
---

# Commune with Nature
Level 5 Divination

- Casting Time: 1 minute or Ritual
- Range: Self
- Components: V, S
- Duration: Instantaneous
- Ritual: yes
- Classes: Druid, Ranger

You commune with nature spirits and gain knowledge of the surrounding area. In the outdoors, the spell gives you knowledge of the area within 3 miles of you. In caves and other natural underground settings, the radius is limited to 300 feet. The spell

doesn't function where nature has been replaced by construction, such as in castles and settlements.

Choose three of the following facts; you learn those facts as they pertain to the spell's area:

- Locations of settlements

- Locations of portals to other planes of existence

- Location of one Challenge Rating 10+ creature (GM's choice) that is a Celestial, an Elemental, a Fey, a Fiend, or an Undead

- The most prevalent kind of plant, mineral, or Beast (you choose which to learn)

- Locations of bodies of water

For example, you could determine the location of a powerful monster in the area, the locations of bodies of water, and the locations of any towns.
`,
      "Commune.md": `---
smType: spell
name: "Commune"
level: 5
school: "Divination"
casting_time: "1 minute or Ritual"
range: "Self"
components: ["V", "S", "M"]
materials: "incense"
duration: "1 minute"
ritual: true
classes: ["Cleric"]
---

# Commune
Level 5 Divination

- Casting Time: 1 minute or Ritual
- Range: Self
- Components: V, S, M (incense)
- Duration: 1 minute
- Ritual: yes
- Classes: Cleric

You contact a deity or a divine proxy and ask up to three questions that can be answered with yes or no. You must ask your questions before the spell ends. You receive a correct answer for each question.

Divine beings aren't necessarily omniscient, so you might receive "unclear" as an answer if a question pertains to information that lies beyond the deity's knowledge. In a case where a one-word answer could be misleading or contrary to the deity's interests, the GM might offer a short phrase as an answer instead.

If you cast the spell more than once before finishing a Long Rest, there is a cumulative 25 percent chance for each casting after the first that you get no answer.
`,
      "Comprehend Languages.md": `---
smType: spell
name: "Comprehend Languages"
level: 1
school: "Divination"
casting_time: "Action or Ritual"
range: "Self"
components: ["V", "S", "M"]
materials: "a pinch of soot and salt"
duration: "1 hour"
ritual: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# Comprehend Languages
Level 1 Divination

- Casting Time: Action or Ritual
- Range: Self
- Components: V, S, M (a pinch of soot and salt)
- Duration: 1 hour
- Ritual: yes
- Classes: Bard, Sorcerer, Warlock, Wizard

For the duration, you understand the literal meaning of any language that you hear or see signed. You also understand any written language that you see, but you must be touching the surface on which the words are written. It takes about 1 minute to read one page of text. This spell doesn't decode symbols or secret messages.
`,
      "Compulsion.md": `---
smType: spell
name: "Compulsion"
level: 4
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard"]
save_ability: "WIS"
---

# Compulsion
Level 4 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard
- Save: WIS

Each creature of your choice that you can see within range must succeed on a Wisdom saving throw or have the Charmed condition until the spell ends.

For the duration, you can take a Bonus Action to designate a direction that is horizontal to you. Each Charmed target must use as much of its movement as possible to move in that direction on its next turn, taking the safest route. After moving in this way, a target repeats the save, ending the spell on itself on a success.
`,
      "Cone of Cold.md": `---
smType: spell
name: "Cone of Cold"
level: 5
school: "Evocation"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a small crystal or glass cone"
duration: "Instantaneous"
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "8d8"
damage_type: "Cold"
---

# Cone of Cold
Level 5 Evocation

- Casting Time: Action
- Range: Self
- Components: V, S, M (a small crystal or glass cone)
- Duration: Instantaneous
- Classes: Druid, Sorcerer, Wizard
- Save: CON (Half damage on success)
- Damage: 8d8 Cold

You unleash a blast of cold air. Each creature in a 60-foot Cone originating from you makes a

Constitution saving throw, taking 8d8 Cold damage on a failed save or half as much damage on a successful one. A creature killed by this spell becomes a frozen statue until it thaws.
`,
      "Confusion.md": `---
smType: spell
name: "Confusion"
level: 4
school: "Enchantment"
casting_time: "Action"
range: "90 feet"
components: ["V", "S", "M"]
materials: "three nut shells"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Druid", "Sorcerer", "Wizard"]
save_ability: "WIS"
---

# Confusion
Level 4 Enchantment

- Casting Time: Action
- Range: 90 feet
- Components: V, S, M (three nut shells)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Druid, Sorcerer, Wizard
- Save: WIS

Each creature in a 10-foot-radius Sphere centered on a point you choose within range must succeed on a Wisdom saving throw, or that target can't take Bonus Actions or Reactions and must roll 1d10 at the start of each of its turns to determine its behavior for that turn, consulting the table below.

Table: 1d10 Behavior for the Turn**

| d10  | Behavior for the Turn                                                                                                                        |

|------|----------------------------------------------------------------------------------------------------------------------------------------------|

| 1    | The target doesn't take an action, and it uses all its movement to move. Roll 1d4 for the direction: 1, north; 2, east; 3, south; or 4, west.|

| 2\u20136  | The target doesn't move or take actions.                                                                                                     |

| 7\u20138  | The target doesn't move, and it takes the Attack action to make one melee attack against a random creature within reach. If none are within reach, the target takes no action. |

| 9\u201310 | The target chooses its behavior.                                                                                                             |

At the end of each of its turns, an affected target repeats the save, ending the spell on itself on a success.
`,
      "Conjure Animals.md": `---
smType: spell
name: "Conjure Animals"
level: 3
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid", "Ranger"]
save_ability: "STR"
damage: "3d10"
damage_type: "Slashing"
---

# Conjure Animals
Level 3 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid, Ranger
- Save: STR
- Damage: 3d10 Slashing

You conjure nature spirits that appear as a Large pack of spectral, intangible animals in an unoccupied space you can see within range. The pack lasts for the duration, and you choose the spirits' animal form, such as wolves, serpents, or birds.

You have Advantage on Strength saving throws while you're within 5 feet of the pack, and when you move on your turn, you can also move the pack up to 30 feet to an unoccupied space you can see.

Whenever the pack moves within 10 feet of a creature you can see and whenever a creature you can see enters a space within 10 feet of the pack or ends its turn there, you can force that creature to make a Dexterity saving throw. On a failed save, the creature takes 3d10 Slashing damage. A creature makes this save only once per turn.
`,
      "Conjure Celestial.md": `---
smType: spell
name: "Conjure Celestial"
level: 7
school: "Conjuration"
casting_time: "Action"
range: "90 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Cleric"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "6d12"
damage_type: "Radiant"
---

# Conjure Celestial
Level 7 Conjuration

- Casting Time: Action
- Range: 90 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Cleric
- Save: DEX (Half damage on success)
- Damage: 6d12 Radiant

You conjure a spirit from the Upper Planes, which manifests as a pillar of light in a 10-foot-radius, 40-foot-high Cylinder centered on a point within range. For each creature you can see in the Cylinder, choose which of these lights shines on it:

**Healing Light.** The target regains Hit Points equal to 4d12 plus your spellcasting ability modifier.

**Searing Light.** The target makes a Dexterity saving throw, taking 6d12 Radiant damage on a failed save or half as much damage on a successful one.

Until the spell ends, Bright Light fills the Cylinder, and when you move on your turn, you can also move the Cylinder up to 30 feet.

Whenever the Cylinder moves into the space of a creature you can see and whenever a creature you can see enters the Cylinder or ends its turn there, you can bathe it in one of the lights. A creature can be affected by this spell only once per turn.
`,
      "Conjure Elemental.md": `---
smType: spell
name: "Conjure Elemental"
level: 5
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid", "Wizard"]
save_ability: "DEX"
---

# Conjure Elemental
Level 5 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid, Wizard
- Save: DEX

You conjure a Large, intangible spirit from the Elemental Planes that appears in an unoccupied space within range. Choose the spirit's element, which determines its damage type: air (Lightning), earth (Thunder), fire (Fire), or water (Cold). The spirit lasts for the duration.

Whenever a creature you can see enters the spirit's space or starts its turn within 5 feet of the spirit, you can force that creature to make a Dexterity saving throw if the spirit has no creature Restrained. On failed save, the target takes 8d8 damage of the spirit's type, and the target has the Restrained condition until the spell ends. At the start of each of its turns, the Restrained target repeats the save.

On a failed save, the target takes 4d8 damage of the spirit's type. On a successful save, the target isn't Restrained by the spirit.
`,
      "Conjure Fey.md": `---
smType: spell
name: "Conjure Fey"
level: 6
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid"]
attack: "melee spell attack"
---

# Conjure Fey
Level 6 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid
- Attack: melee spell attack

You conjure a Medium spirit from the Feywild in an unoccupied space you can see within range. The spirit lasts for the duration, and it looks like a Fey creature of your choice. When the spirit appears, you can make one melee spell attack against a creature within 5 feet of it. On a hit, the target takes Psychic damage equal to 3d12 plus your spellcasting ability modifier, and the target has the Frightened condition until the start of your next turn, with both you and the spirit as the source of the fear.

As a Bonus Action on your later turns, you can teleport the spirit to an unoccupied space you can see within 30 feet of the space it left and make the attack against a creature within 5 feet of it.
`,
      "Conjure Minor Elementals.md": `---
smType: spell
name: "Conjure Minor Elementals"
level: 4
school: "Conjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid", "Wizard"]
---

# Conjure Minor Elementals
Level 4 Conjuration

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid, Wizard

You conjure spirits from the Elemental Planes that flit around you in a 15-foot Emanation for the duration. Until the spell ends, any attack you make deals an extra 2d8 damage when you hit a creature in the Emanation. This damage is Acid, Cold, Fire, or Lightning (your choice when you make the attack).

In addition, the ground in the Emanation is Difficult Terrain for your enemies.
`,
      "Conjure Woodland Beings.md": `---
smType: spell
name: "Conjure Woodland Beings"
level: 4
school: "Conjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid", "Ranger"]
save_ability: "WIS"
save_effect: "Half damage on success"
damage: "5d8"
damage_type: "Force"
---

# Conjure Woodland Beings
Level 4 Conjuration

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid, Ranger
- Save: WIS (Half damage on success)
- Damage: 5d8 Force

You conjure nature spirits that flit around you in a 10-foot Emanation for the duration. Whenever the Emanation enters the space of a creature you can

see and whenever a creature you can see enters the Emanation or ends its turn there, you can force that creature to make a Wisdom saving throw. The creature takes 5d8 Force damage on a failed save or half as much damage on a successful one. A creature makes this save only once per turn.

In addition, you can take the Disengage action as a Bonus Action for the spell's duration.
`,
      "Contact Other Plane.md": `---
smType: spell
name: "Contact Other Plane"
level: 5
school: "Divination"
casting_time: "1 minute or Ritual"
range: "Self"
components: ["V"]
duration: "1 minute"
ritual: true
classes: ["Warlock", "Wizard"]
save_ability: "INT"
damage: "6d6"
damage_type: "Psychic"
---

# Contact Other Plane
Level 5 Divination

- Casting Time: 1 minute or Ritual
- Range: Self
- Components: V
- Duration: 1 minute
- Ritual: yes
- Classes: Warlock, Wizard
- Save: INT
- Damage: 6d6 Psychic

You mentally contact a demigod, the spirit of a longdead sage, or some other knowledgeable entity from another plane. Contacting this otherworldly intelligence can break your mind. When you cast this spell, make a DC 15 Intelligence saving throw. On a successful save, you can ask the entity up to five questions. You must ask your questions before the spell ends. The GM answers each question with one word, such as "yes," "no," "maybe," "never," "irrelevant," or "unclear" (if the entity doesn't know the answer to the question). If a one-word answer would be misleading, the GM might instead offer a short phrase as an answer.

On a failed save, you take 6d6 Psychic damage and have the Incapacitated condition until you finish a Long Rest. A *Greater Restoration* spell cast on you ends this effect.
`,
      "Contagion.md": `---
smType: spell
name: "Contagion"
level: 5
school: "Necromancy"
casting_time: "Action"
range: "Touch"
duration: "7 days"
classes: ["Cleric", "Druid"]
save_ability: "CON"
damage: "11d8"
damage_type: "Necrotic"
---

# Contagion
Level 5 Necromancy

- Casting Time: Action
- Range: Touch
- Duration: 7 days
- Classes: Cleric, Druid
- Save: CON
- Damage: 11d8 Necrotic

Your touch inflicts a magical contagion. The target must succeed on a Constitution saving throw or take 11d8 Necrotic damage and have the Poisoned condition. Also, choose one ability when you cast the spell. While Poisoned, the target has Disadvantage on saving throws made with the chosen ability.

The target must repeat the saving throw at the end of each of its turns until it gets three successes or failures. If the target succeeds on three of these saves, the spell ends on the target. If the target fails three of the saves, the spell lasts for 7 days on it.

Whenever the Poisoned target receives an effect that would end the Poisoned condition, the target must succeed on a Constitution saving throw, or the Poisoned condition doesn't end on it.
`,
      "Contingency.md": `---
smType: spell
name: "Contingency"
level: 6
school: "Abjuration"
casting_time: "10 minutes"
range: "Self"
components: ["V", "S", "M"]
materials: "a gem-encrusted statuette of yourself worth 1,500+ GP"
duration: "10 days"
classes: ["Wizard"]
---

# Contingency
Level 6 Abjuration

- Casting Time: 10 minutes
- Range: Self
- Components: V, S, M (a gem-encrusted statuette of yourself worth 1,500+ GP)
- Duration: 10 days
- Classes: Wizard

Choose a spell of level 5 or lower that you can cast, that has a casting time of an action, and that can target you. You cast that spell\u2014called the contingent spell\u2014as part of casting *Contingency*, expending spell slots for both, but the contingent spell doesn't come into effect. Instead, it takes effect when a certain trigger occurs. You describe that trigger when you cast the two spells. For example, a *Contingency* cast with *Water Breathing* might stipulate that *Water Breathing* comes into effect when you are engulfed in water or a similar liquid.

The contingent spell takes effect immediately after the trigger occurs for the first time, whether or not you want it to, and then *Contingency* ends.

The contingent spell takes effect only on you, even if it can normally target others. You can use only one *Contingency* spell at a time. If you cast this spell again, the effect of another *Contingency* spell on you ends. Also, *Contingency* ends on you if its material component is ever not on your person.
`,
      "Continual Flame.md": `---
smType: spell
name: "Continual Flame"
level: 2
school: "Evocation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "ruby dust worth 50+ GP, which the spell consumes"
duration: "Until dispelled"
classes: ["Cleric", "Druid", "Wizard"]
---

# Continual Flame
Level 2 Evocation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (ruby dust worth 50+ GP, which the spell consumes)
- Duration: Until dispelled
- Classes: Cleric, Druid, Wizard

A flame springs from an object that you touch. The effect casts Bright Light in a 20-foot radius and Dim Light for an additional 20 feet. It looks like a regular flame, but it creates no heat and consumes no fuel. The flame can be covered or hidden but not smothered or quenched.
`,
      "Control Water.md": `---
smType: spell
name: "Control Water"
level: 4
school: "Transmutation"
casting_time: "Action"
range: "300 feet"
components: ["V", "S", "M"]
materials: "a mixture of water and dust"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Cleric", "Druid", "Wizard"]
save_ability: "STR"
save_effect: "Half damage on success"
damage: "2d8"
damage_type: "Bludgeoning"
---

# Control Water
Level 4 Transmutation

- Casting Time: Action
- Range: 300 feet
- Components: V, S, M (a mixture of water and dust)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Cleric, Druid, Wizard
- Save: STR (Half damage on success)
- Damage: 2d8 Bludgeoning

Until the spell ends, you control any water inside an area you choose that is a Cube up to 100 feet on a side, using one of the following effects. As a Magic action on your later turns, you can repeat the same effect or choose a different one.

**_Flood._** You cause the water level of all standing water in the area to rise by as much as 20 feet. If you choose an area in a large body of water, you instead create a 20-foot tall wave that travels from one side of the area to the other and then crashes. Any Huge or smaller vehicles in the wave's path are carried with it to the other side. Any Huge or smaller vehicles struck by the wave have a 25 percent chance of capsizing.

The water level remains elevated until the spell ends or you choose a different effect. If this effect produced a wave, the wave repeats on the start of your next turn while the flood effect lasts.

**_Part Water._** You part water in the area and create a trench. The trench extends across the spell's area, and the separated water forms a wall to either side. The trench remains until the spell ends or you choose a different effect. The water then slowly fills in the trench over the course of the next round until the normal water level is restored.

**_Redirect Flow._** You cause flowing water in the area to move in a direction you choose, even if the water has to flow over obstacles, up walls, or in other unlikely directions. The water in the area moves as you direct it, but once it moves beyond the spell's area, it resumes its flow based on the terrain. The water continues to move in the direction you chose until the spell ends or you choose a different effect.

**_Whirlpool._** You cause a whirlpool to form in the center of the area, which must be at least 50 feet square and 25 feet deep. The whirlpool lasts until you choose a different effect or the spell ends. The whirlpool is 5 feet wide at the base, up to 50 feet wide at the top, and 25 feet tall. Any creature in the water and within 25 feet of the whirlpool is pulled 10 feet toward it. When a creature enters the whirlpool for the first time on a turn or ends its turn there, it makes a Strength saving throw. On a failed save, the creature takes 2d8 Bludgeoning damage. On a successful save, the creature takes half as much damage. A creature can swim away from the whirlpool only if it first takes an action to pull away and succeeds on a Strength (Athletics) check against your spell save DC.
`,
      "Control Weather.md": `---
smType: spell
name: "Control Weather"
level: 8
school: "Transmutation"
casting_time: "10 minutes"
range: "Self"
components: ["V", "S", "M"]
materials: "burning incense"
duration: "Concentration, up to 8 hours"
concentration: true
classes: ["Cleric", "Druid", "Wizard"]
---

# Control Weather
Level 8 Transmutation

- Casting Time: 10 minutes
- Range: Self
- Components: V, S, M (burning incense)
- Duration: Concentration, up to 8 hours
- Concentration: yes
- Classes: Cleric, Druid, Wizard

You take control of the weather within 5 miles of you for the duration. You must be outdoors to cast this spell, and it ends early if you go indoors.

When you cast the spell, you change the current weather conditions, which are determined by the GM. You can change precipitation, temperature, and wind. It takes 1d4 \xD7 10 minutes for the new

conditions to take effect. Once they do so, you can change the conditions again. When the spell ends, the weather gradually returns to normal.

When you change the weather conditions, find a current condition on the following tables and change its stage by one, up or down. When changing the wind, you can change its direction.

Table: Precipitation

| Stage | Condition                                  |

|-------|--------------------------------------------|

| 1     | Clear                                      |

| 2     | Light clouds                               |

| 3     | Overcast or ground fog                     |

| 4     | Rain, hail, or snow                        |

| 5     | Torrential rain, driving hail, or blizzard |

Table: Temperature

| Stage       | Condition |

|-------------|-----------|

| 1           | Heat wave |

| 2           | Hot       |

| 3           | Warm      |

| 4           | Cool      |

| 5           | Cold      |

| 6           | Freezing  |

Table: Wind

| Stage | Condition     |

|-------|---------------|

| 1     | Calm          |

| 2     | Moderate wind |

| 3     | Strong wind   |

| 4     | Gale          |

| 5     | Storm         |
`,
      "Counterspell.md": `---
smType: spell
name: "Counterspell"
level: 3
school: "Abjuration"
casting_time: "Reaction, which you take when you see a creature within 60 feet of yourself casting a spell with Verbal, Somatic, or Material components"
range: "60 feet"
components: ["S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Warlock", "Wizard"]
save_ability: "CON"
---

# Counterspell
Level 3 Abjuration

- Casting Time: Reaction, which you take when you see a creature within 60 feet of yourself casting a spell with Verbal, Somatic, or Material components
- Range: 60 feet
- Components: S
- Duration: Instantaneous
- Classes: Sorcerer, Warlock, Wizard
- Save: CON

You attempt to interrupt a creature in the process of casting a spell. The creature makes a Constitution saving throw. On a failed save, the spell dissipates with no effect, and the action, Bonus Action, or Reaction used to cast it is wasted. If that spell was cast with a spell slot, the slot isn't expended.
`,
      "Create Food and Water.md": `---
smType: spell
name: "Create Food and Water"
level: 3
school: "Conjuration"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric", "Paladin"]
---

# Create Food and Water
Level 3 Conjuration

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric, Paladin

You create 45 pounds of food and 30 gallons of fresh water on the ground or in containers within range\u2014both useful in fending off the hazards of malnutrition and dehydration. The food is bland but nourishing and looks like a food of your choice, and the water is clean. The food spoils after 24 hours if uneaten.
`,
      "Create Undead.md": `---
smType: spell
name: "Create Undead"
level: 6
school: "Necromancy"
casting_time: "1 minute"
range: "10 feet"
components: ["V", "S", "M"]
materials: "one 150+ GP black onyx stone for each corpse"
duration: "Instantaneous"
classes: ["Cleric", "Warlock", "Wizard"]
---

# Create Undead
Level 6 Necromancy

- Casting Time: 1 minute
- Range: 10 feet
- Components: V, S, M (one 150+ GP black onyx stone for each corpse)
- Duration: Instantaneous
- Classes: Cleric, Warlock, Wizard

You can cast this spell only at night. Choose up to three corpses of Medium or Small Humanoids within range. Each one becomes a **Ghoul** under your control (see "Monsters" for its stat block).

As a Bonus Action on each of your turns, you can mentally command any creature you animated with this spell if the creature is within 120 feet of you (if you control multiple creatures, you can command any of them at the same time, issuing the same command to them). You decide what action the creature will take and where it will move on its next turn, or you can issue a general command, such as to guard a particular place. If you issue no commands, the creature takes the Dodge action and moves only to avoid harm. Once given an order, the creature continues to follow the order until its task is complete.

The creature is under your control for 24 hours, after which it stops obeying any command you've given it. To maintain control of the creature for another 24 hours, you must cast this spell on the creature before the current 24-hour period ends. This use of the spell reasserts your control over up to three creatures you have animated with this spell rather than animating new ones.
`,
      "Create or Destroy Water.md": `---
smType: spell
name: "Create or Destroy Water"
level: 1
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a mix of water and sand"
duration: "Instantaneous"
classes: ["Cleric", "Druid"]
---

# Create or Destroy Water
Level 1 Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a mix of water and sand)
- Duration: Instantaneous
- Classes: Cleric, Druid

You do one of the following:

**Create Water.** You create up to 10 gallons of clean water within range in an open container. Alternatively, the water falls as rain in a 30-foot Cube within range, extinguishing exposed flames there.

**Destroy Water.** You destroy up to 10 gallons of water in an open container within range. Alternatively, you destroy fog in a 30-foot Cube within range.
`,
      "Creation.md": `---
smType: spell
name: "Creation"
level: 5
school: "Illusion"
casting_time: "1 minute"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a paintbrush"
duration: "Special"
classes: ["Sorcerer", "Wizard"]
---

# Creation
Level 5 Illusion

- Casting Time: 1 minute
- Range: 30 feet
- Components: V, S, M (a paintbrush)
- Duration: Special
- Classes: Sorcerer, Wizard

You pull wisps of shadow material from the Shadowfell to create an object within range. It is either an object of vegetable matter (soft goods, rope, wood, and the like) or mineral matter (stone, crystal, metal, and the like). The object must be no larger than a 5-foot Cube, and the object must be of a form and material that you have seen.

The spell's duration depends on the object's material, as shown in the Materials table. If the object is composed of multiple materials, use the shortest duration. Using any object created by this spell as another spell's Material component causes the other spell to fail.

Table: Materials

| Material              | Duration   |

|-----------------------|------------|

| Vegetable matter      | 24 hours   |

| Stone or crystal      | 12 hours   |

| Precious metals       | 1 hour     |

| Gems                  | 10 minutes |

| Adamantine or mithral | 1 minute   |
`,
      "Cure Wounds.md": `---
smType: spell
name: "Cure Wounds"
level: 1
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger"]
---

# Cure Wounds
Level 1 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid, Paladin, Ranger

A creature you touch regains a number of Hit Points equal to 2d8 plus your spellcasting ability modifier.

## At Higher Levels

### D Spells
`,
      "Dancing Lights.md": `---
smType: spell
name: "Dancing Lights"
level: 0
school: "Illusion"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a bit of phosphorus"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
---

# Dancing Lights
Cantrip Illusion

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a bit of phosphorus)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard

You create up to four torch-size lights within range, making them appear as torches, lanterns, or glowing orbs that hover for the duration. Alternatively, you combine the four lights into one glowing Medium form that is vaguely humanlike. Whichever form you choose, each light sheds Dim Light in a 10 foot radius.

As a Bonus Action, you can move the lights up to 60 feet to a space within range. A light must be within 20 feet of another light created by this spell, and a light vanishes if it exceeds the spell's range.
`,
      "Darkness.md": `---
smType: spell
name: "Darkness"
level: 2
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V", "M"]
materials: "bat fur and a piece of coal"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Sorcerer", "Warlock", "Wizard"]
---

# Darkness
Level 2 Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V, M (bat fur and a piece of coal)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Sorcerer, Warlock, Wizard

For the duration, magical Darkness spreads from a point within range and fills a 15-foot-radius Sphere. Darkvision can't see through it, and nonmagical light can't illuminate it.

Alternatively, you cast the spell on an object that isn't being worn or carried, causing the Darkness to fill a 15-foot Emanation originating from that object. Covering that object with something opaque, such as a bowl or helm, blocks the Darkness.

If any of this spell's area overlaps with an area of Bright Light or Dim Light created by a spell of level 2 or lower, that other spell is dispelled.
`,
      "Darkvision.md": `---
smType: spell
name: "Darkvision"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a dried carrot"
duration: "8 hours"
classes: ["Druid", "Ranger", "Sorcerer", "Wizard"]
---

# Darkvision
Level 2 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a dried carrot)
- Duration: 8 hours
- Classes: Druid, Ranger, Sorcerer, Wizard

For the duration, a willing creature you touch has Darkvision with a range of 150 feet.
`,
      "Daylight.md": `---
smType: spell
name: "Daylight"
level: 3
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "1 hour"
classes: ["Cleric", "Druid", "Paladin", "Ranger", "Sorcerer"]
---

# Daylight
Level 3 Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: 1 hour
- Classes: Cleric, Druid, Paladin, Ranger, Sorcerer

For the duration, sunlight spreads from a point within range and fills a 60-foot-radius Sphere. The sunlight's area is Bright Light and sheds Dim Light for an additional 60 feet.

Alternatively, you cast the spell on an object that isn't being worn or carried, causing the sunlight to fill a 60-foot Emanation originating from that object. Covering that object with something opaque, such as a bowl or helm, blocks the sunlight.

If any of this spell's area overlaps with an area of Darkness created by a spell of level 3 or lower, that other spell is dispelled.
`,
      "Death Ward.md": `---
smType: spell
name: "Death Ward"
level: 4
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "8 hours"
classes: ["Cleric", "Paladin"]
---

# Death Ward
Level 4 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: 8 hours
- Classes: Cleric, Paladin

You touch a creature and grant it a measure of protection from death. The first time the target would drop to 0 Hit Points before the spell ends, the target instead drops to 1 Hit Point, and the spell ends.

If the spell is still in effect when the target is subjected to an effect that would kill it instantly without dealing damage, that effect is negated against the target, and the spell ends.
`,
      "Delayed Blast Fireball.md": `---
smType: spell
name: "Delayed Blast Fireball"
level: 7
school: "Evocation"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "a ball of bat guano and sulfur"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
---

# Delayed Blast Fireball
Level 7 Evocation

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (a ball of bat guano and sulfur)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Sorcerer, Wizard
- Save: DEX (Half damage on success)

A beam of yellow light flashes from you, then condenses at a chosen point within range as a glowing bead for the duration. When the spell ends, the bead explodes, and each creature in a 20-foot-radius Sphere centered on that point makes a Dexterity saving throw. A creature takes Fire damage equal to the total accumulated damage on a failed save or half as much damage on a successful one.

The spell's base damage is 12d6, and the damage increases by 1d6 whenever your turn ends and the spell hasn't ended.

If a creature touches the glowing bead before the spell ends, that creature makes a Dexterity saving throw. On a failed save, the spell ends, causing the bead to explode. On a successful save, the creature can throw the bead up to 40 feet. If the thrown bead enters a creature's space or collides with a solid object, the spell ends, and the bead explodes.

When the bead explodes, flammable objects in the explosion that aren't being worn or carried start burning.
`,
      "Demiplane.md": `---
smType: spell
name: "Demiplane"
level: 8
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["S"]
duration: "1 hour"
classes: ["Sorcerer", "Warlock", "Wizard"]
---

# Demiplane
Level 8 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: S
- Duration: 1 hour
- Classes: Sorcerer, Warlock, Wizard

You create a shadowy Medium door on a flat solid surface that you can see within range. This door can be opened and closed, and it leads to a demiplane that is an empty room 30 feet in each dimension, made of wood or stone (your choice).

When the spell ends, the door vanishes, and any objects inside the demiplane remain there. Any creatures inside also remain unless they opt to be shunted through the door as it vanishes, landing with the Prone condition in the unoccupied spaces closest to the door's former space.

Each time you cast this spell, you can create a new demiplane or connect the shadowy door to a demiplane you created with a previous casting of this spell. Additionally, if you know the nature and contents of a demiplane created by a casting of this spell by another creature, you can connect the shadowy door to that demiplane instead.
`,
      "Detect Evil and Good.md": `---
smType: spell
name: "Detect Evil and Good"
level: 1
school: "Divination"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Cleric", "Paladin"]
---

# Detect Evil and Good
Level 1 Divination

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Cleric, Paladin

For the duration, you sense the location of any Aberration, Celestial, Elemental, Fey, Fiend, or Undead within 30 feet of yourself. You also sense whether the *Hallow* spell is active there and, if so, where.

The spell is blocked by 1 foot of stone, dirt, or wood; 1 inch of metal; or a thin sheet of lead.
`,
      "Detect Magic.md": `---
smType: spell
name: "Detect Magic"
level: 1
school: "Divination"
casting_time: "Action or Ritual"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
ritual: true
classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger", "Sorcerer", "Warlock", "Wizard"]
---

# Detect Magic
Level 1 Divination

- Casting Time: Action or Ritual
- Range: Self
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Ritual: yes
- Classes: Bard, Cleric, Druid, Paladin, Ranger, Sorcerer, Warlock, Wizard

For the duration, you sense the presence of magical effects within 30 feet of yourself. If you sense such effects, you can take the Magic action to see a faint aura around any visible creature or object in the area that bears the magic, and if an effect was created by a spell, you learn the spell's school of magic.

The spell is blocked by 1 foot of stone, dirt, or wood; 1 inch of metal; or a thin sheet of lead.
`,
      "Detect Poison and Disease.md": `---
smType: spell
name: "Detect Poison and Disease"
level: 1
school: "Divination"
casting_time: "Action or Ritual"
range: "Self"
components: ["V", "S", "M"]
materials: "a yew leaf"
duration: "Concentration, up to 10 minutes"
concentration: true
ritual: true
classes: ["Cleric", "Druid", "Paladin", "Ranger"]
---

# Detect Poison and Disease
Level 1 Divination

- Casting Time: Action or Ritual
- Range: Self
- Components: V, S, M (a yew leaf)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Ritual: yes
- Classes: Cleric, Druid, Paladin, Ranger

For the duration, you sense the location of poisons, poisonous or venomous creatures, and magical contagions within 30 feet of yourself. You sense the kind of poison, creature, or contagion in each case.

The spell is blocked by 1 foot of stone, dirt, or wood; 1 inch of metal; or a thin sheet of lead.
`,
      "Detect Thoughts.md": `---
smType: spell
name: "Detect Thoughts"
level: 2
school: "Divination"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "1 Copper Piece"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "WIS"
---

# Detect Thoughts
Level 2 Divination

- Casting Time: Action
- Range: Self
- Components: V, S, M (1 Copper Piece)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard
- Save: WIS

You activate one of the effects below. Until the spell ends, you can activate either effect as a Magic action on your later turns.

**_Sense Thoughts._** You sense the presence of thoughts within 30 feet of yourself that belong to creatures that know languages or are telepathic. You don't read the thoughts, but you know that a thinking creature is present.

The spell is blocked by 1 foot of stone, dirt, or wood; 1 inch of metal; or a thin sheet of lead.

**_Read Thoughts._** Target one creature you can see within 30 feet of yourself or one creature within 30 feet of yourself that you detected with the Sense Thoughts option. You learn what is most on the target's mind right now. If the target doesn't know any languages and isn't telepathic, you learn nothing.

As a Magic action on your next turn, you can try to probe deeper into the target's mind. If you probe deeper, the target makes a Wisdom saving throw. On a failed save, you discern the target's reasoning, emotions, and something that looms large in its mind (such as a worry, love, or hate). On a successful save, the spell ends. Either way, the target knows that you are probing into its mind, and until you shift your attention away from the target's mind, the target can take an action on its turn to make an Intelligence (Arcana) check against your spell save DC, ending the spell on a success.
`,
      "Dimension Door.md": `---
smType: spell
name: "Dimension Door"
level: 4
school: "Conjuration"
casting_time: "Action"
range: "500 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
damage: "4d6"
damage_type: "Force"
---

# Dimension Door
Level 4 Conjuration

- Casting Time: Action
- Range: 500 feet
- Components: V
- Duration: Instantaneous
- Classes: Bard, Sorcerer, Warlock, Wizard
- Damage: 4d6 Force

You teleport to a location within range. You arrive at exactly the spot desired. It can be a place you can see, one you can visualize, or one you can describe by stating distance and direction, such as "200 feet straight downward" or "300 feet upward to the northwest at a 45-degree angle."

You can also teleport one willing creature. The creature must be within 5 feet of you when you teleport, and it teleports to a space within 5 feet of your destination space.

If you, the other creature, or both would arrive in a space occupied by a creature or completely filled by one or more objects, you and any creature traveling with you each take 4d6 Force damage, and the teleportation fails.
`,
      "Disguise Self.md": `---
smType: spell
name: "Disguise Self"
level: 1
school: "Illusion"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "1 hour"
classes: ["Bard", "Sorcerer", "Wizard"]
---

# Disguise Self
Level 1 Illusion

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: 1 hour
- Classes: Bard, Sorcerer, Wizard

You make yourself\u2014including your clothing, armor, weapons, and other belongings on your person look different until the spell ends. You can seem 1 foot shorter or taller and can appear heavier or lighter. You must adopt a form that has the same basic arrangement of limbs as you have. Otherwise, the extent of the illusion is up to you.

The changes wrought by this spell fail to hold up to physical inspection. For example, if you use this spell to add a hat to your outfit, objects pass through the hat, and anyone who touches it would feel nothing.

To discern that you are disguised, a creature must take the Study action to inspect your appearance and succeed on an Intelligence (Investigation) check against your spell save DC.
`,
      "Disintegrate.md": `---
smType: spell
name: "Disintegrate"
level: 6
school: "Transmutation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a lodestone and dust"
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
damage: "10d6 + 40"
damage_type: "Force"
---

# Disintegrate
Level 6 Transmutation

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a lodestone and dust)
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Save: DEX
- Damage: 10d6 + 40 Force

You launch a green ray at a target you can see within range. The target can be a creature, a nonmagical object, or a creation of magical force, such as the wall created by *Wall of Force.*

A creature targeted by this spell makes a Dexterity saving throw. On a failed save, the target takes 10d6 + 40 Force damage. If this damage reduces it to 0 Hit Points, it and everything nonmagical it is wearing and carrying are disintegrated into gray dust. The target can be revived only by a *True Resurrection* or a *Wish* spell.

This spell automatically disintegrates a Large or smaller nonmagical object or a creation of magical force. If such a target is Huge or larger, this spell disintegrates a 10-foot-Cube portion of it.
`,
      "Dispel Evil and Good.md": `---
smType: spell
name: "Dispel Evil and Good"
level: 5
school: "Abjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "powdered silver and iron"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric", "Paladin"]
save_ability: "CHA"
---

# Dispel Evil and Good
Level 5 Abjuration

- Casting Time: Action
- Range: Self
- Components: V, S, M (powdered silver and iron)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric, Paladin
- Save: CHA

For the duration, Celestials, Elementals, Fey, Fiends, and Undead have Disadvantage on attack rolls against you. You can end the spell early by using either of the following special functions.

*Break Enchantment.* As a Magic action, you touch a creature that is possessed by or has the Charmed or Frightened condition from one or more creatures of the types above. The target is no longer possessed, Charmed, or Frightened by such creatures.

*Dismissal.* As a Magic action, you target one creature you can see within 5 feet of you that has one of the creature types above. The target must succeed on a Charisma saving throw or be sent back to its home plane if it isn't there already. If they aren't on their home plane, Undead are sent to the Shadowfell, and Fey are sent to the Feywild.
`,
      "Dispel Magic.md": `---
smType: spell
name: "Dispel Magic"
level: 3
school: "Abjuration"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger", "Sorcerer", "Warlock", "Wizard"]
---

# Dispel Magic
Level 3 Abjuration

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid, Paladin, Ranger, Sorcerer, Warlock, Wizard

Choose one creature, object, or magical effect within range. Any ongoing spell of level 3 or lower on the target ends. For each ongoing spell of level 4 or higher on the target, make an ability check using your spellcasting ability (DC 10 plus that spell's level). On a successful check, the spell ends.
`,
      "Dissonant Whispers.md": `---
smType: spell
name: "Dissonant Whispers"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Bard"]
save_ability: "WIS"
save_effect: "Half damage on success"
damage: "3d6"
damage_type: "Psychic"
---

# Dissonant Whispers
Level 1 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V
- Duration: Instantaneous
- Classes: Bard
- Save: WIS (Half damage on success)
- Damage: 3d6 Psychic

One creature of your choice that you can see within range hears a discordant melody in its mind. The target makes a Wisdom saving throw. On a failed save, it takes 3d6 Psychic damage and must immediately use its Reaction, if available, to move as far away from you as it can, using the safest route. On a successful save, the target takes half as much damage only.

**Using a Higher-Level Spell Slot._** The damage increases by 1d6 for each spell slot level above 1.
`,
      "Divination.md": `---
smType: spell
name: "Divination"
level: 4
school: "Divination"
casting_time: "Action or Ritual"
range: "Self"
components: ["V", "S", "M"]
materials: "incense worth 25+ GP, which the spell consumes"
duration: "Instantaneous"
ritual: true
classes: ["Cleric", "Druid", "Wizard"]
---

# Divination
Level 4 Divination

- Casting Time: Action or Ritual
- Range: Self
- Components: V, S, M (incense worth 25+ GP, which the spell consumes)
- Duration: Instantaneous
- Ritual: yes
- Classes: Cleric, Druid, Wizard

This spell puts you in contact with a god or a god's servants. You ask one question about a specific goal, event, or activity to occur within 7 days. The GM offers a truthful reply, which might be a short phrase or cryptic rhyme. The spell doesn't account for circumstances that might change the answer, such as the casting of other spells.

If you cast the spell more than once before finishing a Long Rest, there is a cumulative 25 percent chance for each casting after the first that you get no answer.
`,
      "Divine Favor.md": `---
smType: spell
name: "Divine Favor"
level: 1
school: "Transmutation"
casting_time: "Bonus Action"
range: "Self"
components: ["V", "S"]
duration: "1 minute"
classes: ["Paladin"]
damage: "1d4"
damage_type: "Radiant"
---

# Divine Favor
Level 1 Transmutation

- Casting Time: Bonus Action
- Range: Self
- Components: V, S
- Duration: 1 minute
- Classes: Paladin
- Damage: 1d4 Radiant

Until the spell ends, your attacks with weapons deal an extra 1d4 Radiant damage on a hit.
`,
      "Divine Smite.md": `---
smType: spell
name: "Divine Smite"
level: 1
school: "Evocation"
casting_time: "Bonus Action, which you take immediately after hitting a target with a Melee weapon or an Unarmed Strike"
range: "Self"
duration: "Instantaneous"
classes: ["Paladin"]
damage: "2d8"
damage_type: "Radiant"
---

# Divine Smite
Level 1 Evocation

- Casting Time: Bonus Action, which you take immediately after hitting a target with a Melee weapon or an Unarmed Strike
- Range: Self
- Duration: Instantaneous
- Classes: Paladin
- Damage: 2d8 Radiant

The target takes an extra 2d8 Radiant damage from the attack. The damage increases by 1d8 if the target is a Fiend or an Undead.
`,
      "Divine Word.md": `---
smType: spell
name: "Divine Word"
level: 7
school: "Evocation"
casting_time: "Bonus Action"
range: "30 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Cleric"]
save_ability: "CHA"
---

# Divine Word
Level 7 Evocation

- Casting Time: Bonus Action
- Range: 30 feet
- Components: V
- Duration: Instantaneous
- Classes: Cleric
- Save: CHA

You utter a word imbued with power from the Upper Planes. Each creature of your choice in range makes a Charisma saving throw. On a failed save, a target that has 50 Hit Points or fewer suffers an effect based on its current Hit Points, as shown in the Divine Word Effects table. Regardless of its Hit Points, a Celestial, an Elemental, a Fey, or a Fiend target that fails its save is forced back to its plane of origin (if it isn't there already) and can't return to the current plane for 24 hours by any means short of a *Wish* spell.

Table: Divine Word Effects

| Hit Points | Effect                                                                   |

|------------|--------------------------------------------------------------------------|

| 0\u201320       | The target dies.                                                         |

| 21\u201330      | The target has the Blinded, Deafened, and Stunned conditions for 1 hour. |

| 31\u201340      | The target has the Blinded and Deafened conditions for 10 minutes.       |

| 41\u201350      | The target has the Deafened condition for 1 minute.                      |
`,
      "Dominate Beast.md": `---
smType: spell
name: "Dominate Beast"
level: 4
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Ranger", "Sorcerer"]
save_ability: "WIS"
---

# Dominate Beast
Level 4 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Ranger, Sorcerer
- Save: WIS

One Beast you can see within range must succeed on a Wisdom saving throw or have the Charmed condition for the duration. The target has Advantage on the save if you or your allies are fighting it. Whenever the target takes damage, it repeats the save, ending the spell on itself on a success.

You have a telepathic link with the Charmed target while the two of you are on the same plane of existence. On your turn, you can use this link to issue commands to the target (no action required), such as "Attack that creature," "Move over there," or "Fetch that object." The target does its best to obey on its turn. If it completes an order and doesn't receive further direction from you, it acts and moves as it likes, focusing on protecting itself.

You can command the target to take a Reaction but must take your own Reaction to do so.
`,
      "Dominate Monster.md": `---
smType: spell
name: "Dominate Monster"
level: 8
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Dominate Monster
Level 8 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Bard, Sorcerer, Warlock, Wizard
- Save: WIS

One creature you can see within range must succeed on a Wisdom saving throw or have the Charmed condition for the duration. The target has Advantage on the save if you or your allies are fighting it. Whenever the target takes damage, it repeats the save, ending the spell on itself on a success.

You have a telepathic link with the Charmed target while the two of you are on the same plane of existence. On your turn, you can use this link to issue commands to the target (no action required), such as "Attack that creature," "Move over there," or "Fetch that object." The target does its best to obey on its turn. If it completes an order and doesn't receive further direction from you, it acts and moves as it likes, focusing on protecting itself.

You can command the target to take a Reaction but must take your own Reaction to do so.
`,
      "Dominate Person.md": `---
smType: spell
name: "Dominate Person"
level: 5
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "WIS"
---

# Dominate Person
Level 5 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard
- Save: WIS

One Humanoid you can see within range must succeed on a Wisdom saving throw or have the Charmed condition for the duration. The target has Advantage on the save if you or your allies are fighting it. Whenever the target takes damage, it repeats the save, ending the spell on itself on a success.

You have a telepathic link with the Charmed target while the two of you are on the same plane of existence. On your turn, you can use this link to issue commands to the target (no action required), such as "Attack that creature," "Move over there," or "Fetch that object." The target does its best to obey on its turn. If it completes an order and doesn't receive further direction from you, it acts and moves as it likes, focusing on protecting itself.

You can command the target to take a Reaction but must take your own Reaction to do so.
`,
      "Dragon's Breath.md": `---
smType: spell
name: "Dragon's Breath"
level: 2
school: "Transmutation"
casting_time: "Bonus Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a hot pepper"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
---

# Dragon's Breath
Level 2 Transmutation

- Casting Time: Bonus Action
- Range: Touch
- Components: V, S, M (a hot pepper)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Sorcerer, Wizard
- Save: DEX (Half damage on success)

You touch one willing creature, and choose Acid, Cold, Fire, Lightning, or Poison. Until the spell ends, the target can take a Magic action to exhale a 15-foot Cone. Each creature in that area makes a Dexterity saving throw, taking 3d6 damage of the chosen type on a failed save or half as much damage on a successful one.
`,
      "Dream.md": `---
smType: spell
name: "Dream"
level: 5
school: "Illusion"
casting_time: "1 minute"
range: "Special"
components: ["V", "S", "M"]
materials: "a handful of sand"
duration: "8 hours"
classes: ["Bard", "Warlock", "Wizard"]
save_ability: "WIS"
damage: "3d6"
damage_type: "Psychic"
---

# Dream
Level 5 Illusion

- Casting Time: 1 minute
- Range: Special
- Components: V, S, M (a handful of sand)
- Duration: 8 hours
- Classes: Bard, Warlock, Wizard
- Save: WIS
- Damage: 3d6 Psychic

You target a creature you know on the same plane of existence. You or a willing creature you touch enters a trance state to act as a dream messenger. While in the trance, the messenger is Incapacitated and has a Speed of 0.

If the target is asleep, the messenger appears in the target's dreams and can converse with the target as long as it remains asleep, through the spell's duration. The messenger can also shape the dream's environment, creating landscapes, objects, and other images. The messenger can emerge from the trance at any time, ending the spell. The target recalls the dream perfectly upon waking.

If the target is awake when you cast the spell, the messenger knows it and can either end the trance (and the spell) or wait for the target to sleep, at which point the messenger enters its dreams.

You can make the messenger terrifying to the target. If you do so, the messenger can deliver a message of no more than ten words, and then the target makes a Wisdom saving throw. On a failed save, the target gains no benefit from its rest, and it takes 3d6 Psychic damage when it wakes up.
`,
      "Druidcraft.md": `---
smType: spell
name: "Druidcraft"
level: 0
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Druid"]
---

# Druidcraft
Cantrip Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Druid

Whispering to the spirits of nature, you create one of the following effects within range.

**_Weather Sensor._** You create a Tiny, harmless sensory effect that predicts what the weather will be at your location for the next 24 hours. The effect might manifest as a golden orb for clear skies, a cloud for rain, falling snowflakes for snow, and so on. This effect persists for 1 round.

**_Bloom._** You instantly make a flower blossom, a seed pod open, or a leaf bud bloom.

**_Sensory Effect._** You create a harmless sensory effect, such as falling leaves, spectral dancing fairies, a gentle breeze, the sound of an animal, or the faint odor of skunk. The effect must fit in a 5-foot Cube.

**_Fire Play._** You light or snuff out a candle, a torch, or a campfire.

### E Spells
`,
      "Earthquake.md": `---
smType: spell
name: "Earthquake"
level: 8
school: "Transmutation"
casting_time: "Action"
range: "500 feet"
components: ["V", "S", "M"]
materials: "a fractured rock"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric", "Druid", "Sorcerer"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "12d6"
damage_type: "Bludgeoning"
---

# Earthquake
Level 8 Transmutation

- Casting Time: Action
- Range: 500 feet
- Components: V, S, M (a fractured rock)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric, Druid, Sorcerer
- Save: DEX (Half damage on success)
- Damage: 12d6 Bludgeoning

Choose a point on the ground that you can see within range. For the duration, an intense tremor rips through the ground in a 100-foot-radius circle centered on that point. The ground there is Difficult Terrain.

When you cast this spell and at the end of each of your turns for the duration, each creature on the ground in the area makes a Dexterity saving throw. On a failed save, a creature has the Prone condition, and its Concentration is broken.

You can also cause the effects below.

**_Fissures._** A total of 1d6 fissures open in the spell's area at the end of the turn you cast it. You choose the fissures' locations, which can't be under structures. Each fissure is 1d10 \xD7 10 feet deep and 10 feet wide, and it extends from one edge of the spell's area to another edge. A creature in the same space as a fissure must succeed on a Dexterity saving throw or fall in. A creature that successfully saves moves with the fissure's edge as it opens.

**Structures._** The tremor deals 50 Bludgeoning damage to any structure in contact with the ground in the area when you cast the spell and at the end of each of your turns until the spell ends. If a structure drops to 0 Hit Points, it collapses.

A creature within a distance from a collapsing structure equal to half the structure's height makes a Dexterity saving throw. On a failed save, the creature takes 12d6 Bludgeoning damage, has the Prone condition, and is buried in the rubble, requiring a DC 20 Strength (Athletics) check as an action to escape. On a successful save, the creature takes half as much damage only.
`,
      "Eldritch Blast.md": `---
smType: spell
name: "Eldritch Blast"
level: 0
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Warlock"]
attack: "ranged spell attack"
damage: "1d10"
damage_type: "Force"
---

# Eldritch Blast
Cantrip Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Warlock
- Attack: ranged spell attack
- Damage: 1d10 Force

You hurl a beam of crackling energy. Make a ranged spell attack against one creature or object in range. On a hit, the target takes 1d10 Force damage.
`,
      "Elementalism.md": `---
smType: spell
name: "Elementalism"
level: 0
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Druid", "Sorcerer", "Wizard"]
---

# Elementalism
Cantrip Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Druid, Sorcerer, Wizard

You exert control over the elements, creating one of the following effects within range.

**_Beckon Air._** You create a breeze strong enough to ripple cloth, stir dust, rustle leaves, and close open doors and shutters, all in a 5-foot Cube. Doors and shutters being held open by someone or something aren't affected.

**_Beckon Earth._** You create a thin shroud of dust or sand that covers surfaces in a 5-foot-square area, or you cause a single word to appear in your handwriting in a patch of dirt or sand.

**_Beckon Fire._** You create a thin cloud of harmless embers and colored, scented smoke in a 5-foot Cube. You choose the color and scent, and the embers can light candles, torches, or lamps in that area. The smoke's scent lingers for 1 minute.

**_Beckon Water._** You create a spray of cool mist that lightly dampens creatures and objects in a 5-foot Cube. Alternatively, you create 1 cup of clean water either in an open container or on a surface, and the water evaporates in 1 minute.

**_Sculpt Element._** You cause dirt, sand, fire, smoke, mist, or water that can fit in a 1-foot Cube to assume a crude shape (such as that of a creature) for 1 hour.
`,
      "Enhance Ability.md": `---
smType: spell
name: "Enhance Ability"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "fur or a feather"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Bard", "Cleric", "Druid", "Ranger", "Sorcerer", "Wizard"]
---

# Enhance Ability
Level 2 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (fur or a feather)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Bard, Cleric, Druid, Ranger, Sorcerer, Wizard

You touch a creature and choose Strength, Dexterity, Intelligence, Wisdom, or Charisma. For the duration, the target has Advantage on ability checks using the chosen ability.
`,
      "Enlarge-Reduce.md": `---
smType: spell
name: "Enlarge/Reduce"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a pinch of powdered iron"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Druid", "Sorcerer", "Wizard"]
save_ability: "CON"
damage: "1d4"
damage_type: "less"
---

# Enlarge/Reduce
Level 2 Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a pinch of powdered iron)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Druid, Sorcerer, Wizard
- Save: CON
- Damage: 1d4 less

For the duration, the spell enlarges or reduces a creature or an object you can see within range (see the chosen effect below). A targeted object must be neither worn nor carried. If the target is an unwilling creature, it can make a Constitution saving throw. On a successful save, the spell has no effect.

Everything that a targeted creature is wearing and carrying changes size with it. Any item it drops returns to normal size at once. A thrown weapon or piece of ammunition returns to normal size immediately after it hits or misses a target.

**_Enlarge._** The target's size increases by one category\u2014from Medium to Large, for example. The target also has Advantage on Strength checks and Strength saving throws. The target's attacks with its enlarged weapons or Unarmed Strikes deal an extra 1d4 damage on a hit.

**_Reduce._** The target's size decreases by one category\u2014from Medium to Small, for example. The target also has Disadvantage on Strength checks and Strength saving throws. The target's attacks with its reduced weapons or Unarmed Strikes deal 1d4 less damage on a hit (this can't reduce the damage below 1).
`,
      "Ensnaring Strike.md": `---
smType: spell
name: "Ensnaring Strike"
level: 1
school: "Conjuration"
casting_time: "Bonus Action, which you take immediately after hitting a creature with a weapon"
range: "Self"
components: ["V"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Ranger"]
save_ability: "STR"
damage: "1d6"
damage_type: "Piercing"
---

# Ensnaring Strike
Level 1 Conjuration

- Casting Time: Bonus Action, which you take immediately after hitting a creature with a weapon
- Range: Self
- Components: V
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Ranger
- Save: STR
- Damage: 1d6 Piercing

As you hit the target, grasping vines appear on it, and it makes a Strength saving throw. A Large or larger creature has Advantage on this save. On a failed save, the target has the Restrained condition until the spell ends. On a successful save, the vines shrivel away, and the spell ends.

While Restrained, the target takes 1d6 Piercing damage at the start of each of its turns. The target or a creature within reach of it can take an action to make a Strength (Athletics) check against your spell save DC. On a success, the spell ends.
`,
      "Entangle.md": `---
smType: spell
name: "Entangle"
level: 1
school: "Conjuration"
casting_time: "Action"
range: "90 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Ranger"]
save_ability: "STR"
---

# Entangle
Level 1 Conjuration

- Casting Time: Action
- Range: 90 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Ranger
- Save: STR

Grasping plants sprout from the ground in a 20-foot square within range. For the duration, these plants turn the ground in the area into Difficult Terrain. They disappear when the spell ends.

Each creature (other than you) in the area when you cast the spell must succeed on a Strength

saving throw or have the Restrained condition until the spell ends. A Restrained creature can take an action to make a Strength (Athletics) check against your spell save DC. On a success, it frees itself from the grasping plants and is no longer Restrained by them.
`,
      "Enthrall.md": `---
smType: spell
name: "Enthrall"
level: 2
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Warlock"]
save_ability: "WIS"
---

# Enthrall
Level 2 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Warlock
- Save: WIS

You weave a distracting string of words, causing creatures of your choice that you can see within range to make a Wisdom saving throw. Any creature you or your companions are fighting automatically succeeds on this save. On a failed save, a target has a \u221210 penalty to Wisdom (Perception) checks and Passive Perception until the spell ends.
`,
      "Etherealness.md": `---
smType: spell
name: "Etherealness"
level: 7
school: "Conjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Up to 8 hours"
classes: ["Bard", "Cleric", "Sorcerer", "Warlock", "Wizard"]
---

# Etherealness
Level 7 Conjuration

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Up to 8 hours
- Classes: Bard, Cleric, Sorcerer, Warlock, Wizard

You step into the border regions of the Ethereal Plane, where it overlaps with your current plane. You remain in the Border Ethereal for the duration. During this time, you can move in any direction. If you move up or down, every foot of movement costs an extra foot. You can perceive the plane you left, which looks gray, and you can't see anything there more than 60 feet away.

While on the Ethereal Plane, you can affect and be affected only by creatures, objects, and effects on that plane. Creatures that aren't on the Ethereal Plane can't perceive or interact with you unless a feature gives them the ability to do so.

When the spell ends, you return to the plane you left in the spot that corresponds to your space in the Border Ethereal. If you appear in an occupied space, you are shunted to the nearest unoccupied space and take Force damage equal to twice the number of feet you are moved.

This spell ends instantly if you cast it while you are on the Ethereal Plane or a plane that doesn't border it, such as one of the Outer Planes.
`,
      "Expeditious Retreat.md": `---
smType: spell
name: "Expeditious Retreat"
level: 1
school: "Transmutation"
casting_time: "Bonus Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Sorcerer", "Warlock", "Wizard"]
---

# Expeditious Retreat
Level 1 Transmutation

- Casting Time: Bonus Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Sorcerer, Warlock, Wizard

You take the Dash action, and until the spell ends, you can take that action again as a Bonus Action.
`,
      "Eyebite.md": `---
smType: spell
name: "Eyebite"
level: 6
school: "Necromancy"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Eyebite
Level 6 Necromancy

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Warlock, Wizard
- Save: WIS

For the duration, your eyes become an inky void. One creature of your choice within 60 feet of you that you can see must succeed on a Wisdom saving throw or be affected by one of the following effects of your choice for the duration.

On each of your turns until the spell ends, you can take a Magic action to target another creature but can't target a creature again if it has succeeded on a save against this casting of the spell.

**_Asleep._** The target has the Unconscious condition. It wakes up if it takes any damage or if another creature takes an action to shake it awake.

**_Panicked._** The target has the Frightened condition. On each of its turns, the Frightened target must take the Dash action and move away from you by the safest and shortest route available. If the target moves to a space at least 60 feet away from you where it can't see you, this effect ends.

**_Sickened._** The target has the Poisoned condition.

### F Spells
`,
      "Fabricate.md": `---
smType: spell
name: "Fabricate"
level: 4
school: "Transmutation"
casting_time: "10 minutes"
range: "120 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Wizard"]
---

# Fabricate
Level 4 Transmutation

- Casting Time: 10 minutes
- Range: 120 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Wizard

You convert raw materials into products of the same material. For example, you can fabricate a wooden bridge from a clump of trees, a rope from a patch of hemp, or clothes from flax or wool.

Choose raw materials that you can see within range. You can fabricate a Large or smaller object (contained within a 10-foot Cube or eight connected 5-foot Cubes) given a sufficient quantity of material. If you're working with metal, stone, or another mineral substance, however, the fabricated object can be no larger than Medium (contained within a 5-foot Cube). The quality of any fabricated objects is based on the quality of the raw materials.

Creatures and magic items can't be created by this spell. You also can't use it to create items that require a high degree of skill\u2014such as weapons and armor\u2014unless you have proficiency with the type of Artisan's Tools used to craft such objects.
`,
      "Faerie Fire.md": `---
smType: spell
name: "Faerie Fire"
level: 1
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Druid"]
save_ability: "DEX"
---

# Faerie Fire
Level 1 Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Druid
- Save: DEX

Objects in a 20-foot Cube within range are outlined in blue, green, or violet light (your choice). Each creature in the Cube is also outlined if it fails a Dexterity saving throw. For the duration, objects and affected creatures shed Dim Light in a 10-foot radius and can't benefit from the Invisible condition.

Attack rolls against an affected creature or object have Advantage if the attacker can see it.
`,
      "Faithful Hound.md": `---
smType: spell
name: "Faithful Hound"
level: 4
school: "Conjuration"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a silver whistle"
duration: "8 hours"
classes: ["Wizard"]
save_ability: "DEX"
damage: "4d8"
damage_type: "Force"
---

# Faithful Hound
Level 4 Conjuration

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a silver whistle)
- Duration: 8 hours
- Classes: Wizard
- Save: DEX
- Damage: 4d8 Force

You conjure a phantom watchdog in an unoccupied space that you can see within range. The hound remains for the duration or until the two of you are more than 300 feet apart from each other.

No one but you can see the hound, and it is intangible and invulnerable. When a Small or larger creature comes within 30 feet of it without first speaking the password that you specify when you cast this spell, the hound starts barking loudly. The hound has Truesight with a range of 30 feet.

At the start of each of your turns, the hound attempts to bite one enemy within 5 feet of it. That enemy must succeed on a Dexterity saving throw or take 4d8 Force damage.

On your later turns, you can take a Magic action to move the hound up to 30 feet.
`,
      "False Life.md": `---
smType: spell
name: "False Life"
level: 1
school: "Necromancy"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a drop of alcohol"
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
---

# False Life
Level 1 Necromancy

- Casting Time: Action
- Range: Self
- Components: V, S, M (a drop of alcohol)
- Duration: Instantaneous
- Classes: Sorcerer, Wizard

You gain 2d4 + 4 Temporary Hit Points.
`,
      "Fear.md": `---
smType: spell
name: "Fear"
level: 3
school: "Illusion"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a white feather"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Fear
Level 3 Illusion

- Casting Time: Action
- Range: Self
- Components: V, S, M (a white feather)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Warlock, Wizard
- Save: WIS

Each creature in a 30-foot Cone must succeed on a Wisdom saving throw or drop whatever it is holding and have the Frightened condition for the duration.

A Frightened creature takes the Dash action and moves away from you by the safest route on each of its turns unless there is nowhere to move. If the creature ends its turn in a space where it doesn't have line of sight to you, the creature makes a Wisdom saving throw. On a successful save, the spell ends on that creature.
`,
      "Feather Fall.md": `---
smType: spell
name: "Feather Fall"
level: 1
school: "Transmutation"
casting_time: "Reaction, which you take when you or a creature you can see within 60 feet of you falls"
range: "60 feet"
components: ["V", "M"]
materials: "a small feather or piece of down"
duration: "1 minute"
classes: ["Bard", "Sorcerer", "Wizard"]
---

# Feather Fall
Level 1 Transmutation

- Casting Time: Reaction, which you take when you or a creature you can see within 60 feet of you falls
- Range: 60 feet
- Components: V, M (a small feather or piece of down)
- Duration: 1 minute
- Classes: Bard, Sorcerer, Wizard

Choose up to five falling creatures within range. A falling creature's rate of descent slows to 60 feet per round until the spell ends. If a creature lands before the spell ends, the creature takes no damage from the fall, and the spell ends for that creature.
`,
      "Find Familiar.md": `---
smType: spell
name: "Find Familiar"
level: 1
school: "Conjuration"
casting_time: "1 hour or Ritual"
range: "10 feet"
components: ["V", "S", "M"]
materials: "burning incense worth 10+ GP, which the spell consumes"
duration: "Instantaneous"
ritual: true
classes: ["Wizard"]
---

# Find Familiar
Level 1 Conjuration

- Casting Time: 1 hour or Ritual
- Range: 10 feet
- Components: V, S, M (burning incense worth 10+ GP, which the spell consumes)
- Duration: Instantaneous
- Ritual: yes
- Classes: Wizard

You gain the service of a familiar, a spirit that takes an animal form you choose: **Bat, Cat, Frog, Hawk, Lizard, Octopus, Owl, Rat, Raven, Spider, Weasel,** or another Beast that has a Challenge Rating of 0. Appearing in an unoccupied space within range, the familiar has the statistics of the chosen form (see "Monsters"), though it is a Celestial, Fey, or Fiend (your choice) instead of a Beast. Your familiar acts independently of you, but it obeys your commands.

**_Telepathic Connection._** While your familiar is within 100 feet of you, you can communicate with it telepathically. Additionally, as a Bonus Action, you can see through the familiar's eyes and hear what it hears until the start of your next turn, gaining the benefits of any special senses it has.

Finally, when you cast a spell with a range of touch, your familiar can deliver the touch. Your familiar must be within 100 feet of you, and it must take a Reaction to deliver the touch when you cast the spell.

**_Combat._** The familiar is an ally to you and your allies. It rolls its own Initiative and acts on its own turn. A familiar can't attack, but it can take other actions as normal.

**_Disappearance of the Familiar._** When the familiar drops to 0 Hit Points, it disappears. It reappears after you cast this spell again. As a Magic action, you can temporarily dismiss the familiar to a pocket dimension. Alternatively, you can dismiss it forever. As a Magic action while it is temporarily dismissed, you can cause it to reappear in an unoccupied space within 30 feet of you. Whenever the familiar drops to 0 Hit Points or disappears into the pocket dimension, it leaves behind in its space anything it was wearing or carrying.

**_One Familiar Only._** You can't have more than one familiar at a time. If you cast this spell while you have a familiar, you instead cause it to adopt a new eligible form.
`,
      "Find Steed.md": `---
smType: spell
name: "Find Steed"
level: 2
school: "Conjuration"
casting_time: "Action"
range: "30 feet"
duration: "Instantaneous"
classes: ["Paladin"]
---

# Find Steed
Level 2 Conjuration

- Casting Time: Action
- Range: 30 feet
- Duration: Instantaneous
- Classes: Paladin

You summon an otherworldly being that appears as a loyal steed in an unoccupied space of your choice within range. This creature uses the **Otherworldly Steed** stat block. If you already have a steed from this spell, the steed is replaced by the new one.

The steed resembles a Large, rideable animal of your choice, such as a horse, a camel, a dire wolf, or an elk. Whenever you cast the spell, choose the steed's creature type\u2014Celestial, Fey, or Fiend which determines certain traits in the stat block.

**_Combat._** The steed is an ally to you and your allies. In combat, it shares your Initiative count, and it functions as a controlled mount while you ride it (as defined in the rules on mounted combat). If you have the Incapacitated condition, the steed takes its turn immediately after yours and acts independently, focusing on protecting you.

**_Disappearance of the Steed._** The steed disappears if it drops to 0 Hit Points or if you die. When it disappears, it leaves behind anything it was wearing or carrying. If you cast this spell again, you decide whether you summon the steed that disappeared or a different one.

## At Higher Levels

> #### **Otherworldly Steed**

>

> *Large Celestial, Fey, or Fiend (Your Choice), Neutral*

>

> **AC** 10 + 1 per spell level

>

> **HP** 5 + 10 per spell level (the steed has a number of Hit Dice [d10s] equal to the spell's level)

>

> **Speed** 60 ft., Fly 60 ft. (requires level 4+ spell)

>

> | Attribute | Score | Mod | Save |

> |-----------|-------|-----|------|

> | Str       | 18    | +4  | +4   |

> | Dex       | 12    | +1  | +1   |

> | Con       | 14    | +2  | +2   |

> | Int       | 6     | -2  | -2   |

> | Wis       | 12    | +1  | +1   |

> | Cha       | 8     | -1  | -1   |

>

> **Senses** Passive Perception 11

>

> **Languages** Telepathy 1 mile (works only with you)

>

> **CR** None (XP 0; PB equals your Proficiency Bonus)

>

> ##### Traits

>

> **_Life Bond._** When you regain Hit Points from a level 1+ spell, the steed regains the same number of Hit Points if you're within 5 feet of it.

>

> ##### Actions

>

> **_.Otherworldly Slam. Melee Attack Roll:_** Bonus equals your spell attack modifier, reach 5 ft. *Hit:* 1d8 plus the spell's level of Radiant (Celestial), Psychic (Fey), or Necrotic (Fiend) damage.

>

> ##### Bonus Actions

>

> **_Fell Glare (Fiend Only; Recharges after a Long Rest)._** *Wisdom Saving Throw:* DC equals your spell save DC, one creature within 60 feet the steed can see. *Failure:* The target has the Frightened condition until the end of your next turn.

>

> **_Fey Step (Fey Only; Recharges after a Long Rest)._** The steed teleports, along with its rider, to an unoccupied space of your choice up to 60 feet away from itself.

>

> **Healing Touch (Celestial Only; Recharges after a Long Rest)._** One creature within 5 feet of the steed regains a number of Hit Points equal to 2d8 plus the spell's level.
`,
      "Find Traps.md": `---
smType: spell
name: "Find Traps"
level: 2
school: "Divination"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric", "Druid", "Ranger"]
---

# Find Traps
Level 2 Divination

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric, Druid, Ranger

You sense any trap within range that is within line of sight. A trap, for the purpose of this spell, includes any object or mechanism that was created to cause damage or other danger. Thus, the spell would sense the *Alarm* or *Glyph of Warding* spell or a mechanical pit trap, but it wouldn't reveal a natural weakness in the floor, an unstable ceiling, or a hidden sinkhole.

This spell reveals that a trap is present but not its location. You do learn the general nature of the danger posed by a trap you sense.
`,
      "Find the Path.md": `---
smType: spell
name: "Find the Path"
level: 6
school: "Divination"
casting_time: "1 minute"
range: "Self"
components: ["V", "S", "M"]
materials: "a set of divination tools\u2014such as cards or runes\u2014worth 100+ GP"
duration: "Concentration, up to 1 day"
concentration: true
classes: ["Bard", "Cleric", "Druid"]
---

# Find the Path
Level 6 Divination

- Casting Time: 1 minute
- Range: Self
- Components: V, S, M (a set of divination tools\u2014such as cards or runes\u2014worth 100+ GP)
- Duration: Concentration, up to 1 day
- Concentration: yes
- Classes: Bard, Cleric, Druid

You magically sense the most direct physical route to a location you name. You must be familiar with the location, and the spell fails if you name a destination on another plane of existence, a moving destination (such as a mobile fortress), or an unspecific destination (such as "a green dragon's lair").

For the duration, as long as you are on the same plane of existence as the destination, you know how far it is and in what direction it lies. Whenever you face a choice of paths along the way there, you know which path is the most direct.
`,
      "Finger of Death.md": `---
smType: spell
name: "Finger of Death"
level: 7
school: "Necromancy"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Warlock", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "7d8 + 30"
damage_type: "Necrotic"
---

# Finger of Death
Level 7 Necromancy

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Warlock, Wizard
- Save: CON (Half damage on success)
- Damage: 7d8 + 30 Necrotic

You unleash negative energy toward a creature you can see within range. The target makes a Constitution saving throw, taking 7d8 + 30 Necrotic damage on a failed save or half as much damage on a successful one.

A Humanoid killed by this spell rises at the start of your next turn as a **Zombie** (see "Monsters") that follows your verbal orders.
`,
      "Fire Bolt.md": `---
smType: spell
name: "Fire Bolt"
level: 0
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
attack: "ranged spell attack"
damage: "1d10"
damage_type: "Fire"
---

# Fire Bolt
Cantrip Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Attack: ranged spell attack
- Damage: 1d10 Fire

You hurl a mote of fire at a creature or an object within range. Make a ranged spell attack against the target. On a hit, the target takes 1d10 Fire damage. A flammable object hit by this spell starts burning if it isn't being worn or carried.
`,
      "Fire Shield.md": `---
smType: spell
name: "Fire Shield"
level: 4
school: "Evocation"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a bit of phosphorus or a firefly"
duration: "10 minutes"
classes: ["Druid", "Sorcerer", "Wizard"]
damage: "2d8"
damage_type: "Fire"
---

# Fire Shield
Level 4 Evocation

- Casting Time: Action
- Range: Self
- Components: V, S, M (a bit of phosphorus or a firefly)
- Duration: 10 minutes
- Classes: Druid, Sorcerer, Wizard
- Damage: 2d8 Fire

Wispy flames wreathe your body for the duration, shedding Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.

The flames provide you with a warm shield or a chill shield, as you choose. The warm shield grants you Resistance to Cold damage, and the chill shield grants you Resistance to Fire damage.

In addition, whenever a creature within 5 feet of you hits you with a melee attack roll, the shield erupts with flame. The attacker takes 2d8 Fire damage from a warm shield or 2d8 Cold damage from a chill shield.
`,
      "Fire Storm.md": `---
smType: spell
name: "Fire Storm"
level: 7
school: "Evocation"
casting_time: "Action"
range: "150 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric", "Druid", "Sorcerer"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "7d10"
damage_type: "Fire"
---

# Fire Storm
Level 7 Evocation

- Casting Time: Action
- Range: 150 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric, Druid, Sorcerer
- Save: DEX (Half damage on success)
- Damage: 7d10 Fire

A storm of fire appears within range. The area of the storm consists of up to ten 10-foot Cubes, which you arrange as you like. Each Cube must be contiguous with at least one other Cube. Each creature in the area makes a Dexterity saving throw, taking 7d10 Fire damage on a failed save or half as much damage on a successful one.

Flammable objects in the area that aren't being worn or carried start burning.
`,
      "Fireball.md": `---
smType: spell
name: "Fireball"
level: 3
school: "Evocation"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "a ball of bat guano and sulfur"
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "8d6"
damage_type: "Fire"
---

# Fireball
Level 3 Evocation

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (a ball of bat guano and sulfur)
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 8d6 Fire

A bright streak flashes from you to a point you choose within range and then blossoms with a low roar into a fiery explosion. Each creature in a 20-foot-radius Sphere centered on that point makes a Dexterity saving throw, taking 8d6 Fire damage on a failed save or half as much damage on a successful one.

Flammable objects in the area that aren't being worn or carried start burning.

**Using a Higher-Level Spell Slot._** The damage increases by 1d6 for each spell slot level above 3.
`,
      "Flame Blade.md": `---
smType: spell
name: "Flame Blade"
level: 2
school: "Evocation"
casting_time: "Bonus Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a sumac leaf"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid", "Sorcerer"]
attack: "melee spell attack"
---

# Flame Blade
Level 2 Evocation

- Casting Time: Bonus Action
- Range: Self
- Components: V, S, M (a sumac leaf)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid, Sorcerer
- Attack: melee spell attack

You evoke a fiery blade in your free hand. The blade is similar in size and shape to a scimitar, and it lasts for the duration. If you let go of the blade, it disappears, but you can evoke it again as a Bonus Action.

As a Magic action, you can make a melee spell attack with the fiery blade. On a hit, the target takes Fire damage equal to 3d6 plus your spellcasting ability modifier.

The flaming blade sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.
`,
      "Flame Strike.md": `---
smType: spell
name: "Flame Strike"
level: 5
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a pinch of sulfur"
duration: "Instantaneous"
classes: ["Cleric"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "5d6"
damage_type: "Fire"
---

# Flame Strike
Level 5 Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a pinch of sulfur)
- Duration: Instantaneous
- Classes: Cleric
- Save: DEX (Half damage on success)
- Damage: 5d6 Fire

A vertical column of brilliant fire roars down from above. Each creature in a 10-foot-radius, 40-foothigh Cylinder centered on a point within range makes a Dexterity saving throw, taking 5d6 Fire damage and 5d6 Radiant damage on a failed save or half as much damage on a successful one.
`,
      "Flaming Sphere.md": `---
smType: spell
name: "Flaming Sphere"
level: 2
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a ball of wax"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "2d6"
damage_type: "Fire"
---

# Flaming Sphere
Level 2 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a ball of wax)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 2d6 Fire

You create a 5-foot-diameter sphere of fire in an unoccupied space on the ground within range. It lasts for the duration. Any creature that ends its turn within 5 feet of the sphere makes a Dexterity saving throw, taking 2d6 Fire damage on a failed save or half as much damage on a successful one.

As a Bonus Action, you can move the sphere up to 30 feet, rolling it along the ground. If you move the sphere into a creature's space, that creature makes the save against the sphere, and the sphere stops moving for the turn.

When you move the sphere, you can direct it over barriers up to 5 feet tall and jump it across pits up to 10 feet wide. Flammable objects that aren't being worn or carried start burning if touched by the sphere, and it sheds Bright Light in a 20-foot radius and Dim Light for an additional 20 feet.
`,
      "Flesh to Stone.md": `---
smType: spell
name: "Flesh to Stone"
level: 6
school: "Transmutation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a cockatrice feather"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "CON"
---

# Flesh to Stone
Level 6 Transmutation

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a cockatrice feather)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Sorcerer, Wizard
- Save: CON

You attempt to turn one creature that you can see within range into stone. The target makes a Constitution saving throw. On a failed save, it has the Restrained condition for the duration. On a successful save, its Speed is 0 until the start of your next turn. Constructs automatically succeed on the save.

A Restrained target makes another Constitution saving throw at the end of each of its turns. If it successfully saves against this spell three times, the spell ends. If it fails its saves three times, it is turned to stone and has the Petrified condition for the duration. The successes and failures needn't be consecutive; keep track of both until the target collects three of a kind.

If you maintain your Concentration on this spell for the entire possible duration, the target is Petrified until the condition is ended by *Greater Restoration* or similar magic.
`,
      "Floating Disk.md": `---
smType: spell
name: "Floating Disk"
level: 1
school: "Conjuration"
casting_time: "Action or Ritual"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a drop of mercury"
duration: "1 hour"
ritual: true
classes: ["Wizard"]
---

# Floating Disk
Level 1 Conjuration

- Casting Time: Action or Ritual
- Range: 30 feet
- Components: V, S, M (a drop of mercury)
- Duration: 1 hour
- Ritual: yes
- Classes: Wizard

This spell creates a circular, horizontal plane of force, 3 feet in diameter and 1 inch thick, that floats 3 feet above the ground in an unoccupied space of your choice that you can see within range. The disk remains for the duration and can hold up to 500 pounds. If more weight is placed on it, the spell ends, and everything on the disk falls to the ground.

The disk is immobile while you are within 20 feet of it. If you move more than 20 feet away from it, the disk follows you so that it remains within 20 feet of you. It can move across uneven terrain, up or down stairs, slopes and the like, but it can't cross an elevation change of 10 feet or more. For example, the disk can't move across a 10-foot-deep pit, nor could it leave such a pit if it was created at the bottom.

If you move more than 100 feet from the disk (typically because it can't move around an obstacle to follow you), the spell ends.
`,
      "Fly.md": `---
smType: spell
name: "Fly"
level: 3
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a feather"
duration: "Concentration, up to 10 minutes You touch a willing creature. For the duration, the target gains a Fly Speed of 60 feet and can hover. When the spell ends, the target falls if it is still aloft unless it can stop the fall."
concentration: true
classes: ["Sorcerer", "Warlock", "Wizard"]
---

# Fly
Level 3 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a feather)
- Duration: Concentration, up to 10 minutes You touch a willing creature. For the duration, the target gains a Fly Speed of 60 feet and can hover. When the spell ends, the target falls if it is still aloft unless it can stop the fall.
- Concentration: yes
- Classes: Sorcerer, Warlock, Wizard
`,
      "Fog Cloud.md": `---
smType: spell
name: "Fog Cloud"
level: 1
school: "Conjuration"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Druid", "Ranger", "Sorcerer", "Wizard"]
---

# Fog Cloud
Level 1 Conjuration

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Druid, Ranger, Sorcerer, Wizard

You create a 20-foot-radius Sphere of fog centered on a point within range. The Sphere is Heavily Obscured. It lasts for the duration or until a strong wind (such as one created by *Gust of Wind*) disperses it.
`,
      "Forbiddance.md": `---
smType: spell
name: "Forbiddance"
level: 6
school: "Abjuration"
casting_time: "10 minutes or Ritual"
range: "Touch"
components: ["V", "S", "M"]
materials: "ruby dust worth 1,000+ GP"
duration: "1 day"
ritual: true
classes: ["Cleric"]
---

# Forbiddance
Level 6 Abjuration

- Casting Time: 10 minutes or Ritual
- Range: Touch
- Components: V, S, M (ruby dust worth 1,000+ GP)
- Duration: 1 day
- Ritual: yes
- Classes: Cleric

You create a ward against magical travel that protects up to 40,000 square feet of floor space to a height of 30 feet above the floor. For the duration, creatures can't teleport into the area or use portals, such as those created by the *Gate* spell, to enter the area. The spell proofs the area against planar travel, and therefore prevents creatures from accessing the area by way of the Astral Plane, the Ethereal Plane, the Feywild, the Shadowfell, or the *Plane Shift* spell.

In addition, the spell damages types of creatures that you choose when you cast it. Choose one or more of the following: Aberrations, Celestials, Elementals, Fey, Fiends, and Undead. When a creature of a chosen type enters the spell's area for the first time on a turn or ends its turn there, the creature takes 5d10 Radiant or Necrotic damage (your choice when you cast this spell).

You can designate a password when you cast the spell. A creature that speaks the password as it enters the area takes no damage from the spell.

The spell's area can't overlap with the area of another *Forbiddance* spell. If you cast *Forbiddance* every day for 30 days in the same location, the spell lasts until it is dispelled, and the Material components are consumed on the last casting.
`,
      "Forcecage.md": `---
smType: spell
name: "Forcecage"
level: 7
school: "Evocation"
casting_time: "Action **Range:** 100 feet **Components:** V, S, M (ruby dust worth 1,500+ GP, which the spell consumes) **Duration:** Concentration, up to 1 hour"
classes: ["Bard", "Warlock", "Wizard"]
---

# Forcecage
Level 7 Evocation

- Casting Time: Action **Range:** 100 feet **Components:** V, S, M (ruby dust worth 1,500+ GP, which the spell consumes) **Duration:** Concentration, up to 1 hour
- Classes: Bard, Warlock, Wizard
`,
      "Foresight.md": `---
smType: spell
name: "Foresight"
level: 9
school: "Divination"
casting_time: "1 minute"
range: "Touch"
components: ["V", "S", "M"]
materials: "a hummingbird feather"
duration: "8 hours"
classes: ["Bard", "Druid", "Warlock", "Wizard"]
---

# Foresight
Level 9 Divination

- Casting Time: 1 minute
- Range: Touch
- Components: V, S, M (a hummingbird feather)
- Duration: 8 hours
- Classes: Bard, Druid, Warlock, Wizard

You touch a willing creature and bestow a limited ability to see into the immediate future. For the duration, the target has Advantage on D20 Tests, and other creatures have Disadvantage on attack rolls against it. The spell ends early if you cast it again.
`,
      "Freedom of Movement.md": `---
smType: spell
name: "Freedom of Movement"
level: 4
school: "Abjuration"
casting_time: "Action"
range: "300 feet"
components: ["V", "S", "M"]
materials: "a miniature crystal sphere"
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid", "Ranger"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "10d6"
damage_type: "Cold"
---

# Freedom of Movement
Level 4 Abjuration

- Casting Time: Action
- Range: 300 feet
- Components: V, S, M (a miniature crystal sphere)
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid, Ranger
- Save: CON (Half damage on success)
- Damage: 10d6 Cold

A frigid globe streaks from you to a point of your choice within range, where it explodes in a 60-foot-radius Sphere. Each creature in that area makes a Constitution saving throw, taking 10d6 Cold damage on failed save or half as much damage on a successful one.

If the globe strikes a body of water, it freezes the water to a depth of 6 inches over an area 30 feet square. This ice lasts for 1 minute. Creatures that were swimming on the surface of frozen water are trapped in the ice and have the Restrained condition. A trapped creature can take an action to make a Strength (Athletics) check against your spell save DC to break free.

You can refrain from firing the globe after completing the spell's casting. If you do so, a globe about the size of a sling bullet, cool to the touch, appears in your hand. At any time, you or a creature you give the globe to can throw the globe (to a range of 40 feet) or hurl it with a sling (to the sling's normal range). It shatters on impact, with the same effect as a normal casting of the spell. You can also set the globe down without shattering it. After 1 minute, if the globe hasn't already shattered, it explodes.

*Using a Higher-Level Spell Slot.* The damage increases by 1d6 for each spell slot level above 6.

### G Spells
`,
      "Gaseous Form.md": `---
smType: spell
name: "Gaseous Form"
level: 3
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a bit of gauze"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Sorcerer", "Warlock", "Wizard"]
save_ability: "CON"
---

# Gaseous Form
Level 3 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a bit of gauze)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Sorcerer, Warlock, Wizard
- Save: CON

A willing creature you touch shape-shifts, along with everything it's wearing and carrying, into a misty cloud for the duration. The spell ends on the target if it drops to 0 Hit Points or if it takes a Magic action to end the spell on itself.

While in this form, the target's only method of movement is a Fly Speed of 10 feet, and it can hover. The target can enter and occupy the space of another creature. The target has Resistance to Bludgeoning, Piercing, and Slashing damage; it has Immunity to the Prone condition; and it has Advantage on Strength, Dexterity, and Constitution saving throws. The target can pass through narrow openings, but it treats liquids as though they were solid surfaces.

The target can't talk or manipulate objects, and any objects it was carrying or holding can't be dropped, used, or otherwise interacted with. Finally, the target can't attack or cast spells.
`,
      "Gate.md": `---
smType: spell
name: "Gate"
level: 9
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a diamond worth 5,000+ GP"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric", "Sorcerer", "Warlock", "Wizard"]
---

# Gate
Level 9 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a diamond worth 5,000+ GP)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric, Sorcerer, Warlock, Wizard

You conjure a portal linking an unoccupied space you can see within range to a precise location on a different plane of existence. The portal is a circular opening, which you can make 5 to 20 feet in diameter. You can orient the portal in any direction you choose. The portal lasts for the duration, and the portal's destination is visible through it.

The portal has a front and a back on each plane where it appears. Travel through the portal is possible only by moving through its front. Anything that does so is instantly transported to the other plane, appearing in the unoccupied space nearest to the portal.

Deities and other planar rulers can prevent portals created by this spell from opening in their presence or anywhere within their domains.

When you cast this spell, you can speak the name of a specific creature (a pseudonym, title, or nickname doesn't work). If that creature is on a plane other than the one you are on, the portal opens next to the named creature and transports it to the nearest unoccupied space on your side of the portal. You gain no special power over the creature, and it is free to act as the GM deems appropriate. It might leave, attack you, or help you.
`,
      "Geas.md": `---
smType: spell
name: "Geas"
level: 5
school: "Enchantment"
casting_time: "1 minute"
range: "60 feet"
components: ["V"]
duration: "30 days"
classes: ["Bard", "Cleric", "Druid", "Paladin", "Wizard"]
save_ability: "WIS"
damage: "5d10"
damage_type: "Psychic"
---

# Geas
Level 5 Enchantment

- Casting Time: 1 minute
- Range: 60 feet
- Components: V
- Duration: 30 days
- Classes: Bard, Cleric, Druid, Paladin, Wizard
- Save: WIS
- Damage: 5d10 Psychic

You give a verbal command to a creature that you can see within range, ordering it to carry out some service or refrain from an action or a course of activity as you decide. The target must succeed on a Wisdom saving throw or have the Charmed condition for the duration. The target automatically succeeds if it can't understand your command.

While Charmed, the creature takes 5d10 Psychic damage if it acts in a manner directly counter to your command. It takes this damage no more than once each day.

You can issue any command you choose, short of an activity that would result in certain death. Should you issue a suicidal command, the spell ends.

A *Remove Curse*, *Greater Restoration*, or *Wish* spell ends this spell.
`,
      "Gentle Repose.md": `---
smType: spell
name: "Gentle Repose"
level: 2
school: "Necromancy"
casting_time: "Action or Ritual"
range: "Touch"
components: ["V", "S", "M"]
materials: "2 Copper Pieces, which the spell consumes"
duration: "10 days"
ritual: true
classes: ["Cleric", "Paladin", "Wizard"]
---

# Gentle Repose
Level 2 Necromancy

- Casting Time: Action or Ritual
- Range: Touch
- Components: V, S, M (2 Copper Pieces, which the spell consumes)
- Duration: 10 days
- Ritual: yes
- Classes: Cleric, Paladin, Wizard

You touch a corpse or other remains. For the duration, the target is protected from decay and can't become Undead.

The spell also effectively extends the time limit on raising the target from the dead, since days spent under the influence of this spell don't count against the time limit of spells such as *Raise Dead*.
`,
      "Giant Insect.md": `---
smType: spell
name: "Giant Insect"
level: 4
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid"]
---

# Giant Insect
Level 4 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid

You summon a giant centipede, spider, or wasp (chosen when you cast the spell). It manifests in an unoccupied space you can see within range and uses the **Giant Insect** stat block. The form you choose determines certain details in its stat block. The creature disappears when it drops to 0 Hit Points or when the spell ends.

The creature is an ally to you and your allies. In combat, the creature shares your Initiative count, but it takes its turn immediately after yours. It obeys your verbal commands (no action required by you). If you don't issue any, it takes the Dodge action and uses its movement to avoid danger.

## At Higher Levels

> #### Giant Insect

>

> *Large Beast, Unaligned*

>

> **AC** 11 + the spell's level

>

> **HP** 30 + 10 for each spell level above 4

>

> **Speed** 40 ft., Climb 40 ft., Fly 40 ft. (Wasp only)

>

> | Attribute | Score | Mod | Save |

> |-----------|-------|-----|------|

> | Str       | 17    | +3  | +3   |

> | Dex       | 13    | +1  | +1   |

> | Con       | 15    | +2  | +2   |

> | Int       | 4     | -3  | -3   |

> | Wis       | 14    | +2  | +2   |

> | Cha       | 3     | -4  | -4   |

>

> **Senses** Darkvision 60 ft.; Passive Perception 12

>

> **Languages** Understands the languages you know

>

> **CR** None (XP 0; PB equals your Proficiency Bonus)

>

> ##### Traits

>

> **_Spider Climb._** The insect can climb difficult surfaces, including along ceilings, without needing to make an ability check.

>

> ##### Actions

>

> **_Multiattack._** The insect makes a number of attacks equal to half this spell's level (round down).

>

> **_Poison Jab. Melee Attack Roll:_** Bonus equals your spell attack modifier, reach 10 ft. *Hit:* 1d6 + 3 plus the spell's level Piercing damage plus 1d4 Poison damage.

>

> **Web Bolt (Spider Only). Ranged Attack Roll:_** Bonus equals your spell attack modifier, range 60 ft. *Hit:* 1d10 + 3 plus the spell's level Bludgeoning damage, and the target's Speed is reduced to 0 until the start of the insect's next turn.

>

> ##### Bonus Actions

>

> **Venomous Spew (Centipede Only). Constitution Saving Throw:_** Your spell save DC, one creature the insect can see within 10 feet. *Failure:* The target has the Poisoned condition until the start of the insect's next turn.
`,
      "Glibness.md": `---
smType: spell
name: "Glibness"
level: 8
school: "Enchantment"
casting_time: "Action"
range: "Self"
components: ["V"]
duration: "1 hour"
classes: ["Bard", "Warlock"]
---

# Glibness
Level 8 Enchantment

- Casting Time: Action
- Range: Self
- Components: V
- Duration: 1 hour
- Classes: Bard, Warlock

Until the spell ends, when you make a Charisma check, you can replace the number you roll with a 15. Additionally, no matter what you say, magic that would determine if you are telling the truth indicates that you are being truthful.
`,
      "Globe of Invulnerability.md": `---
smType: spell
name: "Globe of Invulnerability"
level: 6
school: "Abjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a glass bead"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Sorcerer", "Wizard"]
---

# Globe of Invulnerability
Level 6 Abjuration

- Casting Time: Action
- Range: Self
- Components: V, S, M (a glass bead)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Sorcerer, Wizard

An immobile, shimmering barrier appears in a 10 foot Emanation around you and remains for the duration.

Any spell of level 5 or lower cast from outside the barrier can't affect anything within it. Such a spell can target creatures and objects within the barrier, but the spell has no effect on them. Similarly, the area within the barrier is excluded from areas of effect created by such spells.
`,
      "Glyph of Warding.md": `---
smType: spell
name: "Glyph of Warding"
level: 3
school: "Abjuration"
casting_time: "1 hour"
range: "Touch"
components: ["V", "S", "M"]
materials: "powdered diamond worth 200+ GP, which the spell consumes"
duration: "Until dispelled or triggered"
classes: ["Bard", "Cleric", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
---

# Glyph of Warding
Level 3 Abjuration

- Casting Time: 1 hour
- Range: Touch
- Components: V, S, M (powdered diamond worth 200+ GP, which the spell consumes)
- Duration: Until dispelled or triggered
- Classes: Bard, Cleric, Wizard
- Save: DEX (Half damage on success)

You inscribe a glyph that later unleashes a magical effect. You inscribe it either on a surface (such as a table or a section of floor) or within an object that can be closed (such as a book or chest) to conceal the glyph. The glyph can cover an area no larger than 10 feet in diameter. If the surface or object is moved more than 10 feet from where you cast this spell, the glyph is broken, and the spell ends without being triggered.

The glyph is nearly imperceptible and requires a successful Wisdom (Perception) check against your spell save DC to notice.

When you inscribe the glyph, you set its trigger and choose whether it's an explosive rune or a spell glyph, as explained below.

**_Set the Trigger._** You decide what triggers the glyph when you cast the spell. For glyphs inscribed on a surface, common triggers include touching or stepping on the glyph, removing another object covering it, or approaching within a certain distance of it. For glyphs inscribed within an object, common triggers include opening that object or seeing the glyph. Once a glyph is triggered, this spell ends.

You can refine the trigger so that only creatures of certain types activate it (for example, the glyph could be set to affect Aberrations). You can also set conditions for creatures that don't trigger the glyph, such as those who say a certain password.

**_Explosive Rune._** When triggered, the glyph erupts with magical energy in a 20-foot-radius Sphere centered on the glyph. Each creature in the area makes a Dexterity saving throw. A creature takes 5d8 Acid, Cold, Fire, Lightning, or Thunder damage (your choice when you create the glyph) on a failed save or half as much damage on a successful one.

**_Spell Glyph._** You can store a prepared spell of level 3 or lower in the glyph by casting it as part of creating the glyph. The spell must target a single creature or an area. The spell being stored has no immediate effect when cast in this way.

When the glyph is triggered, the stored spell takes effect. If the spell has a target, it targets the creature that triggered the glyph. If the spell affects an area, the area is centered on that creature. If the spell summons Hostile creatures or creates harmful objects or traps, they appear as close as possible to the intruder and attack it. If the spell requires Concentration, it lasts until the end of its full duration.
`,
      "Goodberry.md": `---
smType: spell
name: "Goodberry"
level: 1
school: "Conjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a sprig of mistletoe"
duration: "24 hours"
classes: ["Druid", "Ranger"]
---

# Goodberry
Level 1 Conjuration

- Casting Time: Action
- Range: Self
- Components: V, S, M (a sprig of mistletoe)
- Duration: 24 hours
- Classes: Druid, Ranger

Ten berries appear in your hand and are infused with magic for the duration. A creature can take a Bonus Action to eat one berry. Eating a berry restores 1 Hit Point, and the berry provides enough nourishment to sustain a creature for one day.

Uneaten berries disappear when the spell ends.
`,
      "Grease.md": `---
smType: spell
name: "Grease"
level: 1
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a bit of pork rind or butter"
duration: "1 minute"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
---

# Grease
Level 1 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a bit of pork rind or butter)
- Duration: 1 minute
- Classes: Sorcerer, Wizard
- Save: DEX

Nonflammable grease covers the ground in a 10 foot square centered on a point within range and turns it into Difficult Terrain for the duration.

When the grease appears, each creature standing in its area must succeed on a Dexterity saving throw or have the Prone condition. A creature that enters the area or ends its turn there must also succeed on that save or fall Prone.
`,
      "Greater Invisibility.md": `---
smType: spell
name: "Greater Invisibility"
level: 4
school: "Illusion"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Concentration, up to 1 minute A creature you touch has the Invisible condition until the spell ends."
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
---

# Greater Invisibility
Level 4 Illusion

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Concentration, up to 1 minute A creature you touch has the Invisible condition until the spell ends.
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard
`,
      "Greater Restoration.md": `---
smType: spell
name: "Greater Restoration"
level: 5
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "diamond dust worth 100+ GP, which the spell consumes"
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger"]
---

# Greater Restoration
Level 5 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S, M (diamond dust worth 100+ GP, which the spell consumes)
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid, Paladin, Ranger

You touch a creature and magically remove one of the following effects from it:

- 1 Exhaustion level

- The Charmed or Petrified condition

- A curse, including the target's Attunement to a cursed magic item

- Any reduction to one of the target's ability scores

- Any reduction to the target's Hit Point maximum
`,
      "Guardian of Faith.md": `---
smType: spell
name: "Guardian of Faith"
level: 4
school: "Conjuration"
casting_time: "Action"
range: "30 feet"
components: ["V"]
duration: "8 hours"
classes: ["Cleric"]
save_ability: "DEX"
save_effect: "Half damage on success"
---

# Guardian of Faith
Level 4 Conjuration

- Casting Time: Action
- Range: 30 feet
- Components: V
- Duration: 8 hours
- Classes: Cleric
- Save: DEX (Half damage on success)

A Large spectral guardian appears and hovers for the duration in an unoccupied space that you can see within range. The guardian occupies that space and is invulnerable, and it appears in a form appropriate for your deity or pantheon.

Any enemy that moves to a space within 10 feet of the guardian for the first time on a turn or starts its turn there makes a Dexterity saving throw, taking 20 Radiant damage on a failed save or half as much damage on a successful one. The guardian vanishes when it has dealt a total of 60 damage.
`,
      "Guards and Wards.md": `---
smType: spell
name: "Guards and Wards"
level: 6
school: "Abjuration"
casting_time: "1 hour"
range: "Touch"
components: ["V", "S", "M"]
materials: "a silver rod worth 10+ GP"
duration: "24 hours"
classes: ["Bard", "Wizard"]
---

# Guards and Wards
Level 6 Abjuration

- Casting Time: 1 hour
- Range: Touch
- Components: V, S, M (a silver rod worth 10+ GP)
- Duration: 24 hours
- Classes: Bard, Wizard

You create a ward that protects up to 2,500 square feet of floor space. The warded area can be up to 20 feet tall, and you shape it as one 50-foot square, one hundred 5-foot squares that are contiguous, or twenty-five 10-foot squares that are contiguous.

When you cast this spell, you can specify individuals that are unaffected by the spell's effects. You can also specify a password that, when spoken aloud within 5 feet of the warded area, makes the speaker immune to its effects.

The spell creates the effects below within the warded area. *Dispel Magic* has no effect on *Guards and Wards* itself, but each of the following effects can be dispelled. If all four are dispelled, *Guards and Wards* ends. If you cast the spell every day for 365 days on the same area, the spell thereafter lasts until all its effects are dispelled.

**_Corridors._** Fog fills all the warded corridors, making them Heavily Obscured. In addition, at each intersection or branching passage offering a choice of direction, there is a 50 percent chance that a creature other than you believes it is going in the opposite direction from the one it chooses.

**_Doors._** All doors in the warded area are magically locked, as if sealed by the *Arcane Lock* spell. In addition, you can cover up to ten doors with an illusion to make them appear as plain sections of wall.

**_Stairs._** Webs fill all stairs in the warded area from top to bottom, as in the *Web* spell. These strands regrow in 10 minutes if they are destroyed while *Guards and Wards* lasts.

**_Other Spell Effect._** Place one of the following magical effects within the warded area:

- *Dancing Lights* in four corridors, with a simple program that the lights repeat as long as *Guards and Wards* lasts

- *Magic Mouth* in two locations

- *Stinking Cloud* in two locations (the vapors return within 10 minutes if dispersed while *Guards and Wards* lasts)

- *Gust of Wind* in one corridor or room (the wind blows continuously while the spell lasts)

- *Suggestion* in one 5-foot square; any creature that enters that square receives the suggestion mentally
`,
      "Guidance.md": `---
smType: spell
name: "Guidance"
level: 0
school: "Divination"
casting_time: "Action"
range: "Touch"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric", "Druid"]
---

# Guidance
Cantrip Divination

- Casting Time: Action
- Range: Touch
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric, Druid

You touch a willing creature and choose a skill. Until the spell ends, the creature adds 1d4 to any ability check using the chosen skill.
`,
      "Guiding Bolt.md": `---
smType: spell
name: "Guiding Bolt"
level: 1
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "1 round"
classes: ["Cleric"]
attack: "ranged spell attack"
damage: "4d6"
damage_type: "Radiant"
---

# Guiding Bolt
Level 1 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: 1 round
- Classes: Cleric
- Attack: ranged spell attack
- Damage: 4d6 Radiant

You hurl a bolt of light toward a creature within range. Make a ranged spell attack against the target. On a hit, it takes 4d6 Radiant damage, and the next attack roll made against it before the end of your next turn has Advantage.
`,
      "Gust of Wind.md": `---
smType: spell
name: "Gust of Wind"
level: 2
school: "Evocation"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a legume seed"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Ranger", "Sorcerer", "Wizard"]
save_ability: "STR"
---

# Gust of Wind
Level 2 Evocation

- Casting Time: Action
- Range: Self
- Components: V, S, M (a legume seed)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Ranger, Sorcerer, Wizard
- Save: STR

A Line of strong wind 60 feet long and 10 feet wide blasts from you in a direction you choose for the duration. Each creature in the Line must succeed on a Strength saving throw or be pushed 15 feet away from you in a direction following the Line. A creature that ends its turn in the Line must make the same save.

Any creature in the Line must spend 2 feet of movement for every 1 foot it moves when moving closer to you.

The gust disperses gas or vapor, and it extinguishes candles and similar unprotected flames in the area. It causes protected flames, such as those of lanterns, to dance wildly and has a 50 percent chance to extinguish them.

As a Bonus Action on your later turns, you can change the direction in which the Line blasts from you.

### H Spells
`,
      "Hallow.md": `---
smType: spell
name: "Hallow"
level: 5
school: "Abjuration"
casting_time: "24 hours"
range: "Touch"
components: ["V", "S", "M"]
materials: "incense worth 1,000+ GP, which the spell consumes"
duration: "Until dispelled"
classes: ["Cleric"]
---

# Hallow
Level 5 Abjuration

- Casting Time: 24 hours
- Range: Touch
- Components: V, S, M (incense worth 1,000+ GP, which the spell consumes)
- Duration: Until dispelled
- Classes: Cleric

You touch a point and infuse an area around it with holy or unholy power. The area can have a radius up to 60 feet, and the spell fails if the radius includes an area already under the effect of *Hallow*. The affected area has the following effects.

**_Hallowed Ward._** Choose any of these creature types: Aberration, Celestial, Elemental, Fey, Fiend, or Undead. Creatures of the chosen types can't willingly enter the area, and any creature that is possessed by or that has the Charmed or Frightened condition from such creatures isn't possessed, Charmed, or Frightened by them while in the area.

**_Extra Effect._** You bind an extra effect to the area from the list below:

**_Courage._** Creatures of any types you choose can't gain the Frightened condition while in the area.

**_Darkness._** Darkness fills the area. Normal light, as well as magical light created by spells of a level lower than this spell, can't illuminate the area.

**_Daylight._** Bright light fills the area. Magical Darkness created by spells of a level lower than this spell can't extinguish the light.

**_Peaceful Rest._** Dead bodies interred in the area can't be turned into Undead.

**_Extradimensional Interference._** Creatures of any types you choose can't enter or exit the area using teleportation or interplanar travel.

**_Fear._** Creatures of any types you choose have the Frightened condition while in the area.

**_Resistance._** Creatures of any types you choose have Resistance to one damage type of your choice while in the area.

**_Silence._** No sound can emanate from within the area, and no sound can reach into it.

**_Tongues._** Creatures of any types you choose can communicate with any other creature in the area even if they don't share a common language.

**_Vulnerability._** Creatures of any types you choose have Vulnerability to one damage type of your choice while in the area.
`,
      "Hallucinatory Terrain.md": `---
smType: spell
name: "Hallucinatory Terrain"
level: 4
school: "Illusion"
casting_time: "10 minutes"
range: "300 feet"
components: ["V", "S", "M"]
materials: "a mushroom"
duration: "24 hours"
classes: ["Bard", "Druid", "Warlock", "Wizard"]
---

# Hallucinatory Terrain
Level 4 Illusion

- Casting Time: 10 minutes
- Range: 300 feet
- Components: V, S, M (a mushroom)
- Duration: 24 hours
- Classes: Bard, Druid, Warlock, Wizard

You make natural terrain in a 150-foot Cube in range look, sound, and smell like another sort of natural terrain. Thus, open fields or a road can be made to resemble a swamp, hill, crevasse, or some other difficult or impassable terrain. A pond can be made to seem like a grassy meadow, a precipice like a gentle slope, or a rock-strewn gully like a wide and smooth road. Manufactured structures, equipment, and creatures within the area aren't changed.

The tactile characteristics of the terrain are unchanged, so creatures entering the area are likely to notice the illusion. If the difference isn't obvious by touch, a creature examining the illusion can take the Study action to make an Intelligence (Investigation) check against your spell save DC to disbelieve it. If a creature discerns that the terrain is illusory, the creature sees a vague image superimposed on the real terrain.
`,
      "Harm.md": `---
smType: spell
name: "Harm"
level: 6
school: "Necromancy"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "14d6"
damage_type: "Necrotic"
---

# Harm
Level 6 Necromancy

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric
- Save: CON (Half damage on success)
- Damage: 14d6 Necrotic

You unleash virulent magic on a creature you can see within range. The target makes a Constitution saving throw. On a failed save, it takes 14d6

Necrotic damage, and its Hit Point maximum is reduced by an amount equal to the Necrotic damage it took. On a successful save, it takes half as much damage only. This spell can't reduce a target's Hit Point maximum below 1.
`,
      "Haste.md": `---
smType: spell
name: "Haste"
level: 3
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a shaving of licorice root"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
---

# Haste
Level 3 Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a shaving of licorice root)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Sorcerer, Wizard
- Save: DEX

Choose a willing creature that you can see within range. Until the spell ends, the target's Speed is doubled, it gains a +2 bonus to Armor Class, it has Advantage on Dexterity saving throws, and it gains an additional action on each of its turns. That action can be used to take only the Attack (one attack only), Dash, Disengage, Hide, or Utilize action.

When the spell ends, the target is Incapacitated and has a Speed of 0 until the end of its next turn, as a wave of lethargy washes over it.
`,
      "Heal.md": `---
smType: spell
name: "Heal"
level: 6
school: "Abjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric", "Druid"]
---

# Heal
Level 6 Abjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric, Druid

Choose a creature that you can see within range. Positive energy washes through the target, restoring 70 Hit Points. This spell also ends the Blinded, Deafened, and Poisoned conditions on the target.
`,
      "Healing Word.md": `---
smType: spell
name: "Healing Word"
level: 1
school: "Abjuration"
casting_time: "Bonus Action"
range: "60 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid"]
---

# Healing Word
Level 1 Abjuration

- Casting Time: Bonus Action
- Range: 60 feet
- Components: V
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid

A creature of your choice that you can see within range regains Hit Points equal to 2d4 plus your spellcasting ability modifier.
`,
      "Heat Metal.md": `---
smType: spell
name: "Heat Metal"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a piece of iron and a flame"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Druid"]
save_ability: "CON"
damage: "2d8"
damage_type: "Fire"
---

# Heat Metal
Level 2 Transmutation

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a piece of iron and a flame)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Druid
- Save: CON
- Damage: 2d8 Fire

Choose a manufactured metal object, such as a metal weapon or a suit of Heavy or Medium metal armor, that you can see within range. You cause the object to glow red-hot. Any creature in physical contact with the object takes 2d8 Fire damage when you cast the spell. Until the spell ends, you can take a Bonus Action on each of your later turns to deal this damage again if the object is within range.

If a creature is holding or wearing the object and takes the damage from it, the creature must succeed on a Constitution saving throw or drop the object if it can. If it doesn't drop the object, it has Disadvantage on attack rolls and ability checks until the start of your next turn.
`,
      "Hellish Rebuke.md": `---
smType: spell
name: "Hellish Rebuke"
level: 1
school: "Evocation"
casting_time: "Reaction, which you take in response to taking damage from a creature that you can see within 60 feet of yourself"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Warlock"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "2d10"
damage_type: "Fire"
---

# Hellish Rebuke
Level 1 Evocation

- Casting Time: Reaction, which you take in response to taking damage from a creature that you can see within 60 feet of yourself
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Warlock
- Save: DEX (Half damage on success)
- Damage: 2d10 Fire

The creature that damaged you is momentarily surrounded by green flames. It makes a Dexterity saving throw, taking 2d10 Fire damage on a failed save or half as much damage on a successful one.
`,
      "Heroes' Feast.md": `---
smType: spell
name: "Heroes' Feast"
level: 6
school: "Conjuration"
casting_time: "10 minutes"
range: "Self"
components: ["V", "S", "M"]
materials: "a gem-encrusted bowl worth 1,000+ GP, which the spell consumes"
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid"]
---

# Heroes' Feast
Level 6 Conjuration

- Casting Time: 10 minutes
- Range: Self
- Components: V, S, M (a gem-encrusted bowl worth 1,000+ GP, which the spell consumes)
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid

You conjure a feast that appears on a surface in an unoccupied 10-foot Cube next to you. The feast takes 1 hour to consume and disappears at the end of that time, and the beneficial effects don't set in until this hour is over. Up to twelve creatures can partake of the feast.

A creature that partakes gains several benefits, which last for 24 hours. The creature has Resistance to Poison damage, and it has Immunity to the Frightened and Poisoned conditions. Its Hit Point maximum also increases by 2d10, and it gains the same number of Hit Points.
`,
      "Heroism.md": `---
smType: spell
name: "Heroism"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Paladin"]
---

# Heroism
Level 1 Enchantment

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Paladin

A willing creature you touch is imbued with bravery. Until the spell ends, the creature is immune to the Frightened condition and gains Temporary Hit Points equal to your spellcasting ability modifier at the start of each of its turns.
`,
      "Hex.md": `---
smType: spell
name: "Hex"
level: 1
school: "Enchantment"
casting_time: "Bonus Action"
range: "90 feet"
components: ["V", "S", "M"]
materials: "the petrified eye of a newt"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Warlock"]
damage: "1d6"
damage_type: "Necrotic"
---

# Hex
Level 1 Enchantment

- Casting Time: Bonus Action
- Range: 90 feet
- Components: V, S, M (the petrified eye of a newt)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Warlock
- Damage: 1d6 Necrotic

You place a curse on a creature that you can see within range. Until the spell ends, you deal an extra 1d6 Necrotic damage to the target whenever you hit it with an attack roll. Also, choose one ability when you cast the spell. The target has Disadvantage on ability checks made with the chosen ability.

If the target drops to 0 Hit Points before this spell ends, you can take a Bonus Action on a later turn to curse a new creature.
`,
      "Hideous Laughter.md": `---
smType: spell
name: "Hideous Laughter"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a tart and a feather"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Hideous Laughter
Level 1 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a tart and a feather)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Warlock, Wizard
- Save: WIS

One creature of your choice that you can see within range makes a Wisdom saving throw. On a failed save, it has the Prone and Incapacitated conditions for the duration. During that time, it laughs uncontrollably if it's capable of laughter, and it can't end the Prone condition on itself.

At the end of each of its turns and each time it takes damage, it makes another Wisdom saving throw. The target has Advantage on the save if the save is triggered by damage. On a successful save, the spell ends.
`,
      "Hold Monster.md": `---
smType: spell
name: "Hold Monster"
level: 5
school: "Enchantment"
casting_time: "Action"
range: "90 feet"
components: ["V", "S", "M"]
materials: "a straight piece of iron"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Hold Monster
Level 5 Enchantment

- Casting Time: Action
- Range: 90 feet
- Components: V, S, M (a straight piece of iron)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Warlock, Wizard
- Save: WIS

Choose a creature that you can see within range. The target must succeed on a Wisdom saving throw or have the Paralyzed condition for the duration. At the end of each of its turns, the target repeats the save, ending the spell on itself on a success.
`,
      "Hold Person.md": `---
smType: spell
name: "Hold Person"
level: 2
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a straight piece of iron"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Cleric", "Druid", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Hold Person
Level 2 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a straight piece of iron)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Cleric, Druid, Sorcerer, Warlock, Wizard
- Save: WIS

Choose a Humanoid that you can see within range. The target must succeed on a Wisdom saving throw or have the Paralyzed condition for the duration. At the end of each of its turns, the target repeats the save, ending the spell on itself on a success.
`,
      "Holy Aura.md": `---
smType: spell
name: "Holy Aura"
level: 8
school: "Abjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a reliquary worth 1,000+ GP"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric"]
save_ability: "CON"
---

# Holy Aura
Level 8 Abjuration

- Casting Time: Action
- Range: Self
- Components: V, S, M (a reliquary worth 1,000+ GP)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric
- Save: CON

For the duration, you emit an aura in a 30-foot Emanation. While in the aura, creatures of your choice have Advantage on all saving throws, and other creatures have Disadvantage on attack rolls against them. In addition, when a Fiend or an Undead hits an affected creature with a melee attack roll, the attacker must succeed on a Constitution saving throw or have the Blinded condition until the end of its next turn.
`,
      "Hunter's Mark.md": `---
smType: spell
name: "Hunter's Mark"
level: 1
school: "Divination"
casting_time: "Bonus Action"
range: "90 feet"
components: ["V"]
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Ranger"]
damage: "1d6"
damage_type: "Force"
---

# Hunter's Mark
Level 1 Divination

- Casting Time: Bonus Action
- Range: 90 feet
- Components: V
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Ranger
- Damage: 1d6 Force

You magically mark one creature you can see within range as your quarry. Until the spell ends, you deal an extra 1d6 Force damage to the target whenever you hit it with an attack roll. You also have Advantage on any Wisdom (Perception or Survival) check you make to find it.

If the target drops to 0 Hit Points before this spell ends, you can take a Bonus Action to move the mark to a new creature you can see within range.
`,
      "Hypnotic Pattern.md": `---
smType: spell
name: "Hypnotic Pattern"
level: 3
school: "Illusion"
casting_time: "Action"
range: "120 feet"
components: ["S", "M"]
materials: "a pinch of confetti"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Hypnotic Pattern
Level 3 Illusion

- Casting Time: Action
- Range: 120 feet
- Components: S, M (a pinch of confetti)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Warlock, Wizard
- Save: WIS

You create a twisting pattern of colors in a 30-foot Cube within range. The pattern appears for a moment and vanishes. Each creature in the area who can see the pattern must succeed on a Wisdom saving throw or have the Charmed condition for the duration. While Charmed, the creature has the Incapacitated condition and a Speed of 0.

The spell ends for an affected creature if it takes any damage or if someone else uses an action to shake the creature out of its stupor.

### I Spells
`,
      "Ice Knife.md": `---
smType: spell
name: "Ice Knife"
level: 1
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["S", "M"]
materials: "a drop of water or a piece of ice"
duration: "Instantaneous"
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "DEX"
attack: "ranged spell attack"
damage: "1d10"
damage_type: "Piercing"
---

# Ice Knife
Level 1 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: S, M (a drop of water or a piece of ice)
- Duration: Instantaneous
- Classes: Druid, Sorcerer, Wizard
- Attack: ranged spell attack
- Save: DEX
- Damage: 1d10 Piercing

You create a shard of ice and fling it at one creature within range. Make a ranged spell attack against the target. On a hit, the target takes 1d10 Piercing damage. Hit or miss, the shard then explodes. The target and each creature within 5 feet of it must succeed on a Dexterity saving throw or take 2d6 Cold damage.
`,
      "Ice Storm.md": `---
smType: spell
name: "Ice Storm"
level: 4
school: "Evocation"
casting_time: "Action"
range: "300 feet"
components: ["V", "S", "M"]
materials: "a mitten"
duration: "Instantaneous"
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "2d10"
damage_type: "Bludgeoning"
---

# Ice Storm
Level 4 Evocation

- Casting Time: Action
- Range: 300 feet
- Components: V, S, M (a mitten)
- Duration: Instantaneous
- Classes: Druid, Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 2d10 Bludgeoning

Hail falls in a 20-foot-radius, 40-foot-high Cylinder centered on a point within range. Each creature in the Cylinder makes a Dexterity saving throw. A creature takes 2d10 Bludgeoning damage and 4d6 Cold damage on a failed save or half as much damage on a successful one.

Hailstones turn ground in the Cylinder into Difficult Terrain until the end of your next turn.
`,
      "Identify.md": `---
smType: spell
name: "Identify"
level: 1
school: "Divination"
casting_time: "1 minute or Ritual"
range: "Touch"
components: ["V", "S", "M"]
materials: "a pearl worth 100+ GP"
duration: "Instantaneous"
ritual: true
classes: ["Bard", "Wizard"]
---

# Identify
Level 1 Divination

- Casting Time: 1 minute or Ritual
- Range: Touch
- Components: V, S, M (a pearl worth 100+ GP)
- Duration: Instantaneous
- Ritual: yes
- Classes: Bard, Wizard

You touch an object throughout the spell's casting. If the object is a magic item or some other magical object, you learn its properties and how to use them, whether it requires Attunement, and how many charges it has, if any. You learn whether any ongoing spells are affecting the item and what they are. If the item was created by a spell, you learn that spell's name.

If you instead touch a creature throughout the casting, you learn which ongoing spells, if any, are currently affecting it.
`,
      "Illusory Script.md": `---
smType: spell
name: "Illusory Script"
level: 1
school: "Illusion"
casting_time: "1 minute or Ritual"
range: "Touch"
components: ["S", "M"]
materials: "ink worth 10+ GP, which the spell consumes"
duration: "10 days"
ritual: true
classes: ["Bard", "Warlock", "Wizard"]
---

# Illusory Script
Level 1 Illusion

- Casting Time: 1 minute or Ritual
- Range: Touch
- Components: S, M (ink worth 10+ GP, which the spell consumes)
- Duration: 10 days
- Ritual: yes
- Classes: Bard, Warlock, Wizard

You write on parchment, paper, or another suitable material and imbue it with an illusion that lasts for the duration. To you and any creatures you designate when you cast the spell, the writing appears normal, seems to be written in your hand, and conveys whatever meaning you intended when you wrote the text. To all others, the writing appears as if it were written in an unknown or magical script that is unintelligible. Alternatively, the illusion can alter the meaning, handwriting, and language of the text, though the language must be one you know.

If the spell is dispelled, the original script and the illusion both disappear.

A creature that has Truesight can read the hidden message.
`,
      "Imprisonment.md": `---
smType: spell
name: "Imprisonment"
level: 9
school: "Abjuration"
casting_time: "1 minute"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a statuette of the target worth 5,000+ GP"
duration: "Until dispelled"
classes: ["Warlock", "Wizard"]
save_ability: "WIS"
---

# Imprisonment
Level 9 Abjuration

- Casting Time: 1 minute
- Range: 30 feet
- Components: V, S, M (a statuette of the target worth 5,000+ GP)
- Duration: Until dispelled
- Classes: Warlock, Wizard
- Save: WIS

You create a magical restraint to hold a creature that you can see within range. The target must make a Wisdom saving throw. On a successful save, the target is unaffected, and it is immune to this

spell for the next 24 hours. On a failed save, the target is imprisoned. While imprisoned, the target doesn't need to breathe, eat, or drink, and it doesn't age. Divination spells can't locate or perceive the imprisoned target, and the target can't teleport.

Until the spell ends, the target is also affected by one of the following effects of your choice:

**Burial.** The target is entombed beneath the earth in a hollow globe of magical force that is just large enough to contain the target. Nothing can pass into or out of the globe.

**Chaining.** Chains firmly rooted in the ground hold the target in place. The target has the Restrained condition and can't be moved by any means.

**Hedged Prison.** The target is trapped in a demiplane that is warded against teleportation and planar travel. The demiplane is your choice of a labyrinth, a cage, a tower, or the like.

**Minimus Containment.** The target becomes 1 inch tall and is trapped inside an indestructible gemstone or a similar object. Light can pass through the gemstone (allowing the target to see out and other creatures to see in), but nothing else can pass through by any means.

**Slumber.** The target has the Unconscious condition and can't be awoken.

**_Ending the Spell._** When you cast the spell, specify a trigger that will end it. The trigger can be as simple or as elaborate as you choose, but the GM must agree that it has a high likelihood of happening within the next decade. The trigger must be an observable action, such as someone making a particular offering at the temple of your god, saving your true love, or defeating a specific monster.

A *Dispel Magic* spell can end the spell only if it is cast with a level 9 spell slot, targeting either the prison or the component used to create it.
`,
      "Incendiary Cloud.md": `---
smType: spell
name: "Incendiary Cloud"
level: 8
school: "Conjuration"
casting_time: "Action"
range: "150 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "10d8"
damage_type: "Fire"
---

# Incendiary Cloud
Level 8 Conjuration

- Casting Time: Action
- Range: 150 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 10d8 Fire

A swirling cloud of embers and smoke fills a 20-foot-radius Sphere centered on a point within range. The cloud's area is Heavily Obscured. It lasts for the duration or until a strong wind (like that created by *Gust of Wind*) disperses it.

When the cloud appears, each creature in it makes a Dexterity saving throw, taking 10d8 Fire damage on a failed save or half as much damage on a successful one. A creature must also make this save when the Sphere moves into its space and when it enters the Sphere or ends its turn there. A creature makes this save only once per turn.

The cloud moves 10 feet away from you in a direction you choose at the start of each of your turns.
`,
      "Inflict Wounds.md": `---
smType: spell
name: "Inflict Wounds"
level: 1
school: "Necromancy"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "2d10"
damage_type: "Necrotic"
---

# Inflict Wounds
Level 1 Necromancy

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric
- Save: CON (Half damage on success)
- Damage: 2d10 Necrotic

A creature you touch makes a Constitution saving throw, taking 2d10 Necrotic damage on a failed save or half as much damage on a successful one.
`,
      "Insect Plague.md": `---
smType: spell
name: "Insect Plague"
level: 5
school: "Conjuration"
casting_time: "Action"
range: "300 feet"
components: ["V", "S", "M"]
materials: "a locust"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Cleric", "Druid", "Sorcerer"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "4d10"
damage_type: "Piercing"
---

# Insect Plague
Level 5 Conjuration

- Casting Time: Action
- Range: 300 feet
- Components: V, S, M (a locust)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Cleric, Druid, Sorcerer
- Save: CON (Half damage on success)
- Damage: 4d10 Piercing

Swarming locusts fill a 20-foot-radius Sphere centered on a point you choose within range. The Sphere remains for the duration, and its area is Lightly Obscured and Difficult Terrain.

When the swarm appears, each creature in it makes a Constitution saving throw, taking 4d10 Piercing damage on a failed save or half as much damage on a successful one. A creature also makes this save when it enters the spell's area for the first time on a turn or ends its turn there. A creature makes this save only once per turn.
`,
      "Instant Summons.md": `---
smType: spell
name: "Instant Summons"
level: 6
school: "Conjuration"
casting_time: "1 minute or Ritual"
range: "Touch"
components: ["V", "S", "M"]
materials: "a sapphire worth 1,000+ GP"
duration: "Until dispelled"
ritual: true
classes: ["Wizard"]
---

# Instant Summons
Level 6 Conjuration

- Casting Time: 1 minute or Ritual
- Range: Touch
- Components: V, S, M (a sapphire worth 1,000+ GP)
- Duration: Until dispelled
- Ritual: yes
- Classes: Wizard

You touch the sapphire used in the casting and an object weighing 10 pounds or less whose longest dimension is 6 feet or less. The spell leaves an Invisible mark on that object and invisibly inscribes the object's name on the sapphire. Each time you cast this spell, you must use a different sapphire.

Thereafter, you can take a Magic action to speak the object's name and crush the sapphire. The object instantly appears in your hand regardless of physical or planar distances, and the spell ends.

If another creature is holding or carrying the object, crushing the sapphire doesn't transport it, but instead you learn who that creature is and where that creature is currently located.
`,
      "Invisibility.md": `---
smType: spell
name: "Invisibility"
level: 2
school: "Illusion"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "an eyelash in gum arabic"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# Invisibility
Level 2 Illusion

- Casting Time: Action
- Range: Touch
- Components: V, S, M (an eyelash in gum arabic)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Bard, Sorcerer, Warlock, Wizard

A creature you touch has the Invisible condition until the spell ends. The spell ends early immediately after the target makes an attack roll, deals damage, or casts a spell.

## At Higher Levels

### J,K and L Spells
`,
      "Irresistible Dance.md": `---
smType: spell
name: "Irresistible Dance"
level: 6
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Wizard"]
save_ability: "WIS"
---

# Irresistible Dance
Level 6 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Wizard
- Save: WIS

One creature that you can see within range must make a Wisdom saving throw. On a successful save, the target dances comically until the end of its next turn, during which it must spend all its movement to dance in place.

On a failed save, the target has the Charmed condition for the duration. While Charmed, the target dances comically, must use all its movement to dance in place, and has Disadvantage on Dexterity saving throws and attack rolls, and other creatures have Advantage on attack rolls against it. On each of its turns, the target can take an action to collect itself and repeat the save, ending the spell on itself on a success.
`,
      "Jump.md": `---
smType: spell
name: "Jump"
level: 1
school: "Transmutation"
casting_time: "Bonus Action"
range: "Touch"
duration: "1 minute"
classes: ["Druid", "Ranger", "Sorcerer", "Wizard"]
---

# Jump
Level 1 Transmutation

- Casting Time: Bonus Action
- Range: Touch
- Duration: 1 minute
- Classes: Druid, Ranger, Sorcerer, Wizard

You touch a willing creature. Once on each of its turns until the spell ends, that creature can jump up to 30 feet by spending 10 feet of movement.
`,
      "Knock.md": `---
smType: spell
name: "Knock"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "60 feet"
components: ["V"]
duration: "Instantaneous Choose an object that you can see within range. The object can be a door, a box, a chest, a set of manacles, a padlock, or another object that contains a mundane or magical means that prevents access."
classes: ["Bard", "Sorcerer", "Wizard"]
---

# Knock
Level 2 Transmutation

- Casting Time: Action
- Range: 60 feet
- Components: V
- Duration: Instantaneous Choose an object that you can see within range. The object can be a door, a box, a chest, a set of manacles, a padlock, or another object that contains a mundane or magical means that prevents access.
- Classes: Bard, Sorcerer, Wizard

A target that is held shut by a mundane lock or that is stuck or barred becomes unlocked, unstuck, or unbarred. If the object has multiple locks, only one of them is unlocked.

If the target is held shut by *Arcane Lock*, that spell is suppressed for 10 minutes, during which time the target can be opened and closed.

When you cast the spell, a loud knock, audible up to 300 feet away, emanates from the target.
`,
      "Legend Lore.md": `---
smType: spell
name: "Legend Lore"
level: 5
school: "Divination"
casting_time: "10 minutes"
range: "Self"
components: ["V", "S", "M"]
materials: "incense worth 250+ GP, which the spell consumes, and four ivory strips worth 50+ GP each"
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Wizard"]
---

# Legend Lore
Level 5 Divination

- Casting Time: 10 minutes
- Range: Self
- Components: V, S, M (incense worth 250+ GP, which the spell consumes, and four ivory strips worth 50+ GP each)
- Duration: Instantaneous
- Classes: Bard, Cleric, Wizard

Name or describe a famous person, place, or object. The spell brings to your mind a brief summary of the significant lore about that famous thing, as described by the GM.

The lore might consist of important details, amusing revelations, or even secret lore that has never been widely known. The more information you already know about the thing, the more precise and detailed the information you receive is. That information is accurate but might be couched in figurative language or poetry, as determined by the GM.

If the famous thing you chose isn't actually famous, you hear sad musical notes played on a trombone, and the spell fails.
`,
      "Lesser Restoration.md": `---
smType: spell
name: "Lesser Restoration"
level: 2
school: "Abjuration"
casting_time: "Bonus Action"
range: "Touch"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger"]
---

# Lesser Restoration
Level 2 Abjuration

- Casting Time: Bonus Action
- Range: Touch
- Components: V, S
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid, Paladin, Ranger

You touch a creature and end one condition on it: Blinded, Deafened, Paralyzed, or Poisoned.
`,
      "Levitate.md": `---
smType: spell
name: "Levitate"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a metal spring"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Sorcerer", "Wizard"]
save_ability: "CON"
---

# Levitate
Level 2 Transmutation

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a metal spring)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Sorcerer, Wizard
- Save: CON

One creature or loose object of your choice that you can see within range rises vertically up to 20 feet and remains suspended there for the duration. The spell can levitate an object that weighs up to 500 pounds. An unwilling creature that succeeds on a Constitution saving throw is unaffected.

The target can move only by pushing or pulling against a fixed object or surface within reach (such as a wall or a ceiling), which allows it to move as if it were climbing. You can change the target's altitude by up to 20 feet in either direction on your turn. If you are the target, you can move up or down as part of your move. Otherwise, you can take a Magic action to move the target, which must remain within the spell's range.

When the spell ends, the target floats gently to the ground if it is still aloft.
`,
      "Light.md": `---
smType: spell
name: "Light"
level: 0
school: "Evocation"
casting_time: "Action"
range: "Touch"
components: ["V", "M"]
materials: "a firefly or phosphorescent moss"
duration: "1 hour"
classes: ["Bard", "Cleric", "Sorcerer", "Wizard"]
---

# Light
Cantrip Evocation

- Casting Time: Action
- Range: Touch
- Components: V, M (a firefly or phosphorescent moss)
- Duration: 1 hour
- Classes: Bard, Cleric, Sorcerer, Wizard

You touch one Large or smaller object that isn't being worn or carried by someone else. Until the spell ends, the object sheds Bright Light in a 20-foot radius and Dim Light for an additional 20 feet. The light can be colored as you like.

Covering the object with something opaque blocks the light. The spell ends if you cast it again.
`,
      "Lightning Bolt.md": `---
smType: spell
name: "Lightning Bolt"
level: 3
school: "Evocation"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a bit of fur and a crystal rod"
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "8d6"
damage_type: "Lightning"
---

# Lightning Bolt
Level 3 Evocation

- Casting Time: Action
- Range: Self
- Components: V, S, M (a bit of fur and a crystal rod)
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 8d6 Lightning

A stroke of lightning forming a 100-foot-long, 5-foot-wide Line blasts out from you in a direction you choose. Each creature in the Line makes a Dexterity saving throw, taking 8d6 Lightning damage on a failed save or half as much damage on a successful one.
`,
      "Locate Animals or Plants.md": `---
smType: spell
name: "Locate Animals or Plants"
level: 2
school: "Divination"
casting_time: "Action or Ritual"
range: "Self"
components: ["V", "S", "M"]
materials: "fur from a bloodhound"
duration: "Instantaneous"
ritual: true
classes: ["Bard", "Druid", "Ranger"]
---

# Locate Animals or Plants
Level 2 Divination

- Casting Time: Action or Ritual
- Range: Self
- Components: V, S, M (fur from a bloodhound)
- Duration: Instantaneous
- Ritual: yes
- Classes: Bard, Druid, Ranger

Describe or name a specific kind of Beast, Plant creature, or nonmagical plant. You learn the direction and distance to the closest creature or plant of that kind within 5 miles, if any are present.
`,
      "Locate Creature.md": `---
smType: spell
name: "Locate Creature"
level: 4
school: "Divination"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "fur from a bloodhound"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger", "Wizard"]
---

# Locate Creature
Level 4 Divination

- Casting Time: Action
- Range: Self
- Components: V, S, M (fur from a bloodhound)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Bard, Cleric, Druid, Paladin, Ranger, Wizard

Describe or name a creature that is familiar to you. You sense the direction to the creature's location if that creature is within 1,000 feet of you. If the creature is moving, you know the direction of its movement.

The spell can locate a specific creature known to you or the nearest creature of a specific kind (such as a human or a unicorn) if you have seen such a creature up close\u2014within 30 feet\u2014at least once. If the creature you described or named is in a different form, such as under the effects of a *Flesh to Stone* or *Polymorph* spell, this spell doesn't locate the creature.

This spell can't locate a creature if any thickness of lead blocks a direct path between you and the creature.
`,
      "Locate Object.md": `---
smType: spell
name: "Locate Object"
level: 2
school: "Divination"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a forked twig"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger", "Wizard"]
---

# Locate Object
Level 2 Divination

- Casting Time: Action
- Range: Self
- Components: V, S, M (a forked twig)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Bard, Cleric, Druid, Paladin, Ranger, Wizard

Describe or name an object that is familiar to you. You sense the direction to the object's location if that object is within 1,000 feet of you. If the object is in motion, you know the direction of its movement.

The spell can locate a specific object known to you if you have seen it up close\u2014within 30 feet\u2014at least once. Alternatively, the spell can locate the nearest object of a particular kind, such as a certain kind of apparel, jewelry, furniture, tool, or weapon.

This spell can't locate an object if any thickness of lead blocks a direct path between you and the object.
`,
      "Longstrider.md": `---
smType: spell
name: "Longstrider"
level: 1
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a pinch of dirt"
duration: "1 hour"
classes: ["Bard", "Druid", "Ranger", "Wizard"]
---

# Longstrider
Level 1 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a pinch of dirt)
- Duration: 1 hour
- Classes: Bard, Druid, Ranger, Wizard

You touch a creature. The target's Speed increases by 10 feet until the spell ends.

## At Higher Levels

### M and N Spells
`,
      "Mage Armor.md": `---
smType: spell
name: "Mage Armor"
level: 1
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a piece of cured leather"
duration: "8 hours"
classes: ["Sorcerer", "Wizard"]
---

# Mage Armor
Level 1 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a piece of cured leather)
- Duration: 8 hours
- Classes: Sorcerer, Wizard

You touch a willing creature who isn't wearing armor. Until the spell ends, the target's base AC becomes 13 plus its Dexterity modifier. The spell ends early if the target dons armor.
`,
      "Mage Hand.md": `---
smType: spell
name: "Mage Hand"
level: 0
school: "Conjuration"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "1 minute"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# Mage Hand
Cantrip Conjuration

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: 1 minute
- Classes: Bard, Sorcerer, Warlock, Wizard

A spectral, floating hand appears at a point you choose within range. The hand lasts for the duration. The hand vanishes if it is ever more than 30 feet away from you or if you cast this spell again.

When you cast the spell, you can use the hand to manipulate an object, open an unlocked door or container, stow or retrieve an item from an open container, or pour the contents out of a vial.

As a Magic action on your later turns, you can control the hand thus again. As part of that action, you can move the hand up to 30 feet.

The hand can't attack, activate magic items, or carry more than 10 pounds.
`,
      "Magic Circle.md": `---
smType: spell
name: "Magic Circle"
level: 3
school: "Abjuration"
casting_time: "1 minute"
range: "10 feet"
components: ["V", "S", "M"]
materials: "salt and powdered silver worth 100+ GP, which the spell consumes"
duration: "1 hour"
classes: ["Cleric", "Paladin", "Warlock", "Wizard"]
save_ability: "CHA"
---

# Magic Circle
Level 3 Abjuration

- Casting Time: 1 minute
- Range: 10 feet
- Components: V, S, M (salt and powdered silver worth 100+ GP, which the spell consumes)
- Duration: 1 hour
- Classes: Cleric, Paladin, Warlock, Wizard
- Save: CHA

You create a 10-foot-radius, 20-foot-tall Cylinder of magical energy centered on a point on the ground that you can see within range. Glowing runes appear wherever the Cylinder intersects with the floor or other surface.

Choose one or more of the following types of creatures: Celestials, Elementals, Fey, Fiends, or Undead. The circle affects a creature of the chosen type in the following ways:

- The creature can't willingly enter the Cylinder by nonmagical means. If the creature tries to use teleportation or interplanar travel to do so, it must first succeed on a Charisma saving throw.

- The creature has Disadvantage on attack rolls against targets within the Cylinder.

- Targets within the Cylinder can't be possessed by or gain the Charmed or Frightened condition from the creature.

Each time you cast this spell, you can cause its magic to operate in the reverse direction, preventing a creature of the specified type from leaving the Cylinder and protecting targets outside it.
`,
      "Magic Jar.md": `---
smType: spell
name: "Magic Jar"
level: 6
school: "Necromancy"
casting_time: "1 minute"
range: "Self"
components: ["V", "S", "M"]
materials: "a gem, crystal, or reliquary worth 500+ GP"
duration: "Until dispelled"
classes: ["Wizard"]
save_ability: "CHA"
---

# Magic Jar
Level 6 Necromancy

- Casting Time: 1 minute
- Range: Self
- Components: V, S, M (a gem, crystal, or reliquary worth 500+ GP)
- Duration: Until dispelled
- Classes: Wizard
- Save: CHA

Your body falls into a catatonic state as your soul leaves it and enters the container you used for the spell's Material component. While your soul inhabits the container, you are aware of your surroundings as if you were in the container's space. You can't move or take Reactions. The only action you can take is to project your soul up to 100 feet out of the container, either returning to your living body (and ending the spell) or attempting to possess a Humanoid's body.

You can attempt to possess any Humanoid within 100 feet of you that you can see (creatures warded by a *Protection from Evil and Good* or *Magic Circle* spell can't be possessed). The target makes a Charisma saving throw. On a failed save, your soul enters the target's body, and the target's soul becomes trapped in the container. On a successful save, the target resists your efforts to possess it, and you can't attempt to possess it again for 24 hours.

Once you possess a creature's body, you control it. Your Hit Points, Hit Point Dice, Strength, Dexterity, Constitution, Speed, and senses are replaced by the creature's. You otherwise keep your game statistics.

Meanwhile, the possessed creature's soul can perceive from the container using its own senses, but it can't move and it is Incapacitated.

While possessing a body, you can take a Magic action to return from the host body to the container if it is within 100 feet of you, returning the host creature's soul to its body. If the host body dies while you're in it, the creature dies, and you make a Charisma saving throw against your own spellcasting DC. On a success, you return to the container if it is within 100 feet of you. Otherwise, you die.

If the container is destroyed or the spell ends, your soul returns to your body. If your body is more than 100 feet away from you or if your body is dead, you die. If another creature's soul is in the container when it is destroyed, the creature's soul returns to its body if the body is alive and within 100 feet. Otherwise, that creature dies.

When the spell ends, the container is destroyed.
`,
      "Magic Missile.md": `---
smType: spell
name: "Magic Missile"
level: 1
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
damage: "1d4 + 1"
damage_type: "Force"
---

# Magic Missile
Level 1 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Damage: 1d4 + 1 Force

You create three glowing darts of magical force. Each dart strikes a creature of your choice that you can see within range. A dart deals 1d4 + 1 Force damage to its target. The darts all strike simultaneously, and you can direct them to hit one creature or several.
`,
      "Magic Mouth.md": `---
smType: spell
name: "Magic Mouth"
level: 2
school: "Illusion"
casting_time: "1 minute or Ritual"
range: "30 feet"
components: ["V", "S", "M"]
materials: "jade dust worth 10+ GP, which the spell consumes"
duration: "Until dispelled"
ritual: true
classes: ["Bard", "Wizard"]
---

# Magic Mouth
Level 2 Illusion

- Casting Time: 1 minute or Ritual
- Range: 30 feet
- Components: V, S, M (jade dust worth 10+ GP, which the spell consumes)
- Duration: Until dispelled
- Ritual: yes
- Classes: Bard, Wizard

You implant a message within an object in range\u2014a message that is uttered when a trigger condition is met. Choose an object that you can see and that isn't being worn or carried by another creature. Then speak the message, which must be 25 words or fewer, though it can be delivered over as long as 10 minutes. Finally, determine the circumstance that will trigger the spell to deliver your message.

When that trigger occurs, a magical mouth appears on the object and recites the message in your voice and at the same volume you spoke. If the object you chose has a mouth or something that looks like a mouth (for example, the mouth of a statue), the magical mouth appears there, so the words appear to come from the object's mouth. When you cast this spell, you can have the spell end after it delivers its message, or it can remain and repeat its message whenever the trigger occurs.

The trigger can be as general or as detailed as you like, though it must be based on visual or audible conditions that occur within 30 feet of the object. For example, you could instruct the mouth to speak when any creature moves within 30 feet of the object or when a silver bell rings within 30 feet of it.
`,
      "Magic Weapon.md": `---
smType: spell
name: "Magic Weapon"
level: 2
school: "Transmutation"
casting_time: "Bonus Action"
range: "Touch"
components: ["V", "S"]
duration: "1 hour"
classes: ["Paladin", "Ranger", "Sorcerer", "Wizard"]
---

# Magic Weapon
Level 2 Transmutation

- Casting Time: Bonus Action
- Range: Touch
- Components: V, S
- Duration: 1 hour
- Classes: Paladin, Ranger, Sorcerer, Wizard

You touch a nonmagical weapon. Until the spell ends, that weapon becomes a magic weapon with a +1 bonus to attack rolls and damage rolls. The spell ends early if you cast it again.
`,
      "Magnificent Mansion.md": `---
smType: spell
name: "Magnificent Mansion"
level: 7
school: "Conjuration"
casting_time: "1 minute"
range: "300 feet"
components: ["V", "S", "M"]
materials: "a miniature door worth 15+ GP"
duration: "24 hours"
classes: ["Bard", "Wizard"]
---

# Magnificent Mansion
Level 7 Conjuration

- Casting Time: 1 minute
- Range: 300 feet
- Components: V, S, M (a miniature door worth 15+ GP)
- Duration: 24 hours
- Classes: Bard, Wizard

You conjure a shimmering door in range that lasts for the duration. The door leads to an extradimensional dwelling and is 5 feet wide and 10 feet tall. You and any creature you designate when you cast the spell can enter the extradimensional dwelling as long as the door remains open. You can open or close it (no action required) if you are within 30 feet of it. While closed, the door is imperceptible.

Beyond the door is a magnificent foyer with numerous chambers beyond. The dwelling's atmosphere is clean, fresh, and warm.

You can create any floor plan you like for the dwelling, but it can't exceed 50 contiguous 10-foot Cubes. The place is furnished and decorated as you choose. It contains sufficient food to serve a ninecourse banquet for up to 100 people. Furnishings and other objects created by this spell dissipate into smoke if removed from it.

A staff of 100 near-transparent servants attends all who enter. You determine the appearance of these servants and their attire. They are invulnerable and obey your commands. Each servant can perform tasks that a human could perform, but they can't attack or take any action that would directly harm another creature. Thus the servants can fetch things, clean, mend, fold clothes, light fires, serve food, pour wine, and so on. The servants can't leave the dwelling.

When the spell ends, any creatures or objects left inside the extradimensional space are expelled into the unoccupied spaces nearest to the entrance.
`,
      "Major Image.md": `---
smType: spell
name: "Major Image"
level: 3
school: "Illusion"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a bit of fleece"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# Major Image
Level 3 Illusion

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a bit of fleece)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Bard, Sorcerer, Warlock, Wizard

You create the image of an object, a creature, or some other visible phenomenon that is no larger than a 20-foot Cube. The image appears at a spot that you can see within range and lasts for the duration. It seems real, including sounds, smells, and temperature appropriate to the thing depicted, but it can't deal damage or cause conditions.

If you are within range of the illusion, you can take a Magic action to cause the image to move to any other spot within range. As the image changes location, you can alter its appearance so that its movements appear natural for the image. For example, if you create an image of a creature and move it, you can alter the image so that it appears to be walking. Similarly, you can cause the illusion to make different sounds at different times, even making it carry on a conversation, for example.

Physical interaction with the image reveals it to be an illusion, for things can pass through it. A creature that takes a Study action to examine the image can determine that it is an illusion with a successful Intelligence (Investigation) check against your spell save DC. If a creature discerns the illusion for what it is, the creature can see through the image, and its other sensory qualities become faint to the creature.
`,
      "Mass Cure Wounds.md": `---
smType: spell
name: "Mass Cure Wounds"
level: 5
school: "Abjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid"]
---

# Mass Cure Wounds
Level 5 Abjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid

A wave of healing energy washes out from a point you can see within range. Choose up to six creatures in a 30-foot-radius Sphere centered on that point. Each target regains Hit Points equal to 5d8 plus your spellcasting ability modifier.
`,
      "Mass Heal.md": `---
smType: spell
name: "Mass Heal"
level: 9
school: "Abjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric"]
---

# Mass Heal
Level 9 Abjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric

A flood of healing energy flows from you into creatures around you. You restore up to 700 Hit Points, divided as you choose among any number of creatures that you can see within range. Creatures healed by this spell also have the Blinded, Deafened, and Poisoned conditions removed from them.
`,
      "Mass Healing Word.md": `---
smType: spell
name: "Mass Healing Word"
level: 3
school: "Abjuration"
casting_time: "Bonus Action"
range: "60 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Bard", "Cleric"]
---

# Mass Healing Word
Level 3 Abjuration

- Casting Time: Bonus Action
- Range: 60 feet
- Components: V
- Duration: Instantaneous
- Classes: Bard, Cleric

Up to six creatures of your choice that you can see within range regain Hit Points equal to 2d4 plus your spellcasting ability modifier.
`,
      "Mass Suggestion.md": `---
smType: spell
name: "Mass Suggestion"
level: 6
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "M"]
materials: "a snake's tongue"
duration: "24 hours"
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "WIS"
---

# Mass Suggestion
Level 6 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, M (a snake's tongue)
- Duration: 24 hours
- Classes: Bard, Sorcerer, Wizard
- Save: WIS

You suggest a course of activity\u2014described in no more than 25 words\u2014to twelve or fewer creatures you can see within range that can hear and understand you. The suggestion must sound achievable and not involve anything that would obviously deal damage to any of the targets or their allies. For example, you could say, "Walk to the village down that road, and help the villagers there harvest crops until sunset." Or you could say, "Now is not the time for violence. Drop your weapons, and dance! Stop in an hour."

Each target must succeed on a Wisdom saving throw or have the Charmed condition for the duration or until you or your allies deal damage to the target. Each Charmed target pursues the suggestion to the best of its ability. The suggested activity can continue for the entire duration, but if the suggested activity can be completed in a shorter time, the spell ends for a target upon completing it.
`,
      "Maze.md": `---
smType: spell
name: "Maze"
level: 8
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Wizard"]
---

# Maze
Level 8 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Wizard

You banish a creature that you can see within range into a labyrinthine demiplane. The target remains there for the duration or until it escapes the maze.

The target can take a Study action to try to escape. When it does so, it makes a DC 20 Intelligence (Investigation) check. If it succeeds, it escapes, and the spell ends.

When the spell ends, the target reappears in the space it left or, if that space is occupied, in the nearest unoccupied space.
`,
      "Meld into Stone.md": `---
smType: spell
name: "Meld into Stone"
level: 3
school: "Transmutation"
casting_time: "Action or Ritual"
range: "Touch"
components: ["V", "S"]
duration: "8 hours"
ritual: true
classes: ["Cleric", "Druid", "Ranger"]
damage: "6d6"
damage_type: "Force"
---

# Meld into Stone
Level 3 Transmutation

- Casting Time: Action or Ritual
- Range: Touch
- Components: V, S
- Duration: 8 hours
- Ritual: yes
- Classes: Cleric, Druid, Ranger
- Damage: 6d6 Force

You step into a stone object or surface large enough to fully contain your body, merging yourself and your equipment with the stone for the duration. You must touch the stone to do so. Nothing of your presence remains visible or otherwise detectable by nonmagical senses.

While merged with the stone, you can't see what occurs outside it, and any Wisdom (Perception) checks you make to hear sounds outside it are made with Disadvantage. You remain aware of the passage of time and can cast spells on yourself while merged in the stone. You can use 5 feet of movement to leave the stone where you entered it, which ends the spell. You otherwise can't move.

Minor physical damage to the stone doesn't harm you, but its partial destruction or a change in its shape (to the extent that you no longer fit within it) expels you and deals 6d6 Force damage to you. The stone's complete destruction (or transmutation into a different substance) expels you and deals 50 Force damage to you. If expelled, you move into an unoccupied space closest to where you first entered and have the Prone condition.
`,
      "Mending.md": `---
smType: spell
name: "Mending"
level: 0
school: "Transmutation"
casting_time: "1 minute"
range: "Touch"
components: ["V", "S", "M"]
materials: "two lodestones"
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Druid", "Sorcerer", "Wizard"]
---

# Mending
Cantrip Transmutation

- Casting Time: 1 minute
- Range: Touch
- Components: V, S, M (two lodestones)
- Duration: Instantaneous
- Classes: Bard, Cleric, Druid, Sorcerer, Wizard

This spell repairs a single break or tear in an object you touch, such as a broken chain link, two halves of a broken key, a torn cloak, or a leaking wineskin. As long as the break or tear is no larger than 1 foot in any dimension, you mend it, leaving no trace of the former damage.

This spell can physically repair a magic item, but it can't restore magic to such an object.
`,
      "Message.md": `---
smType: spell
name: "Message"
level: 0
school: "Transmutation"
casting_time: "Action"
range: "120 feet"
components: ["S", "M"]
materials: "a copper wire"
duration: "1 round"
classes: ["Bard", "Druid", "Sorcerer", "Wizard"]
---

# Message
Cantrip Transmutation

- Casting Time: Action
- Range: 120 feet
- Components: S, M (a copper wire)
- Duration: 1 round
- Classes: Bard, Druid, Sorcerer, Wizard

You point toward a creature within range and whisper a message. The target (and only the target) hears the message and can reply in a whisper that only you can hear.

You can cast this spell through solid objects if you are familiar with the target and know it is beyond the barrier. Magical silence; 1 foot of stone, metal, or wood; or a thin sheet of lead blocks the spell.
`,
      "Meteor Swarm.md": `---
smType: spell
name: "Meteor Swarm"
level: 9
school: "Evocation"
casting_time: "Action"
range: "1 mile"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "20d6"
damage_type: "Fire"
---

# Meteor Swarm
Level 9 Evocation

- Casting Time: Action
- Range: 1 mile
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 20d6 Fire

Blazing orbs of fire plummet to the ground at four different points you can see within range. Each creature in a 40-foot-radius Sphere centered on each of those points makes a Dexterity saving throw. A creature takes 20d6 Fire damage and 20d6 Bludgeoning damage on a failed save or half as much damage on a successful one. A creature in the area of more than one fiery Sphere is affected only once.

A nonmagical object that isn't being worn or carried also takes the damage if it's in the spell's area, and the object starts burning if it's flammable.
`,
      "Mind Blank.md": `---
smType: spell
name: "Mind Blank"
level: 8
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "24 hours"
classes: ["Bard", "Wizard"]
---

# Mind Blank
Level 8 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: 24 hours
- Classes: Bard, Wizard

Until the spell ends, one willing creature you touch has Immunity to Psychic damage and the Charmed condition. The target is also unaffected by anything that would sense its emotions or alignment, read its thoughts, or magically detect its location, and no spell\u2014not even *Wish*\u2014can gather information about the target, observe it remotely, or control its mind.
`,
      "Mind Spike.md": `---
smType: spell
name: "Mind Spike"
level: 2
school: "Divination"
casting_time: "Action"
range: "120 feet"
components: ["S"]
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
save_effect: "Half damage on success"
damage: "3d8"
damage_type: "Psychic"
---

# Mind Spike
Level 2 Divination

- Casting Time: Action
- Range: 120 feet
- Components: S
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Sorcerer, Warlock, Wizard
- Save: WIS (Half damage on success)
- Damage: 3d8 Psychic

You drive a spike of psionic energy into the mind of one creature you can see within range. The target makes a Wisdom saving throw, taking 3d8 Psychic damage on a failed save or half as much damage on a successful one. On a failed save, you also always know the target's location until the spell ends, but only while the two of you are on the same plane of existence. While you have this knowledge, the target can't become hidden from you, and if it has the Invisible condition, it gains no benefit from that condition against you.
`,
      "Minor Illusion.md": `---
smType: spell
name: "Minor Illusion"
level: 0
school: "Illusion"
casting_time: "Action"
range: "30 feet"
components: ["S", "M"]
materials: "a bit of fleece"
duration: "1 minute"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# Minor Illusion
Cantrip Illusion

- Casting Time: Action
- Range: 30 feet
- Components: S, M (a bit of fleece)
- Duration: 1 minute
- Classes: Bard, Sorcerer, Warlock, Wizard

You create a sound or an image of an object within range that lasts for the duration. See the descriptions below for the effects of each. The illusion ends if you cast this spell again.

If a creature takes a Study action to examine the sound or image, the creature can determine that it is an illusion with a successful Intelligence (Investigation) check against your spell save DC. If a creature discerns the illusion for what it is, the illusion becomes faint to the creature.

**_Sound._** If you create a sound, its volume can range from a whisper to a scream. It can be your voice, someone else's voice, a lion's roar, a beating of drums, or any other sound you choose. The sound continues unabated throughout the duration, or you can make discrete sounds at different times before the spell ends.

**_Image._** If you create an image of an object\u2014such as a chair, muddy footprints, or a small chest\u2014it must be no larger than a 5-foot Cube. The image can't create sound, light, smell, or any other sensory effect. Physical interaction with the image reveals it to be an illusion, since things can pass through it.
`,
      "Mirage Arcane.md": `---
smType: spell
name: "Mirage Arcane"
level: 7
school: "Illusion"
casting_time: "10 minutes"
range: "Sight"
components: ["V", "S"]
duration: "10 days"
classes: ["Bard", "Druid", "Wizard"]
---

# Mirage Arcane
Level 7 Illusion

- Casting Time: 10 minutes
- Range: Sight
- Components: V, S
- Duration: 10 days
- Classes: Bard, Druid, Wizard

You make terrain in an area up to 1 mile square look, sound, smell, and even feel like some other sort of terrain. Open fields or a road could be made to resemble a swamp, hill, crevasse, or some other rough or impassable terrain. A pond can be made to seem like a grassy meadow, a precipice like a gentle slope, or a rock-strewn gully like a wide and smooth road.

Similarly, you can alter the appearance of structures or add them where none are present. The spell doesn't disguise, conceal, or add creatures.

The illusion includes audible, visual, tactile, and olfactory elements, so it can turn clear ground into Difficult Terrain (or vice versa) or otherwise impede movement through the area. Any piece of the illusory terrain (such as a rock or stick) that is removed from the spell's area disappears immediately.

Creatures with Truesight can see through the illusion to the terrain's true form; however, all other elements of the illusion remain, so while the creature is aware of the illusion's presence, the creature can still physically interact with the illusion.
`,
      "Mirror Image.md": `---
smType: spell
name: "Mirror Image"
level: 2
school: "Illusion"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "1 minute"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# Mirror Image
Level 2 Illusion

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: 1 minute
- Classes: Bard, Sorcerer, Warlock, Wizard

Three illusory duplicates of yourself appear in your space. Until the spell ends, the duplicates move with you and mimic your actions, shifting position so it's impossible to track which image is real.

Each time a creature hits you with an attack roll during the spell's duration, roll a d6 for each of your remaining duplicates. If any of the d6s rolls a 3 or higher, one of the duplicates is hit instead of you, and the duplicate is destroyed. The duplicates otherwise ignore all other damage and effects. The spell ends when all three duplicates are destroyed.

A creature is unaffected by this spell if it has the Blinded condition, Blindsight, or Truesight.
`,
      "Mislead.md": `---
smType: spell
name: "Mislead"
level: 5
school: "Illusion"
casting_time: "Action"
range: "Self"
components: ["S"]
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Bard", "Warlock", "Wizard"]
---

# Mislead
Level 5 Illusion

- Casting Time: Action
- Range: Self
- Components: S
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Bard, Warlock, Wizard

You gain the Invisible condition at the same time that an illusory double of you appears where you are standing. The double lasts for the duration, but the invisibility ends immediately after you make an attack roll, deal damage, or cast a spell.

As a Magic action, you can move the illusory double up to twice your Speed and make it gesture, speak, and behave in whatever way you choose. It is intangible and invulnerable.

You can see through its eyes and hear through its ears as if you were located where it is.
`,
      "Misty Step.md": `---
smType: spell
name: "Misty Step"
level: 2
school: "Conjuration"
casting_time: "Bonus Action"
range: "Self"
components: ["V"]
duration: "Instantaneous"
classes: ["Sorcerer", "Warlock", "Wizard"]
---

# Misty Step
Level 2 Conjuration

- Casting Time: Bonus Action
- Range: Self
- Components: V
- Duration: Instantaneous
- Classes: Sorcerer, Warlock, Wizard

Briefly surrounded by silvery mist, you teleport up to 30 feet to an unoccupied space you can see.
`,
      "Modify Memory.md": `---
smType: spell
name: "Modify Memory"
level: 5
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Wizard"]
save_ability: "WIS"
---

# Modify Memory
Level 5 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Wizard
- Save: WIS

You attempt to reshape another creature's memories. One creature that you can see within range makes a Wisdom saving throw. If you are fighting the creature, it has Advantage on the save. On a failed save, the target has the Charmed condition for the duration. While Charmed in this way, the target also has the Incapacitated condition and is unaware of its surroundings, though it can hear you. If it takes any damage or is targeted by another spell, this spell ends, and no memories are modified.

While this charm lasts, you can affect the target's memory of an event that it experienced within the last 24 hours and that lasted no more than 10 minutes. You can permanently eliminate all memory of the event, allow the target to recall the event with perfect clarity, change its memory of the event's details, or create a memory of some other event.

You must speak to the target to describe how its memories are affected, and it must be able to understand your language for the modified memories to take root. Its mind fills in any gaps in the details of your description. If the spell ends before you finish describing the modified memories, the creature's memory isn't altered. Otherwise, the modified memories take hold when the spell ends.

A modified memory doesn't necessarily affect how a creature behaves, particularly if the memory contradicts the creature's natural inclinations, alignment, or beliefs. An illogical modified memory, such as a false memory of how much the creature enjoyed swimming in acid, is dismissed as a bad dream. The GM might deem a modified memory too nonsensical to affect a creature.

A *Remove Curse* or *Greater Restoration* spell cast on the target restores the creature's true memory.
`,
      "Moonbeam.md": `---
smType: spell
name: "Moonbeam"
level: 2
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a moonseed leaf"
duration: "Concentration, up to 1 minute A silvery beam of pale light shines down in a 5-foot-radius, 40-foot-high Cylinder centered on a point within range. Until the spell ends, Dim Light fills the Cylinder, and you can take a Magic action on later turns to move the Cylinder up to 60 feet."
concentration: true
classes: ["Druid"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "2d10"
damage_type: "Radiant"
---

# Moonbeam
Level 2 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a moonseed leaf)
- Duration: Concentration, up to 1 minute A silvery beam of pale light shines down in a 5-foot-radius, 40-foot-high Cylinder centered on a point within range. Until the spell ends, Dim Light fills the Cylinder, and you can take a Magic action on later turns to move the Cylinder up to 60 feet.
- Concentration: yes
- Classes: Druid
- Save: CON (Half damage on success)
- Damage: 2d10 Radiant

When the Cylinder appears, each creature in it makes a Constitution saving throw. On a failed save, a creature takes 2d10 Radiant damage, and if the creature is shape-shifted (as a result of the *Polymorph* spell, for example), it reverts to its true form and can't shape-shift until it leaves the Cylinder. On a successful save, a creature takes half as much damage only. A creature also makes this save when the spell's area moves into its space and when it enters the spell's area or ends its turn there. A creature makes this save only once per turn.
`,
      "Move Earth.md": `---
smType: spell
name: "Move Earth"
level: 6
school: "Transmutation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a miniature shovel"
duration: "Concentration, up to 2 hours"
concentration: true
classes: ["Druid", "Sorcerer", "Wizard"]
---

# Move Earth
Level 6 Transmutation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a miniature shovel)
- Duration: Concentration, up to 2 hours
- Concentration: yes
- Classes: Druid, Sorcerer, Wizard

Choose an area of terrain no larger than 40 feet on a side within range. You can reshape dirt, sand, or clay in the area in any manner you choose for the duration. You can raise or lower the area's elevation, create or fill in a trench, erect or flatten a wall, or form a pillar. The extent of any such changes can't exceed half the area's largest dimension. For example, if you affect a 40-foot square, you can create a pillar up to 20 feet high, raise or lower the square's elevation by up to 20 feet, dig a trench up to 20 feet deep, and so on. It takes 10 minutes for these changes to complete. Because the terrain's transformation occurs slowly, creatures in the area can't usually be trapped or injured by the ground's movement.

At the end of every 10 minutes you spend concentrating on the spell, you can choose a new area of terrain to affect within range.

This spell can't manipulate natural stone or stone construction. Rocks and structures shift to accommodate the new terrain. If the way you shape the terrain would make a structure unstable, it might collapse.

Similarly, this spell doesn't directly affect plant growth. The moved earth carries any plants along with it.
`,
      "Nondetection.md": `---
smType: spell
name: "Nondetection"
level: 3
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a pinch of diamond dust worth 25+ GP, which the spell consumes"
duration: "8 hours"
classes: ["Bard", "Ranger", "Wizard"]
---

# Nondetection
Level 3 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a pinch of diamond dust worth 25+ GP, which the spell consumes)
- Duration: 8 hours
- Classes: Bard, Ranger, Wizard

For the duration, you hide a target that you touch from Divination spells. The target can be a willing creature, or it can be a place or an object no larger than 10 feet in any dimension. The target can't be targeted by any Divination spell or perceived through magical scrying sensors.

### P Spells
`,
      "Pass without Trace.md": `---
smType: spell
name: "Pass without Trace"
level: 2
school: "Abjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "ashes from burned mistletoe"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Druid", "Ranger"]
---

# Pass without Trace
Level 2 Abjuration

- Casting Time: Action
- Range: Self
- Components: V, S, M (ashes from burned mistletoe)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Druid, Ranger

You radiate a concealing aura in a 30-foot Emanation for the duration. While in the aura, you and each creature you choose have a +10 bonus to Dexterity (Stealth) checks and leave no tracks.
`,
      "Passwall.md": `---
smType: spell
name: "Passwall"
level: 5
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a pinch of sesame seeds"
duration: "1 hour"
classes: ["Wizard"]
---

# Passwall
Level 5 Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a pinch of sesame seeds)
- Duration: 1 hour
- Classes: Wizard

A passage appears at a point that you can see on a wooden, plaster, or stone surface (such as a wall, ceiling, or floor) within range and lasts for the duration. You choose the opening's dimensions: up to 5 feet wide, 8 feet tall, and 20 feet deep. The passage creates no instability in a structure surrounding it.

When the opening disappears, any creatures or objects still in the passage created by the spell are safely ejected to an unoccupied space nearest to the surface on which you cast the spell.
`,
      "Phantasmal Force.md": `---
smType: spell
name: "Phantasmal Force"
level: 2
school: "Illusion"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a bit of fleece"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "INT"
damage: "2d8"
damage_type: "Psychic"
---

# Phantasmal Force
Level 2 Illusion

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a bit of fleece)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard
- Save: INT
- Damage: 2d8 Psychic

You attempt to craft an illusion in the mind of a creature you can see within range. The target makes an Intelligence saving throw. On a failed save, you create a phantasmal object, creature, or other phenomenon that is no larger than a 10-foot Cube and that is perceivable only to the target for the duration. The phantasm includes sound, temperature, and other stimuli.

The target can take a Study action to examine the phantasm with an Intelligence (Investigation) check against your spell save DC. If the check succeeds, the target realizes that the phantasm is an illusion, and the spell ends.

While affected by the spell, the target treats the phantasm as if it were real and rationalizes any illogical outcomes from interacting with it. For example, if the target steps through a phantasmal bridge and survives the fall, it believes the bridge exists and something else caused it to fall.

An affected target can even take damage from the illusion if the phantasm represents a dangerous creature or hazard. On each of your turns, such a phantasm can deal 2d8 Psychic damage to the target if it is in the phantasm's area or within 5 feet of the phantasm. The target perceives the damage as a type appropriate to the illusion.
`,
      "Phantasmal Killer.md": `---
smType: spell
name: "Phantasmal Killer"
level: 4
school: "Illusion"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Wizard"]
save_ability: "WIS"
save_effect: "Half damage on success"
damage: "4d10"
damage_type: "Psychic"
---

# Phantasmal Killer
Level 4 Illusion

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Wizard
- Save: WIS (Half damage on success)
- Damage: 4d10 Psychic

You tap into the nightmares of a creature you can see within range and create an illusion of its deepest fears, visible only to that creature. The target makes a Wisdom saving throw. On a failed save, the target takes 4d10 Psychic damage and has Disadvantage on ability checks and attack rolls for the duration. On a successful save, the target takes half as much damage, and the spell ends.

For the duration, the target makes a Wisdom saving throw at the end of each of its turns. On a failed save, it takes the Psychic damage again. On a successful save, the spell ends.
`,
      "Phantom Steed.md": `---
smType: spell
name: "Phantom Steed"
level: 3
school: "Illusion"
casting_time: "1 minute or Ritual"
range: "30 feet"
components: ["V", "S"]
duration: "1 hour"
ritual: true
classes: ["Wizard"]
---

# Phantom Steed
Level 3 Illusion

- Casting Time: 1 minute or Ritual
- Range: 30 feet
- Components: V, S
- Duration: 1 hour
- Ritual: yes
- Classes: Wizard

A Large, quasi-real, horselike creature appears on the ground in an unoccupied space of your choice within range. You decide the creature's appearance, and it is equipped with a saddle, bit, and bridle. Any of the equipment created by the spell vanishes in a puff of smoke if it is carried more than 10 feet away from the steed.

For the duration, you or a creature you choose can ride the steed. The steed uses the **Riding Horse**  stat block (see "Monsters"), except it has a Speed of 100 feet and can travel 13 miles in an hour. When the spell ends, the steed gradually fades, giving the rider 1 minute to dismount. The spell ends early if the steed takes any damage.
`,
      "Planar Ally.md": `---
smType: spell
name: "Planar Ally"
level: 6
school: "Conjuration"
casting_time: "10 minutes"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric"]
---

# Planar Ally
Level 6 Conjuration

- Casting Time: 10 minutes
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric

You beseech an otherworldly entity for aid. The being must be known to you: a god, a demon prince, or some other being of cosmic power. That entity sends a Celestial, an Elemental, or a Fiend loyal to it to aid you, making the creature appear in an unoccupied space within range. If you know a specific creature's name, you can speak that name when you cast this spell to request that creature, though you might get a different creature anyway (GM's choice).

When the creature appears, it is under no compulsion to behave a particular way. You can ask it to perform a service in exchange for payment, but it isn't obliged to do so. The requested task could range from simple (fly us across the chasm, or help us fight a battle) to complex (spy on our enemies, or protect us during our foray into the dungeon). You must be able to communicate with the creature to bargain for its services.

Payment can take a variety of forms. A Celestial might require a sizable donation of gold or magic items to an allied temple, while a Fiend might demand a living sacrifice or a gift of treasure. Some creatures might exchange their service for a quest undertaken by you.

A task that can be measured in minutes requires a payment worth 100 GP per minute. A task measured in hours requires 1,000 GP per hour. And a task measured in days (up to 10 days) requires 10,000 GP per day. The GM can adjust these payments based on the circumstances under which you cast the spell. If the task is aligned with the creature's ethos, the payment might be halved or even waived. Nonhazardous tasks typically require only half the suggested payment, while especially dangerous tasks might require a greater gift. Creatures rarely accept tasks that seem suicidal.

After the creature completes the task, or when the agreed-upon duration of service expires, the creature returns to its home plane after reporting back to you if possible. If you are unable to agree on a price for the creature's service, the creature immediately returns to its home plane.
`,
      "Planar Binding.md": `---
smType: spell
name: "Planar Binding"
level: 5
school: "Abjuration"
casting_time: "1 hour"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a jewel worth 1,000+ GP, which the spell consumes"
duration: "24 hours"
classes: ["Bard", "Cleric", "Druid", "Warlock", "Wizard"]
save_ability: "CHA"
---

# Planar Binding
Level 5 Abjuration

- Casting Time: 1 hour
- Range: 60 feet
- Components: V, S, M (a jewel worth 1,000+ GP, which the spell consumes)
- Duration: 24 hours
- Classes: Bard, Cleric, Druid, Warlock, Wizard
- Save: CHA

You attempt to bind a Celestial, an Elemental, a Fey, or a Fiend to your service. The creature must be within range for the entire casting of the spell. (Typically, the creature is first summoned into the center of the inverted version of the *Magic Circle* spell to trap it while this spell is cast.) At the completion of the casting, the target must succeed on a Charisma saving throw or be bound to serve you for the duration. If the creature was summoned or created by another spell, that spell's duration is extended to match the duration of this spell.

A bound creature must follow your commands to the best of its ability. You might command the creature to accompany you on an adventure, to guard a location, or to deliver a message. If the creature is Hostile, it strives to twist your commands to achieve its own objectives. If the creature carries out your commands completely before the spell ends, it travels to you to report this fact if you are on the same plane of existence. If you are on a different plane, it returns to the place where you bound it and remains there until the spell ends.
`,
      "Plane Shift.md": `---
smType: spell
name: "Plane Shift"
level: 7
school: "Conjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a forked, metal rod worth 250+ GP and attuned to a plane of existence"
duration: "Instantaneous"
classes: ["Cleric", "Druid", "Sorcerer", "Warlock", "Wizard"]
---

# Plane Shift
Level 7 Conjuration

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a forked, metal rod worth 250+ GP and attuned to a plane of existence)
- Duration: Instantaneous
- Classes: Cleric, Druid, Sorcerer, Warlock, Wizard

You and up to eight willing creatures who link hands in a circle are transported to a different plane of existence. You can specify a target destination in general terms, such as a specific city on the Elemental Plane of Fire or palace on the second level of the Nine Hells, and you appear in or near that destination, as determined by the GM.

Alternatively, if you know the sigil sequence of a teleportation circle on another plane of existence, this spell can take you to that circle. If the teleportation circle is too small to hold all the creatures you transported, they appear in the closest unoccupied spaces next to the circle.
`,
      "Plant Growth.md": `---
smType: spell
name: "Plant Growth"
level: 3
school: "Transmutation"
casting_time: "Action (Overgrowth) or 8 hours (Enrichment)"
range: "150 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Bard", "Druid", "Ranger"]
---

# Plant Growth
Level 3 Transmutation

- Casting Time: Action (Overgrowth) or 8 hours (Enrichment)
- Range: 150 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Bard, Druid, Ranger

This spell channels vitality into plants. The casting time you use determines whether the spell has the Overgrowth or the Enrichment effect below.

**_Overgrowth._** Choose a point within range. All normal plants in a 100-foot-radius Sphere centered on that point become thick and overgrown. A creature moving through that area must spend 4 feet of movement for every 1 foot it moves. You can exclude one or more areas of any size within the spell's area from being affected.

**_Enrichment._** All plants in a half-mile radius centered on a point within range become enriched for 365 days. The plants yield twice the normal amount of food when harvested. They can benefit from only one *Plant Growth* per year.
`,
      "Poison Spray.md": `---
smType: spell
name: "Poison Spray"
level: 0
school: "Necromancy"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Druid", "Sorcerer", "Warlock", "Wizard"]
attack: "ranged spell attack"
damage: "1d12"
damage_type: "Poison"
---

# Poison Spray
Cantrip Necromancy

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Druid, Sorcerer, Warlock, Wizard
- Attack: ranged spell attack
- Damage: 1d12 Poison

You spray toxic mist at a creature within range. Make a ranged spell attack against the target. On a hit, the target takes 1d12 Poison damage.
`,
      "Polymorph.md": `---
smType: spell
name: "Polymorph"
level: 4
school: "Transmutation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a caterpillar cocoon"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Bard", "Druid", "Sorcerer", "Wizard"]
save_ability: "WIS"
---

# Polymorph
Level 4 Transmutation

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a caterpillar cocoon)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Bard, Druid, Sorcerer, Wizard
- Save: WIS

You attempt to transform a creature that you can see within range into a Beast. The target must succeed on a Wisdom saving throw or shape-shift into a Beast form for the duration. That form can be any Beast you choose that has a Challenge Rating equal to or less than the target's (or the target's level if it doesn't have a Challenge Rating). The target's game statistics are replaced by the stat block of the chosen Beast, but the target retains its alignment, personality, creature type, Hit Points, and Hit Point Dice. See the "Animals" section of "Monsters" for a sample of Beast stat blocks.

The target gains a number of Temporary Hit Points equal to the Hit Points of the Beast form. These Temporary Hit Points vanish if any remain when the spell ends. The spell ends early on the target if it has no Temporary Hit Points left.

The target is limited in the actions it can perform by the anatomy of its new form, and it can't speak or cast spells.

The target's gear melds into the new form. The creature can't use or otherwise benefit from any of that equipment.
`,
      "Power Word Heal.md": `---
smType: spell
name: "Power Word Heal"
level: 9
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
duration: "Instantaneous"
classes: ["Bard", "Cleric"]
---

# Power Word Heal
Level 9 Enchantment

- Casting Time: Action
- Range: 60 feet
- Duration: Instantaneous
- Classes: Bard, Cleric

A wave of healing energy washes over one creature you can see within range. The target regains all its Hit Points. If the creature has the Charmed, Frightened, Paralyzed, Poisoned, or Stunned condition, the condition ends. If the creature has the Prone condition, it can use its Reaction to stand up.
`,
      "Power Word Kill.md": `---
smType: spell
name: "Power Word Kill"
level: 9
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
duration: "Instantaneous"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
damage: "12d12"
damage_type: "Psychic"
---

# Power Word Kill
Level 9 Enchantment

- Casting Time: Action
- Range: 60 feet
- Duration: Instantaneous
- Classes: Bard, Sorcerer, Warlock, Wizard
- Damage: 12d12 Psychic

You compel one creature you can see within range to die. If the target has 100 Hit Points or fewer, it dies. Otherwise, it takes 12d12 Psychic damage.
`,
      "Power Word Stun.md": `---
smType: spell
name: "Power Word Stun"
level: 8
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
save_ability: "CON"
---

# Power Word Stun
Level 8 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V
- Duration: Instantaneous
- Classes: Bard, Sorcerer, Warlock, Wizard
- Save: CON

You overwhelm the mind of one creature you can see within range. If the target has 150 Hit Points or fewer, it has the Stunned condition. Otherwise, its Speed is 0 until the start of your next turn.

The Stunned target makes a Constitution saving throw at the end of each of its turns, ending the condition on itself on a success.
`,
      "Prayer of Healing.md": `---
smType: spell
name: "Prayer of Healing"
level: 2
school: "Abjuration"
casting_time: "10 minutes"
range: "30 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Cleric", "Paladin"]
---

# Prayer of Healing
Level 2 Abjuration

- Casting Time: 10 minutes
- Range: 30 feet
- Components: V
- Duration: Instantaneous
- Classes: Cleric, Paladin

Up to five creatures of your choice who remain within range for the spell's entire casting gain the benefits of a Short Rest and also regain 2d8 Hit Points. A creature can't be affected by this spell again until that creature finishes a Long Rest.
`,
      "Prestidigitation.md": `---
smType: spell
name: "Prestidigitation"
level: 0
school: "Transmutation"
casting_time: "Action"
range: "10 feet"
components: ["V", "S"]
duration: "Up to 1 hour"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# Prestidigitation
Cantrip Transmutation

- Casting Time: Action
- Range: 10 feet
- Components: V, S
- Duration: Up to 1 hour
- Classes: Bard, Sorcerer, Warlock, Wizard

You create a magical effect within range. Choose the effect from the options below. If you cast this spell multiple times, you can have up to three of its non-instantaneous effects active at a time.

**_Sensory Effect._** You create an instantaneous, harmless sensory effect, such as a shower of sparks,

a puff of wind, faint musical notes, or an odd odor. *Fire Play.* You instantaneously light or snuff out a candle, a torch, or a small campfire.

**_Clean or Soil._** You instantaneously clean or soil an object no larger than 1 cubic foot.

**_Minor Sensation._** You chill, warm, or flavor up to 1 cubic foot of nonliving material for 1 hour.

**_Magic Mark._** You make a color, a small mark, or a symbol appear on an object or a surface for 1 hour.

**_Minor Creation._** You create a nonmagical trinket or an illusory image that can fit in your hand. It lasts until the end of your next turn. A trinket can deal no damage and has no monetary worth.
`,
      "Prismatic Spray.md": `---
smType: spell
name: "Prismatic Spray"
level: 7
school: "Evocation"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "12d6"
damage_type: "Fire"
---

# Prismatic Spray
Level 7 Evocation

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Instantaneous
- Classes: Bard, Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 12d6 Fire

Eight rays of light flash from you in a 60-foot Cone. Each creature in the Cone makes a Dexterity saving throw. For each target, roll 1d8 to determine which color ray affects it, consulting the Prismatic Rays table.

Table: Prismatic Rays

| 1d8 | Ray                                                                                       |

|-----|-------------------------------------------------------------------------------------------|

| 1   | **Red.** *Failed Save:* 12d6 Fire damage. *Successful Save:* Half as much damage.         |

| 2   | **Orange.** *Failed Save:* 12d6 Acid damage. *Successful Save:* Half as much damage.      |

| 3   | **Yellow.** *Failed Save:* 12d6 Lightning damage. *Successful Save:* Half as much damage. |

| 4   | **Green.** *Failed Save:* 12d6 Poison damage. *Successful Save:* Half as much damage.     |

| 5   | **Blue.** *Failed Save:* 12d6 Cold damage. *Successful Save:* Half as much damage.        |

| 6   | **Indigo.** *Failed Save:* The target has the Restrained condition and makes a Constitution saving throw at the end of each of its turns. If it successfully saves three times, the condition ends. If it fails three times, it has the Petrified condition until it is freed by an effect like the *Greater Restoration* spell. The successes and failures needn't be consecutive; keep track of both until the target collects three of a kind. |

| 7   | **Violet.** *Failed Save:* The target has the Blinded condition and makes a Wisdom saving throw at the start of your next turn. On a successful save, the condition ends. On a failed save, the condition ends, and the creature teleports to another plane of existence (GM's choice). |

| 8   | **Special.** The target is struck by two rays. Roll twice, rerolling any 8.               |
`,
      "Prismatic Wall.md": `---
smType: spell
name: "Prismatic Wall"
level: 9
school: "Abjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "10 minutes"
classes: ["Bard", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "12d6"
damage_type: "Fire"
---

# Prismatic Wall
Level 9 Abjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: 10 minutes
- Classes: Bard, Wizard
- Save: CON (Half damage on success)
- Damage: 12d6 Fire

A shimmering, multicolored plane of light forms a vertical opaque wall\u2014up to 90 feet long, 30 feet high, and 1 inch thick\u2014centered on a point within range. Alternatively, you shape the wall into a globe up to 30 feet in diameter centered on a point within range. The wall lasts for the duration. If you position the wall in a space occupied by a creature, the spell ends instantly without effect.

The wall sheds Bright Light within 100 feet and Dim Light for an additional 100 feet. You and creatures you designate when you cast the spell can pass through and be near the wall without harm. If another creature that can see the wall moves within 20 feet of it or starts its turn there, the creature must succeed on a Constitution saving throw or have the Blinded condition for 1 minute.

The wall consists of seven layers, each with a different color. When a creature reaches into or passes through the wall, it does so one layer at a time through all the layers. Each layer forces the creature to make a Dexterity saving throw or be affected by that layer's properties as described in the Prismatic Layers table.

The wall, which has AC 10, can be destroyed one layer at a time, in order from red to violet, by means specific to each layer. If a layer is destroyed, it is gone for the duration. *Antimagic Field* has no effect on the wall, and *Dispel Magic* can affect only the violet layer.

Table: Prismatic Layers

| Order | Effects                      |

|-------|------------------------------|

| 1     | **Red.** *Failed Save:* 12d6 Fire damage. *Successful Save:* Half as much damage. *Additional Effects*: Nonmagical ranged attacks can't pass through this layer, which is destroyed if it takes at least 25 Cold damage. |

| 2     | **Orange.** *Failed Save:* 12d6 Acid damage. *Successful Save:* Half as much damage. *Additional Effects:* Magical ranged attacks can't pass through this layer, which is destroyed by a strong wind (such as the one created by *Gust of Wind*). |

| 3     | **Yellow.** *Failed Save:* 12d6 Lightning damage. *Successful Save:* Half as much damage. *Additional Effects:* The layer is destroyed if it takes at least 60 Force damage. |

| 4     | **Green.** *Failed Save:* 12d6 Poison damage. *Successful Save:* Half as much damage. *Additional Effects:* A *Passwall* spell, or another spell of equal or greater level that can open a portal on a solid surface, destroys this layer. |

| 5     | **Blue.** *Failed Save:* 12d6 Cold damage. *Successful Save:* Half as much damage. *Additional Effects:* The layer is destroyed if it takes at least 25 Fire damage. |

| 6     | **Indigo.** *Failed Save:* The target has the Restrained condition and makes a Constitution saving throw at the end of each of its turns. If it successfully saves three times, the condition ends. If it fails three times, it has the Petrified condition until it is freed by an effect like the *Greater Restoration* spell. The successes and failures needn't be consecutive; keep track of both until the target collects three of a kind. *Additional Effects:* Spells can't be cast through this layer, which is destroyed by Bright Light shed by the *Daylight* spell. |

| 7     | **Violet.** *Failed Save:* The target has the Blinded condition and makes a Wisdom saving throw at the start of your next turn. On a successful save, the condition ends. On a failed save, the condition ends, and the creature teleports to another plane of existence (GM's choice). *Additional Effects:* This layer is destroyed by *Dispel Magic*. |
`,
      "Private Sanctum.md": `---
smType: spell
name: "Private Sanctum"
level: 4
school: "Abjuration"
casting_time: "10 minutes"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a thin sheet of lead"
duration: "24 hours"
classes: ["Wizard"]
---

# Private Sanctum
Level 4 Abjuration

- Casting Time: 10 minutes
- Range: 120 feet
- Components: V, S, M (a thin sheet of lead)
- Duration: 24 hours
- Classes: Wizard

You make an area within range magically secure. The area is a Cube that can be as small as 5 feet to as large as 100 feet on each side. The spell lasts for the duration.

When you cast the spell, you decide what sort of security the spell provides, choosing any of the following properties:

- Sound can't pass through the barrier at the edge of the warded area.

- The barrier of the warded area appears dark and foggy, preventing vision (including Darkvision) through it.

- Sensors created by Divination spells can't appear inside the protected area or pass through the barrier at its perimeter.

- Creatures in the area can't be targeted by Divination spells.

- Nothing can teleport into or out of the warded area.

- Planar travel is blocked within the warded area.

Casting this spell on the same spot every day for 365 days makes the spell last until dispelled.
`,
      "Produce Flame.md": `---
smType: spell
name: "Produce Flame"
level: 0
school: "Conjuration"
casting_time: "Bonus Action"
range: "Self"
components: ["V", "S"]
duration: "10 minutes"
classes: ["Druid"]
attack: "ranged spell attack"
damage: "1d8"
damage_type: "Fire"
---

# Produce Flame
Cantrip Conjuration

- Casting Time: Bonus Action
- Range: Self
- Components: V, S
- Duration: 10 minutes
- Classes: Druid
- Attack: ranged spell attack
- Damage: 1d8 Fire

A flickering flame appears in your hand and remains there for the duration. While there, the flame emits no heat and ignites nothing, and it sheds Bright Light in a 20-foot radius and Dim Light for an additional 20 feet. The spell ends if you cast it again.

Until the spell ends, you can take a Magic action to hurl fire at a creature or an object within 60 feet of you. Make a ranged spell attack. On a hit, the target takes 1d8 Fire damage.
`,
      "Programmed Illusion.md": `---
smType: spell
name: "Programmed Illusion"
level: 6
school: "Illusion"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "jade dust worth 25+ GP"
duration: "Until dispelled"
classes: ["Bard", "Wizard"]
---

# Programmed Illusion
Level 6 Illusion

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (jade dust worth 25+ GP)
- Duration: Until dispelled
- Classes: Bard, Wizard

You create an illusion of an object, a creature, or some other visible phenomenon within range that activates when a specific trigger occurs. The illusion is imperceptible until then. It must be no larger than a 30-foot Cube, and you decide when you cast the spell how the illusion behaves and what sounds it makes. This scripted performance can last up to 5 minutes.

When the trigger you specify occurs, the illusion springs into existence and performs in the manner you described. Once the illusion finishes performing, it disappears and remains dormant for 10 minutes, after which the illusion can be activated again.

The trigger can be as general or as detailed as you like, though it must be based on visual or audible phenomena that occur within 30 feet of the area. For example, you could create an illusion of yourself to appear and warn off others who attempt to open a trapped door.

Physical interaction with the image reveals it to be illusory, since things can pass through it. A creature that takes the Study action to examine the image can determine that it is an illusion with a successful Intelligence (Investigation) check against your spell save DC. If a creature discerns the illusion for what it is, the creature can see through the image, and any noise it makes sounds hollow to the creature.
`,
      "Project Image.md": `---
smType: spell
name: "Project Image"
level: 7
school: "Illusion"
casting_time: "Action"
range: "500 miles"
components: ["V", "S", "M"]
materials: "a statuette of yourself worth 5+ GP"
duration: "Concentration, up to 1 day"
concentration: true
classes: ["Bard", "Wizard"]
---

# Project Image
Level 7 Illusion

- Casting Time: Action
- Range: 500 miles
- Components: V, S, M (a statuette of yourself worth 5+ GP)
- Duration: Concentration, up to 1 day
- Concentration: yes
- Classes: Bard, Wizard

You create an illusory copy of yourself that lasts for the duration. The copy can appear at any location within range that you have seen before, regardless of intervening obstacles. The illusion looks and sounds like you, but it is intangible. If the illusion takes any damage, it disappears, and the spell ends.

You can see through the illusion's eyes and hear through its ears as if you were in its space. As a Magic action, you can move it up to 60 feet and make it gesture, speak, and behave in whatever way you choose. It mimics your mannerisms perfectly.

Physical interaction with the image reveals it to be illusory, since things can pass through it. A creature that takes the Study action to examine the image can determine that it is an illusion with a successful Intelligence (Investigation) check against your spell save DC. If a creature discerns the illusion for what it is, the creature can see through the image, and any noise it makes sounds hollow to the creature.
`,
      "Protection from Energy.md": `---
smType: spell
name: "Protection from Energy"
level: 3
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Cleric", "Druid", "Ranger", "Sorcerer", "Wizard"]
---

# Protection from Energy
Level 3 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Cleric, Druid, Ranger, Sorcerer, Wizard

For the duration, the willing creature you touch has Resistance to one damage type of your choice: Acid, Cold, Fire, Lightning, or Thunder.
`,
      "Protection from Evil and Good.md": `---
smType: spell
name: "Protection from Evil and Good"
level: 1
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a flask of Holy Water worth 25+ GP, which the spell consumes"
duration: "Concentration up to 10 minutes"
concentration: true
classes: ["Cleric", "Druid", "Paladin", "Warlock", "Wizard"]
---

# Protection from Evil and Good
Level 1 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a flask of Holy Water worth 25+ GP, which the spell consumes)
- Duration: Concentration up to 10 minutes
- Concentration: yes
- Classes: Cleric, Druid, Paladin, Warlock, Wizard

Until the spell ends, one willing creature you touch is protected against creatures that are Aberrations, Celestials, Elementals, Fey, Fiends, or Undead. The protection grants several benefits. Creatures of those types have Disadvantage on attack rolls against the target. The target also can't be possessed by or gain the Charmed or Frightened conditions from them. If the target is already possessed, Charmed, or Frightened by such a creature, the target has Advantage on any new saving throw against the relevant effect.
`,
      "Protection from Poison.md": `---
smType: spell
name: "Protection from Poison"
level: 2
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "1 hour"
classes: ["Cleric", "Druid", "Paladin", "Ranger"]
---

# Protection from Poison
Level 2 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: 1 hour
- Classes: Cleric, Druid, Paladin, Ranger

You touch a creature and end the Poisoned condition on it. For the duration, the target has Advantage on saving throws to avoid or end the Poisoned condition, and it has Resistance to Poison damage.
`,
      "Purify Food and Drink.md": `---
smType: spell
name: "Purify Food and Drink"
level: 1
school: "Transmutation"
casting_time: "Action or Ritual"
range: "10 feet"
components: ["V", "S"]
duration: "Instantaneous"
ritual: true
classes: ["Cleric", "Druid", "Paladin"]
---

# Purify Food and Drink
Level 1 Transmutation

- Casting Time: Action or Ritual
- Range: 10 feet
- Components: V, S
- Duration: Instantaneous
- Ritual: yes
- Classes: Cleric, Druid, Paladin

You remove poison and rot from nonmagical food and drink in a 5-foot-radius Sphere centered on a point within range.

### R Spells
`,
      "Raise Dead.md": `---
smType: spell
name: "Raise Dead"
level: 5
school: "Necromancy"
casting_time: "1 hour"
range: "Touch"
components: ["V", "S", "M"]
materials: "a diamond worth 500+ GP, which the spell consumes"
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Paladin"]
---

# Raise Dead
Level 5 Necromancy

- Casting Time: 1 hour
- Range: Touch
- Components: V, S, M (a diamond worth 500+ GP, which the spell consumes)
- Duration: Instantaneous
- Classes: Bard, Cleric, Paladin

With a touch, you revive a dead creature if it has been dead no longer than 10 days and it wasn't Undead when it died.

The creature returns to life with 1 Hit Point. This spell also neutralizes any poisons that affected the creature at the time of death.

This spell closes all mortal wounds, but it doesn't restore missing body parts. If the creature is lacking body parts or organs integral for its survival its head, for instance\u2014the spell automatically fails.

Coming back from the dead is an ordeal. The target takes a \u22124 penalty to D20 Tests. Every time the target finishes a Long Rest, the penalty is reduced by 1 until it becomes 0.
`,
      "Ray of Enfeeblement.md": `---
smType: spell
name: "Ray of Enfeeblement"
level: 2
school: "Necromancy"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Warlock", "Wizard"]
save_ability: "CON"
---

# Ray of Enfeeblement
Level 2 Necromancy

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Warlock, Wizard
- Save: CON

A beam of enervating energy shoots from you toward a creature within range. The target must make a Constitution saving throw. On a successful save, the target has Disadvantage on the next attack roll it makes until the start of your next turn.

On a failed save, the target has Disadvantage on Strength-based D20 Tests for the duration. During that time, it also subtracts 1d8 from all its damage rolls. The target repeats the save at the end of each of its turns, ending the spell on a success.
`,
      "Ray of Frost.md": `---
smType: spell
name: "Ray of Frost"
level: 0
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
attack: "ranged spell attack"
damage: "1d8"
damage_type: "Cold"
---

# Ray of Frost
Cantrip Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Attack: ranged spell attack
- Damage: 1d8 Cold

A frigid beam of blue-white light streaks toward a creature within range. Make a ranged spell attack against the target. On a hit, it takes 1d8 Cold damage, and its Speed is reduced by 10 feet until the start of your next turn.
`,
      "Ray of Sickness.md": `---
smType: spell
name: "Ray of Sickness"
level: 1
school: "Necromancy"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
attack: "ranged spell attack"
damage: "2d8"
damage_type: "Poison"
---

# Ray of Sickness
Level 1 Necromancy

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Attack: ranged spell attack
- Damage: 2d8 Poison

You shoot a greenish ray at a creature within range. Make a ranged spell attack against the target. On a hit, the target takes 2d8 Poison damage and has the Poisoned condition until the end of your next turn.
`,
      "Regenerate.md": `---
smType: spell
name: "Regenerate"
level: 7
school: "Transmutation"
casting_time: "1 minute"
range: "Touch"
components: ["V", "S", "M"]
materials: "a prayer wheel"
duration: "1 hour"
classes: ["Bard", "Cleric", "Druid"]
---

# Regenerate
Level 7 Transmutation

- Casting Time: 1 minute
- Range: Touch
- Components: V, S, M (a prayer wheel)
- Duration: 1 hour
- Classes: Bard, Cleric, Druid

A creature you touch regains 4d8 + 15 Hit Points. For the duration, the target regains 1 Hit Point at the start of each of its turns, and any severed body parts regrow after 2 minutes.
`,
      "Reincarnate.md": `---
smType: spell
name: "Reincarnate"
level: 5
school: "Necromancy"
casting_time: "1 hour"
range: "Touch"
components: ["V", "S", "M"]
materials: "rare oils worth 1,000+ GP, which the spell consumes"
duration: "Instantaneous"
classes: ["Druid"]
---

# Reincarnate
Level 5 Necromancy

- Casting Time: 1 hour
- Range: Touch
- Components: V, S, M (rare oils worth 1,000+ GP, which the spell consumes)
- Duration: Instantaneous
- Classes: Druid

You touch a dead Humanoid or a piece of one. If the creature has been dead no longer than 10 days, the spell forms a new body for it and calls the soul to enter that body. Roll 1d10 and consult the table below to determine the body's species, or the GM chooses another playable species.

| 1d10 | Species     |

|------|-------------|

| 1    | Roll again. |

| 2    | Dragonborn  |

| 3    | Dwarf       |

| 4    | Elf         |

| 5    | Gnome       |

| 6    | Goliath     |

| 7    | Halfling    |

| 8    | Human       |

| 9    | Orc         |

| 10   | Tiefling    |

The reincarnated creature makes any choices that a species' description offers, and the creature recalls its former life. It retains the capabilities it had in its original form, except it loses the traits of its previous species and gains the traits of its new one.
`,
      "Remove Curse.md": `---
smType: spell
name: "Remove Curse"
level: 3
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric", "Paladin", "Warlock", "Wizard"]
---

# Remove Curse
Level 3 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric, Paladin, Warlock, Wizard

At your touch, all curses affecting one creature or object end. If the object is a cursed magic item, its curse remains, but the spell breaks its owner's Attunement to the object so it can be removed or discarded.
`,
      "Resilient Sphere.md": `---
smType: spell
name: "Resilient Sphere"
level: 4
school: "Abjuration"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a glass sphere"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
---

# Resilient Sphere
Level 4 Abjuration

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a glass sphere)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Wizard
- Save: DEX (Half damage on success)

A shimmering sphere encloses a Large or smaller creature or object within range. An unwilling creature must succeed on a Dexterity saving throw or be enclosed for the duration.

Nothing\u2014not physical objects, energy, or other spell effects\u2014can pass through the barrier, in or out, though a creature in the sphere can breathe there. The sphere is immune to all damage, and a creature or object inside can't be damaged by attacks or effects originating from outside, nor can a creature inside the sphere damage anything outside it.

The sphere is weightless and just large enough to contain the creature or object inside. An enclosed creature can take an action to push against the sphere's walls and thus roll the sphere at up to half the creature's Speed. Similarly, the globe can be picked up and moved by other creatures.

A *Disintegrate* spell targeting the globe destroys it without harming anything inside.
`,
      "Resistance.md": `---
smType: spell
name: "Resistance"
level: 0
school: "Abjuration"
casting_time: "Action"
range: "Touch"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric", "Druid"]
---

# Resistance
Cantrip Abjuration

- Casting Time: Action
- Range: Touch
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric, Druid

You touch a willing creature and choose a damage type: Acid, Bludgeoning, Cold, Fire, Lightning, Necrotic, Piercing, Poison, Radiant, Slashing, or Thunder. When the creature takes damage of the chosen type before the spell ends, the creature reduces the total damage taken by 1d4. A creature can benefit from this spell only once per turn.
`,
      "Resurrection.md": `---
smType: spell
name: "Resurrection"
level: 7
school: "Necromancy"
casting_time: "1 hour"
range: "Touch"
components: ["V", "S", "M"]
materials: "a diamond worth 1,000+ GP, which the spell consumes"
duration: "Instantaneous"
classes: ["Bard", "Cleric"]
---

# Resurrection
Level 7 Necromancy

- Casting Time: 1 hour
- Range: Touch
- Components: V, S, M (a diamond worth 1,000+ GP, which the spell consumes)
- Duration: Instantaneous
- Classes: Bard, Cleric

With a touch, you revive a dead creature that has been dead for no more than a century, didn't die of old age, and wasn't Undead when it died.

The creature returns to life with all its Hit Points. This spell also neutralizes any poisons that affected the creature at the time of death. This spell closes all mortal wounds and restores any missing body parts.

Coming back from the dead is an ordeal. The target takes a \u22124 penalty to D20 Tests. Every time the target finishes a Long Rest, the penalty is reduced by 1 until it becomes 0.

Casting this spell to revive a creature that has been dead for 365 days or longer taxes you. Until you finish a Long Rest, you can't cast spells again, and you have Disadvantage on D20 Tests.
`,
      "Reverse Gravity.md": `---
smType: spell
name: "Reverse Gravity"
level: 7
school: "Transmutation"
casting_time: "Action"
range: "100 feet"
components: ["V", "S", "M"]
materials: "a lodestone and iron filings"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "DEX"
---

# Reverse Gravity
Level 7 Transmutation

- Casting Time: Action
- Range: 100 feet
- Components: V, S, M (a lodestone and iron filings)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Sorcerer, Wizard
- Save: DEX

This spell reverses gravity in a 50-foot-radius, 100 foot high Cylinder centered on a point within range. All creatures and objects in that area that aren't anchored to the ground fall upward and reach the top of the Cylinder. A creature can make a Dexterity saving throw to grab a fixed object it can reach, thus avoiding the fall upward.

If a ceiling or an anchored object is encountered in this upward fall, creatures and objects strike it just as they would during a downward fall. If an affected creature or object reaches the Cylinder's top without striking anything, it hovers there for the duration. When the spell ends, affected objects and creatures fall downward.
`,
      "Revivify.md": `---
smType: spell
name: "Revivify"
level: 3
school: "Necromancy"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a diamond worth 300+ GP, which the spell consumes"
duration: "Instantaneous"
classes: ["Cleric", "Druid", "Paladin", "Ranger"]
---

# Revivify
Level 3 Necromancy

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a diamond worth 300+ GP, which the spell consumes)
- Duration: Instantaneous
- Classes: Cleric, Druid, Paladin, Ranger

You touch a creature that has died within the last minute. That creature revives with 1 Hit Point. This spell can't revive a creature that has died of old age, nor does it restore any missing body parts.
`,
      "Rope Trick.md": `---
smType: spell
name: "Rope Trick"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a segment of rope"
duration: "1 hour"
classes: ["Wizard"]
---

# Rope Trick
Level 2 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a segment of rope)
- Duration: 1 hour
- Classes: Wizard

You touch a rope. One end of it hovers upward until the rope hangs perpendicular to the ground or the rope reaches a ceiling. At the rope's upper end, an Invisible 3-foot-by-5-foot portal opens to an extradimensional space that lasts until the spell ends. That space can be reached by climbing the rope, which can be pulled into or dropped out of it.

The space can hold up to eight Medium or smaller creatures. Attacks, spells, and other effects can't pass into or out of the space, but creatures inside it can see through the portal. Anything inside the space drops out when the spell ends.

### S Spells
`,
      "Sacred Flame.md": `---
smType: spell
name: "Sacred Flame"
level: 0
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "1d8"
damage_type: "Radiant"
---

# Sacred Flame
Cantrip Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric
- Save: DEX (Half damage on success)
- Damage: 1d8 Radiant

Flame-like radiance descends on a creature that you can see within range. The target must succeed on a Dexterity saving throw or take 1d8 Radiant damage. The target gains no benefit from Half Cover or Three-Quarters Cover for this save.
`,
      "Sanctuary.md": `---
smType: spell
name: "Sanctuary"
level: 1
school: "Abjuration"
casting_time: "Bonus Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a shard of glass from a mirror"
duration: "1 minute"
classes: ["Cleric"]
save_ability: "WIS"
---

# Sanctuary
Level 1 Abjuration

- Casting Time: Bonus Action
- Range: 30 feet
- Components: V, S, M (a shard of glass from a mirror)
- Duration: 1 minute
- Classes: Cleric
- Save: WIS

You ward a creature within range. Until the spell ends, any creature who targets the warded creature with an attack roll or a damaging spell must succeed on a Wisdom saving throw or either choose a new target or lose the attack or spell. This spell doesn't protect the warded creature from areas of effect. The spell ends if the warded creature makes an attack roll, casts a spell, or deals damage.
`,
      "Scorching Ray.md": `---
smType: spell
name: "Scorching Ray"
level: 2
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
attack: "ranged spell attack"
damage: "2d6"
damage_type: "Fire"
---

# Scorching Ray
Level 2 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Attack: ranged spell attack
- Damage: 2d6 Fire

You hurl three fiery rays. You can hurl them at one target within range or at several. Make a ranged spell attack for each ray. On a hit, the target takes 2d6 Fire damage.
`,
      "Scrying.md": `---
smType: spell
name: "Scrying"
level: 5
school: "Divination"
casting_time: "10 minutes"
range: "Self"
components: ["V", "S", "M"]
materials: "a focus worth 1,000+ GP, such as a crystal ball, mirror, or water-filled font"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Bard", "Cleric", "Druid", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Scrying
Level 5 Divination

- Casting Time: 10 minutes
- Range: Self
- Components: V, S, M (a focus worth 1,000+ GP, such as a crystal ball, mirror, or water-filled font)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Bard, Cleric, Druid, Warlock, Wizard
- Save: WIS

You can see and hear a creature you choose that is on the same plane of existence as you. The target makes a Wisdom saving throw, which is modified (see the tables below) by how well you know the target and the sort of physical connection you have to it. The target doesn't know what it is making the save against, only that it feels uneasy.

| Your Knowledge of the Target Is \u2026       | Save Modifier |

|-----------------------------------------|---------------|

| Secondhand (heard of the target)        | +5            |

| Firsthand (met the target)              | +0            |

| Extensive (know the target well)        | \u22125            |

| You Have the Target's \u2026                 | Save Modifier |

|-----------------------------------------|---------------|

| Picture or other likeness               | \u22122            |

| Garment or other possession             | \u22124            |

| Body part, lock of hair, or bit of nail | \u221210           |

On a successful save, the target isn't affected, and you can't use this spell on it again for 24 hours.

On a failed save, the spell creates an Invisible, intangible sensor within 10 feet of the target. You can see and hear through the sensor as if you were there. The sensor moves with the target, remaining within 10 feet of it for the duration. If something can see the sensor, it appears as a luminous orb about the size of your fist.

Instead of targeting a creature, you can target a location you have seen. When you do so, the sensor appears at that location and doesn't move.
`,
      "Searing Smite.md": `---
smType: spell
name: "Searing Smite"
level: 1
school: "Evocation"
casting_time: "Bonus Action, which you take immediately after hitting a target with a Melee weapon or an Unarmed Strike"
range: "Self"
duration: "1 minute"
classes: ["Paladin"]
save_ability: "CON"
damage: "1d6"
damage_type: "Fire"
---

# Searing Smite
Level 1 Evocation

- Casting Time: Bonus Action, which you take immediately after hitting a target with a Melee weapon or an Unarmed Strike
- Range: Self
- Duration: 1 minute
- Classes: Paladin
- Save: CON
- Damage: 1d6 Fire

As you hit the target, it takes an extra 1d6 Fire damage from the attack. At the start of each of its turns until the spell ends, the target takes 1d6 Fire damage and then makes a Constitution saving throw. On a failed save, the spell continues. On a successful save, the spell ends.
`,
      "Secret Chest.md": `---
smType: spell
name: "Secret Chest"
level: 4
school: "Conjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a chest, 3 feet by 2 feet by 2 feet, constructed from rare materials worth 5,000+ GP, and a Tiny replica of the chest made from the same materials worth 50+ GP"
duration: "Until dispelled"
classes: ["Wizard"]
---

# Secret Chest
Level 4 Conjuration

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a chest, 3 feet by 2 feet by 2 feet, constructed from rare materials worth 5,000+ GP, and a Tiny replica of the chest made from the same materials worth 50+ GP)
- Duration: Until dispelled
- Classes: Wizard

You hide a chest and all its contents on the Ethereal Plane. You must touch the chest and the miniature replica that serve as Material components for the spell. The chest can contain up to 12 cubic feet of nonliving material (3 feet by 2 feet by 2 feet).

While the chest remains on the Ethereal Plane, you can take a Magic action and touch the replica to recall the chest. It appears in an unoccupied space on the ground within 5 feet of you. You can send the chest back to the Ethereal Plane by taking a Magic action to touch the chest and the replica.

After 60 days, there is a cumulative 5 percent chance at the end of each day that the spell ends. The spell also ends if you cast this spell again or if the Tiny replica chest is destroyed. If the spell ends and the larger chest is on the Ethereal Plane, the chest remains there for you or someone else to find.
`,
      "See Invisibility.md": `---
smType: spell
name: "See Invisibility"
level: 2
school: "Divination"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a pinch of talc"
duration: "1 hour"
classes: ["Bard", "Sorcerer", "Wizard"]
---

# See Invisibility
Level 2 Divination

- Casting Time: Action
- Range: Self
- Components: V, S, M (a pinch of talc)
- Duration: 1 hour
- Classes: Bard, Sorcerer, Wizard

For the duration, you see creatures and objects that have the Invisible condition as if they were visible, and you can see into the Ethereal Plane. Creatures and objects there appear ghostly.
`,
      "Seeming.md": `---
smType: spell
name: "Seeming"
level: 5
school: "Illusion"
casting_time: "Action"
range: "30 feet"
components: ["V", "S"]
duration: "8 hours"
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "CHA"
---

# Seeming
Level 5 Illusion

- Casting Time: Action
- Range: 30 feet
- Components: V, S
- Duration: 8 hours
- Classes: Bard, Sorcerer, Wizard
- Save: CHA

You give an illusory appearance to each creature of your choice that you can see within range. An unwilling target can make a Charisma saving throw, and if it succeeds, it is unaffected by this spell.

You can give the same appearance or different ones to the targets. The spell can change the appearance of the targets' bodies and equipment. You can make each creature seem 1 foot shorter or taller and appear heavier or lighter. A target's new appearance must have the same basic arrangement of limbs as the target, but the extent of the illusion is otherwise up to you. The spell lasts for the duration.

The changes wrought by this spell fail to hold up to physical inspection. For example, if you use this spell to add a hat to a creature's outfit, objects pass through the hat.

A creature that takes the Study action to examine a target can make an Intelligence (Investigation) check against your spell save DC. If it succeeds, it becomes aware that the target is disguised.
`,
      "Sending.md": `---
smType: spell
name: "Sending"
level: 3
school: "Divination"
casting_time: "Action"
range: "Unlimited"
components: ["V", "S", "M"]
materials: "a copper wire"
duration: "Instantaneous"
classes: ["Bard", "Cleric", "Wizard"]
---

# Sending
Level 3 Divination

- Casting Time: Action
- Range: Unlimited
- Components: V, S, M (a copper wire)
- Duration: Instantaneous
- Classes: Bard, Cleric, Wizard

You send a short message of 25 words or fewer to a creature you have met or a creature described to you by someone who has met it. The target hears the message in its mind, recognizes you as the sender if it knows you, and can answer in a like manner immediately. The spell enables targets to understand the meaning of your message.

You can send the message across any distance and even to other planes of existence, but if the target is on a different plane than you, there is a 5 percent chance that the message doesn't arrive. You know if the delivery fails.

Upon receiving your message, a creature can block your ability to reach it again with this spell for 8 hours. If you try to send another message during that time, you learn that you are blocked, and the spell fails.
`,
      "Sequester.md": `---
smType: spell
name: "Sequester"
level: 7
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "gem dust worth 5,000+ GP, which the spell consumes"
duration: "Until dispelled"
classes: ["Wizard"]
---

# Sequester
Level 7 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (gem dust worth 5,000+ GP, which the spell consumes)
- Duration: Until dispelled
- Classes: Wizard

With a touch, you magically sequester an object or a willing creature. For the duration, the target has the Invisible condition and can't be targeted by Divination spells, detected by magic, or viewed remotely with magic.

If the target is a creature, it enters a state of suspended animation; it has the Unconscious condition, doesn't age, and doesn't need food, water, or air.

You can set a condition for the spell to end early. The condition can be anything you choose, but it must occur or be visible within 1 mile of the target. Examples include "after 1,000 years" or "when the tarrasque awakens." This spell also ends if the target takes any damage.
`,
      "Shapechange.md": `---
smType: spell
name: "Shapechange"
level: 9
school: "Transmutation"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a jade circlet worth 1,500+ GP"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Druid", "Wizard"]
---

# Shapechange
Level 9 Transmutation

- Casting Time: Action
- Range: Self
- Components: V, S, M (a jade circlet worth 1,500+ GP)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Druid, Wizard

You shape-shift into another creature for the duration or until you take a Magic action to shape-shift into a different eligible form. The new form must be of a creature that has a Challenge Rating no higher than your level or Challenge Rating. You must have seen the sort of creature before, and it can't be a Construct or an Undead.

When you cast the spell, you gain a number of Temporary Hit Points equal to the Hit Points of the first form into which you shape-shift. These Temporary Hit Points vanish if any remain when the spell ends.

Your game statistics are replaced by the stat block of the chosen form, but you retain your creature type; alignment; personality; Intelligence, Wisdom, and Charisma scores; Hit Points; Hit Point Dice; proficiencies; and ability to communicate. If you have the Spellcasting feature, you retain it too.

Upon shape-shifting, you determine whether your equipment drops to the ground or changes in size and shape to fit the new form while you're in it.
`,
      "Shatter.md": `---
smType: spell
name: "Shatter"
level: 2
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a chip of mica"
duration: "Instantaneous"
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "3d8"
damage_type: "Thunder"
---

# Shatter
Level 2 Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a chip of mica)
- Duration: Instantaneous
- Classes: Bard, Sorcerer, Wizard
- Save: CON (Half damage on success)
- Damage: 3d8 Thunder

A loud noise erupts from a point of your choice within range. Each creature in a 10-foot-radius Sphere centered there makes a Constitution saving throw, taking 3d8 Thunder damage on a failed save or half as much damage on a successful one. A Construct has Disadvantage on the save.

A nonmagical object that isn't being worn or carried also takes the damage if it's in the spell's area.
`,
      "Shield of Faith.md": `---
smType: spell
name: "Shield of Faith"
level: 1
school: "Abjuration"
casting_time: "Bonus Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a prayer scroll"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Cleric", "Paladin"]
---

# Shield of Faith
Level 1 Abjuration

- Casting Time: Bonus Action
- Range: 60 feet
- Components: V, S, M (a prayer scroll)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Cleric, Paladin

A shimmering field surrounds a creature of your choice within range, granting it a +2 bonus to AC for the duration.
`,
      "Shield.md": `---
smType: spell
name: "Shield"
level: 1
school: "Abjuration"
casting_time: "Reaction, which you take when you are hit by an attack roll or targeted by the *Magic Missile* spell"
range: "Self"
components: ["V", "S"]
duration: "1 round"
classes: ["Sorcerer", "Wizard"]
---

# Shield
Level 1 Abjuration

- Casting Time: Reaction, which you take when you are hit by an attack roll or targeted by the *Magic Missile* spell
- Range: Self
- Components: V, S
- Duration: 1 round
- Classes: Sorcerer, Wizard

An imperceptible barrier of magical force protects you. Until the start of your next turn, you have a +5 bonus to AC, including against the triggering attack, and you take no damage from *Magic Missile*.
`,
      "Shillelagh.md": `---
smType: spell
name: "Shillelagh"
level: 0
school: "Transmutation"
casting_time: "Bonus Action"
range: "Self"
components: ["V", "S", "M"]
materials: "mistletoe"
duration: "1 minute"
classes: ["Druid"]
---

# Shillelagh
Cantrip Transmutation

- Casting Time: Bonus Action
- Range: Self
- Components: V, S, M (mistletoe)
- Duration: 1 minute
- Classes: Druid

A Club or Quarterstaff you are holding is imbued with nature's power. For the duration, you can use your spellcasting ability instead of Strength for the attack and damage rolls of melee attacks using that weapon, and the weapon's damage die becomes a d8. If the attack deals damage, it can be Force damage or the weapon's normal damage type (your choice).

The spell ends early if you cast it again or if you let go of the weapon.
`,
      "Shining Smite.md": `---
smType: spell
name: "Shining Smite"
level: 2
school: "Transmutation"
casting_time: "Bonus Action, which you take immediately after hitting a creature with a Melee weapon or an Unarmed Strike"
range: "Self"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Paladin"]
damage: "2d6"
damage_type: "Radiant"
---

# Shining Smite
Level 2 Transmutation

- Casting Time: Bonus Action, which you take immediately after hitting a creature with a Melee weapon or an Unarmed Strike
- Range: Self
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Paladin
- Damage: 2d6 Radiant

The target hit by the strike takes an extra 2d6 Radiant damage from the attack. Until the spell ends, the target sheds Bright Light in a 5-foot radius, attack rolls against it have Advantage, and it can't benefit from the Invisible condition.
`,
      "Shocking Grasp.md": `---
smType: spell
name: "Shocking Grasp"
level: 0
school: "Evocation"
casting_time: "Action"
range: "Touch"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
attack: "melee spell attack"
damage: "1d8"
damage_type: "Lightning"
---

# Shocking Grasp
Cantrip Evocation

- Casting Time: Action
- Range: Touch
- Components: V, S
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Attack: melee spell attack
- Damage: 1d8 Lightning

Lightning springs from you to a creature that you try to touch. Make a melee spell attack against the target. On a hit, the target takes 1d8 Lightning damage, and it can't make Opportunity Attacks until the start of its next turn.
`,
      "Silence.md": `---
smType: spell
name: "Silence"
level: 2
school: "Illusion"
casting_time: "Action or Ritual"
range: "120 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
ritual: true
classes: ["Bard", "Cleric", "Ranger"]
---

# Silence
Level 2 Illusion

- Casting Time: Action or Ritual
- Range: 120 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Ritual: yes
- Classes: Bard, Cleric, Ranger

For the duration, no sound can be created within or pass through a 20-foot-radius Sphere centered on a point you choose within range. Any creature or object entirely inside the Sphere has Immunity to Thunder damage, and creatures have the Deafened condition while entirely inside it. Casting a spell that includes a Verbal component is impossible there.
`,
      "Silent Image.md": `---
smType: spell
name: "Silent Image"
level: 1
school: "Illusion"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a bit of fleece"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
---

# Silent Image
Level 1 Illusion

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a bit of fleece)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard

You create the image of an object, a creature, or some other visible phenomenon that is no larger than a 15-foot Cube. The image appears at a spot within range and lasts for the duration. The image is purely visual; it isn't accompanied by sound, smell, or other sensory effects.

As a Magic action, you can cause the image to move to any spot within range. As the image changes location, you can alter its appearance so that its movements appear natural for the image. For example, if you create an image of a creature and move it, you can alter the image so that it appears to be walking.

Physical interaction with the image reveals it to be an illusion, since things can pass through it. A creature that takes a Study action to examine the image can determine that it is an illusion with a successful Intelligence (Investigation) check against your spell save DC. If a creature discerns the illusion for what it is, the creature can see through the image.
`,
      "Simulacrum.md": `---
smType: spell
name: "Simulacrum"
level: 7
school: "Illusion"
casting_time: "12 hours"
range: "Touch"
components: ["V", "S", "M"]
materials: "powdered ruby worth 1,500+ GP, which the spell consumes"
duration: "Until dispelled"
classes: ["Wizard"]
save_effect: "Half damage on success"
---

# Simulacrum
Level 7 Illusion

- Casting Time: 12 hours
- Range: Touch
- Components: V, S, M (powdered ruby worth 1,500+ GP, which the spell consumes)
- Duration: Until dispelled
- Classes: Wizard

You create a simulacrum of one Beast or Humanoid that is within 10 feet of you for the entire casting of the spell. You finish the casting by touching both the creature and a pile of ice or snow that is the same size as that creature, and the pile turns into the simulacrum, which is a creature. It uses the game statistics of the original creature at the time of casting, except it is a Construct, its Hit Point maximum is half as much, and it can't cast this spell.

The simulacrum is Friendly to you and creatures you designate. It obeys your commands and acts on your turn in combat. The simulacrum can't gain levels, and it can't take Short or Long Rests.

If the simulacrum takes damage, the only way to restore its Hit Points is to repair it as you take a Long Rest, during which you expend components worth 100 GP per Hit Point restored. The simulacrum must stay within 5 feet of you for the repair.

The simulacrum lasts until it drops to 0 Hit Points, at which point it reverts to snow and melts away. If you cast this spell again, any simulacrum you created with this spell is instantly destroyed.
`,
      "Sleep.md": `---
smType: spell
name: "Sleep"
level: 1
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a pinch of sand or rose petals"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "WIS"
---

# Sleep
Level 1 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a pinch of sand or rose petals)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard
- Save: WIS

Each creature of your choice in a 5-foot-radius Sphere centered on a point within range must succeed on a Wisdom saving throw or have the Incapacitated condition until the end of its next turn, at which point it must repeat the save. If the target fails the second save, the target has the Unconscious condition for the duration. The spell ends on a target if it takes damage or someone within 5 feet of it takes an action to shake it out of the spell's effect.

Creatures that don't sleep, such as elves, or that have Immunity to the Exhaustion condition automatically succeed on saves against this spell.
`,
      "Sleet Storm.md": `---
smType: spell
name: "Sleet Storm"
level: 3
school: "Conjuration"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "a miniature umbrella"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "DEX"
---

# Sleet Storm
Level 3 Conjuration

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (a miniature umbrella)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Sorcerer, Wizard
- Save: DEX

Until the spell ends, sleet falls in a 40-foot-tall, 20-foot-radius Cylinder centered on a point you choose within range. The area is Heavily Obscured, and exposed flames in the area are doused.

Ground in the Cylinder is Difficult Terrain. When a creature enters the Cylinder for the first time on a turn or starts its turn there, it must succeed on a

Dexterity saving throw or have the Prone condition and lose Concentration.
`,
      "Slow.md": `---
smType: spell
name: "Slow"
level: 3
school: "Transmutation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a drop of molasses"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "WIS"
---

# Slow
Level 3 Transmutation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a drop of molasses)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard
- Save: WIS

You alter time around up to six creatures of your choice in a 40-foot Cube within range. Each target must succeed on a Wisdom saving throw or be affected by this spell for the duration.

An affected target's Speed is halved, it takes a \u22122 penalty to AC and Dexterity saving throws, and it can't take Reactions. On its turns, it can take either an action or a Bonus Action, not both, and it can make only one attack if it takes the Attack action. If it casts a spell with a Somatic component, there is a 25 percent chance the spell fails as a result of the target making the spell's gestures too slowly.

An affected target repeats the save at the end of each of its turns, ending the spell on itself on a success.
`,
      "Sorcerous Burst.md": `---
smType: spell
name: "Sorcerous Burst"
level: 0
school: "Evocation"
casting_time: "Action"
range: "120 feet"
duration: "Instantaneous"
classes: ["Sorcerer"]
attack: "ranged spell attack"
---

# Sorcerous Burst
Cantrip Evocation

- Casting Time: Action
- Range: 120 feet
- Duration: Instantaneous
- Classes: Sorcerer
- Attack: ranged spell attack

You cast sorcerous energy at one creature or object within range. Make a ranged spell attack against the target. On a hit, the target takes 1d8 damage of a type you choose: Acid, Cold, Fire, Lightning, Poison, Psychic, or Thunder.

If you roll an 8 on a d8 for this spell, you can roll another d8, and add it to the damage. When you cast this spell, the maximum number of these d8s you can add to the spell's damage equals your spellcasting ability modifier.
`,
      "Spare the Dying.md": `---
smType: spell
name: "Spare the Dying"
level: 0
school: "Necromancy"
casting_time: "Action"
range: "15 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Cleric", "Druid"]
---

# Spare the Dying
Cantrip Necromancy

- Casting Time: Action
- Range: 15 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Cleric, Druid

Choose a creature within range that has 0 Hit Points and isn't dead. The creature becomes Stable.
`,
      "Speak with Animals.md": `---
smType: spell
name: "Speak with Animals"
level: 1
school: "Divination"
casting_time: "Action or Ritual"
range: "Self"
components: ["V", "S"]
duration: "10 minutes"
ritual: true
classes: ["Bard", "Druid", "Ranger", "Warlock"]
---

# Speak with Animals
Level 1 Divination

- Casting Time: Action or Ritual
- Range: Self
- Components: V, S
- Duration: 10 minutes
- Ritual: yes
- Classes: Bard, Druid, Ranger, Warlock

For the duration, you can comprehend and verbally communicate with Beasts, and you can use any of the Influence action's skill options with them.

Most Beasts have little to say about topics that don't pertain to survival or companionship, but at minimum, a Beast can give you information about nearby locations and monsters, including whatever it has perceived within the past day.
`,
      "Speak with Dead.md": `---
smType: spell
name: "Speak with Dead"
level: 3
school: "Necromancy"
casting_time: "Action"
range: "10 feet"
components: ["V", "S", "M"]
materials: "burning incense"
duration: "10 minutes"
classes: ["Bard", "Cleric", "Wizard"]
---

# Speak with Dead
Level 3 Necromancy

- Casting Time: Action
- Range: 10 feet
- Components: V, S, M (burning incense)
- Duration: 10 minutes
- Classes: Bard, Cleric, Wizard

You grant the semblance of life to a corpse of your choice within range, allowing it to answer questions you pose. The corpse must have a mouth, and this spell fails if the deceased creature was Undead when it died. The spell also fails if the corpse was the target of this spell within the past 10 days.

Until the spell ends, you can ask the corpse up to five questions. The corpse knows only what it knew in life, including the languages it knew. Answers are usually brief, cryptic, or repetitive, and the corpse is under no compulsion to offer a truthful answer if you are antagonistic toward it or it recognizes you as an enemy. This spell doesn't return the creature's soul to its body, only its animating spirit. Thus, the corpse can't learn new information, doesn't comprehend anything that has happened since it died, and can't speculate about future events.
`,
      "Speak with Plants.md": `---
smType: spell
name: "Speak with Plants"
level: 3
school: "Transmutation"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "10 minutes"
classes: ["Bard", "Druid", "Ranger"]
---

# Speak with Plants
Level 3 Transmutation

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: 10 minutes
- Classes: Bard, Druid, Ranger

You imbue plants in an immobile 30-foot Emanation with limited sentience and animation, giving them the ability to communicate with you and follow your simple commands. You can question plants about events in the spell's area within the past day, gaining information about creatures that have passed, weather, and other circumstances.

You can also turn Difficult Terrain caused by plant growth (such as thickets and undergrowth) into ordinary terrain that lasts for the duration. Or you can turn ordinary terrain where plants are present into Difficult Terrain that lasts for the duration.

The spell doesn't enable plants to uproot themselves and move about, but they can move their branches, tendrils, and stalks for you.

If a Plant creature is in the area, you can communicate with it as if you shared a common language.
`,
      "Spider Climb.md": `---
smType: spell
name: "Spider Climb"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a drop of bitumen and a spider"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Sorcerer", "Warlock", "Wizard"]
---

# Spider Climb
Level 2 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a drop of bitumen and a spider)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Sorcerer, Warlock, Wizard

Until the spell ends, one willing creature you touch gains the ability to move up, down, and across vertical surfaces and along ceilings, while leaving its hands free. The target also gains a Climb Speed equal to its Speed.
`,
      "Spike Growth.md": `---
smType: spell
name: "Spike Growth"
level: 2
school: "Transmutation"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "seven thorns"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid", "Ranger"]
damage: "2d4"
damage_type: "Piercing"
---

# Spike Growth
Level 2 Transmutation

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (seven thorns)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid, Ranger
- Damage: 2d4 Piercing

The ground in a 20-foot-radius Sphere centered on a point within range sprouts hard spikes and thorns. The area becomes Difficult Terrain for the duration. When a creature moves into or within the area, it takes 2d4 Piercing damage for every 5 feet it travels.

The transformation of the ground is camouflaged to look natural. Any creature that can't see the area when the spell is cast must take a Search action and succeed on a Wisdom (Perception or Survival) check against your spell save DC to recognize the terrain as hazardous before entering it.
`,
      "Spirit Guardians.md": `---
smType: spell
name: "Spirit Guardians"
level: 3
school: "Conjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a prayer scroll"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Cleric"]
save_ability: "WIS"
save_effect: "Half damage on success"
damage: "3d8"
damage_type: "Radiant"
---

# Spirit Guardians
Level 3 Conjuration

- Casting Time: Action
- Range: Self
- Components: V, S, M (a prayer scroll)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Cleric
- Save: WIS (Half damage on success)
- Damage: 3d8 Radiant

Protective spirits flit around you in a 15-foot Emanation for the duration. If you are good or neutral, their spectral form appears angelic or fey (your choice). If you are evil, they appear fiendish.

When you cast this spell, you can designate creatures to be unaffected by it. Any other creature's Speed is halved in the Emanation, and whenever the Emanation enters a creature's space and whenever a creature enters the Emanation or ends its turn there, the creature must make a Wisdom saving throw. On a failed save, the creature takes 3d8 Radiant damage (if you are good or neutral) or 3d8 Necrotic damage (if you are evil). On a successful save, the creature takes half as much damage. A creature makes this save only once per turn.
`,
      "Spiritual Weapon.md": `---
smType: spell
name: "Spiritual Weapon"
level: 2
school: "Evocation"
casting_time: "Bonus Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric"]
attack: "melee spell attack"
---

# Spiritual Weapon
Level 2 Evocation

- Casting Time: Bonus Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric
- Attack: melee spell attack

You create a floating, spectral force that resembles a weapon of your choice and lasts for the duration. The force appears within range in a space of your choice, and you can immediately make one melee spell attack against one creature within 5 feet of the force. On a hit, the target takes Force damage equal to 1d8 plus your spellcasting ability modifier.

As a Bonus Action on your later turns, you can move the force up to 20 feet and repeat the attack against a creature within 5 feet of it.
`,
      "Starry Wisp.md": `---
smType: spell
name: "Starry Wisp"
level: 0
school: "Evocation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Bard", "Druid"]
attack: "ranged spell attack"
damage: "1d8"
damage_type: "Radiant"
---

# Starry Wisp
Cantrip Evocation

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Instantaneous
- Classes: Bard, Druid
- Attack: ranged spell attack
- Damage: 1d8 Radiant

You launch a mote of light at one creature or object within range. Make a ranged spell attack against the target. On a hit, the target takes 1d8 Radiant damage, and until the end of your next turn, it emits Dim Light in a 10-foot radius and can't benefit from the Invisible condition.
`,
      "Stinking Cloud.md": `---
smType: spell
name: "Stinking Cloud"
level: 3
school: "Conjuration"
casting_time: "Action"
range: "90 feet"
components: ["V", "S", "M"]
materials: "a rotten egg"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Bard", "Sorcerer", "Wizard"]
save_ability: "CON"
---

# Stinking Cloud
Level 3 Conjuration

- Casting Time: Action
- Range: 90 feet
- Components: V, S, M (a rotten egg)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Bard, Sorcerer, Wizard
- Save: CON

You create a 20-foot-radius Sphere of yellow, nauseating gas centered on a point within range. The cloud is Heavily Obscured. The cloud lingers in the air for the duration or until a strong wind (such as the one created by *Gust of Wind*) disperses it.

Each creature that starts its turn in the Sphere must succeed on a Constitution saving throw or have the Poisoned condition until the end of the current turn. While Poisoned in this way, the creature can't take an action or a Bonus Action.
`,
      "Stone Shape.md": `---
smType: spell
name: "Stone Shape"
level: 4
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "soft clay"
duration: "Instantaneous"
classes: ["Cleric", "Druid", "Wizard"]
---

# Stone Shape
Level 4 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (soft clay)
- Duration: Instantaneous
- Classes: Cleric, Druid, Wizard

You touch a stone object of Medium size or smaller or a section of stone no more than 5 feet in any dimension and form it into any shape you like. For example, you could shape a large rock into a weapon, statue, or coffer, or you could make a small passage through a wall that is 5 feet thick. You could also shape a stone door or its frame to seal the door shut. The object you create can have up to two hinges and a latch, but finer mechanical detail isn't possible.
`,
      "Stoneskin.md": `---
smType: spell
name: "Stoneskin"
level: 4
school: "Transmutation"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "diamond dust worth 100+ GP, which the spell consumes"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Druid", "Ranger", "Sorcerer", "Wizard"]
---

# Stoneskin
Level 4 Transmutation

- Casting Time: Action
- Range: Touch
- Components: V, S, M (diamond dust worth 100+ GP, which the spell consumes)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Druid, Ranger, Sorcerer, Wizard

Until the spell ends, one willing creature you touch has Resistance to Bludgeoning, Piercing, and Slashing damage.
`,
      "Storm of Vengeance.md": `---
smType: spell
name: "Storm of Vengeance"
level: 9
school: "Conjuration"
casting_time: "Action"
range: "1 mile"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "2d6"
damage_type: "Thunder"
---

# Storm of Vengeance
Level 9 Conjuration

- Casting Time: Action
- Range: 1 mile
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid
- Save: CON (Half damage on success)
- Damage: 2d6 Thunder

A churning storm cloud forms for the duration, centered on a point within range and spreading to a radius of 300 feet. Each creature under the cloud when it appears must succeed on a Constitution saving throw or take 2d6 Thunder damage and have the Deafened condition for the duration.

At the start of each of your later turns, the storm produces different effects, as detailed below.

**_Turn 2._** Acidic rain falls. Each creature and object under the cloud takes 4d6 Acid damage.

**_Turn 3._** You call six bolts of lightning from the cloud to strike six different creatures or objects beneath it. Each target makes a Dexterity saving throw, taking 10d6 Lightning damage on a failed save or half as much damage on a successful one.

**_Turn 4._** Hailstones rain down. Each creature under the cloud takes 2d6 Bludgeoning damage.

**_Turns 5\u201310._** Gusts and freezing rain assail the area under the cloud. Each creature there takes 1d6 Cold damage. Until the spell ends, the area is Difficult Terrain and Heavily Obscured, ranged attacks with weapons are impossible there, and strong wind blows through the area.
`,
      "Suggestion.md": `---
smType: spell
name: "Suggestion"
level: 2
school: "Enchantment"
casting_time: "Action"
range: "30 feet"
components: ["V", "M"]
materials: "a drop of honey"
duration: "Concentration, up to 8 hours"
concentration: true
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
save_ability: "WIS"
---

# Suggestion
Level 2 Enchantment

- Casting Time: Action
- Range: 30 feet
- Components: V, M (a drop of honey)
- Duration: Concentration, up to 8 hours
- Concentration: yes
- Classes: Bard, Sorcerer, Warlock, Wizard
- Save: WIS

You suggest a course of activity\u2014described in no more than 25 words\u2014to one creature you can see within range that can hear and understand you. The suggestion must sound achievable and not involve anything that would obviously deal damage to the target or its allies. For example, you could say, "Fetch the key to the cult's treasure vault, and give the key to me." Or you could say, "Stop fighting, leave this library peacefully, and don't return."

The target must succeed on a Wisdom saving throw or have the Charmed condition for the duration or until you or your allies deal damage to the target. The Charmed target pursues the suggestion to the best of its ability. The suggested activity can continue for the entire duration, but if the suggested activity can be completed in a shorter time, the spell ends for the target upon completing it.
`,
      "Summon Dragon.md": `---
smType: spell
name: "Summon Dragon"
level: 5
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "an object with the image of a dragon engraved on it worth 500+ GP"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Wizard"]
---

# Summon Dragon
Level 5 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (an object with the image of a dragon engraved on it worth 500+ GP)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Wizard

You call forth a Dragon spirit. It manifests in an unoccupied space that you can see within range and uses the **Draconic Spirit** stat block. The creature disappears when it drops to 0 Hit Points or when the spell ends.

The creature is an ally to you and your allies. In combat, the creature shares your Initiative count, but it takes its turn immediately after yours. It obeys your verbal commands (no action required by you). If you don't issue any, it takes the Dodge action and uses its movement to avoid danger.

## At Higher Levels

> #### Draconic Spirit

>

> *Large Dragon, Neutral*

>

> **AC** 14 + the spell's level

>

> **HP** 50 + 10 for each spell level above 5

>

> **Speed** 30 ft., Fly 60 ft., Swim 30 ft.

>

> | Attribute | Score | Mod | Save |

> |-----------|-------|-----|------|

> | Str       | 19    | +4  | +4   |

> | Dex       | 14    | +2  | +2   |

> | Con       | 17    | +3  | +3   |

> | Int       | 10    | +0  | +0   |

> | Wis       | 14    | +2  | +2   |

> | Cha       | 14    | +2  | +2   |

>

> **Resistances** Acid, Cold, Fire, Lightning, Poison

>

> **Immunities** Charmed, Frightened, Poisoned

>

> **Senses** Blindsight 30 ft., Darkvision 60 ft.; Passive Perception 12

>

> **Languages** Draconic, understands the languages you know **CR** None (XP 0; PB equals your Proficiency Bonus)

>

> ##### Traits

>

> **_Shared Resistances._** When you summon the spirit, choose one of its Resistances. You have Resistance to the chosen damage type until the spell ends.

>

> ##### Actions

>

> **_Multiattack._** The spirit makes a number of Rend attacks equal to half the spell's level (round down), and it uses Breath Weapon.

>

> **_Rend. Melee Attack Roll:_** Bonus equals your spell attack modifier, reach 10 feet. *Hit:* 1d6 + 4 + the spell's level Piercing damage.

>

> **_Breath Weapon. Dexterity Saving Throw:_** DC equals your spell save DC, each creature in a 30-foot Cone. *Failure:* 2d6 damage of a type this spirit has Resistance to (your choice when you cast the spell). *Success:*  Half damage.
`,
      "Sunbeam.md": `---
smType: spell
name: "Sunbeam"
level: 6
school: "Evocation"
casting_time: "Action"
range: "Self"
components: ["V", "S", "M"]
materials: "a magnifying glass"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Cleric", "Druid", "Sorcerer", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "6d8"
damage_type: "Radiant"
---

# Sunbeam
Level 6 Evocation

- Casting Time: Action
- Range: Self
- Components: V, S, M (a magnifying glass)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Cleric, Druid, Sorcerer, Wizard
- Save: CON (Half damage on success)
- Damage: 6d8 Radiant

You launch a sunbeam in a 5-foot-wide, 60-foot-long Line. Each creature in the Line makes a Constitution saving throw. On a failed save, a creature takes 6d8 Radiant damage and has the Blinded condition until the start of your next turn. On a successful save, it takes half as much damage only.

Until the spell ends, you can take a Magic action to create a new Line of radiance.

For the duration, a mote of brilliant radiance shines above you. It sheds Bright Light in a 30-foot radius and Dim Light for an additional 30 feet. This light is sunlight.
`,
      "Sunburst.md": `---
smType: spell
name: "Sunburst"
level: 8
school: "Evocation"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "a piece of sunstone"
duration: "Instantaneous"
classes: ["Cleric", "Druid", "Sorcerer", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "12d6"
damage_type: "Radiant"
---

# Sunburst
Level 8 Evocation

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (a piece of sunstone)
- Duration: Instantaneous
- Classes: Cleric, Druid, Sorcerer, Wizard
- Save: CON (Half damage on success)
- Damage: 12d6 Radiant

Brilliant sunlight flashes in a 60-foot-radius Sphere centered on a point you choose within range. Each creature in the Sphere makes a Constitution saving throw. On a failed save, a creature takes 12d6 Radiant damage and has the Blinded condition for 1 minute. On a successful save, it takes half as much damage only.

A creature Blinded by this spell makes another Constitution saving throw at the end of each of its turns, ending the effect on itself on a success.

This spell dispels Darkness in its area that was created by any spell.
`,
      "Symbol.md": `---
smType: spell
name: "Symbol"
level: 7
school: "Abjuration"
casting_time: "1 minute"
range: "Touch"
components: ["V", "S", "M"]
materials: "powdered diamond worth 1,000+ GP, which the spell consumes"
duration: "Until dispelled or triggered"
classes: ["Bard", "Cleric", "Druid", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "10d10"
damage_type: "Necrotic"
---

# Symbol
Level 7 Abjuration

- Casting Time: 1 minute
- Range: Touch
- Components: V, S, M (powdered diamond worth 1,000+ GP, which the spell consumes)
- Duration: Until dispelled or triggered
- Classes: Bard, Cleric, Druid, Wizard
- Save: CON (Half damage on success)
- Damage: 10d10 Necrotic

You inscribe a harmful glyph either on a surface (such as a section of floor or wall) or within an object that can be closed (such as a book or chest). The glyph can cover an area no larger than 10 feet in diameter. If you choose an object, it must remain in place; if it is moved more than 10 feet from where you cast this spell, the glyph is broken, and the spell ends without being triggered.

The glyph is nearly imperceptible and requires a successful Wisdom (Perception) check against your spell save DC to notice.

When you inscribe the glyph, you set its trigger and choose which effect the symbol bears: Death, Discord, Fear, Pain, Sleep, or Stunning. Each one is explained below.

**_Set the Trigger._** You decide what triggers the glyph when you cast the spell. For glyphs inscribed on a surface, common triggers include touching or stepping on the glyph, removing another object covering it, or approaching within a certain distance of it. For glyphs inscribed within an object, common triggers include opening that object or seeing the glyph.

You can refine the trigger so that only creatures of certain types activate it (for example, the glyph could be set to affect Aberrations). You can also set conditions for creatures that don't trigger the glyph, such as those who say a certain password.

Once triggered, the glyph glows, filling a 60-foot-radius Sphere with Dim Light for 10 minutes, after which time the spell ends. Each creature in the Sphere when the glyph activates is targeted by its effect, as is a creature that enters the Sphere for the first time on a turn or ends its turn there. A creature is targeted only once per turn.

**_Death._** Each target makes a Constitution saving throw, taking 10d10 Necrotic damage on a failed save or half as much damage on a successful save.

**_Discord._** Each target makes a Wisdom saving throw. On a failed save, a target argues with other creatures for 1 minute. During this time, it is incapable of meaningful communication and has Disadvantage on attack rolls and ability checks.

**_Fear._** Each target must succeed on a Wisdom saving throw or have the Frightened condition for 1 minute. While Frightened, the target must move at least 30 feet away from the glyph on each of its turns, if able.

**_Pain._** Each target must succeed on a Constitution saving throw or have the Incapacitated condition for 1 minute.

**_Sleep._** Each target must succeed on a Wisdom saving throw or have the Unconscious condition for 10 minutes. A creature awakens if it takes damage or if someone takes an action to shake it awake.

**_Stunning._** Each target must succeed on a Wisdom saving throw or have the Stunned condition for 1 minute.

### T Spells
`,
      "Telekinesis.md": `---
smType: spell
name: "Telekinesis"
level: 5
school: "Transmutation"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Sorcerer", "Wizard"]
save_ability: "STR"
---

# Telekinesis
Level 5 Transmutation

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Sorcerer, Wizard
- Save: STR

You gain the ability to move or manipulate creatures or objects by thought. When you cast the spell and as a Magic action on your later turns before the spell ends, you can exert your will on one creature or object that you can see within range, causing the appropriate effect below. You can affect the same target round after round or choose a new one at any time. If you switch targets, the prior target is no longer affected by the spell.

**_Creature._** You can try to move a Huge or smaller creature. The target must succeed on a Strength saving throw, or you move it up to 30 feet in any direction within the spell's range. Until the end of your next turn, the creature has the Restrained condition, and if you lift it into the air, it is suspended there. It falls at the end of your next turn unless you use this option on it again and it fails the save.

**_Object._** You can try to move a Huge or smaller object. If the object isn't being worn or carried, you automatically move it up to 30 feet in any direction within the spell's range.

If the object is worn or carried by a creature, that creature must succeed on a Strength saving throw, or you pull the object away and move it up to 30 feet in any direction within the spell's range.

You can exert fine control on objects with your telekinetic grip, such as manipulating a simple tool,
`,
      "Telepathic Bond.md": `---
smType: spell
name: "Telepathic Bond"
level: 5
school: "Divination"
casting_time: "Action or Ritual"
range: "30 feet"
components: ["V", "S", "M"]
materials: "two eggs"
duration: "1 hour"
ritual: true
classes: ["Bard", "Wizard"]
---

# Telepathic Bond
Level 5 Divination

- Casting Time: Action or Ritual
- Range: 30 feet
- Components: V, S, M (two eggs)
- Duration: 1 hour
- Ritual: yes
- Classes: Bard, Wizard

You forge a telepathic link among up to eight willing creatures of your choice within range, psychically linking each creature to all the others for the duration. Creatures that can't communicate in any languages aren't affected by this spell.

Until the spell ends, the targets can communicate telepathically through the bond whether or not they share a language. The communication is possible over any distance, though it can't extend to other planes of existence.
`,
      "Teleport.md": `---
smType: spell
name: "Teleport"
level: 7
school: "Conjuration"
casting_time: "Action"
range: "10 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Bard", "Sorcerer", "Wizard"]
damage: "3d10"
damage_type: "Force"
---

# Teleport
Level 7 Conjuration

- Casting Time: Action
- Range: 10 feet
- Components: V
- Duration: Instantaneous
- Classes: Bard, Sorcerer, Wizard
- Damage: 3d10 Force

This spell instantly transports you and up to eight willing creatures that you can see within range, or a single object that you can see within range, to a destination you select. If you target an object, it must be Large or smaller, and it can't be held or carried by an unwilling creature.

The destination you choose must be known to you, and it must be on the same plane of existence as you. Your familiarity with the destination determines whether you arrive there successfully. The GM rolls 1d100 and consults the Teleportation Outcome table and the explanations after it.

Table: Teleportation Outcome

| Familiarity              | Mishap | Similar Area | Off Target | On Target |

|--------------------------|--------|--------------|------------|-----------|

| Permanent circle         | \u2014      | \u2014            | \u2014          | 01\u201300     |

| Linked object            | \u2014      | \u2014            | \u2014          | 01\u201300     |

| Very familiar            | 01\u201305  | 06\u201313        | 14\u201324      | 25\u201300     |

| Seen casually            | 01\u201333  | 34\u201343        | 44\u201353      | 54\u201300     |

| Viewed once or described | 01\u201343  | 44\u201353        | 54\u201373      | 74\u201300     |

| False destination        | 01\u201350  | 51\u201300        | \u2014          | \u2014         |

**_Familiarity._** Here are the meanings of the terms in the table's Familiarity column:

- "Permanent circle" means a permanent teleportation circle whose sigil sequence you know.

- "Linked object" means you possess an object taken from the desired destination within the last six months, such as a book from a wizard's library.

- "Very familiar" is a place you have visited often, a place you have carefully studied, or a place you can see when you cast the spell.

- "Seen casually" is a place you have seen more than once but with which you aren't very familiar.

- "Viewed once or described" is a place you have seen once, possibly using magic, or a place you know through someone else's description, perhaps from a map.

- "False destination" is a place that doesn't exist. Perhaps you tried to scry an enemy's sanctum but instead viewed an illusion, or you are attempting to teleport to a location that no longer exists.

**_Mishap._** The spell's unpredictable magic results in a difficult journey. Each teleporting creature (or the target object) takes 3d10 Force damage, and the GM rerolls on the table to see where you wind up (multiple mishaps can occur, dealing damage each time).

**_Similar Area._** You and your group (or the target object) appear in a different area that's visually or thematically similar to the target area. You appear in the closest similar place. If you are heading for your home laboratory, for example, you might appear in another person's laboratory in the same city.

**_Off Target._** You and your group (or the target object) appear 2d12 miles away from the destination in a random direction. Roll 1d8 for the direction: 1, east; 2, southeast; 3, south; 4, southwest; 5, west; 6, northwest; 7, north; or 8, northeast.

**_On Target._** You and your group (or the target object) appear where you intended.
`,
      "Teleportation Circle.md": `---
smType: spell
name: "Teleportation Circle"
level: 5
school: "Conjuration"
casting_time: "1 minute"
range: "10 feet"
components: ["V", "M"]
materials: "rare inks worth 50+ GP, which the spell consumes"
duration: "1 round"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# Teleportation Circle
Level 5 Conjuration

- Casting Time: 1 minute
- Range: 10 feet
- Components: V, M (rare inks worth 50+ GP, which the spell consumes)
- Duration: 1 round
- Classes: Bard, Sorcerer, Warlock, Wizard

As you cast the spell, you draw a 5-foot-radius circle on the ground inscribed with sigils that link your location to a permanent teleportation circle of your choice whose sigil sequence you know and that is on the same plane of existence as you. A shimmering portal opens within the circle you drew and remains open until the end of your next turn. Any creature that enters the portal instantly appears within 5 feet of the destination circle or in the nearest unoccupied space if that space is occupied.

Many major temples, guildhalls, and other important places have permanent teleportation circles. Each circle includes a unique sigil sequence\u2014a string of runes arranged in a particular pattern.

When you first gain the ability to cast this spell, you learn the sigil sequences for two destinations on the Material Plane, determined by the GM. You might learn additional sigil sequences during your adventures. You can commit a new sigil sequence to memory after studying it for 1 minute.

You can create a permanent teleportation circle by casting this spell in the same location every day for 365 days.
`,
      "Thaumaturgy.md": `---
smType: spell
name: "Thaumaturgy"
level: 0
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V"]
duration: "Up to 1 minute"
classes: ["Cleric"]
---

# Thaumaturgy
Cantrip Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V
- Duration: Up to 1 minute
- Classes: Cleric

You manifest a minor wonder within range. You create one of the effects below within range. If you cast this spell multiple times, you can have up to three of its 1-minute effects active at a time.

**_Altered Eyes._** You alter the appearance of your eyes for 1 minute.

**_Booming Voice._** Your voice booms up to three times as loud as normal for 1 minute. For the duration, you have Advantage on Charisma (Intimidation) checks.

**_Fire Play._** You cause flames to flicker, brighten, dim, or change color for 1 minute.

**_Invisible Hand._** You instantaneously cause an unlocked door or window to fly open or slam shut.

**_Phantom Sound._** You create an instantaneous sound that originates from a point of your choice within range, such as a rumble of thunder, the cry of a raven, or ominous whispers.

**_Tremors._** You cause harmless tremors in the ground for 1 minute.
`,
      "Thunderwavea.md": `---
smType: spell
name: "Thunderwavea"
level: 1
school: "Evocation"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Instantaneous"
classes: ["Bard", "Druid", "Sorcerer", "Wizard"]
save_ability: "CON"
save_effect: "Half damage on success"
damage: "2d8"
damage_type: "Thunder"
---

# Thunderwavea
Level 1 Evocation

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Instantaneous
- Classes: Bard, Druid, Sorcerer, Wizard
- Save: CON (Half damage on success)
- Damage: 2d8 Thunder

You unleash a wave of thunderous energy. Each creature in a 15-foot Cube originating from you makes a Constitution saving throw. On a failed save, a creature takes 2d8 Thunder damage and is pushed 10 feet away from you. On a successful save, a creature takes half as much damage only.

In addition, unsecured objects that are entirely within the Cube are pushed 10 feet away from you, and a thunderous boom is audible within 300 feet.
`,
      "Time Stop.md": `---
smType: spell
name: "Time Stop"
level: 9
school: "Transmutation"
casting_time: "Action"
range: "Self"
components: ["V"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
---

# Time Stop
Level 9 Transmutation

- Casting Time: Action
- Range: Self
- Components: V
- Duration: Instantaneous
- Classes: Sorcerer, Wizard

You briefly stop the flow of time for everyone but yourself. No time passes for other creatures, while you take 1d4 + 1 turns in a row, during which you can use actions and move as normal.

This spell ends if one of the actions you use during this period, or any effects that you create during it, affects a creature other than you or an object being worn or carried by someone other than you. In addition, the spell ends if you move to a place more than 1,000 feet from the location where you cast it.
`,
      "Tiny Hut.md": `---
smType: spell
name: "Tiny Hut"
level: 3
school: "Evocation"
casting_time: "1 minute or Ritual"
range: "Self"
components: ["V", "S", "M"]
materials: "a crystal bead"
duration: "8 hours"
ritual: true
classes: ["Bard", "Wizard"]
---

# Tiny Hut
Level 3 Evocation

- Casting Time: 1 minute or Ritual
- Range: Self
- Components: V, S, M (a crystal bead)
- Duration: 8 hours
- Ritual: yes
- Classes: Bard, Wizard

A 10-foot Emanation springs into existence around you and remains stationary for the duration. The spell fails when you cast it if the Emanation isn't big enough to fully encapsulate all creatures in its area.

Creatures and objects within the Emanation when you cast the spell can move through it freely. All other creatures and objects are barred from passing through it. Spells of level 3 or lower can't be cast through it, and the effects of such spells can't extend into it.

The atmosphere inside the Emanation is comfortable and dry, regardless of the weather outside. Until the spell ends, you can command the interior to have Dim Light or Darkness (no action required). The Emanation is opaque from the outside and of any color you choose, but it's transparent from the inside.

The spell ends early if you leave the Emanation or if you cast it again.
`,
      "Tongues.md": `---
smType: spell
name: "Tongues"
level: 3
school: "Divination"
casting_time: "Action"
range: "Touch"
components: ["V", "M"]
materials: "a miniature ziggurat"
duration: "1 hour"
classes: ["Bard", "Cleric", "Sorcerer", "Warlock", "Wizard"]
---

# Tongues
Level 3 Divination

- Casting Time: Action
- Range: Touch
- Components: V, M (a miniature ziggurat)
- Duration: 1 hour
- Classes: Bard, Cleric, Sorcerer, Warlock, Wizard

This spell grants the creature you touch the ability to understand any spoken or signed language that it hears or sees. Moreover, when the target communicates by speaking or signing, any creature that

knows at least one language can understand it if that creature can hear the speech or see the signing.
`,
      "Transport via Plants.md": `---
smType: spell
name: "Transport via Plants"
level: 6
school: "Conjuration"
casting_time: "Action"
range: "10 feet"
components: ["V", "S"]
duration: "1 minute"
classes: ["Druid"]
---

# Transport via Plants
Level 6 Conjuration

- Casting Time: Action
- Range: 10 feet
- Components: V, S
- Duration: 1 minute
- Classes: Druid

This spell creates a magical link between a Large or larger inanimate plant within range and another plant, at any distance, on the same plane of existence. You must have seen or touched the destination plant at least once before. For the duration, any creature can step into the target plant and exit from the destination plant by using 5 feet of movement.
`,
      "Tree Stride.md": `---
smType: spell
name: "Tree Stride"
level: 5
school: "Conjuration"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Ranger"]
---

# Tree Stride
Level 5 Conjuration

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Ranger

You gain the ability to enter a tree and move from inside it to inside another tree of the same kind within 500 feet. Both trees must be living and at least the same size as you. You must use 5 feet of movement to enter a tree. You instantly know the location of all other trees of the same kind within 500 feet and, as part of the move used to enter the tree, can either pass into one of those trees or step out of the tree you're in. You appear in a spot of your choice within 5 feet of the destination tree, using another 5 feet of movement. If you have no movement left, you appear within 5 feet of the tree you entered.

You can use this transportation ability only once on each of your turns. You must end each turn outside a tree.
`,
      "True Polymorph.md": `---
smType: spell
name: "True Polymorph"
level: 9
school: "Transmutation"
casting_time: "Action"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a drop of mercury, a dollop of gum arabic, and a wisp of smoke"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Bard", "Warlock", "Wizard"]
save_ability: "WIS"
---

# True Polymorph
Level 9 Transmutation

- Casting Time: Action
- Range: 30 feet
- Components: V, S, M (a drop of mercury, a dollop of gum arabic, and a wisp of smoke)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Bard, Warlock, Wizard
- Save: WIS

Choose one creature or nonmagical object that you can see within range. The creature shape-shifts into a different creature or a nonmagical object, or the object shape-shifts into a creature (the object must be neither worn nor carried). The transformation lasts for the duration or until the target dies or is destroyed, but if you maintain Concentration on this spell for the full duration, the spell lasts until dispelled.

An unwilling creature can make a Wisdom saving throw, and if it succeeds, it isn't affected by this spell.

**_Creature into Creature._** If you turn a creature into another kind of creature, the new form can be any kind you choose that has a Challenge Rating equal to or less than the target's Challenge Rating or level. The target's game statistics are replaced by the stat block of the new form, but it retains its Hit Points, Hit Point Dice, alignment, and personality.

The target gains a number of Temporary Hit Points equal to the Hit Points of the new form. These Temporary Hit Points vanish if any remain when the spell ends.

The target is limited in the actions it can perform by the anatomy of its new form, and it can't speak or cast spells.

The target's gear melds into the new form. The creature can't use or otherwise benefit from any of that equipment.

**_Object into Creature._** You can turn an object into any kind of creature, as long as the creature's size is no larger than the object's size and the creature has a Challenge Rating of 9 or lower. The creature is Friendly to you and your allies. In combat, it takes its turns immediately after yours, and it obeys your commands.

If the spell lasts more than an hour, you no longer control the creature. It might remain Friendly to you, depending on how you have treated it.

**_Creature into Object._** If you turn a creature into an object, it transforms along with whatever it is wearing and carrying into that form, as long as the object's size is no larger than the creature's size. The creature's statistics become those of the object, and the creature has no memory of time spent in this form after the spell ends and it returns to normal.
`,
      "True Resurrection.md": `---
smType: spell
name: "True Resurrection"
level: 9
school: "Necromancy"
casting_time: "1 hour"
range: "Touch"
components: ["V", "S", "M"]
materials: "diamonds worth 25,000+ GP, which the spell consumes"
duration: "Instantaneous"
classes: ["Cleric", "Druid"]
---

# True Resurrection
Level 9 Necromancy

- Casting Time: 1 hour
- Range: Touch
- Components: V, S, M (diamonds worth 25,000+ GP, which the spell consumes)
- Duration: Instantaneous
- Classes: Cleric, Druid

You touch a creature that has been dead for no longer than 200 years and that died for any reason except old age. The creature is revived with all its Hit Points.

This spell closes all wounds, neutralizes any poison, cures all magical contagions, and lifts any curses affecting the creature when it died. The spell replaces damaged or missing organs and limbs. If the creature was Undead, it is restored to its non-Undead form.

The spell can provide a new body if the original no longer exists, in which case you must speak the creature's name. The creature then appears in an unoccupied space you choose within 10 feet of you.
`,
      "True Seeing.md": `---
smType: spell
name: "True Seeing"
level: 6
school: "Divination"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "mushroom powder worth 25+ GP, which the spell consumes"
duration: "1 hour"
classes: ["Bard", "Cleric", "Sorcerer", "Warlock", "Wizard"]
---

# True Seeing
Level 6 Divination

- Casting Time: Action
- Range: Touch
- Components: V, S, M (mushroom powder worth 25+ GP, which the spell consumes)
- Duration: 1 hour
- Classes: Bard, Cleric, Sorcerer, Warlock, Wizard

For the duration, the willing creature you touch has Truesight with a range of 120 feet.
`,
      "True Strike.md": `---
smType: spell
name: "True Strike"
level: 0
school: "Divination"
casting_time: "Action"
range: "Self"
components: ["S", "M"]
materials: "a weapon with which you have proficiency and that is worth 1+ CP"
duration: "Instantaneous"
classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]
---

# True Strike
Cantrip Divination

- Casting Time: Action
- Range: Self
- Components: S, M (a weapon with which you have proficiency and that is worth 1+ CP)
- Duration: Instantaneous
- Classes: Bard, Sorcerer, Warlock, Wizard

Guided by a flash of magical insight, you make one attack with the weapon used in the spell's casting. The attack uses your spellcasting ability for the attack and damage rolls instead of using Strength or Dexterity. If the attack deals damage, it can be Radiant damage or the weapon's normal damage type (your choice).
`,
      "Tsunami.md": `---
smType: spell
name: "Tsunami"
level: 8
school: "Conjuration"
casting_time: "1 minute"
range: "1 mile"
components: ["V", "S"]
duration: "Concentration, up to 6 rounds"
concentration: true
classes: ["Druid"]
save_ability: "STR"
save_effect: "Half damage on success"
damage: "6d10"
damage_type: "Bludgeoning"
---

# Tsunami
Level 8 Conjuration

- Casting Time: 1 minute
- Range: 1 mile
- Components: V, S
- Duration: Concentration, up to 6 rounds
- Concentration: yes
- Classes: Druid
- Save: STR (Half damage on success)
- Damage: 6d10 Bludgeoning

A wall of water springs into existence at a point you choose within range. You can make the wall up to 300 feet long, 300 feet high, and 50 feet thick. The wall lasts for the duration.

When the wall appears, each creature in its area makes a Strength saving throw, taking 6d10 Bludgeoning damage on a failed save or half as much damage on a successful one.

At the start of each of your turns after the wall appears, the wall, along with any creatures in it, moves 50 feet away from you. Any Huge or smaller creature inside the wall or whose space the wall enters when it moves must succeed on a Strength saving throw or take 5d10 Bludgeoning damage. A creature can take this damage only once per round. At the end of the turn, the wall's height is reduced by 50 feet, and the damage the wall deals on later rounds is reduced by 1d10. When the wall reaches 0 feet in height, the spell ends.

A creature caught in the wall can move by swimming. Because of the wave's force, though, the creature must succeed on a Strength (Athletics) check against your spell save DC to move at all. If it fails the check, it can't move. A creature that moves out of the wall falls to the ground.

### U-Z Spells
`,
      "Unseen Servant.md": `---
smType: spell
name: "Unseen Servant"
level: 1
school: "Conjuration"
casting_time: "Action or Ritual"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a bit of string and of wood"
duration: "1 hour"
ritual: true
classes: ["Bard", "Warlock", "Wizard"]
---

# Unseen Servant
Level 1 Conjuration

- Casting Time: Action or Ritual
- Range: 60 feet
- Components: V, S, M (a bit of string and of wood)
- Duration: 1 hour
- Ritual: yes
- Classes: Bard, Warlock, Wizard

This spell creates an Invisible, mindless, shapeless, Medium force that performs simple tasks at your command until the spell ends. The servant springs into existence in an unoccupied space on the ground within range. It has AC 10, 1 Hit Point, and a Strength of 2, and it can't attack. If it drops to 0 Hit Points, the spell ends.

Once on each of your turns as a Bonus Action, you can mentally command the servant to move up to 15 feet and interact with an object. The servant can perform simple tasks that a human could do, such as fetching things, cleaning, mending, folding clothes, lighting fires, serving food, and pouring drinks. Once you give the command, the servant performs the task to the best of its ability until it completes the task, then waits for your next command.

If you command the servant to perform a task that would move it more than 60 feet away from you, the spell ends.
`,
      "Vampiric Touch.md": `---
smType: spell
name: "Vampiric Touch"
level: 3
school: "Necromancy"
casting_time: "Action"
range: "Self"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Sorcerer", "Warlock", "Wizard"]
save_effect: "Half damage on success"
attack: "melee spell attack"
damage: "3d6"
damage_type: "Necrotic"
---

# Vampiric Touch
Level 3 Necromancy

- Casting Time: Action
- Range: Self
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Sorcerer, Warlock, Wizard
- Attack: melee spell attack
- Damage: 3d6 Necrotic

The touch of your shadow-wreathed hand can siphon life force from others to heal your wounds. Make a melee spell attack against one creature within reach. On a hit, the target takes 3d6 Necrotic damage, and you regain Hit Points equal to half the amount of Necrotic damage dealt.

Until the spell ends, you can make the attack again on each of your turns as a Magic action, targeting the same creature or a different one.
`,
      "Vicious Mockery.md": `---
smType: spell
name: "Vicious Mockery"
level: 0
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Bard"]
save_ability: "WIS"
damage: "1d6"
damage_type: "Psychic"
---

# Vicious Mockery
Cantrip Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V
- Duration: Instantaneous
- Classes: Bard
- Save: WIS
- Damage: 1d6 Psychic

You unleash a string of insults laced with subtle enchantments at one creature you can see or hear within range. The target must succeed on a Wisdom saving throw or take 1d6 Psychic damage and have Disadvantage on the next attack roll it makes before the end of its next turn.
`,
      "Vitriolic Sphere.md": `---
smType: spell
name: "Vitriolic Sphere"
level: 4
school: "Evocation"
casting_time: "Action"
range: "150 feet"
components: ["V", "S", "M"]
materials: "a drop of bile"
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "10d4"
damage_type: "Acid"
---

# Vitriolic Sphere
Level 4 Evocation

- Casting Time: Action
- Range: 150 feet
- Components: V, S, M (a drop of bile)
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 10d4 Acid

You point at a location within range, and a glowing, 1-foot-diameter ball of acid streaks there and explodes in a 20-foot-radius Sphere. Each creature in that area makes a Dexterity saving throw. On a failed save, a creature takes 10d4 Acid damage and another 5d4 Acid damage at the end of its next turn. On a successful save, a creature takes half the initial damage only.
`,
      "Wall of Fire.md": `---
smType: spell
name: "Wall of Fire"
level: 4
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a piece of charcoal"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "5d8"
damage_type: "Fire"
---

# Wall of Fire
Level 4 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a piece of charcoal)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Sorcerer, Wizard
- Save: DEX (Half damage on success)
- Damage: 5d8 Fire

You create a wall of fire on a solid surface within range. You can make the wall up to 60 feet long, 20 feet high, and 1 foot thick, or a ringed wall up to 20 feet in diameter, 20 feet high, and 1 foot thick. The wall is opaque and lasts for the duration.

When the wall appears, each creature in its area makes a Dexterity saving throw, taking 5d8 Fire damage on a failed save or half as much damage on a successful one.

One side of the wall, selected by you when you cast this spell, deals 5d8 Fire damage to each creature that ends its turn within 10 feet of that side or inside the wall. A creature takes the same damage when it enters the wall for the first time on a turn or ends its turn there. The other side of the wall deals no damage.
`,
      "Wall of Force.md": `---
smType: spell
name: "Wall of Force"
level: 5
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a shard of glass"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Wizard"]
---

# Wall of Force
Level 5 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a shard of glass)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Wizard

An Invisible wall of force springs into existence at a point you choose within range. The wall appears in any orientation you choose, as a horizontal or vertical barrier or at an angle. It can be free floating or resting on a solid surface. You can form it into a hemispherical dome or a globe with a radius of up to 10 feet, or you can shape a flat surface made up of ten 10-foot-by-10-foot panels. Each panel must be contiguous with another panel. In any form, the wall is 1/4 inch thick and lasts for the duration. If the wall cuts through a creature's space when it appears, the creature is pushed to one side of the wall (you choose which side).

Nothing can physically pass through the wall. It is immune to all damage and can't be dispelled by *Dispel Magic.* A *Disintegrate* spell destroys the wall instantly, however. The wall also extends into the Ethereal Plane and blocks ethereal travel through the wall.
`,
      "Wall of Ice.md": `---
smType: spell
name: "Wall of Ice"
level: 6
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a piece of quartz"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Wizard"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "10d6"
damage_type: "Cold"
---

# Wall of Ice
Level 6 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a piece of quartz)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Wizard
- Save: DEX (Half damage on success)
- Damage: 10d6 Cold

You create a wall of ice on a solid surface within range. You can form it into a hemispherical dome or a globe with a radius of up to 10 feet, or you can shape a flat surface made up of ten 10-foot-square panels. Each panel must be contiguous with another panel. In any form, the wall is 1 foot thick and lasts for the duration.

If the wall cuts through a creature's space when it appears, the creature is pushed to one side of the wall (you choose which side) and makes a Dexterity saving throw, taking 10d6 Cold damage on a failed save or half as much damage on a successful one.

The wall is an object that can be damaged and thus breached. It has AC 12 and 30 Hit Points per 10-foot section, and it has Immunity to Cold, Poison, and Psychic damage and Vulnerability to Fire damage. Reducing a 10-foot section of wall to 0 Hit Points destroys it and leaves behind a sheet of frigid air in the space the wall occupied.

A creature moving through the sheet of frigid air for the first time on a turn makes a Constitution saving throw, taking 5d6 Cold damage on a failed save or half as much damage on a successful one.
`,
      "Wall of Stone.md": `---
smType: spell
name: "Wall of Stone"
level: 5
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a cube of granite"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid", "Sorcerer", "Wizard"]
save_ability: "DEX"
---

# Wall of Stone
Level 5 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a cube of granite)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid, Sorcerer, Wizard
- Save: DEX

A nonmagical wall of solid stone springs into existence at a point you choose within range. The wall is 6 inches thick and is composed of ten 10-foot-by-10-foot panels. Each panel must be contiguous with another panel. Alternatively, you can create 10-footby-20-foot panels that are only 3 inches thick.

If the wall cuts through a creature's space when it appears, the creature is pushed to one side of the wall (you choose which side). If a creature would be surrounded on all sides by the wall (or the wall and another solid surface), that creature can make a Dexterity saving throw. On a success, it can use its Reaction to move up to its Speed so that it is no longer enclosed by the wall.

The wall can have any shape you desire, though it can't occupy the same space as a creature or object. The wall doesn't need to be vertical or rest on a firm foundation. It must, however, merge with and be solidly supported by existing stone. Thus, you can use this spell to bridge a chasm or create a ramp.

If you create a span greater than 20 feet in length, you must halve the size of each panel to create supports. You can crudely shape the wall to create battlements and the like.

The wall is an object made of stone that can be damaged and thus breached. Each panel has AC 15 and 30 Hit Points per inch of thickness, and it has Immunity to Poison and Psychic damage. Reducing a panel to 0 Hit Points destroys it and might cause connected panels to collapse at the GM's discretion.

If you maintain your Concentration on this spell for its full duration, the wall becomes permanent and can't be dispelled. Otherwise, the wall disappears when the spell ends.
`,
      "Wall of Thorns.md": `---
smType: spell
name: "Wall of Thorns"
level: 6
school: "Conjuration"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a handful of thorns"
duration: "Concentration, up to 10 minutes"
concentration: true
classes: ["Druid"]
save_ability: "DEX"
save_effect: "Half damage on success"
damage: "7d8"
damage_type: "Piercing"
---

# Wall of Thorns
Level 6 Conjuration

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a handful of thorns)
- Duration: Concentration, up to 10 minutes
- Concentration: yes
- Classes: Druid
- Save: DEX (Half damage on success)
- Damage: 7d8 Piercing

You create a wall of tangled brush bristling with needle-sharp thorns. The wall appears within range on a solid surface and lasts for the duration. You choose to make the wall up to 60 feet long, 10 feet high, and 5 feet thick or a circle that has a 20-foot diameter and is up to 20 feet high and 5 feet thick. The wall blocks line of sight.

When the wall appears, each creature in its area makes a Dexterity saving throw, taking 7d8 Piercing damage on a failed save or half as much damage on a successful one.

A creature can move through the wall, albeit slowly and painfully. For every 1 foot a creature moves through the wall, it must spend 4 feet of movement. Furthermore, the first time a creature enters a space in the wall on a turn or ends its turn there, the creature makes a Dexterity saving throw, taking 7d8 Slashing damage on a failed save or half as much damage on a successful one. A creature makes this save only once per turn.
`,
      "Warding Bond.md": `---
smType: spell
name: "Warding Bond"
level: 2
school: "Abjuration"
casting_time: "Action"
range: "Touch"
components: ["V", "S", "M"]
materials: "a pair of platinum rings worth 50+ GP each, which you and the target must wear for the duration"
duration: "1 hour"
classes: ["Cleric", "Paladin"]
---

# Warding Bond
Level 2 Abjuration

- Casting Time: Action
- Range: Touch
- Components: V, S, M (a pair of platinum rings worth 50+ GP each, which you and the target must wear for the duration)
- Duration: 1 hour
- Classes: Cleric, Paladin

You touch another creature that is willing and create a mystic connection between you and the target until the spell ends. While the target is within 60 feet of you, it gains a +1 bonus to AC and saving throws, and it has Resistance to all damage. Also, each time it takes damage, you take the same amount of damage.

The spell ends if you drop to 0 Hit Points or if you and the target become separated by more than 60 feet. It also ends if the spell is cast again on either of the connected creatures.
`,
      "Water Breathing.md": `---
smType: spell
name: "Water Breathing"
level: 3
school: "Transmutation"
casting_time: "Action or Ritual"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a short reed"
duration: "24 hours"
ritual: true
classes: ["Druid", "Ranger", "Sorcerer", "Wizard"]
---

# Water Breathing
Level 3 Transmutation

- Casting Time: Action or Ritual
- Range: 30 feet
- Components: V, S, M (a short reed)
- Duration: 24 hours
- Ritual: yes
- Classes: Druid, Ranger, Sorcerer, Wizard

This spell grants up to ten willing creatures of your choice within range the ability to breathe underwater until the spell ends. Affected creatures also retain their normal mode of respiration.
`,
      "Water Walk.md": `---
smType: spell
name: "Water Walk"
level: 3
school: "Transmutation"
casting_time: "Action or Ritual"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a piece of cork"
duration: "1 hour"
ritual: true
classes: ["Cleric", "Druid", "Ranger", "Sorcerer"]
---

# Water Walk
Level 3 Transmutation

- Casting Time: Action or Ritual
- Range: 30 feet
- Components: V, S, M (a piece of cork)
- Duration: 1 hour
- Ritual: yes
- Classes: Cleric, Druid, Ranger, Sorcerer

This spell grants the ability to move across any liquid surface\u2014such as water, acid, mud, snow, quicksand, or lava\u2014as if it were harmless solid ground (creatures crossing molten lava can still take damage from the heat). Up to ten willing creatures of your choice within range gain this ability for the duration.

An affected target must take a Bonus Action to pass from the liquid's surface into the liquid itself and vice versa, but if the target falls into the liquid, the target passes through the surface into the liquid below.
`,
      "Web.md": `---
smType: spell
name: "Web"
level: 2
school: "Conjuration"
casting_time: "Action"
range: "60 feet"
components: ["V", "S", "M"]
materials: "a bit of spiderweb"
duration: "Concentration, up to 1 hour"
concentration: true
classes: ["Sorcerer", "Wizard"]
save_ability: "DEX"
damage: "2d4"
damage_type: "Fire"
---

# Web
Level 2 Conjuration

- Casting Time: Action
- Range: 60 feet
- Components: V, S, M (a bit of spiderweb)
- Duration: Concentration, up to 1 hour
- Concentration: yes
- Classes: Sorcerer, Wizard
- Save: DEX
- Damage: 2d4 Fire

You conjure a mass of sticky webbing at a point within range. The webs fill a 20-foot Cube there for the duration. The webs are Difficult Terrain, and the area within them is Lightly Obscured.

If the webs aren't anchored between two solid masses (such as walls or trees) or layered across a floor, wall, or ceiling, the web collapses on itself, and the spell ends at the start of your next turn. Webs layered over a flat surface have a depth of 5 feet.

The first time a creature enters the webs on a turn or starts its turn there, it must succeed on a Dexterity saving throw or have the Restrained condition while in the webs or until it breaks free.

A creature Restrained by the webs can take an action to make a Strength (Athletics) check against your spell save DC. If it succeeds, it is no longer Restrained.

The webs are flammable. Any 5-foot Cube of webs exposed to fire burns away in 1 round, dealing 2d4 Fire damage to any creature that starts its turn in the fire.
`,
      "Weird.md": `---
smType: spell
name: "Weird"
level: 9
school: "Illusion"
casting_time: "Action"
range: "120 feet"
components: ["V", "S"]
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Warlock", "Wizard"]
save_ability: "WIS"
save_effect: "Half damage on success"
damage: "10d10"
damage_type: "Psychic"
---

# Weird
Level 9 Illusion

- Casting Time: Action
- Range: 120 feet
- Components: V, S
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Warlock, Wizard
- Save: WIS (Half damage on success)
- Damage: 10d10 Psychic

You try to create illusory terrors in others' minds. Each creature of your choice in a 30-foot-radius Sphere centered on a point within range makes a Wisdom saving throw. On a failed save, a target takes 10d10 Psychic damage and has the Frightened condition for the duration. On a successful save, a target takes half as much damage only.

A Frightened target makes a Wisdom saving throw at the end of each of its turns. On a failed save, it takes 5d10 Psychic damage. On a successful save, the spell ends on that target.
`,
      "Wind Walk.md": `---
smType: spell
name: "Wind Walk"
level: 6
school: "Transmutation"
casting_time: "1 minute"
range: "30 feet"
components: ["V", "S", "M"]
materials: "a candle"
duration: "8 hours"
classes: ["Druid"]
---

# Wind Walk
Level 6 Transmutation

- Casting Time: 1 minute
- Range: 30 feet
- Components: V, S, M (a candle)
- Duration: 8 hours
- Classes: Druid

You and up to ten willing creatures of your choice within range assume gaseous forms for the duration, appearing as wisps of cloud. While in this cloud form, a target has a Fly Speed of 300 feet and can hover; it has Immunity to the Prone condition; and it has Resistance to Bludgeoning, Piercing, and Slashing damage. The only actions a target can take in this form are the Dash action or a Magic action to begin reverting to its normal form. Reverting takes 1 minute, during which the target has the Stunned condition. Until the spell ends, the target can revert to cloud form, which also requires a Magic action followed by a 1-minute transformation.

If a target is in cloud form and flying when the effect ends, the target descends 60 feet per round for 1 minute until it lands, which it does safely. If it can't land after 1 minute, it falls the remaining distance.
`,
      "Wind Wall.md": `---
smType: spell
name: "Wind Wall"
level: 3
school: "Evocation"
casting_time: "Action"
range: "120 feet"
components: ["V", "S", "M"]
materials: "a fan and a feather"
duration: "Concentration, up to 1 minute"
concentration: true
classes: ["Druid", "Ranger"]
save_ability: "STR"
save_effect: "Half damage on success"
damage: "4d8"
damage_type: "Bludgeoning"
---

# Wind Wall
Level 3 Evocation

- Casting Time: Action
- Range: 120 feet
- Components: V, S, M (a fan and a feather)
- Duration: Concentration, up to 1 minute
- Concentration: yes
- Classes: Druid, Ranger
- Save: STR (Half damage on success)
- Damage: 4d8 Bludgeoning

A wall of strong wind rises from the ground at a point you choose within range. You can make the wall up to 50 feet long, 15 feet high, and 1 foot thick. You can shape the wall in any way you choose so long as it makes one continuous path along the ground. The wall lasts for the duration.

When the wall appears, each creature in its area makes a Strength saving throw, taking 4d8 Bludgeoning damage on a failed save or half as much damage on a successful one.

The strong wind keeps fog, smoke, and other gases at bay. Small or smaller flying creatures or objects can't pass through the wall. Loose, lightweight materials brought into the wall fly upward. Arrows, bolts, and other ordinary projectiles launched at targets behind the wall are deflected upward and miss automatically. Boulders hurled by Giants or siege engines, and similar projectiles, are unaffected. Creatures in gaseous form can't pass through it.
`,
      "Wish.md": `---
smType: spell
name: "Wish"
level: 9
school: "Conjuration"
casting_time: "Action"
range: "Self"
components: ["V"]
duration: "Instantaneous"
classes: ["Sorcerer", "Wizard"]
damage: "1d10"
damage_type: "Necrotic"
---

# Wish
Level 9 Conjuration

- Casting Time: Action
- Range: Self
- Components: V
- Duration: Instantaneous
- Classes: Sorcerer, Wizard
- Damage: 1d10 Necrotic

*Wish* is the mightiest spell a mortal can cast. By simply speaking aloud, you can alter reality itself.

The basic use of this spell is to duplicate any other spell of level 8 or lower. If you use it this way, you don't need to meet any requirements to cast that spell, including costly components. The spell simply takes effect.

Alternatively, you can create one of the following effects of your choice:

**_Object Creation._** You create one object of up to 25,000 GP in value that isn't a magic item. The object can be no more than 300 feet in any dimension, and it appears in an unoccupied space that you can see on the ground.

**_Instant Health._** You allow yourself and up to twenty creatures that you can see to regain all Hit Points, and you end all effects on them listed in the *Greater Restoration* spell.

**_Resistance._** You grant up to ten creatures that you can see Resistance to one damage type that you choose. This Resistance is permanent.

**_Spell Immunity._** You grant up to ten creatures you can see immunity to a single spell or other magical effect for 8 hours.

**_Sudden Learning._** You replace one of your feats with another feat for which you are eligible. You lose all the benefits of the old feat and gain the benefits of the new one. You can't replace a feat that is a prerequisite for any of your other feats or features.

**_Roll Redo._** You undo a single recent event by forcing a reroll of any die roll made within the last round (including your last turn). Reality reshapes itself to accommodate the new result. For example, a *Wish* spell could undo an ally's failed saving throw or a foe's Critical Hit. You can force the reroll to be made with Advantage or Disadvantage, and you choose whether to use the reroll or the original roll.

**_Reshape Reality._** You may wish for something not included in any of the other effects. To do so, state your wish to the GM as precisely as possible. The GM has great latitude in ruling what occurs in such an instance; the greater the wish, the greater the likelihood that something goes wrong. This spell might simply fail, the effect you desire might be achieved only in part, or you might suffer an unforeseen consequence as a result of how you worded the wish. For example, wishing that a villain were dead might propel you forward in time to a period when that villain is no longer alive, effectively removing you from the game.

Similarly, wishing for a Legendary magic item or an Artifact might instantly transport you to the presence of the item's current owner. If your wish is granted and its effects have consequences for a whole community, region, or world, you are likely to attract powerful foes. If your wish would affect a god, the god's divine servants might instantly intervene to prevent it or to encourage you to craft the wish in a particular way. If your wish would undo the multiverse itself, your wish fails.

The stress of casting *Wish* to produce any effect other than duplicating another spell weakens you. After enduring that stress, each time you cast a spell until you finish a Long Rest, you take 1d10 Necrotic damage per level of that spell. This damage can't be reduced or prevented in any way. In addition, your Strength score becomes 3 for 2d4 days. For each of those days that you spend resting and doing nothing more than light activity, your remaining recovery time decreases by 2 days. Finally, there is a 33 percent chance that you are unable to cast *Wish* ever again if you suffer this stress.
`,
      "Word of Recall.md": `---
smType: spell
name: "Word of Recall"
level: 6
school: "Conjuration"
casting_time: "Action"
range: "5 feet"
components: ["V"]
duration: "Instantaneous"
classes: ["Cleric"]
---

# Word of Recall
Level 6 Conjuration

- Casting Time: Action
- Range: 5 feet
- Components: V
- Duration: Instantaneous
- Classes: Cleric

You and up to five willing creatures within 5 feet of you instantly teleport to a previously designated sanctuary. You and any creatures that teleport with you appear in the nearest unoccupied space to the spot you designated when you prepared your sanctuary (see below). If you cast this spell without first preparing a sanctuary, the spell has no effect.

You must designate a location, such as a temple, as a sanctuary by casting this spell there.
`,
      "Zone of Truth.md": `---
smType: spell
name: "Zone of Truth"
level: 2
school: "Enchantment"
casting_time: "Action"
range: "60 feet"
components: ["V", "S"]
duration: "10 minutes"
classes: ["Bard", "Cleric", "Paladin"]
save_ability: "CHA"
---

# Zone of Truth
Level 2 Enchantment

- Casting Time: Action
- Range: 60 feet
- Components: V, S
- Duration: 10 minutes
- Classes: Bard, Cleric, Paladin
- Save: CHA

You create a magical zone that guards against deception in a 15-foot-radius Sphere centered on a point within range. Until the spell ends, a creature that enters the spell's area for the first time on a turn or starts its turn there makes a Charisma saving throw. On a failed save, a creature can't speak a deliberate lie while in the radius. You know whether a creature succeeds or fails on this save.

An affected creature is aware of the spell and can avoid answering questions to which it would normally respond with a lie. Such a creature can be evasive yet must be truthful.
`
    };
    PRESET_ITEMS = {
      "--Wand of Fireballs.md": `---
smType: item
name: "**Wand of Fireballs"
category: "Wand"
type: "Requires Attunement by a Spellcaster"
rarity: "Rare"
attunement: true
attunement_req: "by a Spellcaster"
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# **Wand of Fireballs
*Wand (Requires Attunement by a Spellcaster) Rare (Requires Attunement by a Spellcaster)*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed

This wand has 7 charges. While holding it, you can expend no more than 3 charges to cast *Fireball* (save DC 15) from it. For 1 charge, you cast the level 3 version of the spell. You can increase the spell's level by 1 for each additional charge you expend.
`,
      "Adamantine Armor.md": `---
smType: item
name: "Adamantine Armor"
category: "Armor"
type: "Any Medium or Heavy, Except Hide Armor"
rarity: "Uncommon"
---

# Adamantine Armor
*Armor (Any Medium or Heavy, Except Hide Armor) Uncommon*

This suit of armor is reinforced with adamantine, one of the hardest substances in existence. While you're wearing it, any Critical Hit against you becomes a normal hit.
`,
      "Ammunition of Slaying.md": `---
smType: item
name: "Ammunition of Slaying"
category: "Weapon"
type: "Any Ammunition"
rarity: "Very Rare"
---

# Ammunition of Slaying
*Weapon (Any Ammunition) Very Rare*

This magic ammunition is meant to slay creatures of a particular type, which the GM chooses or determines randomly by rolling on the table below. If a creature of that type takes damage from the ammunition, the creature makes a DC 17 Constitution saving throw, taking an extra 6d10 Force damage on a failed save or half as much extra damage on a successful one.

After dealing its extra damage to a creature, the ammunition becomes nonmagical.
`,
      "Ammunition, +1, +2, or +3.md": `---
smType: item
name: "Ammunition, +1, +2, or +3"
category: "Weapon"
type: "Any Ammunition"
rarity: "Uncommon"
---

# Ammunition, +1, +2, or +3
*Weapon (Any Ammunition) Uncommon*

You have a bonus to attack rolls and damage rolls made with this piece of magic ammunition. The bonus is determined by the rarity of the ammunition. Once it hits a target, the ammunition is no longer magical.

This ammunition is typically found or sold in quantities of ten or twenty pieces. Ten pieces of this ammunition are equivalent in value to a potion of the same rarity.
`,
      "Amulet of Health.md": `---
smType: item
name: "Amulet of Health"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
ability_changes_json: "[{\\"ability\\":\\"con\\",\\"value\\":19},{\\"ability\\":\\"con\\",\\"value\\":19}]"
---

# Amulet of Health
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

## Ability Changes

- CON becomes 19
- CON becomes 19

Your Constitution is 19 while you wear this amulet. It has no effect on you if your Constitution is 19 or higher without it.
`,
      "Amulet of Proof against Detection and Location.md": `---
smType: item
name: "Amulet of Proof against Detection and Location"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Amulet of Proof against Detection and Location
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this amulet, you can't be targeted by Divination spells or perceived through magical scrying sensors unless you allow it.
`,
      "Amulet of the Planes.md": `---
smType: item
name: "Amulet of the Planes"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
---

# Amulet of the Planes
*Wondrous (Requires Attunement) Very Rare (Requires Attunement)*

While wearing this amulet, you can take a Magic action to name a location that you are familiar with on another plane of existence. Then make a DC 15 Intelligence (Arcana) check. On a successful check, you cast *Plane Shift*. On a failed check, you and each creature and object within 15 feet of you travel to a random destination determined by rolling 1d100 and consulting the following table.
`,
      "Animated Shield.md": `---
smType: item
name: "Animated Shield"
category: "Armor"
type: "Shield"
rarity: "Very Rare"
attunement: true
---

# Animated Shield
*Armor (Shield) Very Rare (Requires Attunement)*

While holding this Shield, you can take a Bonus Action to cause it to animate. The Shield leaps into the air and hovers in your space to protect you as if you were wielding it, leaving your hands free. The Shield remains animate for 1 minute, until you take a Bonus Action to end this effect, or until you die or have the Incapacitated condition, at which point the Shield falls to the ground or into your hand if you have one free.
`,
      "Apparatus of the Crab.md": `---
smType: item
name: "Apparatus of the Crab"
category: "Wondrous"
rarity: "Legendary"
---

# Apparatus of the Crab
*Wondrous Legendary*

This item first appears to be a sealed iron barrel weighing 500 pounds. The barrel has a hidden catch, which can be found with a successful DC 20 Intelligence (Investigation) check. Releasing the catch unlocks a hatch at one end of the barrel, allowing two Medium or smaller creatures to crawl inside. Ten levers are set in a row at the far end, each in a neutral position, able to move up or down. When certain levers are used, the apparatus transforms to resemble a giant lobster.

The *Apparatus of the Crab* is a Large object with the following statistics: AC 20; HP 200; Speed 30 ft., Swim 30 ft. (or 0 ft. for both if the legs aren't extended); Immunity to Poison and Psychic damage.

To be used as a vehicle, the apparatus requires one pilot. While the apparatus's hatch is closed, the compartment is airtight and watertight. The compartment holds enough air for 10 hours of breathing, divided by the number of breathing creatures inside.

The apparatus floats on water. It can also go underwater to a depth of 900 feet. Below that, the vehicle takes 2d6 Bludgeoning damage each minute from pressure.

A creature in the compartment can take a Utilize action to move as many as two of the apparatus's levers up or down. After each use, a lever goes back to its neutral position. Each lever, from left to right, functions as shown in the Apparatus of the Crab Levers table.
`,
      "Armor of Invulnerability.md": `---
smType: item
name: "Armor of Invulnerability"
category: "Armor"
type: "Plate Armor"
rarity: "Legendary"
attunement: true
---

# Armor of Invulnerability
*Armor (Plate Armor) Legendary (Requires Attunement)*

You have Resistance to Bludgeoning, Piercing, and Slashing damage while you wear this armor.

*Metal Shell.* You can take a Magic action to give yourself Immunity to Bludgeoning, Piercing, and Slashing damage for 10 minutes or until you are no longer wearing the armor. Once this property is used, it can't be used again until the next dawn.
`,
      "Armor of Resistance.md": `---
smType: item
name: "Armor of Resistance"
category: "Armor"
type: "Any Light, Medium, or Heavy"
rarity: "Rare"
attunement: true
---

# Armor of Resistance
*Armor (Any Light, Medium, or Heavy) Rare (Requires Attunement)*

You have Resistance to one type of damage while you wear this armor. The GM chooses the type or determines it randomly by rolling on the following table.
`,
      "Armor of Vulnerability.md": `---
smType: item
name: "Armor of Vulnerability"
category: "Armor"
type: "Any Light, Medium, or Heavy"
rarity: "Rare"
attunement: true
---

# Armor of Vulnerability
*Armor (Any Light, Medium, or Heavy) Rare (Requires Attunement)*

While wearing this armor, you have Resistance to one of the following damage types: Bludgeoning, Piercing, or Slashing. The GM chooses the type or determines it randomly.

*Curse.* This armor is cursed, a fact that is revealed only when the *Identify* spell is cast on the armor or you attune to it. Attuning to the armor curses you until you are targeted by a *Remove Curse* spell or similar magic; removing the armor fails to end the curse. While cursed, you have Vulnerability to two of the three damage types associated with the armor (not the one to which it grants Resistance).
`,
      "Armor, +1, +2, or +3.md": `---
smType: item
name: "Armor, +1, +2, or +3"
category: "Armor"
type: "Any Light, Medium, or Heavy"
rarity: "Rare"
---

# Armor, +1, +2, or +3
*Armor (Any Light, Medium, or Heavy) Rare*

You have a bonus to Armor Class while wearing this armor. The bonus is determined by its rarity.
`,
      "Arrow-Catching Shield.md": `---
smType: item
name: "Arrow-Catching Shield"
category: "Armor"
type: "Shield"
rarity: "Rare"
attunement: true
---

# Arrow-Catching Shield
*Armor (Shield) Rare (Requires Attunement)*

You gain a +2 bonus to Armor Class against ranged attack rolls while you wield this Shield. This bonus is in addition to the Shield's normal bonus to AC.

Whenever an attacker makes a ranged attack roll against a target within 5 feet of you, you can take a Reaction to become the target of the attack instead.
`,
      "Bag of Beans.md": `---
smType: item
name: "Bag of Beans"
category: "Wondrous"
rarity: "Rare"
---

# Bag of Beans
*Wondrous Rare*

This heavy cloth bag contains 3d4 dry beans when found. The bag weighs half a pound regardless of how many beans it contains and becomes a nonmagical item when it no longer contains any beans.

If you dump one or more beans out of the bag, they explode in a 10-foot-radius Sphere centered on them. All the dumped beans are destroyed in the explosion, and each creature in the Sphere, including you, makes a DC 15 Dexterity saving throw, taking 5d4 Force damage on a failed save or half as much damage on a successful one.

If you remove a bean from the bag, plant it in dirt or sand, and then water it, the bean disappears as it produces an effect 1 minute later from the ground where it was planted. The GM can choose an effect from the following table or determine it randomly.
`,
      "Bag of Devouring.md": `---
smType: item
name: "Bag of Devouring"
category: "Wondrous"
rarity: "Very Rare"
---

# Bag of Devouring
*Wondrous Very Rare*

This bag resembles a *Bag of Holding* but is a feeding orifice for a gigantic extradimensional creature. Turning the bag inside out closes the orifice.

The extradimensional creature attached to the bag can sense whatever is placed inside the bag. Animal or vegetable matter placed wholly in the bag is devoured and lost forever. When part of a living creature is placed in the bag, as happens when someone reaches inside it, there is a 50 percent chance that the creature is pulled inside the bag. A creature inside the bag can take an action to try to escape, doing so with a successful DC 15 Strength (Athletics) check. Another creature can take an action to reach into the bag to pull a creature out, doing so with a successful DC 20 Strength (Athletics) check, provided the puller isn't pulled inside the bag first. Any creature that starts its turn inside the bag is devoured, its body destroyed.

Inanimate objects can be stored in the bag, which can hold a cubic foot of such material. However, once each day, the bag swallows any objects inside it and spits them out into another plane of existence. The GM determines the time and plane.

If the bag is pierced or torn, it is destroyed, and anything contained within it is transported to a random location on the Astral Plane.
`,
      "Bag of Holding.md": `---
smType: item
name: "Bag of Holding"
category: "Wondrous"
rarity: "Uncommon"
---

# Bag of Holding
*Wondrous Uncommon*

This bag has an interior space considerably larger than its outside dimensions\u2014roughly 2 feet square and 4 feet deep on the inside. The bag can hold up to 500 pounds, not exceeding a volume of 64 cubic feet. The bag weighs 5 pounds, regardless of its contents. Retrieving an item from the bag requires a Utilize action.

If the bag is overloaded, pierced, or torn, it is destroyed, and its contents are scattered in the Astral Plane. If the bag is turned inside out, its contents spill forth unharmed, but the bag must be put right before it can be used again. The bag holds enough air for 10 minutes of breathing, divided by the number of breathing creatures inside.

Placing a *Bag of Holding* inside an extradimensional space created by a *Handy Haversack*, *Portable Hole*, or similar item instantly destroys both items and opens a gate to the Astral Plane. The gate originates where the one item was placed inside the other. Any creature within a 10-foot-radius Sphere centered on the gate is sucked through it to a random location on the Astral Plane. The gate then closes. The gate is one-way and can't be reopened.
`,
      "Bag of Tricks.md": `---
smType: item
name: "Bag of Tricks"
category: "Wondrous"
rarity: "Uncommon"
---

# Bag of Tricks
*Wondrous Uncommon*

This bag made from gray, rust, or tan cloth appears empty. Reaching inside the bag, however, reveals the presence of a small, fuzzy object.

You can take a Magic action to pull the fuzzy object from the bag and throw it up to 20 feet. When the object lands, it transforms into a creature you determine by rolling on the table that corresponds to the bag's color. See "Monsters" for the creature's stat block. The creature vanishes at the next dawn or when it is reduced to 0 Hit Points.

The creature is Friendly to you and your allies, and it acts immediately after you on your Initiative count. You can take a Bonus Action to command how the creature moves and what action it takes on its next turn, such as attacking an enemy. In the absence of such orders, the creature acts in a fashion appropriate to its nature.

Once three fuzzy objects have been pulled from the bag, the bag can't be used again until the next dawn.
`,
      "Bead of Force.md": `---
smType: item
name: "Bead of Force"
category: "Wondrous"
rarity: "Rare"
---

# Bead of Force
*Wondrous Rare*

This small black sphere measures 3/4 of an inch in diameter and weighs an ounce. Typically, 1d4 + 4 *Beads of Force* are found together.

You can take a Magic action to throw the bead up to 60 feet. The bead explodes in a 10-foot-radius Sphere on impact and is destroyed. Each creature

in the Sphere must succeed on a DC 15 Dexterity saving throw or take 5d4 Force damage. A sphere of transparent force then encloses the area for 1 minute. Any creature that failed the save and is completely within the area is trapped inside this sphere. Creatures that succeeded on the save or are partially within the area are pushed away from the center of the sphere until they are no longer inside it. Only breathable air can pass through the sphere's wall. No attack or other effect can pass through.

An enclosed creature can take a Utilize action to push against the sphere's wall, moving the sphere up to half the creature's Speed. The sphere can be picked up, and its magic causes it to weigh only 1 pound, regardless of the weight of creatures inside.
`,
      "Belt of Dwarvenkind.md": `---
smType: item
name: "Belt of Dwarvenkind"
resistances: ["Poison"]
---

# Belt of Dwarvenkind

- Resistances: Poison
`,
      "Belt of Giant Strength.md": `---
smType: item
name: "Belt of Giant Strength"
category: "Wondrous"
type: "Requires Attunement"
attunement: true
---

# Belt of Giant Strength
*Wondrous (Requires Attunement) (Requires Attunement)*

While wearing this belt, your Strength changes to a score granted by the belt. The type of giant determines the score (see the table below). The item has no effect on you if your Strength without the belt is equal to or greater than the belt's score.
`,
      "Berserker Axe.md": `---
smType: item
name: "Berserker Axe"
category: "Weapon"
type: "Battleaxe, Greataxe, or Halberd"
rarity: "Rare"
attunement: true
cursed: true
curse_description: "This weapon is cursed, and becoming attuned to it extends the curse to you. As long as you remain cursed, you are unwilling to part with the weapon, keeping it within reach at all times. You also have Disadvantage on attack rolls with weapons other than this one. Whenever another creature damages you while the weapon is in your possession, you must succeed on a DC 15 Wisdom saving throw or go berserk. This berserk state ends when you start your turn and there are no creatures within 60 feet of you that you can see or hear. While berserk, you regard the creature nearest to you that you can see or hear as your enemy. If there are multiple possible creatures, choose one at random. On each of your turns, you must move as close to the creature as possible and take the Attack action, targeting the creature. If you're unable to get close enough to the creature to attack it with the weapon, your turn ends after you've used up all your available movement. If the creature dies or can no longer be seen or heard by you, the next nearest creature that you can see or hear becomes your new target."
---

# Berserker Axe
*Weapon (Battleaxe, Greataxe, or Halberd) Rare (Requires Attunement)*

You gain a +1 bonus to attack rolls and damage rolls made with this magic weapon. In addition, while you are attuned to this weapon, your Hit Point maximum increases by 1 for each level you have attained.

## Curse

This weapon is cursed, and becoming attuned to it extends the curse to you. As long as you remain cursed, you are unwilling to part with the weapon, keeping it within reach at all times. You also have Disadvantage on attack rolls with weapons other than this one. Whenever another creature damages you while the weapon is in your possession, you must succeed on a DC 15 Wisdom saving throw or go berserk. This berserk state ends when you start your turn and there are no creatures within 60 feet of you that you can see or hear. While berserk, you regard the creature nearest to you that you can see or hear as your enemy. If there are multiple possible creatures, choose one at random. On each of your turns, you must move as close to the creature as possible and take the Attack action, targeting the creature. If you're unable to get close enough to the creature to attack it with the weapon, your turn ends after you've used up all your available movement. If the creature dies or can no longer be seen or heard by you, the next nearest creature that you can see or hear becomes your new target.
`,
      "Boots of Elvenkind.md": `---
smType: item
name: "Boots of Elvenkind"
category: "Wondrous"
rarity: "Uncommon"
---

# Boots of Elvenkind
*Wondrous Uncommon*

While you wear these boots, your steps make no sound, regardless of the surface you are moving across. You also have Advantage on Dexterity (Stealth) checks.
`,
      "Boots of Levitation.md": `---
smType: item
name: "Boots of Levitation"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Boots of Levitation
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

While you wear these boots, you can cast *Levitate* on yourself.
`,
      "Boots of Speed.md": `---
smType: item
name: "Boots of Speed"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Boots of Speed
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

While you wear these boots, you can take a Bonus Action to click the boots' heels together. If you do, the boots double your Speed, and any creature that makes an Opportunity Attack against you has Disadvantage on the attack roll. If you click your heels together again, you end the effect.

When you've used the boots' property for a total of 10 minutes, the magic ceases to function for you until you finish a Long Rest.
`,
      "Boots of Striding and Springing.md": `---
smType: item
name: "Boots of Striding and Springing"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Boots of Striding and Springing
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While you wear these boots, your Speed becomes 30 feet unless your Speed is higher, and your Speed isn't reduced by you carrying weight in excess of your carrying capacity or wearing Heavy Armor.

Once on each of your turns, you can jump up to 30 feet by spending only 10 feet of movement.
`,
      "Boots of the Winterlands.md": `---
smType: item
name: "Boots of the Winterlands"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
resistances: ["Cold"]
---

# Boots of the Winterlands
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

- Resistances: Cold

These furred boots are snug and feel warm. While wearing them, you gain the following benefits.
`,
      "Bowl of Commanding Water Elementals.md": `---
smType: item
name: "Bowl of Commanding Water Elementals"
category: "Wondrous"
rarity: "Rare"
---

# Bowl of Commanding Water Elementals
*Wondrous Rare*

While this bowl is filled with water and you are within 5 feet of it, you can take a Magic action to summon a **Water Elemental**. The elemental appears in an unoccupied space as close to the bowl as possible, understands your languages, obeys your commands, and takes its turn immediately after you on your Initiative count. The elemental disappears after 1 hour, when it dies, or when you dismiss it as a Bonus Action. The bowl can't be used this way again until the next dawn.

The bowl is about 1 foot in diameter and half as deep. It holds about 3 gallons.
`,
      "Bracers of Archery.md": `---
smType: item
name: "Bracers of Archery"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Bracers of Archery
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing these bracers, you have proficiency with the Longbow and Shortbow, and you gain a +2 bonus to damage rolls made with such weapons.
`,
      "Bracers of Defense.md": `---
smType: item
name: "Bracers of Defense"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Bracers of Defense
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

While wearing these bracers, you gain a +2 bonus to Armor Class if you are wearing no armor and using no Shield.
`,
      "Brazier of Commanding Fire Elementals.md": `---
smType: item
name: "Brazier of Commanding Fire Elementals"
category: "Wondrous"
rarity: "Rare"
---

# Brazier of Commanding Fire Elementals
*Wondrous Rare*

While you are within 5 feet of this brazier, you can take a Magic action to summon a **Fire Elemental**. The elemental appears in an unoccupied space as close to the brazier as possible, understands your languages, obeys your commands, and takes its turn immediately after you on your Initiative count. The elemental disappears after 1 hour, when it dies, or

when you dismiss it as a Bonus Action. The brazier can't be used this way again until the next dawn.
`,
      "Brooch of Shielding.md": `---
smType: item
name: "Brooch of Shielding"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
resistances: ["Force"]
---

# Brooch of Shielding
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

- Resistances: Force

While wearing this brooch, you have Resistance to Force damage, and you have Immunity to damage from the *Magic Missile* spell.
`,
      "Broom of Flying.md": `---
smType: item
name: "Broom of Flying"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Broom of Flying
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

This wooden broom functions like a mundane broom until you stand astride it and take a Magic action to make it hover beneath you, at which time it can be ridden in the air. It has a Fly Speed of 50 feet. It can carry up to 400 pounds, but its Fly Speed becomes 30 feet while carrying over 200 pounds. The broom stops hovering when you land or when you're no longer riding it.

As a Magic action, you can send the broom to travel alone to a destination within 1 mile of you if you name the location and are familiar with it. The broom comes back to you when you take a Magic action and use a command word if the broom is still within 1 mile of you.
`,
      "Candle of Invocation.md": `---
smType: item
name: "Candle of Invocation"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
---

# Candle of Invocation
*Wondrous (Requires Attunement) Very Rare (Requires Attunement)*

This candle's magic is activated when the candle is lit, which requires a Magic action. After burning for 4 hours, the candle is destroyed. You can snuff it out early for use at a later time. Deduct the time it burned in increments of 1 minute from its total burn time.

While lit, the candle sheds Dim Light in a 30-foot radius. While you are within that light, you have Advantage on D20 Tests. In addition, a Cleric or Druid in the light can cast level 1 spells they have prepared without expending spell slots.

Alternatively, when you light the candle for the first time, you can cast *Gate* with it. Doing so destroys the candle. The portal created by the spell links to a particular Outer Plane chosen by the GM or determined by rolling on the following table.
`,
      "Cape of the Mountebank.md": `---
smType: item
name: "Cape of the Mountebank"
category: "Wondrous"
rarity: "Rare"
---

# Cape of the Mountebank
*Wondrous Rare*

This cape smells faintly of brimstone. While wearing it, you can use it to cast *Dimension Door* as a Magic action. This property can't be used again until the next dawn.

When you teleport with that spell, you leave behind a cloud of smoke. The space you left is Lightly Obscured by that smoke until the end of your next turn.
`,
      "Carpet of Flying.md": `---
smType: item
name: "Carpet of Flying"
category: "Wondrous"
rarity: "Very Rare"
---

# Carpet of Flying
*Wondrous Very Rare*

You can make this carpet hover and fly by taking a Magic action and using the carpet's command word. It moves according to your directions if you are within 30 feet of it.

Four sizes of *Carpet of Flying* exist. The GM chooses the size of a given carpet or determines it randomly by rolling on the following table. A carpet can carry up to twice the weight shown on the table, but its Fly Speed is halved if it carries more than its normal capacity.
`,
      "Censer of Controlling Air Elementals.md": `---
smType: item
name: "Censer of Controlling Air Elementals"
category: "Wondrous"
rarity: "Rare"
---

# Censer of Controlling Air Elementals
*Wondrous Rare*

While gently swinging this censer, you can take a Magic action to summon an **Air Elemental**. The elemental appears in an unoccupied space as close to the censer as possible, understands your languages, obeys your commands, and takes its turn immediately after you on your Initiative count. The elemental disappears after 1 hour, when it dies, or when you dismiss it as a Bonus Action. The censer can't be used this way again until the next dawn.
`,
      "Chime of Opening.md": `---
smType: item
name: "Chime of Opening"
category: "Wondrous"
rarity: "Rare"
---

# Chime of Opening
*Wondrous Rare*

This hollow metal tube measures about 1 foot long and weighs 1 pound. As a Magic action, you can strike the chime to cast *Knock*. The spell's customary knocking sound is replaced by the clear, ringing tone of the chime, which is audible out to 300 feet.

The chime can be used 10 times. After the tenth time, it cracks and becomes useless.
`,
      "Circlet of Blasting.md": `---
smType: item
name: "Circlet of Blasting"
category: "Wondrous"
rarity: "Uncommon"
---

# Circlet of Blasting
*Wondrous Uncommon*

While wearing this circlet, you can cast *Scorching Ray* with it (+5 to hit). The circlet can't cast this spell again until the next dawn.
`,
      "Cloak of Arachnida.md": `---
smType: item
name: "Cloak of Arachnida"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
resistances: ["Poison"]
---

# Cloak of Arachnida
*Wondrous (Requires Attunement) Very Rare (Requires Attunement)*

- Resistances: Poison

This fine garment is made of black silk interwoven with faint, silvery threads. While wearing it, you gain the following benefits.
`,
      "Cloak of Displacement.md": `---
smType: item
name: "Cloak of Displacement"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Cloak of Displacement
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

While you wear this cloak, it magically projects an illusion that makes you appear to be standing in a place near your actual location, causing any creature to have Disadvantage on attack rolls against you. If you take damage, the property ceases to function until the start of your next turn. This property is suppressed while your Speed is 0.
`,
      "Cloak of Elvenkind.md": `---
smType: item
name: "Cloak of Elvenkind"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Cloak of Elvenkind
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While you wear this cloak, Wisdom (Perception) checks made to perceive you have Disadvantage, and you have Advantage on Dexterity (Stealth) checks.
`,
      "Cloak of Protection.md": `---
smType: item
name: "Cloak of Protection"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Cloak of Protection
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

You gain a +1 bonus to Armor Class and saving throws while you wear this cloak.
`,
      "Cloak of the Bat.md": `---
smType: item
name: "Cloak of the Bat"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Cloak of the Bat
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

While wearing this cloak, you have Advantage on Dexterity (Stealth) checks. In an area of Dim Light or Darkness, you can grip the edges of the cloak and use it to gain a Fly Speed of 40 feet. If you ever fail to grip the cloak's edges while flying in this way, or if you are no longer in Dim Light or Darkness, you lose this Fly Speed.

While wearing the cloak in an area of Dim Light or Darkness, you can cast *Polymorph* on yourself, shape-shifting into a **Bat**. While in that form, you retain your Intelligence, Wisdom, and Charisma scores. The cloak can't be used this way again until the next dawn.
`,
      "Cloak of the Manta Ray.md": `---
smType: item
name: "Cloak of the Manta Ray"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Cloak of the Manta Ray
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this cloak, you can breathe underwater, and you have a Swim Speed of 60 feet.
`,
      "Crystal Ball of Mind Reading.md": `---
smType: item
name: "Crystal Ball of Mind Reading"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
---

# Crystal Ball of Mind Reading
*Wondrous (Requires Attunement) Legendary (Requires Attunement)*

While touching this crystal orb, you can cast *Scrying* (save DC 17) with it. In addition, you can cast *Detect Thoughts* (save DC 17) targeting creatures you can see within 30 feet of the spell's sensor. You don't need to concentrate on this *Detect Thoughts* spell to maintain it during its duration, but it ends if the *Scrying* spell ends.
`,
      "Crystal Ball of Telepathy.md": `---
smType: item
name: "Crystal Ball of Telepathy"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
---

# Crystal Ball of Telepathy
*Wondrous (Requires Attunement) Legendary (Requires Attunement)*

While touching this crystal orb, you can cast *Scrying* (save DC 17) with it. In addition, you can communicate telepathically with creatures you can see within 30 feet of the spell's sensor. You can also cast *Suggestion* (save DC 17) through the sensor on one of those creatures. You don't need to concentrate on this *Suggestion* to maintain it during its duration, but it ends if *Scrying* ends. You can't cast *Suggestion* in this way again until the next dawn.
`,
      "Crystal Ball of True Seeing.md": `---
smType: item
name: "Crystal Ball of True Seeing"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
---

# Crystal Ball of True Seeing
*Wondrous (Requires Attunement) Legendary (Requires Attunement)*

While touching this crystal orb, you can cast *Scrying* (save DC 17) with it. In addition, you have Truesight with a range of 120 feet centered on the spell's sensor.
`,
      "Crystal Ball.md": `---
smType: item
name: "Crystal Ball"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
---

# Crystal Ball
*Wondrous (Requires Attunement) Very Rare (Requires Attunement)*

While touching this crystal orb, you can cast *Scrying* (save DC 17) with it.
`,
      "Cube of Force.md": `---
smType: item
name: "Cube of Force"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
recharge_formula: "1d6"
recharge_time: "Dawn"
---

# Cube of Force
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

This cube is about an inch across. Each face has a distinct marking on it. You can press one of those faces, expend the number of charges required for it, and thereby cast the spell associated with it (save DC 17), as shown in the Cube of Force Faces table.

The cube starts with 10 charges, and it regains 1d6 expended charges daily at dawn.
`,
      "Cubic Gate.md": `---
smType: item
name: "Cubic Gate"
category: "Wondrous"
rarity: "Legendary"
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Cubic Gate
*Wondrous Legendary*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This cube is 3 inches across and radiates palpable magical energy. The six sides of the cube are each keyed to a different plane of existence, one of which is the Material Plane. The other sides are linked to planes determined by the GM.

The cube has 3 charges and regains 1d3 expended charges daily at dawn. As a Magic action, you can expend 1 of the cube's charges to cast one of the following spells using the cube.
`,
      "Dagger of Venom.md": `---
smType: item
name: "Dagger of Venom"
category: "Weapon"
type: "Dagger"
rarity: "Rare"
---

# Dagger of Venom
*Weapon (Dagger) Rare*

You gain a +1 bonus to attack rolls and damage rolls made with this magic weapon.

You can take a Bonus Action to magically coat the blade with poison. The poison remains for 1 minute or until an attack using this weapon hits a creature. That creature must succeed on a DC 15 Constitution saving throw or take 2d10 Poison damage and have the Poisoned condition for 1 minute. The weapon can't be used this way again until the next dawn.
`,
      "Dancing Sword.md": `---
smType: item
name: "Dancing Sword"
category: "Weapon"
type: "Greatsword, Longsword, Rapier, Scimitar, or Shortsword"
rarity: "Very Rare"
attunement: true
---

# Dancing Sword
*Weapon (Greatsword, Longsword, Rapier, Scimitar, or Shortsword) Very Rare (Requires Attunement)*

You can take a Bonus Action to toss this magic weapon into the air. When you do so, the weapon begins to hover, flies up to 30 feet, and attacks one creature of your choice within 5 feet of itself. The weapon uses your attack roll and adds your ability modifier to damage rolls.

While the weapon hovers, you can take a Bonus Action to cause it to fly up to 30 feet to another spot within 30 feet of you. As part of the same Bonus Action, you can cause the weapon to attack one creature within 5 feet of the weapon.

After the hovering weapon attacks for the fourth time, it flies back to you and tries to return to your hand. If you have no hand free, the weapon falls to the ground in your space. If the weapon has no unobstructed path to you, it moves as close to you as it can and then falls to the ground. It also ceases to hover if you grasp it or are more than 30 feet away from it.
`,
      "Decanter of Endless Water.md": `---
smType: item
name: "Decanter of Endless Water"
category: "Wondrous"
rarity: "Uncommon"
---

# Decanter of Endless Water
*Wondrous Uncommon*

This stoppered flask sloshes when shaken, as if it contains water. The decanter weighs 2 pounds.

You can take a Magic action to remove the stopper and issue one of three command words, whereupon an amount of fresh water or salt water (your choice) pours out of the flask. The water stops pouring out at the start of your next turn. Choose from the following command words:

**Splash.** The decanter produces 1 gallon of water.

**Fountain.** The decanter produces 5 gallons of water.

**Geyser.** The decanter produces 30 gallons of water that gushes forth in a Line 30 feet long and 1 foot wide. If you're holding the decanter, you can aim the geyser in one direction (no action required). One creature of your choice in the Line must succeed on a DC 13 Strength saving throw or take 1d4 Bludgeoning damage and have the Prone condition. Instead of a creature, you can target one object in the Line that isn't being worn or carried and that weighs no more than 200 pounds. The object is knocked over by the geyser.
`,
      "Deck of Illusions.md": `---
smType: item
name: "Deck of Illusions"
category: "Wondrous"
rarity: "Uncommon"
---

# Deck of Illusions
*Wondrous Uncommon*

This box contains a set of cards. A full deck has 34 cards: 32 depicting specific creatures and two with a mirrored surface. A deck found as treasure is usually missing 1d20 \u2212 1 cards.

The magic of the deck functions only if its cards are drawn at random. You can take a Magic action to draw a card at random from the deck and throw it to the ground at a point within 30 feet of yourself. An illusion of a creature, determined by rolling on the Deck of Illusions table, forms over the thrown card and remains until dispelled. The illusory creature created by the card looks and behaves like a real creature of its kind, except that it can do no harm. While you are within 120 feet of the illusory creature and can see it, you can take a Magic action to move it anywhere within 30 feet of its card.

Any physical interaction with the illusory creature reveals it to be false, because objects pass through it. A creature that takes a Study action to visually inspect the illusory creature identifies it as an illusion with a successful DC 15 Intelligence (Investigation) check. The illusion lasts until its card is moved or the illusion is dispelled (using a *Dispel Magic* spell or a similar effect). When the illusion ends, the image on its card disappears, and that card can't be used again.
`,
      "Defender.md": `---
smType: item
name: "Defender"
category: "Weapon"
type: "Any Melee Weapon"
rarity: "Legendary"
attunement: true
---

# Defender
*Weapon (Any Melee Weapon) Legendary (Requires Attunement)*

You gain a +3 bonus to attack rolls and damage rolls made with this magic weapon.

The first time you attack with the weapon on each of your turns, you can transfer some or all of the weapon's bonus to your Armor Class. For example, you could reduce the bonus to your attack rolls and damage rolls to +1 and gain a +2 bonus to Armor Class. The adjusted bonuses remain in effect until the start of your next turn, although you must hold the weapon to gain a bonus to AC from it.
`,
      "Demon Armor.md": `---
smType: item
name: "Demon Armor"
category: "Armor"
type: "Any Light, Medium, or Heavy"
rarity: "Very Rare"
attunement: true
---

# Demon Armor
*Armor (Any Light, Medium, or Heavy) Very Rare (Requires Attunement)*

While wearing this armor, you gain a +1 bonus to Armor Class, and you know Abyssal. In addition, the armor's clawed gauntlets allow your Unarmed Strikes to deal 1d8 Slashing damage instead of the usual Bludgeoning damage, and you gain a +1 bonus to the attack and damage rolls of your Unarmed Strikes.
`,
      "Dimensional Shackles.md": `---
smType: item
name: "Dimensional Shackles"
category: "Wondrous"
rarity: "Rare"
---

# Dimensional Shackles
*Wondrous Rare*

You can take a Utilize action to place these shackles on a creature that has the Incapacitated condition. The shackles adjust to fit a creature of Small to Large size. The shackles prevent a creature bound by them from using any method of extradimensional movement, including teleportation or travel to a different plane of existence. They don't prevent the creature from passing through an interdimensional portal.

You and any creature you designate when you use the shackles can take a Utilize action to remove them. Once every 30 days, the bound creature can make a DC 30 Strength (Athletics) check. On a successful check, the creature breaks free and destroys the shackles.
`,
      "Dragon Orb.md": `---
smType: item
name: "Dragon Orb"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Artifact"
attunement: true
max_charges: 7
recharge_formula: "1d4 + 3"
recharge_time: "Dawn"
---

# Dragon Orb
*Wondrous (Requires Attunement) Artifact (Requires Attunement)*

## Charges

This item has 7 charges.
regains 1d4 + 3 charges at Dawn.

An orb is an etched crystal globe about 10 inches in diameter. When used, it grows to about 20 inches in diameter, and mist swirls inside it.

While attuned to an orb, you can take a Magic action to peer into the orb's depths. You must then make a DC 15 Charisma saving throw. On a successful save, you control the orb for as long as you remain attuned to it. On a failed save, the orb imposes the Charmed condition on you for as long as you remain attuned to it.

While you are Charmed by the orb, you can't voluntarily end your Attunement to it, and the orb casts *Suggestion* on you at will (save DC 18), urging you to work toward the evil ends it desires. The dragon essence within the orb might want many things: the annihilation of a particular society or organization, freedom from the orb, to spread suffering in the world, to advance the worship of Tiamat, or something else the GM decides.
`,
      "Dragon Scale Mail.md": `---
smType: item
name: "Dragon Scale Mail"
category: "Armor"
type: "Scale Mail"
rarity: "Very Rare"
attunement: true
resistances: ["one"]
---

# Dragon Scale Mail
*Armor (Scale Mail) Very Rare (Requires Attunement)*

- Resistances: one

*Dragon Scale Mail* is made of the scales of one kind of dragon. Sometimes dragons collect their cast-off scales and gift them. Other times, hunters carefully preserve the hide of a dead dragon. In either case, *Dragon Scale Mail* is highly valued.

While wearing this armor, you gain a +1 bonus to Armor Class, you have Advantage on saving throws against the breath weapons of Dragons, and you have Resistance to one damage type determined by the kind of dragon that provided the scales (see the accompanying table).

Additionally, you can focus your senses as a Magic action to discern the distance and direction to the closest dragon within 30 miles of yourself that is of the same type as the armor. This action can't be used again until the next dawn.
`,
      "Dragon Slayer.md": `---
smType: item
name: "Dragon Slayer"
category: "Weapon"
type: "Any Simple or Martial"
rarity: "Rare"
---

# Dragon Slayer
*Weapon (Any Simple or Martial) Rare*

You gain a +1 bonus to attack rolls and damage rolls made with this magic weapon.

The weapon deals an extra 3d6 damage of the weapon's type if the target is a Dragon.
`,
      "Dust of Disappearance.md": `---
smType: item
name: "Dust of Disappearance"
category: "Wondrous"
rarity: "Uncommon"
---

# Dust of Disappearance
*Wondrous Uncommon*

This powder resembles fine sand. There is enough of it for one use. When you take a Utilize action to throw the dust into the air, you and each creature and object within a 10-foot Emanation originating from you have the Invisible condition for 2d4 minutes. The duration is the same for all subjects, and the dust is consumed when its magic takes effect. Immediately after an affected creature makes an attack roll, deals damage, or casts a spell, the Invisible condition ends for that creature.
`,
      "Dust of Dryness.md": `---
smType: item
name: "Dust of Dryness"
category: "Wondrous"
rarity: "Uncommon"
---

# Dust of Dryness
*Wondrous Uncommon*

This small packet contains 1d6 + 4 pinches of dust. As a Utilize action, you can sprinkle a pinch of the dust over water, turning up to a 15-foot Cube of water into one marble-sized pellet, which floats or rests near where the dust was sprinkled. The pellet's weight is negligible. A creature can take a Utilize action to smash the pellet against a hard surface, causing the pellet to shatter and release the water the dust absorbed. Doing so destroys the pellet and ends its magic.

As a Utilize action, you can sprinkle a pinch of the dust on an Elemental within 5 feet of yourself that is composed mostly of water (such as a **Water Elemental**). Such a creature exposed to a pinch of the dust makes a DC 13 Constitution saving throw, taking 10d6 Necrotic damage on a failed save or half as much damage on a successful one.
`,
      "Dust of Sneezing and Choking.md": `---
smType: item
name: "Dust of Sneezing and Choking"
category: "Wondrous"
rarity: "Uncommon"
---

# Dust of Sneezing and Choking
*Wondrous Uncommon*

Found in a small container, this powder resembles *Dust of Disappearance*, and *Identify* reveals it to be such. There is enough of it for one use.

As a Utilize action, you can throw the dust into the air, forcing yourself and every creature in a 30-foot

Emanation originating from you to make a DC 15 Constitution saving throw. Constructs, Elementals, Oozes, Plants, and Undead succeed on the save automatically.

On a failed save, a creature begins sneezing uncontrollably; it has the Incapacitated condition and is suffocating. The creature repeats the save at the end of each of its turns, ending the effect on itself on a success. The effect also ends on any creature targeted by a *Lesser Restoration* spell.
`,
      "Dwarven Plate.md": `---
smType: item
name: "Dwarven Plate"
category: "Armor"
type: "Half Plate Armor or Plate Armor"
rarity: "Very Rare"
---

# Dwarven Plate
*Armor (Half Plate Armor or Plate Armor) Very Rare*

While wearing this armor, you gain a +2 bonus to Armor Class. In addition, if an effect moves you against your will along the ground, you can take a Reaction to reduce the distance you are moved by up to 10 feet.
`,
      "Dwarven Thrower.md": `---
smType: item
name: "Dwarven Thrower"
category: "Weapon"
type: "Warhammer"
rarity: "Very Rare"
attunement: true
attunement_req: "by a Dwarf or a Creature Attuned to a Belt of Dwarvenkind"
---

# Dwarven Thrower
*Weapon (Warhammer) Very Rare (Requires Attunement by a Dwarf or a Creature Attuned to a Belt of Dwarvenkind)*

You gain a +3 bonus to attack rolls and damage rolls made with this magic weapon. It has the Thrown property with a normal range of 20 feet and a long range of 60 feet. When you hit with a ranged attack using this weapon, it deals an extra 1d8 Force damage, or an extra 2d8 Force damage if the target is a Giant. Immediately after hitting or missing, the weapon flies back to your hand.
`,
      "Efficient Quiver.md": `---
smType: item
name: "Efficient Quiver"
category: "Wondrous"
rarity: "Uncommon"
---

# Efficient Quiver
*Wondrous Uncommon*

Each of the quiver's three compartments connects to an extradimensional space that allows the quiver to hold numerous items while never weighing more than 2 pounds. The shortest compartment can hold up to 60 Arrows, Bolts, or similar objects. The midsize compartment holds up to 18 Javelins or similar objects. The longest compartment holds up to 6 long objects, such as bows, Quarterstaffs, or Spears.

You can draw any item the quiver contains as if doing so from a regular quiver or scabbard.
`,
      "Efreeti Bottle.md": `---
smType: item
name: "Efreeti Bottle"
category: "Wondrous"
rarity: "Very Rare"
---

# Efreeti Bottle
*Wondrous Very Rare*

When you take a Magic action to remove the stopper of this painted brass bottle, a cloud of thick smoke flows out of it. At the end of your turn, the smoke disappears with a flash of harmless fire, and an **Efreeti** appears in an unoccupied space within 30 feet of you.

The first time the bottle is opened, the GM rolls on the following table to determine what happens.
`,
      "Elemental Gem.md": `---
smType: item
name: "Elemental Gem"
category: "Wondrous"
rarity: "Uncommon"
---

# Elemental Gem
*Wondrous Uncommon*

This gem contains a mote of elemental energy. When you take a Utilize action to break the gem, an elemental is summoned (see "Monsters" for its stat block), and the gem ceases to be magical. The elemental appears in an unoccupied space as close to the broken gem as possible, understands your languages, obeys your commands, and takes its turn immediately after you on your Initiative count. The elemental disappears after 1 hour, when it dies, or when you dismiss it as a Bonus Action. The type of gem determines the elemental, as shown in the following table.
`,
      "Elven Chain.md": `---
smType: item
name: "Elven Chain"
category: "Armor"
type: "Chain Mail or Chain Shirt"
rarity: "Rare"
---

# Elven Chain
*Armor (Chain Mail or Chain Shirt) Rare*

You gain a +1 bonus to Armor Class while you wear this armor. You are considered trained with this armor even if you lack training with Medium or Heavy armor.
`,
      "Eversmoking Bottle.md": `---
smType: item
name: "Eversmoking Bottle"
category: "Wondrous"
rarity: "Uncommon"
---

# Eversmoking Bottle
*Wondrous Uncommon*

As a Magic action, you can open or close this bottle. Opening the bottle causes thick smoke to billow out, forming a cloud that fills a 60-foot Emanation originating from the bottle. The area within the smoke is Heavily Obscured.

Each minute the bottle remains open, the size of the Emanation increases by 10 feet until it reaches its maximum size of 120 feet.

Closing the bottle causes the cloud to become fixed in place until it disperses after 10 minutes. A strong wind (such as that created by the *Gust of Wind* spell) disperses the cloud after 1 minute.
`,
      "Eyes of Charming.md": `---
smType: item
name: "Eyes of Charming"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Eyes of Charming
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

These crystal lenses fit over the eyes. They have 3 charges. While wearing them, you can expend 1 or more charges to cast *Charm Person* (save DC 13). For 1 charge, you cast the level 1 version of the spell. You increase the spell's level by one for each additional charge you expend. The lenses regain all expended charges daily at dawn.
`,
      "Eyes of Minute Seeing.md": `---
smType: item
name: "Eyes of Minute Seeing"
category: "Wondrous"
rarity: "Uncommon"
---

# Eyes of Minute Seeing
*Wondrous Uncommon*

These crystal lenses fit over the eyes. While wearing them, your vision improves significantly out to a range of 1 foot, granting you Darkvision within that range and Advantage on Intelligence (Investigation) checks made to examine something within that range.
`,
      "Eyes of the Eagle.md": `---
smType: item
name: "Eyes of the Eagle"
category: "Wondrous"
rarity: "Uncommon"
---

# Eyes of the Eagle
*Wondrous Uncommon*

These crystal lenses fit over the eyes. While wearing them, you have Advantage on Wisdom (Perception) checks that rely on sight. In conditions of clear visibility, you can make out details of even extremely distant creatures and objects as small as 2 feet across.
`,
      "Feather Token.md": `---
smType: item
name: "Feather Token"
category: "Wondrous"
---

# Feather Token
*Wondrous*

This object looks like a feather. Different types of feather tokens exist, each with a different single-use effect. The GM chooses the kind of token or determines it randomly by rolling on the Feather Tokens table. The type of token determines its rarity.
`,
      "Figurine of Wondrous Power.md": `---
smType: item
name: "Figurine of Wondrous Power"
category: "Wondrous"
max_charges: 24
---

# Figurine of Wondrous Power
*Wondrous*

## Charges

This item has 24 charges.

A *Figurine of Wondrous Power* is a statuette small enough to fit in a pocket. If you take a Magic action to throw the figurine to a point on the ground within 60 feet of yourself, the figurine becomes a living creature specified in the figurine's description below. If the space where the creature would appear is occupied by other creatures or objects, or if there isn't enough space for the creature, the figurine doesn't become a creature.

The creature is Friendly to you and your allies. It understands your languages, obeys your commands, and takes its turn immediately after you on your Initiative count. If you issue no commands, the creature defends itself but takes no other actions.

The creature exists for a duration specific to each figurine. At the end of the duration, the creature reverts to its figurine form. It reverts to a figurine early if its creature form drops to 0 Hit Points or if you take a Magic action while touching the creature to make it revert to figurine form. When the creature becomes a figurine again, its property can't be used again until a certain amount of time has passed, as specified in the figurine's description.
`,
      "Flame Tongue.md": `---
smType: item
name: "Flame Tongue"
category: "Weapon"
type: "Any Melee Weapon"
rarity: "Rare"
attunement: true
---

# Flame Tongue
*Weapon (Any Melee Weapon) Rare (Requires Attunement)*

While holding this magic weapon, you can take a Bonus Action and use a command word to cause flames to engulf the damage-dealing part of the weapon. These flames shed Bright Light in a 40 foot radius and Dim Light for an additional 40 feet. While the weapon is ablaze, it deals an extra 2d6 Fire damage on a hit. The flames last until you take a Bonus Action to issue the command again or until you drop, stow, or sheathe the weapon.
`,
      "Folding Boat.md": `---
smType: item
name: "Folding Boat"
category: "Wondrous"
rarity: "Rare"
---

# Folding Boat
*Wondrous Rare*

This object appears as a wooden box that measures 12 inches long, 6 inches wide, and 6 inches deep. It weighs 4 pounds and floats. It can be opened to store items inside. This item also has three command words, each requiring a Magic action to use:

**First Command Word.** The box unfolds into a Rowboat.

**Second Command Word.** The box unfolds into a Keelboat.

**Third Command Word.** The *Folding Boat* folds back into a box if no creatures are aboard. Any objects in the vessel that can't fit inside the box remain outside the box as it folds. Any objects in the vessel that can fit inside the box do so.

When the box becomes a vessel, its weight becomes that of a normal vessel its size, and anything that was stored in the box remains in the boat.

Statistics for the Rowboat and Keelboat appear in "Equipment." If either vessel is reduced to 0 Hit Points, the *Folding Boat* is destroyed.
`,
      "Frost Brand.md": `---
smType: item
name: "Frost Brand"
category: "Weapon"
type: "Glaive, Greatsword, Longsword, Rapier, Scimitar, or Shortsword"
rarity: "Very Rare"
attunement: true
resistances: ["Fire"]
---

# Frost Brand
*Weapon (Glaive, Greatsword, Longsword, Rapier, Scimitar, or Shortsword) Very Rare (Requires Attunement)*

- Resistances: Fire

When you hit with an attack roll using this magic weapon, the target takes an extra 1d6 Cold damage. In addition, while you hold the weapon, you have Resistance to Fire damage.

In freezing temperatures, the weapon sheds Bright Light in a 10-foot radius and Dim Light for an additional 10 feet.

When you draw this weapon, you can extinguish all nonmagical flames within 30 feet of yourself. Once used, this property can't be used again for 1 hour.
`,
      "Gauntlets of Ogre Power.md": `---
smType: item
name: "Gauntlets of Ogre Power"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
ability_changes_json: "[{\\"ability\\":\\"str\\",\\"value\\":19},{\\"ability\\":\\"str\\",\\"value\\":19}]"
---

# Gauntlets of Ogre Power
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

## Ability Changes

- STR becomes 19
- STR becomes 19

Your Strength is 19 while you wear these gauntlets. They have no effect on you if your Strength is 19 or higher without them.
`,
      "Gem of Brightness.md": `---
smType: item
name: "Gem of Brightness"
category: "Wondrous"
rarity: "Uncommon"
max_charges: 50
---

# Gem of Brightness
*Wondrous Uncommon*

## Charges

This item has 50 charges.

This prism has 50 charges. While you are holding it, you can take a Magic action and use one of three command words to cause one of the following effects:

**First Command Word.** The gem sheds Bright Light in a 30-foot radius and Dim Light for an additional 30 feet. This effect doesn't expend a charge. It lasts until you take a Bonus Action to repeat the command word or until you use another function of the gem.

**Second Command Word.** You expend 1 charge and cause the gem to fire a brilliant beam of light at one creature you can see within 60 feet of yourself. The creature must succeed on a DC 15 Constitution saving throw or have the Blinded condition for 1 minute. The creature repeats the save at the end of each of its turns, ending the effect on itself on a success.

**Third Command Word.** You expend 5 charges and cause the gem to flare with intense light in a 30 foot Cone. Each creature in the Cone makes a saving throw as if struck by the beam created with the second command word.

When all of the gem's charges are expended, the gem becomes a nonmagical jewel worth 50 GP.
`,
      "Gem of Seeing.md": `---
smType: item
name: "Gem of Seeing"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Gem of Seeing
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This gem has 3 charges. As a Magic action, you can expend 1 charge. For the next 10 minutes, you have Truesight out to 120 feet when you peer through the gem.

The gem regains 1d3 expended charges daily at dawn.
`,
      "Giant Slayer.md": `---
smType: item
name: "Giant Slayer"
category: "Weapon"
type: "Any Simple or Martial"
rarity: "Rare"
---

# Giant Slayer
*Weapon (Any Simple or Martial) Rare*

You gain a +1 bonus to attack rolls and damage rolls made with this magic weapon.

When you hit a Giant with this weapon, the Giant takes an extra 2d6 damage of the weapon's type and must succeed on a DC 15 Strength saving throw or have the Prone condition.
`,
      "Glamoured Studded Leather.md": `---
smType: item
name: "Glamoured Studded Leather"
category: "Armor"
type: "Studded Leather Armor"
rarity: "Rare"
---

# Glamoured Studded Leather
*Armor (Studded Leather Armor) Rare*

While wearing this armor, you gain a +1 bonus to Armor Class. You can also take a Bonus Action to cause the armor to assume the appearance of a normal set of clothing or some other kind of armor. You decide what it looks like\u2014including color, style, and accessories\u2014but the armor retains its normal bulk and weight. The illusory appearance lasts until you use this property again or doff the armor.
`,
      "Gloves of Missile Snaring.md": `---
smType: item
name: "Gloves of Missile Snaring"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Gloves of Missile Snaring
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

If you're hit by an attack roll made with a Ranged or Thrown weapon while wearing these gloves, you can take a Reaction to reduce the damage by 1d10 plus your Dexterity modifier if you have a free hand. If you reduce the damage to 0, you can catch the ammunition or weapon if it is small enough for you to hold in that hand.
`,
      "Gloves of Swimming and Climbing.md": `---
smType: item
name: "Gloves of Swimming and Climbing"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Gloves of Swimming and Climbing
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing these gloves, you have a Climb Speed and a Swim Speed equal to your Speed, and you gain a +5 bonus to Strength (Athletics) checks made to climb or swim.
`,
      "Goggles of Night.md": `---
smType: item
name: "Goggles of Night"
category: "Wondrous"
rarity: "Uncommon"
---

# Goggles of Night
*Wondrous Uncommon*

While wearing these dark lenses, you have Darkvision out to 60 feet. If you already have Darkvision, wearing the goggles increases its range by 60 feet.
`,
      "Hammer of Thunderbolts.md": `---
smType: item
name: "Hammer of Thunderbolts"
category: "Weapon"
type: "Maul or Warhammer"
rarity: "Legendary"
attunement: true
max_charges: 5
recharge_formula: "1d4 + 1"
recharge_time: "Dawn"
---

# Hammer of Thunderbolts
*Weapon (Maul or Warhammer) Legendary (Requires Attunement)*

## Charges

This item has 5 charges.
regains 1d4 + 1 charges at Dawn.

You gain a +1 bonus to attack rolls and damage rolls made with this magic weapon.

The weapon has 5 charges. You can expend 1 charge and make a ranged attack with the weapon, hurling it as if it had the Thrown property with a normal range of 20 feet and a long range of 60 feet. If the attack hits, the weapon unleashes a thunderclap audible out to 300 feet. The target and every creature within 30 feet of it other than you must succeed on a DC 17 Constitution saving throw or have the Stunned condition until the end of your next turn. Immediately after hitting or missing, the weapon flies back to your hand. The weapon regains 1d4 + 1 expended charges daily at dawn.
`,
      "Handy Haversack.md": `---
smType: item
name: "Handy Haversack"
category: "Wondrous"
rarity: "Rare"
---

# Handy Haversack
*Wondrous Rare*

This backpack has a central pouch and two side pouches, each of which is an extradimensional space. Each side pouch can hold up to 200 pounds of material, not exceeding a volume of 25 cubic feet. The central pouch can hold up to 500 pounds of material, not exceeding a volume of 64 cubic feet. The haversack always weighs 5 pounds, regardless of its contents.

Retrieving an item from the haversack requires a Utilize action or a Bonus Action (your choice). When you reach into the haversack for a specific item, the item is always magically on top.

If any of its pouches is overloaded, pierced, or torn, the haversack ruptures and is destroyed. If the haversack is destroyed, its contents are lost forever, although an Artifact always turns up again somewhere. If the haversack is turned inside out, its contents spill forth unharmed, and the haversack must be put right before it can be used again.

Each pouch of the haversack holds enough air for 10 minutes of breathing, divided by the number of breathing creatures inside.

Placing the haversack inside an extradimensional space created by a *Bag of Holding*, *Portable Hole*, or similar item instantly destroys both items and opens a gate to the Astral Plane. The gate originates where the one item was placed inside the other. Any creature within 10 feet of the gate and not behind Total Cover is sucked through it and deposited in a random location on the Astral Plane. The gate then closes. The gate is one-way only and can't be reopened.
`,
      "Hat of Disguise.md": `---
smType: item
name: "Hat of Disguise"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Hat of Disguise
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this hat, you can cast the *Disguise Self* spell. The spell ends if the hat is removed.
`,
      "Headband of Intellect.md": `---
smType: item
name: "Headband of Intellect"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
ability_changes_json: "[{\\"ability\\":\\"int\\",\\"value\\":19},{\\"ability\\":\\"int\\",\\"value\\":19}]"
---

# Headband of Intellect
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

## Ability Changes

- INT becomes 19
- INT becomes 19

Your Intelligence is 19 while you wear this headband. It has no effect on you if your Intelligence is 19 or higher without it.
`,
      "Helm of Brilliance.md": `---
smType: item
name: "Helm of Brilliance"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
resistances: ["Fire"]
---

# Helm of Brilliance
*Wondrous (Requires Attunement) Very Rare (Requires Attunement)*

- Resistances: Fire

This helm is set with 1d10 diamonds, 2d10 rubies, 3d10 fire opals, and 4d10 opals. Any gem pried from the helm crumbles to dust. When all the gems are removed or destroyed, the helm loses its magic.

You gain the following benefits while wearing the helm.
`,
      "Helm of Comprehending Languages.md": `---
smType: item
name: "Helm of Comprehending Languages"
category: "Wondrous"
rarity: "Uncommon"
---

# Helm of Comprehending Languages
*Wondrous Uncommon*

While wearing this helm, you can cast *Comprehend Languages* from it.
`,
      "Helm of Telepathy.md": `---
smType: item
name: "Helm of Telepathy"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Helm of Telepathy
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this helm, you have telepathy with a range of 30 feet, and you can cast *Detect Thoughts* or *Suggestion* (save DC 13) from the helm. Once either spell is cast from the helm, that spell can't be cast from it again until the next dawn.
`,
      "Helm of Teleportation.md": `---
smType: item
name: "Helm of Teleportation"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Helm of Teleportation
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This helm has 3 charges. While wearing it, you can expend 1 charge to cast *Teleport* from it. The helm regains 1d3 expended charges daily at dawn.
`,
      "Holy Avenger.md": `---
smType: item
name: "Holy Avenger"
category: "Weapon"
type: "Any Simple or Martial"
rarity: "Legendary"
attunement: true
attunement_req: "by a Paladin"
---

# Holy Avenger
*Weapon (Any Simple or Martial) Legendary (Requires Attunement by a Paladin)*

You gain a +3 bonus to attack rolls and damage rolls made with this magic weapon. When you hit a Fiend or an Undead with it, that creature takes an extra 2d10 Radiant damage.

While you hold the drawn weapon, it creates a 10-foot Emanation originating from you. You and all creatures Friendly to you in the Emanation have Advantage on saving throws against spells and other magical effects. If you have 17 or more levels in the Paladin class, the size of the Emanation increases to 30 feet.
`,
      "Horn of Blasting.md": `---
smType: item
name: "Horn of Blasting"
category: "Wondrous"
rarity: "Rare"
---

# Horn of Blasting
*Wondrous Rare*

You can take a Magic action to blow the horn, which emits a thunderous blast in a 30-foot Cone that is audible out to 600 feet. Each creature in the Cone makes a DC 15 Constitution saving throw. On a failed save, a creature takes 5d8 Thunder damage and has the Deafened condition for 1 minute. On a successful save, a creature takes half as much damage only. Glass or crystal objects in the Cone that aren't being worn or carried take 10d8 Thunder damage.

Each use of the horn's magic has a 20 percent chance of causing the horn to explode. The explosion deals 10d6 Force damage to the user and destroys the horn.
`,
      "Horn of Valhalla.md": `---
smType: item
name: "Horn of Valhalla"
category: "Wondrous"
type: "Silver or Brass"
rarity: "Rare"
---

# Horn of Valhalla
*Wondrous (Silver or Brass) Rare*

You can take a Magic action to blow this horn. In response, warrior spirits from the plane of Ysgard appear in unoccupied spaces within 60 feet of you. Each spirit uses the **Berserker** stat block and returns to Ysgard after 1 hour or when it drops to 0 Hit Points. The spirits look like living, breathing warriors, and they have Immunity to the Charmed and Frightened conditions. Once you use the horn, it can't be used again until 7 days have passed.

Four types of *Horn of Valhalla* are known to exist, each made of a different metal. The horn's type determines how many spirits it summons, as well as the requirement for its use. The GM chooses the horn's type or determines it randomly by rolling on the following table.

If you blow the horn without meeting its requirement, the summoned spirits attack you. If you meet the requirement, they are Friendly to you and your allies and follow your commands.
`,
      "Horseshoes of Speed.md": `---
smType: item
name: "Horseshoes of Speed"
category: "Wondrous"
rarity: "Rare"
---

# Horseshoes of Speed
*Wondrous Rare*

These horseshoes come in a set of four. As a Magic action, you can touch one of the horseshoes to the hoof of a horse or similar creature, whereupon the horseshoe affixes itself to the hoof. Removing a horseshoe also takes a Magic action.

While all four horseshoes are attached to the same creature, its Speed is increased by 30 feet.
`,
      "Horseshoes of a Zephyr.md": `---
smType: item
name: "Horseshoes of a Zephyr"
category: "Wondrous"
rarity: "Very Rare"
---

# Horseshoes of a Zephyr
*Wondrous Very Rare*

These horseshoes come in a set of four. As a Magic action, you can touch one of the horseshoes to the hoof of a horse or similar creature, whereupon the horseshoe affixes itself to the hoof. Removing a horseshoe also takes a Magic action.

While all four shoes are affixed to the hooves of a horse or similar creature, they allow the creature to move normally while floating 4 inches above a surface. This effect means the creature can cross or stand above nonsolid or unstable surfaces, such as water or lava. The creature leaves no tracks and ignores Difficult Terrain. In addition, the creature can travel for up to 12 hours a day without gaining Exhaustion levels from extended travel.
`,
      "Immovable Rod.md": `---
smType: item
name: "Immovable Rod"
category: "Rod"
rarity: "Uncommon"
---

# Immovable Rod
*Rod Uncommon*

This iron rod has a button on one end. You can take a Utilize action to press the button, which causes the rod to become magically fixed in place. Until you or another creature takes a Utilize action to push the button again, the rod doesn't move, even if it defies gravity. The rod can hold up to 8,000 pounds of weight. More weight causes the rod to deactivate and fall. A creature can take a Utilize action to make a DC 30 Strength (Athletics) check, moving the fixed rod up to 10 feet on a successful check.
`,
      "Instant Fortress.md": `---
smType: item
name: "Instant Fortress"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Instant Fortress
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

As a Magic action, you can place this 1-inch adamantine statuette on the ground and, using a command word, cause it to grow rapidly into a square adamantine tower. Repeating the command word causes the tower to revert to statuette form, which works only if the tower is empty. Each creature in the area where the tower appears is pushed to an unoccupied space outside but next to the tower. Objects in the area that aren't being worn or carried are also pushed clear of the tower.

The tower is 20 feet on a side and 30 feet high, with arrow slits on all sides and a battlement atop it. Its interior is divided into two floors, with a ladder, staircase, or ramp (your choice) connecting them. This ladder, staircase, or ramp ends at a trapdoor leading to the roof. When created, the tower has a single door at ground level on the side facing you. The door opens only at your command, which you can issue as a Bonus Action. It is immune to the *Knock* spell and similar magic.

Magic prevents the tower from being tipped over. The roof, the door, and the walls each have AC 20; HP 100; Immunity to Bludgeoning, Piercing, and Slashing damage except that which is dealt by siege equipment; and Resistance to all other damage. Shrinking the tower back down to statuette form doesn't repair damage to the tower. Only a *Wish* spell can repair the tower (this use of the spell counts as replicating a spell of level 8 or lower). Each casting of *Wish* causes the tower to regain all its Hit Points.
`,
      "Ioun Stone.md": `---
smType: item
name: "Ioun Stone"
category: "Wondrous"
type: "Requires Attunement"
attunement: true
---

# Ioun Stone
*Wondrous (Requires Attunement) (Requires Attunement)*

Roughly marble sized, *Ioun Stones* are named after Ioun, a god of knowledge and prophecy revered on some worlds. Many types of *Ioun Stones* exist, each type a distinct combination of shape and color.

When you take a Magic action to toss an *Ioun Stone* into the air, the stone orbits your head at a distance of 1d3 feet, conferring its benefit to you while doing so. You can have up to three *Ioun Stones* orbiting your head at the same time.

Each *Ioun Stone* orbiting your head is considered to be an object you are wearing. The orbiting stone avoids contact with other creatures and objects, adjusting its orbit to avoid collisions and thwarting all attempts by other creatures to attack or snatch it.

As a Utilize action, you can seize and stow any number of *Ioun Stones* orbiting your head. If your Attunement to an *Ioun Stone* ends while it's orbiting your head, the stone falls as though you had dropped it.

The type of stone determines its rarity and effects.
`,
      "Iron Bands.md": `---
smType: item
name: "Iron Bands"
category: "Wondrous"
rarity: "Rare"
---

# Iron Bands
*Wondrous Rare*

This rusty iron sphere measures 3 inches in diameter and weighs 1 pound. You can take a Magic action to throw the sphere at a Huge or smaller creature you can see within 60 feet of yourself. As the sphere moves through the air, it opens into a tangle of metal bands.

Make a ranged attack roll with an attack bonus equal to your Dexterity modifier plus your Proficiency Bonus. On a hit, the target has the Restrained condition until you take a Bonus Action to issue a command that releases it. Doing so or missing with the attack causes the bands to contract and become a sphere once more.

A creature that can touch the bands, including the one Restrained, can take an action to make a DC 20 Strength (Athletics) check to break the iron bands. On a successful check, the item is destroyed, and the Restrained creature is freed. On a failed check, any further attempts made by that creature automatically fail until 24 hours have elapsed.

Once the bands are used, they can't be used again until the next dawn.
`,
      "Iron Flask.md": `---
smType: item
name: "Iron Flask"
category: "Wondrous"
rarity: "Legendary"
---

# Iron Flask
*Wondrous Legendary*

While holding this brass-stoppered iron flask, you can take a Magic action to target a creature that you can see within 60 feet of yourself. If the flask is empty and the target is native to a plane of existence other than the one you're on, the target must succeed on a DC 17 Wisdom saving throw or be trapped in the flask. If the target has been trapped by the flask before, it has Advantage on the save. Once trapped, a creature remains in the flask until released. The flask can hold only one creature at a time. A creature trapped in the flask doesn't age and doesn't need to breathe, eat, or drink.

You can take a Magic action to remove the flask's stopper and release the creature in the flask. The creature then obeys your commands for 1 hour, understanding those commands even if it doesn't know the language in which the commands are given. If you issue no commands or give the creature a command that is likely to result in its death or imprisonment, it defends itself but otherwise takes no actions. At the end of the duration, the creature acts in accordance with its normal disposition and alignment.

An *Identify* spell reveals if the flask contains a creature, but the only way to determine the type of creature is to open the flask. A newly discovered *Iron Flask* might already contain a creature chosen by the GM.
`,
      "Javelin of Lightning.md": `---
smType: item
name: "Javelin of Lightning"
category: "Weapon"
type: "Javelin"
rarity: "Uncommon"
---

# Javelin of Lightning
*Weapon (Javelin) Uncommon*

Each time you make an attack roll with this magic weapon and hit, you can have it deal Lightning damage instead of Piercing damage.

*Lightning Bolt.* When you throw this weapon at a target no farther than 120 feet from you, you can forgo making a ranged attack roll and instead turn the weapon into a bolt of lightning. This bolt forms a 5-foot-wide Line between you and the target. The target and each other creature in the Line (excluding you) makes a DC 13 Dexterity saving throw, taking 4d6 Lightning damage on a failed save or half as much damage on a successful one. Immediately after dealing this damage, the weapon reappears in your hand. This property can't be used again until the next dawn.
`,
      "Lantern of Revealing.md": `---
smType: item
name: "Lantern of Revealing"
category: "Wondrous"
rarity: "Uncommon"
---

# Lantern of Revealing
*Wondrous Uncommon*

While lit, this hooded lantern burns for 6 hours on 1 pint of oil, shedding Bright Light in a 30-foot radius and Dim Light for an additional 30 feet. Invisible creatures and objects are visible as long as they are in the lantern's Bright Light. You can take a Utilize action to lower the hood, reducing the lantern's light to Dim Light in a 5-foot radius.
`,
      "Luck Blade.md": `---
smType: item
name: "Luck Blade"
category: "Weapon"
type: "Glaive, Greatsword, Longsword, Rapier, Scimitar, Sickle, or Shortsword"
rarity: "Legendary"
attunement: true
---

# Luck Blade
*Weapon (Glaive, Greatsword, Longsword, Rapier, Scimitar, Sickle, or Shortsword) Legendary (Requires Attunement)*

You gain a +1 bonus to attack rolls and damage rolls made with this magic weapon. While the weapon is on your person, you also gain a +1 bonus to saving throws.

*Luck.* If the weapon is on your person, you can call on its luck (no action required) to reroll one failed D20 Test if you don't have the Incapacitated condition. You must use the second roll. Once used, this property can't be used again until the next dawn.

*Wish.* The weapon has 1d3 charges. While holding it, you can expend 1 charge and cast *Wish* from it. Once used, this property can't be used again until the next dawn. The weapon loses this property if it has no charges.
`,
      "Mace of Disruption.md": `---
smType: item
name: "Mace of Disruption"
category: "Weapon"
type: "Mace"
rarity: "Rare"
attunement: true
---

# Mace of Disruption
*Weapon (Mace) Rare (Requires Attunement)*

When you hit a Fiend or an Undead with this magic weapon, that creature takes an extra 2d6 Radiant damage. If the target has 25 Hit Points or fewer after taking this damage, it must succeed on a DC 15 Wisdom saving throw or be destroyed. On a successful save, the creature has the Frightened condition until the end of your next turn.
`,
      "Mace of Smiting.md": `---
smType: item
name: "Mace of Smiting"
category: "Weapon"
type: "Mace"
rarity: "Rare"
---

# Mace of Smiting
*Weapon (Mace) Rare*

You gain a +1 bonus to attack rolls and damage rolls made with this magic weapon. The bonus increases to +3 when you use the weapon to attack a Construct.

When you roll a 20 on an attack roll made with this weapon, the target takes an extra 7 Bludgeoning damage, or 14 Bludgeoning damage if it's a Construct. If a Construct has 25 Hit Points or fewer after taking this damage, it is destroyed.
`,
      "Mace of Terror.md": `---
smType: item
name: "Mace of Terror"
category: "Weapon"
type: "Mace"
rarity: "Rare"
attunement: true
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Mace of Terror
*Weapon (Mace) Rare (Requires Attunement)*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This magic weapon has 3 charges and regains 1d3 expended charges daily at dawn. While holding the weapon, you can take a Magic action and expend 1 charge to release a wave of terror from it. Each creature of your choice within 30 feet of you must succeed on a DC 15 Wisdom saving throw or have the Frightened condition for 1 minute. While Frightened in this way, a creature must spend its turns trying to move as far away from you as it can, and it can't make Opportunity Attacks. For its action, it can use only the Dash action or try to escape from an effect that prevents it from moving. If it has nowhere it can move, the creature can take the Dodge action. At the end of each of its turns, a creature repeats the save, ending the effect on itself on a success.
`,
      "Mantle of Spell Resistance.md": `---
smType: item
name: "Mantle of Spell Resistance"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Mantle of Spell Resistance
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

You have Advantage on saving throws against spells while you wear this cloak.
`,
      "Manual of Bodily Health.md": `---
smType: item
name: "Manual of Bodily Health"
category: "Wondrous"
rarity: "Very Rare"
---

# Manual of Bodily Health
*Wondrous Very Rare*

This book contains health and nutrition tips, and its words are charged with magic. If you spend 48 hours over a period of 6 days or fewer studying the book's contents and practicing its guidelines, your Constitution increases by 2, to a maximum of 30. The manual then loses its magic but regains it in a century.
`,
      "Manual of Gainful Exercise.md": `---
smType: item
name: "Manual of Gainful Exercise"
category: "Wondrous"
rarity: "Very Rare"
---

# Manual of Gainful Exercise
*Wondrous Very Rare*

This book describes fitness exercises, and its words are charged with magic. If you spend 48 hours over a period of 6 days or fewer studying the book's contents and practicing its guidelines, your Strength increases by 2, to a maximum of 30. The manual then loses its magic but regains it in a century.
`,
      "Manual of Golems.md": `---
smType: item
name: "Manual of Golems"
category: "Wondrous"
rarity: "Very Rare"
---

# Manual of Golems
*Wondrous Very Rare*

This tome contains information and incantations necessary to make a particular type of golem. The GM chooses the type or determines it randomly by rolling on the accompanying table. To decipher and use the manual, you must be a spellcaster with at least two level 5 spell slots. A creature that can't use a *Manual of Golems* and attempts to read it takes 6d6 Psychic damage.

To create a golem, you must spend the time shown on the table, working without interruption with the manual at hand and resting no more than 8 hours per day. You must also pay the specified cost to purchase supplies.

Once you finish creating the golem, the book is consumed in eldritch flames. The golem becomes animate when the ashes of the manual are sprinkled on it. See "Monsters" for the golem's stat block. The golem is under your control, and it understands and obeys your commands.
`,
      "Manual of Quickness of Action.md": `---
smType: item
name: "Manual of Quickness of Action"
category: "Wondrous"
rarity: "Very Rare"
---

# Manual of Quickness of Action
*Wondrous Very Rare*

This book contains coordination and balance exercises, and its words are charged with magic. If you spend 48 hours over a period of 6 days or fewer studying the book's contents and practicing its guidelines, your Dexterity increases by 2, to a maximum of 30. The manual then loses its magic but regains it in a century.
`,
      "Marvelous Pigments.md": `---
smType: item
name: "Marvelous Pigments"
category: "Wondrous"
rarity: "Very Rare"
---

# Marvelous Pigments
*Wondrous Very Rare*

This fine wooden box contains 1d4 pots of pigment and a brush (weighing 1 pound in total).

Using the brush and expending 1 pot of pigment, you can paint any number of three-dimensional objects and terrain features (such as walls, doors, trees, flowers, weapons, webs, and pits), provided these elements are all confined to a 20-foot Cube. The effort takes 10 minutes (regardless of the number of elements you create), during which time you must remain in the Cube, and requires Concentration. If your Concentration is broken or you leave the Cube before the work is done, all the painted elements vanish, and the pot of pigment is wasted.

When the work is done, all the painted objects and terrain features become real. Thus, painting a door on a wall creates an actual door, which can be opened to whatever is beyond. Painting a pit creates a real pit, the entire depth of which must lie within the 20-foot Cube.

No object created by a pot of pigment can have a value greater than 25 GP, and the total value of all objects created by a pot of pigment can't exceed 500 GP. If you paint objects of greater value (such as a large pile of gold), they look authentic, but close inspection reveals they're made from paste, cookies, or some other worthless material.

If you paint a form of energy such as fire or lightning, the energy dissipates as soon as you complete the painting, doing no harm.
`,
      "Medallion of Thoughts.md": `---
smType: item
name: "Medallion of Thoughts"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
max_charges: 5
recharge_formula: "1d4"
recharge_time: "Dawn"
---

# Medallion of Thoughts
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

## Charges

This item has 5 charges.
regains 1d4 charges at Dawn.

The medallion has 5 charges. While wearing it, you can expend 1 charge to cast *Detect Thoughts* (save DC 13) from it. The medallion regains 1d4 expended charges daily at dawn.
`,
      "Mirror of Life Trapping.md": `---
smType: item
name: "Mirror of Life Trapping"
category: "Wondrous"
rarity: "Very Rare"
---

# Mirror of Life Trapping
*Wondrous Very Rare*

When this 4-foot-tall, 2-foot-wide mirror is viewed indirectly, its surface shows faint images of creatures. The mirror weighs 50 pounds, and it has AC 11, HP 10, Immunity to Poison and Psychic damage, and Vulnerability to Bludgeoning damage. It shatters and is destroyed when reduced to 0 Hit Points.

If the mirror is hanging on a vertical surface and you are within 5 feet of it, you can take a Magic action and use a command word to activate it. It remains activated until you take a Magic action and repeat the command word to deactivate it.

Any creature other than you that sees its reflection in the activated mirror while within 30 feet of the mirror must succeed on a DC 15 Charisma saving throw or be trapped, along with anything it is wearing or carrying, in one of the mirror's twelve extradimensional cells. A creature that knows the mirror's nature makes the save with Advantage, and Constructs succeed on the save automatically.

An extradimensional cell is an infinite expanse filled with thick fog that reduces visibility to 10 feet. Creatures trapped in the mirror's cells don't age, and they don't need to eat, drink, or sleep. A creature trapped within a cell can escape using magic that permits planar travel. Otherwise, the creature is confined to the cell until freed.

If the mirror traps a creature but its twelve extradimensional cells are already occupied, the mirror frees one trapped creature at random to accommodate the new prisoner. A freed creature appears in an unoccupied space within sight of the mirror but facing away from it. If the mirror is shattered, all creatures it contains are freed and appear in unoccupied spaces near it.

While within 5 feet of the mirror, you can take a Magic action to name one creature trapped in it or call out a particular cell by number. The creature named or contained in the named cell appears as an image on the mirror's surface. You and the creature can then communicate.

In a similar way, you can take a Magic action and use a second command word to free one creature trapped in the mirror. The freed creature appears, along with its possessions, in the unoccupied space nearest to the mirror and facing away from it.

Placing the mirror inside an extradimensional space created by a *Bag of Holding*, *Portable Hole*, or similar item instantly destroys both items and opens a gate to the Astral Plane. The gate originates where the one item was placed inside the other. Any creature within 10 feet of the gate and not behind Total Cover is sucked through it to a random location on the Astral Plane. The gate then closes. The gate is one-way only and can't be reopened.
`,
      "Mithral Armor.md": `---
smType: item
name: "Mithral Armor"
category: "Armor"
type: "Any Medium or Heavy, Except Hide Armor"
rarity: "Uncommon"
---

# Mithral Armor
*Armor (Any Medium or Heavy, Except Hide Armor) Uncommon*

Mithral is a light, flexible metal. Armor made of this substance can be worn under normal clothes. If the armor normally imposes Disadvantage on Dexterity (Stealth) checks or has a Strength requirement, the mithral version of the armor doesn't.
`,
      "Mysterious Deck.md": `---
smType: item
name: "Mysterious Deck"
category: "Wondrous"
rarity: "Legendary"
---

# Mysterious Deck
*Wondrous Legendary*

Usually found in a box or pouch, this deck contains a number of cards made of ivory or vellum. Most (75 percent) of these decks have thirteen cards, but some have twenty-two. Use the appropriate column of the Mysterious Deck table when randomly determining cards drawn from the deck.

Before you draw a card, you must declare how many cards you intend to draw and then draw them randomly. Any cards drawn in excess of this number have no effect. Otherwise, as soon as you draw a card from the deck, its magic takes effect. You must draw each card no more than 1 hour after the previous draw. If you fail to draw the chosen number, the remaining number of cards fly from the deck on their own and take effect all at once.

Once a card is drawn, it disappears. Unless the card is the Fool or Jester, the card reappears in the deck, making it possible to draw the same card twice. (Once the Fool or Jester has left the deck, reroll on the table if that card comes up again.)
`,
      "Necklace of Adaptation.md": `---
smType: item
name: "Necklace of Adaptation"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Necklace of Adaptation
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this necklace, you can breathe normally in any environment, and you have Advantage on saving throws made to avoid or end the Poisoned condition.
`,
      "Necklace of Fireballs.md": `---
smType: item
name: "Necklace of Fireballs"
category: "Wondrous"
rarity: "Rare"
---

# Necklace of Fireballs
*Wondrous Rare*

This necklace has 1d6 + 3 beads hanging from it. You can take a Magic action to detach a bead and throw it up to 60 feet away. When it reaches the end of its trajectory, the bead detonates as a level 3 *Fireball* (save DC 15).

You can hurl multiple beads, or even the whole necklace, at one time. When you do so, increase the damage of the *Fireball* by 1d6 for each bead after the first (maximum 12d6).
`,
      "Necklace of Prayer Beads.md": `---
smType: item
name: "Necklace of Prayer Beads"
category: "Wondrous"
type: "Requires Attunement by a Cleric, Druid, or Paladin"
rarity: "Rare"
attunement: true
attunement_req: "by a Cleric, Druid, or Paladin"
---

# Necklace of Prayer Beads
*Wondrous (Requires Attunement by a Cleric, Druid, or Paladin) Rare (Requires Attunement by a Cleric, Druid, or Paladin)*

This necklace has 1d4 + 2 magic beads made from aquamarine, black pearl, or topaz. It also has many nonmagical beads made from stones such as amber, bloodstone, citrine, coral, jade, pearl, or quartz. If a magic bead is removed from the necklace, that bead loses its magic.

Six types of magic beads exist. The GM decides the type of each bead on the necklace or determines it randomly by rolling on the table below. A necklace can have more than one bead of the same type. To use one, you must be wearing the necklace. Each bead contains a spell that you can cast from it as a Bonus Action (using your spell save DC if a save is necessary). Once a magic bead's spell is cast, that bead can't be used again until the next dawn.
`,
      "Nine Lives Stealer.md": `---
smType: item
name: "Nine Lives Stealer"
category: "Weapon"
type: "Any Simple or Martial"
rarity: "Very Rare"
attunement: true
---

# Nine Lives Stealer
*Weapon (Any Simple or Martial) Very Rare (Requires Attunement)*

You gain a +2 bonus to attack rolls and damage rolls made with this magic weapon.
`,
      "Oathbow.md": `---
smType: item
name: "Oathbow"
category: "Weapon"
type: "Longbow or Shortbow"
rarity: "Very Rare"
attunement: true
---

# Oathbow
*Weapon (Longbow or Shortbow) Very Rare (Requires Attunement)*

When you nock an arrow on this bow, it whispers in Elvish, "Swift defeat to my enemies." When you use this weapon to make a ranged attack, you can utter or sign the following command words: "Swift death to you who have wronged me." The target of your attack becomes your sworn enemy until it dies or until dawn 7 days later. You can have only one such sworn enemy at a time. When your sworn enemy dies, you can choose a new one after the next dawn.

When you make a ranged attack roll with this weapon against your sworn enemy, you have Advantage on the roll. In addition, your target gains no benefit from Half Cover or Three-Quarters Cover, and you suffer no Disadvantage due to long range. If the attack hits, your sworn enemy takes an extra 3d6 Piercing damage.

While your sworn enemy lives, you have Disadvantage on attack rolls with all other weapons.
`,
      "Oil of Etherealness.md": `---
smType: item
name: "Oil of Etherealness"
category: "Potion"
rarity: "Rare"
---

# Oil of Etherealness
*Potion Rare*

One vial of this oil can cover one Medium or smaller creature, along with the equipment it's wearing and carrying (one additional vial is required for each size category above Medium). Applying the oil takes 10 minutes. The affected creature then gains the effect of the *Etherealness* spell for 1 hour.

Beads of this cloudy, gray oil form on the outside of its container and quickly evaporate.
`,
      "Oil of Sharpness.md": `---
smType: item
name: "Oil of Sharpness"
category: "Potion"
rarity: "Very Rare"
---

# Oil of Sharpness
*Potion Very Rare*

One vial of this oil can coat one Melee weapon or twenty pieces of ammunition, but only ammunition and Melee weapons that are nonmagical and deal Slashing or Piercing damage are affected. Applying the oil takes 1 minute, after which the oil magically seeps into whatever it coats, turning the coated weapon into a *+3 Weapon* or the coated ammunition into *+3 Ammunition*.

This clear, gelatinous oil sparkles with tiny, ultrathin silver shards.
`,
      "Oil of Slipperiness.md": `---
smType: item
name: "Oil of Slipperiness"
category: "Potion"
rarity: "Uncommon"
---

# Oil of Slipperiness
*Potion Uncommon*

One vial of this oil can cover one Medium or smaller creature, along with the equipment it's wearing and carrying (one additional vial is required for each size category above Medium). Applying the oil takes 10 minutes. The affected creature then gains the effect of the *Freedom of Movement* spell for 8 hours.

Alternatively, the oil can be poured on the ground as a Magic action, where it covers a 10-foot square, duplicating the effect of the *Grease* spell in that area for 8 hours.

This sticky, black unguent is thick and heavy, but it flows quickly when poured.
`,
      "Pearl of Power.md": `---
smType: item
name: "Pearl of Power"
category: "Wondrous"
type: "Requires Attunement by a Spellcaster"
rarity: "Uncommon"
attunement: true
attunement_req: "by a Spellcaster"
---

# Pearl of Power
*Wondrous (Requires Attunement by a Spellcaster) Uncommon (Requires Attunement by a Spellcaster)*

While this pearl is on your person, you can take a Magic action to regain one expended spell slot of level 3 or lower. Once you use the pearl, it can't be used again until the next dawn.
`,
      "Periapt of Health.md": `---
smType: item
name: "Periapt of Health"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Periapt of Health
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this pendant, you can take a Magic action to regain 2d4 + 2 Hit Points. Once used, this property can't be used again until the next dawn.

In addition, you have Advantage on saving throws to avoid or end the Poisoned condition while you wear this pendant.
`,
      "Periapt of Proof against Poison.md": `---
smType: item
name: "Periapt of Proof against Poison"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Periapt of Proof against Poison
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

This delicate silver chain has a brilliant-cut black gem pendant. While you wear it, you have Immunity to the Poisoned condition and Poison damage.
`,
      "Periapt of Wound Closure.md": `---
smType: item
name: "Periapt of Wound Closure"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Periapt of Wound Closure
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this pendant, you gain the following benefits.
`,
      "Philter of Love.md": `---
smType: item
name: "Philter of Love"
category: "Potion"
rarity: "Uncommon"
---

# Philter of Love
*Potion Uncommon*

The next time you see a creature within 10 minutes after drinking this philter, you are charmed by that creature and have the Charmed condition for 1 hour.

This rose-hued, effervescent liquid contains one easy-to-miss bubble shaped like a heart.
`,
      "Pipes of Haunting.md": `---
smType: item
name: "Pipes of Haunting"
category: "Wondrous"
rarity: "Uncommon"
---

# Pipes of Haunting
*Wondrous Uncommon*

These pipes have 3 charges and regain 1d3 expended charges daily at dawn. You can take a Magic action to play them and expend 1 charge to create an eerie, spellbinding tune. Each creature of your choice within 30 feet of you must succeed on a DC 15 Wisdom saving throw or have the Frightened condition for 1 minute. A creature that fails the save repeats it at the end of each of its turns, ending the effect on itself on a success. A creature that succeeds on its save is immune to the effect of these pipes for 24 hours.
`,
      "Pipes of the Sewers.md": `---
smType: item
name: "Pipes of the Sewers"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Pipes of the Sewers
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While these pipes are on your person, ordinary rats and giant rats are Indifferent toward you and won't attack you unless you threaten or harm them.

The pipes have 3 charges and regain 1d3 expended charges daily at dawn. If you play the pipes as a Magic action, you can take a Bonus Action to expend 1 to 3 charges, calling forth one **Swarm of Rats** with each expended charge if enough rats are within half a mile of you to be called in this fashion (as determined by the GM). If there aren't enough rats to form a swarm, the charge is wasted. Called swarms move toward the music by the shortest available route but aren't under your control otherwise.

Whenever a **Swarm of Rats** that isn't under another creature's control comes within 30 feet of you while you are playing the pipes, the swarm makes a DC 15 Wisdom saving throw. On a successful save, the swarm behaves as it normally would and can't be swayed by the pipes' music for the next 24 hours. On a failed save, the swarm is swayed by the pipes' music and becomes Friendly to you and your allies for as long as you continue to play the pipes each round as a Magic action. A Friendly swarm obeys your commands. If you issue no commands to a Friendly swarm, it defends itself but otherwise takes no actions. If a Friendly swarm starts its turn more than 30 feet away from you, your control over that swarm ends, and the swarm behaves as it normally would and can't be swayed by the pipes' music for the next 24 hours.
`,
      "Plate Armor of Etherealness.md": `---
smType: item
name: "Plate Armor of Etherealness"
category: "Armor"
type: "Half Plate Armor or Plate Armor"
rarity: "Legendary"
attunement: true
---

# Plate Armor of Etherealness
*Armor (Half Plate Armor or Plate Armor) Legendary (Requires Attunement)*

While you're wearing this armor, you can take a Magic action and use a command word to gain the effect of the *Etherealness* spell. The spell ends immediately if you remove the armor or take a Magic action to repeat the command word. This property of the armor can't be used again until the next dawn.
`,
      "Portable Hole.md": `---
smType: item
name: "Portable Hole"
category: "Wondrous"
rarity: "Rare"
---

# Portable Hole
*Wondrous Rare*

This fine black cloth, soft as silk, is folded up to the dimensions of a handkerchief. It unfolds into a circular sheet 6 feet in diameter.

You can take a Magic action to unfold a *Portable Hole* and place it on or against a solid surface, whereupon the *Portable Hole* creates an extradimensional hole 10 feet deep. The cylindrical space within the hole exists on a different plane of existence, so it can't be used to create open passages. Any creature inside an open *Portable Hole* can exit the hole by climbing out of it.

You can take a Magic action to close a *Portable Hole* by taking hold of the edges of the cloth and folding it up. Folding the cloth closes the hole, and any creatures or objects within remain in the extradimensional space. No matter what's in it, the hole weighs next to nothing.

If the hole is folded up, a creature within the hole's extradimensional space can take an action to make a DC 10 Strength (Athletics) check. On a successful check, the creature forces its way out and appears within 5 feet of the *Portable Hole*. A closed *Portable Hole* holds enough air for 1 hour of breathing, divided by the number of breathing creatures inside.

Placing a *Portable Hole* inside an extradimensional space created by a *Bag of Holding*, *Handy Haversack*, or similar item instantly destroys both items and opens a gate to the Astral Plane. The gate originates where the one item was placed inside the other. Any creature within 10 feet of the gate and not behind Total Cover is sucked through it and deposited in a random location on the Astral Plane. The gate then closes. The gate is one-way only and can't be reopened.
`,
      "Potion of Animal Friendship.md": `---
smType: item
name: "Potion of Animal Friendship"
category: "Potion"
rarity: "Uncommon"
---

# Potion of Animal Friendship
*Potion Uncommon*

When you drink this potion, you can cast the level 3 version of the *Animal Friendship* spell (save DC 13).

Agitating this potion's muddy liquid brings little bits into view: a fish scale, a hummingbird feather, a cat claw, or a squirrel hair.
`,
      "Potion of Clairvoyance.md": `---
smType: item
name: "Potion of Clairvoyance"
category: "Potion"
rarity: "Rare"
---

# Potion of Clairvoyance
*Potion Rare*

When you drink this potion, you gain the effect of the *Clairvoyance* spell (no Concentration required).

An eyeball bobs in this potion's yellowish liquid but vanishes when the potion is opened.
`,
      "Potion of Climbing.md": `---
smType: item
name: "Potion of Climbing"
category: "Potion"
rarity: "Common"
---

# Potion of Climbing
*Potion Common*

When you drink this potion, you gain a Climb Speed equal to your Speed for 1 hour. During this time, you have Advantage on Strength (Athletics) checks to climb.

This potion is separated into brown, silver, and gray layers resembling bands of stone. Shaking the bottle fails to mix the colors.
`,
      "Potion of Diminution.md": `---
smType: item
name: "Potion of Diminution"
category: "Potion"
rarity: "Rare"
---

# Potion of Diminution
*Potion Rare*

When you drink this potion, you gain the "reduce" effect of the *Enlarge/Reduce* spell for 1d4 hours (no Concentration required).

The red in the potion's liquid continuously contracts to a tiny bead and then expands to color the clear liquid around it. Shaking the bottle fails to interrupt this process.
`,
      "Potion of Flying.md": `---
smType: item
name: "Potion of Flying"
category: "Potion"
rarity: "Very Rare"
---

# Potion of Flying
*Potion Very Rare*

When you drink this potion, you gain a Fly Speed equal to your Speed for 1 hour and can hover. If you're in the air when the potion wears off, you fall unless you have some other means of staying aloft.

This potion's clear liquid floats at the top of its container and has cloudy white impurities drifting in it.
`,
      "Potion of Gaseous Form.md": `---
smType: item
name: "Potion of Gaseous Form"
category: "Potion"
rarity: "Rare"
---

# Potion of Gaseous Form
*Potion Rare*

When you drink this potion, you gain the effect of the *Gaseous Form* spell for 1 hour (no Concentration required) or until you end the effect as a Bonus Action.

This potion's container seems to hold fog that moves and pours like water.
`,
      "Potion of Giant Strength.md": `---
smType: item
name: "Potion of Giant Strength"
category: "Potion"
---

# Potion of Giant Strength
*Potion*

When you drink this potion, your Strength score changes for 1 hour. The type of giant determines the score (see the table below). The potion has no effect on you if your Strength is equal to or greater than that score.

This potion's transparent liquid has floating in it a sliver of light resembling a giant's fingernail.
`,
      "Potion of Growth.md": `---
smType: item
name: "Potion of Growth"
category: "Potion"
rarity: "Uncommon"
---

# Potion of Growth
*Potion Uncommon*

When you drink this potion, you gain the "enlarge" effect of the *Enlarge/Reduce* spell for 10 minutes (no Concentration required).

The red in the potion's liquid continuously expands from a tiny bead to color the clear liquid around it and then contracts. Shaking the bottle fails to interrupt this process.
`,
      "Potion of Heroism.md": `---
smType: item
name: "Potion of Heroism"
category: "Potion"
rarity: "Rare"
---

# Potion of Heroism
*Potion Rare*

When you drink this potion, you gain 10 Temporary Hit Points that last for 1 hour. For the same duration, you are under the effect of the *Bless* spell (no Concentration required).

This potion's blue liquid bubbles and steams as if boiling.
`,
      "Potion of Invisibility.md": `---
smType: item
name: "Potion of Invisibility"
category: "Potion"
rarity: "Rare"
---

# Potion of Invisibility
*Potion Rare*

This potion's container looks empty but feels as though it holds liquid. When you drink the potion, you have the Invisible condition for 1 hour. The effect ends early if you make an attack roll, deal damage, or cast a spell.
`,
      "Potion of Mind Reading.md": `---
smType: item
name: "Potion of Mind Reading"
category: "Potion"
rarity: "Rare"
---

# Potion of Mind Reading
*Potion Rare*

When you drink this potion, you gain the effect of the *Detect Thoughts* spell (save DC 13) for 10 minutes (no Concentration required).

This potion's dense, purple liquid has an ovoid cloud of pink floating in it.
`,
      "Potion of Poison.md": `---
smType: item
name: "Potion of Poison"
category: "Potion"
rarity: "Uncommon"
---

# Potion of Poison
*Potion Uncommon*

This concoction looks, smells, and tastes like a *Potion of Healing* or another beneficial potion. However, it is actually poison masked by illusion magic. *Identify* reveals its true nature.

If you drink this potion, you take 4d6 Poison damage and must succeed on a DC 13 Constitution saving throw or have the Poisoned condition for 1 hour.
`,
      "Potion of Resistance.md": `---
smType: item
name: "Potion of Resistance"
category: "Potion"
rarity: "Uncommon"
---

# Potion of Resistance
*Potion Uncommon*

When you drink this potion, you have Resistance to one type of damage for 1 hour. The GM chooses the type or determines it randomly by rolling on the following table.
`,
      "Potion of Speed.md": `---
smType: item
name: "Potion of Speed"
category: "Potion"
rarity: "Very Rare"
---

# Potion of Speed
*Potion Very Rare*

When you drink this potion, you gain the effect of the *Haste* spell for 1 minute (no Concentration required) without suffering the wave of lethargy that typically occurs when the effect ends.

This potion's yellow fluid is streaked with black and swirls on its own.
`,
      "Potion of Water Breathing.md": `---
smType: item
name: "Potion of Water Breathing"
category: "Potion"
rarity: "Uncommon"
---

# Potion of Water Breathing
*Potion Uncommon*

You can breathe underwater for 24 hours after drinking this potion.

This potion's cloudy green fluid smells of the sea and has a jellyfish-like bubble floating in it.
`,
      "Potions of Healing.md": `---
smType: item
name: "Potions of Healing"
category: "Potion"
---

# Potions of Healing
*Potion*

You regain Hit Points when you drink this potion. The number of Hit Points depends on the potion's rarity, as shown in the table below.

Whatever its potency, the potion's red liquid glimmers when agitated.
`,
      "Ring of Animal Influence.md": `---
smType: item
name: "Ring of Animal Influence"
category: "Ring"
rarity: "Rare"
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Ring of Animal Influence
*Ring Rare*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This ring has 3 charges, and it regains 1d3 expended charges daily at dawn. While wearing the ring, you can expend 1 charge to cast one of the following spells (save DC 13) from it:

- *Animal Friendship*

- *Fear* (affects Beasts only)

- *Speak with Animals*
`,
      "Ring of Djinni Summoning.md": `---
smType: item
name: "Ring of Djinni Summoning"
category: "Ring"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
---

# Ring of Djinni Summoning
*Ring (Requires Attunement) Legendary (Requires Attunement)*

While wearing this ring, you can take a Magic action to summon a particular **Djinni** from the Elemental Plane of Air. The djinni appears in an unoccupied space you choose within 120 feet of yourself. It remains as long as you maintain Concentration, to a maximum of 1 hour, or until it drops to 0 Hit Points.

While summoned, the djinni is Friendly to you and your allies, and it obeys your commands. If you fail to command it, the djinni defends itself against attackers but takes no other actions.

After the djinni departs, it can't be summoned again for 24 hours, and the ring becomes nonmagical if the djinni dies.

*Rings of Djinni Summoning* are often created by the djinn they summon and given to mortals as gifts of friendship or tokens of esteem.
`,
      "Ring of Elemental Command.md": `---
smType: item
name: "Ring of Elemental Command"
category: "Ring"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
max_charges: 5
recharge_formula: "1d4 + 1"
recharge_time: "Dawn"
resistances: ["Lightning", "Acid"]
---

# Ring of Elemental Command
*Ring (Requires Attunement) Legendary (Requires Attunement)*

## Charges

This item has 5 charges.
regains 1d4 + 1 charges at Dawn.

- Resistances: Lightning, Acid

Each *Ring of Elemental Command* is linked to one of the four Elemental Planes. The GM chooses or randomly determines the linked plane. For example, a *Ring of Elemental Command* (air) is linked to the Elemental Plane of Air.

Every *Ring of Elemental Command* has the following two properties:
`,
      "Ring of Evasion.md": `---
smType: item
name: "Ring of Evasion"
category: "Ring"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Ring of Evasion
*Ring (Requires Attunement) Rare (Requires Attunement)*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This ring has 3 charges, and it regains 1d3 expended charges daily at dawn. When you fail a Dexterity saving throw while wearing the ring, you can take a Reaction to expend 1 charge to succeed on that save instead.
`,
      "Ring of Feather Falling.md": `---
smType: item
name: "Ring of Feather Falling"
category: "Ring"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Ring of Feather Falling
*Ring (Requires Attunement) Rare (Requires Attunement)*

When you fall while wearing this ring, you descend 60 feet per round and take no damage from falling.
`,
      "Ring of Free Action.md": `---
smType: item
name: "Ring of Free Action"
category: "Ring"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Ring of Free Action
*Ring (Requires Attunement) Rare (Requires Attunement)*

While you wear this ring, Difficult Terrain doesn't cost you extra movement. In addition, magic can neither reduce any of your Speeds nor cause you to have the Paralyzed or Restrained condition.
`,
      "Ring of Invisibility.md": `---
smType: item
name: "Ring of Invisibility"
category: "Ring"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
---

# Ring of Invisibility
*Ring (Requires Attunement) Legendary (Requires Attunement)*

While wearing this ring, you can take a Magic action to give yourself the Invisible condition. You remain Invisible until the ring is removed or until you take a Bonus Action to become visible again.
`,
      "Ring of Jumping.md": `---
smType: item
name: "Ring of Jumping"
category: "Ring"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Ring of Jumping
*Ring (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this ring, you can cast *Jump* from it, but can target only yourself when you do so.
`,
      "Ring of Mind Shielding.md": `---
smType: item
name: "Ring of Mind Shielding"
category: "Ring"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Ring of Mind Shielding
*Ring (Requires Attunement) Uncommon (Requires Attunement)*

While wearing this ring, you are immune to magic that allows other creatures to read your thoughts, determine whether you are lying, know your alignment, or know your creature type. Creatures can telepathically communicate with you only if you allow it.

You can take a Magic action to cause the ring to become imperceptible until you take another Magic action to make it perceptible, until you remove the ring, or until you die.

If you die while wearing the ring, your soul enters it, unless it already houses a soul. You can remain in the ring or depart for the afterlife. As long as your soul is in the ring, you can telepathically communicate with any creature wearing it. A wearer can't prevent this telepathic communication.
`,
      "Ring of Protection.md": `---
smType: item
name: "Ring of Protection"
category: "Ring"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Ring of Protection
*Ring (Requires Attunement) Rare (Requires Attunement)*

You gain a +1 bonus to Armor Class and saving throws while wearing this ring.
`,
      "Ring of Regeneration.md": `---
smType: item
name: "Ring of Regeneration"
category: "Ring"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
---

# Ring of Regeneration
*Ring (Requires Attunement) Very Rare (Requires Attunement)*

While wearing this ring, you regain 1d6 Hit Points every 10 minutes if you have at least 1 Hit Point. If you lose a body part, the ring causes the missing part to regrow and return to full functionality after 1d6 + 1 days if you have at least 1 Hit Point the whole time.
`,
      "Ring of Resistance.md": `---
smType: item
name: "Ring of Resistance"
category: "Ring"
rarity: "Rare"
resistances: ["one"]
---

# Ring of Resistance
*Ring Rare*

- Resistances: one

You have Resistance to one damage type while wearing this ring. The gemstone in the ring indicates the type, which the GM chooses or determines randomly by rolling on the following table.
`,
      "Ring of Shooting Stars.md": `---
smType: item
name: "Ring of Shooting Stars"
category: "Ring"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
max_charges: 6
recharge_formula: "1d6"
recharge_time: "Dawn"
---

# Ring of Shooting Stars
*Ring (Requires Attunement) Very Rare (Requires Attunement)*

## Charges

This item has 6 charges.
regains 1d6 charges at Dawn.

You can cast *Dancing Lights* or *Light* from the ring.

The ring has 6 charges and regains 1d6 expended charges daily at dawn. You can expend its charges to use the properties below.
`,
      "Ring of Spell Storing.md": `---
smType: item
name: "Ring of Spell Storing"
category: "Ring"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Ring of Spell Storing
*Ring (Requires Attunement) Rare (Requires Attunement)*

This ring stores spells cast into it, holding them until the attuned wearer uses them. The ring can store up to 5 levels worth of spells at a time. When found, it contains 1d6 \u2212 1 levels of stored spells chosen by the GM.

Any creature can cast a spell of level 1 through 5 into the ring by touching the ring as the spell is cast. The spell has no effect other than to be stored in the ring. If the ring can't hold the spell, the spell is expended without effect. The level of the slot used to cast the spell determines how much space it uses.

While wearing this ring, you can cast any spell stored in it. The spell uses the slot level, spell save DC, spell attack bonus, and spellcasting ability of the original caster but is otherwise treated as if you cast the spell. The spell cast from the ring is no longer stored in it, freeing up space.
`,
      "Ring of Spell Turning.md": `---
smType: item
name: "Ring of Spell Turning"
category: "Ring"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
---

# Ring of Spell Turning
*Ring (Requires Attunement) Legendary (Requires Attunement)*

While wearing this ring, you have Advantage on saving throws against spells. If you succeed on the save for a spell of level 7 or lower, the spell has no effect on you. If that spell targeted only you and didn't create an area of effect, you can take a Reaction to deflect the spell back at the spell's caster; the caster must make a saving throw against the spell using their own spell save DC.
`,
      "Ring of Swimming.md": `---
smType: item
name: "Ring of Swimming"
category: "Ring"
rarity: "Uncommon"
---

# Ring of Swimming
*Ring Uncommon*

You have a Swim Speed of 40 feet while wearing this ring.
`,
      "Ring of Telekinesis.md": `---
smType: item
name: "Ring of Telekinesis"
---

# Ring of Telekinesis
`,
      "Ring of Three Wishes.md": `---
smType: item
name: "Ring of Three Wishes"
category: "Ring"
rarity: "Legendary"
---

# Ring of Three Wishes
*Ring Legendary*

While wearing this ring, you can expend 1 of its 3 charges to cast *Wish* from it. The ring becomes nonmagical when you use the last charge.
`,
      "Ring of Warmth.md": `---
smType: item
name: "Ring of Warmth"
category: "Ring"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Ring of Warmth
*Ring (Requires Attunement) Uncommon (Requires Attunement)*

If you take Cold damage while wearing this ring, the ring reduces the damage you take by 2d8.

In addition, while wearing this ring, you and everything you wear and carry are unharmed by temperatures of 0 degrees Fahrenheit or lower.
`,
      "Ring of Water Walking.md": `---
smType: item
name: "Ring of Water Walking"
category: "Ring"
rarity: "Uncommon"
---

# Ring of Water Walking
*Ring Uncommon*

While wearing this ring, you cast *Water Walk* from it, targeting only yourself.
`,
      "Ring of X-ray Vision.md": `---
smType: item
name: "Ring of X-ray Vision"
category: "Ring"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Ring of X-ray Vision
*Ring (Requires Attunement) Rare (Requires Attunement)*

While wearing this ring, you can take a Magic action to gain X-ray vision with a range of 30 feet for 1 minute. To you, solid objects within that radius appear transparent and don't prevent light from passing through them. The vision can penetrate 1 foot of stone, 1 inch of common metal, or up to 3 feet of wood or dirt. Thicker substances or a thin sheet of lead block the vision.

Whenever you use the ring again before taking a Long Rest, you must succeed on a DC 15 Constitution saving throw or gain 1 Exhaustion level.
`,
      "Ring of the Ram.md": `---
smType: item
name: "Ring of the Ram"
category: "Ring"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Ring of the Ram
*Ring (Requires Attunement) Rare (Requires Attunement)*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This ring has 3 charges and regains 1d3 expended charges daily at dawn. While wearing the ring, you can take a Magic action to expend 1 to 3 charges to make a ranged spell attack against one creature you can see within 60 feet of yourself. The ring produces a spectral ram's head and makes its attack roll with a +7 bonus. On a hit, for each charge you spend, the target takes 2d10 Force damage and is pushed 5 feet away from you.

Alternatively, you can expend 1 to 3 of the ring's charges as a Magic action to try to break a nonmagical object you can see within 60 feet of yourself that isn't being worn or carried. The ring makes a Strength check with a +5 bonus for each charge you spend.
`,
      "Robe of Eyes.md": `---
smType: item
name: "Robe of Eyes"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Robe of Eyes
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

This robe is adorned with eyelike patterns. While you wear the robe, you gain the following benefits:

**All-Around Vision.** The robe gives you Advantage on Wisdom (Perception) checks that rely on sight.

**Special Senses.** You have Darkvision and Truesight, both with a range of 120 feet.
`,
      "Robe of Scintillating Colors.md": `---
smType: item
name: "Robe of Scintillating Colors"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Robe of Scintillating Colors
*Wondrous (Requires Attunement) Very Rare (Requires Attunement)*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This robe has 3 charges, and it regains 1d3 expended charges daily at dawn. While you wear it, you can take a Magic action and expend 1 charge to cause the garment to display a shifting pattern of dazzling hues until the end of your next turn. During this time, the robe sheds Bright Light in a 30-foot radius and Dim Light for an additional 30 feet, and creatures that can see you have Disadvantage on attack rolls against you. Any creature in the Bright Light that can see you when the robe's power is activated must succeed on a DC 15 Wisdom saving throw or have the Stunned condition until the effect ends.
`,
      "Robe of Stars.md": `---
smType: item
name: "Robe of Stars"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
---

# Robe of Stars
*Wondrous (Requires Attunement) Very Rare (Requires Attunement)*

This black or dark-blue robe is embroidered with small white or silver stars. You gain a +1 bonus to saving throws while you wear it.

Six stars, located on the robe's upper-front portion, are particularly large. While wearing this robe, you can take a Magic action to remove one of the stars and expend it to cast the level 5 version of *Magic Missile*. Daily at dusk, 1d6 removed stars reappear on the robe.

While you wear the robe, you can take a Magic action to enter the Astral Plane along with everything you are wearing and carrying. You remain there until you take a Magic action to return to the plane you were on. You reappear in the last space you occupied or, if that space is occupied, the nearest unoccupied space.
`,
      "Robe of Useful Items.md": `---
smType: item
name: "Robe of Useful Items"
category: "Wondrous"
rarity: "Uncommon"
---

# Robe of Useful Items
*Wondrous Uncommon*

This robe has cloth patches of various shapes and colors covering it. While wearing the robe, you can take a Magic action to detach one of the patches, causing it to become the object or creature it represents. Once the last patch is removed, the robe becomes an ordinary garment.

The robe has two of each of the following patches:

- Bullseye Lantern (filled and lit)

- Dagger

- Mirror

- Pole

- Rope (coiled)

- Sack

In addition, the robe has 4d4 other patches. The GM chooses the patches or determines them randomly by rolling on the following table.
`,
      "Robe of the Archmagi.md": `---
smType: item
name: "Robe of the Archmagi"
category: "Wondrous"
type: "Requires Attunement by a Sorcerer, Warlock, or Wizard"
rarity: "Legendary"
attunement: true
attunement_req: "by a Sorcerer, Warlock, or Wizard"
---

# Robe of the Archmagi
*Wondrous (Requires Attunement by a Sorcerer, Warlock, or Wizard) Legendary (Requires Attunement by a Sorcerer, Warlock, or Wizard)*

This elegant garment is made from exquisite cloth and adorned with runes.

You gain these benefits while wearing the robe. *Armor.* If you aren't wearing armor, your base

Armor Class is 15 plus your Dexterity modifier. *Magic Resistance.* You have Advantage on saving throws against spells and other magical effects. *War Mage.* Your spell save DC and spell attack bonus each increase by 2.
`,
      "Rod of Absorption.md": `---
smType: item
name: "Rod of Absorption"
category: "Rod"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
---

# Rod of Absorption
*Rod (Requires Attunement) Very Rare (Requires Attunement)*

While holding this rod, you can take a Reaction to absorb a spell that is targeting only you and doesn't create an area of effect. The absorbed spell's effect is canceled, and the spell's energy\u2014not the spell itself\u2014is stored in the rod. The energy has the same level as the spell when it was cast. A canceled spell dissipates with no effect, and any resources used to cast it are wasted. The rod can absorb and store up to 50 levels of energy over the course of its existence. Once the rod absorbs 50 levels of energy, it can't absorb more. If you are targeted by a spell that the rod can't store, the rod has no effect on that spell.

When you become attuned to the rod, you know how many levels of energy the rod has absorbed over the course of its existence and how many levels of spell energy it currently has stored.

If you are a spellcaster holding the rod, you can convert energy stored in it into spell slots to cast spells you have prepared or know. You can create spell slots only of a level equal to or lower than your own spell slots, up to a maximum of level 5. You use the stored levels in place of your slots but otherwise cast the spell as normal. For example, you can use 3 levels stored in the rod as a level 3 spell slot.

A newly found rod typically has 1d10 levels of spell energy stored in it. A rod that can no longer absorb spell energy and has no energy remaining becomes nonmagical.
`,
      "Rod of Alertness.md": `---
smType: item
name: "Rod of Alertness"
category: "Rod"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
---

# Rod of Alertness
*Rod (Requires Attunement) Very Rare (Requires Attunement)*

This rod has the following properties.
`,
      "Rod of Lordly Might.md": `---
smType: item
name: "Rod of Lordly Might"
category: "Rod"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
---

# Rod of Lordly Might
*Rod (Requires Attunement) Legendary (Requires Attunement)*

This rod has a flanged head, and it functions as a magic Mace that grants a +3 bonus to attack rolls and damage rolls made with it. The rod has properties associated with six different buttons that are set in a row along the haft. It has three other properties as well, detailed below.
`,
      "Rod of Rulership.md": `---
smType: item
name: "Rod of Rulership"
category: "Rod"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Rod of Rulership
*Rod (Requires Attunement) Rare (Requires Attunement)*

You can take a Magic action to present the rod and command obedience from each creature of your choice that you can see within 120 feet of yourself. Each target must succeed on a DC 15 Wisdom saving throw or have the Charmed condition for 8 hours. While Charmed in this way, the creature regards you as its trusted leader. If harmed by you or your allies or commanded to do something contrary to its nature, a target ceases to be Charmed in this way. Once used, this property can't be used again until the next dawn.
`,
      "Rod of Security.md": `---
smType: item
name: "Rod of Security"
category: "Rod"
rarity: "Very Rare"
---

# Rod of Security
*Rod Very Rare*

While holding this rod, you can take a Magic action to activate it. The rod then instantly transports you and up to 199 other willing creatures you can see to a demiplane. You choose the form the demiplane takes. It could be a tranquil garden, a cheery tavern, an immense palace, a tropical island, a fantastic carnival, or whatever else you can imagine. Regardless of its nature, the demiplane contains enough water and food to sustain its visitors, and the demiplane's environment can't harm its occupants. Everything else that can be interacted with there can exist only there. For example, a flower picked from a garden there disappears if it is taken outside the demiplane.

For each hour spent in the demiplane, a visitor regains Hit Points as if it had spent 1 Hit Point Die. Also, creatures don't age while there, although time passes normally. Visitors can remain there for up to 200 days divided by the number of creatures present (round down).

When the time runs out or you take a Magic action to end the effect, all visitors reappear in the location they occupied when you activated the rod or an unoccupied space nearest that location. Once used, this property can't be used again until 10 days have passed.
`,
      "Rope of Climbing.md": `---
smType: item
name: "Rope of Climbing"
category: "Wondrous"
rarity: "Uncommon"
---

# Rope of Climbing
*Wondrous Uncommon*

This 60-foot length of rope can hold up to 3,000 pounds. While holding one end of the rope, you can take a Magic action to command the other end of the rope to animate and move toward a destination you choose, up to the rope's length away from you. That end moves 10 feet on your turn when you first command it and 10 feet at the start of each of your subsequent turns until reaching its destination or until you tell it to stop. You can also tell the rope to fasten itself securely to an object or to unfasten itself, to knot or unknot itself, or to coil itself for carrying.

If you tell the rope to knot, large knots appear at 1-foot intervals along the rope. While knotted, the rope shortens to a 50-foot length and grants Advantage on ability checks made to climb using the rope.

The rope has AC 20, HP 20, and Immunity to Poison and Psychic damage. It regains 1 Hit Point every 5 minutes as long as it has at least 1 Hit Point. If the rope drops to 0 Hit Points, it is destroyed.
`,
      "Rope of Entanglement.md": `---
smType: item
name: "Rope of Entanglement"
category: "Wondrous"
rarity: "Rare"
---

# Rope of Entanglement
*Wondrous Rare*

This rope is 30 feet long. While holding one end of the rope, you can take a Magic action to command the other end to dart forward and entangle one creature you can see within 20 feet of yourself. The target must succeed on a DC 15 Dexterity saving throw or have the Restrained condition. You can release the target by letting go of your end of the rope (causing the rope to coil up in the target's space) or by using a Bonus Action to repeat the command (causing the rope to coil up in your hand).

A target Restrained by the rope can take an action to make its choice of a DC 15 Strength (Athletics) or Dexterity (Acrobatics) check. On a successful check, the target is no longer Restrained by the rope. If you're still holding onto the rope when a target escapes from it, you can take a Reaction to command the rope to coil up in your hand; otherwise, the rope coils up in the target's space.

The rope has AC 20, HP 20, and Immunity to Poison and Psychic damage. It regains 1 Hit Point every 5 minutes as long as it has at least 1 Hit Point. If the rope drops to 0 Hit Points, it is destroyed.
`,
      "Scarab of Protection.md": `---
smType: item
name: "Scarab of Protection"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
max_charges: 12
---

# Scarab of Protection
*Wondrous (Requires Attunement) Legendary (Requires Attunement)*

## Charges

This item has 12 charges.

This beetle-shaped medallion provides three benefits while it is on your person.
`,
      "Scimitar of Speed.md": `---
smType: item
name: "Scimitar of Speed"
category: "Weapon"
type: "Scimitar"
rarity: "Very Rare"
attunement: true
---

# Scimitar of Speed
*Weapon (Scimitar) Very Rare (Requires Attunement)*

You gain a +2 bonus to attack rolls and damage rolls made with this magic weapon. In addition, you can make one attack with it as a Bonus Action on each of your turns.
`,
      "Shield of Missile Attraction.md": `---
smType: item
name: "Shield of Missile Attraction"
category: "Armor"
type: "Shield"
rarity: "Rare"
attunement: true
---

# Shield of Missile Attraction
*Armor (Shield) Rare (Requires Attunement)*

While holding this Shield, you have Resistance to damage from attacks made with Ranged weapons.
`,
      "Shield, +1, +2, or +3.md": `---
smType: item
name: "Shield, +1, +2, or +3"
category: "Armor"
type: "Shield"
rarity: "Uncommon"
---

# Shield, +1, +2, or +3
*Armor (Shield) Uncommon*

While holding this Shield, you have a bonus to Armor Class determined by the Shield's rarity, in addition to the Shield's normal bonus to AC.
`,
      "Slippers of Spider Climbing.md": `---
smType: item
name: "Slippers of Spider Climbing"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Slippers of Spider Climbing
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While you wear these light shoes, you can move up, down, and across vertical surfaces and along ceilings, while leaving your hands free. You have a Climb Speed equal to your Speed. However, the slippers don't allow you to move this way on a slippery surface, such as one covered by ice or oil.
`,
      "Sovereign Glue.md": `---
smType: item
name: "Sovereign Glue"
category: "Wondrous"
rarity: "Legendary"
---

# Sovereign Glue
*Wondrous Legendary*

This viscous, milky-white substance can form a permanent adhesive bond between any two objects. It must be stored in a jar or flask that has been coated inside with *Oil of Slipperiness*. When found, a container contains 1d6 + 1 ounces.

One ounce of the glue can cover a 1-foot square surface. Applying an ounce of *Sovereign Glue* takes a Utilize action, and the applied glue takes 1 minute to set. Once it has done so, the bond it creates can be broken only by the application of *Universal Solvent* or *Oil of Etherealness*, or with a *Wish* spell.
`,
      "Spell Scroll.md": `---
smType: item
name: "Spell Scroll"
category: "Scroll"
---

# Spell Scroll
*Scroll*

A *Spell Scroll* bears the words of a single spell, written in a mystical cipher. If the spell is on your spell list, you can read the scroll and cast its spell without Material components. Otherwise, the scroll is unintelligible. Casting the spell by reading the scroll requires the spell's normal casting time. Once the spell is cast, the scroll crumbles to dust. If the casting is interrupted, the scroll isn't lost.

If the spell is on your spell list but of a higher level than you can normally cast, you make an ability check using your spellcasting ability to determine whether you cast the spell. The DC equals 10 plus the spell's level. On a failed check, the spell disappears from the scroll with no other effect.

The level of the spell on the scroll determines the spell's saving throw DC and attack bonus, as well as the scroll's rarity, as shown in the following table.
`,
      "Spellguard Shield.md": `---
smType: item
name: "Spellguard Shield"
category: "Armor"
type: "Shield"
rarity: "Very Rare"
attunement: true
---

# Spellguard Shield
*Armor (Shield) Very Rare (Requires Attunement)*

While holding this Shield, you have Advantage on saving throws against spells and other magical effects, and spell attack rolls have Disadvantage against you.
`,
      "Sphere of Annihilation.md": `---
smType: item
name: "Sphere of Annihilation"
category: "Wondrous"
rarity: "Legendary"
---

# Sphere of Annihilation
*Wondrous Legendary*

This 2-foot-diameter black sphere is a hole in the multiverse, hovering in space and stabilized by a magical field surrounding it.

The sphere obliterates all matter it passes through and all matter that passes through it. Artifacts are the exception. Unless an Artifact is susceptible to damage from a *Sphere of Annihilation*, it passes through the sphere unscathed. Anything else that touches the sphere but isn't wholly engulfed and obliterated by it takes 8d10 Force damage.
`,
      "Staff of Charming.md": `---
smType: item
name: "Staff of Charming"
category: "Staff"
type: "Requires Attunement by a Bard, Cleric, Druid, Sorcerer, Warlock, or Wizard"
rarity: "Rare"
attunement: true
attunement_req: "by a Bard, Cleric, Druid, Sorcerer, Warlock, or Wizard"
max_charges: 10
recharge_formula: "1d8 + 2"
recharge_time: "Dawn"
destruction_risk: "On 1, the staff crumbles to dust and is destroyed"
---

# Staff of Charming
*Staff (Requires Attunement by a Bard, Cleric, Druid, Sorcerer, Warlock, or Wizard) Rare (Requires Attunement by a Bard, Cleric, Druid, Sorcerer, Warlock, or Wizard)*

## Charges

This item has 10 charges.
regains 1d8 + 2 charges at Dawn.
On 1, the staff crumbles to dust and is destroyed

This staff has 10 charges. While holding the staff, you can use any of its properties:

**Cast Spell.** You can expend 1 of the staff's charges to cast *Charm Person*, *Command*, or *Comprehend Languages* from it using your spell save DC.

**Reflect Enchantment.*** If you succeed on a saving throw against an Enchantment spell that targets only you, you can take a Reaction to expend 1 charge from the staff and turn the spell back on its caster as if you had cast the spell.

**Resist Enchantment.** If you fail a saving throw against an Enchantment spell that targets only you, you can turn your failed save into a successful one. You can't use this property of the staff again until the next dawn.

**Regaining Charges.** The staff regains 1d8 + 2 expended charges daily at dawn. If you expend the last charge, roll 1d20. On a 1, the staff crumbles to dust and is destroyed.
`,
      "Staff of Fire.md": `---
smType: item
name: "Staff of Fire"
category: "Staff"
type: "Requires Attunement by a Druid, Sorcerer, Warlock, or Wizard"
rarity: "Very Rare"
attunement: true
attunement_req: "by a Druid, Sorcerer, Warlock, or Wizard"
max_charges: 10
recharge_formula: "1d6 + 4"
recharge_time: "Dawn"
destruction_risk: "On 1, the staff crumbles into cinders and is destroyed"
resistances: ["Fire"]
---

# Staff of Fire
*Staff (Requires Attunement by a Druid, Sorcerer, Warlock, or Wizard) Very Rare (Requires Attunement by a Druid, Sorcerer, Warlock, or Wizard)*

## Charges

This item has 10 charges.
regains 1d6 + 4 charges at Dawn.
On 1, the staff crumbles into cinders and is destroyed

- Resistances: Fire

You have Resistance to Fire damage while you hold this staff.
`,
      "Staff of Frost.md": `---
smType: item
name: "Staff of Frost"
category: "Staff"
type: "Requires Attunement by a Druid, Sorcerer, Warlock, or Wizard"
rarity: "Very Rare"
attunement: true
attunement_req: "by a Druid, Sorcerer, Warlock, or Wizard"
max_charges: 10
recharge_formula: "1d6 + 4"
recharge_time: "Dawn"
destruction_risk: "On 1, the staff turns to water and is destroyed"
resistances: ["Cold"]
---

# Staff of Frost
*Staff (Requires Attunement by a Druid, Sorcerer, Warlock, or Wizard) Very Rare (Requires Attunement by a Druid, Sorcerer, Warlock, or Wizard)*

## Charges

This item has 10 charges.
regains 1d6 + 4 charges at Dawn.
On 1, the staff turns to water and is destroyed

- Resistances: Cold

You have Resistance to Cold damage while you hold this staff.
`,
      "Staff of Healing.md": `---
smType: item
name: "Staff of Healing"
category: "Staff"
type: "Requires Attunement by a Bard, Cleric, or Druid"
rarity: "Rare"
attunement: true
attunement_req: "by a Bard, Cleric, or Druid"
max_charges: 10
recharge_formula: "1d6 + 4"
recharge_time: "Dawn"
destruction_risk: "On 1, the staff vanishes in a flash of light, lost forever"
---

# Staff of Healing
*Staff (Requires Attunement by a Bard, Cleric, or Druid) Rare (Requires Attunement by a Bard, Cleric, or Druid)*

## Charges

This item has 10 charges.
regains 1d6 + 4 charges at Dawn.
On 1, the staff vanishes in a flash of light, lost forever

This staff has 10 charges. While holding the staff, you can cast one of the spells on the following table from it, using your spellcasting ability modifier. The table indicates how many charges you must expend to cast the spell.
`,
      "Staff of Power.md": `---
smType: item
name: "Staff of Power"
category: "Staff"
type: "Requires Attunement by a Sorcerer, Warlock, or Wizard"
rarity: "Very Rare"
attunement: true
attunement_req: "by a Sorcerer, Warlock, or Wizard"
max_charges: 20
recharge_formula: "2d8 + 4"
recharge_time: "Dawn"
destruction_risk: "On 1, the staff retains its +2 bonus to attack rolls and damage rolls but loses all other properties"
---

# Staff of Power
*Staff (Requires Attunement by a Sorcerer, Warlock, or Wizard) Very Rare (Requires Attunement by a Sorcerer, Warlock, or Wizard)*

## Charges

This item has 20 charges.
regains 2d8 + 4 charges at Dawn.
On 1, the staff retains its +2 bonus to attack rolls and damage rolls but loses all other properties

This staff has 20 charges and can be wielded as a magic Quarterstaff that grants a +2 bonus to attack rolls and damage rolls made with it. While holding it, you gain a +2 bonus to Armor Class, saving throws, and spell attack rolls.
`,
      "Staff of Striking.md": `---
smType: item
name: "Staff of Striking"
category: "Staff"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
max_charges: 10
recharge_formula: "1d6 + 4"
recharge_time: "Dawn"
destruction_risk: "On 1, the staff becomes a nonmagical Quarterstaff"
---

# Staff of Striking
*Staff (Requires Attunement) Very Rare (Requires Attunement)*

## Charges

This item has 10 charges.
regains 1d6 + 4 charges at Dawn.
On 1, the staff becomes a nonmagical Quarterstaff

This staff can be wielded as a magic Quarterstaff that grants a +3 bonus to attack rolls and damage rolls made with it.

The staff has 10 charges. When you hit with a melee attack using it, you can expend up to 3 charges. For each charge you expend, the target takes an extra 1d6 Force damage.
`,
      "Staff of Swarming Insects.md": `---
smType: item
name: "Staff of Swarming Insects"
category: "Staff"
type: "Requires Attunement by a Bard, Cleric, Druid, Sorcerer, Warlock, or Wizard"
rarity: "Rare"
attunement: true
attunement_req: "by a Bard, Cleric, Druid, Sorcerer, Warlock, or Wizard"
max_charges: 10
recharge_formula: "1d6 + 4"
recharge_time: "Dawn"
destruction_risk: "On 1, a swarm of insects consumes and destroys the staff, then disperses"
---

# Staff of Swarming Insects
*Staff (Requires Attunement by a Bard, Cleric, Druid, Sorcerer, Warlock, or Wizard) Rare (Requires Attunement by a Bard, Cleric, Druid, Sorcerer, Warlock, or Wizard)*

## Charges

This item has 10 charges.
regains 1d6 + 4 charges at Dawn.
On 1, a swarm of insects consumes and destroys the staff, then disperses

This staff has 10 charges.
`,
      "Staff of Thunder and Lightning.md": `---
smType: item
name: "Staff of Thunder and Lightning"
category: "Staff"
type: "Requires Attunement"
rarity: "Very Rare"
attunement: true
---

# Staff of Thunder and Lightning
*Staff (Requires Attunement) Very Rare (Requires Attunement)*

This staff can be wielded as a magic Quarterstaff that grants a +2 bonus to attack rolls and damage rolls made with it. It also has the following additional properties. Once one of these properties is used, it can't be used again until the next dawn.
`,
      "Staff of Withering.md": `---
smType: item
name: "Staff of Withering"
category: "Staff"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Staff of Withering
*Staff (Requires Attunement) Rare (Requires Attunement)*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This staff has 3 charges and regains 1d3 expended charges daily at dawn.

The staff can be wielded as a magic Quarterstaff. On a hit, it deals damage as a normal Quarterstaff, and you can expend 1 charge to deal an extra 2d10 Necrotic damage to the target and force it to make a DC 15 Constitution saving throw. On a failed save, the target has Disadvantage for 1 hour on any ability check or saving throw that uses Strength or Constitution.
`,
      "Staff of the Magi.md": `---
smType: item
name: "Staff of the Magi"
category: "Staff"
type: "Requires Attunement by a Sorcerer, Warlock, or Wizard"
rarity: "Legendary"
attunement: true
attunement_req: "by a Sorcerer, Warlock, or Wizard"
max_charges: 50
recharge_formula: "4d6 + 2"
recharge_time: "Dawn"
---

# Staff of the Magi
*Staff (Requires Attunement by a Sorcerer, Warlock, or Wizard) Legendary (Requires Attunement by a Sorcerer, Warlock, or Wizard)*

## Charges

This item has 50 charges.
regains 4d6 + 2 charges at Dawn.

This staff has 50 charges and can be wielded as a magic Quarterstaff that grants a +2 bonus to attack rolls and damage rolls made with it. While you hold it, you gain a +2 bonus to spell attack rolls.
`,
      "Staff of the Python.md": `---
smType: item
name: "Staff of the Python"
category: "Staff"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Staff of the Python
*Staff (Requires Attunement) Uncommon (Requires Attunement)*

As a Magic action, you can throw this staff so that it lands in an unoccupied space within 10 feet of you, causing the staff to become a **Giant Constrictor Snake** in that space. The snake is under your control and shares your Initiative count, taking its turn immediately after yours.

On your turn, you can mentally command the snake (no action required) if it is within 60 feet of you and you don't have the Incapacitated condition. You decide what action the snake takes and where it moves during its turn, or you can issue it a general command, such as to attack your enemies or guard a location. Absent commands from you, the snake defends itself.

As a Bonus Action, you can command the snake to revert to staff form in its current space, and you can't use the staff's property again for 1 hour. If the snake is reduced to 0 Hit Points, it dies and reverts to its staff form; the staff then shatters and is destroyed. If the snake reverts to staff form before losing all its Hit Points, it regains all of them.
`,
      "Staff of the Woodlands.md": `---
smType: item
name: "Staff of the Woodlands"
category: "Staff"
type: "Requires Attunement by a Druid"
rarity: "Rare"
attunement: true
attunement_req: "by a Druid"
max_charges: 6
recharge_formula: "1d6"
recharge_time: "Dawn"
destruction_risk: "On 1, the staff loses its properties and becomes a nonmagical Quarterstaff"
---

# Staff of the Woodlands
*Staff (Requires Attunement by a Druid) Rare (Requires Attunement by a Druid)*

## Charges

This item has 6 charges.
regains 1d6 charges at Dawn.
On 1, the staff loses its properties and becomes a nonmagical Quarterstaff

This staff has 6 charges and can be wielded as a magic Quarterstaff that grants a +2 bonus to attack rolls and damage rolls made with it. While holding it, you have a +2 bonus to spell attack rolls.
`,
      "Stone of Controlling Earth Elementals.md": `---
smType: item
name: "Stone of Controlling Earth Elementals"
category: "Wondrous"
rarity: "Rare"
---

# Stone of Controlling Earth Elementals
*Wondrous Rare*

While touching this 5-pound stone to the ground, you can take a Magic action to summon an **Earth Elemental**. The elemental appears in an unoccupied space you choose within 30 feet of yourself, obeys your commands, and takes its turn immediately after you on your Initiative count. The elemental disappears after 1 hour, when it dies, or when you dismiss it as a Bonus Action. The stone can't be used this way again until the next dawn.
`,
      "Stone of Good Luck (Luckstone).md": `---
smType: item
name: "Stone of Good Luck (Luckstone)"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Stone of Good Luck (Luckstone)
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

While this polished agate is on your person, you gain a +1 bonus to ability checks and saving throws.
`,
      "Sun Blade.md": `---
smType: item
name: "Sun Blade"
category: "Weapon"
type: "Longsword"
rarity: "Rare"
attunement: true
---

# Sun Blade
*Weapon (Longsword) Rare (Requires Attunement)*

This item appears to be a sword hilt.
`,
      "Sword of Life Stealing.md": `---
smType: item
name: "Sword of Life Stealing"
category: "Weapon"
type: "Glaive, Greatsword, Longsword, Rapier, Scimitar, or Shortsword"
rarity: "Rare"
attunement: true
---

# Sword of Life Stealing
*Weapon (Glaive, Greatsword, Longsword, Rapier, Scimitar, or Shortsword) Rare (Requires Attunement)*

When you attack a creature with this magic weapon and roll a 20 on the d20 for the attack roll, that target takes an extra 15 Necrotic damage if it isn't a Construct or an Undead, and you gain Temporary Hit Points equal to the amount of Necrotic damage taken.
`,
      "Sword of Sharpness.md": `---
smType: item
name: "Sword of Sharpness"
category: "Weapon"
type: "Glaive, Greatsword, Longsword, or Scimitar"
rarity: "Very Rare"
attunement: true
---

# Sword of Sharpness
*Weapon (Glaive, Greatsword, Longsword, or Scimitar) Very Rare (Requires Attunement)*

When you attack an object with this magic weapon and hit, maximize your weapon damage dice against the target.

When you attack a creature with this weapon and roll a 20 on the d20 for the attack roll, that target takes an extra 14 Slashing damage and gains 1 Exhaustion level.
`,
      "Sword of Wounding.md": `---
smType: item
name: "Sword of Wounding"
category: "Weapon"
type: "Glaive, Greatsword, Longsword, Rapier, Scimitar, or Shortsword"
rarity: "Rare"
attunement: true
---

# Sword of Wounding
*Weapon (Glaive, Greatsword, Longsword, Rapier, Scimitar, or Shortsword) Rare (Requires Attunement)*

When you hit a creature with an attack using this magic weapon, the target takes an extra 2d6 Necrotic damage and must succeed on a DC 15 Constitution saving throw or be unable to regain Hit Points for 1 hour. The target repeats the save at the end of each of its turns, ending the effect on itself on a success.
`,
      "Talisman of Pure Good.md": `---
smType: item
name: "Talisman of Pure Good"
category: "Wondrous"
type: "Requires Attunement by a Cleric or Paladin"
rarity: "Legendary"
attunement: true
attunement_req: "by a Cleric or Paladin"
max_charges: 7
---

# Talisman of Pure Good
*Wondrous (Requires Attunement by a Cleric or Paladin) Legendary (Requires Attunement by a Cleric or Paladin)*

## Charges

This item has 7 charges.

This talisman is a mighty symbol of goodness. A Fiend or an Undead that touches the talisman takes 8d6 Radiant damage and takes the damage again each time it ends its turn holding or carrying the talisman.
`,
      "Talisman of Ultimate Evil.md": `---
smType: item
name: "Talisman of Ultimate Evil"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
max_charges: 6
---

# Talisman of Ultimate Evil
*Wondrous (Requires Attunement) Legendary (Requires Attunement)*

## Charges

This item has 6 charges.

This item symbolizes unrepentant evil. A creature that isn't a Fiend or an Undead that touches the talisman takes 8d6 Necrotic damage and takes the damage again each time it ends its turn holding or carrying the talisman.
`,
      "Talisman of the Sphere.md": `---
smType: item
name: "Talisman of the Sphere"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Legendary"
attunement: true
---

# Talisman of the Sphere
*Wondrous (Requires Attunement) Legendary (Requires Attunement)*

While holding or wearing this talisman, you have Advantage on any Intelligence (Arcana) check you make to control a *Sphere of Annihilation*. In addition, when you start your turn in control of a *Sphere of Annihilation*, you can take a Magic action to move it 10 feet plus a number of additional feet equal to 10 times your Intelligence modifier. This movement doesn't have to be in a straight line.
`,
      "Tome of Clear Thought.md": `---
smType: item
name: "Tome of Clear Thought"
category: "Wondrous"
rarity: "Very Rare"
---

# Tome of Clear Thought
*Wondrous Very Rare*

This book contains memory and logic exercises, and its words are charged with magic. If you spend 48 hours over a period of 6 days or fewer studying the book's contents and practicing its guidelines, your Intelligence increases by 2, to a maximum of 30. The manual then loses its magic but regains it in a century.
`,
      "Tome of Leadership and Influence.md": `---
smType: item
name: "Tome of Leadership and Influence"
category: "Wondrous"
rarity: "Very Rare"
---

# Tome of Leadership and Influence
*Wondrous Very Rare*

This book contains guidelines for influencing and charming others, and its words are charged with magic. If you spend 48 hours over a period of 6 days or fewer studying the book's contents and practicing its guidelines, your Charisma increases by 2, to a maximum of 30. The manual then loses its magic but regains it in a century.
`,
      "Tome of Understanding.md": `---
smType: item
name: "Tome of Understanding"
category: "Wondrous"
rarity: "Very Rare"
---

# Tome of Understanding
*Wondrous Very Rare*

This book contains intuition and insight exercises, and its words are charged with magic. If you spend 48 hours over a period of 6 days or fewer studying the book's contents and practicing its guidelines, your Wisdom increases by 2, to a maximum of 30. The manual then loses its magic, but regains it in a century.
`,
      "Trident of Fish Command.md": `---
smType: item
name: "Trident of Fish Command"
category: "Weapon"
type: "Trident"
rarity: "Uncommon"
attunement: true
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Trident of Fish Command
*Weapon (Trident) Uncommon (Requires Attunement)*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This magic weapon has 3 charges, and it regains 1d3 expended charges daily at dawn. While you carry it, you can expend 1 charge to cast *Dominate Beast* (save DC 15) from it on a Beast that has a Swim Speed.
`,
      "Universal Solvent.md": `---
smType: item
name: "Universal Solvent"
category: "Wondrous"
rarity: "Legendary"
---

# Universal Solvent
*Wondrous Legendary*

This tube holds milky liquid with a strong alcohol smell. When found, a tube contains 1d6 + 1 ounces.

You can take a Utilize action to pour 1 or more ounces of solvent from the tube onto a surface within reach. Each ounce instantly dissolves up to 1 square foot of adhesive it touches, including *Sovereign Glue*.
`,
      "Vicious Weapon.md": `---
smType: item
name: "Vicious Weapon"
category: "Weapon"
type: "Any Simple or Martial"
rarity: "Rare"
---

# Vicious Weapon
*Weapon (Any Simple or Martial) Rare*

This magic weapon deals an extra 2d6 damage to any creature it hits. This extra damage is of the same type as the weapon's normal damage.
`,
      "Vorpal Sword.md": `---
smType: item
name: "Vorpal Sword"
category: "Weapon"
type: "Glaive, Greatsword, Longsword, or Scimitar"
rarity: "Legendary"
attunement: true
resistances: ["Slashing"]
---

# Vorpal Sword
*Weapon (Glaive, Greatsword, Longsword, or Scimitar) Legendary (Requires Attunement)*

- Resistances: Slashing

You gain a +3 bonus to attack rolls and damage rolls made with this magic weapon. In addition, the weapon ignores Resistance to Slashing damage.

When you use this weapon to attack a creature that has at least one head and roll a 20 on the d20 for the attack roll, you cut off one of the creature's heads. The creature dies if it can't survive without the lost head. A creature is immune to this effect if it has Immunity to Slashing damage, if it doesn't have or need a head, or if the GM decides that the creature is too big for its head to be cut off with this weapon. Such a creature instead takes an extra 30 Slashing damage from the hit. If the creature has Legendary Resistance, it can expend one daily use of that trait to avoid losing its head, taking the extra damage instead.
`,
      "Wand of Binding.md": `---
smType: item
name: "Wand of Binding"
category: "Wand"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# Wand of Binding
*Wand (Requires Attunement) Rare (Requires Attunement)*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed

This wand has 7 charges.
`,
      "Wand of Enemy Detection.md": `---
smType: item
name: "Wand of Enemy Detection"
category: "Wand"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# Wand of Enemy Detection
*Wand (Requires Attunement) Rare (Requires Attunement)*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed

This wand has 7 charges. While holding it, you can take a Magic action to expend 1 charge. For 1 minute, you know the direction of the nearest creature Hostile to you within 60 feet, but not its distance from you. The wand can sense the presence of Hostile creatures that are Invisible, ethereal, disguised, or hidden, as well as those in plain sight. The effect ends if you stop holding the wand.
`,
      "Wand of Fear.md": `---
smType: item
name: "Wand of Fear"
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# Wand of Fear

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed
`,
      "Wand of Lightning Bolts.md": `---
smType: item
name: "Wand of Lightning Bolts"
category: "Wand"
type: "Requires Attunement by a Spellcaster"
rarity: "Rare"
attunement: true
attunement_req: "by a Spellcaster"
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# Wand of Lightning Bolts
*Wand (Requires Attunement by a Spellcaster) Rare (Requires Attunement by a Spellcaster)*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed

This wand has 7 charges. While holding it, you can expend no more than 3 charges to cast *Lightning Bolt* (save DC 15) from it. For 1 charge, you cast the level 3 version of the spell. You can increase the spell's level by 1 for each additional charge you expend.
`,
      "Wand of Magic Detection.md": `---
smType: item
name: "Wand of Magic Detection"
category: "Wand"
rarity: "Uncommon"
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Wand of Magic Detection
*Wand Uncommon*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This wand has 3 charges. While holding it, you can expend 1 charge to cast *Detect Magic* from it. The wand regains 1d3 expended charges daily at dawn.
`,
      "Wand of Magic Missiles.md": `---
smType: item
name: "Wand of Magic Missiles"
category: "Wand"
rarity: "Uncommon"
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# Wand of Magic Missiles
*Wand Uncommon*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed

This wand has 7 charges. While holding it, you can expend no more than 3 charges to cast *Magic Missile* from it. For 1 charge, you cast the level 1 version of the spell. You can increase the spell's level by 1 for each additional charge you expend.
`,
      "Wand of Paralysis.md": `---
smType: item
name: "Wand of Paralysis"
category: "Wand"
type: "Requires Attunement by a Spellcaster"
rarity: "Rare"
attunement: true
attunement_req: "by a Spellcaster"
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# Wand of Paralysis
*Wand (Requires Attunement by a Spellcaster) Rare (Requires Attunement by a Spellcaster)*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed

This wand has 7 charges. While holding it, you can take a Magic action to expend 1 charge to cause a thin blue ray to streak from the tip toward a creature you can see within 60 feet of yourself. The target must succeed on a DC 15 Constitution saving throw or have the Paralyzed condition for 1 minute. At the end of each of the target's turns, it repeats the save, ending the effect on itself on a success.
`,
      "Wand of Polymorph.md": `---
smType: item
name: "Wand of Polymorph"
category: "Wand"
type: "Requires Attunement by a Spellcaster"
rarity: "Very Rare"
attunement: true
attunement_req: "by a Spellcaster"
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# Wand of Polymorph
*Wand (Requires Attunement by a Spellcaster) Very Rare (Requires Attunement by a Spellcaster)*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed

This wand has 7 charges. While holding it, you can expend 1 charge to cast *Polymorph* (save DC 15) from it.
`,
      "Wand of Secrets.md": `---
smType: item
name: "Wand of Secrets"
category: "Wand"
rarity: "Uncommon"
max_charges: 3
recharge_formula: "1d3"
recharge_time: "Dawn"
---

# Wand of Secrets
*Wand Uncommon*

## Charges

This item has 3 charges.
regains 1d3 charges at Dawn.

This wand has 3 charges and regains 1d3 expended charges daily at dawn. While holding it, you can take a Magic action to expend 1 charge, and if a secret door or trap is within 60 feet of you, the wand pulses and points at the one nearest to you.
`,
      "Wand of Web.md": `---
smType: item
name: "Wand of Web"
category: "Wand"
type: "Requires Attunement by a Spellcaster"
rarity: "Uncommon"
attunement: true
attunement_req: "by a Spellcaster"
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into ashes and is destroyed"
---

# Wand of Web
*Wand (Requires Attunement by a Spellcaster) Uncommon (Requires Attunement by a Spellcaster)*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into ashes and is destroyed

This wand has 7 charges. While holding it, you can expend 1 charge to cast *Web* (save DC 13) from it.
`,
      "Wand of Wonder.md": `---
smType: item
name: "Wand of Wonder"
category: "Wand"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
max_charges: 7
recharge_formula: "1d6 + 1"
recharge_time: "Dawn"
destruction_risk: "On 1, the wand crumbles into dust and is destroyed"
---

# Wand of Wonder
*Wand (Requires Attunement) Rare (Requires Attunement)*

## Charges

This item has 7 charges.
regains 1d6 + 1 charges at Dawn.
On 1, the wand crumbles into dust and is destroyed

This wand has 7 charges. While holding it, you can take a Magic action to expend 1 charge while choosing a point within 120 feet of yourself. That location becomes the point of origin of a spell or other magical effect determined by rolling on the Wand of Wonder Effects table. Spells cast from the wand have a save DC of 15. If a spell's maximum range is normally less than 120 feet, it becomes 120 feet when cast from the wand. If an effect has multiple possible subjects, the GM determines randomly which among them are affected.
`,
      "Wand of the War Mage, +1, +2, or +3.md": `---
smType: item
name: "Wand of the War Mage, +1, +2, or +3"
category: "Wand"
type: "+1"
rarity: "Uncommon"
attunement: true
attunement_req: "by a Spellcaster"
---

# Wand of the War Mage, +1, +2, or +3
*Wand (+1) Uncommon (Requires Attunement by a Spellcaster)*

While holding this wand, you gain a bonus to spell attack rolls determined by the wand's rarity. In addition, you ignore Half Cover when making a spell attack roll.
`,
      "Weapon of Warning.md": `---
smType: item
name: "Weapon of Warning"
category: "Weapon"
type: "Any Simple or Martial"
rarity: "Uncommon"
attunement: true
---

# Weapon of Warning
*Weapon (Any Simple or Martial) Uncommon (Requires Attunement)*

As long as this weapon is within your reach and you are attuned to it, you and allies within 30 feet of you gain the following benefits.
`,
      "Weapon, +1, +2, or +3.md": `---
smType: item
name: "Weapon, +1, +2, or +3"
category: "Weapon"
type: "Any Simple or Martial"
rarity: "Uncommon"
---

# Weapon, +1, +2, or +3
*Weapon (Any Simple or Martial) Uncommon*

You have a bonus to attack rolls and damage rolls made with this magic weapon. The bonus is determined by the weapon's rarity.
`,
      "Well of Many Worlds.md": `---
smType: item
name: "Well of Many Worlds"
category: "Wondrous"
rarity: "Legendary"
---

# Well of Many Worlds
*Wondrous Legendary*

This fine black cloth, soft as silk, is folded up to the dimensions of a handkerchief. It unfolds into a circular sheet 6 feet in diameter.

You can take a Magic action to unfold the *Well of Many Worlds* and place it on a solid surface, whereupon it forms a two-way, 6-foot-diameter, circular portal to another world or plane of existence. Each time the item opens a portal, the GM decides where it leads. The portal remains open until a creature within 5 feet of it takes a Magic action to close it by taking hold of the edges of the cloth and folding it up.

Once the *Well of Many Worlds* has opened a portal, it can't do so again for 1d8 hours.
`,
      "Wind Fan.md": `---
smType: item
name: "Wind Fan"
category: "Wondrous"
rarity: "Uncommon"
---

# Wind Fan
*Wondrous Uncommon*

While holding this fan, you can cast *Gust of Wind* (save DC 13) from it. Each subsequent time the fan is used before the next dawn, it has a cumulative 20 percent chance of not working; if the fan fails to work, it tears into useless, nonmagical tatters.
`,
      "Winged Boots.md": `---
smType: item
name: "Winged Boots"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Uncommon"
attunement: true
---

# Winged Boots
*Wondrous (Requires Attunement) Uncommon (Requires Attunement)*

These boots have 4 charges and regain 1d4 expended charges daily at dawn. While wearing the boots, you can take a Magic action to expend 1 charge, gaining a Fly Speed of 30 feet for 1 hour. If you are flying when the duration expires, you descend at a rate of 30 feet per round until you land.
`,
      "Wings of Flying.md": `---
smType: item
name: "Wings of Flying"
category: "Wondrous"
type: "Requires Attunement"
rarity: "Rare"
attunement: true
---

# Wings of Flying
*Wondrous (Requires Attunement) Rare (Requires Attunement)*

While wearing this cloak, you can take a Magic action to turn the cloak into a pair of wings on your back. The wings lasts for 1 hour or until you end the effect early as a Magic action. The wings give you a Fly Speed of 60 feet. If you are aloft when the wings disappear, you fall. When the wings disappear, you can't use them again for 1d12 hours.
`
    };
    PRESET_EQUIPMENT = {
      ".md": `---
smType: equipment
name: ""
type: "armor"
armor_category: "Shield"
don_time: "Utilize Action"
doff_time: "Utilize Action"
---

# 
*Shield Armor*

**Time:** Don: Utilize Action, Doff: Utilize Action
`,
      "Acid.md": `---
smType: equipment
name: "Acid"
type: "gear"
cost: "25 GP"
weight: "1 lb."
---

# Acid
*Adventuring Gear*

- **Cost:** 25 GP
- **Weight:** 1 lb.
`,
      "Alchemist's Fire.md": `---
smType: equipment
name: "Alchemist's Fire"
type: "gear"
cost: "50 GP"
weight: "1 lb."
---

# Alchemist's Fire
*Adventuring Gear*

- **Cost:** 50 GP
- **Weight:** 1 lb.
`,
      "Ammunition.md": `---
smType: equipment
name: "Ammunition"
type: "gear"
cost: "Varies"
weight: "Varies"
---

# Ammunition
*Adventuring Gear*

- **Cost:** Varies
- **Weight:** Varies
`,
      "Antitoxin.md": `---
smType: equipment
name: "Antitoxin"
type: "gear"
cost: "50 GP"
weight: "\u2014"
---

# Antitoxin
*Adventuring Gear*

- **Cost:** 50 GP
- **Weight:** \u2014
`,
      "Arcane Focus.md": `---
smType: equipment
name: "Arcane Focus"
type: "gear"
cost: "Varies"
weight: "Varies"
---

# Arcane Focus
*Adventuring Gear*

- **Cost:** Varies
- **Weight:** Varies
`,
      "Backpack.md": `---
smType: equipment
name: "Backpack"
type: "gear"
cost: "2 GP"
weight: "5 lb."
---

# Backpack
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 5 lb.
`,
      "Ball Bearings.md": `---
smType: equipment
name: "Ball Bearings"
type: "gear"
cost: "1 GP"
weight: "2 lb."
---

# Ball Bearings
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 2 lb.
`,
      "Barrel.md": `---
smType: equipment
name: "Barrel"
type: "gear"
cost: "2 GP"
weight: "70 lb."
---

# Barrel
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 70 lb.
`,
      "Basket.md": `---
smType: equipment
name: "Basket"
type: "gear"
cost: "4 SP"
weight: "2 lb."
---

# Basket
*Adventuring Gear*

- **Cost:** 4 SP
- **Weight:** 2 lb.
`,
      "Bedroll.md": `---
smType: equipment
name: "Bedroll"
type: "gear"
cost: "1 GP"
weight: "7 lb."
---

# Bedroll
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 7 lb.
`,
      "Bell.md": `---
smType: equipment
name: "Bell"
type: "gear"
cost: "1 GP"
weight: "\u2014"
---

# Bell
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** \u2014
`,
      "Blanket.md": `---
smType: equipment
name: "Blanket"
type: "gear"
cost: "5 SP"
weight: "3 lb."
---

# Blanket
*Adventuring Gear*

- **Cost:** 5 SP
- **Weight:** 3 lb.
`,
      "Block and Tackle.md": `---
smType: equipment
name: "Block and Tackle"
type: "gear"
cost: "1 GP"
weight: "5 lb."
---

# Block and Tackle
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 5 lb.
`,
      "Book.md": `---
smType: equipment
name: "Book"
type: "gear"
cost: "25 GP"
weight: "5 lb."
---

# Book
*Adventuring Gear*

- **Cost:** 25 GP
- **Weight:** 5 lb.
`,
      "Bottle, Glass.md": `---
smType: equipment
name: "Bottle, Glass"
type: "gear"
cost: "2 GP"
weight: "2 lb."
---

# Bottle, Glass
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 2 lb.
`,
      "Bucket.md": `---
smType: equipment
name: "Bucket"
type: "gear"
cost: "5 CP"
weight: "2 lb."
---

# Bucket
*Adventuring Gear*

- **Cost:** 5 CP
- **Weight:** 2 lb.
`,
      "Burglar's Pack.md": `---
smType: equipment
name: "Burglar's Pack"
type: "gear"
cost: "16 GP"
weight: "42 lb."
---

# Burglar's Pack
*Adventuring Gear*

- **Cost:** 16 GP
- **Weight:** 42 lb.
`,
      "Caltrops.md": `---
smType: equipment
name: "Caltrops"
type: "gear"
cost: "1 GP"
weight: "2 lb."
---

# Caltrops
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 2 lb.
`,
      "Candle.md": `---
smType: equipment
name: "Candle"
type: "gear"
cost: "1 CP"
weight: "\u2014"
---

# Candle
*Adventuring Gear*

- **Cost:** 1 CP
- **Weight:** \u2014
`,
      "Case, Crossbow Bolt.md": `---
smType: equipment
name: "Case, Crossbow Bolt"
type: "gear"
cost: "1 GP"
weight: "1 lb."
---

# Case, Crossbow Bolt
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 1 lb.
`,
      "Case, Map or Scroll.md": `---
smType: equipment
name: "Case, Map or Scroll"
type: "gear"
cost: "1 GP"
weight: "1 lb."
---

# Case, Map or Scroll
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 1 lb.
`,
      "Chain.md": `---
smType: equipment
name: "Chain"
type: "gear"
cost: "5 GP"
weight: "10 lb."
---

# Chain
*Adventuring Gear*

- **Cost:** 5 GP
- **Weight:** 10 lb.
`,
      "Chest.md": `---
smType: equipment
name: "Chest"
type: "gear"
cost: "5 GP"
weight: "25 lb."
---

# Chest
*Adventuring Gear*

- **Cost:** 5 GP
- **Weight:** 25 lb.
`,
      "Climber's Kit.md": `---
smType: equipment
name: "Climber's Kit"
type: "gear"
cost: "25 GP"
weight: "12 lb."
---

# Climber's Kit
*Adventuring Gear*

- **Cost:** 25 GP
- **Weight:** 12 lb.
`,
      "Clothes, Fine.md": `---
smType: equipment
name: "Clothes, Fine"
type: "gear"
cost: "15 GP"
weight: "6 lb."
---

# Clothes, Fine
*Adventuring Gear*

- **Cost:** 15 GP
- **Weight:** 6 lb.
`,
      "Clothes, Traveler's.md": `---
smType: equipment
name: "Clothes, Traveler's"
type: "gear"
cost: "2 GP"
weight: "4 lb."
---

# Clothes, Traveler's
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 4 lb.
`,
      "Component Pouch.md": `---
smType: equipment
name: "Component Pouch"
type: "gear"
cost: "25 GP"
weight: "2 lb."
---

# Component Pouch
*Adventuring Gear*

- **Cost:** 25 GP
- **Weight:** 2 lb.
`,
      "Costume.md": `---
smType: equipment
name: "Costume"
type: "gear"
cost: "5 GP"
weight: "4 lb."
---

# Costume
*Adventuring Gear*

- **Cost:** 5 GP
- **Weight:** 4 lb.
`,
      "Crowbar.md": `---
smType: equipment
name: "Crowbar"
type: "gear"
cost: "2 GP"
weight: "5 lb."
---

# Crowbar
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 5 lb.
`,
      "Diplomat's Pack.md": `---
smType: equipment
name: "Diplomat's Pack"
type: "gear"
cost: "39 GP"
weight: "39 lb."
---

# Diplomat's Pack
*Adventuring Gear*

- **Cost:** 39 GP
- **Weight:** 39 lb.
`,
      "Druidic Focus.md": `---
smType: equipment
name: "Druidic Focus"
type: "gear"
cost: "Varies"
weight: "Varies"
---

# Druidic Focus
*Adventuring Gear*

- **Cost:** Varies
- **Weight:** Varies
`,
      "Dungeoneer's Pack.md": `---
smType: equipment
name: "Dungeoneer's Pack"
type: "gear"
cost: "12 GP"
weight: "55 lb."
---

# Dungeoneer's Pack
*Adventuring Gear*

- **Cost:** 12 GP
- **Weight:** 55 lb.
`,
      "Entertainer's Pack.md": `---
smType: equipment
name: "Entertainer's Pack"
type: "gear"
cost: "40 GP"
weight: "58\xBD lb."
---

# Entertainer's Pack
*Adventuring Gear*

- **Cost:** 40 GP
- **Weight:** 58\xBD lb.
`,
      "Explorer's Pack.md": `---
smType: equipment
name: "Explorer's Pack"
type: "gear"
cost: "10 GP"
weight: "55 lb."
---

# Explorer's Pack
*Adventuring Gear*

- **Cost:** 10 GP
- **Weight:** 55 lb.
`,
      "Flask.md": `---
smType: equipment
name: "Flask"
type: "gear"
cost: "2 CP"
weight: "1 lb."
---

# Flask
*Adventuring Gear*

- **Cost:** 2 CP
- **Weight:** 1 lb.
`,
      "Grappling Hook.md": `---
smType: equipment
name: "Grappling Hook"
type: "gear"
cost: "2 GP"
weight: "4 lb."
---

# Grappling Hook
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 4 lb.
`,
      "Healer's Kit.md": `---
smType: equipment
name: "Healer's Kit"
type: "gear"
cost: "5 GP"
weight: "3 lb."
---

# Healer's Kit
*Adventuring Gear*

- **Cost:** 5 GP
- **Weight:** 3 lb.
`,
      "Holy Symbol.md": `---
smType: equipment
name: "Holy Symbol"
type: "gear"
cost: "Varies"
weight: "Varies"
---

# Holy Symbol
*Adventuring Gear*

- **Cost:** Varies
- **Weight:** Varies
`,
      "Holy Water.md": `---
smType: equipment
name: "Holy Water"
type: "gear"
cost: "25 GP"
weight: "1 lb."
---

# Holy Water
*Adventuring Gear*

- **Cost:** 25 GP
- **Weight:** 1 lb.
`,
      "Hunting Trap.md": `---
smType: equipment
name: "Hunting Trap"
type: "gear"
cost: "5 GP"
weight: "25 lb."
---

# Hunting Trap
*Adventuring Gear*

- **Cost:** 5 GP
- **Weight:** 25 lb.
`,
      "Ink Pen.md": `---
smType: equipment
name: "Ink Pen"
type: "gear"
cost: "2 CP"
weight: "\u2014"
---

# Ink Pen
*Adventuring Gear*

- **Cost:** 2 CP
- **Weight:** \u2014
`,
      "Ink.md": `---
smType: equipment
name: "Ink"
type: "gear"
cost: "10 GP"
weight: "\u2014"
---

# Ink
*Adventuring Gear*

- **Cost:** 10 GP
- **Weight:** \u2014
`,
      "Jug.md": `---
smType: equipment
name: "Jug"
type: "gear"
cost: "2 CP"
weight: "4 lb."
---

# Jug
*Adventuring Gear*

- **Cost:** 2 CP
- **Weight:** 4 lb.
`,
      "Ladder.md": `---
smType: equipment
name: "Ladder"
type: "gear"
cost: "1 SP"
weight: "25 lb."
---

# Ladder
*Adventuring Gear*

- **Cost:** 1 SP
- **Weight:** 25 lb.
`,
      "Lamp.md": `---
smType: equipment
name: "Lamp"
type: "gear"
cost: "5 SP"
weight: "1 lb."
---

# Lamp
*Adventuring Gear*

- **Cost:** 5 SP
- **Weight:** 1 lb.
`,
      "Lantern, Bullseye.md": `---
smType: equipment
name: "Lantern, Bullseye"
type: "gear"
cost: "10 GP"
weight: "2 lb."
---

# Lantern, Bullseye
*Adventuring Gear*

- **Cost:** 10 GP
- **Weight:** 2 lb.
`,
      "Lantern, Hooded.md": `---
smType: equipment
name: "Lantern, Hooded"
type: "gear"
cost: "5 GP"
weight: "2 lb."
---

# Lantern, Hooded
*Adventuring Gear*

- **Cost:** 5 GP
- **Weight:** 2 lb.
`,
      "Lock.md": `---
smType: equipment
name: "Lock"
type: "gear"
cost: "10 GP"
weight: "1 lb."
---

# Lock
*Adventuring Gear*

- **Cost:** 10 GP
- **Weight:** 1 lb.
`,
      "Magnifying Glass.md": `---
smType: equipment
name: "Magnifying Glass"
type: "gear"
cost: "100 GP"
weight: "\u2014"
---

# Magnifying Glass
*Adventuring Gear*

- **Cost:** 100 GP
- **Weight:** \u2014
`,
      "Manacles.md": `---
smType: equipment
name: "Manacles"
type: "gear"
cost: "2 GP"
weight: "6 lb."
---

# Manacles
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 6 lb.
`,
      "Map.md": `---
smType: equipment
name: "Map"
type: "gear"
cost: "1 GP"
weight: "\u2014"
---

# Map
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** \u2014
`,
      "Mirror.md": `---
smType: equipment
name: "Mirror"
type: "gear"
cost: "5 GP"
weight: "1/2 lb."
---

# Mirror
*Adventuring Gear*

- **Cost:** 5 GP
- **Weight:** 1/2 lb.
`,
      "Net.md": `---
smType: equipment
name: "Net"
type: "gear"
cost: "1 GP"
weight: "3 lb."
---

# Net
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 3 lb.
`,
      "Oil.md": `---
smType: equipment
name: "Oil"
type: "gear"
cost: "1 SP"
weight: "1 lb."
---

# Oil
*Adventuring Gear*

- **Cost:** 1 SP
- **Weight:** 1 lb.
`,
      "Paper.md": `---
smType: equipment
name: "Paper"
type: "gear"
cost: "2 SP"
weight: "\u2014"
---

# Paper
*Adventuring Gear*

- **Cost:** 2 SP
- **Weight:** \u2014
`,
      "Parchment.md": `---
smType: equipment
name: "Parchment"
type: "gear"
cost: "1 SP"
weight: "\u2014"
---

# Parchment
*Adventuring Gear*

- **Cost:** 1 SP
- **Weight:** \u2014
`,
      "Perfume.md": `---
smType: equipment
name: "Perfume"
type: "gear"
cost: "5 GP"
weight: "\u2014"
---

# Perfume
*Adventuring Gear*

- **Cost:** 5 GP
- **Weight:** \u2014
`,
      "Poison, Basic.md": `---
smType: equipment
name: "Poison, Basic"
type: "gear"
cost: "100 GP"
weight: "\u2014"
---

# Poison, Basic
*Adventuring Gear*

- **Cost:** 100 GP
- **Weight:** \u2014
`,
      "Pole.md": `---
smType: equipment
name: "Pole"
type: "gear"
cost: "5 CP"
weight: "7 lb."
---

# Pole
*Adventuring Gear*

- **Cost:** 5 CP
- **Weight:** 7 lb.
`,
      "Pot, Iron.md": `---
smType: equipment
name: "Pot, Iron"
type: "gear"
cost: "2 GP"
weight: "10 lb."
---

# Pot, Iron
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 10 lb.
`,
      "Potion of Healing.md": `---
smType: equipment
name: "Potion of Healing"
type: "gear"
cost: "50 GP"
weight: "1/2 lb."
---

# Potion of Healing
*Adventuring Gear*

- **Cost:** 50 GP
- **Weight:** 1/2 lb.
`,
      "Pouch.md": `---
smType: equipment
name: "Pouch"
type: "gear"
cost: "5 SP"
weight: "1 lb."
---

# Pouch
*Adventuring Gear*

- **Cost:** 5 SP
- **Weight:** 1 lb.
`,
      "Priest's Pack.md": `---
smType: equipment
name: "Priest's Pack"
type: "gear"
cost: "33 GP"
weight: "29 lb."
---

# Priest's Pack
*Adventuring Gear*

- **Cost:** 33 GP
- **Weight:** 29 lb.
`,
      "Quiver.md": `---
smType: equipment
name: "Quiver"
type: "gear"
cost: "1 GP"
weight: "1 lb."
---

# Quiver
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 1 lb.
`,
      "Ram, Portable.md": `---
smType: equipment
name: "Ram, Portable"
type: "gear"
cost: "4 GP"
weight: "35 lb."
---

# Ram, Portable
*Adventuring Gear*

- **Cost:** 4 GP
- **Weight:** 35 lb.
`,
      "Rations.md": `---
smType: equipment
name: "Rations"
type: "gear"
cost: "5 SP"
weight: "2 lb."
---

# Rations
*Adventuring Gear*

- **Cost:** 5 SP
- **Weight:** 2 lb.
`,
      "Robe.md": `---
smType: equipment
name: "Robe"
type: "gear"
cost: "1 GP"
weight: "4 lb."
---

# Robe
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 4 lb.
`,
      "Rope.md": `---
smType: equipment
name: "Rope"
type: "gear"
cost: "1 GP"
weight: "5 lb."
---

# Rope
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 5 lb.
`,
      "Sack.md": `---
smType: equipment
name: "Sack"
type: "gear"
cost: "1 CP"
weight: "1/2 lb."
---

# Sack
*Adventuring Gear*

- **Cost:** 1 CP
- **Weight:** 1/2 lb.
`,
      "Scholar's Pack.md": `---
smType: equipment
name: "Scholar's Pack"
type: "gear"
cost: "40 GP"
weight: "22 lb."
---

# Scholar's Pack
*Adventuring Gear*

- **Cost:** 40 GP
- **Weight:** 22 lb.
`,
      "Shovel.md": `---
smType: equipment
name: "Shovel"
type: "gear"
cost: "2 GP"
weight: "5 lb."
---

# Shovel
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 5 lb.
`,
      "Signal Whistle.md": `---
smType: equipment
name: "Signal Whistle"
type: "gear"
cost: "5 CP"
weight: "\u2014"
---

# Signal Whistle
*Adventuring Gear*

- **Cost:** 5 CP
- **Weight:** \u2014
`,
      "Spell Scroll (Cantrip).md": `---
smType: equipment
name: "Spell Scroll (Cantrip)"
type: "gear"
cost: "30 GP"
weight: "\u2014"
---

# Spell Scroll (Cantrip)
*Adventuring Gear*

- **Cost:** 30 GP
- **Weight:** \u2014
`,
      "Spell Scroll (Level 1).md": `---
smType: equipment
name: "Spell Scroll (Level 1)"
type: "gear"
cost: "50 GP"
weight: "\u2014"
---

# Spell Scroll (Level 1)
*Adventuring Gear*

- **Cost:** 50 GP
- **Weight:** \u2014
`,
      "Spikes, Iron.md": `---
smType: equipment
name: "Spikes, Iron"
type: "gear"
cost: "1 GP"
weight: "5 lb."
---

# Spikes, Iron
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** 5 lb.
`,
      "Spyglass.md": `---
smType: equipment
name: "Spyglass"
type: "gear"
cost: "1,000 GP"
weight: "1 lb."
---

# Spyglass
*Adventuring Gear*

- **Cost:** 1,000 GP
- **Weight:** 1 lb.
`,
      "String.md": `---
smType: equipment
name: "String"
type: "gear"
cost: "1 SP"
weight: "\u2014"
---

# String
*Adventuring Gear*

- **Cost:** 1 SP
- **Weight:** \u2014
`,
      "Tent.md": `---
smType: equipment
name: "Tent"
type: "gear"
cost: "2 GP"
weight: "20 lb."
---

# Tent
*Adventuring Gear*

- **Cost:** 2 GP
- **Weight:** 20 lb.
`,
      "Tinderbox.md": `---
smType: equipment
name: "Tinderbox"
type: "gear"
cost: "5 SP"
weight: "1 lb."
---

# Tinderbox
*Adventuring Gear*

- **Cost:** 5 SP
- **Weight:** 1 lb.
`,
      "Torch.md": `---
smType: equipment
name: "Torch"
type: "gear"
cost: "1 CP"
weight: "1 lb."
---

# Torch
*Adventuring Gear*

- **Cost:** 1 CP
- **Weight:** 1 lb.
`,
      "Vial.md": `---
smType: equipment
name: "Vial"
type: "gear"
cost: "1 GP"
weight: "\u2014"
---

# Vial
*Adventuring Gear*

- **Cost:** 1 GP
- **Weight:** \u2014
`,
      "Waterskin.md": `---
smType: equipment
name: "Waterskin"
type: "gear"
cost: "2 SP"
weight: "5 lb. (full)"
---

# Waterskin
*Adventuring Gear*

- **Cost:** 2 SP
- **Weight:** 5 lb. (full)
`,
      "Alchemist's Supplies.md": `---
smType: equipment
name: "Alchemist's Supplies"
type: "tool"
cost: "50 GP"
weight: "8 lb."
tool_category: "Artisan"
ability: "Intelligence"
utilize: ["Identify a substance (DC 15)", "start a fire (DC 15)"]
craft: ["Acid", "Alchemist's Fire", "Component Pouch", "Oil", "Paper", "Perfume"]
---

# Alchemist's Supplies
*Artisan Tool*

- **Cost:** 50 GP
- **Weight:** 8 lb.

**Ability:** Intelligence

## Utilize

- Identify a substance (DC 15)
- start a fire (DC 15)

## Craft

Acid, Alchemist's Fire, Component Pouch, Oil, Paper, Perfume
`,
      "Brewer's Supplies.md": `---
smType: equipment
name: "Brewer's Supplies"
type: "tool"
cost: "20 GP"
weight: "9 lb."
tool_category: "Artisan"
ability: "Intelligence"
utilize: ["Detect poisoned drink (DC 15)", "identify alcohol (DC 10)"]
craft: ["Antitoxin"]
---

# Brewer's Supplies
*Artisan Tool*

- **Cost:** 20 GP
- **Weight:** 9 lb.

**Ability:** Intelligence

## Utilize

- Detect poisoned drink (DC 15)
- identify alcohol (DC 10)

## Craft

Antitoxin
`,
      "Calligrapher's Supplies.md": `---
smType: equipment
name: "Calligrapher's Supplies"
type: "tool"
cost: "10 GP"
weight: "5 lb."
tool_category: "Artisan"
ability: "Dexterity"
utilize: ["Write text with impressive flourishes that guard against forgery (DC 15)"]
craft: ["Ink", "*Spell Scroll*"]
---

# Calligrapher's Supplies
*Artisan Tool*

- **Cost:** 10 GP
- **Weight:** 5 lb.

**Ability:** Dexterity

## Utilize

- Write text with impressive flourishes that guard against forgery (DC 15)

## Craft

Ink, *Spell Scroll*
`,
      "Carpenter's Tools.md": `---
smType: equipment
name: "Carpenter's Tools"
type: "tool"
cost: "8 GP"
weight: "6 lb."
tool_category: "Artisan"
ability: "Strength"
utilize: ["Seal or pry open a door or container (DC 20)"]
craft: ["Club", "Greatclub", "Quarterstaff", "Barrel", "Chest", "Ladder", "Pole", "Portable Ram", "Torch"]
---

# Carpenter's Tools
*Artisan Tool*

- **Cost:** 8 GP
- **Weight:** 6 lb.

**Ability:** Strength

## Utilize

- Seal or pry open a door or container (DC 20)

## Craft

Club, Greatclub, Quarterstaff, Barrel, Chest, Ladder, Pole, Portable Ram, Torch
`,
      "Cartographer's Tools.md": `---
smType: equipment
name: "Cartographer's Tools"
type: "tool"
cost: "15 GP"
weight: "6 lb."
tool_category: "Artisan"
ability: "Wisdom"
utilize: ["Draft a map of a small area (DC 15)"]
craft: ["Map"]
---

# Cartographer's Tools
*Artisan Tool*

- **Cost:** 15 GP
- **Weight:** 6 lb.

**Ability:** Wisdom

## Utilize

- Draft a map of a small area (DC 15)

## Craft

Map
`,
      "Cobbler's Tools.md": `---
smType: equipment
name: "Cobbler's Tools"
type: "tool"
cost: "5 GP"
weight: "5 lb."
tool_category: "Artisan"
ability: "Dexterity"
utilize: ["Modify footwear to give Advantage on the wearer's next Dexterity (Acrobatics) check (DC 10)"]
craft: ["Climber's Kit"]
---

# Cobbler's Tools
*Artisan Tool*

- **Cost:** 5 GP
- **Weight:** 5 lb.

**Ability:** Dexterity

## Utilize

- Modify footwear to give Advantage on the wearer's next Dexterity (Acrobatics) check (DC 10)

## Craft

Climber's Kit
`,
      "Cook's Utensils.md": `---
smType: equipment
name: "Cook's Utensils"
type: "tool"
cost: "1 GP"
weight: "8 lb."
tool_category: "Artisan"
ability: "Wisdom"
utilize: ["Improve food's flavor (DC 10)", "detect spoiled or poisoned food (DC 15)"]
craft: ["Rations"]
---

# Cook's Utensils
*Artisan Tool*

- **Cost:** 1 GP
- **Weight:** 8 lb.

**Ability:** Wisdom

## Utilize

- Improve food's flavor (DC 10)
- detect spoiled or poisoned food (DC 15)

## Craft

Rations
`,
      "Disguise Kit.md": `---
smType: equipment
name: "Disguise Kit"
type: "tool"
cost: "25 GP"
weight: "3 lb."
tool_category: "Other"
ability: "Charisma"
utilize: ["Apply makeup (DC 10)"]
craft: ["Costume"]
---

# Disguise Kit
*Other Tool*

- **Cost:** 25 GP
- **Weight:** 3 lb.

**Ability:** Charisma

## Utilize

- Apply makeup (DC 10)

## Craft

Costume
`,
      "Forgery Kit.md": `---
smType: equipment
name: "Forgery Kit"
type: "tool"
cost: "15 GP"
weight: "5 lb."
tool_category: "Other"
ability: "Dexterity"
utilize: ["Mimic 10 or fewer words of someone else's handwriting (DC 15)", "duplicate a wax seal (DC 20)"]
---

# Forgery Kit
*Other Tool*

- **Cost:** 15 GP
- **Weight:** 5 lb.

**Ability:** Dexterity

## Utilize

- Mimic 10 or fewer words of someone else's handwriting (DC 15)
- duplicate a wax seal (DC 20)
`,
      "Gaming Set.md": `---
smType: equipment
name: "Gaming Set"
type: "tool"
cost: "Varies"
weight: "\u2014"
tool_category: "Gaming"
ability: "Wisdom"
utilize: ["Discern whether someone is cheating (DC 10)", "win the game (DC 20)"]
variants: ["Dice (1 SP)", "dragonchess (1 GP)", "playing cards (5 SP)", "three-dragon ante (1 GP)"]
---

# Gaming Set
*Gaming Tool*

- **Cost:** Varies
- **Weight:** \u2014

**Ability:** Wisdom

## Utilize

- Discern whether someone is cheating (DC 10)
- win the game (DC 20)

## Variants

- Dice (1 SP)
- dragonchess (1 GP)
- playing cards (5 SP)
- three-dragon ante (1 GP)
`,
      "Glassblower's Tools.md": `---
smType: equipment
name: "Glassblower's Tools"
type: "tool"
cost: "30 GP"
weight: "5 lb."
tool_category: "Artisan"
ability: "Intelligence"
utilize: ["Discern what a glass object held in the past 24 hours (DC 15)"]
craft: ["Glass Bottle", "Magnifying Glass", "Spyglass", "Vial"]
---

# Glassblower's Tools
*Artisan Tool*

- **Cost:** 30 GP
- **Weight:** 5 lb.

**Ability:** Intelligence

## Utilize

- Discern what a glass object held in the past 24 hours (DC 15)

## Craft

Glass Bottle, Magnifying Glass, Spyglass, Vial
`,
      "Herbalism Kit.md": `---
smType: equipment
name: "Herbalism Kit"
type: "tool"
cost: "5 GP"
weight: "3 lb."
tool_category: "Other"
ability: "Intelligence"
utilize: ["Identify a plant (DC 10)"]
craft: ["Antitoxin", "Candle", "Healer's Kit", "*Potion of Healing*"]
---

# Herbalism Kit
*Other Tool*

- **Cost:** 5 GP
- **Weight:** 3 lb.

**Ability:** Intelligence

## Utilize

- Identify a plant (DC 10)

## Craft

Antitoxin, Candle, Healer's Kit, *Potion of Healing*
`,
      "Jeweler's Tools.md": `---
smType: equipment
name: "Jeweler's Tools"
type: "tool"
cost: "25 GP"
weight: "2 lb."
tool_category: "Artisan"
ability: "Intelligence"
utilize: ["Discern a gem's value (DC 15)"]
craft: ["Arcane Focus", "Holy Symbol"]
---

# Jeweler's Tools
*Artisan Tool*

- **Cost:** 25 GP
- **Weight:** 2 lb.

**Ability:** Intelligence

## Utilize

- Discern a gem's value (DC 15)

## Craft

Arcane Focus, Holy Symbol
`,
      "Leatherworker's Tools.md": `---
smType: equipment
name: "Leatherworker's Tools"
type: "tool"
cost: "5 GP"
weight: "5 lb."
tool_category: "Artisan"
ability: "Dexterity"
utilize: ["Add a design to a leather item (DC 10)"]
craft: ["Sling", "Whip", "Hide Armor", "Leather Armor", "Studded Leather Armor", "Backpack", "Crossbow Bolt Case", "Map or Scroll Case", "Parchment", "Pouch", "Quiver", "Waterskin"]
---

# Leatherworker's Tools
*Artisan Tool*

- **Cost:** 5 GP
- **Weight:** 5 lb.

**Ability:** Dexterity

## Utilize

- Add a design to a leather item (DC 10)

## Craft

Sling, Whip, Hide Armor, Leather Armor, Studded Leather Armor, Backpack, Crossbow Bolt Case, Map or Scroll Case, Parchment, Pouch, Quiver, Waterskin
`,
      "Mason's Tools.md": `---
smType: equipment
name: "Mason's Tools"
type: "tool"
cost: "10 GP"
weight: "8 lb."
tool_category: "Artisan"
ability: "Strength"
utilize: ["Chisel a symbol or hole in stone (DC 10)"]
craft: ["Block and Tackle"]
---

# Mason's Tools
*Artisan Tool*

- **Cost:** 10 GP
- **Weight:** 8 lb.

**Ability:** Strength

## Utilize

- Chisel a symbol or hole in stone (DC 10)

## Craft

Block and Tackle
`,
      "Musical Instrument.md": `---
smType: equipment
name: "Musical Instrument"
type: "tool"
cost: "Varies"
weight: "Varies"
tool_category: "Musical"
ability: "Charisma"
utilize: ["Play a known tune (DC 10)", "improvise a song (DC 15)"]
variants: ["Bagpipes (30 GP", "6 lb.)", "drum (6 GP", "3 lb.)", "dulcimer (25 GP", "10 lb.)", "flute (2 GP", "1 lb.)", "horn (3 GP", "2 lb.)", "lute (35 GP", "2 lb.)", "lyre (30 GP", "2 lb.)", "pan flute (12 GP", "2 lb.)", "shawm (2 GP", "1 lb.)", "viol (30 GP", "1 lb.)"]
---

# Musical Instrument
*Musical Tool*

- **Cost:** Varies
- **Weight:** Varies

**Ability:** Charisma

## Utilize

- Play a known tune (DC 10)
- improvise a song (DC 15)

## Variants

- Bagpipes (30 GP
- 6 lb.)
- drum (6 GP
- 3 lb.)
- dulcimer (25 GP
- 10 lb.)
- flute (2 GP
- 1 lb.)
- horn (3 GP
- 2 lb.)
- lute (35 GP
- 2 lb.)
- lyre (30 GP
- 2 lb.)
- pan flute (12 GP
- 2 lb.)
- shawm (2 GP
- 1 lb.)
- viol (30 GP
- 1 lb.)
`,
      "Navigator's Tools.md": `---
smType: equipment
name: "Navigator's Tools"
type: "tool"
cost: "25 GP"
weight: "2 lb."
tool_category: "Other"
ability: "Wisdom"
utilize: ["Plot a course (DC 10)", "determine position by stargazing (DC 15)"]
---

# Navigator's Tools
*Other Tool*

- **Cost:** 25 GP
- **Weight:** 2 lb.

**Ability:** Wisdom

## Utilize

- Plot a course (DC 10)
- determine position by stargazing (DC 15)
`,
      "Painter's Supplies.md": `---
smType: equipment
name: "Painter's Supplies"
type: "tool"
cost: "10 GP"
weight: "5 lb."
tool_category: "Artisan"
ability: "Wisdom"
utilize: ["Paint a recognizable image of something you've seen (DC 10)"]
craft: ["Druidic Focus", "Holy Symbol"]
---

# Painter's Supplies
*Artisan Tool*

- **Cost:** 10 GP
- **Weight:** 5 lb.

**Ability:** Wisdom

## Utilize

- Paint a recognizable image of something you've seen (DC 10)

## Craft

Druidic Focus, Holy Symbol
`,
      "Poisoner's Kit.md": `---
smType: equipment
name: "Poisoner's Kit"
type: "tool"
cost: "50 GP"
weight: "2 lb."
tool_category: "Other"
ability: "Intelligence"
utilize: ["Detect a poisoned object (DC 10)"]
craft: ["Basic Poison"]
---

# Poisoner's Kit
*Other Tool*

- **Cost:** 50 GP
- **Weight:** 2 lb.

**Ability:** Intelligence

## Utilize

- Detect a poisoned object (DC 10)

## Craft

Basic Poison
`,
      "Potter's Tools.md": `---
smType: equipment
name: "Potter's Tools"
type: "tool"
cost: "10 GP"
weight: "3 lb."
tool_category: "Artisan"
ability: "Intelligence"
utilize: ["Discern what a ceramic object held in the past 24 hours (DC 15)"]
craft: ["Jug", "Lamp"]
---

# Potter's Tools
*Artisan Tool*

- **Cost:** 10 GP
- **Weight:** 3 lb.

**Ability:** Intelligence

## Utilize

- Discern what a ceramic object held in the past 24 hours (DC 15)

## Craft

Jug, Lamp
`,
      "Smith's Tools.md": `---
smType: equipment
name: "Smith's Tools"
type: "tool"
cost: "20 GP"
weight: "8 lb."
tool_category: "Artisan"
ability: "Strength"
utilize: ["Pry open a door or container (DC 20)"]
craft: ["Any Melee weapon (except Club", "Greatclub", "Quarterstaff", "and Whip)", "Medium armor (except Hide)", "Heavy armor", "Ball Bearings", "Bucket", "Caltrops", "Chain", "Crowbar", "Firearm Bullets", "Grappling Hook", "Iron Pot", "Iron Spikes", "Sling Bullets"]
---

# Smith's Tools
*Artisan Tool*

- **Cost:** 20 GP
- **Weight:** 8 lb.

**Ability:** Strength

## Utilize

- Pry open a door or container (DC 20)

## Craft

Any Melee weapon (except Club, Greatclub, Quarterstaff, and Whip), Medium armor (except Hide), Heavy armor, Ball Bearings, Bucket, Caltrops, Chain, Crowbar, Firearm Bullets, Grappling Hook, Iron Pot, Iron Spikes, Sling Bullets
`,
      "Thieves' Tools.md": `---
smType: equipment
name: "Thieves' Tools"
type: "tool"
cost: "25 GP"
weight: "1 lb."
tool_category: "Other"
ability: "Dexterity"
utilize: ["Pick a lock (DC 15)", "disarm a trap (DC 15)"]
---

# Thieves' Tools
*Other Tool*

- **Cost:** 25 GP
- **Weight:** 1 lb.

**Ability:** Dexterity

## Utilize

- Pick a lock (DC 15)
- disarm a trap (DC 15)
`,
      "Tinker's Tools.md": `---
smType: equipment
name: "Tinker's Tools"
type: "tool"
cost: "50 GP"
weight: "10 lb."
tool_category: "Artisan"
ability: "Dexterity"
utilize: ["Assemble a Tiny item composed of scrap, which falls apart in 1 minute (DC 20)"]
craft: ["Musket", "Pistol", "Bell", "Bullseye Lantern", "Flask", "Hooded Lantern", "Hunting Trap", "Lock", "Manacles", "Mirror", "Shovel", "Signal Whistle", "Tinderbox"]
---

# Tinker's Tools
*Artisan Tool*

- **Cost:** 50 GP
- **Weight:** 10 lb.

**Ability:** Dexterity

## Utilize

- Assemble a Tiny item composed of scrap, which falls apart in 1 minute (DC 20)

## Craft

Musket, Pistol, Bell, Bullseye Lantern, Flask, Hooded Lantern, Hunting Trap, Lock, Manacles, Mirror, Shovel, Signal Whistle, Tinderbox
`,
      "Weaver's Tools.md": `---
smType: equipment
name: "Weaver's Tools"
type: "tool"
cost: "1 GP"
weight: "5 lb."
tool_category: "Artisan"
ability: "Dexterity"
utilize: ["Mend a tear in clothing (DC 10)", "sew a Tiny design (DC 10)"]
craft: ["Padded Armor", "Basket", "Bedroll", "Blanket", "Fine Clothes", "Net", "Robe", "Rope", "Sack", "String", "Tent", "Traveler's Clothes"]
---

# Weaver's Tools
*Artisan Tool*

- **Cost:** 1 GP
- **Weight:** 5 lb.

**Ability:** Dexterity

## Utilize

- Mend a tear in clothing (DC 10)
- sew a Tiny design (DC 10)

## Craft

Padded Armor, Basket, Bedroll, Blanket, Fine Clothes, Net, Robe, Rope, Sack, String, Tent, Traveler's Clothes
`,
      "Woodcarver's Tools.md": `---
smType: equipment
name: "Woodcarver's Tools"
type: "tool"
cost: "1 GP"
weight: "5 lb."
tool_category: "Artisan"
ability: "Dexterity"
utilize: ["Carve a pattern in wood (DC 10)"]
craft: ["Club", "Greatclub", "Quarterstaff", "Ranged weapons (except Pistol", "Musket", "and Sling)", "Arcane Focus", "Arrows", "Bolts", "Druidic Focus", "Ink Pen", "Needles"]
---

# Woodcarver's Tools
*Artisan Tool*

- **Cost:** 1 GP
- **Weight:** 5 lb.

**Ability:** Dexterity

## Utilize

- Carve a pattern in wood (DC 10)

## Craft

Club, Greatclub, Quarterstaff, Ranged weapons (except Pistol, Musket, and Sling), Arcane Focus, Arrows, Bolts, Druidic Focus, Ink Pen, Needles
`,
      "Battleaxe.md": `---
smType: equipment
name: "Battleaxe"
type: "weapon"
cost: "10 GP"
weight: "4 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d8 Slashing"
properties: ["Versatile (1d10)"]
mastery: "Topple"
---

# Battleaxe
*Martial Melee Weapon*

- **Cost:** 10 GP
- **Weight:** 4 lb.

**Damage:** 1d8 Slashing

**Properties:** Versatile (1d10)

**Mastery:** Topple
`,
      "Blowgun.md": `---
smType: equipment
name: "Blowgun"
type: "weapon"
cost: "10 GP"
weight: "1 lb."
weapon_category: "Martial"
weapon_type: "Ranged"
damage: "1 Piercing"
properties: ["Ammunition (Range 25/100; Needle)", "Loading"]
mastery: "Vex"
---

# Blowgun
*Martial Ranged Weapon*

- **Cost:** 10 GP
- **Weight:** 1 lb.

**Damage:** 1 Piercing

**Properties:** Ammunition (Range 25/100; Needle), Loading

**Mastery:** Vex
`,
      "Club.md": `---
smType: equipment
name: "Club"
type: "weapon"
cost: "1 SP"
weight: "2 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d4 Bludgeoning"
properties: ["Light"]
mastery: "Slow"
---

# Club
*Simple Melee Weapon*

- **Cost:** 1 SP
- **Weight:** 2 lb.

**Damage:** 1d4 Bludgeoning

**Properties:** Light

**Mastery:** Slow
`,
      "Dagger.md": `---
smType: equipment
name: "Dagger"
type: "weapon"
cost: "2 GP"
weight: "1 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d4 Piercing"
properties: ["Finesse", "Light", "Thrown (Range 20/60)"]
mastery: "Nick"
---

# Dagger
*Simple Melee Weapon*

- **Cost:** 2 GP
- **Weight:** 1 lb.

**Damage:** 1d4 Piercing

**Properties:** Finesse, Light, Thrown (Range 20/60)

**Mastery:** Nick
`,
      "Dart.md": `---
smType: equipment
name: "Dart"
type: "weapon"
cost: "5 CP"
weight: "1/4 lb."
weapon_category: "Simple"
weapon_type: "Ranged"
damage: "1d4 Piercing"
properties: ["Finesse", "Thrown (Range 20/60)"]
mastery: "Vex"
---

# Dart
*Simple Ranged Weapon*

- **Cost:** 5 CP
- **Weight:** 1/4 lb.

**Damage:** 1d4 Piercing

**Properties:** Finesse, Thrown (Range 20/60)

**Mastery:** Vex
`,
      "Flail.md": `---
smType: equipment
name: "Flail"
type: "weapon"
cost: "10 GP"
weight: "2 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d8 Bludgeoning"
mastery: "Sap"
---

# Flail
*Martial Melee Weapon*

- **Cost:** 10 GP
- **Weight:** 2 lb.

**Damage:** 1d8 Bludgeoning

**Mastery:** Sap
`,
      "Glaive.md": `---
smType: equipment
name: "Glaive"
type: "weapon"
cost: "20 GP"
weight: "6 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d10 Slashing"
properties: ["Heavy", "Reach", "Two-Handed"]
mastery: "Graze"
---

# Glaive
*Martial Melee Weapon*

- **Cost:** 20 GP
- **Weight:** 6 lb.

**Damage:** 1d10 Slashing

**Properties:** Heavy, Reach, Two-Handed

**Mastery:** Graze
`,
      "Greataxe.md": `---
smType: equipment
name: "Greataxe"
type: "weapon"
cost: "30 GP"
weight: "7 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d12 Slashing"
properties: ["Heavy", "Two-Handed"]
mastery: "Cleave"
---

# Greataxe
*Martial Melee Weapon*

- **Cost:** 30 GP
- **Weight:** 7 lb.

**Damage:** 1d12 Slashing

**Properties:** Heavy, Two-Handed

**Mastery:** Cleave
`,
      "Greatclub.md": `---
smType: equipment
name: "Greatclub"
type: "weapon"
cost: "2 SP"
weight: "10 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d8 Bludgeoning"
properties: ["Two-Handed"]
mastery: "Push"
---

# Greatclub
*Simple Melee Weapon*

- **Cost:** 2 SP
- **Weight:** 10 lb.

**Damage:** 1d8 Bludgeoning

**Properties:** Two-Handed

**Mastery:** Push
`,
      "Greatsword.md": `---
smType: equipment
name: "Greatsword"
type: "weapon"
cost: "50 GP"
weight: "6 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "2d6 Slashing"
properties: ["Heavy", "Two-Handed"]
mastery: "Graze"
---

# Greatsword
*Martial Melee Weapon*

- **Cost:** 50 GP
- **Weight:** 6 lb.

**Damage:** 2d6 Slashing

**Properties:** Heavy, Two-Handed

**Mastery:** Graze
`,
      "Halberd.md": `---
smType: equipment
name: "Halberd"
type: "weapon"
cost: "20 GP"
weight: "6 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d10 Slashing"
properties: ["Heavy", "Reach", "Two-Handed"]
mastery: "Cleave"
---

# Halberd
*Martial Melee Weapon*

- **Cost:** 20 GP
- **Weight:** 6 lb.

**Damage:** 1d10 Slashing

**Properties:** Heavy, Reach, Two-Handed

**Mastery:** Cleave
`,
      "Hand Crossbow.md": `---
smType: equipment
name: "Hand Crossbow"
type: "weapon"
cost: "75 GP"
weight: "3 lb."
weapon_category: "Martial"
weapon_type: "Ranged"
damage: "1d6 Piercing"
properties: ["Ammunition (Range 30/120; Bolt)", "Light", "Loading"]
mastery: "Vex"
---

# Hand Crossbow
*Martial Ranged Weapon*

- **Cost:** 75 GP
- **Weight:** 3 lb.

**Damage:** 1d6 Piercing

**Properties:** Ammunition (Range 30/120; Bolt), Light, Loading

**Mastery:** Vex
`,
      "Handaxe.md": `---
smType: equipment
name: "Handaxe"
type: "weapon"
cost: "5 GP"
weight: "2 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d6 Slashing"
properties: ["Light", "Thrown (Range 20/60)"]
mastery: "Vex"
---

# Handaxe
*Simple Melee Weapon*

- **Cost:** 5 GP
- **Weight:** 2 lb.

**Damage:** 1d6 Slashing

**Properties:** Light, Thrown (Range 20/60)

**Mastery:** Vex
`,
      "Heavy Crossbow.md": `---
smType: equipment
name: "Heavy Crossbow"
type: "weapon"
cost: "50 GP"
weight: "18 lb."
weapon_category: "Martial"
weapon_type: "Ranged"
damage: "1d10 Piercing"
properties: ["Ammunition (Range 100/400; Bolt)", "Heavy", "Loading", "Two-Handed"]
mastery: "Push"
---

# Heavy Crossbow
*Martial Ranged Weapon*

- **Cost:** 50 GP
- **Weight:** 18 lb.

**Damage:** 1d10 Piercing

**Properties:** Ammunition (Range 100/400; Bolt), Heavy, Loading, Two-Handed

**Mastery:** Push
`,
      "Javelin.md": `---
smType: equipment
name: "Javelin"
type: "weapon"
cost: "5 SP"
weight: "2 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d6 Piercing"
properties: ["Thrown (Range 30/120)"]
mastery: "Slow"
---

# Javelin
*Simple Melee Weapon*

- **Cost:** 5 SP
- **Weight:** 2 lb.

**Damage:** 1d6 Piercing

**Properties:** Thrown (Range 30/120)

**Mastery:** Slow
`,
      "Lance.md": `---
smType: equipment
name: "Lance"
type: "weapon"
cost: "10 GP"
weight: "6 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d10 Piercing"
properties: ["Heavy", "Reach", "Two-Handed (unless mounted)"]
mastery: "Topple"
---

# Lance
*Martial Melee Weapon*

- **Cost:** 10 GP
- **Weight:** 6 lb.

**Damage:** 1d10 Piercing

**Properties:** Heavy, Reach, Two-Handed (unless mounted)

**Mastery:** Topple
`,
      "Light Crossbow.md": `---
smType: equipment
name: "Light Crossbow"
type: "weapon"
cost: "25 GP"
weight: "5 lb."
weapon_category: "Simple"
weapon_type: "Ranged"
damage: "1d8 Piercing"
properties: ["Ammunition (Range 80/320; Bolt)", "Loading", "Two-Handed"]
mastery: "Slow"
---

# Light Crossbow
*Simple Ranged Weapon*

- **Cost:** 25 GP
- **Weight:** 5 lb.

**Damage:** 1d8 Piercing

**Properties:** Ammunition (Range 80/320; Bolt), Loading, Two-Handed

**Mastery:** Slow
`,
      "Light Hammer.md": `---
smType: equipment
name: "Light Hammer"
type: "weapon"
cost: "2 GP"
weight: "2 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d4 Bludgeoning"
properties: ["Light", "Thrown (Range 20/60)"]
mastery: "Nick"
---

# Light Hammer
*Simple Melee Weapon*

- **Cost:** 2 GP
- **Weight:** 2 lb.

**Damage:** 1d4 Bludgeoning

**Properties:** Light, Thrown (Range 20/60)

**Mastery:** Nick
`,
      "Longbow.md": `---
smType: equipment
name: "Longbow"
type: "weapon"
cost: "50 GP"
weight: "2 lb."
weapon_category: "Martial"
weapon_type: "Ranged"
damage: "1d8 Piercing"
properties: ["Ammunition (Range 150/600; Arrow)", "Heavy", "Two-Handed"]
mastery: "Slow"
---

# Longbow
*Martial Ranged Weapon*

- **Cost:** 50 GP
- **Weight:** 2 lb.

**Damage:** 1d8 Piercing

**Properties:** Ammunition (Range 150/600; Arrow), Heavy, Two-Handed

**Mastery:** Slow
`,
      "Longsword.md": `---
smType: equipment
name: "Longsword"
type: "weapon"
cost: "15 GP"
weight: "3 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d8 Slashing"
properties: ["Versatile (1d10)"]
mastery: "Sap"
---

# Longsword
*Martial Melee Weapon*

- **Cost:** 15 GP
- **Weight:** 3 lb.

**Damage:** 1d8 Slashing

**Properties:** Versatile (1d10)

**Mastery:** Sap
`,
      "Mace.md": `---
smType: equipment
name: "Mace"
type: "weapon"
cost: "5 GP"
weight: "4 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d6 Bludgeoning"
mastery: "Sap"
---

# Mace
*Simple Melee Weapon*

- **Cost:** 5 GP
- **Weight:** 4 lb.

**Damage:** 1d6 Bludgeoning

**Mastery:** Sap
`,
      "Maul.md": `---
smType: equipment
name: "Maul"
type: "weapon"
cost: "10 GP"
weight: "10 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "2d6 Bludgeoning"
properties: ["Heavy", "Two-Handed"]
mastery: "Topple"
---

# Maul
*Martial Melee Weapon*

- **Cost:** 10 GP
- **Weight:** 10 lb.

**Damage:** 2d6 Bludgeoning

**Properties:** Heavy, Two-Handed

**Mastery:** Topple
`,
      "Morningstar.md": `---
smType: equipment
name: "Morningstar"
type: "weapon"
cost: "15 GP"
weight: "4 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d8 Piercing"
mastery: "Sap"
---

# Morningstar
*Martial Melee Weapon*

- **Cost:** 15 GP
- **Weight:** 4 lb.

**Damage:** 1d8 Piercing

**Mastery:** Sap
`,
      "Musket.md": `---
smType: equipment
name: "Musket"
type: "weapon"
cost: "500 GP"
weight: "10 lb."
weapon_category: "Martial"
weapon_type: "Ranged"
damage: "1d12 Piercing"
properties: ["Ammunition (Range 40/120; Bullet)", "Loading", "Two-Handed"]
mastery: "Slow"
---

# Musket
*Martial Ranged Weapon*

- **Cost:** 500 GP
- **Weight:** 10 lb.

**Damage:** 1d12 Piercing

**Properties:** Ammunition (Range 40/120; Bullet), Loading, Two-Handed

**Mastery:** Slow
`,
      "Pike.md": `---
smType: equipment
name: "Pike"
type: "weapon"
cost: "5 GP"
weight: "18 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d10 Piercing"
properties: ["Heavy", "Reach", "Two-Handed"]
mastery: "Push"
---

# Pike
*Martial Melee Weapon*

- **Cost:** 5 GP
- **Weight:** 18 lb.

**Damage:** 1d10 Piercing

**Properties:** Heavy, Reach, Two-Handed

**Mastery:** Push
`,
      "Pistol.md": `---
smType: equipment
name: "Pistol"
type: "weapon"
cost: "250 GP"
weight: "3 lb."
weapon_category: "Martial"
weapon_type: "Ranged"
damage: "1d10 Piercing"
properties: ["Ammunition (Range 30/90; Bullet)", "Loading"]
mastery: "Vex"
---

# Pistol
*Martial Ranged Weapon*

- **Cost:** 250 GP
- **Weight:** 3 lb.

**Damage:** 1d10 Piercing

**Properties:** Ammunition (Range 30/90; Bullet), Loading

**Mastery:** Vex
`,
      "Quarterstaff.md": `---
smType: equipment
name: "Quarterstaff"
type: "weapon"
cost: "2 SP"
weight: "4 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d6 Bludgeoning"
properties: ["Versatile (1d8)"]
mastery: "Topple"
---

# Quarterstaff
*Simple Melee Weapon*

- **Cost:** 2 SP
- **Weight:** 4 lb.

**Damage:** 1d6 Bludgeoning

**Properties:** Versatile (1d8)

**Mastery:** Topple
`,
      "Rapier.md": `---
smType: equipment
name: "Rapier"
type: "weapon"
cost: "25 GP"
weight: "2 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d8 Piercing"
properties: ["Finesse"]
mastery: "Vex"
---

# Rapier
*Martial Melee Weapon*

- **Cost:** 25 GP
- **Weight:** 2 lb.

**Damage:** 1d8 Piercing

**Properties:** Finesse

**Mastery:** Vex
`,
      "Scimitar.md": `---
smType: equipment
name: "Scimitar"
type: "weapon"
cost: "25 GP"
weight: "3 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d6 Slashing"
properties: ["Finesse", "Light"]
mastery: "Nick"
---

# Scimitar
*Martial Melee Weapon*

- **Cost:** 25 GP
- **Weight:** 3 lb.

**Damage:** 1d6 Slashing

**Properties:** Finesse, Light

**Mastery:** Nick
`,
      "Shortbow.md": `---
smType: equipment
name: "Shortbow"
type: "weapon"
cost: "25 GP"
weight: "2 lb."
weapon_category: "Simple"
weapon_type: "Ranged"
damage: "1d6 Piercing"
properties: ["Ammunition (Range 80/320; Arrow)", "Two-Handed"]
mastery: "Vex"
---

# Shortbow
*Simple Ranged Weapon*

- **Cost:** 25 GP
- **Weight:** 2 lb.

**Damage:** 1d6 Piercing

**Properties:** Ammunition (Range 80/320; Arrow), Two-Handed

**Mastery:** Vex
`,
      "Shortsword.md": `---
smType: equipment
name: "Shortsword"
type: "weapon"
cost: "10 GP"
weight: "2 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d6 Piercing"
properties: ["Finesse", "Light"]
mastery: "Vex"
---

# Shortsword
*Martial Melee Weapon*

- **Cost:** 10 GP
- **Weight:** 2 lb.

**Damage:** 1d6 Piercing

**Properties:** Finesse, Light

**Mastery:** Vex
`,
      "Sickle.md": `---
smType: equipment
name: "Sickle"
type: "weapon"
cost: "1 GP"
weight: "2 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d4 Slashing"
properties: ["Light"]
mastery: "Nick"
---

# Sickle
*Simple Melee Weapon*

- **Cost:** 1 GP
- **Weight:** 2 lb.

**Damage:** 1d4 Slashing

**Properties:** Light

**Mastery:** Nick
`,
      "Sling.md": `---
smType: equipment
name: "Sling"
type: "weapon"
cost: "1 SP"
weight: "\u2014"
weapon_category: "Simple"
weapon_type: "Ranged"
damage: "1d4 Bludgeoning"
properties: ["Ammunition (Range 30/120; Bullet)"]
mastery: "Slow"
---

# Sling
*Simple Ranged Weapon*

- **Cost:** 1 SP
- **Weight:** \u2014

**Damage:** 1d4 Bludgeoning

**Properties:** Ammunition (Range 30/120; Bullet)

**Mastery:** Slow
`,
      "Spear.md": `---
smType: equipment
name: "Spear"
type: "weapon"
cost: "1 GP"
weight: "3 lb."
weapon_category: "Simple"
weapon_type: "Melee"
damage: "1d6 Piercing"
properties: ["Thrown (Range 20/60)", "Versatile (1d8)"]
mastery: "Sap"
---

# Spear
*Simple Melee Weapon*

- **Cost:** 1 GP
- **Weight:** 3 lb.

**Damage:** 1d6 Piercing

**Properties:** Thrown (Range 20/60), Versatile (1d8)

**Mastery:** Sap
`,
      "Trident.md": `---
smType: equipment
name: "Trident"
type: "weapon"
cost: "5 GP"
weight: "4 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d8 Piercing"
properties: ["Thrown (Range 20/60)", "Versatile (1d10)"]
mastery: "Topple"
---

# Trident
*Martial Melee Weapon*

- **Cost:** 5 GP
- **Weight:** 4 lb.

**Damage:** 1d8 Piercing

**Properties:** Thrown (Range 20/60), Versatile (1d10)

**Mastery:** Topple
`,
      "War Pick.md": `---
smType: equipment
name: "War Pick"
type: "weapon"
cost: "5 GP"
weight: "2 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d8 Piercing"
properties: ["Versatile (1d10)"]
mastery: "Sap"
---

# War Pick
*Martial Melee Weapon*

- **Cost:** 5 GP
- **Weight:** 2 lb.

**Damage:** 1d8 Piercing

**Properties:** Versatile (1d10)

**Mastery:** Sap
`,
      "Warhammer.md": `---
smType: equipment
name: "Warhammer"
type: "weapon"
cost: "15 GP"
weight: "5 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d8 Bludgeoning"
properties: ["Versatile (1d10)"]
mastery: "Push"
---

# Warhammer
*Martial Melee Weapon*

- **Cost:** 15 GP
- **Weight:** 5 lb.

**Damage:** 1d8 Bludgeoning

**Properties:** Versatile (1d10)

**Mastery:** Push
`,
      "Whip.md": `---
smType: equipment
name: "Whip"
type: "weapon"
cost: "2 GP"
weight: "3 lb."
weapon_category: "Martial"
weapon_type: "Melee"
damage: "1d4 Slashing"
properties: ["Finesse", "Reach"]
mastery: "Slow"
---

# Whip
*Martial Melee Weapon*

- **Cost:** 2 GP
- **Weight:** 3 lb.

**Damage:** 1d4 Slashing

**Properties:** Finesse, Reach

**Mastery:** Slow
`
    };
  }
});

// src/apps/library/core/plugin-presets.ts
var plugin_presets_exports = {};
__export(plugin_presets_exports, {
  importEquipmentPresets: () => importEquipmentPresets,
  importItemPresets: () => importItemPresets,
  importPluginPresets: () => importPluginPresets,
  importSpellPresets: () => importSpellPresets,
  registerPreset: () => registerPreset,
  shouldImportEquipmentPresets: () => shouldImportEquipmentPresets,
  shouldImportItemPresets: () => shouldImportItemPresets,
  shouldImportPluginPresets: () => shouldImportPluginPresets,
  shouldImportSpellPresets: () => shouldImportSpellPresets
});
function registerPreset(fileName, content) {
  PRESET_FILES[fileName] = content;
}
async function importPresetsForDir(app, dir, presetKey, typeName, ensureDir2) {
  try {
    await ensureDir2(app);
    const presetModule = await Promise.resolve().then(() => (init_preset_data(), preset_data_exports));
    const presetFiles = presetModule[presetKey] || {};
    const fileNames = Object.keys(presetFiles);
    if (fileNames.length === 0) {
      console.log(`No preset ${typeName} found in plugin`);
      return;
    }
    console.log(`Found ${fileNames.length} preset ${typeName} in plugin`);
    const existingFiles = /* @__PURE__ */ new Set();
    try {
      const existing = await app.vault.adapter.list(dir);
      existing.files.forEach((file) => {
        const fileName = file.split("/").pop()?.toLowerCase();
        if (fileName) existingFiles.add(fileName);
      });
    } catch {
    }
    let importedCount = 0;
    let skippedCount = 0;
    let errorCount = 0;
    for (const fileName of fileNames) {
      const targetPath = (0, import_obsidian34.normalizePath)(`${dir}/${fileName}`);
      if (existingFiles.has(fileName.toLowerCase())) {
        skippedCount++;
        continue;
      }
      try {
        const content = presetFiles[fileName];
        await app.vault.create(targetPath, content);
        importedCount++;
        console.log(`Imported ${typeName} preset: ${fileName}`);
      } catch (err) {
        console.error(`Failed to import ${typeName} preset ${fileName}:`, err);
        errorCount++;
      }
    }
    if (importedCount > 0) {
      new import_obsidian34.Notice(`Imported ${importedCount} ${typeName} presets`);
      console.log(`${typeName} import complete: ${importedCount} imported, ${skippedCount} skipped, ${errorCount} errors`);
    } else if (skippedCount > 0) {
      console.log(`All ${skippedCount} ${typeName} presets already exist`);
    } else if (errorCount > 0) {
      new import_obsidian34.Notice(`Failed to import ${typeName} presets. Check console for details.`);
    }
  } catch (err) {
    console.error(`Failed to import ${typeName} presets:`, err);
    if (err instanceof Error && err.message.includes("Cannot find module")) {
      console.log(`No ${typeName} preset data found - skipping import`);
    } else {
      new import_obsidian34.Notice(`Failed to import ${typeName} presets. Check console for details.`);
    }
  }
}
async function importPluginPresets(app) {
  return importPresetsForDir(app, CREATURES_DIR, "PRESET_CREATURES", "creature", ensureCreatureDir);
}
async function shouldImportPresetsForDir(app, dir, markerName, label, ensureDir2) {
  const markerPath = `${dir}/${markerName}`;
  const markerFile = app.vault.getAbstractFileByPath(markerPath);
  if (markerFile) {
    return false;
  }
  try {
    await ensureDir2(app);
    await app.vault.create(markerPath, `${label} imported on ${(/* @__PURE__ */ new Date()).toISOString()}`);
  } catch (err) {
    console.error(`Failed to create ${label} marker:`, err);
  }
  return true;
}
async function shouldImportPluginPresets(app) {
  return shouldImportPresetsForDir(app, CREATURES_DIR, ".plugin-presets-imported", "Plugin presets", ensureCreatureDir);
}
async function importSpellPresets(app) {
  return importPresetsForDir(app, SPELLS_DIR, "PRESET_SPELLS", "spell", ensureSpellDir);
}
async function shouldImportSpellPresets(app) {
  return shouldImportPresetsForDir(app, SPELLS_DIR, ".plugin-spells-imported", "Spell presets", ensureSpellDir);
}
async function importItemPresets(app) {
  return importPresetsForDir(app, ITEMS_DIR, "PRESET_ITEMS", "item", ensureItemDir);
}
async function shouldImportItemPresets(app) {
  return shouldImportPresetsForDir(app, ITEMS_DIR, ".plugin-items-imported", "Item presets", ensureItemDir);
}
async function importEquipmentPresets(app) {
  return importPresetsForDir(app, EQUIPMENT_DIR, "PRESET_EQUIPMENT", "equipment", ensureEquipmentDir);
}
async function shouldImportEquipmentPresets(app) {
  return shouldImportPresetsForDir(app, EQUIPMENT_DIR, ".plugin-equipment-imported", "Equipment presets", ensureEquipmentDir);
}
var import_obsidian34, PRESET_FILES;
var init_plugin_presets = __esm({
  "src/apps/library/core/plugin-presets.ts"() {
    "use strict";
    import_obsidian34 = require("obsidian");
    init_creature_files();
    init_spell_files();
    init_item_files();
    init_equipment_files();
    PRESET_FILES = {};
  }
});

// src/apps/library/core/index-files.ts
var index_files_exports = {};
__export(index_files_exports, {
  generateAllIndexes: () => generateAllIndexes,
  generateCreaturesIndex: () => generateCreaturesIndex,
  generateEquipmentIndex: () => generateEquipmentIndex,
  generateItemsIndex: () => generateItemsIndex,
  generateLibraryHub: () => generateLibraryHub,
  generateSpellsIndex: () => generateSpellsIndex
});
async function createIndexFile(app, filePath, title, description, directory) {
  const folder = app.vault.getAbstractFileByPath(directory);
  if (!(folder instanceof import_obsidian35.TFolder)) {
    console.log(`[Index] Directory ${directory} not found, skipping index generation`);
    return;
  }
  const files = [];
  const collectFiles = (folder2) => {
    for (const child of folder2.children) {
      if (child instanceof import_obsidian35.TFile && child.extension === "md") {
        files.push(child);
      } else if (child instanceof import_obsidian35.TFolder) {
        collectFiles(child);
      }
    }
  };
  collectFiles(folder);
  files.sort((a, b) => a.basename.localeCompare(b.basename));
  const lines = [];
  lines.push(`# ${title}`);
  lines.push("");
  lines.push(description);
  lines.push("");
  lines.push(`**Total:** ${files.length} entries`);
  lines.push("");
  const groups = /* @__PURE__ */ new Map();
  for (const file of files) {
    const relativePath = file.path.substring(directory.length + 1);
    const slashIndex = relativePath.indexOf("/");
    const group = slashIndex !== -1 ? relativePath.substring(0, slashIndex) : "Other";
    if (!groups.has(group)) {
      groups.set(group, []);
    }
    groups.get(group).push(file);
  }
  const sortedGroups = Array.from(groups.entries()).sort((a, b) => a[0].localeCompare(b[0]));
  for (const [groupName, groupFiles] of sortedGroups) {
    if (sortedGroups.length > 1 && groupName !== "Other") {
      lines.push(`## ${groupName}`);
      lines.push("");
    }
    for (const file of groupFiles) {
      lines.push(`- [[${file.basename}]]`);
    }
    lines.push("");
  }
  const content = lines.join("\n");
  const existingFile = app.vault.getAbstractFileByPath(filePath);
  if (existingFile instanceof import_obsidian35.TFile) {
    await app.vault.modify(existingFile, content);
  } else {
    await app.vault.create(filePath, content);
  }
}
async function generateCreaturesIndex(app) {
  await createIndexFile(
    app,
    `${SALTMARCHER_DIR}/Creatures.md`,
    "Creatures",
    "Index of all creatures in the library.",
    CREATURES_DIR2
  );
}
async function generateEquipmentIndex(app) {
  await createIndexFile(
    app,
    `${SALTMARCHER_DIR}/Equipment.md`,
    "Equipment",
    "Index of all equipment in the library.",
    EQUIPMENT_DIR2
  );
}
async function generateSpellsIndex(app) {
  await createIndexFile(
    app,
    `${SALTMARCHER_DIR}/Spells.md`,
    "Spells",
    "Index of all spells in the library.",
    SPELLS_DIR2
  );
}
async function generateItemsIndex(app) {
  await createIndexFile(
    app,
    `${SALTMARCHER_DIR}/Items.md`,
    "Items",
    "Index of all magic items in the library.",
    ITEMS_DIR2
  );
}
async function generateLibraryHub(app) {
  const lines = [];
  lines.push("# Library");
  lines.push("");
  lines.push("Central hub for all Salt Marcher library content.");
  lines.push("");
  lines.push("## Categories");
  lines.push("");
  lines.push("- [[Creatures]] - Monsters, animals, and NPCs");
  lines.push("- [[Equipment]] - Weapons, armor, tools, and adventuring gear");
  lines.push("- [[Spells]] - Spell compendium");
  lines.push("- [[Items]] - Magic items and artifacts");
  lines.push("");
  const content = lines.join("\n");
  const filePath = `${SALTMARCHER_DIR}/Library.md`;
  const existingFile = app.vault.getAbstractFileByPath(filePath);
  if (existingFile instanceof import_obsidian35.TFile) {
    await app.vault.modify(existingFile, content);
  } else {
    await app.vault.create(filePath, content);
  }
}
async function generateAllIndexes(app) {
  console.log("[Index] Generating all library indexes...");
  const saltmarcherFolder = app.vault.getAbstractFileByPath(SALTMARCHER_DIR);
  if (!saltmarcherFolder) {
    await app.vault.createFolder(SALTMARCHER_DIR);
  }
  await Promise.all([
    generateCreaturesIndex(app),
    generateEquipmentIndex(app),
    generateSpellsIndex(app),
    generateItemsIndex(app),
    generateLibraryHub(app)
  ]);
  console.log("[Index] All indexes generated successfully");
}
var import_obsidian35, SALTMARCHER_DIR, CREATURES_DIR2, EQUIPMENT_DIR2, SPELLS_DIR2, ITEMS_DIR2;
var init_index_files = __esm({
  "src/apps/library/core/index-files.ts"() {
    "use strict";
    import_obsidian35 = require("obsidian");
    SALTMARCHER_DIR = "SaltMarcher";
    CREATURES_DIR2 = "SaltMarcher/Creatures";
    EQUIPMENT_DIR2 = "SaltMarcher/Equipment";
    SPELLS_DIR2 = "SaltMarcher/Spells";
    ITEMS_DIR2 = "SaltMarcher/Items";
  }
});

// src/apps/library/tools/parsers/reference-parser.ts
function parseReferenceStatblock(markdown) {
  const lines = markdown.split("\n").map((line) => line.trim());
  const data = { name: "" };
  data.name = extractH1(lines);
  const subtitle = extractSubtitle(lines);
  if (subtitle) {
    const parsed = parseSubtitle(subtitle);
    data.size = parsed.size;
    data.type = parsed.type;
    data.typeTags = parsed.typeTags;
    data.alignmentLawChaos = parsed.alignmentLawChaos;
    data.alignmentGoodEvil = parsed.alignmentGoodEvil;
    data.alignmentOverride = parsed.alignmentOverride;
  }
  const bullets = extractBulletStats(lines);
  data.ac = bullets.get("armor class");
  const initiativeText = bullets.get("initiative");
  if (initiativeText) {
    const match = initiativeText.match(/^([+\-]?\d+)/);
    data.initiative = match ? match[1] : initiativeText;
  }
  const hpText = bullets.get("hit points");
  if (hpText) {
    const { hp, hitDice } = parseHitPoints(hpText);
    data.hp = hp;
    data.hitDice = hitDice;
  }
  const speedText = bullets.get("speed");
  if (speedText) {
    data.speeds = parseSpeed(speedText);
  }
  const skillsText = bullets.get("skills");
  if (skillsText) {
    data.skillsProf = parseSkills(skillsText);
  }
  const sensesText = bullets.get("senses");
  if (sensesText) {
    const { senses, passives } = parseSenses(sensesText);
    data.sensesList = senses;
    data.passivesList = passives;
  }
  const languagesText = bullets.get("languages");
  if (languagesText) {
    data.languagesList = parseList(languagesText);
  }
  const gearText = bullets.get("gear");
  if (gearText) {
    data.gearList = parseList(gearText);
  }
  const immunitiesText = bullets.get("immunities");
  if (immunitiesText) {
    data.damageImmunitiesList = parseList(immunitiesText);
  }
  const resistancesText = bullets.get("resistances");
  if (resistancesText) {
    data.damageResistancesList = parseList(resistancesText);
  }
  const vulnerabilitiesText = bullets.get("vulnerabilities");
  if (vulnerabilitiesText) {
    data.damageVulnerabilitiesList = parseList(vulnerabilitiesText);
  }
  const crText = bullets.get("cr");
  if (crText) {
    const { cr, xp, pb } = parseCRLine(crText);
    data.cr = cr;
    data.xp = xp;
    data.pb = pb || calculatePBFromCR2(cr);
  }
  const abilityTable = extractAbilityTable(lines);
  if (abilityTable) {
    data.str = abilityTable.str.score;
    data.dex = abilityTable.dex.score;
    data.con = abilityTable.con.score;
    data.int = abilityTable.int.score;
    data.wis = abilityTable.wis.score;
    data.cha = abilityTable.cha.score;
    data.saveProf = determineSaveProficiencies(abilityTable, data.pb);
  }
  const sections = extractSections(lines);
  data.entries = parseSections(sections, data);
  data.spellcasting = extractSpellcasting(data.entries || []);
  return data;
}
function extractH1(lines) {
  for (const line of lines) {
    const match = line.match(/^#\s+(.+)$/);
    if (match) return match[1].trim();
  }
  return "Unknown Creature";
}
function extractSubtitle(lines) {
  for (const line of lines) {
    const match = line.match(/^\*(.+)\*$/);
    if (match) return match[1].trim();
  }
  return null;
}
function parseSubtitle(subtitle) {
  const parts = subtitle.split(",").map((p) => p.trim());
  if (parts.length === 0) return {};
  const firstPart = parts[0];
  const secondPart = parts[1];
  const result = {};
  const typeMatch = firstPart.match(/^(\w+)\s+(.+)$/);
  if (typeMatch) {
    result.size = typeMatch[1];
    const typeWithTags = typeMatch[2];
    const tagMatch = typeWithTags.match(/^(.+?)\s*\((.+)\)$/);
    if (tagMatch) {
      result.type = tagMatch[1].trim();
      result.typeTags = tagMatch[2].split(",").map((t) => t.trim());
    } else {
      result.type = typeWithTags;
    }
  }
  if (secondPart) {
    const alignment = parseAlignment2(secondPart);
    result.alignmentLawChaos = alignment.lawChaos;
    result.alignmentGoodEvil = alignment.goodEvil;
    result.alignmentOverride = alignment.override;
  }
  return result;
}
function parseAlignment2(text) {
  const normalized = text.toLowerCase().trim();
  if (normalized === "unaligned" || normalized === "any alignment") {
    return { override: text };
  }
  if (normalized === "neutral") {
    return { lawChaos: "Neutral", goodEvil: "Neutral" };
  }
  const words = text.split(/\s+/);
  if (words.length === 2) {
    return { lawChaos: words[0], goodEvil: words[1] };
  } else if (words.length === 1) {
    const word = words[0];
    if (["Good", "Evil"].includes(word)) {
      return { goodEvil: word };
    } else if (["Lawful", "Chaotic"].includes(word)) {
      return { lawChaos: word };
    }
  }
  return { override: text };
}
function extractBulletStats(lines) {
  const stats = /* @__PURE__ */ new Map();
  for (const line of lines) {
    let match = line.match(/^-?\s*\*\*(.+?):\*\*\s*(.+)$/);
    if (match) {
      const label = match[1].toLowerCase().trim();
      const value = match[2].trim();
      stats.set(label, value);
      continue;
    }
    match = line.match(/^-?\s*\*\*(.+?)\*\*:?\s+(.+)$/);
    if (match) {
      const label = match[1].toLowerCase().trim();
      const value = match[2].trim();
      stats.set(label, value);
    }
  }
  return stats;
}
function parseHitPoints(text) {
  const match = text.match(/^(\d+)\s*(?:\((.+?)\))?/);
  if (match) {
    return {
      hp: match[1],
      hitDice: match[2] || void 0
    };
  }
  return { hp: text };
}
function parseSpeed(text) {
  const speeds = {};
  const parts = text.split(",").map((p) => p.trim());
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    if (i === 0 && !part.match(/^(walk|climb|fly|swim|burrow)/i)) {
      const match2 = part.match(/^(\d+\s*ft\.?)/);
      if (match2) {
        speeds.walk = { distance: match2[1] };
      }
      continue;
    }
    const match = part.match(/^(walk|climb|fly|swim|burrow)\s+(\d+\s*ft\.?)(\s*\(hover\))?/i);
    if (match) {
      const type = match[1].toLowerCase();
      const distance = match[2];
      const hover = !!match[3];
      if (type === "walk" || type === "climb" || type === "fly" || type === "swim" || type === "burrow") {
        speeds[type] = { distance };
        if (type === "fly" && hover) {
          speeds.fly.hover = true;
        }
      }
    }
  }
  return speeds;
}
function parseSkills(text) {
  const skills = [];
  const parts = text.split(",").map((p) => p.trim());
  for (const part of parts) {
    const match = part.match(/^(.+?)\s+[+\-]\d+/);
    if (match) {
      skills.push(match[1].trim());
    }
  }
  return skills;
}
function parseSenses(text) {
  const parts = text.split(";").map((p) => p.trim());
  const senses = [];
  const passives = [];
  for (const part of parts) {
    if (part.toLowerCase().startsWith("passive")) {
      passives.push(part);
    } else if (part) {
      senses.push(...part.split(",").map((s) => s.trim()).filter(Boolean));
    }
  }
  return { senses, passives };
}
function parseList(text) {
  return text.split(/[,;]/).map((item) => item.trim()).filter(Boolean);
}
function parseCRLine(text) {
  const result = {};
  const crMatch = text.match(/^([\d/]+)/);
  if (crMatch) {
    result.cr = crMatch[1];
  }
  const xpMatch = text.match(/XP\s+([\d,]+)/);
  if (xpMatch) {
    result.xp = xpMatch[1].replace(/,/g, "");
  }
  const pbMatch = text.match(/PB\s+([+\-]?\d+)/);
  if (pbMatch) {
    result.pb = pbMatch[1];
  }
  return result;
}
function calculatePBFromCR2(cr) {
  if (!cr) return void 0;
  let crValue;
  if (cr.includes("/")) {
    const [num, denom] = cr.split("/").map(Number);
    crValue = num / denom;
  } else {
    crValue = Number(cr);
  }
  if (isNaN(crValue)) return void 0;
  if (crValue <= 4) return "+2";
  if (crValue <= 8) return "+3";
  if (crValue <= 12) return "+4";
  if (crValue <= 16) return "+5";
  if (crValue <= 20) return "+6";
  if (crValue <= 24) return "+7";
  if (crValue <= 28) return "+8";
  return "+9";
}
function extractAbilityTable(lines) {
  let tableStart = -1;
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].includes("| STAT |") || lines[i].includes("|STAT|")) {
      tableStart = i;
      break;
    }
  }
  if (tableStart === -1) return null;
  const result = {};
  for (let i = tableStart + 2; i < tableStart + 8 && i < lines.length; i++) {
    const line = lines[i];
    const cells = line.split("|").map((c) => c.trim()).filter(Boolean);
    if (cells.length >= 4) {
      const stat = cells[0].toLowerCase();
      const score = cells[1];
      const mod2 = parseInt(cells[2].replace(/[+\-]/g, ""));
      const save = parseInt(cells[3].replace(/[+\-]/g, ""));
      if (["str", "dex", "con", "int", "wis", "cha"].includes(stat)) {
        result[stat] = { score, mod: mod2, save };
      }
    }
  }
  return result;
}
function determineSaveProficiencies(table, pb) {
  const proficiencies = {};
  const pbValue = pb ? parseInt(pb.replace(/[+\-]/g, "")) : 0;
  for (const [key, data] of Object.entries(table)) {
    if (Math.abs(data.save) > Math.abs(data.mod) + 0.5) {
      proficiencies[key] = true;
    }
  }
  return proficiencies;
}
function extractSections(lines) {
  const sections = [];
  let currentSection = null;
  for (const line of lines) {
    const headerMatch = line.match(/^###\s+(.+)$/);
    if (headerMatch) {
      if (currentSection) {
        sections.push(currentSection);
      }
      currentSection = {
        category: headerMatch[1].trim(),
        content: []
      };
    } else if (currentSection && line) {
      currentSection.content.push(line);
    }
  }
  if (currentSection) {
    sections.push(currentSection);
  }
  return sections;
}
function parseSections(sections, data) {
  const entries = [];
  const categoryMap = {
    "traits": "trait",
    "actions": "action",
    "bonus actions": "bonus",
    "reactions": "reaction",
    "legendary actions": "legendary"
  };
  for (const section of sections) {
    const category = categoryMap[section.category.toLowerCase()];
    if (!category) continue;
    const parsedEntries = parseEntries(section.content, category, data);
    entries.push(...parsedEntries);
  }
  return entries.length > 0 ? entries : void 0;
}
function parseEntries(lines, category, data) {
  const entries = [];
  let currentEntry = null;
  for (const line of lines) {
    const entryMatch = line.match(/^\*\*\*(.+?)\.\*\*\*(.*)$/);
    if (entryMatch) {
      if (currentEntry) {
        entries.push(currentEntry);
      }
      const nameAndRecharge = entryMatch[1];
      const rest = entryMatch[2].trim();
      const rechargeMatch = nameAndRecharge.match(/^(.+?)\s*\((Recharge\s+\d+-?\d*|\d+\/Day)\)$/i);
      const name = rechargeMatch ? rechargeMatch[1].trim() : nameAndRecharge.trim();
      const recharge = rechargeMatch ? rechargeMatch[2] : void 0;
      currentEntry = {
        category,
        name,
        recharge,
        text: rest
      };
    } else if (currentEntry && line) {
      currentEntry.text = (currentEntry.text ? currentEntry.text + " " : "") + line;
    }
  }
  if (currentEntry) {
    entries.push(currentEntry);
  }
  for (const entry of entries) {
    if (entry.text) {
      parseEntryDetails(entry, data);
    }
  }
  return entries;
}
function parseEntryDetails(entry, data) {
  if (!entry.text) return;
  const text = entry.text;
  const attackMatch = text.match(/\*(Melee|Ranged)\s+Attack\s+Roll:\*\s*([+\-]\d+),\s*(?:reach|range)\s+([^.]+)/i);
  if (attackMatch) {
    entry.kind = `${attackMatch[1]} Attack Roll`;
    entry.to_hit = attackMatch[2];
    entry.range = attackMatch[3].trim();
  }
  const targetMatch = text.match(/\b(one\s+(?:target|creature)|all\s+creatures?|each\s+creature\s+(?:in|within)[^.]*)/i);
  if (targetMatch) {
    entry.target = targetMatch[1].trim();
  }
  const damageMatch = text.match(/(\d+)\s*\(([^)]+)\)\s+(\w+)\s+damage/i);
  if (damageMatch) {
    entry.damage = `${damageMatch[1]} (${damageMatch[2]}) ${damageMatch[3]}`;
  }
  const saveMatch = text.match(/\*(\w+)\s+Saving\s+Throw\*:\s*DC\s+(\d+)/i);
  if (saveMatch) {
    entry.save_ability = saveMatch[1].substring(0, 3).toUpperCase();
    entry.save_dc = parseInt(saveMatch[2]);
  }
  const successMatch = text.match(/\*Success:\*\s*([^.*]+)/i);
  if (successMatch) {
    entry.save_effect = successMatch[1].trim();
  }
}
function extractSpellcasting(entries) {
  const spellcastingEntry = entries.find(
    (e) => e.category === "action" && e.name.toLowerCase().includes("spellcasting")
  );
  if (!spellcastingEntry || !spellcastingEntry.text) return void 0;
  const text = spellcastingEntry.text;
  const data = {
    title: spellcastingEntry.name,
    groups: []
  };
  const dcMatch = text.match(/spell\s+save\s+DC\s+(\d+)/i);
  if (dcMatch) {
    data.saveDcOverride = parseInt(dcMatch[1]);
  }
  const abilityMatch = text.match(/using\s+(\w+)\s+as\s+the\s+spellcasting\s+ability/i);
  if (abilityMatch) {
    const abilityName = abilityMatch[1].toLowerCase();
    const abilityMap = {
      "strength": "str",
      "dexterity": "dex",
      "constitution": "con",
      "intelligence": "int",
      "wisdom": "wis",
      "charisma": "cha"
    };
    data.ability = abilityMap[abilityName];
  }
  data.summary = text;
  return data;
}
var init_reference_parser = __esm({
  "src/apps/library/tools/parsers/reference-parser.ts"() {
    "use strict";
  }
});

// src/apps/library/tools/parsers/spell-reference-parser.ts
function parseReferenceSpell(markdown) {
  const lines = markdown.split("\n").map((line) => line.trim());
  const data = { name: "" };
  data.name = extractH4(lines);
  const subtitle = extractSubtitle2(lines);
  if (subtitle) {
    const parsed = parseSubtitle2(subtitle);
    data.level = parsed.level;
    data.school = parsed.school;
    data.classes = parsed.classes;
  }
  const stats = extractLabeledStats(lines);
  data.casting_time = stats.get("casting time");
  data.range = stats.get("range");
  data.duration = stats.get("duration");
  const componentsText = stats.get("components");
  if (componentsText) {
    const parsed = parseComponents(componentsText);
    data.components = parsed.components;
    data.materials = parsed.materials;
  }
  const { description, higherLevels } = extractDescription(lines);
  data.description = description;
  data.higher_levels = higherLevels;
  if (data.duration) {
    if (data.duration.toLowerCase().includes("concentration")) {
      data.concentration = true;
    }
    if (data.duration.toLowerCase().includes("ritual")) {
      data.ritual = true;
    }
  }
  if (data.casting_time?.toLowerCase().includes("ritual")) {
    data.ritual = true;
  }
  if (description) {
    const details = parseSpellDetails(description);
    if (details.save_ability) data.save_ability = details.save_ability;
    if (details.save_effect) data.save_effect = details.save_effect;
    if (details.attack) data.attack = details.attack;
    if (details.damage) data.damage = details.damage;
    if (details.damage_type) data.damage_type = details.damage_type;
  }
  return data;
}
function extractH4(lines) {
  for (const line of lines) {
    const match = line.match(/^####\s+(.+)$/);
    if (match) {
      return match[1].trim().replace(/^\*\*(.+)\*\*$/, "$1");
    }
  }
  return "Unknown Spell";
}
function extractSubtitle2(lines) {
  for (const line of lines) {
    const match = line.match(/^\*(.+)\*$/);
    if (match) return match[1].trim();
  }
  return null;
}
function parseSubtitle2(subtitle) {
  const result = {};
  const classMatch = subtitle.match(/\(([^)]+)\)$/);
  if (classMatch) {
    result.classes = classMatch[1].split(",").map((c) => c.trim());
  }
  const withoutClasses = subtitle.replace(/\s*\([^)]+\)$/, "").trim();
  if (withoutClasses.toLowerCase().includes("cantrip")) {
    result.level = 0;
    const schoolMatch = withoutClasses.match(/^(\w+)\s+Cantrip/i);
    if (schoolMatch) {
      result.school = schoolMatch[1];
    }
  } else {
    const levelMatch = withoutClasses.match(/Level\s+(\d+)\s+(\w+)/i);
    if (levelMatch) {
      result.level = parseInt(levelMatch[1]);
      result.school = levelMatch[2];
    }
  }
  return result;
}
function extractLabeledStats(lines) {
  const stats = /* @__PURE__ */ new Map();
  for (const line of lines) {
    const match = line.match(/^\*\*(.+?):\*\*\s*(.+)$/);
    if (match) {
      const label = match[1].toLowerCase().trim();
      const value = match[2].trim();
      stats.set(label, value);
    }
  }
  return stats;
}
function parseComponents(text) {
  const result = {};
  const components = [];
  if (text.includes("V")) components.push("V");
  if (text.includes("S")) components.push("S");
  if (text.includes("M")) components.push("M");
  if (components.length > 0) {
    result.components = components;
  }
  const materialMatch = text.match(/M\s*\(([^)]+)\)/);
  if (materialMatch) {
    result.materials = materialMatch[1].trim();
  }
  return result;
}
function extractDescription(lines) {
  let descriptionLines = [];
  let higherLevelLines = [];
  let inHigherLevels = false;
  let startCapturing = false;
  for (const line of lines) {
    if (line.startsWith("**Duration:")) {
      startCapturing = true;
      continue;
    }
    if (!startCapturing) continue;
    if (line.match(/\*\*_Using a Higher-Level Spell Slot\._\*\*/i) || line.match(/\*\*_Cantrip Upgrade\._\*\*/i)) {
      inHigherLevels = true;
      continue;
    }
    if (!inHigherLevels && descriptionLines.length === 0 && !line) continue;
    if (inHigherLevels && higherLevelLines.length === 0 && !line) continue;
    if (line.startsWith("####") || line.startsWith("###") || line.startsWith("##")) {
      break;
    }
    if (inHigherLevels) {
      if (line) higherLevelLines.push(line);
    } else {
      if (line) descriptionLines.push(line);
    }
  }
  const description = descriptionLines.join("\n\n").trim();
  const higherLevels = higherLevelLines.join("\n\n").trim();
  return {
    description: description || void 0,
    higher_levels: higherLevels || void 0
  };
}
function parseSpellDetails(description) {
  const result = {};
  const saveMatch = description.match(/\b(Strength|Dexterity|Constitution|Intelligence|Wisdom|Charisma)\s+saving\s+throw/i);
  if (saveMatch) {
    result.save_ability = saveMatch[1].substring(0, 3).toUpperCase();
  }
  if (description.toLowerCase().includes("half") && description.toLowerCase().includes("damage")) {
    result.save_effect = "Half damage on success";
  } else if (description.toLowerCase().includes("no effect on a successful save")) {
    result.save_effect = "No effect on success";
  }
  const attackMatch = description.match(/\b(ranged|melee)\s+spell\s+attack/i);
  if (attackMatch) {
    result.attack = `${attackMatch[1]} spell attack`;
  }
  const damageMatch = description.match(/(\d+d\d+(?:\s*[+\-]\s*\d+)?)\s+(\w+)\s+damage/i);
  if (damageMatch) {
    result.damage = damageMatch[1];
    result.damage_type = damageMatch[2];
  }
  return result;
}
var init_spell_reference_parser = __esm({
  "src/apps/library/tools/parsers/spell-reference-parser.ts"() {
    "use strict";
  }
});

// src/apps/library/tools/convert-references.ts
var convert_references_exports = {};
__export(convert_references_exports, {
  convertAllReferences: () => convertAllReferences,
  convertAllSpells: () => convertAllSpells,
  convertSpecificFiles: () => convertSpecificFiles
});
async function convertAllReferences(app, options = {}) {
  const { dryRun = false, limit, onProgress } = options;
  const result = {
    success: 0,
    failed: 0,
    skipped: 0,
    errors: []
  };
  const referenceFiles = await findReferenceFiles(app);
  if (referenceFiles.length === 0) {
    new import_obsidian36.Notice("Keine Reference Statbl\xF6cke gefunden");
    return result;
  }
  const filesToProcess = limit ? referenceFiles.slice(0, limit) : referenceFiles;
  new import_obsidian36.Notice(`Konvertiere ${filesToProcess.length} Statbl\xF6cke${dryRun ? " (Dry Run)" : ""}...`);
  if (!dryRun) {
    await ensureDir(app, CREATURES_PRESETS_DIR);
  }
  for (let i = 0; i < filesToProcess.length; i++) {
    const file = filesToProcess[i];
    onProgress?.(i + 1, filesToProcess.length, file.path);
    try {
      await convertFile(app, file, dryRun);
      result.success++;
    } catch (error) {
      result.failed++;
      result.errors.push({
        file: file.path,
        error: error instanceof Error ? error.message : String(error)
      });
      console.error(`Fehler beim Konvertieren von ${file.path}:`, error);
    }
  }
  const summary = `Konvertierung abgeschlossen: ${result.success} erfolgreich, ${result.failed} fehlgeschlagen`;
  new import_obsidian36.Notice(summary);
  console.log(summary);
  if (result.errors.length > 0) {
    console.log("Fehler:", result.errors);
  }
  return result;
}
async function convertFile(app, file, dryRun) {
  const content = await app.vault.read(file);
  const statblockData = parseReferenceStatblock(content);
  const presetMarkdown = statblockToMarkdown(statblockData);
  const relativePath = file.path.replace(`${CREATURES_REFERENCES_DIR}/`, "");
  const targetPath = `${CREATURES_PRESETS_DIR}/${relativePath}`;
  if (dryRun) {
    console.log(`[DRY RUN] W\xFCrde konvertieren: ${file.path} -> ${targetPath}`);
    return;
  }
  const targetDir = targetPath.substring(0, targetPath.lastIndexOf("/"));
  await ensureDir(app, targetDir);
  const existingFile = app.vault.getAbstractFileByPath(targetPath);
  if (existingFile) {
    await app.vault.modify(existingFile, presetMarkdown);
  } else {
    await app.vault.create(targetPath, presetMarkdown);
  }
}
async function findReferenceFiles(app) {
  const files = [];
  const traverse = (folderPath) => {
    const folder = app.vault.getAbstractFileByPath(folderPath);
    if (!folder) return;
    if ("children" in folder) {
      for (const child of folder.children) {
        if ("children" in child) {
          traverse(child.path);
        } else if (child.path.endsWith(".md")) {
          files.push(child);
        }
      }
    }
  };
  traverse(CREATURES_REFERENCES_DIR);
  return files;
}
async function ensureDir(app, path) {
  const exists = app.vault.getAbstractFileByPath(path);
  if (!exists) {
    await app.vault.createFolder(path);
  }
}
async function convertSpecificFiles(app, filePaths, dryRun = false) {
  const result = {
    success: 0,
    failed: 0,
    skipped: 0,
    errors: []
  };
  if (!dryRun) {
    await ensureDir(app, CREATURES_PRESETS_DIR);
  }
  for (const filePath of filePaths) {
    const file = app.vault.getAbstractFileByPath(filePath);
    if (!file || !("extension" in file) || file.extension !== "md") {
      result.skipped++;
      continue;
    }
    try {
      await convertFile(app, file, dryRun);
      result.success++;
    } catch (error) {
      result.failed++;
      result.errors.push({
        file: filePath,
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  return result;
}
async function convertAllSpells(app, options = {}) {
  const { dryRun = false, limit, onProgress } = options;
  const result = {
    success: 0,
    failed: 0,
    skipped: 0,
    errors: []
  };
  const spellsFile = app.vault.getAbstractFileByPath(SPELLS_REFERENCES_FILE);
  if (!spellsFile || !("extension" in spellsFile)) {
    new import_obsidian36.Notice("Spells Reference Datei nicht gefunden");
    return result;
  }
  const content = await app.vault.read(spellsFile);
  const spellSections = extractSpellSections(content);
  if (spellSections.length === 0) {
    new import_obsidian36.Notice("Keine Spells in Reference Datei gefunden");
    return result;
  }
  const sectionsToProcess = limit ? spellSections.slice(0, limit) : spellSections;
  new import_obsidian36.Notice(`Konvertiere ${sectionsToProcess.length} Spells${dryRun ? " (Dry Run)" : ""}...`);
  if (!dryRun) {
    await ensureDir(app, SPELLS_PRESETS_DIR);
  }
  for (let i = 0; i < sectionsToProcess.length; i++) {
    const spellMarkdown = sectionsToProcess[i];
    onProgress?.(i + 1, sectionsToProcess.length, spellMarkdown.split("\n")[0]);
    try {
      await convertSpellSection(app, spellMarkdown, dryRun);
      result.success++;
    } catch (error) {
      result.failed++;
      result.errors.push({
        file: `Spell ${i + 1}`,
        error: error instanceof Error ? error.message : String(error)
      });
      console.error(`Fehler beim Konvertieren von Spell:`, error);
    }
  }
  const summary = `Spell-Konvertierung abgeschlossen: ${result.success} erfolgreich, ${result.failed} fehlgeschlagen`;
  new import_obsidian36.Notice(summary);
  console.log(summary);
  if (result.errors.length > 0) {
    console.log("Fehler:", result.errors);
  }
  return result;
}
function extractSpellSections(content) {
  const sections = [];
  const lines = content.split("\n");
  let currentSection = [];
  for (const line of lines) {
    if (line.startsWith("####")) {
      if (currentSection.length > 0) {
        sections.push(currentSection.join("\n"));
      }
      currentSection = [line];
    } else if (currentSection.length > 0) {
      currentSection.push(line);
    }
  }
  if (currentSection.length > 0) {
    sections.push(currentSection.join("\n"));
  }
  return sections;
}
async function convertSpellSection(app, spellMarkdown, dryRun) {
  const spellData = parseReferenceSpell(spellMarkdown);
  const presetMarkdown = spellToMarkdown(spellData);
  const fileName = spellData.name.replace(/[\\/:*?"<>|]/g, "-") + ".md";
  const targetPath = `${SPELLS_PRESETS_DIR}/${fileName}`;
  if (dryRun) {
    console.log(`[DRY RUN] W\xFCrde konvertieren: ${spellData.name} -> ${targetPath}`);
    return;
  }
  const existingFile = app.vault.getAbstractFileByPath(targetPath);
  if (existingFile) {
    await app.vault.modify(existingFile, presetMarkdown);
  } else {
    await app.vault.create(targetPath, presetMarkdown);
  }
}
var import_obsidian36, CREATURES_REFERENCES_DIR, CREATURES_PRESETS_DIR, SPELLS_REFERENCES_FILE, SPELLS_PRESETS_DIR;
var init_convert_references = __esm({
  "src/apps/library/tools/convert-references.ts"() {
    "use strict";
    init_reference_parser();
    init_spell_reference_parser();
    init_creature_files();
    init_spell_files();
    import_obsidian36 = require("obsidian");
    CREATURES_REFERENCES_DIR = "References/rulebooks/Statblocks/Creatures";
    CREATURES_PRESETS_DIR = "SaltMarcher/Presets/Creatures";
    SPELLS_REFERENCES_FILE = "References/rulebooks/Spells/07_Spells.md";
    SPELLS_PRESETS_DIR = "SaltMarcher/Presets/Spells";
  }
});

// src/app/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SaltMarcherPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian37 = require("obsidian");

// src/apps/cartographer/index.ts
var import_obsidian17 = require("obsidian");

// src/apps/cartographer/controller.ts
var import_obsidian16 = require("obsidian");
init_options();
init_map_list();

// src/apps/cartographer/travel/ui/map-layer.ts
init_hex_render();
var keyOf3 = (r, c) => `${r},${c}`;
async function createMapLayer(app, host, mapFile, opts) {
  const handles = await renderHexMap(app, host, opts, mapFile.path);
  const polyToCoord = /* @__PURE__ */ new WeakMap();
  for (const [k, poly] of handles.polyByCoord) {
    if (!poly) continue;
    const [r, c] = k.split(",").map(Number);
    polyToCoord.set(poly, { r, c });
  }
  const ensureHandlesPolys = typeof handles.ensurePolys === "function" ? (coords) => handles.ensurePolys(coords) : null;
  function ensurePolys(coords) {
    ensureHandlesPolys?.(coords);
    for (const rc of coords) {
      const poly = handles.polyByCoord.get(keyOf3(rc.r, rc.c));
      if (poly) polyToCoord.set(poly, rc);
    }
  }
  function centerOf(rc) {
    let poly = handles.polyByCoord.get(keyOf3(rc.r, rc.c));
    if (!poly) {
      ensurePolys([rc]);
      poly = handles.polyByCoord.get(keyOf3(rc.r, rc.c));
      if (!poly) return null;
    }
    const bb = poly.getBBox();
    return { x: bb.x + bb.width / 2, y: bb.y + bb.height / 2 };
  }
  function destroy() {
    try {
      handles.destroy?.();
    } catch {
    }
  }
  return { handles, polyToCoord, ensurePolys, centerOf, destroy };
}

// src/ui/map-manager.ts
var import_obsidian7 = require("obsidian");
init_map_workflows();

// src/ui/confirm-delete.ts
var import_obsidian6 = require("obsidian");
init_copy();
var ConfirmDeleteModal = class extends import_obsidian6.Modal {
  constructor(app, mapFile, onConfirm) {
    super(app);
    this.mapFile = mapFile;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const name = this.mapFile.basename;
    contentEl.createEl("h3", { text: CONFIRM_DELETE_COPY.title });
    const message = contentEl.createEl("p");
    message.textContent = CONFIRM_DELETE_COPY.body(name);
    const input = contentEl.createEl("input", {
      attr: {
        type: "text",
        placeholder: CONFIRM_DELETE_COPY.inputPlaceholder(name),
        style: "width:100%;"
      }
    });
    const btnRow = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = btnRow.createEl("button", { text: CONFIRM_DELETE_COPY.buttons.cancel });
    const confirmBtn = btnRow.createEl("button", { text: CONFIRM_DELETE_COPY.buttons.confirm });
    (0, import_obsidian6.setIcon)(confirmBtn, "trash");
    confirmBtn.classList.add("mod-warning");
    confirmBtn.disabled = true;
    input.addEventListener("input", () => {
      confirmBtn.disabled = input.value.trim() !== name;
    });
    cancelBtn.onclick = () => this.close();
    confirmBtn.onclick = async () => {
      confirmBtn.disabled = true;
      try {
        await this.onConfirm();
        new import_obsidian6.Notice(CONFIRM_DELETE_COPY.notices.success);
      } catch (e) {
        console.error(e);
        new import_obsidian6.Notice(CONFIRM_DELETE_COPY.notices.error);
      } finally {
        this.close();
      }
    };
    setTimeout(() => input.focus(), 0);
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/core/map-delete.ts
init_hex_notes();
async function deleteMapAndTiles(app, mapFile) {
  const tiles = await listTilesForMap(app, mapFile);
  for (const t of tiles) {
    try {
      await app.vault.delete(t.file);
    } catch (e) {
      console.warn("Delete tile failed:", t.file.path, e);
    }
  }
  try {
    await app.vault.delete(mapFile);
  } catch (e) {
    console.warn("Delete map failed:", mapFile.path, e);
  }
}

// src/ui/map-manager.ts
var MAP_MANAGER_COPY = {
  notices: {
    missingSelection: "Select a map before deleting.",
    deleteFailed: "Unable to delete the map. Check the developer console for details."
  },
  logs: {
    deleteFailed: "Map deletion failed"
  }
};
function createMapManager(app, options = {}) {
  const notices = {
    missingSelection: options.notices?.missingSelection ?? MAP_MANAGER_COPY.notices.missingSelection,
    deleteFailed: MAP_MANAGER_COPY.notices.deleteFailed
  };
  let current = options.initialFile ?? null;
  const applyChange = async (file) => {
    current = file;
    await options.onChange?.(file);
  };
  const setFile = async (file) => {
    await applyChange(file);
  };
  const open = async () => {
    await promptMapSelection(
      app,
      async (file) => {
        await applyChange(file);
      },
      options.selectOptions
    );
  };
  const create = () => {
    promptCreateMap(
      app,
      async (file) => {
        await applyChange(file);
      },
      options.createOptions
    );
  };
  const deleteCurrent = () => {
    const target = current;
    if (!target) {
      new import_obsidian7.Notice(notices.missingSelection);
      return;
    }
    new ConfirmDeleteModal(app, target, async () => {
      try {
        await deleteMapAndTiles(app, target);
        if (current && current.path === target.path) {
          await applyChange(null);
        }
      } catch (error) {
        console.error(MAP_MANAGER_COPY.logs.deleteFailed, error);
        new import_obsidian7.Notice(notices.deleteFailed);
      }
    }).open();
  };
  return {
    getFile: () => current,
    setFile,
    open,
    create,
    deleteCurrent
  };
}

// src/ui/map-header.ts
var import_obsidian8 = require("obsidian");
init_map_workflows();
init_search_dropdown();

// src/core/save.ts
async function saveMap(_app, file) {
  console.warn("[save] saveMap() not implemented. File:", file.path);
}
async function saveMapAs(_app, file) {
  console.warn("[save] saveMapAs() not implemented. File:", file.path);
}

// src/ui/map-header.ts
init_copy();
function createMapHeader(app, host, options) {
  const labels = {
    open: options.labels?.open ?? MAP_HEADER_COPY.labels.open,
    create: options.labels?.create ?? MAP_HEADER_COPY.labels.create,
    delete: options.labels?.delete ?? MAP_HEADER_COPY.labels.delete,
    save: options.labels?.save ?? MAP_HEADER_COPY.labels.save,
    saveAs: options.labels?.saveAs ?? MAP_HEADER_COPY.labels.saveAs,
    trigger: options.labels?.trigger ?? MAP_HEADER_COPY.labels.trigger
  };
  const notices = {
    missingFile: options.notices?.missingFile ?? MAP_HEADER_COPY.notices.missingFile,
    saveSuccess: options.notices?.saveSuccess ?? MAP_HEADER_COPY.notices.saveSuccess,
    saveError: options.notices?.saveError ?? MAP_HEADER_COPY.notices.saveError
  };
  let currentFile = options.initialFile ?? null;
  let destroyed = false;
  const root = host.createDiv({ cls: "sm-map-header" });
  root.classList.add("map-editor-header");
  Object.assign(root.style, { display: "flex", flexDirection: "column", gap: ".4rem" });
  const row1 = root.createDiv();
  Object.assign(row1.style, { display: "flex", alignItems: "center", gap: ".5rem" });
  const titleGroup = row1.createDiv({ cls: "sm-map-header__title-group" });
  Object.assign(titleGroup.style, {
    display: "flex",
    alignItems: "center",
    gap: ".5rem",
    marginRight: "auto"
  });
  const titleEl = titleGroup.createEl("h2", { text: options.title });
  Object.assign(titleEl.style, { margin: 0 });
  const titleRightSlot = titleGroup.createDiv({ cls: "sm-map-header__title-slot" });
  Object.assign(titleRightSlot.style, {
    display: "flex",
    alignItems: "center",
    gap: ".5rem"
  });
  if (options.titleRightSlot) {
    options.titleRightSlot(titleRightSlot);
  } else {
    titleRightSlot.style.display = "none";
  }
  const openBtn = row1.createEl("button", { text: labels.open });
  (0, import_obsidian8.setIcon)(openBtn, "folder-open");
  applyMapButtonStyle(openBtn);
  openBtn.onclick = () => {
    if (destroyed) return;
    void promptMapSelection(app, async (file) => {
      if (destroyed) return;
      setFileLabel(file);
      await options.onOpen?.(file);
    });
  };
  const createBtn = row1.createEl("button", { text: labels.create });
  (0, import_obsidian8.setIcon)(createBtn, "plus");
  applyMapButtonStyle(createBtn);
  createBtn.onclick = () => {
    if (destroyed) return;
    promptCreateMap(app, async (file) => {
      if (destroyed) return;
      setFileLabel(file);
      await options.onCreate?.(file);
    });
  };
  const deleteBtn = options.onDelete ? row1.createEl("button", { text: labels.delete, attr: { "aria-label": labels.delete } }) : null;
  if (deleteBtn) {
    (0, import_obsidian8.setIcon)(deleteBtn, "trash");
    applyMapButtonStyle(deleteBtn);
    deleteBtn.onclick = () => {
      if (destroyed) return;
      if (!currentFile) {
        new import_obsidian8.Notice(notices.missingFile);
        return;
      }
      void options.onDelete?.(currentFile);
    };
  }
  const row2 = root.createDiv();
  Object.assign(row2.style, { display: "flex", alignItems: "center", gap: ".5rem" });
  const secondaryLeftSlot = row2.createDiv({ cls: "sm-map-header__secondary-left" });
  Object.assign(secondaryLeftSlot.style, {
    marginRight: "auto",
    display: "flex",
    alignItems: "center",
    gap: ".5rem"
  });
  let nameBox = null;
  if (options.secondaryLeftSlot) {
    options.secondaryLeftSlot(secondaryLeftSlot);
  } else {
    nameBox = secondaryLeftSlot.createEl("div", {
      text: options.initialFile?.basename ?? options.emptyLabel ?? "\u2014"
    });
    nameBox.style.opacity = ".85";
  }
  const select = row2.createEl("select");
  select.createEl("option", { text: labels.save }).value = "save";
  select.createEl("option", { text: labels.saveAs }).value = "saveAs";
  enhanceSelectToSearch(select, MAP_HEADER_COPY.selectPlaceholder);
  const triggerBtn = row2.createEl("button", { text: labels.trigger });
  applyMapButtonStyle(triggerBtn);
  triggerBtn.onclick = async () => {
    if (destroyed) return;
    const mode = select.value ?? "save";
    const file = currentFile;
    if (!file) {
      await options.onSave?.(mode, null);
      new import_obsidian8.Notice(notices.missingFile);
      return;
    }
    try {
      const handled = await options.onSave?.(mode, file) === true;
      if (!handled) {
        if (mode === "save") await saveMap(app, file);
        else await saveMapAs(app, file);
      }
      new import_obsidian8.Notice(notices.saveSuccess);
    } catch (err) {
      console.error("[map-header] save failed", err);
      new import_obsidian8.Notice(notices.saveError);
    }
  };
  function setFileLabel(file) {
    currentFile = file;
    const label = file?.basename ?? options.emptyLabel ?? "\u2014";
    if (nameBox) {
      nameBox.textContent = label;
    }
    secondaryLeftSlot.dataset.fileLabel = label;
    if (deleteBtn) {
      deleteBtn.disabled = !file;
      deleteBtn.style.opacity = file ? "1" : "0.5";
    }
  }
  function setTitle(title) {
    titleEl.textContent = title;
  }
  function destroy() {
    if (destroyed) return;
    destroyed = true;
    openBtn.onclick = null;
    createBtn.onclick = null;
    triggerBtn.onclick = null;
    root.remove();
  }
  setFileLabel(currentFile);
  return { root, secondaryLeftSlot, titleRightSlot, setFileLabel, setTitle, destroy };
}

// src/ui/view-container.ts
var DEFAULT_CAMERA = {
  minScale: 0.25,
  maxScale: 4,
  zoomSpeed: 1.1
};
function createViewContainer(parent, options = {}) {
  const root = parent.createDiv({ cls: "sm-view-container" });
  if (options.className) root.addClass(options.className);
  const viewport = root.createDiv({ cls: "sm-view-container__viewport" });
  const stage = viewport.createDiv({ cls: "sm-view-container__stage" });
  const overlay = root.createDiv({ cls: "sm-view-container__overlay" });
  overlay.toggleClass("is-visible", false);
  let overlayMessageEl = null;
  const ensureOverlayMessage = () => {
    if (overlayMessageEl && overlayMessageEl.isConnected) return overlayMessageEl;
    overlay.empty();
    overlayMessageEl = overlay.createDiv({ cls: "sm-view-container__overlay-message" });
    return overlayMessageEl;
  };
  let cameraEnabled = options.camera !== false;
  const cameraConfig = {
    ...DEFAULT_CAMERA,
    ...typeof options.camera === "object" ? options.camera : {}
  };
  let camera = { x: 0, y: 0, scale: options.initialScale ?? 1 };
  const applyCamera = () => {
    stage.style.transform = `translate(${camera.x}px, ${camera.y}px) scale(${camera.scale})`;
  };
  applyCamera();
  let panPointer = null;
  let panStartX = 0;
  let panStartY = 0;
  let panOriginX = 0;
  let panOriginY = 0;
  const handlePointerDown = (ev) => {
    if (!cameraEnabled || ev.button !== 1) return;
    ev.preventDefault();
    ev.stopPropagation();
    panPointer = ev.pointerId;
    panStartX = ev.clientX;
    panStartY = ev.clientY;
    panOriginX = camera.x;
    panOriginY = camera.y;
    viewport.setPointerCapture(ev.pointerId);
    viewport.addClass("is-panning");
  };
  const handlePointerMove = (ev) => {
    if (panPointer === null || ev.pointerId !== panPointer) return;
    ev.preventDefault();
    ev.stopPropagation();
    const dx = ev.clientX - panStartX;
    const dy = ev.clientY - panStartY;
    camera = { ...camera, x: panOriginX + dx, y: panOriginY + dy };
    applyCamera();
  };
  const stopPan = (ev) => {
    if (panPointer === null) return;
    if (ev && ev.pointerId !== panPointer) return;
    if (ev) {
      ev.preventDefault();
      ev.stopPropagation();
      viewport.releasePointerCapture(ev.pointerId);
    }
    panPointer = null;
    viewport.removeClass("is-panning");
  };
  const handleWheel = (ev) => {
    if (!cameraEnabled) return;
    ev.preventDefault();
    ev.stopPropagation();
    const delta = ev.deltaY;
    const factor = Math.exp(-delta * 15e-4 * (cameraConfig.zoomSpeed ?? 1));
    const nextScale = Math.min(cameraConfig.maxScale, Math.max(cameraConfig.minScale, camera.scale * factor));
    if (Math.abs(nextScale - camera.scale) < 1e-4) return;
    const rect = viewport.getBoundingClientRect();
    const px = ev.clientX - rect.left;
    const py = ev.clientY - rect.top;
    const worldX = (px - camera.x) / camera.scale;
    const worldY = (py - camera.y) / camera.scale;
    camera = {
      scale: nextScale,
      x: px - worldX * nextScale,
      y: py - worldY * nextScale
    };
    applyCamera();
  };
  if (cameraEnabled) {
    viewport.style.touchAction = "none";
    viewport.addEventListener("pointerdown", handlePointerDown);
    viewport.addEventListener("pointermove", handlePointerMove);
    viewport.addEventListener("pointerup", stopPan);
    viewport.addEventListener("pointercancel", stopPan);
    viewport.addEventListener("pointerleave", stopPan);
    viewport.addEventListener("wheel", handleWheel, { passive: false });
  }
  const setOverlay = (message) => {
    if (!message) {
      overlay.toggleClass("is-visible", false);
      overlay.empty();
      overlayMessageEl = null;
      return;
    }
    const target = ensureOverlayMessage();
    target.setText(message);
    overlay.toggleClass("is-visible", true);
  };
  return {
    rootEl: root,
    viewportEl: viewport,
    stageEl: stage,
    overlayEl: overlay,
    setOverlay,
    clearOverlay() {
      setOverlay(null);
    },
    resetCamera() {
      camera = { x: 0, y: 0, scale: options.initialScale ?? 1 };
      applyCamera();
    },
    destroy() {
      stopPan();
      if (cameraEnabled) {
        viewport.removeEventListener("pointerdown", handlePointerDown);
        viewport.removeEventListener("pointermove", handlePointerMove);
        viewport.removeEventListener("pointerup", stopPan);
        viewport.removeEventListener("pointercancel", stopPan);
        viewport.removeEventListener("pointerleave", stopPan);
        viewport.removeEventListener("wheel", handleWheel);
      }
      root.remove();
    }
  };
}

// src/apps/cartographer/controller.ts
var DEFAULT_MODE_DESCRIPTORS = [
  {
    id: "travel",
    label: "Travel",
    async load() {
      const { createTravelGuideMode: createTravelGuideMode2 } = await Promise.resolve().then(() => (init_travel_guide(), travel_guide_exports));
      return createTravelGuideMode2();
    }
  },
  {
    id: "editor",
    label: "Editor",
    async load() {
      const { createEditorMode: createEditorMode2 } = await Promise.resolve().then(() => (init_editor(), editor_exports));
      return createEditorMode2();
    }
  },
  {
    id: "inspector",
    label: "Inspector",
    async load() {
      const { createInspectorMode: createInspectorMode2 } = await Promise.resolve().then(() => (init_inspector(), inspector_exports));
      return createInspectorMode2();
    }
  }
];
var createDefaultDeps = (app) => ({
  createMapManager: (appInstance, options) => createMapManager(appInstance, options),
  createMapLayer: (appInstance, host, file, opts) => createMapLayer(appInstance, host, file, opts),
  loadHexOptions: async (appInstance, file) => {
    const block = await getFirstHexBlock(appInstance, file);
    return block ? parseOptions(block) : null;
  },
  modeDescriptors: DEFAULT_MODE_DESCRIPTORS
});
var MODE_PROVISION_OVERLAY_MESSAGE = "Cartographer-Modi konnten nicht geladen werden.";
var MODE_PROVISION_NOTICE_MESSAGE = "Cartographer-Modi konnten nicht geladen werden. Bitte die Konsole pr\xFCfen.";
var CartographerController = class {
  constructor(app, deps = {}) {
    this.view = null;
    this.host = null;
    this.mapManager = null;
    this.currentFile = null;
    this.requestedFile = null;
    this.currentOptions = null;
    this.mapLayer = null;
    this.isMounted = false;
    this.shellModes = [];
    this.activeMode = null;
    this.activeModeId = null;
    this.lifecycle = null;
    this.app = app;
    const defaults = createDefaultDeps(app);
    this.deps = {
      ...defaults,
      ...deps,
      modeDescriptors: deps.modeDescriptors ?? defaults.modeDescriptors
    };
    this.callbacks = {
      onModeSelect: (id, ctx) => this.setMode(id, ctx),
      onOpen: (file) => this.mapManager?.setFile(file),
      onCreate: (file) => this.mapManager?.setFile(file),
      onDelete: () => this.mapManager?.deleteCurrent(),
      onSave: (mode, file) => this.handleSave(mode, file),
      onHexClick: (coord, event) => this.handleHexClick(coord, event)
    };
  }
  async onOpen(host, fallbackFile) {
    await this.onClose();
    this.host = host;
    this.isMounted = true;
    const initialFile = this.requestedFile ?? fallbackFile ?? null;
    this.currentFile = initialFile;
    this.requestedFile = initialFile;
    const view = createControllerView({
      app: this.app,
      host,
      initialFile,
      modes: this.shellModes,
      callbacks: this.callbacks
    });
    this.view = view;
    this.mapManager = this.deps.createMapManager(this.app, {
      initialFile,
      onChange: async (file) => {
        await this.applyCurrentFile(file);
      }
    });
    view.setModes(this.shellModes, this.activeModeId);
    view.setFileLabel(initialFile);
    let initialMode = this.activeModeId;
    try {
      const modes = await this.loadModesOnce();
      if (!initialMode) {
        const first = modes.keys().next();
        initialMode = first.done ? null : first.value;
      }
    } catch {
    }
    if (initialMode) {
      await this.setMode(initialMode);
    }
    await this.mapManager.setFile(initialFile);
  }
  async onClose() {
    const lifecycle = this.lifecycle;
    const active = this.activeMode;
    this.lifecycle = null;
    this.activeModeId = null;
    this.activeMode = null;
    this.shellModes = [];
    if (lifecycle) lifecycle.controller.abort();
    if (active && lifecycle) {
      try {
        await active.onExit(lifecycle.ctx);
      } catch (error) {
        console.error("[cartographer] mode exit failed", error);
      }
    }
    if (this.view) {
      this.view.destroy();
      this.view = null;
    }
    this.host = null;
    this.renderAbort?.abort();
    this.renderAbort = void 0;
    this.destroyMapLayer();
    this.currentOptions = null;
    this.mapManager = null;
    this.isMounted = false;
  }
  async setFile(file) {
    this.requestedFile = file;
    if (!this.mapManager) return;
    await this.mapManager.setFile(file);
  }
  async loadModesOnce() {
    if (!this.modeLoad) {
      this.modeLoad = Promise.all(
        this.deps.modeDescriptors.map(async (descriptor) => ({
          descriptor,
          mode: await descriptor.load()
        }))
      ).then((entries) => {
        const map = /* @__PURE__ */ new Map();
        this.shellModes = entries.map(({ mode }) => {
          map.set(mode.id, mode);
          return { id: mode.id, label: mode.label };
        });
        this.view?.setModes(this.shellModes, this.activeModeId);
        this.view?.setOverlay(null);
        return map;
      }).catch((error) => {
        console.error("[cartographer] failed to load modes", error);
        this.view?.setOverlay(MODE_PROVISION_OVERLAY_MESSAGE);
        new import_obsidian16.Notice(MODE_PROVISION_NOTICE_MESSAGE);
        this.modeLoad = void 0;
        throw error;
      });
    }
    return this.modeLoad;
  }
  async setMode(id, ctx) {
    let modes;
    try {
      modes = await this.loadModesOnce();
    } catch {
      return;
    }
    const next = modes.get(id) ?? modes.values().next().value ?? null;
    if (!next) return;
    if (this.activeModeId === next.id) {
      this.view?.setModes(this.shellModes, next.id);
      return;
    }
    const previousLifecycle = this.lifecycle;
    if (previousLifecycle) previousLifecycle.controller.abort();
    const previous = this.activeMode;
    this.activeMode = null;
    this.lifecycle = null;
    this.activeModeId = null;
    if (previous && previousLifecycle) {
      try {
        await previous.onExit(previousLifecycle.ctx);
      } catch (error) {
        console.error("[cartographer] mode exit failed", error);
      }
    }
    if (!this.isMounted || !this.view) {
      this.activeMode = next;
      this.activeModeId = next.id;
      return;
    }
    const controller = new AbortController();
    if (ctx?.signal) {
      if (ctx.signal.aborted) controller.abort();
      else ctx.signal.addEventListener("abort", () => controller.abort(), { once: true });
    }
    const lifecycleCtx = this.createLifecycleContext(controller.signal);
    this.lifecycle = { controller, ctx: lifecycleCtx };
    this.activeMode = next;
    this.activeModeId = next.id;
    this.view.setModes(this.shellModes, next.id);
    try {
      await next.onEnter(lifecycleCtx);
    } catch (error) {
      if (!controller.signal.aborted) console.error("[cartographer] mode enter failed", error);
    }
    if (controller.signal.aborted) return;
    await this.applyCurrentFile(this.currentFile, lifecycleCtx);
  }
  async handleSave(mode, file) {
    if (!this.activeMode?.onSave || !this.lifecycle) return false;
    try {
      return await this.activeMode.onSave(mode, file, this.lifecycle.ctx) === true;
    } catch (error) {
      console.error("[cartographer] mode onSave failed", error);
      return false;
    }
  }
  async handleHexClick(coord, event) {
    if (!this.activeMode?.onHexClick || !this.lifecycle) return;
    try {
      await this.activeMode.onHexClick(coord, event, this.lifecycle.ctx);
    } catch (error) {
      console.error("[cartographer] mode onHexClick failed", error);
    }
  }
  get baseModeCtx() {
    if (!this.view || !this.host) throw new Error("CartographerController is not mounted.");
    return {
      app: this.app,
      host: this.host,
      mapHost: this.view.mapHost,
      sidebarHost: this.view.sidebarHost,
      getFile: () => this.currentFile,
      getMapLayer: () => this.mapLayer,
      getRenderHandles: () => this.mapLayer?.handles ?? null,
      getOptions: () => this.currentOptions
    };
  }
  createLifecycleContext(signal) {
    return { ...this.baseModeCtx, signal };
  }
  async applyCurrentFile(file = this.currentFile, lifecycleCtx = this.lifecycle?.ctx ?? null) {
    this.currentFile = file ?? null;
    this.requestedFile = file ?? null;
    const view = this.view;
    const ctx = lifecycleCtx;
    if (!view || !ctx || !this.activeMode) return;
    view.setFileLabel(this.currentFile);
    this.renderAbort?.abort();
    const controller = new AbortController();
    this.renderAbort = controller;
    const { signal } = controller;
    try {
      if (!this.currentFile) {
        this.destroyMapLayer();
        view.clearMap();
        this.currentOptions = null;
        view.setOverlay("Keine Karte ausgew\xE4hlt.");
        await this.safeFileChange(null, null, ctx);
        return;
      }
      let options = null;
      try {
        options = await this.deps.loadHexOptions(this.app, this.currentFile);
      } catch (error) {
        console.error("[cartographer] failed to parse map options", error);
      }
      if (signal.aborted || !this.view) return;
      if (!options) {
        this.destroyMapLayer();
        view.clearMap();
        this.currentOptions = null;
        view.setOverlay("Kein hex3x3-Block in dieser Datei.");
        await this.safeFileChange(this.currentFile, null, ctx);
        return;
      }
      let layer = null;
      try {
        layer = await this.deps.createMapLayer(this.app, view.mapHost, this.currentFile, options);
      } catch (error) {
        console.error("[cartographer] failed to render map", error);
        layer = null;
      }
      if (signal.aborted || !this.view) {
        layer?.destroy();
        return;
      }
      if (!layer) {
        this.destroyMapLayer();
        view.clearMap();
        this.currentOptions = null;
        view.setOverlay("Karte konnte nicht geladen werden.");
        await this.safeFileChange(this.currentFile, null, ctx);
        return;
      }
      this.destroyMapLayer();
      this.mapLayer = layer;
      this.currentOptions = options;
      view.setOverlay(null);
      await this.safeFileChange(this.currentFile, layer.handles, ctx);
    } finally {
      if (signal.aborted) {
        this.destroyMapLayer();
        this.currentOptions = null;
        view.clearMap();
      }
      if (this.renderAbort === controller) {
        this.renderAbort = void 0;
      }
    }
  }
  async safeFileChange(file, handles, ctx) {
    try {
      await this.activeMode?.onFileChange(file, handles, ctx);
    } catch (error) {
      console.error("[cartographer] mode onFileChange failed", error);
    }
  }
  destroyMapLayer() {
    const layer = this.mapLayer;
    this.mapLayer = null;
    if (!layer) return;
    try {
      layer.destroy();
    } catch (error) {
      console.error("[cartographer] failed to destroy map layer", error);
    }
  }
};
function createControllerView(options) {
  const { app, host, initialFile, modes, callbacks } = options;
  host.empty();
  host.addClass("sm-cartographer");
  const headerHost = host.createDiv({ cls: "sm-cartographer__header" });
  const bodyHost = host.createDiv({ cls: "sm-cartographer__body" });
  const mapWrapper = bodyHost.createDiv({ cls: "sm-cartographer__map" });
  const sidebarHost = bodyHost.createDiv({ cls: "sm-cartographer__sidebar" });
  const surface = createViewContainer(mapWrapper, { camera: false });
  let selectHandle = null;
  const headerHandle = createMapHeader(app, headerHost, {
    title: "Cartographer",
    initialFile,
    onOpen: (file) => callbacks.onOpen(file),
    onCreate: (file) => callbacks.onCreate(file),
    onDelete: (file) => callbacks.onDelete(file),
    onSave: (mode, file) => callbacks.onSave(mode, file),
    titleRightSlot: (slot) => {
      selectHandle = renderModeSelect(slot, modes, (id) => callbacks.onModeSelect(id));
    }
  });
  if (!selectHandle) {
    selectHandle = renderModeSelect(headerHandle.titleRightSlot, modes, (id) => callbacks.onModeSelect(id));
  }
  const hexListener = (event) => {
    if (!(event instanceof CustomEvent)) return;
    const detail = event.detail;
    if (!detail) return;
    event.stopPropagation();
    if (event.cancelable) event.preventDefault();
    void Promise.resolve(callbacks.onHexClick(detail, event)).catch((error) => {
      console.error("[cartographer] hex click handler failed", error);
    });
  };
  surface.stageEl.addEventListener("hex:click", hexListener, { passive: false });
  return {
    mapHost: surface.stageEl,
    sidebarHost,
    setFileLabel: (file) => headerHandle.setFileLabel(file),
    setModes: (nextModes, activeId) => selectHandle?.setModes(nextModes, activeId),
    setOverlay: (content) => surface.setOverlay(content),
    clearMap: () => surface.stageEl.empty(),
    destroy: () => {
      surface.stageEl.removeEventListener("hex:click", hexListener);
      selectHandle?.destroy();
      headerHandle.destroy();
      surface.destroy();
      host.empty();
      host.removeClass("sm-cartographer");
    }
  };
}
function renderModeSelect(slot, initialModes, onChange) {
  slot.empty();
  slot.addClass("sm-cartographer__mode-slot");
  const selectEl = slot.createEl("select", { cls: "sm-cartographer__mode-select" });
  selectEl.setAttribute("aria-label", "Cartographer mode");
  let modes = [...initialModes];
  const sync = (list, activeId) => {
    modes = [...list];
    selectEl.empty();
    if (modes.length === 0) {
      const option = selectEl.createEl("option", { text: "Keine Modi" });
      option.disabled = true;
      option.selected = true;
      selectEl.disabled = true;
      return;
    }
    for (const mode of modes) {
      const option = selectEl.createEl("option", { text: mode.label });
      option.value = mode.id;
    }
    selectEl.disabled = false;
    const requested = activeId && modes.some((mode) => mode.id === activeId) ? activeId : modes[0]?.id ?? "";
    selectEl.value = requested ?? "";
  };
  sync(modes);
  const handleChange = () => {
    const id = selectEl.value;
    if (!id) return;
    void Promise.resolve(onChange(id)).catch((error) => {
      console.error("[cartographer] failed to select mode", error);
    });
  };
  selectEl.addEventListener("change", handleChange);
  return {
    setModes: (nextModes, activeId) => sync(nextModes, activeId),
    destroy: () => {
      selectEl.removeEventListener("change", handleChange);
      slot.empty();
      modes = [];
    }
  };
}

// src/apps/cartographer/index.ts
var VIEW_TYPE_CARTOGRAPHER = "cartographer-view";
var VIEW_CARTOGRAPHER = VIEW_TYPE_CARTOGRAPHER;
var CartographerView = class extends import_obsidian17.ItemView {
  constructor(leaf) {
    super(leaf);
    this.hostEl = null;
    this.pendingFile = null;
    this.controller = new CartographerController(this.app);
    this.callbacks = this.controller.callbacks;
  }
  getViewType() {
    return VIEW_TYPE_CARTOGRAPHER;
  }
  getDisplayText() {
    return "Cartographer";
  }
  getIcon() {
    return "compass";
  }
  setFile(file) {
    this.pendingFile = file;
    void this.controller.setFile(file ?? null);
  }
  async onOpen() {
    const container = this.containerEl;
    const content = container.children[1];
    content.empty();
    this.hostEl = content.createDiv({ cls: "cartographer-host" });
    const fallbackFile = this.pendingFile ?? this.app.workspace.getActiveFile() ?? null;
    await this.controller.onOpen(this.hostEl, fallbackFile);
  }
  async onClose() {
    await this.controller.onClose();
    this.hostEl = null;
  }
};
function getExistingCartographerLeaves(app) {
  return app.workspace.getLeavesOfType(VIEW_TYPE_CARTOGRAPHER);
}
function getOrCreateCartographerLeaf(app) {
  const existing = getExistingCartographerLeaves(app);
  if (existing.length > 0) return existing[0];
  return app.workspace.getLeaf(false) ?? app.workspace.getLeaf(true);
}
async function openCartographer(app, file) {
  const leaf = getOrCreateCartographerLeaf(app);
  await leaf.setViewState({ type: VIEW_TYPE_CARTOGRAPHER, active: true });
  app.workspace.revealLeaf(leaf);
  if (file) {
    const view = leaf.view instanceof CartographerView ? leaf.view : null;
    view?.setFile(file);
  }
}
async function detachCartographerLeaves(app) {
  const leaves = getExistingCartographerLeaves(app);
  for (const leaf of leaves) {
    await leaf.detach();
  }
}

// src/apps/view-manifest.ts
init_view();

// src/apps/library/view.ts
var import_obsidian29 = require("obsidian");

// src/ui/workmode/tab-navigation.ts
function createTabNavigation(parent, config) {
  const container = parent.createDiv({ cls: "sm-tab-nav" });
  if (config.className) {
    container.addClass(config.className);
  }
  const buttons = /* @__PURE__ */ new Map();
  let currentActive = config.activeTab;
  const updateActiveState = () => {
    for (const [tabId, { button }] of buttons.entries()) {
      button.classList.toggle("is-active", tabId === currentActive);
      button.setAttribute("aria-selected", String(tabId === currentActive));
    }
  };
  const createTabButton = (tab) => {
    const button = container.createEl("button", {
      cls: "sm-tab-nav__button",
      attr: {
        "data-tab-id": tab.id,
        "role": "tab",
        "aria-selected": String(tab.id === currentActive),
        "tabindex": tab.id === currentActive ? "0" : "-1"
      }
    });
    if (tab.disabled) {
      button.disabled = true;
      button.addClass("is-disabled");
    }
    if (tab.icon) {
      const icon = button.createSpan({ cls: "sm-tab-nav__icon" });
      icon.innerHTML = tab.icon;
    }
    button.createSpan({ cls: "sm-tab-nav__label", text: tab.label });
    let badge;
    if (tab.badgeCount !== void 0 && tab.badgeCount > 0) {
      badge = button.createSpan({ cls: "sm-tab-nav__badge", text: String(tab.badgeCount) });
    }
    if (tab.description) {
      button.setAttribute("aria-label", tab.description);
      button.setAttribute("title", tab.description);
    }
    button.onclick = () => {
      if (button.disabled) return;
      currentActive = tab.id;
      updateActiveState();
      config.onSelect(tab.id);
    };
    return { button, badge };
  };
  for (const tab of config.tabs) {
    const tabButton = createTabButton(tab);
    buttons.set(tab.id, tabButton);
  }
  updateActiveState();
  container.addEventListener("keydown", (e) => {
    if (e.key !== "ArrowLeft" && e.key !== "ArrowRight") return;
    const tabIds = Array.from(buttons.keys());
    const currentIndex = tabIds.indexOf(currentActive);
    if (currentIndex === -1) return;
    let nextIndex;
    if (e.key === "ArrowRight") {
      nextIndex = (currentIndex + 1) % tabIds.length;
    } else {
      nextIndex = (currentIndex - 1 + tabIds.length) % tabIds.length;
    }
    const nextTab = tabIds[nextIndex];
    const nextButton = buttons.get(nextTab);
    if (nextButton && !nextButton.button.disabled) {
      currentActive = nextTab;
      updateActiveState();
      nextButton.button.focus();
      config.onSelect(nextTab);
    }
  });
  return {
    element: container,
    setActiveTab(tabId) {
      if (!buttons.has(tabId)) {
        console.warn(`Tab ${tabId} not found in navigation`);
        return;
      }
      currentActive = tabId;
      updateActiveState();
    },
    setBadgeCount(tabId, count) {
      const entry = buttons.get(tabId);
      if (!entry) return;
      if (entry.badge) {
        if (count !== void 0 && count > 0) {
          entry.badge.setText(String(count));
          entry.badge.style.display = "";
        } else {
          entry.badge.style.display = "none";
        }
      } else if (count !== void 0 && count > 0) {
        entry.badge = entry.button.createSpan({ cls: "sm-tab-nav__badge", text: String(count) });
      }
    },
    setDisabled(tabId, disabled) {
      const entry = buttons.get(tabId);
      if (!entry) return;
      entry.button.disabled = disabled;
      entry.button.classList.toggle("is-disabled", disabled);
    },
    destroy() {
      container.remove();
    }
  };
}

// src/ui/workmode/mode-renderer.ts
var BaseModeRenderer = class {
  constructor(app, container) {
    this.app = app;
    this.container = container;
    this.query = "";
    this.disposed = false;
    this.cleanups = [];
  }
  /**
   * Initialize the renderer. Override to load initial data.
   */
  async init() {
  }
  /**
   * Update the search query and trigger a re-render.
   */
  setQuery(query) {
    this.query = (query || "").toLowerCase().trim();
    this.render();
  }
  /**
   * Handle creation of a new entry. Override if needed.
   */
  async handleCreate(_name) {
  }
  /**
   * Clean up all resources and remove DOM elements.
   */
  async destroy() {
    if (this.disposed) return;
    this.disposed = true;
    for (const fn of this.cleanups.splice(0)) {
      try {
        fn();
      } catch (err) {
        console.error("Cleanup function failed:", err);
      }
    }
    this.container.empty();
  }
  /**
   * Check if this renderer has been disposed.
   */
  isDisposed() {
    return this.disposed;
  }
  /**
   * Register a cleanup function to be called during destroy().
   */
  registerCleanup(fn) {
    if (this.disposed) {
      console.warn("Attempted to register cleanup on disposed renderer");
      return;
    }
    this.cleanups.push(fn);
  }
  /**
   * Helper to create a simple message element in the container.
   */
  renderMessage(message, className) {
    this.container.empty();
    const el = this.container.createDiv({ text: message });
    if (className) {
      el.addClass(className);
    }
  }
  /**
   * Helper to render an empty state.
   */
  renderEmptyState(message) {
    this.renderMessage(message, "sm-mode-empty");
  }
  /**
   * Helper to render an error state.
   */
  renderErrorState(message) {
    this.renderMessage(message, "sm-mode-error");
  }
};
function scoreName(name, query) {
  if (!query) return 1e-4;
  const lowerName = name.toLowerCase();
  const lowerQuery = query.toLowerCase();
  if (lowerName === lowerQuery) return 1e3;
  if (lowerName.startsWith(lowerQuery)) {
    return 900 - (name.length - query.length);
  }
  const idx = lowerName.indexOf(lowerQuery);
  if (idx >= 0) {
    return 700 - idx;
  }
  const tokens = lowerName.split(/\s+|[-_]/);
  const tokenIdx = tokens.findIndex((t) => t.startsWith(lowerQuery));
  if (tokenIdx >= 0) {
    return 600 - tokenIdx * 5;
  }
  return -Infinity;
}

// src/ui/workmode/watcher-hub.ts
var WatcherHub = class {
  constructor() {
    this.registry = /* @__PURE__ */ new Map();
  }
  /**
   * Subscribe to changes for a specific source.
   *
   * @param key - The unique identifier for the watched resource
   * @param factory - Factory function that creates the watcher
   * @param listener - Callback to be invoked when changes occur
   * @returns Unsubscribe function
   */
  subscribe(key, factory, listener) {
    let entry = this.registry.get(key);
    if (!entry) {
      const listeners2 = /* @__PURE__ */ new Set();
      const stop = factory(() => {
        for (const cb of listeners2) {
          try {
            cb();
          } catch (err) {
            console.error(`Watcher listener failed for key ${key}:`, err);
          }
        }
      });
      entry = { stop, listeners: listeners2 };
      this.registry.set(key, entry);
    }
    entry.listeners.add(listener);
    return () => {
      const current = this.registry.get(key);
      if (!current) return;
      current.listeners.delete(listener);
      if (current.listeners.size === 0) {
        try {
          current.stop?.();
        } catch (err) {
          console.error(`Failed to stop watcher for key ${key}:`, err);
        }
        this.registry.delete(key);
      }
    };
  }
  /**
   * Get the number of active watchers.
   */
  getActiveWatcherCount() {
    return this.registry.size;
  }
  /**
   * Get the number of listeners for a specific key.
   */
  getListenerCount(key) {
    return this.registry.get(key)?.listeners.size ?? 0;
  }
  /**
   * Stop all watchers and clear all listeners.
   */
  destroy() {
    for (const [key, entry] of this.registry.entries()) {
      try {
        entry.stop?.();
      } catch (err) {
        console.error(`Failed to stop watcher for key ${key}:`, err);
      }
    }
    this.registry.clear();
  }
};

// src/ui/workmode/split-view-container.ts
var DEFAULT_SPLIT = 0.6;
var DEFAULT_MIN_SIZE = 100;
function createSplitView(parent, config = {}) {
  const {
    className,
    initialSplit = DEFAULT_SPLIT,
    minUpperSize = DEFAULT_MIN_SIZE,
    minLowerSize = DEFAULT_MIN_SIZE,
    orientation = "horizontal",
    resizable = true,
    onSplitChange
  } = config;
  const container = parent.createDiv({ cls: "sm-split-view" });
  container.dataset.orientation = orientation;
  if (className) {
    container.addClass(className);
  }
  const upperPane = container.createDiv({ cls: "sm-split-view__upper" });
  const lowerPane = container.createDiv({ cls: "sm-split-view__lower" });
  let currentSplit = Math.max(0.1, Math.min(0.9, initialSplit));
  let isDragging = false;
  let dragStartY = 0;
  let dragStartSplit = 0;
  const applySplit = () => {
    if (orientation === "horizontal") {
      upperPane.style.height = `${currentSplit * 100}%`;
      lowerPane.style.height = `${(1 - currentSplit) * 100}%`;
    } else {
      upperPane.style.width = `${currentSplit * 100}%`;
      lowerPane.style.width = `${(1 - currentSplit) * 100}%`;
    }
  };
  applySplit();
  let resizer;
  if (resizable) {
    resizer = container.createDiv({ cls: "sm-split-view__resizer" });
    resizer.dataset.orientation = orientation;
    container.insertBefore(resizer, lowerPane);
    const handlePointerDown = (e) => {
      if (e.button !== 0) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartY = orientation === "horizontal" ? e.clientY : e.clientX;
      dragStartSplit = currentSplit;
      resizer.setPointerCapture(e.pointerId);
      container.addClass("is-resizing");
    };
    const handlePointerMove = (e) => {
      if (!isDragging) return;
      e.preventDefault();
      e.stopPropagation();
      const containerRect = container.getBoundingClientRect();
      const containerSize = orientation === "horizontal" ? containerRect.height : containerRect.width;
      const currentPos = orientation === "horizontal" ? e.clientY : e.clientX;
      const deltaPos = currentPos - dragStartY;
      const deltaRatio = deltaPos / containerSize;
      let newSplit = dragStartSplit + deltaRatio;
      const minUpperRatio = minUpperSize / containerSize;
      const minLowerRatio = minLowerSize / containerSize;
      newSplit = Math.max(minUpperRatio, Math.min(1 - minLowerRatio, newSplit));
      if (Math.abs(newSplit - currentSplit) > 1e-3) {
        currentSplit = newSplit;
        applySplit();
        onSplitChange?.(currentSplit);
      }
    };
    const stopDragging = (e) => {
      if (!isDragging) return;
      if (e) {
        e.preventDefault();
        e.stopPropagation();
        resizer.releasePointerCapture(e.pointerId);
      }
      isDragging = false;
      container.removeClass("is-resizing");
    };
    resizer.addEventListener("pointerdown", handlePointerDown);
    resizer.addEventListener("pointermove", handlePointerMove);
    resizer.addEventListener("pointerup", stopDragging);
    resizer.addEventListener("pointercancel", stopDragging);
    resizer.addEventListener("pointerleave", (e) => {
      if (isDragging) stopDragging(e);
    });
  }
  return {
    element: container,
    upperElement: upperPane,
    lowerElement: lowerPane,
    resizerElement: resizer,
    getSplitRatio() {
      return currentSplit;
    },
    setSplitRatio(ratio) {
      currentSplit = Math.max(0.1, Math.min(0.9, ratio));
      applySplit();
      onSplitChange?.(currentSplit);
    },
    toggleUpper(visible) {
      const shouldShow = visible ?? upperPane.style.display === "none";
      upperPane.style.display = shouldShow ? "" : "none";
      if (resizer) {
        resizer.style.display = shouldShow ? "" : "none";
      }
    },
    toggleLower(visible) {
      const shouldShow = visible ?? lowerPane.style.display === "none";
      lowerPane.style.display = shouldShow ? "" : "none";
      if (resizer) {
        resizer.style.display = shouldShow ? "" : "none";
      }
    },
    destroy() {
      if (isDragging) {
        isDragging = false;
        container.removeClass("is-resizing");
      }
      container.remove();
    }
  };
}

// src/apps/library/view/mode.ts
var BaseModeRenderer2 = class extends BaseModeRenderer {
  // Override setQuery to trim the query (Library-specific behavior)
  setQuery(query) {
    this.query = (query || "").toLowerCase();
    this.render();
  }
};
var LibrarySourceWatcherHub = class {
  constructor() {
    this.hub = new WatcherHub();
  }
  subscribe(source, factory, listener) {
    return this.hub.subscribe(source, factory, listener);
  }
  destroy() {
    this.hub.destroy();
  }
};

// src/apps/library/core/data-sources.ts
init_creature_files();
init_spell_files();
init_item_files();
init_equipment_files();
async function readFrontmatter(app, file) {
  const cached = app.metadataCache.getFileCache(file)?.frontmatter;
  if (cached && typeof cached === "object") {
    return cached;
  }
  const content = await app.vault.read(file);
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match) return {};
  const lines = match[1].split(/\r?\n/);
  const data = {};
  for (const line of lines) {
    const idx = line.indexOf(":");
    if (idx === -1) continue;
    const rawKey = line.slice(0, idx).trim();
    if (!rawKey) continue;
    let rawValue = line.slice(idx + 1).trim();
    if (!rawValue) {
      data[rawKey] = rawValue;
      continue;
    }
    if (/^".*"$/.test(rawValue)) {
      rawValue = rawValue.slice(1, -1);
    }
    const num = Number(rawValue);
    data[rawKey] = Number.isFinite(num) && rawValue === String(num) ? num : rawValue;
  }
  return data;
}
async function loadCreatureEntry(app, file) {
  const fm2 = await readFrontmatter(app, file);
  const type = typeof fm2.type === "string" ? fm2.type : void 0;
  const crValue = typeof fm2.cr === "string" ? fm2.cr : typeof fm2.cr === "number" ? String(fm2.cr) : void 0;
  return { file, name: file.basename, type, cr: crValue };
}
async function loadSpellEntry(app, file) {
  const fm2 = await readFrontmatter(app, file);
  const school = typeof fm2.school === "string" ? fm2.school : void 0;
  const rawLevel = fm2.level;
  const level = typeof rawLevel === "number" ? rawLevel : typeof rawLevel === "string" ? Number(rawLevel) : void 0;
  const casting_time = typeof fm2.casting_time === "string" ? fm2.casting_time : void 0;
  const duration = typeof fm2.duration === "string" ? fm2.duration : void 0;
  const concentration = typeof fm2.concentration === "boolean" ? fm2.concentration : void 0;
  const ritual = typeof fm2.ritual === "boolean" ? fm2.ritual : void 0;
  const description = typeof fm2.description === "string" ? fm2.description : void 0;
  return {
    file,
    name: file.basename,
    school,
    level: Number.isFinite(level) ? level : void 0,
    casting_time,
    duration,
    concentration,
    ritual,
    description
  };
}
async function loadItemEntry(app, file) {
  const fm2 = await readFrontmatter(app, file);
  const category = typeof fm2.category === "string" ? fm2.category : void 0;
  const rarity = typeof fm2.rarity === "string" ? fm2.rarity : void 0;
  return { file, name: file.basename, category, rarity };
}
async function loadEquipmentEntry(app, file) {
  const fm2 = await readFrontmatter(app, file);
  const type = typeof fm2.type === "string" ? fm2.type : void 0;
  const roleCandidate = [
    fm2.weapon_category,
    fm2.armor_category,
    fm2.tool_category,
    fm2.gear_category
  ].find((value) => typeof value === "string" && value.length > 0);
  return { file, name: file.basename, type, role: roleCandidate };
}
var LIBRARY_DATA_SOURCES = {
  creatures: {
    id: "creatures",
    list: (app) => listCreatureFiles(app),
    watch: (app, onChange) => watchCreatureDir(app, onChange),
    load: loadCreatureEntry
  },
  spells: {
    id: "spells",
    list: (app) => listSpellFiles(app),
    watch: (app, onChange) => watchSpellDir(app, onChange),
    load: loadSpellEntry
  },
  items: {
    id: "items",
    list: (app) => listItemFiles(app),
    watch: (app, onChange) => watchItemDir(app, onChange),
    load: loadItemEntry
  },
  equipment: {
    id: "equipment",
    list: (app) => listEquipmentFiles(app),
    watch: (app, onChange) => watchEquipmentDir(app, onChange),
    load: loadEquipmentEntry
  }
};

// src/apps/library/view/filter-registry.ts
var RARITY_ORDER = /* @__PURE__ */ new Map([
  ["common", 0],
  ["uncommon", 1],
  ["rare", 2],
  ["very rare", 3],
  ["legendary", 4],
  ["artifact", 5]
]);
function rarityOrder(value) {
  if (!value) return Number.POSITIVE_INFINITY;
  return RARITY_ORDER.get(value.toLowerCase()) ?? Number.POSITIVE_INFINITY;
}
function parseCr(value) {
  if (!value) return Number.POSITIVE_INFINITY;
  if (value.includes("/")) {
    const [num, denom] = value.split("/").map((part) => Number(part.trim()));
    if (Number.isFinite(num) && Number.isFinite(denom) && denom !== 0) {
      return num / denom;
    }
  }
  const numeric = Number(value);
  return Number.isFinite(numeric) ? numeric : Number.POSITIVE_INFINITY;
}
function formatSpellLevel(level) {
  if (level == null) return "Unknown";
  if (level === 0) return "Cantrip";
  return `Level ${level}`;
}
var LIBRARY_LIST_SCHEMAS = {
  creatures: {
    filters: [
      {
        id: "type",
        label: "Type",
        getValues: (entry) => [entry.type]
      },
      {
        id: "cr",
        label: "CR",
        getValues: (entry) => [entry.cr],
        sortComparator: (a, b) => parseCr(a) - parseCr(b)
      }
    ],
    sorts: [
      {
        id: "name",
        label: "Name",
        compare: (a, b) => a.name.localeCompare(b.name)
      },
      {
        id: "type",
        label: "Type",
        compare: (a, b) => (a.type || "").localeCompare(b.type || "") || a.name.localeCompare(b.name)
      },
      {
        id: "cr",
        label: "CR",
        compare: (a, b) => parseCr(a.cr) - parseCr(b.cr) || a.name.localeCompare(b.name)
      }
    ],
    search: (entry) => [entry.type, entry.cr].filter((value) => Boolean(value))
  },
  spells: {
    filters: [
      {
        id: "school",
        label: "School",
        getValues: (entry) => [entry.school]
      },
      {
        id: "level",
        label: "Level",
        getValues: (entry) => [entry.level != null ? String(entry.level) : void 0],
        sortComparator: (a, b) => Number(a) - Number(b),
        formatOption: (value) => formatSpellLevel(Number(value))
      },
      {
        id: "ritual",
        label: "Ritual",
        getValues: (entry) => [entry.ritual == null ? void 0 : entry.ritual ? "true" : "false"],
        emptyLabel: "All",
        formatOption: (value) => value === "true" ? "Only rituals" : "No rituals"
      }
    ],
    sorts: [
      {
        id: "name",
        label: "Name",
        compare: (a, b) => a.name.localeCompare(b.name)
      },
      {
        id: "level",
        label: "Level",
        compare: (a, b) => (a.level ?? 0) - (b.level ?? 0) || a.name.localeCompare(b.name)
      },
      {
        id: "school",
        label: "School",
        compare: (a, b) => (a.school || "").localeCompare(b.school || "") || a.name.localeCompare(b.name)
      }
    ],
    search: (entry) => [
      entry.school,
      entry.level != null ? formatSpellLevel(entry.level) : void 0,
      entry.casting_time,
      entry.duration,
      entry.description
    ].filter((value) => Boolean(value))
  },
  items: {
    filters: [
      {
        id: "category",
        label: "Category",
        getValues: (entry) => [entry.category]
      },
      {
        id: "rarity",
        label: "Rarity",
        getValues: (entry) => [entry.rarity],
        sortComparator: (a, b) => rarityOrder(a) - rarityOrder(b) || a.localeCompare(b)
      }
    ],
    sorts: [
      {
        id: "name",
        label: "Name",
        compare: (a, b) => a.name.localeCompare(b.name)
      },
      {
        id: "rarity",
        label: "Rarity",
        compare: (a, b) => rarityOrder(a.rarity) - rarityOrder(b.rarity) || a.name.localeCompare(b.name)
      },
      {
        id: "category",
        label: "Category",
        compare: (a, b) => (a.category || "").localeCompare(b.category || "") || a.name.localeCompare(b.name)
      }
    ],
    search: (entry) => [entry.category, entry.rarity].filter((value) => Boolean(value))
  },
  equipment: {
    filters: [
      {
        id: "type",
        label: "Type",
        getValues: (entry) => [entry.type]
      },
      {
        id: "role",
        label: "Role",
        getValues: (entry) => [entry.role]
      }
    ],
    sorts: [
      {
        id: "name",
        label: "Name",
        compare: (a, b) => a.name.localeCompare(b.name)
      },
      {
        id: "type",
        label: "Type",
        compare: (a, b) => (a.type || "").localeCompare(b.type || "") || a.name.localeCompare(b.name)
      },
      {
        id: "role",
        label: "Role",
        compare: (a, b) => (a.role || "").localeCompare(b.role || "") || a.name.localeCompare(b.name)
      }
    ],
    search: (entry) => [entry.type, entry.role].filter((value) => Boolean(value))
  }
};

// src/apps/library/view/view-registry.ts
init_creature_presets();
init_creature_files();
init_spell_files();
init_item_files();
init_equipment_files();

// src/apps/library/create/creature/sections.ts
var import_obsidian24 = require("obsidian");

// src/apps/library/create/shared/form-controls.ts
init_search_dropdown();
function createTextInput2(parent, options = {}) {
  const input = parent.createEl("input", {
    cls: options.className || "sm-cc-input",
    attr: {
      type: "text",
      placeholder: options.placeholder || "",
      "aria-label": options.ariaLabel || options.placeholder || "Text input"
    }
  });
  if (options.value !== void 0) {
    input.value = options.value;
  }
  if (options.onChange) {
    input.addEventListener("change", () => options.onChange(input.value));
  }
  if (options.onInput) {
    input.addEventListener("input", () => options.onInput(input.value));
  }
  return input;
}
function createNumberInput2(parent, options = {}) {
  const input = parent.createEl("input", {
    cls: options.className || "sm-cc-input",
    attr: {
      type: "number",
      placeholder: options.placeholder || "",
      "aria-label": options.ariaLabel || options.placeholder || "Number input"
    }
  });
  if (options.min !== void 0) input.min = String(options.min);
  if (options.max !== void 0) input.max = String(options.max);
  if (options.step !== void 0) input.step = String(options.step);
  if (options.value !== void 0) input.value = String(options.value);
  if (options.onChange) {
    input.addEventListener("change", () => {
      const val = input.value.trim();
      const num = val ? parseFloat(val) : void 0;
      options.onChange(num);
    });
  }
  return input;
}
function createSelectDropdown(parent, options) {
  const select = parent.createEl("select", {
    cls: options.className || "sm-cc-select",
    attr: {
      "aria-label": options.ariaLabel || options.placeholder || "Select option"
    }
  });
  const normalizeOptions = (opts) => {
    return opts.map(
      (opt) => typeof opt === "object" && "value" in opt ? opt : { value: opt, label: String(opt) }
    );
  };
  let normalizedOptions = normalizeOptions(options.options);
  const populateOptions = () => {
    select.empty();
    normalizedOptions.forEach((opt) => {
      const optEl = select.createEl("option", { text: opt.label });
      optEl.value = String(opt.value);
    });
  };
  populateOptions();
  if (options.value !== void 0) {
    select.value = String(options.value);
  }
  if (options.onChange) {
    select.addEventListener("change", () => {
      options.onChange(select.value);
    });
  }
  if (options.enableSearch) {
    try {
      enhanceSelectToSearch(select, options.searchPlaceholder || "Suchen\u2026");
    } catch (e) {
      console.warn("Failed to enhance select to search:", e);
    }
  }
  const syncDisplay = () => {
    const searchInput = select._smSearchInput;
    if (searchInput) {
      const selectedOption = Array.from(select.options).find(
        (opt) => opt.value === select.value
      );
      searchInput.value = selectedOption?.text || "";
    }
  };
  const handle = {
    element: select,
    getValue: () => select.value,
    setValue: (value) => {
      select.value = String(value);
      syncDisplay();
    },
    setOptions: (newOptions) => {
      normalizedOptions = normalizeOptions(newOptions);
      populateOptions();
    },
    syncDisplay
  };
  if (options.value !== void 0 && options.enableSearch) {
    syncDisplay();
  }
  return handle;
}
function enhanceExistingSelectDropdown(select, searchPlaceholder) {
  if (!select._smEnhanced) {
    try {
      enhanceSelectToSearch(select, searchPlaceholder || "Suchen\u2026");
    } catch (e) {
      console.warn("Failed to enhance select to search:", e);
    }
  }
  const syncDisplay = () => {
    const searchInput = select._smSearchInput;
    if (searchInput) {
      const selectedOption = Array.from(select.options).find(
        (opt) => opt.value === select.value
      );
      searchInput.value = selectedOption?.text || "";
    }
  };
  const handle = {
    element: select,
    getValue: () => select.value,
    setValue: (value) => {
      select.value = String(value);
      syncDisplay();
    },
    setOptions: (newOptions) => {
      select.empty();
      const normalizedOptions = newOptions.map(
        (opt) => typeof opt === "object" && "value" in opt ? opt : { value: opt, label: String(opt) }
      );
      normalizedOptions.forEach((opt) => {
        const optEl = select.createEl("option", { text: opt.label });
        optEl.value = String(opt.value);
      });
    },
    syncDisplay
  };
  return handle;
}
function createTextArea(parent, options = {}) {
  const textarea = parent.createEl("textarea", {
    cls: options.className || "sm-cc-textarea",
    attr: {
      placeholder: options.placeholder || "",
      "aria-label": options.ariaLabel || options.placeholder || "Text area"
    }
  });
  if (options.minHeight) {
    textarea.style.minHeight = `${options.minHeight}px`;
  }
  if (options.value !== void 0) {
    textarea.value = options.value;
  }
  if (options.onChange) {
    textarea.addEventListener("change", () => options.onChange(textarea.value));
  }
  if (options.onInput) {
    textarea.addEventListener("input", () => options.onInput(textarea.value));
  }
  return textarea;
}

// src/apps/library/create/shared/token-editor.ts
var import_obsidian19 = require("obsidian");
function mountTokenEditor(parent, title, model, options = {}) {
  const placeholder = options.placeholder ?? "Begriff eingeben\u2026";
  const addLabel = options.addButtonLabel ?? "+";
  const setting = new import_obsidian19.Setting(parent).setName(title);
  setting.settingEl.addClass("sm-cc-setting");
  setting.settingEl.addClass("sm-cc-setting--show-name");
  setting.settingEl.addClass("sm-cc-setting--token-editor");
  let inputEl;
  let renderChips = () => {
  };
  const commitValue = (value) => {
    const trimmed = value.trim();
    if (!trimmed) return;
    model.add(trimmed);
    options.onAdd?.(trimmed);
    renderChips();
  };
  setting.addText((t) => {
    t.setPlaceholder(placeholder);
    inputEl = t.inputEl;
    t.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        commitValue((inputEl?.value ?? "").trim());
        if (inputEl) inputEl.value = "";
      }
    });
  });
  setting.addButton(
    (b) => b.setButtonText(addLabel).onClick(() => {
      commitValue((inputEl?.value ?? "").trim());
      if (inputEl) inputEl.value = "";
    })
  );
  const chips = parent.createDiv({ cls: "sm-cc-chips" });
  renderChips = () => {
    chips.empty();
    const items = model.getItems();
    items.forEach((txt, index) => {
      const chip = chips.createDiv({ cls: "sm-cc-chip" });
      chip.createSpan({ text: txt });
      const removeBtn = chip.createEl("button", { text: "\xD7" });
      removeBtn.onclick = () => {
        model.remove(index);
        options.onRemove?.(txt, index);
        renderChips();
      };
    });
  };
  renderChips();
  return { setting, chipsEl: chips, refresh: renderChips };
}

// src/apps/library/create/shared/layouts.ts
var import_obsidian20 = require("obsidian");
function createFormCard(parent, options) {
  const { title, subtitle, registerValidator, id, headingId, role } = options;
  const card = parent.createDiv({ cls: "sm-cc-card" });
  if (id) card.id = id;
  const computedHeadingId = headingId ?? (id ? `${id}__title` : void 0);
  card.setAttribute("role", role ?? "region");
  if (computedHeadingId) {
    card.setAttribute("aria-labelledby", computedHeadingId);
  }
  const head = card.createDiv({ cls: "sm-cc-card__head" });
  const heading = head.createDiv({ cls: "sm-cc-card__heading" });
  const headingTitle = heading.createEl("h3", { text: title, cls: "sm-cc-card__title" });
  if (computedHeadingId) headingTitle.id = computedHeadingId;
  const status = heading.createSpan({
    cls: "sm-cc-card__status",
    attr: { hidden: "" }
  });
  if (subtitle) head.createEl("p", { text: subtitle, cls: "sm-cc-card__subtitle" });
  const validation = card.createDiv({ cls: "sm-cc-card__validation", attr: { hidden: "" } });
  const validationList = validation.createEl("ul", { cls: "sm-cc-card__validation-list" });
  const applyValidation = (issues, summary) => {
    const hasIssues = issues.length > 0;
    card.toggleClass("is-invalid", hasIssues);
    if (!hasIssues) {
      validation.setAttribute("hidden", "");
      validation.classList.remove("is-visible");
      validationList.empty();
      status.textContent = "";
      status.setAttribute("hidden", "");
      status.classList.remove("is-active");
      return;
    }
    validation.removeAttribute("hidden");
    validation.classList.add("is-visible");
    validationList.empty();
    for (const message of issues) {
      validationList.createEl("li", { text: message });
    }
    const fallbackSummary = issues.length === 1 ? issues[0] : `${issues.length} Probleme`;
    status.textContent = summary?.trim() || fallbackSummary;
    status.removeAttribute("hidden");
    status.classList.add("is-active");
  };
  const body = card.createDiv({ cls: "sm-cc-card__body" });
  const registerValidation = (compute) => {
    const runner = () => {
      const result = compute();
      const normalized = Array.isArray(result) ? { issues: result, summary: void 0 } : result ?? { issues: [], summary: void 0 };
      applyValidation(normalized.issues, normalized.summary);
      return normalized.issues;
    };
    return registerValidator ? registerValidator(runner) : runner;
  };
  return { card, body, heading: headingTitle, registerValidation };
}
function createFieldGrid(parent, options) {
  const classes = ["sm-cc-field-grid"];
  if (options?.variant) classes.push(`sm-cc-field-grid--${options.variant}`);
  if (options?.className) {
    const extras = Array.isArray(options.className) ? options.className : [options.className];
    classes.push(...extras);
  }
  const grid = parent.createDiv({ cls: classes.join(" ") });
  if (options?.minColumnWidth) {
    grid.style.gridTemplateColumns = `repeat(auto-fit, minmax(${options.minColumnWidth}, 1fr))`;
  }
  const createSetting = (label, settingOptions) => {
    const setting = new import_obsidian20.Setting(grid).setName(label);
    setting.settingEl.addClass("sm-cc-setting");
    const additional = settingOptions?.className;
    if (additional) {
      const extras = Array.isArray(additional) ? additional : [additional];
      setting.settingEl.classList.add(...extras);
    }
    return setting;
  };
  return { grid, createSetting };
}

// src/apps/library/create/shared/creature-controls.ts
var import_obsidian21 = require("obsidian");

// src/apps/library/create/creature/presets.ts
var CREATURE_SIZES = [
  "Tiny",
  "Small",
  "Medium",
  "Large",
  "Huge",
  "Gargantuan"
];
var CREATURE_TYPES = [
  "Aberration",
  "Beast",
  "Celestial",
  "Construct",
  "Dragon",
  "Elemental",
  "Fey",
  "Fiend",
  "Giant",
  "Humanoid",
  "Monstrosity",
  "Ooze",
  "Plant",
  "Undead"
];
var CREATURE_ABILITY_KEYS = ["str", "dex", "con", "int", "wis", "cha"];
var CREATURE_ABILITY_LABELS = ["STR", "DEX", "CON", "INT", "WIS", "CHA"];
var CREATURE_ABILITIES = [
  { key: "str", label: "STR" },
  { key: "dex", label: "DEX" },
  { key: "con", label: "CON" },
  { key: "int", label: "INT" },
  { key: "wis", label: "WIS" },
  { key: "cha", label: "CHA" }
];
var CREATURE_SKILLS = [
  ["Athletics", "str"],
  ["Acrobatics", "dex"],
  ["Sleight of Hand", "dex"],
  ["Stealth", "dex"],
  ["Arcana", "int"],
  ["History", "int"],
  ["Investigation", "int"],
  ["Nature", "int"],
  ["Religion", "int"],
  ["Animal Handling", "wis"],
  ["Insight", "wis"],
  ["Medicine", "wis"],
  ["Perception", "wis"],
  ["Survival", "wis"],
  ["Deception", "cha"],
  ["Intimidation", "cha"],
  ["Performance", "cha"],
  ["Persuasion", "cha"]
];
var CREATURE_ENTRY_CATEGORIES = [
  ["trait", "Eigenschaft"],
  ["action", "Aktion"],
  ["bonus", "Bonusaktion"],
  ["reaction", "Reaktion"],
  ["legendary", "Legend\xE4re Aktion"]
];
var CREATURE_ABILITY_SELECTIONS = [
  "",
  "best_of_str_dex",
  ...CREATURE_ABILITY_KEYS
];
var CREATURE_SAVE_OPTIONS = [
  "",
  ...CREATURE_ABILITY_LABELS
];
var CREATURE_MOVEMENT_TYPES = [
  ["walk", "Gehen"],
  ["climb", "Klettern"],
  ["fly", "Fliegen"],
  ["swim", "Schwimmen"],
  ["burrow", "Graben"]
];
var CREATURE_DAMAGE_PRESETS = [
  "Acid",
  "Bludgeoning",
  "Bludgeoning (magisch)",
  "Bludgeoning (nichtmagisch)",
  "Cold",
  "Fire",
  "Force",
  "Lightning",
  "Necrotic",
  "Piercing",
  "Piercing (magisch)",
  "Piercing (nichtmagisch)",
  "Poison",
  "Psychic",
  "Radiant",
  "Slashing",
  "Slashing (magisch)",
  "Slashing (nichtmagisch)",
  "Thunder",
  "Alle au\xDFer Force",
  "Alle au\xDFer Psychic",
  "Nichtmagische Angriffe",
  "Magische Angriffe",
  "Nichtmagische Waffen",
  "Nichtmagische Angriffe (nicht versilbert)",
  "Nichtmagische Angriffe (nicht aus Adamantit)"
];
var CREATURE_CONDITION_PRESETS = [
  "Blinded",
  "Charmed",
  "Deafened",
  "Exhaustion",
  "Frightened",
  "Grappled",
  "Incapacitated",
  "Invisible",
  "Paralyzed",
  "Petrified",
  "Poisoned",
  "Prone",
  "Restrained",
  "Stunned",
  "Unconscious"
];
var CREATURE_SENSE_PRESETS = [
  "Blindsight",
  "Darkvision",
  "Tremorsense",
  "Truesight",
  "Passive Perception",
  "Telepathy"
];
var CREATURE_PASSIVE_PRESETS = [
  "Passive Perception",
  "Passive Insight",
  "Passive Investigation"
];
var CREATURE_LANGUAGE_PRESETS = [
  "Common",
  "Dwarvish",
  "Elvish",
  "Giant",
  "Gnomish",
  "Goblin",
  "Halfling",
  "Orc",
  "Abyssal",
  "Celestial",
  "Draconic",
  "Deep Speech",
  "Infernal",
  "Primordial",
  "Aquan",
  "Auran",
  "Ignan",
  "Terran",
  "Sylvan",
  "Undercommon",
  "Druidic",
  "Thieves' Cant"
];

// src/apps/library/create/shared/creature-controls.ts
function mountPresetSelectEditor(parent, title, options, model, config) {
  const resolved = typeof config === "string" ? { placeholder: config } : config ?? {};
  const {
    placeholder,
    inlineLabel,
    rowClass,
    defaultAddButtonLabel,
    addButtonLabel,
    settingClass
  } = resolved;
  const setting = new import_obsidian21.Setting(parent).setName(title);
  setting.settingEl.addClass("sm-cc-setting");
  if (settingClass) {
    const classes = Array.isArray(settingClass) ? settingClass : [settingClass];
    setting.settingEl.classList.add(...classes);
  }
  const rowClasses = ["sm-cc-searchbar"];
  if (rowClass) rowClasses.push(rowClass);
  const row = setting.controlEl.createDiv({ cls: rowClasses.join(" ") });
  let labelEl;
  let controlId;
  if (inlineLabel) {
    controlId = `sm-cc-select-${Math.random().toString(36).slice(2)}`;
    labelEl = row.createEl("label", { text: inlineLabel, attr: { for: controlId } });
  }
  const selectAttrs = {};
  if (controlId) selectAttrs.id = controlId;
  else selectAttrs["aria-label"] = `${title} ausw\xE4hlen`;
  const select = row.createEl(
    "select",
    Object.keys(selectAttrs).length ? { attr: selectAttrs } : void 0
  );
  const blank = select.createEl("option", { text: "Auswahl\u2026" });
  blank.value = "";
  for (const option of options) {
    const opt = select.createEl("option", { text: option });
    opt.value = option;
  }
  const selectHandle = enhanceExistingSelectDropdown(select, placeholder ?? "Such-dropdown\u2026");
  const searchInput = select._smSearchInput;
  if (searchInput) {
    if (placeholder) searchInput.placeholder = placeholder;
    if (!searchInput.id) {
      searchInput.id = controlId ?? `sm-cc-input-${Math.random().toString(36).slice(2)}`;
    }
    if (labelEl) labelEl.htmlFor = searchInput.id;
    else searchInput.setAttribute("aria-label", placeholder ?? title);
  }
  const fallbackAddLabel = defaultAddButtonLabel ?? "+";
  const effectiveAddLabel = addButtonLabel ?? fallbackAddLabel;
  const addBtn = row.createEl("button", {
    text: effectiveAddLabel,
    attr: { type: "button", "aria-label": `${title} hinzuf\xFCgen` }
  });
  const chips = setting.controlEl.createDiv({ cls: "sm-cc-chips" });
  const renderChips = () => {
    chips.empty();
    model.get().forEach((txt, index) => {
      const chip = chips.createDiv({ cls: "sm-cc-chip" });
      chip.createSpan({ text: txt });
      const removeBtn = chip.createEl("button", {
        cls: "sm-cc-chip__remove",
        text: "\xD7",
        attr: { type: "button", "aria-label": `${txt} entfernen` }
      });
      removeBtn.onclick = () => {
        model.remove(index);
        renderChips();
      };
    });
  };
  const addEntry = () => {
    const selectedValue = select.value.trim();
    const typedValue = searchInput?.value.trim() ?? "";
    let value = selectedValue;
    if (!value && typedValue) {
      const match = Array.from(select.options).find(
        (opt) => opt.text.trim().toLowerCase() === typedValue.toLowerCase()
      );
      value = match ? match.value.trim() : typedValue;
    }
    if (!value) {
      select.value = "";
      if (searchInput) searchInput.value = "";
      return;
    }
    model.add(value);
    select.value = "";
    if (searchInput) searchInput.value = "";
    renderChips();
  };
  addBtn.onclick = addEntry;
  if (searchInput) {
    searchInput.addEventListener("keydown", (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        addEntry();
      }
    });
  }
  renderChips();
}
function mountDamageResponseEditor(parent, damageLists, onChange) {
  const configs = [
    {
      kind: "res",
      label: "Resistenz",
      list: damageLists.resistances,
      chipClass: "sm-cc-damage-chip--res"
    },
    {
      kind: "imm",
      label: "Immunit\xE4t",
      list: damageLists.immunities,
      chipClass: "sm-cc-damage-chip--imm"
    },
    {
      kind: "vuln",
      label: "Verwundbarkeit",
      list: damageLists.vulnerabilities,
      chipClass: "sm-cc-damage-chip--vuln"
    }
  ];
  const setting = new import_obsidian21.Setting(parent).setName("Schadenstyp-Reaktionen");
  setting.settingEl.addClass("sm-cc-setting");
  const row = setting.controlEl.createDiv({ cls: "sm-cc-searchbar sm-cc-damage-row" });
  row.createEl("label", { cls: "sm-cc-damage-label", text: "Schadenstyp" });
  const select = row.createEl("select", { cls: "sm-cc-damage-select" });
  const blank = select.createEl("option", { text: "Auswahl\u2026" });
  blank.value = "";
  for (const option of CREATURE_DAMAGE_PRESETS) {
    const opt = select.createEl("option", { text: option });
    opt.value = option;
  }
  const selectHandle = enhanceExistingSelectDropdown(select, "Schadenstyp suchen\u2026");
  const searchInput = select._smSearchInput;
  const typeWrap = row.createDiv({ cls: "sm-cc-damage-type" });
  typeWrap.createSpan({ cls: "sm-cc-damage-type__label", text: "Status" });
  const btnWrap = typeWrap.createDiv({ cls: "sm-cc-damage-type__buttons" });
  let activeConfig = configs[0];
  const buttons = /* @__PURE__ */ new Map();
  for (const config of configs) {
    const btn = btnWrap.createEl("button", {
      cls: "sm-cc-damage-type__btn",
      text: config.label,
      attr: { type: "button" }
    });
    buttons.set(config.kind, btn);
    btn.onclick = () => {
      activeConfig = config;
      for (const [kind, button] of buttons) {
        if (kind === config.kind) button.addClass("is-active");
        else button.removeClass("is-active");
      }
    };
  }
  buttons.get(activeConfig.kind)?.addClass("is-active");
  const addBtn = row.createEl("button", {
    cls: "sm-cc-damage-add",
    text: "+ Hinzuf\xFCgen",
    attr: { type: "button" }
  });
  const chips = setting.controlEl.createDiv({ cls: "sm-cc-chips sm-cc-damage-chips" });
  const normalize = (value) => value.trim().toLowerCase();
  const renderChips = () => {
    chips.empty();
    for (const config of configs) {
      config.list.forEach((entry, index) => {
        const chip = chips.createDiv({ cls: `sm-cc-chip sm-cc-damage-chip ${config.chipClass}` });
        chip.createSpan({ cls: "sm-cc-damage-chip__name", text: entry });
        chip.createSpan({ cls: "sm-cc-damage-chip__badge", text: config.label });
        const removeBtn = chip.createEl("button", {
          cls: "sm-cc-chip__remove",
          text: "\xD7",
          attr: { type: "button", "aria-label": `${config.label} entfernen` }
        });
        removeBtn.onclick = () => {
          config.list.splice(index, 1);
          renderChips();
        };
      });
    }
    onChange?.(damageLists);
  };
  const addEntry = () => {
    const selectedValue = select.value.trim();
    const typedValue = searchInput?.value.trim() ?? "";
    let value = selectedValue;
    if (!value && typedValue) {
      const match = Array.from(select.options).find(
        (opt) => opt.text.trim().toLowerCase() === typedValue.toLowerCase()
      );
      value = match ? match.value.trim() : typedValue;
    }
    const trimmed = value.trim();
    if (!trimmed) {
      select.value = "";
      if (searchInput) searchInput.value = "";
      return;
    }
    const list = activeConfig.list;
    if (list.some((entry) => normalize(entry) === normalize(trimmed))) {
      return;
    }
    list.push(trimmed);
    select.value = "";
    if (searchInput) searchInput.value = "";
    renderChips();
  };
  addBtn.addEventListener("click", addEntry);
  if (searchInput) {
    searchInput.addEventListener("keydown", (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        addEntry();
      }
    });
  }
  renderChips();
}
function mountMovementEditor(parent, title, movementTypes, model, onChange) {
  const setting = new import_obsidian21.Setting(parent).setName(title);
  setting.settingEl.addClass("sm-cc-setting");
  const row = setting.controlEl.createDiv({ cls: "sm-cc-searchbar sm-cc-movement-row" });
  const select = row.createEl("select", { cls: "sm-cc-movement-select" });
  const blank = select.createEl("option", { text: "Bewegungsart\u2026" });
  blank.value = "";
  for (const [type, label] of movementTypes) {
    const opt = select.createEl("option", { text: label });
    opt.value = type;
  }
  const selectHandle = enhanceExistingSelectDropdown(select, "Bewegungsart suchen\u2026");
  const searchInput = select._smSearchInput;
  const distanceInput = row.createEl("input", {
    cls: "sm-cc-movement-distance",
    attr: { type: "text", placeholder: "30 ft." }
  });
  const hoverId = `movement-hover-${Math.random().toString(36).slice(2)}`;
  const hoverCheckbox = row.createDiv({ cls: "sm-cc-movement-hover" });
  const hoverInput = hoverCheckbox.createEl("input", {
    attr: { type: "checkbox", id: hoverId }
  });
  hoverCheckbox.createEl("label", { text: "Hover", attr: { for: hoverId } });
  const addBtn = row.createEl("button", {
    cls: "sm-cc-movement-add",
    text: "+ Hinzuf\xFCgen",
    attr: { type: "button" }
  });
  const chips = setting.controlEl.createDiv({ cls: "sm-cc-chips sm-cc-movement-chips" });
  const renderChips = () => {
    chips.empty();
    model.get().forEach((entry, index) => {
      const chip = chips.createDiv({ cls: "sm-cc-chip sm-cc-movement-chip" });
      chip.createSpan({ cls: "sm-cc-movement-chip__label", text: entry.label });
      chip.createSpan({ cls: "sm-cc-movement-chip__distance", text: entry.distance });
      if (entry.hover) {
        chip.createSpan({ cls: "sm-cc-movement-chip__badge", text: "Hover" });
      }
      const removeBtn = chip.createEl("button", {
        cls: "sm-cc-chip__remove",
        text: "\xD7",
        attr: { type: "button", "aria-label": `${entry.label} entfernen` }
      });
      removeBtn.onclick = () => {
        model.remove(index);
        renderChips();
        onChange?.();
      };
    });
  };
  const addEntry = () => {
    const selectedType = select.value.trim();
    if (!selectedType) {
      return;
    }
    const distance = distanceInput.value.trim();
    if (!distance) {
      return;
    }
    const selectedOption = movementTypes.find(([type2]) => type2 === selectedType);
    if (!selectedOption) return;
    const [type, label] = selectedOption;
    model.add({
      type,
      label,
      distance,
      hover: hoverInput.checked
    });
    select.value = "";
    if (searchInput) searchInput.value = "";
    distanceInput.value = "";
    hoverInput.checked = false;
    renderChips();
    onChange?.();
  };
  addBtn.addEventListener("click", addEntry);
  if (searchInput) {
    searchInput.addEventListener("keydown", (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        addEntry();
      }
    });
  }
  distanceInput.addEventListener("keydown", (evt) => {
    if (evt.key === "Enter") {
      evt.preventDefault();
      addEntry();
    }
  });
  renderChips();
}

// src/apps/library/create/shared/stat-utils.ts
function parseIntSafe(value) {
  if (typeof value === "number") {
    return Number.isFinite(value) ? Math.trunc(value) : NaN;
  }
  const match = String(value ?? "").match(/-?\d+/);
  return match ? parseInt(match[0], 10) : NaN;
}
function abilityMod(score) {
  const numeric = typeof score === "number" ? score : parseIntSafe(score);
  if (Number.isNaN(numeric)) return 0;
  return Math.floor((numeric - 10) / 2);
}
function formatSigned(value) {
  return `${value >= 0 ? "+" : ""}${value}`;
}

// src/apps/library/create/creature/components/section-helpers.ts
var LAW_CHAOS_OPTIONS = [
  { value: "", label: "" },
  { value: "Lawful", label: "Rechtschaffen" },
  { value: "Neutral", label: "Neutral" },
  { value: "Chaotic", label: "Chaotisch" }
];
var GOOD_EVIL_OPTIONS = [
  { value: "", label: "" },
  { value: "Good", label: "Gut" },
  { value: "Neutral", label: "Neutral" },
  { value: "Evil", label: "B\xF6se" }
];
function createAlignmentEditor(options) {
  const { grid, data } = options;
  let lawChaosDropdown = null;
  let goodEvilDropdown = null;
  const refreshControls = () => {
    const hasOverride = Boolean((data.alignmentOverride ?? "").trim());
    const toggleDropdown = (dropdown) => {
      if (!dropdown) return;
      if (hasOverride) {
        dropdown.selectEl.setAttribute("disabled", "true");
        dropdown.selectEl.setAttribute("aria-disabled", "true");
      } else {
        dropdown.selectEl.removeAttribute("disabled");
        dropdown.selectEl.removeAttribute("aria-disabled");
      }
    };
    toggleDropdown(lawChaosDropdown);
    toggleDropdown(goodEvilDropdown);
  };
  const lawChaosSetting = grid.createSetting("Gesetz/Chaos", {
    className: "sm-cc-setting--show-name"
  });
  lawChaosSetting.addDropdown((dd) => {
    lawChaosDropdown = dd;
    for (const option of LAW_CHAOS_OPTIONS) dd.addOption(option.value, option.label);
    dd.onChange((value) => {
      data.alignmentLawChaos = value || void 0;
    });
    dd.selectEl.classList.add("sm-cc-select");
    const handle = enhanceExistingSelectDropdown(dd.selectEl, "Such-dropdown\u2026");
    handle.setValue(data.alignmentLawChaos ?? "");
    refreshControls();
  });
  const goodEvilSetting = grid.createSetting("Gut/B\xF6se", {
    className: "sm-cc-setting--show-name"
  });
  goodEvilSetting.addDropdown((dd) => {
    goodEvilDropdown = dd;
    for (const option of GOOD_EVIL_OPTIONS) dd.addOption(option.value, option.label);
    dd.onChange((value) => {
      data.alignmentGoodEvil = value || void 0;
    });
    dd.selectEl.classList.add("sm-cc-select");
    const handle = enhanceExistingSelectDropdown(dd.selectEl, "Such-dropdown\u2026");
    handle.setValue(data.alignmentGoodEvil ?? "");
    refreshControls();
  });
  const overrideSetting = grid.createSetting("Alignment-Override", {
    className: [
      "sm-cc-setting--span-2",
      "sm-cc-setting--show-name",
      "sm-cc-setting--alignment-override"
    ]
  });
  overrideSetting.addText((t) => {
    const applyOverride = (raw) => {
      const trimmed = raw.trim();
      if (trimmed) data.alignmentOverride = trimmed;
      else data.alignmentOverride = void 0;
      refreshControls();
    };
    t.setPlaceholder('z. B. Unaligned oder "Lawful Neutral"').setValue(data.alignmentOverride ?? "").onChange(applyOverride);
    t.inputEl.addEventListener("input", () => applyOverride(t.inputEl.value));
    t.inputEl.classList.add("sm-cc-input", "sm-cc-input--alignment-override");
  });
  refreshControls();
}
function ensureSpeeds(data) {
  const speeds = data.speeds ?? (data.speeds = {});
  if (!Array.isArray(speeds.extras)) speeds.extras = [];
  return speeds;
}
function applySpeedValue(data, key, patch) {
  const speeds = ensureSpeeds(data);
  const prev = speeds[key] ?? {};
  const next = { ...prev, ...patch };
  const hasContent = Boolean(next.distance?.trim()) || next.hover || Boolean(next.note?.trim());
  if (hasContent) speeds[key] = next;
  else delete speeds[key];
}
function createMovementModel(data, movementTypes) {
  return {
    get: () => {
      const speeds = ensureSpeeds(data);
      const entries = [];
      for (const [type, label] of movementTypes) {
        const speed = speeds[type];
        if (speed?.distance) {
          entries.push({
            type,
            label,
            distance: speed.distance,
            hover: speed.hover
          });
        }
      }
      if (speeds.extras) {
        for (const extra of speeds.extras) {
          entries.push({
            type: "custom",
            label: extra.label,
            distance: extra.distance ?? "",
            hover: extra.hover
          });
        }
      }
      return entries;
    },
    add: (entry) => {
      const speeds = ensureSpeeds(data);
      const standardType = movementTypes.find(([type]) => type === entry.type);
      if (standardType) {
        const [type] = standardType;
        applySpeedValue(data, type, {
          distance: entry.distance,
          hover: entry.hover
        });
      } else {
        if (!speeds.extras) speeds.extras = [];
        speeds.extras.push({
          label: entry.label,
          distance: entry.distance,
          hover: entry.hover
        });
      }
    },
    remove: (index) => {
      const entries = model.get();
      if (index < 0 || index >= entries.length) return;
      const entry = entries[index];
      const speeds = ensureSpeeds(data);
      const standardType = movementTypes.find(([type]) => type === entry.type);
      if (standardType) {
        const [type] = standardType;
        delete speeds[type];
      } else {
        if (speeds.extras) {
          const extraIndex = speeds.extras.findIndex(
            (e) => e.label === entry.label && e.distance === entry.distance
          );
          if (extraIndex !== -1) {
            speeds.extras.splice(extraIndex, 1);
          }
        }
      }
    },
    update: (index, updates) => {
    }
  };
  const model = {
    get: function() {
      const speeds = ensureSpeeds(data);
      const entries = [];
      for (const [type, label] of movementTypes) {
        const speed = speeds[type];
        if (speed?.distance) {
          entries.push({ type, label, distance: speed.distance, hover: speed.hover });
        }
      }
      if (speeds.extras) {
        for (const extra of speeds.extras) {
          entries.push({ type: "custom", label: extra.label, distance: extra.distance ?? "", hover: extra.hover });
        }
      }
      return entries;
    },
    add: function(entry) {
      const speeds = ensureSpeeds(data);
      const standardType = movementTypes.find(([type]) => type === entry.type);
      if (standardType) {
        const [type] = standardType;
        applySpeedValue(data, type, { distance: entry.distance, hover: entry.hover });
      } else {
        if (!speeds.extras) speeds.extras = [];
        speeds.extras.push({ label: entry.label, distance: entry.distance, hover: entry.hover });
      }
    },
    remove: function(index) {
      const entries = model.get();
      if (index < 0 || index >= entries.length) return;
      const entry = entries[index];
      const speeds = ensureSpeeds(data);
      const standardType = movementTypes.find(([type]) => type === entry.type);
      if (standardType) {
        const [type] = standardType;
        delete speeds[type];
      } else {
        if (speeds.extras) {
          const extraIndex = speeds.extras.findIndex(
            (e) => e.label === entry.label && e.distance === entry.distance
          );
          if (extraIndex !== -1) speeds.extras.splice(extraIndex, 1);
        }
      }
    },
    update: function(index, updates) {
    }
  };
  return model;
}
function createStatColumn(parent, options) {
  const { abilities, data, onUpdate } = options;
  const refs = /* @__PURE__ */ new Map();
  const columnEl = parent.createDiv({ cls: "sm-cc-stats-col" });
  const header = columnEl.createDiv({ cls: "sm-cc-stats-col__header" });
  header.createSpan({
    cls: "sm-cc-stats-col__header-cell sm-cc-stats-col__header-cell--mod",
    text: "Mod"
  });
  const saveHead = header.createDiv({
    cls: "sm-cc-stats-col__header-cell sm-cc-stats-col__header-cell--save"
  });
  saveHead.createSpan({ cls: "sm-cc-stats-col__header-save-label", text: "Save" });
  saveHead.createSpan({ cls: "sm-cc-stats-col__header-save-mod", text: "Mod" });
  if (!data.abilities) data.abilities = [];
  if (!data.saves) data.saves = [];
  for (const ability of abilities) {
    const row = columnEl.createDiv({ cls: "sm-cc-stat-row" });
    row.createSpan({ cls: "sm-cc-stat-row__label", text: ability.label });
    const scoreWrap = row.createDiv({ cls: "sm-inline-number sm-cc-stat-row__score" });
    const score = scoreWrap.createEl("input", {
      attr: { type: "number", placeholder: "10", min: "0", step: "1" }
    });
    score.addClass("sm-cc-stat-row__score-input");
    const dec = scoreWrap.createEl("button", { text: "\u2212", cls: "btn-compact" });
    const inc = scoreWrap.createEl("button", { text: "+", cls: "btn-compact" });
    const existingAbility = data.abilities.find((a) => a.ability === ability.key);
    score.value = existingAbility ? String(existingAbility.score) : "";
    const step = (delta) => {
      const cur = parseInt(score.value, 10) || 0;
      const next = Math.max(0, cur + delta);
      score.value = String(next);
      data.abilities = data.abilities.filter((a) => a.ability !== ability.key);
      if (next > 0) {
        data.abilities.push({ ability: ability.key, score: next });
      }
      onUpdate();
    };
    dec.onclick = () => step(-1);
    inc.onclick = () => step(1);
    score.addEventListener("input", () => {
      const value = score.value.trim();
      data.abilities = data.abilities.filter((a) => a.ability !== ability.key);
      if (value !== "") {
        const scoreValue = parseInt(value);
        if (!isNaN(scoreValue) && scoreValue > 0) {
          data.abilities.push({ ability: ability.key, score: scoreValue });
        }
      }
      onUpdate();
    });
    const modOut = row.createSpan({ cls: "sm-cc-stat-row__mod-value", text: "+0" });
    const saveWrap = row.createDiv({ cls: "sm-cc-stat-row__save" });
    const saveInput = saveWrap.createEl("input", {
      attr: {
        type: "number",
        placeholder: "Auto",
        "aria-label": `${ability.label} Save Bonus (leave empty for auto-calculation)`
      }
    });
    saveInput.addClass("sm-cc-stat-row__save-input");
    const saveOut = saveWrap.createSpan({ cls: "sm-cc-stat-row__save-mod", text: "+0" });
    const existingSave = data.saves.find((s) => s.ability === ability.key);
    if (existingSave) {
      saveInput.value = String(existingSave.bonus);
    }
    saveInput.addEventListener("input", () => {
      const value = saveInput.value.trim();
      data.saves = data.saves.filter((s) => s.ability !== ability.key);
      if (value !== "") {
        const bonus = parseInt(value);
        if (!isNaN(bonus)) {
          data.saves.push({ ability: ability.key, bonus });
        }
      }
      onUpdate();
    });
    refs.set(ability.key, { score, mod: modOut, save: saveInput, saveMod: saveOut });
  }
  return refs;
}
function createSkillManager(options) {
  const { parent, data, getAbilityMod, getProficiencyBonus: getProficiencyBonus2, onUpdate } = options;
  const skillAbilityMap = new Map(CREATURE_SKILLS);
  const refs = /* @__PURE__ */ new Map();
  const ensureSkills = () => {
    if (!data.skills) data.skills = [];
  };
  const searchRow = parent.createDiv({ cls: "sm-cc-searchbar sm-cc-skill-search" });
  const selectId = "sm-cc-skill-select";
  const select = searchRow.createEl("select", {
    attr: { id: selectId, "aria-label": "Fertigkeit ausw\xE4hlen" }
  });
  const blankOption = select.createEl("option", { text: "Fertigkeit w\xE4hlen\u2026" });
  blankOption.value = "";
  for (const [name] of CREATURE_SKILLS) {
    const opt = select.createEl("option", { text: name });
    opt.value = name;
  }
  const selectHandle = enhanceExistingSelectDropdown(select, "Fertigkeit suchen\u2026");
  const searchInput = select._smSearchInput;
  if (searchInput) {
    searchInput.placeholder = "Fertigkeit suchen\u2026";
    if (!searchInput.id) searchInput.id = `${selectId}-search`;
    searchInput.setAttribute("aria-label", "Fertigkeit suchen");
  }
  const addBtn = searchRow.createEl("button", {
    text: "+",
    attr: { type: "button", "aria-label": "Fertigkeit hinzuf\xFCgen" }
  });
  const chipsContainer = parent.createDiv({ cls: "sm-cc-chips sm-cc-skill-chips" });
  const addSkill = (rawName) => {
    const name = rawName.trim();
    if (!name || !skillAbilityMap.has(name)) return;
    ensureSkills();
    if (!data.skills.find((s) => s.name === name)) {
      const abilityKey = skillAbilityMap.get(name);
      const mod2 = abilityKey ? getAbilityMod(abilityKey) : 0;
      const pb = getProficiencyBonus2();
      const bonus = mod2 + pb;
      data.skills.push({ name, bonus });
      render();
    }
  };
  addBtn.onclick = () => {
    const selected = select.value.trim();
    const typed = searchInput?.value.trim() ?? "";
    let value = selected;
    if (!value && typed) {
      const match = Array.from(select.options).find(
        (opt) => opt.text.trim().toLowerCase() === typed.toLowerCase()
      );
      if (match) value = match.value.trim();
    }
    if (searchInput) searchInput.value = "";
    select.value = "";
    addSkill(value);
  };
  const render = () => {
    ensureSkills();
    chipsContainer.empty();
    refs.clear();
    const skills = data.skills ?? [];
    for (const skill of skills) {
      const chip = chipsContainer.createDiv({ cls: "sm-cc-chip sm-cc-skill-chip" });
      chip.createSpan({ cls: "sm-cc-skill-chip__name", text: skill.name });
      const abilityKey = skillAbilityMap.get(skill.name);
      const mod2 = abilityKey ? getAbilityMod(abilityKey) : 0;
      const pb = getProficiencyBonus2();
      const autoBonus = mod2 + pb;
      const bonusInput = chip.createEl("input", {
        cls: "sm-cc-skill-chip__bonus-input",
        attr: {
          type: "number",
          placeholder: String(autoBonus),
          "aria-label": `${skill.name} Bonus`
        }
      });
      bonusInput.value = String(skill.bonus);
      bonusInput.addEventListener("input", () => {
        const value = bonusInput.value.trim();
        if (value !== "") {
          const newBonus = parseInt(value);
          if (!isNaN(newBonus)) {
            skill.bonus = newBonus;
            updateMods();
            onUpdate();
          }
        }
      });
      const modOut = chip.createSpan({ cls: "sm-cc-skill-chip__mod", text: "+0" });
      const removeBtn = chip.createEl("button", {
        cls: "sm-cc-chip__remove",
        text: "\xD7",
        attr: { "aria-label": `${skill.name} entfernen` }
      });
      removeBtn.onclick = () => {
        ensureSkills();
        data.skills = data.skills.filter((s) => s.name !== skill.name);
        render();
      };
      refs.set(skill.name, { mod: modOut, bonusInput });
    }
    updateMods();
  };
  const updateMods = () => {
    for (const [name, ref] of refs) {
      const skill = data.skills?.find((s) => s.name === name);
      if (skill) {
        const total = skill.bonus;
        ref.mod.textContent = total >= 0 ? `+${total}` : String(total);
      }
    }
  };
  return { refs, render, addSkill };
}

// src/apps/library/create/creature/sections.ts
init_entry_model();

// src/apps/library/create/creature/components/entry-card.ts
init_entry_model();

// src/apps/library/create/creature/entry-presets.ts
var ENTRY_PRESETS = [
  // === Traits ===
  {
    category: "trait",
    name: "Amphibious",
    text: "The creature can breathe air and water."
  },
  {
    category: "trait",
    name: "Magic Resistance",
    text: "The creature has Advantage on saving throws against spells and other magical effects."
  },
  {
    category: "trait",
    name: "Legendary Resistance (3/Day)",
    text: "If the creature fails a saving throw, it can choose to succeed instead."
  },
  {
    category: "trait",
    name: "Pack Tactics",
    text: "The creature has Advantage on an attack roll against a creature if at least one of its allies is within 5 feet of the creature and the ally doesn't have the Incapacitated condition."
  },
  {
    category: "trait",
    name: "Spider Climb",
    text: "The creature can climb difficult surfaces, including along ceilings, without needing to make an ability check."
  },
  {
    category: "trait",
    name: "Keen Hearing and Smell",
    text: "The creature has Advantage on Wisdom (Perception) checks that rely on hearing or smell."
  },
  {
    category: "trait",
    name: "Keen Sight",
    text: "The creature has Advantage on Wisdom (Perception) checks that rely on sight."
  },
  {
    category: "trait",
    name: "Undead Fortitude",
    text: "If damage reduces the creature to 0 Hit Points, it makes a Constitution saving throw (DC 5 plus the damage taken) unless the damage is Radiant or from a Critical Hit. On a successful save, the creature drops to 1 Hit Point instead."
  },
  {
    category: "trait",
    name: "Immutable Form",
    text: "The creature can't shape-shift."
  },
  {
    category: "trait",
    name: "Sunlight Sensitivity",
    text: "While in Sunlight, the creature has Disadvantage on attack rolls, as well as on Wisdom (Perception) checks that rely on sight."
  },
  // === Actions ===
  {
    category: "action",
    name: "Multiattack",
    text: "The creature makes two attacks."
  },
  {
    category: "action",
    name: "Bite",
    kind: "Melee Attack Roll",
    range: "reach 5 ft.",
    target: "one target",
    to_hit_ability: "str",
    to_hit_proficient: true,
    damage_dice: "1d6",
    damage_ability: "str",
    damage_type: "piercing"
  },
  {
    category: "action",
    name: "Claw",
    kind: "Melee Attack Roll",
    range: "reach 5 ft.",
    target: "one target",
    to_hit_ability: "str",
    to_hit_proficient: true,
    damage_dice: "1d4",
    damage_ability: "str",
    damage_type: "slashing"
  },
  {
    category: "action",
    name: "Slam",
    kind: "Melee Attack Roll",
    range: "reach 5 ft.",
    target: "one target",
    to_hit_ability: "str",
    to_hit_proficient: true,
    damage_dice: "1d6",
    damage_ability: "str",
    damage_type: "bludgeoning"
  },
  {
    category: "action",
    name: "Longsword",
    kind: "Melee Attack Roll",
    range: "reach 5 ft.",
    target: "one target",
    to_hit_ability: "str",
    to_hit_proficient: true,
    damage_dice: "1d8",
    damage_ability: "str",
    damage_type: "slashing"
  },
  {
    category: "action",
    name: "Shortsword",
    kind: "Melee Attack Roll",
    range: "reach 5 ft.",
    target: "one target",
    to_hit_ability: "best_of_str_dex",
    to_hit_proficient: true,
    damage_dice: "1d6",
    damage_ability: "best_of_str_dex",
    damage_type: "piercing"
  },
  {
    category: "action",
    name: "Scimitar",
    kind: "Melee Attack Roll",
    range: "reach 5 ft.",
    target: "one target",
    to_hit_ability: "best_of_str_dex",
    to_hit_proficient: true,
    damage_dice: "1d6",
    damage_ability: "best_of_str_dex",
    damage_type: "slashing"
  },
  {
    category: "action",
    name: "Spear",
    kind: "Melee or Ranged Attack Roll",
    range: "reach 5 ft. or range 20/60 ft.",
    target: "one target",
    to_hit_ability: "str",
    to_hit_proficient: true,
    damage_dice: "1d6",
    damage_ability: "str",
    damage_type: "piercing"
  },
  {
    category: "action",
    name: "Shortbow",
    kind: "Ranged Attack Roll",
    range: "range 80/320 ft.",
    target: "one target",
    to_hit_ability: "dex",
    to_hit_proficient: true,
    damage_dice: "1d6",
    damage_ability: "dex",
    damage_type: "piercing"
  },
  {
    category: "action",
    name: "Longbow",
    kind: "Ranged Attack Roll",
    range: "range 150/600 ft.",
    target: "one target",
    to_hit_ability: "dex",
    to_hit_proficient: true,
    damage_dice: "1d8",
    damage_ability: "dex",
    damage_type: "piercing"
  },
  {
    category: "action",
    name: "Fire Breath",
    kind: "Dexterity Saving Throw",
    range: "15-foot Cone or 30-foot Line",
    save_ability: "DEX",
    save_dc: 10,
    save_effect: "Half damage",
    recharge: "Recharge 5\u20136",
    damage: "2d6 fire",
    damage_dice: "2d6",
    damage_type: "fire",
    text: "*Failure:* damage. *Success:* Half damage."
  },
  {
    category: "action",
    name: "Poison Breath",
    kind: "Constitution Saving Throw",
    range: "15-foot Cone",
    save_ability: "CON",
    save_dc: 10,
    save_effect: "Half damage",
    recharge: "Recharge 5\u20136",
    damage: "2d6 poison",
    damage_dice: "2d6",
    damage_type: "poison",
    text: "*Failure:* damage. *Success:* Half damage."
  },
  // === Bonus Actions ===
  {
    category: "bonus",
    name: "Nimble Escape",
    text: "The creature takes the Disengage or Hide action."
  },
  {
    category: "bonus",
    name: "Cunning Action",
    text: "The creature takes the Dash, Disengage, or Hide action."
  },
  // === Reactions ===
  {
    category: "reaction",
    name: "Parry",
    text: "The creature adds 2 to its AC against one melee attack that would hit it. To do so, the creature must see the attacker and be wielding a melee weapon."
  },
  {
    category: "reaction",
    name: "Shield",
    text: "The creature casts *Shield* in response to being hit by an attack."
  },
  // === Legendary Actions ===
  {
    category: "legendary",
    name: "Detect",
    text: "The creature makes a Wisdom (Perception) check."
  },
  {
    category: "legendary",
    name: "Move",
    text: "The creature moves up to its Speed without provoking Opportunity Attacks."
  },
  {
    category: "legendary",
    name: "Attack",
    text: "The creature makes one attack."
  }
];
function findEntryPresets(query, category) {
  const lowerQuery = query.toLowerCase().trim();
  if (!lowerQuery) return [];
  return ENTRY_PRESETS.filter((preset) => {
    if (category && preset.category !== category) return false;
    return preset.name.toLowerCase().includes(lowerQuery);
  }).slice(0, 10);
}

// src/apps/library/create/creature/components/entry-card.ts
var import_obsidian23 = require("obsidian");

// src/apps/library/create/creature/components/entry-helpers.ts
var import_obsidian22 = require("obsidian");
var DAMAGE_TYPES = [
  // Physical
  { value: "slashing", label: "Slashing", category: "physical" },
  { value: "piercing", label: "Piercing", category: "physical" },
  { value: "bludgeoning", label: "Bludgeoning", category: "physical" },
  // Elemental
  { value: "fire", label: "Fire", category: "elemental" },
  { value: "cold", label: "Cold", category: "elemental" },
  { value: "lightning", label: "Lightning", category: "elemental" },
  { value: "thunder", label: "Thunder", category: "elemental" },
  { value: "acid", label: "Acid", category: "elemental" },
  { value: "poison", label: "Poison", category: "elemental" },
  // Magical
  { value: "necrotic", label: "Necrotic", category: "magical" },
  { value: "radiant", label: "Radiant", category: "magical" },
  { value: "force", label: "Force", category: "magical" },
  { value: "psychic", label: "Psychic", category: "magical" }
];
function validateDiceNotation(dice) {
  if (!dice || !dice.trim()) return false;
  const dicePattern = /^\d+d\d+([+-]\d+)?$/i;
  return dicePattern.test(dice.trim());
}
function parseDiceNotation(dice) {
  const trimmed = dice.trim();
  if (!validateDiceNotation(trimmed)) return null;
  const match = trimmed.match(/^(\d+)d(\d+)([+-]\d+)?$/i);
  if (!match) return null;
  return {
    count: parseInt(match[1], 10),
    sides: parseInt(match[2], 10),
    modifier: match[3] ? parseInt(match[3], 10) : 0
  };
}
function calculateAverageDamage(dice, bonus = 0) {
  const parsed = parseDiceNotation(dice);
  if (!parsed) return 0;
  const diceAverage = parsed.count * ((parsed.sides + 1) / 2);
  return Math.floor(diceAverage + parsed.modifier + bonus);
}
function formatDamageString(instance, data) {
  let bonus = 0;
  if (instance.bonus === "auto" && instance.bonusAbility) {
    const abilKey = instance.bonusAbility.toLowerCase();
    if (abilKey === "best_of_str_dex") {
      const strMod = abilityMod(data.str);
      const dexMod = abilityMod(data.dex);
      bonus = Math.max(strMod, dexMod);
    } else {
      bonus = abilityMod(data[abilKey]);
    }
  } else if (typeof instance.bonus === "number") {
    bonus = instance.bonus;
  }
  const average = calculateAverageDamage(instance.dice, bonus);
  const bonusStr = bonus !== 0 ? ` ${formatSigned(bonus)}` : "";
  const diceStr = `${instance.dice}${bonusStr}`;
  let damageStr = `${average} (${diceStr}) ${instance.damageType}`;
  if (instance.condition) {
    damageStr += ` (${instance.condition})`;
  }
  return damageStr;
}
function createDamageInstanceUI(parent, instance, index, data, onChange, onDelete, isFirst) {
  const container = parent.createDiv({
    cls: `sm-cc-damage-instance ${instance.isAdditional ? "sm-cc-damage-instance--additional" : "sm-cc-damage-instance--primary"}`
  });
  const header = container.createDiv({ cls: "sm-cc-damage-instance-header" });
  const label = header.createSpan({
    cls: "sm-cc-damage-instance-label",
    text: instance.isAdditional ? "Additional Damage" : "Primary Damage"
  });
  if (!isFirst || instance.isAdditional) {
    const deleteBtn = header.createEl("button", {
      cls: "sm-cc-damage-delete-btn",
      attr: { type: "button", "aria-label": "Delete Damage" }
    });
    (0, import_obsidian22.setIcon)(deleteBtn, "x");
    deleteBtn.onclick = onDelete;
  }
  const grid = container.createDiv({ cls: "sm-cc-damage-grid" });
  grid.createEl("label", { text: "Dice", cls: "sm-cc-damage-label" });
  const diceInputWrapper = grid.createDiv({ cls: "sm-cc-damage-dice-wrapper" });
  const diceInput = createTextInput2(diceInputWrapper, {
    className: "sm-cc-damage-dice-input",
    placeholder: "2d6",
    ariaLabel: "Damage Dice",
    value: instance.dice || "",
    onInput: (value) => {
      instance.dice = value.trim();
      if (value.trim() && !validateDiceNotation(value.trim())) {
        diceInputWrapper.addClass("sm-cc-damage-dice-invalid");
      } else {
        diceInputWrapper.removeClass("sm-cc-damage-dice-invalid");
      }
      onChange();
    }
  });
  const validationIcon = diceInputWrapper.createSpan({ cls: "sm-cc-damage-dice-validation" });
  if (instance.dice && !validateDiceNotation(instance.dice)) {
    (0, import_obsidian22.setIcon)(validationIcon, "alert-circle");
    diceInputWrapper.addClass("sm-cc-damage-dice-invalid");
  }
  grid.createEl("label", { text: "Bonus", cls: "sm-cc-damage-label" });
  const bonusWrapper = grid.createDiv({ cls: "sm-cc-damage-bonus-wrapper" });
  const bonusInput = createTextInput2(bonusWrapper, {
    className: "sm-cc-damage-bonus-input",
    placeholder: "auto",
    ariaLabel: "Damage Bonus",
    value: instance.bonus === "auto" ? "auto" : instance.bonus !== void 0 ? String(instance.bonus) : "",
    onInput: (value) => {
      const trimmed = value.trim().toLowerCase();
      if (trimmed === "auto" || trimmed === "") {
        instance.bonus = trimmed === "auto" ? "auto" : void 0;
      } else {
        const num = parseInt(trimmed, 10);
        instance.bonus = isNaN(num) ? void 0 : num;
      }
      if (instance.bonus === "auto") {
        abilityWrapper.style.display = "";
      } else {
        abilityWrapper.style.display = "none";
      }
      onChange();
    }
  });
  bonusInput.style.width = "6ch";
  grid.createEl("label", { text: "Ability", cls: "sm-cc-damage-label" });
  const abilityWrapper = grid.createDiv({ cls: "sm-cc-damage-ability-wrapper" });
  const abilitySelect = createSelectDropdown(abilityWrapper, {
    className: "sm-cc-damage-ability-select",
    options: [
      { value: "", label: "(none)" },
      { value: "str", label: "STR" },
      { value: "dex", label: "DEX" },
      { value: "con", label: "CON" },
      { value: "int", label: "INT" },
      { value: "wis", label: "WIS" },
      { value: "cha", label: "CHA" },
      { value: "best_of_str_dex", label: "Best of STR/DEX" }
    ],
    value: instance.bonusAbility || "",
    onChange: (value) => {
      instance.bonusAbility = value || void 0;
      onChange();
    }
  });
  if (instance.bonus !== "auto") {
    abilityWrapper.style.display = "none";
  }
  grid.createEl("label", { text: "Type", cls: "sm-cc-damage-label" });
  const damageTypeSelect = createSelectDropdown(grid, {
    className: "sm-cc-damage-type-select",
    options: DAMAGE_TYPES.map((t) => ({ value: t.value, label: t.label })),
    value: instance.damageType || "slashing",
    enableSearch: true,
    searchPlaceholder: "Search damage type...",
    onChange: (value) => {
      instance.damageType = value;
      onChange();
    }
  });
  grid.createEl("label", { text: "Condition", cls: "sm-cc-damage-label" });
  createTextInput2(grid, {
    className: "sm-cc-damage-condition-input",
    placeholder: "if target is prone",
    ariaLabel: "Damage Condition",
    value: instance.condition || "",
    onInput: (value) => {
      instance.condition = value.trim() || void 0;
      onChange();
    }
  });
  const preview = container.createDiv({ cls: "sm-cc-damage-preview" });
  const updatePreview = () => {
    if (instance.dice && validateDiceNotation(instance.dice)) {
      const formatted = formatDamageString(instance, data);
      preview.textContent = instance.isAdditional ? `plus ${formatted}` : formatted;
      preview.addClass("sm-cc-damage-preview--valid");
    } else {
      preview.textContent = instance.dice ? "Invalid dice notation" : "Enter dice notation";
      preview.removeClass("sm-cc-damage-preview--valid");
    }
  };
  updatePreview();
  const originalOnChange = onChange;
  onChange = () => {
    updatePreview();
    originalOnChange();
  };
  return container;
}
function createDamageComponent(parent, options) {
  const { damages, data, onChange, maxDamages = 5 } = options;
  const section = parent.createDiv({ cls: "sm-cc-damage-component" });
  const header = section.createDiv({ cls: "sm-cc-damage-header" });
  header.createEl("h4", { text: "Damage", cls: "sm-cc-damage-title" });
  const container = section.createDiv({ cls: "sm-cc-damage-instances" });
  const renderDamages = () => {
    container.empty();
    if (damages.length === 0) {
      damages.push({
        dice: "",
        damageType: "slashing",
        isAdditional: false
      });
    }
    damages.forEach((damage, index) => {
      createDamageInstanceUI(
        container,
        damage,
        index,
        data,
        onChange,
        () => {
          damages.splice(index, 1);
          renderDamages();
          onChange();
        },
        index === 0
      );
    });
    if (damages.length < maxDamages) {
      const addBtn = container.createEl("button", {
        cls: "sm-cc-damage-add-btn",
        text: "+ Additional Damage",
        attr: { type: "button" }
      });
      addBtn.onclick = () => {
        damages.push({
          dice: "",
          damageType: "fire",
          isAdditional: true
        });
        renderDamages();
        onChange();
      };
    }
  };
  renderDamages();
  return section;
}
function damageInstancesToString(damages, data) {
  return damages.filter((d) => d.dice && validateDiceNotation(d.dice)).map((d, index) => {
    const formatted = formatDamageString(d, data);
    return index === 0 ? formatted : `plus ${formatted}`;
  }).join(", ");
}
function parseDamageString(damageStr) {
  const instances = [];
  if (!damageStr || !damageStr.trim()) return instances;
  const parts = damageStr.split(/(?:,\s*)?plus\s+/i);
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i].trim();
    if (!part) continue;
    const typeMatch = part.match(/\b(slashing|piercing|bludgeoning|fire|cold|lightning|thunder|acid|poison|necrotic|radiant|force|psychic)\b/i);
    const damageType = typeMatch?.[1]?.toLowerCase() || "slashing";
    const diceMatch = part.match(/\(([^)]+)\)/);
    const diceStr = diceMatch?.[1]?.trim() || "";
    const diceOnly = diceStr.match(/(\d+d\d+)/i)?.[1] || diceStr;
    const bonusMatch = diceStr.match(/([+-]\s*\d+)/);
    const bonus = bonusMatch ? parseInt(bonusMatch[1].replace(/\s/g, ""), 10) : void 0;
    instances.push({
      dice: diceOnly,
      bonus,
      damageType,
      isAdditional: i > 0
    });
  }
  return instances;
}

// src/apps/library/create/creature/components/entry-card.ts
var COMPONENT_TYPES = [
  {
    type: "attack",
    label: "Attack Roll",
    icon: "sword",
    description: "To hit, reach/range, and target",
    category: "combat"
  },
  {
    type: "damage",
    label: "Damage",
    icon: "zap",
    description: "Damage dice, type, and effects",
    category: "combat"
  },
  {
    type: "save",
    label: "Saving Throw",
    icon: "shield",
    description: "Save DC and effects",
    category: "combat"
  },
  {
    type: "condition",
    label: "Condition",
    icon: "alert-circle",
    description: "Apply conditions like poisoned, stunned",
    category: "effects"
  },
  {
    type: "area",
    label: "Area of Effect",
    icon: "circle-dashed",
    description: "Cone, sphere, line, etc.",
    category: "combat"
  },
  {
    type: "recharge",
    label: "Recharge",
    icon: "refresh-cw",
    description: "Recharge 5-6, daily limits",
    category: "meta"
  },
  {
    type: "uses",
    label: "Limited Uses",
    icon: "hash",
    description: "Number of uses per day/rest",
    category: "meta"
  }
];
function generateComponentId() {
  return `component-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
function createDefaultComponentData(type) {
  switch (type) {
    case "attack":
      return { type: "attack" };
    case "save":
      return { type: "save" };
    case "damage":
      return { type: "damage", damages: [] };
    case "condition":
      return { type: "condition", condition: "" };
    case "area":
      return { type: "area", area_type: "sphere", size: "20 ft." };
    case "recharge":
      return { type: "recharge", recharge: "Recharge 5-6" };
    case "uses":
      return { type: "uses", uses: "1/Day" };
  }
}
function migrateEntryToComponents(entry) {
  if (entry.components && entry.components.length > 0) return;
  entry.components = [];
  if (entry.to_hit || entry.to_hit_from || entry.reach || entry.target) {
    entry.components.push({
      type: "attack",
      id: generateComponentId(),
      data: {
        type: "attack",
        to_hit: entry.to_hit,
        to_hit_from: entry.to_hit_from,
        reach: entry.reach,
        target: entry.target
      }
    });
  }
  if (entry.save_ability || entry.save_dc || entry.save_effect) {
    entry.components.push({
      type: "save",
      id: generateComponentId(),
      data: {
        type: "save",
        save_ability: entry.save_ability,
        save_dc: entry.save_dc,
        save_effect: entry.save_effect
      }
    });
  }
  if (entry.damage || entry.damage_from) {
    const damages = entry.damage ? parseDamageString(entry.damage) : [];
    entry.components.push({
      type: "damage",
      id: generateComponentId(),
      data: {
        type: "damage",
        damage: entry.damage,
        damage_from: entry.damage_from,
        damages
      }
    });
  }
  if (entry.recharge) {
    entry.components.push({
      type: "recharge",
      id: generateComponentId(),
      data: {
        type: "recharge",
        recharge: entry.recharge
      }
    });
  }
}
function createComponentCard(parent, component, entry, data, onUpdate, onDelete, onMoveUp, onMoveDown, canMoveUp, canMoveDown) {
  const metadata = COMPONENT_TYPES.find((t) => t.type === component.type);
  if (!metadata) {
    console.error(`Unknown component type: ${component.type}`);
    return parent.createDiv({ cls: "sm-cc-component-card sm-cc-component-card--error" });
  }
  const card = parent.createDiv({
    cls: `sm-cc-component-card sm-cc-component-card--${component.type}`,
    attr: { "data-component-id": component.id }
  });
  const header = card.createDiv({ cls: "sm-cc-component-header" });
  const labelGroup = header.createDiv({ cls: "sm-cc-component-label-group" });
  const iconEl = labelGroup.createSpan({ cls: "sm-cc-component-icon" });
  (0, import_obsidian23.setIcon)(iconEl, metadata.icon);
  labelGroup.createSpan({ cls: "sm-cc-component-label", text: metadata.label });
  const controls = header.createDiv({ cls: "sm-cc-component-controls" });
  const moveUpBtn = controls.createEl("button", {
    cls: "sm-cc-component-btn",
    attr: {
      type: "button",
      "aria-label": "Move Up",
      disabled: !canMoveUp ? "true" : void 0
    }
  });
  (0, import_obsidian23.setIcon)(moveUpBtn, "chevron-up");
  moveUpBtn.onclick = onMoveUp;
  const moveDownBtn = controls.createEl("button", {
    cls: "sm-cc-component-btn",
    attr: {
      type: "button",
      "aria-label": "Move Down",
      disabled: !canMoveDown ? "true" : void 0
    }
  });
  (0, import_obsidian23.setIcon)(moveDownBtn, "chevron-down");
  moveDownBtn.onclick = onMoveDown;
  const duplicateBtn = controls.createEl("button", {
    cls: "sm-cc-component-btn",
    attr: { type: "button", "aria-label": "Duplicate" }
  });
  (0, import_obsidian23.setIcon)(duplicateBtn, "copy");
  duplicateBtn.onclick = () => {
    const newComponent = {
      type: component.type,
      id: generateComponentId(),
      data: structuredClone ? structuredClone(component.data) : JSON.parse(JSON.stringify(component.data))
    };
    const index = entry.components.indexOf(component);
    entry.components.splice(index + 1, 0, newComponent);
    onUpdate();
  };
  const deleteBtn = controls.createEl("button", {
    cls: "sm-cc-component-btn sm-cc-component-btn--delete",
    attr: { type: "button", "aria-label": "Delete" }
  });
  (0, import_obsidian23.setIcon)(deleteBtn, "trash-2");
  deleteBtn.onclick = onDelete;
  const content = card.createDiv({ cls: "sm-cc-component-content" });
  renderComponentContent(content, component, entry, data, onUpdate);
  return card;
}
function renderComponentContent(parent, component, entry, data, onUpdate) {
  switch (component.type) {
    case "attack":
      renderAttackComponent(parent, component.data, entry, data, onUpdate);
      break;
    case "save":
      renderSaveComponent(parent, component.data, entry, data, onUpdate);
      break;
    case "damage":
      renderDamageComponent(parent, component.data, entry, data, onUpdate);
      break;
    case "condition":
      renderConditionComponent(parent, component.data, onUpdate);
      break;
    case "area":
      renderAreaComponent(parent, component.data, onUpdate);
      break;
    case "recharge":
      renderRechargeComponent(parent, component.data, onUpdate);
      break;
    case "uses":
      renderUsesComponent(parent, component.data, onUpdate);
      break;
  }
}
function renderAttackComponent(parent, data, entry, statblockData, onUpdate) {
  const grid = parent.createDiv({ cls: "sm-cc-component-grid" });
  grid.createEl("label", { text: "To Hit" });
  const toHitInput = createTextInput2(grid, {
    placeholder: "Auto",
    ariaLabel: "To Hit",
    value: data.to_hit || "",
    onInput: (value) => {
      data.to_hit = value.trim() || void 0;
      onUpdate();
    }
  });
  grid.createEl("label", { text: "Reach/Range" });
  createTextInput2(grid, {
    placeholder: "5 ft. / 30/120 ft.",
    ariaLabel: "Reach/Range",
    value: data.reach || "",
    onInput: (value) => {
      data.reach = value.trim() || void 0;
      onUpdate();
    }
  });
  grid.createEl("label", { text: "Target" });
  createTextInput2(grid, {
    placeholder: "one target",
    ariaLabel: "Target",
    value: data.target || "",
    onInput: (value) => {
      data.target = value.trim() || void 0;
      onUpdate();
    }
  });
}
function renderSaveComponent(parent, data, entry, statblockData, onUpdate) {
  const grid = parent.createDiv({ cls: "sm-cc-component-grid" });
  grid.createEl("label", { text: "Save" });
  createSelectDropdown(grid, {
    options: CREATURE_SAVE_OPTIONS.map((v) => ({ value: v, label: v || "(none)" })),
    value: data.save_ability || "",
    onChange: (value) => {
      data.save_ability = value || void 0;
      onUpdate();
    }
  });
  grid.createEl("label", { text: "DC" });
  createNumberInput2(grid, {
    placeholder: "DC",
    ariaLabel: "DC",
    value: data.save_dc,
    min: 1,
    max: 30,
    onChange: (value) => {
      data.save_dc = value;
      onUpdate();
    }
  });
  grid.createEl("label", { text: "On Success" });
  createTextInput2(grid, {
    placeholder: "half damage",
    ariaLabel: "Save Effect",
    value: data.save_effect || "",
    onInput: (value) => {
      data.save_effect = value.trim() || void 0;
      onUpdate();
    }
  });
}
function renderDamageComponent(parent, data, entry, statblockData, onUpdate) {
  if (!data.damages) {
    data.damages = data.damage ? parseDamageString(data.damage) : [];
  }
  createDamageComponent(parent, {
    damages: data.damages,
    data: statblockData,
    onChange: () => {
      data.damage = damageInstancesToString(data.damages, statblockData);
      onUpdate();
    }
  });
}
function renderConditionComponent(parent, data, onUpdate) {
  const grid = parent.createDiv({ cls: "sm-cc-component-grid" });
  grid.createEl("label", { text: "Condition" });
  createTextInput2(grid, {
    placeholder: "poisoned, stunned, etc.",
    ariaLabel: "Condition",
    value: data.condition || "",
    onInput: (value) => {
      data.condition = value.trim();
      onUpdate();
    }
  });
  grid.createEl("label", { text: "Duration" });
  createTextInput2(grid, {
    placeholder: "1 minute, until end of next turn",
    ariaLabel: "Duration",
    value: data.duration || "",
    onInput: (value) => {
      data.duration = value.trim() || void 0;
      onUpdate();
    }
  });
  const saveCheckbox = parent.createDiv({ cls: "sm-cc-component-checkbox" });
  const checkbox = saveCheckbox.createEl("input", {
    attr: { type: "checkbox" }
  });
  checkbox.checked = data.save_at_end || false;
  checkbox.onchange = () => {
    data.save_at_end = checkbox.checked;
    onUpdate();
  };
  saveCheckbox.createEl("label", { text: "Can save at end of each turn" });
}
function renderAreaComponent(parent, data, onUpdate) {
  const grid = parent.createDiv({ cls: "sm-cc-component-grid" });
  grid.createEl("label", { text: "Type" });
  createSelectDropdown(grid, {
    options: [
      { value: "sphere", label: "Sphere" },
      { value: "cone", label: "Cone" },
      { value: "line", label: "Line" },
      { value: "cube", label: "Cube" },
      { value: "cylinder", label: "Cylinder" },
      { value: "custom", label: "Custom" }
    ],
    value: data.area_type,
    onChange: (value) => {
      data.area_type = value;
      onUpdate();
    }
  });
  grid.createEl("label", { text: "Size" });
  createTextInput2(grid, {
    placeholder: "20 ft.",
    ariaLabel: "Size",
    value: data.size || "",
    onInput: (value) => {
      data.size = value.trim();
      onUpdate();
    }
  });
}
function renderRechargeComponent(parent, data, onUpdate) {
  const container = parent.createDiv({ cls: "sm-cc-component-field" });
  container.createEl("label", { text: "Recharge" });
  createTextInput2(container, {
    placeholder: "Recharge 5-6",
    ariaLabel: "Recharge",
    value: data.recharge || "",
    onInput: (value) => {
      data.recharge = value.trim();
      onUpdate();
    }
  });
}
function renderUsesComponent(parent, data, onUpdate) {
  const container = parent.createDiv({ cls: "sm-cc-component-field" });
  container.createEl("label", { text: "Uses" });
  createTextInput2(container, {
    placeholder: "1/Day, 3/Day each",
    ariaLabel: "Uses",
    value: data.uses || "",
    onInput: (value) => {
      data.uses = value.trim();
      onUpdate();
    }
  });
}
function createComponentSelector(parent, entry, onUpdate) {
  const selector = parent.createDiv({ cls: "sm-cc-component-selector" });
  const categories = {
    combat: [],
    effects: [],
    meta: []
  };
  COMPONENT_TYPES.forEach((type) => {
    categories[type.category].push(type);
  });
  const dropdown = selector.createEl("select", { cls: "sm-cc-component-select" });
  const placeholder = dropdown.createEl("option", {
    text: "+ Add Component...",
    attr: { value: "", selected: "true", disabled: "true" }
  });
  Object.entries(categories).forEach(([category, types]) => {
    const group = dropdown.createEl("optgroup", {
      attr: { label: category.charAt(0).toUpperCase() + category.slice(1) }
    });
    types.forEach((type) => {
      group.createEl("option", {
        text: type.label,
        attr: { value: type.type }
      });
    });
  });
  dropdown.onchange = () => {
    const selectedType = dropdown.value;
    if (!selectedType) return;
    const newComponent = {
      type: selectedType,
      id: generateComponentId(),
      data: createDefaultComponentData(selectedType)
    };
    if (!entry.components) {
      entry.components = [];
    }
    entry.components.push(newComponent);
    dropdown.value = "";
    onUpdate();
  };
}
function createComponentsSection(parent, entry, data, onUpdate) {
  migrateEntryToComponents(entry);
  const section = parent.createDiv({ cls: "sm-cc-components-section" });
  const render = () => {
    section.empty();
    const container = section.createDiv({ cls: "sm-cc-components-list" });
    if (entry.components && entry.components.length > 0) {
      entry.components.forEach((component, index) => {
        createComponentCard(
          container,
          component,
          entry,
          data,
          () => {
            onUpdate();
            render();
          },
          () => {
            entry.components.splice(index, 1);
            onUpdate();
            render();
          },
          () => {
            if (index > 0) {
              [entry.components[index - 1], entry.components[index]] = [entry.components[index], entry.components[index - 1]];
              onUpdate();
              render();
            }
          },
          () => {
            if (index < entry.components.length - 1) {
              [entry.components[index], entry.components[index + 1]] = [entry.components[index + 1], entry.components[index]];
              onUpdate();
              render();
            }
          },
          index > 0,
          index < entry.components.length - 1
        );
      });
    }
    createComponentSelector(section, entry, () => {
      onUpdate();
      render();
    });
  };
  render();
}
function createDetailsSection(parent, entry, onUpdate) {
  const section = parent.createDiv({ cls: "sm-cc-entry-section sm-cc-entry-section--details" });
  section.createEl("label", { cls: "sm-cc-entry-label", text: "Details" });
  createTextArea(section, {
    className: "sm-cc-entry-text",
    placeholder: "Details (Markdown)",
    ariaLabel: "Details",
    value: entry.text || "",
    onInput: (value) => {
      entry.text = value;
      onUpdate();
    }
  });
}
function createSpellcastingSection(parent, entry, data, onUpdate) {
  const section = parent.createDiv({ cls: "sm-cc-entry-section sm-cc-entry-section--spellcasting" });
  if (!entry.spellGroups) {
    entry.spellGroups = [];
  }
  const headerGrid = section.createDiv({ cls: "sm-cc-entry-grid" });
  headerGrid.createEl("label", { text: "Spell Ability" });
  const spellAbilityHandle = createSelectDropdown(headerGrid, {
    options: [
      { value: "", label: "(none)" },
      ...CREATURE_ABILITY_LABELS.map((label) => ({
        value: label.toLowerCase(),
        label
      }))
    ],
    value: entry.spellAbility || "",
    onChange: (value) => {
      entry.spellAbility = value || void 0;
      onUpdate();
    }
  });
  headerGrid.createEl("label", { text: "DC Override" });
  createNumberInput2(headerGrid, {
    placeholder: "Auto",
    ariaLabel: "DC Override",
    value: entry.spellDcOverride,
    min: 1,
    max: 30,
    onChange: (value) => {
      entry.spellDcOverride = value;
      onUpdate();
    }
  });
  headerGrid.createEl("label", { text: "Attack Override" });
  const attackOverrideInput = headerGrid.createEl("input", {
    cls: "sm-cc-input",
    attr: {
      type: "text",
      placeholder: "Auto",
      "aria-label": "Attack Override"
    }
  });
  attackOverrideInput.value = entry.spellAttackOverride !== void 0 ? String(entry.spellAttackOverride) : "";
  attackOverrideInput.oninput = () => {
    const val = attackOverrideInput.value.trim();
    entry.spellAttackOverride = val ? parseInt(val, 10) : void 0;
    onUpdate();
  };
  attackOverrideInput.style.width = "6ch";
  const groupsContainer = section.createDiv({ cls: "sm-cc-spellcasting-groups" });
  const renderAllGroups = () => {
    groupsContainer.empty();
    const groupsByType = {
      "at-will": [],
      "per-day": [],
      "level": []
    };
    entry.spellGroups?.forEach((group) => {
      if (groupsByType[group.type]) {
        groupsByType[group.type].push(group);
      }
    });
    groupsByType.level.sort((a, b) => (a.level || 0) - (b.level || 0));
    groupsByType["at-will"].forEach((group, index) => {
      renderSpellGroup2(groupsContainer, group, index, "at-will");
    });
    groupsByType["per-day"].forEach((group, index) => {
      renderSpellGroup2(groupsContainer, group, index, "per-day");
    });
    groupsByType.level.forEach((group, index) => {
      renderSpellGroup2(groupsContainer, group, index, "level");
    });
    const addButtonsRow = groupsContainer.createDiv({ cls: "sm-cc-spellcasting-add-buttons" });
    const addAtWillBtn = addButtonsRow.createEl("button", {
      cls: "sm-cc-button",
      text: "+ At-Will Group",
      attr: { type: "button" }
    });
    addAtWillBtn.onclick = () => {
      entry.spellGroups.push({
        type: "at-will",
        label: "At Will",
        spells: []
      });
      renderAllGroups();
      onUpdate();
    };
    const addPerDayBtn = addButtonsRow.createEl("button", {
      cls: "sm-cc-button",
      text: "+ Per-Day Group",
      attr: { type: "button" }
    });
    addPerDayBtn.onclick = () => {
      entry.spellGroups.push({
        type: "per-day",
        label: "1/Day each",
        spells: []
      });
      renderAllGroups();
      onUpdate();
    };
    const addLevelBtn = addButtonsRow.createEl("button", {
      cls: "sm-cc-button",
      text: "+ Spell Level",
      attr: { type: "button" }
    });
    addLevelBtn.onclick = () => {
      const usedLevels = new Set(
        entry.spellGroups.filter((g) => g.type === "level").map((g) => g.level || 0)
      );
      let nextLevel = 1;
      while (usedLevels.has(nextLevel) && nextLevel <= 9) {
        nextLevel++;
      }
      if (nextLevel <= 9) {
        entry.spellGroups.push({
          type: "level",
          level: nextLevel,
          slots: 2,
          label: getLevelLabel(nextLevel),
          spells: []
        });
        renderAllGroups();
        onUpdate();
      }
    };
  };
  const renderSpellGroup2 = (container, group, groupIndex, groupType) => {
    const groupCard = container.createDiv({ cls: `sm-cc-spell-group sm-cc-spell-group--${groupType}` });
    const groupHeader = groupCard.createDiv({ cls: "sm-cc-spell-group-header" });
    const headerLeft = groupHeader.createDiv({ cls: "sm-cc-spell-group-header-left" });
    if (groupType === "level") {
      const levelSelect = createSelectDropdown(headerLeft, {
        className: "sm-cc-spellcasting-level-select",
        options: [1, 2, 3, 4, 5, 6, 7, 8, 9].map((lvl) => ({
          value: lvl,
          label: getLevelLabel(lvl)
        })),
        value: group.level || 1,
        onChange: (value) => {
          group.level = value;
          group.label = getLevelLabel(value);
          renderAllGroups();
          onUpdate();
        }
      });
      headerLeft.createSpan({ text: " - ", cls: "sm-cc-spell-group-separator" });
      const slotsInput = createNumberInput2(headerLeft, {
        className: "sm-cc-spellcasting-slots",
        placeholder: "Slots",
        ariaLabel: "Spell Slots",
        value: group.slots || 0,
        min: 0,
        max: 20,
        onChange: (value) => {
          group.slots = value || 0;
          onUpdate();
        }
      });
      slotsInput.style.width = "4ch";
      headerLeft.createSpan({ text: " slots", cls: "sm-cc-spell-group-suffix" });
    } else {
      const labelInput = createTextInput2(headerLeft, {
        className: "sm-cc-spellcasting-group-label",
        placeholder: groupType === "at-will" ? "At Will" : "1/Day each",
        ariaLabel: "Group Label",
        value: group.label || "",
        onInput: (value) => {
          group.label = value.trim() || void 0;
          onUpdate();
        }
      });
    }
    const headerRight = groupHeader.createDiv({ cls: "sm-cc-spell-group-header-right" });
    const spellCount = group.spells.filter((s) => s.trim().length > 0).length;
    const spellCountSpan = headerRight.createSpan({
      cls: "sm-cc-spell-count",
      text: spellCount === 1 ? "1 spell" : `${spellCount} spells`
    });
    const deleteGroupBtn = headerRight.createEl("button", {
      cls: "sm-cc-entry-delete",
      text: "\xD7",
      attr: { type: "button", "aria-label": "Delete Group" }
    });
    deleteGroupBtn.onclick = () => {
      const actualIndex = entry.spellGroups.indexOf(group);
      if (actualIndex !== -1) {
        entry.spellGroups.splice(actualIndex, 1);
        renderAllGroups();
        onUpdate();
      }
    };
    const spellsList = groupCard.createDiv({ cls: "sm-cc-spellcasting-spells-list" });
    const renderSpells = () => {
      spellsList.empty();
      group.spells.forEach((spell, spellIndex) => {
        const spellItem = spellsList.createDiv({ cls: "sm-cc-spell-item" });
        const spellInput = createTextInput2(spellItem, {
          className: "sm-cc-spellcasting-spell-input",
          placeholder: "Enter spell name...",
          ariaLabel: "Spell name",
          value: spell,
          onInput: (value) => {
            group.spells[spellIndex] = value.trim();
            const newCount = group.spells.filter((s) => s.trim().length > 0).length;
            spellCountSpan.textContent = newCount === 1 ? "1 spell" : `${newCount} spells`;
            onUpdate();
          }
        });
        if (spell === "" && spellIndex === group.spells.length - 1) {
          setTimeout(() => spellInput.focus(), 0);
        }
        spellInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            group.spells.push("");
            renderSpells();
            onUpdate();
          }
        });
        const deleteSpellBtn = spellItem.createEl("button", {
          cls: "sm-cc-button-small sm-cc-spell-delete",
          text: "\xD7",
          attr: { type: "button", "aria-label": "Delete Spell" }
        });
        deleteSpellBtn.onclick = () => {
          group.spells.splice(spellIndex, 1);
          renderSpells();
          const newCount = group.spells.filter((s) => s.trim().length > 0).length;
          spellCountSpan.textContent = newCount === 1 ? "1 spell" : `${newCount} spells`;
          onUpdate();
        };
      });
      const addSpellInline = spellsList.createEl("button", {
        cls: "sm-cc-spell-add-inline",
        text: "+",
        attr: { type: "button", "aria-label": "Add Spell" }
      });
      addSpellInline.onclick = () => {
        group.spells.push("");
        renderSpells();
        onUpdate();
      };
    };
    renderSpells();
  };
  const getLevelLabel = (level) => {
    const labels = [
      "Cantrip",
      "1st Level",
      "2nd Level",
      "3rd Level",
      "4th Level",
      "5th Level",
      "6th Level",
      "7th Level",
      "8th Level",
      "9th Level"
    ];
    return labels[level] || `${level}th Level`;
  };
  renderAllGroups();
}
function createEntryCard(parent, options) {
  const { entry, index, data, onDelete, onMoveUp, onMoveDown, canMoveUp, canMoveDown, onUpdate, shouldFocus } = options;
  const currentType = inferEntryType(entry);
  const card = parent.createDiv({
    cls: `sm-cc-entry-card sm-cc-entry-card--type-${currentType}`
  });
  const head = card.createDiv({ cls: "sm-cc-entry-head" });
  const categoryText = entry.category || "action";
  const badge = head.createEl("span", {
    cls: `sm-cc-entry-badge sm-cc-entry-badge--${categoryText}`,
    text: categoryText.toUpperCase()
  });
  const nameBox = head.createDiv({ cls: "sm-cc-entry-name-box sm-preset-box" });
  const nameInput = createTextInput2(nameBox, {
    className: "sm-cc-entry-name sm-preset-input",
    placeholder: "Entry Name",
    ariaLabel: "Entry Name",
    value: entry.name || "",
    onInput: (value) => {
      entry.name = value;
      onUpdate();
    }
  });
  if (shouldFocus) {
    setTimeout(() => nameInput.focus(), 0);
  }
  let presetMenu = null;
  let selectedPresetIndex = -1;
  const showPresetMenu = (query) => {
    const presets = findEntryPresets(query);
    if (presets.length === 0) {
      hidePresetMenu();
      return;
    }
    if (!presetMenu) {
      presetMenu = nameBox.createDiv({ cls: "sm-preset-menu" });
    }
    presetMenu.empty();
    nameBox.addClass("is-open");
    presets.forEach((preset, idx) => {
      const item = presetMenu.createDiv({
        cls: idx === selectedPresetIndex ? "sm-preset-item is-selected" : "sm-preset-item"
      });
      item.textContent = preset.name;
      item.onclick = () => {
        applyPreset(preset);
        hidePresetMenu();
      };
    });
  };
  const hidePresetMenu = () => {
    nameBox.removeClass("is-open");
    selectedPresetIndex = -1;
  };
  const applyPreset = (preset) => {
    entry.name = preset.name;
    if (preset.text !== void 0) entry.text = preset.text;
    if (preset.to_hit !== void 0) entry.to_hit = preset.to_hit;
    if (preset.reach !== void 0) entry.reach = preset.reach;
    if (preset.target !== void 0) entry.target = preset.target;
    if (preset.damage !== void 0) entry.damage = preset.damage;
    if (preset.save_ability !== void 0) entry.save_ability = preset.save_ability;
    if (preset.save_dc !== void 0) entry.save_dc = preset.save_dc;
    if (preset.save_effect !== void 0) entry.save_effect = preset.save_effect;
    if (preset.recharge !== void 0) entry.recharge = preset.recharge;
    nameInput.value = preset.name;
    onUpdate();
  };
  nameInput.oninput = () => {
    const query = nameInput.value.trim();
    if (query.length > 1) {
      showPresetMenu(query);
    } else {
      hidePresetMenu();
    }
  };
  nameInput.onkeydown = (e) => {
    if (!presetMenu || !nameBox.hasClass("is-open")) return;
    const items = presetMenu.querySelectorAll(".sm-preset-item");
    if (items.length === 0) return;
    if (e.key === "ArrowDown") {
      e.preventDefault();
      selectedPresetIndex = Math.min(selectedPresetIndex + 1, items.length - 1);
      items.forEach((el, i) => {
        el.toggleClass("is-selected", i === selectedPresetIndex);
      });
    } else if (e.key === "ArrowUp") {
      e.preventDefault();
      selectedPresetIndex = Math.max(selectedPresetIndex - 1, 0);
      items.forEach((el, i) => {
        el.toggleClass("is-selected", i === selectedPresetIndex);
      });
    } else if (e.key === "Enter" && selectedPresetIndex >= 0) {
      e.preventDefault();
      const presets = findEntryPresets(nameInput.value.trim());
      if (presets[selectedPresetIndex]) {
        applyPreset(presets[selectedPresetIndex]);
        hidePresetMenu();
      }
    } else if (e.key === "Escape") {
      hidePresetMenu();
    }
  };
  nameInput.onblur = () => {
    setTimeout(() => hidePresetMenu(), 200);
  };
  const actions = head.createDiv({ cls: "sm-cc-entry-actions" });
  if (onMoveUp) {
    const moveUpBtn = actions.createEl("button", {
      cls: "sm-cc-entry-move-btn",
      attr: { type: "button", "aria-label": "Move Up", disabled: !canMoveUp ? "true" : void 0 }
    });
    (0, import_obsidian23.setIcon)(moveUpBtn, "chevron-up");
    moveUpBtn.onclick = onMoveUp;
  }
  if (onMoveDown) {
    const moveDownBtn = actions.createEl("button", {
      cls: "sm-cc-entry-move-btn",
      attr: { type: "button", "aria-label": "Move Down", disabled: !canMoveDown ? "true" : void 0 }
    });
    (0, import_obsidian23.setIcon)(moveDownBtn, "chevron-down");
    moveDownBtn.onclick = onMoveDown;
  }
  const deleteBtn = actions.createEl("button", {
    cls: "sm-cc-entry-delete",
    text: "\xD7",
    attr: { type: "button", "aria-label": "Delete Entry" }
  });
  deleteBtn.onclick = onDelete;
  migrateEntryToComponents(entry);
  createComponentsSection(card, entry, data, onUpdate);
  if (currentType === "spellcasting") {
    createSpellcastingSection(card, entry, data, onUpdate);
  }
  createDetailsSection(card, entry, onUpdate);
  return card;
}

// src/apps/library/create/creature/sections.ts
function ensureArray(data, key) {
  const current = data[key];
  if (Array.isArray(current)) return current;
  const arr = [];
  data[key] = arr;
  return arr;
}
function createTextSetting(grid, label, placeholder, key, data) {
  const setting = grid.createSetting(label);
  setting.settingEl.addClass("sm-cc-setting--show-name");
  setting.addText((t) => {
    t.setPlaceholder(placeholder).setValue(data[key] ?? "").onChange((v) => data[key] = v.trim());
    t.inputEl.classList.add("sm-cc-input");
  });
  return setting;
}
function createPresetModel(list, onMutate) {
  return {
    get: () => list,
    add: (value) => {
      const trimmed = value.trim();
      if (trimmed && !list.includes(trimmed)) {
        list.push(trimmed);
        onMutate?.();
      }
    },
    remove: (index) => {
      if (index >= 0 && index < list.length) {
        list.splice(index, 1);
        onMutate?.();
      }
    }
  };
}
function setupCreatureAutocomplete({ app, inputEl, onSelect }) {
  let container = null;
  let selectedIndex = -1;
  const hide = () => {
    container?.remove();
    container = null;
    selectedIndex = -1;
  };
  const updateSelection = () => {
    if (!container) return;
    const items = container.querySelectorAll(".sm-cc-autocomplete__item");
    items.forEach((item, index) => {
      item.classList.toggle("is-selected", index === selectedIndex);
    });
  };
  const selectItem = () => {
    if (!container || selectedIndex < 0) return;
    const items = container.querySelectorAll(".sm-cc-autocomplete__item");
    items[selectedIndex]?.click();
  };
  const show = async (query) => {
    if (query.length < 2) {
      hide();
      return;
    }
    const { findCreaturePresets: findCreaturePresets2 } = await Promise.resolve().then(() => (init_creature_presets(), creature_presets_exports));
    const results = await findCreaturePresets2(app, query, { limit: 8 });
    if (results.length === 0) {
      hide();
      return;
    }
    if (!container) {
      container = document.createElement("div");
      container.className = "sm-cc-autocomplete";
      inputEl.parentElement?.appendChild(container);
    }
    container.empty();
    selectedIndex = -1;
    results.forEach((result, index) => {
      const item = container.createDiv({ cls: "sm-cc-autocomplete__item" });
      item.createDiv({ cls: "sm-cc-autocomplete__name", text: result.data.name });
      const meta = item.createDiv({ cls: "sm-cc-autocomplete__meta" });
      const parts = [result.data.size, result.data.type, result.data.cr && `CR ${result.data.cr}`].filter(Boolean);
      meta.setText(parts.join(" \u2022 "));
      item.addEventListener("click", () => {
        hide();
        onSelect(result.data);
      });
      item.addEventListener("mouseenter", () => {
        selectedIndex = index;
        updateSelection();
      });
    });
    updateSelection();
  };
  inputEl.addEventListener("input", () => void show(inputEl.value));
  inputEl.addEventListener("keydown", (e) => {
    if (!container) return;
    const items = container.querySelectorAll(".sm-cc-autocomplete__item");
    if (items.length === 0) return;
    if (e.key === "ArrowDown") {
      e.preventDefault();
      selectedIndex = (selectedIndex + 1) % items.length;
      updateSelection();
    } else if (e.key === "ArrowUp") {
      e.preventDefault();
      selectedIndex = selectedIndex <= 0 ? items.length - 1 : selectedIndex - 1;
      updateSelection();
    } else if (e.key === "Enter" && selectedIndex >= 0) {
      e.preventDefault();
      selectItem();
    } else if (e.key === "Escape") {
      e.preventDefault();
      hide();
    }
  });
  inputEl.addEventListener("blur", () => setTimeout(hide, 200));
}
function mountCreatureClassificationSection(parent, data, options) {
  const card = createFormCard(parent, {
    title: "Identit\xE4t & Klassifikation",
    role: "group"
  });
  card.card.addClass("sm-cc-card--basics");
  card.body.addClass("sm-cc-card__body--basics");
  const identitySection = card.body.createDiv({ cls: "sm-cc-card__section sm-cc-card__section--basics" });
  const identityGrid = createFieldGrid(identitySection, {
    variant: "identity",
    className: "sm-cc-field-grid--basics",
    minColumnWidth: "18rem"
  });
  const nameSetting = identityGrid.createSetting("Name");
  nameSetting.settingEl.addClass("sm-cc-setting--show-name");
  nameSetting.addText((t) => {
    t.setPlaceholder("Aboleth oder Preset suchen...").setValue(data.name || "").onChange((v) => data.name = v.trim());
    t.inputEl.classList.add("sm-cc-input");
    if (options?.app && options?.onPresetSelected) {
      setupCreatureAutocomplete({
        app: options.app,
        inputEl: t.inputEl,
        onSelect: options.onPresetSelected
      });
    }
  });
  const typeSetting = identityGrid.createSetting("Typ");
  typeSetting.settingEl.addClass("sm-cc-setting--show-name");
  typeSetting.addDropdown((dd) => {
    dd.addOption("", "");
    CREATURE_TYPES.forEach((opt) => dd.addOption(opt, opt));
    dd.onChange((v) => data.type = v);
    dd.selectEl.classList.add("sm-cc-select");
    const handle = enhanceExistingSelectDropdown(dd.selectEl, "Such-dropdown\u2026");
    handle.setValue(data.type ?? "");
  });
  const sizeSetting = identityGrid.createSetting("Gr\xF6\xDFe");
  sizeSetting.settingEl.addClass("sm-cc-setting--show-name");
  sizeSetting.addDropdown((dd) => {
    dd.addOption("", "");
    CREATURE_SIZES.forEach((opt) => dd.addOption(opt, opt));
    dd.onChange((v) => data.size = v);
    dd.selectEl.classList.add("sm-cc-select");
    const handle = enhanceExistingSelectDropdown(dd.selectEl, "Such-dropdown\u2026");
    handle.setValue(data.size ?? "");
  });
  const tags = ensureArray(data, "typeTags");
  const typeTagsEditor = mountTokenEditor(identitySection, "Typ-Tags", {
    getItems: () => tags.slice(),
    add: (value) => {
      const normalized = value.trim();
      if (normalized && !tags.some((t) => t.toLowerCase() === normalized.toLowerCase())) {
        tags.push(normalized);
        typeTagsEditor.refresh();
      }
    },
    remove: (index) => {
      tags.splice(index, 1);
      typeTagsEditor.refresh();
    }
  }, {
    placeholder: "z. B. shapechanger",
    addButtonLabel: "+ Tag"
  });
  typeTagsEditor.setting.settingEl.addClass("sm-cc-setting--stack");
  const classificationSection = card.body.createDiv({ cls: "sm-cc-card__section sm-cc-card__section--basics" });
  const classificationGrid = createFieldGrid(classificationSection, {
    variant: "classification",
    className: "sm-cc-field-grid--basics",
    minColumnWidth: "16rem"
  });
  createAlignmentEditor({ grid: classificationGrid, data });
  createTextSetting(classificationGrid, "PB", "+4", "pb", data);
  createTextSetting(classificationGrid, "CR", "10", "cr", data);
  createTextSetting(classificationGrid, "XP", "5900", "xp", data);
}
function mountCreatureVitalSection(parent, data) {
  const card = createFormCard(parent, {
    title: "Vitalwerte & Bewegung",
    role: "group"
  });
  card.card.addClass("sm-cc-card--basics");
  card.body.addClass("sm-cc-card__body--basics");
  const vitalsSection = card.body.createDiv({ cls: "sm-cc-card__section sm-cc-card__section--basics" });
  const vitalsGrid = createFieldGrid(vitalsSection, {
    variant: "vitals",
    className: "sm-cc-field-grid--basics",
    minColumnWidth: "16rem"
  });
  createTextSetting(vitalsGrid, "AC", "17", "ac", data);
  createTextSetting(vitalsGrid, "HP", "150", "hp", data);
  createTextSetting(vitalsGrid, "Initiative", "+7", "initiative", data);
  createTextSetting(vitalsGrid, "Hit Dice", "20d10 + 40", "hitDice", data);
  const movementSection = card.body.createDiv({ cls: "sm-cc-card__section sm-cc-card__section--basics" });
  const movementModel = createMovementModel(data, CREATURE_MOVEMENT_TYPES);
  mountMovementEditor(movementSection, "Bewegungsraten", CREATURE_MOVEMENT_TYPES, movementModel);
}
function collectStatsAndSkillsIssues(data) {
  const issues = [];
  const profs = new Set(data.skillsProf ?? []);
  for (const name of data.skillsExpertise ?? []) {
    if (!profs.has(name)) {
      issues.push(`Expertise f\xFCr "${name}" setzt eine Profizient voraus.`);
    }
  }
  return issues;
}
function mountCreatureStatsAndSkillsSection(parent, data, registerValidation) {
  const root = parent.createDiv({ cls: "sm-cc-stats" });
  if (!data.saveProf) data.saveProf = {};
  if (!data.skillsProf) data.skillsProf = [];
  if (!data.skillsExpertise) data.skillsExpertise = [];
  const abilityElems = /* @__PURE__ */ new Map();
  const statsSection = root.createDiv({ cls: "sm-cc-stats-section" });
  statsSection.createEl("h4", { cls: "sm-cc-stats-section__title", text: "Stats" });
  const statsGrid = statsSection.createDiv({ cls: "sm-cc-stats-grid" });
  const abilityByKey = new Map(CREATURE_ABILITIES.map((def) => [def.key, def]));
  const statColumns = [
    ["str", "dex", "con"],
    ["int", "wis", "cha"]
  ];
  const updateMods = () => {
    const pb = parseIntSafe(data.pb) || 0;
    for (const [key, refs] of abilityElems) {
      const mod2 = abilityMod(data[key]);
      refs.mod.textContent = formatSigned(mod2);
      const saveBonus = data.saveProf?.[key] ? pb : 0;
      refs.saveMod.textContent = formatSigned(mod2 + saveBonus);
    }
    const profs = new Set(data.skillsProf ?? []);
    data.skillsExpertise = (data.skillsExpertise ?? []).filter((name) => profs.has(name));
    skillManager.render();
    revalidate();
  };
  for (const keys of statColumns) {
    const abilities = keys.map((key) => abilityByKey.get(key)).filter(Boolean);
    const refs = createStatColumn(statsGrid, {
      abilities,
      data,
      onUpdate: updateMods
    });
    for (const [key, ref] of refs) {
      abilityElems.set(key, ref);
    }
  }
  const skillsSetting = new import_obsidian24.Setting(root).setName("Fertigkeiten");
  skillsSetting.settingEl.addClass("sm-cc-skills");
  const skillsControl = skillsSetting.controlEl;
  skillsControl.addClass("sm-cc-skill-editor");
  const revalidate = registerValidation?.(() => collectStatsAndSkillsIssues(data)) ?? (() => []);
  const skillManager = createSkillManager({
    parent: skillsControl,
    data,
    getAbilityMod: (key) => abilityMod(data[key]),
    getProficiencyBonus: () => parseIntSafe(data.pb) || 0,
    onUpdate: updateMods
  });
  skillManager.render();
  updateMods();
}
function mountCreatureSensesAndDefensesSection(parent, data) {
  const root = parent.createDiv({ cls: "sm-cc-defenses" });
  const senses = ensureArray(data, "sensesList");
  const languages = ensureArray(data, "languagesList");
  const passives = ensureArray(data, "passivesList");
  const vulnerabilities = ensureArray(data, "damageVulnerabilitiesList");
  const resistances = ensureArray(data, "damageResistancesList");
  const immunities = ensureArray(data, "damageImmunitiesList");
  const conditionImmunities = ensureArray(data, "conditionImmunitiesList");
  const summary = root.createDiv({ cls: "sm-cc-defense-summary" });
  const summaryEntries = [
    { label: "Resistenzen", list: resistances, className: "sm-cc-defense-pill--res", emptyMessage: "Keine Resistenzen hinterlegt" },
    { label: "Immunit\xE4ten", list: immunities, className: "sm-cc-defense-pill--imm", emptyMessage: "Keine Immunit\xE4ten hinterlegt" },
    { label: "Verwundbarkeiten", list: vulnerabilities, className: "sm-cc-defense-pill--vuln", emptyMessage: "Keine Verwundbarkeiten hinterlegt" },
    { label: "Zustandsimmunit\xE4ten", list: conditionImmunities, className: "sm-cc-defense-pill--cond", emptyMessage: "Keine Zustandsimmunit\xE4ten hinterlegt", optional: true }
  ];
  const refreshSummary = () => {
    summary.empty();
    summary.setAttribute("role", "list");
    for (const entry of summaryEntries) {
      if (entry.optional && entry.list.length === 0) continue;
      const pill = summary.createDiv({ cls: `sm-cc-defense-pill ${entry.className}` });
      const isEmpty = entry.list.length === 0;
      if (isEmpty) pill.addClass("is-empty");
      const tooltip = entry.list.length ? entry.list.join(", ") : entry.emptyMessage;
      pill.setAttribute("title", tooltip);
      pill.setAttribute("aria-label", `${entry.label}: ${tooltip}`);
      pill.setAttribute("role", "listitem");
      pill.createSpan({ cls: "sm-cc-defense-pill__label", text: entry.label });
      pill.createSpan({ cls: "sm-cc-defense-pill__count", text: entry.list.length.toString() });
    }
    if (!summary.hasChildNodes()) {
      summary.createSpan({ cls: "sm-cc-defense-pill__empty", text: "Keine Verteidigungsmerkmale erfasst" });
    }
  };
  refreshSummary();
  const sensesLanguages = root.createDiv({ cls: "sm-cc-senses-block" });
  mountPresetSelectEditor(sensesLanguages, "Sinne", CREATURE_SENSE_PRESETS, createPresetModel(senses, refreshSummary), {
    placeholder: "Sinn suchen oder eingeben\u2026",
    rowClass: "sm-cc-senses-search",
    defaultAddButtonLabel: "+",
    settingClass: "sm-cc-senses-setting"
  });
  mountPresetSelectEditor(sensesLanguages, "Sprachen", CREATURE_LANGUAGE_PRESETS, createPresetModel(languages, refreshSummary), {
    placeholder: "Sprache suchen oder eingeben\u2026",
    rowClass: "sm-cc-senses-search",
    defaultAddButtonLabel: "+",
    settingClass: "sm-cc-senses-setting"
  });
  mountPresetSelectEditor(root, "Passive Werte", CREATURE_PASSIVE_PRESETS, createPresetModel(passives, refreshSummary), "Passiven Wert suchen oder eingeben\u2026");
  mountDamageResponseEditor(root, { vulnerabilities, resistances, immunities }, refreshSummary);
  mountPresetSelectEditor(root, "Zustandsimmunit\xE4ten", CREATURE_CONDITION_PRESETS, createPresetModel(conditionImmunities, refreshSummary), "Zustandsimmunit\xE4t suchen oder eingeben\u2026");
  const gear = ensureArray(data, "gearList");
  mountTokenEditor(root, "Ausr\xFCstung/Gear", {
    getItems: () => gear,
    add: (value) => {
      const trimmed = value.trim();
      if (trimmed && !gear.includes(trimmed)) {
        gear.push(trimmed);
        refreshSummary();
      }
    },
    remove: (index) => {
      if (index >= 0 && index < gear.length) {
        gear.splice(index, 1);
        refreshSummary();
      }
    }
  }, {
    placeholder: "Gegenstand oder Hinweis\u2026",
    addButtonLabel: "+ Hinzuf\xFCgen"
  });
}
var ENTRY_FILTER_OPTIONS = [
  { value: "all", label: "Alle", hint: "Alle Eintr\xE4ge anzeigen" },
  { value: "trait", label: "Traits", hint: "Nur Eigenschaften anzeigen" },
  { value: "action", label: "Actions", hint: "Nur Aktionen anzeigen" },
  { value: "bonus", label: "Bonus", hint: "Nur Bonusaktionen anzeigen" },
  { value: "reaction", label: "Reactions", hint: "Nur Reaktionen anzeigen" },
  { value: "legendary", label: "Legendary", hint: "Nur legend\xE4re Aktionen anzeigen" }
];
function collectEntryDependencyIssues(data) {
  const entries = data.entries ?? [];
  return entries.flatMap((entry, index) => validateEntry(entry, index));
}
function mountEntriesSection(parent, data, registerValidation) {
  if (!data.entries) data.entries = [];
  const wrap = parent.createDiv({ cls: "setting-item sm-cc-entries" });
  wrap.createDiv({ cls: "setting-item-info", text: "Eintr\xE4ge (Traits, Aktionen, \u2026)" });
  const ctl = wrap.createDiv({ cls: "setting-item-control" });
  let activeFilter = "all";
  let focusIdx = null;
  const addBar = ctl.createDiv({ cls: "sm-cc-entry-add-bar" });
  addBar.createEl("span", { cls: "sm-cc-entry-add-label", text: "Hinzuf\xFCgen:" });
  const addButtonGroup = addBar.createDiv({ cls: "sm-cc-entry-add-group" });
  for (const [value, label] of CREATURE_ENTRY_CATEGORIES) {
    const btn = addButtonGroup.createEl("button", {
      cls: `sm-cc-entry-add-btn sm-cc-entry-add-btn--${value}`,
      text: label,
      attr: { type: "button", "data-category": value }
    });
    btn.onclick = () => {
      data.entries.unshift({ category: value, name: "" });
      if (activeFilter !== "all" && activeFilter !== value) {
        activeFilter = "all";
        updateFilterButtons();
      }
      focusIdx = 0;
      render();
    };
  }
  const filterBar = ctl.createDiv({ cls: "sm-cc-entry-filter", attr: { role: "toolbar", "aria-label": "Eintragsliste filtern" } });
  const filterButtons = /* @__PURE__ */ new Map();
  const updateFilterButtons = () => {
    for (const [value, btn] of filterButtons) {
      const isActive = value === activeFilter;
      btn.setAttr("aria-pressed", isActive ? "true" : "false");
      btn.toggleClass("is-active", isActive);
    }
  };
  for (const opt of ENTRY_FILTER_OPTIONS) {
    const btn = filterBar.createEl("button", {
      text: opt.label,
      attr: { type: "button", title: opt.hint, "aria-label": opt.hint, "aria-pressed": opt.value === activeFilter ? "true" : "false" }
    });
    btn.onclick = () => {
      activeFilter = opt.value;
      updateFilterButtons();
      render();
    };
    filterButtons.set(opt.value, btn);
  }
  const host = ctl.createDiv();
  const revalidate = registerValidation?.(() => collectEntryDependencyIssues(data)) ?? (() => []);
  const render = () => {
    updateFilterButtons();
    host.empty();
    data.entries.forEach((entry, index) => {
      const shouldFocus = focusIdx === index;
      if (shouldFocus) focusIdx = null;
      const card = createEntryCard(host, {
        entry,
        index,
        data,
        onDelete: () => {
          data.entries.splice(index, 1);
          render();
        },
        onMoveUp: () => {
          if (index > 0) {
            const entries = data.entries;
            [entries[index], entries[index - 1]] = [entries[index - 1], entries[index]];
            revalidate();
            render();
          }
        },
        onMoveDown: () => {
          const entries = data.entries;
          if (index < entries.length - 1) {
            [entries[index], entries[index + 1]] = [entries[index + 1], entries[index]];
            revalidate();
            render();
          }
        },
        canMoveUp: index > 0,
        canMoveDown: index < data.entries.length - 1,
        onUpdate: () => {
          revalidate();
          render();
        },
        shouldFocus
      });
      const isVisible = activeFilter === "all" || entry.category === activeFilter;
      card.toggleClass("sm-cc-entry-hidden", !isVisible);
      card.style.display = isVisible ? "" : "none";
      card.setAttr("aria-hidden", isVisible ? "false" : "true");
    });
    revalidate();
  };
  render();
}

// src/apps/library/create/creature/modal.ts
init_entry_model();

// src/apps/library/create/shared/base-modal.ts
var import_obsidian25 = require("obsidian");
var BaseCreateModal = class extends import_obsidian25.Modal {
  constructor(app, presetOrName, onSubmit, config) {
    super(app);
    this.validationEl = null;
    this.validationIssues = [];
    // Navigation support
    this.sectionObserver = null;
    this.navButtons = [];
    this.validators = [];
    // Background pointer lock
    this.bgLock = null;
    this.onSubmit = onSubmit;
    this.config = config;
    this.data = this.initializeData(presetOrName);
  }
  /**
   * Initialize data from preset, name string, or default.
   * Subclasses can override to add type-specific defaults.
   */
  initializeData(presetOrName) {
    if (typeof presetOrName === "string") {
      return this.createDefault(presetOrName?.trim() || this.config.defaultName);
    } else if (presetOrName && typeof presetOrName === "object") {
      return this.cloneData(presetOrName);
    } else {
      return this.createDefault(this.config.defaultName);
    }
  }
  /**
   * Clone existing data object.
   * Default implementation does shallow copy, override for deep clone if needed.
   */
  cloneData(data) {
    return { ...data };
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("sm-cc-create-modal");
    this.validationIssues = [];
    this.validators = [];
    this.navButtons = [];
    this.lockBackgroundPointer();
    if (this.config.enableNavigation) {
      this.applyModalLayout();
    }
    if (this.config.enableNavigation && this.config.sections?.length) {
      this.buildNavigationLayout(contentEl);
    } else {
      this.buildSimpleLayout(contentEl);
    }
  }
  /**
   * Build simple layout without navigation (default behavior)
   */
  buildSimpleLayout(contentEl) {
    contentEl.createEl("h3", { text: this.config.title });
    this.buildFields(contentEl);
    this.validationEl = contentEl.createDiv({ cls: "sm-cc-validation" });
    this.buildActionButtons(contentEl);
    this.scope.register([], "Enter", (evt) => {
      if (!(evt.target instanceof HTMLTextAreaElement)) {
        this.submit();
      }
    });
  }
  /**
   * Build navigation layout with sections
   */
  buildNavigationLayout(contentEl) {
    const header = contentEl.createDiv({ cls: "sm-cc-modal-header" });
    header.createEl("h2", { text: this.config.title });
    if (this.config.subtitle) {
      header.createEl("p", {
        cls: "sm-cc-modal-subtitle",
        text: this.config.subtitle
      });
    }
    const shell = contentEl.createDiv({ cls: "sm-cc-shell" });
    const nav = shell.createEl("nav", { cls: "sm-cc-shell__nav", attr: { "aria-label": "Abschnitte" } });
    nav.createEl("p", { cls: "sm-cc-shell__nav-label", text: "Abschnitte" });
    const navList = nav.createDiv({ cls: "sm-cc-shell__nav-list" });
    const content = shell.createDiv({ cls: "sm-cc-shell__content" });
    const setActive = (sectionId) => {
      for (const entry of this.navButtons) {
        const isActive = entry.id === sectionId;
        entry.button.classList.toggle("is-active", isActive);
        if (isActive) {
          entry.button.setAttribute("aria-current", "true");
        } else {
          entry.button.removeAttribute("aria-current");
        }
      }
    };
    const observer = new IntersectionObserver((entries) => {
      const visible = entries.filter((entry) => entry.isIntersecting);
      if (!visible.length) return;
      visible.sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top);
      const next = visible[0].target.id;
      if (next) setActive(next);
    }, { root: contentEl, rootMargin: "-45% 0px -45% 0px", threshold: 0 });
    this.sectionObserver = observer;
    for (const section of this.config.sections) {
      this.createSection(section, content, navList, observer, setActive);
    }
    if (this.config.sections.length) {
      setActive(this.config.sections[0].id);
    }
    const footer = contentEl.createDiv({ cls: "sm-cc-modal-footer" });
    this.buildActionButtons(footer);
  }
  /**
   * Create a single section in navigation layout
   */
  createSection(section, content, navList, observer, setActive) {
    const handles = createFormCard(content, {
      title: section.title,
      subtitle: section.subtitle,
      registerValidator: (runner) => this.addValidator(runner),
      id: section.id
    });
    const navButton = navList.createEl("button", {
      cls: "sm-cc-shell__nav-button",
      text: section.navLabel ?? section.title
    });
    navButton.type = "button";
    navButton.setAttribute("aria-controls", handles.card.id);
    this.navButtons.push({ id: handles.card.id, button: navButton });
    navButton.addEventListener("click", () => {
      setActive(handles.card.id);
      handles.card.scrollIntoView({ behavior: "smooth", block: "start" });
    });
    observer.observe(handles.card);
    section.mount(handles);
  }
  /**
   * Build submit and cancel buttons.
   * Can be overridden for custom button layout.
   */
  buildActionButtons(container) {
    const buttons = new import_obsidian25.Setting(container);
    buttons.addButton((btn) => {
      btn.setButtonText(this.config.cancelButtonText || "Abbrechen").onClick(() => this.close());
    });
    buttons.addButton((btn) => {
      btn.setButtonText(this.config.submitButtonText || "Erstellen").setCta().onClick(() => this.submit());
    });
  }
  /**
   * Validate and submit the form.
   */
  submit() {
    const validatorIssues = this.runValidators();
    const configIssues = this.config.validate?.(this.data) ?? [];
    this.validationIssues = [...validatorIssues, ...configIssues];
    if (this.validationIssues.length > 0) {
      if (this.config.enableNavigation) {
        const firstInvalid = this.contentEl.querySelector(".sm-cc-card.is-invalid");
        if (firstInvalid) firstInvalid.scrollIntoView({ behavior: "smooth", block: "center" });
      } else {
        this.showValidationErrors(this.validationIssues);
      }
      return;
    }
    if (!this.data.name || !this.data.name.trim()) {
      if (!this.config.enableNavigation) {
        this.showValidationErrors(["Name ist erforderlich"]);
      }
      return;
    }
    this.clearValidationErrors();
    this.onSubmit(this.data);
    this.close();
  }
  /**
   * Display validation errors in the validation area.
   */
  showValidationErrors(errors) {
    if (!this.validationEl) return;
    this.validationEl.empty();
    this.validationEl.createEl("p", {
      text: "Validation errors:",
      cls: "sm-cc-validation__title"
    });
    const ul = this.validationEl.createEl("ul");
    for (const error of errors) {
      ul.createEl("li", { text: error });
    }
  }
  /**
   * Clear validation error display.
   */
  clearValidationErrors() {
    this.validationEl?.empty();
  }
  /**
   * Helper to create a textarea field (common pattern across modals).
   */
  addTextArea(parent, label, placeholder, onChange, initialValue, rows = 4) {
    const wrap = parent.createDiv({ cls: "setting-item" });
    wrap.createDiv({ cls: "setting-item-info", text: label });
    const ctl = wrap.createDiv({ cls: "setting-item-control" });
    const ta = ctl.createEl("textarea", { attr: { placeholder } });
    ta.rows = rows;
    ta.style.width = "100%";
    if (initialValue != null) ta.value = initialValue;
    ta.addEventListener("input", () => onChange(ta.value));
    return { wrapper: wrap, controlEl: ctl, textarea: ta };
  }
  onClose() {
    this.sectionObserver?.disconnect();
    this.sectionObserver = null;
    this.navButtons = [];
    this.validators = [];
    if (this.config.enableNavigation) {
      this.resetModalLayout();
    }
    this.restoreBackgroundPointer();
    this.contentEl.empty();
  }
  /**
   * Add a validator (used by sections in navigation mode)
   */
  addValidator(run) {
    this.validators.push(run);
    return run;
  }
  /**
   * Run all validators
   */
  runValidators() {
    const collected = [];
    for (const validator of this.validators) {
      collected.push(...validator());
    }
    return collected;
  }
  /**
   * Lock background pointer to prevent clicks
   */
  lockBackgroundPointer() {
    const bg = document.querySelector(".modal-bg");
    if (!bg) return;
    this.bgLock = { el: bg, pointer: bg.style.pointerEvents };
    bg.style.pointerEvents = "none";
  }
  /**
   * Restore background pointer
   */
  restoreBackgroundPointer() {
    if (!this.bgLock) return;
    this.bgLock.el.style.pointerEvents = this.bgLock.pointer || "";
    this.bgLock = null;
  }
  /**
   * Apply modal layout CSS
   */
  applyModalLayout() {
    this.modalEl.addClass("sm-cc-create-modal-host");
  }
  /**
   * Reset modal layout CSS
   */
  resetModalLayout() {
    this.modalEl.removeClass("sm-cc-create-modal-host");
  }
};

// src/apps/library/create/creature/modal.ts
var CreateCreatureModal = class _CreateCreatureModal extends BaseCreateModal {
  constructor(app, presetName, onSubmit, preset) {
    super(app, preset || presetName, onSubmit, {
      title: "Neuen Statblock erstellen",
      subtitle: "Pflege zuerst Grundlagen und Attribute, anschlie\xDFend Sinne, Verteidigungen und Aktionen.",
      defaultName: "Neue Kreatur",
      submitButtonText: "Erstellen",
      cancelButtonText: "Abbrechen",
      enableNavigation: true,
      sections: [
        {
          id: "sm-cc-section-classification",
          title: "Grunddaten",
          subtitle: "Name, Typ, Gesinnung und Tags",
          mount: (handles) => mountCreatureClassificationSection(handles.body, this.data, {
            app: this.app,
            onPresetSelected: (newPreset) => {
              this.close();
              new _CreateCreatureModal(this.app, void 0, this.onSubmit, newPreset).open();
            }
          })
        },
        {
          id: "sm-cc-section-vitals",
          title: "Vitalwerte",
          subtitle: "AC, HP, Initiative und Bewegung",
          mount: (handles) => mountCreatureVitalSection(handles.body, this.data)
        },
        {
          id: "sm-cc-section-stats",
          title: "Attribute & Fertigkeiten",
          subtitle: "Attributswerte, Rettungsw\xFCrfe und Fertigkeiten",
          mount: (handles) => mountCreatureStatsAndSkillsSection(handles.body, this.data, handles.registerValidation)
        },
        {
          id: "sm-cc-section-defenses",
          title: "Sinne & Verteidigungen",
          mount: (handles) => mountCreatureSensesAndDefensesSection(handles.body, this.data)
        },
        {
          id: "sm-cc-section-entries",
          title: "Eintr\xE4ge",
          subtitle: "Traits, Aktionen, Bonusaktionen, Reaktionen und Legend\xE4res",
          mount: (handles) => mountEntriesSection(handles.body, this.data, handles.registerValidation)
        }
      ]
    });
  }
  createDefault(name) {
    return { name: name?.trim() || "Neue Kreatur" };
  }
  initializeData(presetOrName) {
    if (typeof presetOrName === "string" || !presetOrName) {
      return this.createDefault(presetOrName || this.config.defaultName);
    }
    const data = { ...presetOrName };
    if (data.spellcasting && (!data.entries || data.entries.length === 0)) {
      const spellEntry = spellcastingDataToEntry(data.spellcasting);
      if (!data.entries) data.entries = [];
      data.entries.push(spellEntry);
      delete data.spellcasting;
    }
    return data;
  }
  buildFields() {
  }
};

// src/apps/library/create/spell/modal.ts
var import_obsidian26 = require("obsidian");
init_search_dropdown();

// src/apps/library/create/spell/validation.ts
var SCALING_REQUIRES_LEVEL_MESSAGE = "Skalierende Effekte ben\xF6tigen einen Zaubergrad zwischen 1 und 9.";
var SCALING_DISALLOWS_CANTRIPS_MESSAGE = "Zaubertricks verwenden keine h\xF6heren Zauberstufen \u2013 entferne den Abschnitt oder w\xE4hle Grad 1\u20139.";
function collectSpellScalingIssues(data) {
  const issues = [];
  const scalingText = data.higher_levels?.trim();
  if (!scalingText) return issues;
  const level = data.level;
  if (!Number.isFinite(level)) {
    issues.push(SCALING_REQUIRES_LEVEL_MESSAGE);
    return issues;
  }
  if ((level ?? 0) <= 0) {
    issues.push(SCALING_DISALLOWS_CANTRIPS_MESSAGE);
  }
  return issues;
}

// src/apps/library/create/spell/modal.ts
var CreateSpellModal = class extends BaseCreateModal {
  constructor(app, preset, onSubmit) {
    super(app, preset, onSubmit, {
      title: "Neuen Zauber erstellen",
      defaultName: "Neuer Zauber",
      submitButtonText: "Erstellen"
    });
    this.runScalingValidation = null;
  }
  createDefault(name) {
    return { name };
  }
  cloneData(data) {
    return {
      ...data,
      components: data.components ? [...data.components] : void 0,
      classes: data.classes ? [...data.classes] : void 0
    };
  }
  onOpen() {
    super.onOpen();
    this.runScalingValidation = null;
  }
  buildFields(contentEl) {
    new import_obsidian26.Setting(contentEl).setName("Name").addText((t) => {
      t.setPlaceholder("Fireball").setValue(this.data.name).onChange((v) => this.data.name = v.trim());
      t.inputEl.style.width = "28ch";
    });
    new import_obsidian26.Setting(contentEl).setName("Grad").setDesc("0 = Zaubertrick").addDropdown((dd) => {
      for (let i = 0; i <= 9; i++) dd.addOption(String(i), String(i));
      const initial = Number.isFinite(this.data.level) ? String(this.data.level) : "0";
      dd.setValue(initial);
      this.data.level = parseInt(initial, 10);
      dd.onChange((v) => {
        const parsed = parseInt(v, 10);
        this.data.level = Number.isFinite(parsed) ? parsed : void 0;
        this.runScalingValidation?.();
      });
      try {
        enhanceSelectToSearch(dd.selectEl, "Such-dropdown\u2026");
      } catch {
      }
    });
    new import_obsidian26.Setting(contentEl).setName("Schule").addDropdown((dd) => {
      const schools = ["", "Abjuration", "Conjuration", "Divination", "Enchantment", "Evocation", "Illusion", "Necromancy", "Transmutation"];
      for (const s of schools) dd.addOption(s, s || "(keine)");
      dd.setValue(this.data.school || "");
      dd.onChange((v) => this.data.school = v || void 0);
      try {
        enhanceSelectToSearch(dd.selectEl, "Such-dropdown\u2026");
      } catch {
      }
    });
    new import_obsidian26.Setting(contentEl).setName("Wirkzeit").addText((t) => {
      t.setPlaceholder("1 Aktion").setValue(this.data.casting_time || "").onChange((v) => this.data.casting_time = v.trim() || void 0);
      t.inputEl.style.width = "12ch";
    });
    new import_obsidian26.Setting(contentEl).setName("Reichweite").addText((t) => {
      t.setPlaceholder("60 Fu\xDF").setValue(this.data.range || "").onChange((v) => this.data.range = v.trim() || void 0);
      t.inputEl.style.width = "12ch";
    });
    const comps = new import_obsidian26.Setting(contentEl).setName("Komponenten");
    let cV = this.data.components?.includes("V") ?? false;
    let cS = this.data.components?.includes("S") ?? false;
    let cM = this.data.components?.includes("M") ?? false;
    const updateComps = () => {
      const arr = [];
      if (cV) arr.push("V");
      if (cS) arr.push("S");
      if (cM) arr.push("M");
      this.data.components = arr;
    };
    comps.controlEl.style.display = "grid";
    comps.controlEl.style.gridTemplateColumns = "repeat(6, max-content)";
    const mkCb = (label, on, initial) => {
      const wrap = comps.controlEl.createDiv({ cls: "sm-cc-grid__save" });
      const cb = wrap.createEl("input", { attr: { type: "checkbox" } });
      wrap.createEl("label", { text: label });
      cb.checked = initial;
      cb.addEventListener("change", () => {
        on(cb.checked);
        updateComps();
      });
    };
    mkCb("V", (v) => cV = v, cV);
    mkCb("S", (v) => cS = v, cS);
    mkCb("M", (v) => {
      cM = v;
    }, cM);
    updateComps();
    new import_obsidian26.Setting(contentEl).setName("Materialien").addText((t) => {
      t.setPlaceholder("winzige Kugel aus Guano und Schwefel").setValue(this.data.materials || "").onChange((v) => this.data.materials = v.trim() || void 0);
      t.inputEl.style.width = "34ch";
    });
    new import_obsidian26.Setting(contentEl).setName("Dauer").addText((t) => {
      t.setPlaceholder("Augenblicklich / Konzentration, bis zu 1 Minute").setValue(this.data.duration || "").onChange((v) => this.data.duration = v.trim() || void 0);
      t.inputEl.style.width = "34ch";
    });
    const flags = new import_obsidian26.Setting(contentEl).setName("Flags");
    const cbConc = flags.controlEl.createEl("input", { attr: { type: "checkbox" } });
    flags.controlEl.createEl("label", { text: "Konzentration" });
    cbConc.checked = !!this.data.concentration;
    cbConc.addEventListener("change", () => this.data.concentration = cbConc.checked);
    const cbRit = flags.controlEl.createEl("input", { attr: { type: "checkbox" } });
    flags.controlEl.createEl("label", { text: "Ritual" });
    cbRit.checked = !!this.data.ritual;
    cbRit.addEventListener("change", () => this.data.ritual = cbRit.checked);
    new import_obsidian26.Setting(contentEl).setName("Angriff").addDropdown((dd) => {
      const opts = ["", "Melee Spell Attack", "Ranged Spell Attack", "Melee Weapon Attack", "Ranged Weapon Attack"];
      for (const s of opts) dd.addOption(s, s || "(kein)");
      dd.setValue(this.data.attack || "");
      dd.onChange((v) => this.data.attack = v || void 0);
      try {
        enhanceSelectToSearch(dd.selectEl, "Such-dropdown\u2026");
      } catch {
      }
    });
    const save = new import_obsidian26.Setting(contentEl).setName("Rettungswurf");
    save.addDropdown((dd) => {
      const abil = ["", "STR", "DEX", "CON", "INT", "WIS", "CHA"];
      for (const a of abil) dd.addOption(a, a || "(kein)");
      dd.setValue(this.data.save_ability || "");
      dd.onChange((v) => this.data.save_ability = v || void 0);
      try {
        enhanceSelectToSearch(dd.selectEl, "Such-dropdown\u2026");
      } catch {
      }
    });
    save.controlEl.createEl("label", { text: "Effekt" });
    save.addText((t) => {
      t.setPlaceholder("Half on save / Negates \u2026").setValue(this.data.save_effect || "").onChange((v) => this.data.save_effect = v.trim() || void 0);
      t.inputEl.style.width = "18ch";
    });
    const dmg = new import_obsidian26.Setting(contentEl).setName("Schaden");
    dmg.controlEl.createEl("label", { text: "W\xFCrfel" });
    dmg.addText((t) => {
      t.setPlaceholder("8d6").setValue(this.data.damage || "").onChange((v) => this.data.damage = v.trim() || void 0);
      t.inputEl.style.width = "10ch";
    });
    dmg.controlEl.createEl("label", { text: "Typ" });
    dmg.addText((t) => {
      t.setPlaceholder("fire / radiant \u2026").setValue(this.data.damage_type || "").onChange((v) => this.data.damage_type = v.trim() || void 0);
      t.inputEl.style.width = "12ch";
    });
    if (!this.data.classes) this.data.classes = [];
    mountTokenEditor(contentEl, "Klassen", {
      getItems: () => this.data.classes,
      add: (value) => this.data.classes.push(value),
      remove: (index) => this.data.classes.splice(index, 1)
    });
    this.addTextArea(
      contentEl,
      "Beschreibung",
      "Beschreibung (Markdown)",
      (v) => this.data.description = v,
      this.data.description
    );
    const higherLevelsField = this.addTextArea(
      contentEl,
      "H\xF6here Grade",
      "Bei h\xF6heren Graden (Markdown)",
      (v) => {
        const trimmed = v.trim();
        this.data.higher_levels = trimmed ? trimmed : void 0;
        this.runScalingValidation?.();
      },
      this.data.higher_levels
    );
    const scalingValidation = higherLevelsField.controlEl.createDiv({ cls: "sm-setting-validation", attr: { hidden: "" } });
    const applyScalingValidation = (issues) => {
      const hasIssues = issues.length > 0;
      higherLevelsField.wrapper.toggleClass("is-invalid", hasIssues);
      if (!hasIssues) {
        scalingValidation.setAttribute("hidden", "");
        scalingValidation.classList.remove("is-visible");
        scalingValidation.empty();
        return;
      }
      scalingValidation.removeAttribute("hidden");
      scalingValidation.classList.add("is-visible");
      scalingValidation.empty();
      const list = scalingValidation.createEl("ul");
      for (const issue of issues) list.createEl("li", { text: issue });
    };
    this.runScalingValidation = () => {
      const issues = collectSpellScalingIssues(this.data);
      applyScalingValidation(issues);
      return issues;
    };
    this.runScalingValidation();
  }
  submit() {
    const scalingIssues = this.runScalingValidation?.() ?? [];
    if (scalingIssues.length > 0) return;
    super.submit();
  }
};

// src/apps/library/create/item/modal.ts
var import_obsidian27 = require("obsidian");
init_search_dropdown();

// src/apps/library/create/item/validation.ts
var NAME_REQUIRED_MESSAGE = "Item name is required.";
var CHARGES_INVALID_MESSAGE = "Max charges must be a positive number.";
var SPELLS_REQUIRE_NAMES_MESSAGE = "All spells must have a name.";
var BONUSES_REQUIRE_TYPE_MESSAGE = "All bonuses must have a type.";
var ABILITY_CHANGES_INVALID_MESSAGE = "Ability changes must have a valid ability and value.";
function collectItemValidationIssues(data) {
  const issues = [];
  if (!data.name || !data.name.trim()) {
    issues.push(NAME_REQUIRED_MESSAGE);
  }
  if (data.max_charges != null) {
    if (data.max_charges <= 0) {
      issues.push(CHARGES_INVALID_MESSAGE);
    }
  }
  if (data.spells && data.spells.length > 0) {
    for (const spell of data.spells) {
      if (!spell.name || !spell.name.trim()) {
        issues.push(SPELLS_REQUIRE_NAMES_MESSAGE);
        break;
      }
    }
  }
  if (data.bonuses && data.bonuses.length > 0) {
    for (const bonus of data.bonuses) {
      if (!bonus.type || !bonus.type.trim()) {
        issues.push(BONUSES_REQUIRE_TYPE_MESSAGE);
        break;
      }
    }
  }
  if (data.ability_changes && data.ability_changes.length > 0) {
    const validAbilities = ["str", "dex", "con", "int", "wis", "cha"];
    for (const change of data.ability_changes) {
      if (!change.ability || !validAbilities.includes(change.ability.toLowerCase())) {
        issues.push(ABILITY_CHANGES_INVALID_MESSAGE);
        break;
      }
      if (!change.value || change.value < 1 || change.value > 30) {
        issues.push(ABILITY_CHANGES_INVALID_MESSAGE);
        break;
      }
    }
  }
  return issues;
}

// src/apps/library/create/item/modal.ts
var CreateItemModal = class extends BaseCreateModal {
  constructor(app, presetNameOrData, onSubmit) {
    super(app, presetNameOrData, onSubmit, {
      title: "Create New Item",
      defaultName: "New Item",
      validate: collectItemValidationIssues,
      submitButtonText: "Create Item"
    });
  }
  createDefault(name) {
    return { name };
  }
  buildFields(contentEl) {
    contentEl.createEl("h4", { text: "Basic Information" });
    new import_obsidian27.Setting(contentEl).setName("Name").addText((t) => {
      t.setPlaceholder("Flaming Longsword").setValue(this.data.name).onChange((v) => this.data.name = v.trim());
      t.inputEl.style.width = "28ch";
    });
    new import_obsidian27.Setting(contentEl).setName("Category").addDropdown((dd) => {
      const categories = ["", "Armor", "Potion", "Ring", "Rod", "Scroll", "Staff", "Wand", "Weapon", "Wondrous Item"];
      for (const c of categories) dd.addOption(c, c || "(none)");
      dd.setValue(this.data.category || "");
      dd.onChange((v) => this.data.category = v || void 0);
      try {
        enhanceSelectToSearch(dd.selectEl, "Search\u2026");
      } catch {
      }
    });
    new import_obsidian27.Setting(contentEl).setName("Type").setDesc("e.g., 'Armor (Plate)', 'Weapon (Longsword)'").addText((t) => {
      t.setPlaceholder("Weapon (Longsword)").setValue(this.data.type || "").onChange((v) => this.data.type = v.trim() || void 0);
      t.inputEl.style.width = "28ch";
    });
    new import_obsidian27.Setting(contentEl).setName("Rarity").addDropdown((dd) => {
      const rarities = ["", "Common", "Uncommon", "Rare", "Very Rare", "Legendary", "Artifact"];
      for (const r of rarities) dd.addOption(r, r || "(none)");
      dd.setValue(this.data.rarity || "");
      dd.onChange((v) => this.data.rarity = v || void 0);
      try {
        enhanceSelectToSearch(dd.selectEl, "Search\u2026");
      } catch {
      }
    });
    const attuneSetting = new import_obsidian27.Setting(contentEl).setName("Requires Attunement");
    attuneSetting.addToggle((t) => {
      t.setValue(!!this.data.attunement);
      t.onChange((v) => this.data.attunement = v || void 0);
    });
    new import_obsidian27.Setting(contentEl).setName("Attunement Requirement").setDesc("e.g., 'by a Cleric'").addText((t) => {
      t.setPlaceholder("by a Druid, Sorcerer, Warlock, or Wizard").setValue(this.data.attunement_req || "").onChange((v) => this.data.attunement_req = v.trim() || void 0);
      t.inputEl.style.width = "34ch";
    });
    contentEl.createEl("h4", { text: "Charges System" });
    new import_obsidian27.Setting(contentEl).setName("Max Charges").addText((t) => {
      t.setPlaceholder("10").setValue(this.data.max_charges?.toString() || "").onChange((v) => {
        const num = parseInt(v);
        this.data.max_charges = Number.isFinite(num) ? num : void 0;
      });
      t.inputEl.style.width = "8ch";
      t.inputEl.type = "number";
    });
    new import_obsidian27.Setting(contentEl).setName("Recharge Formula").setDesc("e.g., '1d6 + 4'").addText((t) => {
      t.setPlaceholder("1d6 + 4").setValue(this.data.recharge_formula || "").onChange((v) => this.data.recharge_formula = v.trim() || void 0);
      t.inputEl.style.width = "12ch";
    });
    new import_obsidian27.Setting(contentEl).setName("Recharge Time").addDropdown((dd) => {
      const times = ["", "Dawn", "Dusk", "Long Rest", "Short Rest"];
      for (const time of times) dd.addOption(time, time || "(none)");
      dd.setValue(this.data.recharge_time || "");
      dd.onChange((v) => this.data.recharge_time = v || void 0);
      try {
        enhanceSelectToSearch(dd.selectEl, "Search\u2026");
      } catch {
      }
    });
    new import_obsidian27.Setting(contentEl).setName("Destruction Risk").setDesc("e.g., 'On 1, turns to water'").addText((t) => {
      t.setPlaceholder("On 1, turns to water and is destroyed").setValue(this.data.destruction_risk || "").onChange((v) => this.data.destruction_risk = v.trim() || void 0);
      t.inputEl.style.width = "34ch";
    });
    contentEl.createEl("h4", { text: "Properties & Effects" });
    this.addTextArea(
      contentEl,
      "Description",
      "While wearing this armor...",
      (v) => this.data.description = v.trim() || void 0,
      this.data.description,
      6
    );
    this.addTextArea(
      contentEl,
      "Notes",
      "Additional information...",
      (v) => this.data.notes = v.trim() || void 0,
      this.data.notes,
      3
    );
    contentEl.createEl("h4", { text: "Weight & Value" });
    new import_obsidian27.Setting(contentEl).setName("Weight").addText((t) => {
      t.setPlaceholder("5 pounds").setValue(this.data.weight || "").onChange((v) => this.data.weight = v.trim() || void 0);
      t.inputEl.style.width = "12ch";
    });
    new import_obsidian27.Setting(contentEl).setName("Value").addText((t) => {
      t.setPlaceholder("2,000 GP").setValue(this.data.value || "").onChange((v) => this.data.value = v.trim() || void 0);
      t.inputEl.style.width = "12ch";
    });
    contentEl.createEl("h4", { text: "Curse" });
    const cursedSetting = new import_obsidian27.Setting(contentEl).setName("Cursed Item");
    cursedSetting.addToggle((t) => {
      t.setValue(!!this.data.cursed);
      t.onChange((v) => this.data.cursed = v || void 0);
    });
    this.addTextArea(
      contentEl,
      "Curse Description",
      "This armor is cursed...",
      (v) => this.data.curse_description = v.trim() || void 0,
      this.data.curse_description,
      3
    );
  }
};

// src/apps/library/create/equipment/modal.ts
var import_obsidian28 = require("obsidian");
init_search_dropdown();

// src/apps/library/create/equipment/validation.ts
function collectEquipmentValidationIssues(d) {
  const issues = [];
  if (!d.name || !d.name.trim()) {
    issues.push("Name is required");
  }
  if (!d.type) {
    issues.push("Equipment type is required");
  }
  if (d.type === "weapon") {
    if (d.weapon_category && !["Simple", "Martial"].includes(d.weapon_category)) {
      issues.push("Weapon category must be 'Simple' or 'Martial'");
    }
    if (d.weapon_type && !["Melee", "Ranged"].includes(d.weapon_type)) {
      issues.push("Weapon type must be 'Melee' or 'Ranged'");
    }
  }
  if (d.type === "armor") {
    if (d.armor_category && !["Light", "Medium", "Heavy", "Shield"].includes(d.armor_category)) {
      issues.push("Armor category must be 'Light', 'Medium', 'Heavy', or 'Shield'");
    }
  }
  if (d.type === "tool") {
    if (d.tool_category && !["Artisan", "Gaming", "Musical", "Other"].includes(d.tool_category)) {
      issues.push("Tool category must be 'Artisan', 'Gaming', 'Musical', or 'Other'");
    }
  }
  return issues;
}

// src/apps/library/create/equipment/modal.ts
var CreateEquipmentModal = class extends BaseCreateModal {
  constructor(app, presetNameOrData, onSubmit) {
    super(app, presetNameOrData, onSubmit, {
      title: "Create New Equipment",
      defaultName: "New Equipment",
      validate: collectEquipmentValidationIssues,
      submitButtonText: "Create Equipment"
    });
    this.containerEl = null;
  }
  createDefault(name) {
    return { name, type: "weapon" };
  }
  onOpen() {
    super.onOpen();
    this.containerEl = this.contentEl;
  }
  buildFields(contentEl) {
    contentEl.createEl("h4", { text: "Basic Information" });
    new import_obsidian28.Setting(contentEl).setName("Name").addText((t) => {
      t.setPlaceholder("Longsword").setValue(this.data.name).onChange((v) => this.data.name = v.trim());
      t.inputEl.style.width = "28ch";
    });
    new import_obsidian28.Setting(contentEl).setName("Type").addDropdown((dd) => {
      const types = ["weapon", "armor", "tool", "gear"];
      for (const type of types) {
        dd.addOption(type, type.charAt(0).toUpperCase() + type.slice(1));
      }
      dd.setValue(this.data.type);
      dd.onChange((v) => {
        this.data.type = v;
        this.rebuildTypeSpecificFields();
      });
      try {
        enhanceSelectToSearch(dd.selectEl, "Search\u2026");
      } catch {
      }
    });
    new import_obsidian28.Setting(contentEl).setName("Cost").setDesc("e.g., '15 GP', '2 SP'").addText((t) => {
      t.setPlaceholder("15 GP").setValue(this.data.cost || "").onChange((v) => this.data.cost = v.trim() || void 0);
      t.inputEl.style.width = "12ch";
    });
    new import_obsidian28.Setting(contentEl).setName("Weight").setDesc("e.g., '3 lb.', '\u2014'").addText((t) => {
      t.setPlaceholder("3 lb.").setValue(this.data.weight || "").onChange((v) => this.data.weight = v.trim() || void 0);
      t.inputEl.style.width = "12ch";
    });
    const typeFieldsContainer = contentEl.createDiv({ cls: "sm-cc-type-fields" });
    this.buildTypeSpecificFields(typeFieldsContainer);
    contentEl.createEl("h4", { text: "Description" });
    this.addTextArea(
      contentEl,
      "Description",
      "Equipment description...",
      (v) => this.data.description = v.trim() || void 0,
      this.data.description
    );
  }
  rebuildTypeSpecificFields() {
    if (!this.containerEl) return;
    const typeFieldsContainer = this.containerEl.querySelector(".sm-cc-type-fields");
    if (typeFieldsContainer) {
      typeFieldsContainer.empty();
      this.buildTypeSpecificFields(typeFieldsContainer);
    }
  }
  buildTypeSpecificFields(container) {
    container.empty();
    if (this.data.type === "weapon") {
      this.buildWeaponFields(container);
    } else if (this.data.type === "armor") {
      this.buildArmorFields(container);
    } else if (this.data.type === "tool") {
      this.buildToolFields(container);
    } else if (this.data.type === "gear") {
      this.buildGearFields(container);
    }
  }
  buildWeaponFields(container) {
    container.createEl("h4", { text: "Weapon Properties" });
    new import_obsidian28.Setting(container).setName("Category").addDropdown((dd) => {
      const categories = ["", "Simple", "Martial"];
      for (const cat of categories) dd.addOption(cat, cat || "(none)");
      dd.setValue(this.data.weapon_category || "");
      dd.onChange((v) => this.data.weapon_category = v || void 0);
      try {
        enhanceSelectToSearch(dd.selectEl, "Search\u2026");
      } catch {
      }
    });
    new import_obsidian28.Setting(container).setName("Weapon Type").addDropdown((dd) => {
      const types = ["", "Melee", "Ranged"];
      for (const type of types) dd.addOption(type, type || "(none)");
      dd.setValue(this.data.weapon_type || "");
      dd.onChange((v) => this.data.weapon_type = v || void 0);
      try {
        enhanceSelectToSearch(dd.selectEl, "Search\u2026");
      } catch {
      }
    });
    new import_obsidian28.Setting(container).setName("Damage").setDesc("e.g., '1d8 Slashing'").addText((t) => {
      t.setPlaceholder("1d8 Slashing").setValue(this.data.damage || "").onChange((v) => this.data.damage = v.trim() || void 0);
      t.inputEl.style.width = "18ch";
    });
    new import_obsidian28.Setting(container).setName("Properties").setDesc("Comma-separated: Finesse, Light, etc.").addText((t) => {
      const propsStr = this.data.properties?.join(", ") || "";
      t.setPlaceholder("Finesse, Light").setValue(propsStr).onChange((v) => {
        if (v.trim()) {
          this.data.properties = v.split(",").map((p) => p.trim()).filter(Boolean);
        } else {
          this.data.properties = void 0;
        }
      });
      t.inputEl.style.width = "34ch";
    });
    new import_obsidian28.Setting(container).setName("Mastery").setDesc("e.g., 'Sap', 'Vex'").addText((t) => {
      t.setPlaceholder("Sap").setValue(this.data.mastery || "").onChange((v) => this.data.mastery = v.trim() || void 0);
      t.inputEl.style.width = "12ch";
    });
  }
  buildArmorFields(container) {
    container.createEl("h4", { text: "Armor Properties" });
    new import_obsidian28.Setting(container).setName("Category").addDropdown((dd) => {
      const categories = ["", "Light", "Medium", "Heavy", "Shield"];
      for (const cat of categories) dd.addOption(cat, cat || "(none)");
      dd.setValue(this.data.armor_category || "");
      dd.onChange((v) => this.data.armor_category = v || void 0);
      try {
        enhanceSelectToSearch(dd.selectEl, "Search\u2026");
      } catch {
      }
    });
    new import_obsidian28.Setting(container).setName("Armor Class (AC)").setDesc("e.g., '11 + Dex modifier', '18'").addText((t) => {
      t.setPlaceholder("11 + Dex modifier").setValue(this.data.ac || "").onChange((v) => this.data.ac = v.trim() || void 0);
      t.inputEl.style.width = "22ch";
    });
    new import_obsidian28.Setting(container).setName("Strength Requirement").setDesc("e.g., 'Str 13'").addText((t) => {
      t.setPlaceholder("Str 13").setValue(this.data.strength_requirement || "").onChange((v) => this.data.strength_requirement = v.trim() || void 0);
      t.inputEl.style.width = "12ch";
    });
    new import_obsidian28.Setting(container).setName("Stealth Disadvantage").addToggle((t) => {
      t.setValue(!!this.data.stealth_disadvantage);
      t.onChange((v) => this.data.stealth_disadvantage = v || void 0);
    });
    new import_obsidian28.Setting(container).setName("Don Time").setDesc("e.g., '1 Minute'").addText((t) => {
      t.setPlaceholder("1 Minute").setValue(this.data.don_time || "").onChange((v) => this.data.don_time = v.trim() || void 0);
      t.inputEl.style.width = "18ch";
    });
    new import_obsidian28.Setting(container).setName("Doff Time").setDesc("e.g., '1 Minute'").addText((t) => {
      t.setPlaceholder("1 Minute").setValue(this.data.doff_time || "").onChange((v) => this.data.doff_time = v.trim() || void 0);
      t.inputEl.style.width = "18ch";
    });
  }
  buildToolFields(container) {
    container.createEl("h4", { text: "Tool Properties" });
    new import_obsidian28.Setting(container).setName("Category").addDropdown((dd) => {
      const categories = ["", "Artisan", "Gaming", "Musical", "Other"];
      for (const cat of categories) dd.addOption(cat, cat || "(none)");
      dd.setValue(this.data.tool_category || "");
      dd.onChange((v) => this.data.tool_category = v || void 0);
      try {
        enhanceSelectToSearch(dd.selectEl, "Search\u2026");
      } catch {
      }
    });
    new import_obsidian28.Setting(container).setName("Ability").setDesc("e.g., 'Intelligence', 'Dexterity'").addText((t) => {
      t.setPlaceholder("Intelligence").setValue(this.data.ability || "").onChange((v) => this.data.ability = v.trim() || void 0);
      t.inputEl.style.width = "18ch";
    });
    new import_obsidian28.Setting(container).setName("Utilize").setDesc("Comma-separated actions").addTextArea((ta) => {
      const utilizeStr = this.data.utilize?.join(", ") || "";
      ta.setPlaceholder("Identify a substance (DC 15), Start a fire (DC 15)").setValue(utilizeStr).onChange((v) => {
        if (v.trim()) {
          this.data.utilize = v.split(",").map((u) => u.trim()).filter(Boolean);
        } else {
          this.data.utilize = void 0;
        }
      });
      ta.inputEl.rows = 2;
      ta.inputEl.style.width = "100%";
    });
    new import_obsidian28.Setting(container).setName("Craft").setDesc("Comma-separated craftable items").addTextArea((ta) => {
      const craftStr = this.data.craft?.join(", ") || "";
      ta.setPlaceholder("Acid, Alchemist's Fire, Oil").setValue(craftStr).onChange((v) => {
        if (v.trim()) {
          this.data.craft = v.split(",").map((c) => c.trim()).filter(Boolean);
        } else {
          this.data.craft = void 0;
        }
      });
      ta.inputEl.rows = 2;
      ta.inputEl.style.width = "100%";
    });
    new import_obsidian28.Setting(container).setName("Variants").setDesc("Comma-separated variants").addTextArea((ta) => {
      const variantsStr = this.data.variants?.join(", ") || "";
      ta.setPlaceholder("Dice (1 SP), Playing cards (5 SP)").setValue(variantsStr).onChange((v) => {
        if (v.trim()) {
          this.data.variants = v.split(",").map((va) => va.trim()).filter(Boolean);
        } else {
          this.data.variants = void 0;
        }
      });
      ta.inputEl.rows = 2;
      ta.inputEl.style.width = "100%";
    });
  }
  buildGearFields(container) {
    container.createEl("h4", { text: "Adventuring Gear Properties" });
    new import_obsidian28.Setting(container).setName("Category").setDesc("e.g., 'Container', 'Light Source'").addText((t) => {
      t.setPlaceholder("Container").setValue(this.data.gear_category || "").onChange((v) => this.data.gear_category = v.trim() || void 0);
      t.inputEl.style.width = "18ch";
    });
    new import_obsidian28.Setting(container).setName("Capacity").setDesc("For containers").addText((t) => {
      t.setPlaceholder("30 cubic feet / 300 lb.").setValue(this.data.capacity || "").onChange((v) => this.data.capacity = v.trim() || void 0);
      t.inputEl.style.width = "22ch";
    });
    new import_obsidian28.Setting(container).setName("Duration").setDesc("For consumables").addText((t) => {
      t.setPlaceholder("1 hour").setValue(this.data.duration || "").onChange((v) => this.data.duration = v.trim() || void 0);
      t.inputEl.style.width = "12ch";
    });
    new import_obsidian28.Setting(container).setName("Special Use").setDesc("Special usage rules").addTextArea((ta) => {
      ta.setPlaceholder("When you take the Attack action...").setValue(this.data.special_use || "").onChange((v) => this.data.special_use = v.trim() || void 0);
      ta.inputEl.rows = 3;
      ta.inputEl.style.width = "100%";
    });
  }
};

// src/apps/library/view/view-registry.ts
function createOpenAction() {
  return {
    id: "open",
    label: "Open",
    execute: async (app, entry) => {
      await app.workspace.openLinkText(entry.file.path, entry.file.path, true);
    }
  };
}
function createDeleteAction(typeName) {
  return {
    id: "delete",
    label: "Delete",
    execute: async (app, entry, context) => {
      const question = `Delete ${entry.name}? This moves the file to the trash.`;
      const confirmation = typeof window !== "undefined" && typeof window.confirm === "function" ? window.confirm(question) : true;
      if (!confirmation) return;
      try {
        await app.vault.trash(entry.file, true);
        await context.reloadEntries();
      } catch (err) {
        console.error(`Failed to delete ${typeName}`, err);
      }
    }
  };
}
var creaturesMetadata = [
  {
    id: "type",
    cls: "sm-cc-item__type",
    getValue: (entry) => entry.type
  },
  {
    id: "cr",
    cls: "sm-cc-item__cr",
    getValue: (entry) => entry.cr ? `CR ${entry.cr}` : void 0
  }
];
var creaturesActions = [
  createOpenAction(),
  {
    id: "edit",
    label: "Edit",
    execute: async (app, entry, context) => {
      try {
        const creatureData = await loadCreaturePreset(app, entry.file);
        new CreateCreatureModal(app, creatureData.name, async (data) => {
          const file = await createCreatureFile(app, data);
          await context.reloadEntries();
          await app.workspace.openLinkText(file.path, file.path, true, { state: { mode: "source" } });
        }, creatureData).open();
      } catch (err) {
        console.error("Failed to load creature for editing", err);
      }
    }
  },
  createDeleteAction("creature")
];
var spellsMetadata = [
  {
    id: "level",
    cls: "sm-cc-item__type",
    getValue: (entry) => formatSpellLevel(entry.level)
  },
  {
    id: "school",
    cls: "sm-cc-item__cr",
    getValue: (entry) => entry.school
  }
];
var spellsActions = [
  createOpenAction(),
  {
    id: "edit",
    label: "Edit",
    execute: async (app, entry, context) => {
      try {
        const spellData = await loadSpellFile(app, entry.file);
        new CreateSpellModal(app, spellData, async (data) => {
          const content = spellToMarkdown(data);
          await app.vault.modify(entry.file, content);
          await context.reloadEntries();
        }).open();
      } catch (err) {
        console.error("Failed to load spell for editing", err);
      }
    }
  },
  createDeleteAction("spell")
];
var itemsMetadata = [
  {
    id: "category",
    cls: "sm-cc-item__type",
    getValue: (entry) => entry.category
  },
  {
    id: "rarity",
    cls: "sm-cc-item__cr",
    getValue: (entry) => entry.rarity
  }
];
var itemsActions = [
  createOpenAction(),
  {
    id: "edit",
    label: "Edit",
    execute: async (app, entry, context) => {
      try {
        const itemData = await loadItemFile(app, entry.file);
        new CreateItemModal(app, itemData, async (updatedData) => {
          const newContent = itemToMarkdown(updatedData);
          await app.vault.modify(entry.file, newContent);
          await context.reloadEntries();
          await app.workspace.openLinkText(entry.file.path, entry.file.path, true, { state: { mode: "source" } });
        }).open();
      } catch (err) {
        console.error("Failed to edit item", err);
      }
    }
  },
  createDeleteAction("item")
];
var equipmentMetadata = [
  {
    id: "type",
    cls: "sm-cc-item__type",
    getValue: (entry) => entry.type
  },
  {
    id: "role",
    cls: "sm-cc-item__cr",
    getValue: (entry) => entry.role
  }
];
var equipmentActions = [
  createOpenAction(),
  {
    id: "edit",
    label: "Edit",
    execute: async (app, entry, context) => {
      try {
        const equipmentData = await loadEquipmentFile(app, entry.file);
        new CreateEquipmentModal(app, equipmentData, async (updatedData) => {
          const newContent = equipmentToMarkdown(updatedData);
          await app.vault.modify(entry.file, newContent);
          await context.reloadEntries();
          await app.workspace.openLinkText(entry.file.path, entry.file.path, true, { state: { mode: "source" } });
        }).open();
      } catch (err) {
        console.error("Failed to edit equipment", err);
      }
    }
  },
  createDeleteAction("equipment")
];
var LIBRARY_VIEW_CONFIGS = {
  creatures: {
    metadataFields: creaturesMetadata,
    actions: creaturesActions,
    handleCreate: async (app, name, context) => {
      new CreateCreatureModal(app, name, async (data) => {
        const file = await createCreatureFile(app, data);
        await context.reloadEntries();
        await app.workspace.openLinkText(file.path, file.path, true, { state: { mode: "source" } });
      }, void 0).open();
    }
  },
  spells: {
    metadataFields: spellsMetadata,
    actions: spellsActions,
    handleCreate: async (app, name, context) => {
      const trimmed = name.trim();
      const preset = { name: trimmed || "Neuer Zauber" };
      if (context.getFilterSelection) {
        const levelFilter = context.getFilterSelection("level");
        if (levelFilter) {
          const parsed = Number(levelFilter);
          if (Number.isFinite(parsed)) preset.level = parsed;
        }
        const schoolFilter = context.getFilterSelection("school");
        if (schoolFilter) preset.school = schoolFilter;
        const ritualFilter = context.getFilterSelection("ritual");
        if (ritualFilter === "true") preset.ritual = true;
        if (ritualFilter === "false") preset.ritual = false;
      }
      new CreateSpellModal(app, preset, async (data) => {
        const file = await createSpellFile(app, data);
        await context.reloadEntries();
        await app.workspace.openLinkText(file.path, file.path, true, { state: { mode: "source" } });
      }).open();
    }
  },
  items: {
    metadataFields: itemsMetadata,
    actions: itemsActions,
    handleCreate: async (app, name, context) => {
      new CreateItemModal(app, name, async (data) => {
        const file = await createItemFile(app, data);
        await context.reloadEntries();
        await app.workspace.openLinkText(file.path, file.path, true, { state: { mode: "source" } });
      }).open();
    }
  },
  equipment: {
    metadataFields: equipmentMetadata,
    actions: equipmentActions,
    handleCreate: async (app, name, context) => {
      new CreateEquipmentModal(app, name, async (data) => {
        const file = await createEquipmentFile(app, data);
        await context.reloadEntries();
        await app.workspace.openLinkText(file.path, file.path, true, { state: { mode: "source" } });
      }).open();
    }
  }
};

// src/apps/library/view/filterable-mode.ts
var LibraryListState = class {
  constructor(schema) {
    this.schema = schema;
    this.filters = /* @__PURE__ */ new Map();
    this.sortDirection = "asc";
  }
  ensureSortAvailable(sorts) {
    if (!sorts.length) {
      this.sortId = void 0;
      this.sortDirection = "asc";
      return;
    }
    if (!this.sortId || !sorts.some((option) => option.id === this.sortId)) {
      this.sortId = sorts[0].id;
      this.sortDirection = "asc";
    }
  }
  getSortId() {
    return this.sortId;
  }
  getSortDirection() {
    return this.sortDirection;
  }
  setSort(id) {
    if (this.sortId === id) {
      this.sortDirection = this.sortDirection === "asc" ? "desc" : "asc";
    } else {
      this.sortId = id;
      this.sortDirection = "asc";
    }
  }
  getFilterValue(id) {
    return this.filters.get(id);
  }
  setFilterValue(id, value) {
    if (value) {
      this.filters.set(id, value);
    } else {
      this.filters.delete(id);
    }
  }
  hasFilters() {
    return this.filters.size > 0;
  }
  clearFilters() {
    this.filters.clear();
  }
  pruneInvalidFilters(options) {
    for (const [id, value] of Array.from(this.filters.entries())) {
      if (!value) continue;
      if (!options.get(id)?.includes(value)) {
        this.filters.delete(id);
      }
    }
  }
  matches(entry, filters) {
    if (!this.filters.size) return true;
    for (const [id, selected] of this.filters.entries()) {
      if (!selected) continue;
      const definition = filters.find((filter) => filter.id === id);
      if (!definition) continue;
      const values = (definition.getValues(entry) || []).map((value) => (value ?? "").trim()).filter((value) => Boolean(value));
      if (!values.includes(selected)) {
        return false;
      }
    }
    return true;
  }
};
function renderFeedback(container, kind, message) {
  container.createDiv({ cls: `sm-cc-feedback sm-cc-feedback--${kind}`, text: message });
}
var FilterableLibraryRenderer = class extends BaseModeRenderer2 {
  constructor(app, container, watchers, mode) {
    super(app, container);
    this.watchers = watchers;
    this.entries = [];
    this.renderToken = 0;
    this.mode = mode;
    this.source = LIBRARY_DATA_SOURCES[mode];
    this.schema = LIBRARY_LIST_SCHEMAS[mode];
    this.viewConfig = LIBRARY_VIEW_CONFIGS[mode];
    this.state = new LibraryListState(this.schema);
  }
  async init() {
    await this.refreshEntries();
    if (this.isDisposed()) return;
    const unsubscribe = this.watchers.subscribe(this.mode, (onChange) => this.source.watch(this.app, onChange), () => {
      void this.handleSourceChange();
    });
    this.registerCleanup(unsubscribe);
  }
  render() {
    if (this.isDisposed()) return;
    this.renderInternal();
  }
  renderEntry(row, entry) {
    const config = this.viewConfig;
    const nameContainer = row.createDiv({ cls: "sm-cc-item__name-container" });
    nameContainer.createDiv({ cls: "sm-cc-item__name", text: entry.name });
    if (config.metadataFields.length > 0) {
      const infoContainer = row.createDiv({ cls: "sm-cc-item__info" });
      for (const field of config.metadataFields) {
        const value = field.getValue(entry);
        if (value) {
          infoContainer.createEl("span", { cls: field.cls, text: value });
        }
      }
    }
    this.renderActions(row, entry);
  }
  renderActions(container, entry) {
    const config = this.viewConfig;
    const actions = container.createDiv({ cls: "sm-cc-item__actions" });
    const context = {
      reloadEntries: () => this.reloadEntries(),
      getRenderer: () => this.viewConfig,
      getFilterSelection: (id) => this.getFilterSelection(id)
    };
    for (const action of config.actions) {
      const cls = action.cls ? `sm-cc-item__action ${action.cls}` : "sm-cc-item__action";
      const btn = actions.createEl("button", { text: action.label, cls });
      btn.onclick = async () => {
        await action.execute(this.app, entry, context);
      };
    }
  }
  async handleCreate(name) {
    const context = {
      reloadEntries: () => this.reloadEntries(),
      getRenderer: () => this.viewConfig,
      getFilterSelection: (id) => this.getFilterSelection(id)
    };
    await this.viewConfig.handleCreate(this.app, name, context);
  }
  getEmptyMessage() {
    return "No entries found.";
  }
  getErrorMessage() {
    return "Failed to load entries.";
  }
  async reloadEntries() {
    await this.refreshEntries();
    if (!this.isDisposed()) {
      this.render();
    }
  }
  getFilterSelection(id) {
    return this.state.getFilterValue(id);
  }
  async handleSourceChange() {
    await this.refreshEntries();
    if (!this.isDisposed()) {
      this.render();
    }
  }
  async refreshEntries() {
    try {
      const files = await this.source.list(this.app);
      const entries = await Promise.all(files.map((file) => this.source.load(this.app, file)));
      this.entries = entries;
      this.loadError = void 0;
    } catch (err) {
      console.error("Failed to load library entries", err);
      this.entries = [];
      this.loadError = err;
    }
  }
  renderInternal() {
    const token = ++this.renderToken;
    const container = this.container;
    container.empty();
    if (this.loadError) {
      renderFeedback(container, "error", this.getErrorMessage());
      return;
    }
    const filters = this.schema.filters;
    const sorts = this.schema.sorts;
    this.state.ensureSortAvailable(sorts);
    const optionValues = this.collectFilterOptions(this.entries, filters);
    this.state.pruneInvalidFilters(optionValues);
    if (filters.length || sorts.length) {
      this.renderControls(container, filters, sorts, optionValues);
    }
    const query = this.query;
    const prepared = this.entries.map((entry) => ({
      entry,
      score: this.computeSearchScore(entry, query)
    }));
    const filtered = prepared.filter((item) => this.state.matches(item.entry, filters));
    const visible = query ? filtered.filter((item) => item.score > -Infinity) : filtered;
    const sortDef = sorts.find((option) => option.id === this.state.getSortId()) ?? sorts[0];
    visible.sort((a, b) => {
      if (query && a.score !== b.score) {
        return b.score - a.score;
      }
      let comparison = sortDef ? sortDef.compare(a.entry, b.entry) : a.entry.name.localeCompare(b.entry.name);
      if (comparison === 0) {
        comparison = a.entry.name.localeCompare(b.entry.name);
      }
      return this.state.getSortDirection() === "asc" ? comparison : -comparison;
    });
    if (token !== this.renderToken || this.isDisposed()) {
      return;
    }
    if (!visible.length) {
      renderFeedback(container, "empty", this.getEmptyMessage());
      return;
    }
    for (const item of visible) {
      const row = container.createDiv({ cls: "sm-cc-item" });
      this.renderEntry(row, item.entry);
    }
  }
  collectFilterOptions(entries, filters) {
    const options = /* @__PURE__ */ new Map();
    for (const filter of filters) {
      const values = /* @__PURE__ */ new Set();
      for (const entry of entries) {
        const rawValues = filter.getValues(entry) || [];
        for (const raw of rawValues) {
          const value = (raw ?? "").trim();
          if (value) {
            values.add(value);
          }
        }
      }
      const list = Array.from(values);
      const comparator = filter.sortComparator ?? ((a, b) => a.localeCompare(b, void 0, { sensitivity: "base" }));
      list.sort(comparator);
      options.set(filter.id, list);
    }
    return options;
  }
  renderControls(container, filters, sorts, optionValues) {
    const controls = container.createDiv({ cls: "sm-cc-controls" });
    if (filters.length) {
      const filterContainer = controls.createDiv({ cls: "sm-cc-filters" });
      filterContainer.createEl("h4", { text: "Filter", cls: "sm-cc-section-header" });
      const filterContent = filterContainer.createDiv({ cls: "sm-cc-filter-content" });
      for (const filter of filters) {
        const wrapper = filterContent.createDiv({ cls: "sm-cc-filter" });
        wrapper.createEl("label", { text: `${filter.label}: ` });
        const select = wrapper.createEl("select");
        select.createEl("option", { value: "", text: filter.emptyLabel ?? "All" });
        const values = optionValues.get(filter.id) ?? [];
        for (const value of values) {
          select.createEl("option", { value, text: filter.formatOption ? filter.formatOption(value) : value });
        }
        select.value = this.state.getFilterValue(filter.id) ?? "";
        select.onchange = () => {
          this.state.setFilterValue(filter.id, select.value);
          this.render();
        };
      }
      if (this.state.hasFilters()) {
        const clearBtn = filterContent.createEl("button", { text: "Clear filters", cls: "sm-cc-clear-filters" });
        clearBtn.onclick = () => {
          this.state.clearFilters();
          this.render();
        };
      }
    }
    if (sorts.length) {
      const sortContainer = controls.createDiv({ cls: "sm-cc-sorting" });
      sortContainer.createEl("h4", { text: "Sort", cls: "sm-cc-section-header" });
      const sortContent = sortContainer.createDiv({ cls: "sm-cc-sort-content" });
      const sortWrapper = sortContent.createDiv({ cls: "sm-cc-sort" });
      sortWrapper.createEl("label", { text: "Sort by: " });
      const select = sortWrapper.createEl("select");
      for (const option of sorts) {
        select.createEl("option", { value: option.id, text: option.label });
      }
      const currentSort = this.state.getSortId();
      if (currentSort) {
        select.value = currentSort;
      }
      select.onchange = () => {
        this.state.setSort(select.value);
        updateDirectionVisuals();
        this.render();
      };
      const directionBtn = sortContent.createEl("button", {
        cls: "sm-cc-sort-direction",
        attr: { "aria-label": this.state.getSortDirection() === "asc" ? "Sort ascending" : "Sort descending" }
      });
      const updateDirectionVisuals = () => {
        directionBtn.innerHTML = this.state.getSortDirection() === "asc" ? "\u2191" : "\u2193";
        directionBtn.title = this.state.getSortDirection() === "asc" ? "Ascending" : "Descending";
      };
      updateDirectionVisuals();
      directionBtn.onclick = () => {
        const targetId = this.state.getSortId() ?? sorts[0]?.id;
        if (!targetId) return;
        this.state.setSort(targetId);
        updateDirectionVisuals();
        this.render();
      };
    }
  }
  computeSearchScore(entry, query) {
    if (!query) return 1e-4;
    const candidates = [entry.name, ...this.schema.search(entry)];
    let best = -Infinity;
    for (const candidate of candidates) {
      if (!candidate) continue;
      const score = scoreName(candidate.toLowerCase(), query);
      if (score > best) {
        best = score;
      }
    }
    return best;
  }
};

// src/apps/library/view/creatures.ts
var CreaturesRenderer = class extends FilterableLibraryRenderer {
  constructor(app, container, watchers) {
    super(app, container, watchers, "creatures");
  }
};

// src/apps/library/view/spells.ts
var SpellsRenderer = class extends FilterableLibraryRenderer {
  constructor(app, container, watchers) {
    super(app, container, watchers, "spells");
  }
};

// src/apps/library/view/items.ts
var ItemsRenderer = class extends FilterableLibraryRenderer {
  constructor(app, container, watchers) {
    super(app, container, watchers, "items");
  }
};

// src/apps/library/view/equipment.ts
var EquipmentRenderer = class extends FilterableLibraryRenderer {
  constructor(app, container, watchers) {
    super(app, container, watchers, "equipment");
  }
};

// src/apps/library/view/terrains.ts
init_terrain_store();
var SAVE_DEBOUNCE_MS = 500;
var TerrainsRenderer = class extends BaseModeRenderer2 {
  constructor() {
    super(...arguments);
    this.mode = "terrains";
    this.terrains = {};
    this.saveTimer = null;
    this.dirty = false;
  }
  async init() {
    await ensureTerrainFile(this.app);
    this.terrains = await loadTerrains(this.app);
    this.ensureEmptyKey();
    const stop = watchTerrains(this.app, async () => {
      if (this.isDisposed()) return;
      this.terrains = await loadTerrains(this.app);
      this.ensureEmptyKey();
      this.render();
    });
    this.registerCleanup(stop);
  }
  render() {
    if (this.isDisposed()) return;
    const list = this.container;
    list.empty();
    const q = this.query;
    const names = Object.keys(this.terrains);
    const order = ["", ...names.filter((n) => n !== "")];
    const entries = order.map((name) => ({
      name,
      displayName: name || "",
      score: scoreName(name.toLowerCase(), q)
    })).filter((x) => x.name === "" || (q ? x.score > -Infinity : true)).sort((a, b) => a.name === "" ? -1 : b.name === "" ? 1 : b.score - a.score || a.name.localeCompare(b.name));
    for (const entry of entries) {
      let currentKey = entry.name;
      const row = list.createDiv({ cls: "sm-cc-item" });
      const nameInp = row.createEl("input", { attr: { type: "text", placeholder: "(Name)" } });
      nameInp.value = currentKey;
      const colorInp = row.createEl("input", { attr: { type: "color" } });
      const speedInp = row.createEl("input", { attr: { type: "number", step: "0.1", min: "0" } });
      const delBtn = row.createEl("button", { text: "\u{1F5D1}" });
      const base = this.terrains[currentKey] ?? { color: "transparent", speed: 1 };
      colorInp.value = /^#([0-9a-f]{6})$/i.test(base.color) ? base.color : "#999999";
      speedInp.value = String(Number.isFinite(base.speed) ? base.speed : 1);
      const updateFromInputs = () => {
        const nextKey = nameInp.value.trim();
        const color = colorInp.value || "#999999";
        const speed = parseFloat(speedInp.value);
        const normalizedNext = nextKey || "";
        const normalizedCurrent = currentKey || "";
        this.writeTerrain(currentKey, nextKey, {
          color,
          speed: Number.isFinite(speed) ? speed : 1
        });
        currentKey = normalizedNext;
        if (normalizedNext !== normalizedCurrent) {
          this.render();
        }
      };
      nameInp.addEventListener("change", updateFromInputs);
      nameInp.addEventListener("blur", updateFromInputs);
      nameInp.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter") {
          evt.preventDefault();
          updateFromInputs();
        }
      });
      colorInp.addEventListener("input", () => {
        const speed = parseFloat(speedInp.value);
        const nextKey = nameInp.value.trim();
        this.writeTerrain(currentKey, nextKey, {
          color: colorInp.value || "#999999",
          speed: Number.isFinite(speed) ? speed : 1
        });
        currentKey = nextKey || "";
      });
      speedInp.addEventListener("change", updateFromInputs);
      speedInp.addEventListener("blur", updateFromInputs);
      delBtn.onclick = () => {
        this.deleteTerrain(currentKey);
        this.render();
      };
    }
    if (!entries.length) {
      list.createDiv({ cls: "sm-cc-item" }).setText("No terrains available.");
    }
  }
  async handleCreate(name) {
    const key = name.trim();
    if (!key) return;
    if (!this.terrains[key]) {
      this.terrains[key] = { color: "#888888", speed: 1 };
      this.ensureEmptyKey();
      this.render();
      this.scheduleSave();
    }
  }
  async destroy() {
    await this.flushSave();
    await super.destroy();
  }
  ensureEmptyKey() {
    if (!this.terrains[""]) {
      this.terrains[""] = { color: "transparent", speed: 1 };
    }
  }
  writeTerrain(oldKey, newKey, payload) {
    const next = { ...this.terrains };
    const normalizedOld = oldKey || "";
    const normalizedNew = newKey || "";
    delete next[normalizedOld];
    next[normalizedNew] = payload;
    this.terrains = next;
    this.ensureEmptyKey();
    this.scheduleSave();
  }
  deleteTerrain(key) {
    const normalized = key || "";
    if (normalized === "") return;
    const next = { ...this.terrains };
    delete next[normalized];
    this.terrains = next;
    this.ensureEmptyKey();
    this.scheduleSave();
  }
  scheduleSave() {
    if (this.isDisposed()) return;
    this.dirty = true;
    if (this.saveTimer) clearTimeout(this.saveTimer);
    this.saveTimer = setTimeout(() => {
      void this.flushSave();
    }, SAVE_DEBOUNCE_MS);
  }
  async flushSave() {
    if (!this.dirty) {
      if (this.saveTimer) {
        clearTimeout(this.saveTimer);
        this.saveTimer = null;
      }
      return;
    }
    this.dirty = false;
    if (this.saveTimer) {
      clearTimeout(this.saveTimer);
      this.saveTimer = null;
    }
    await saveTerrains(this.app, this.terrains);
    this.terrains = await loadTerrains(this.app);
    this.ensureEmptyKey();
    if (!this.isDisposed()) this.render();
  }
};

// src/apps/library/view/regions.ts
init_search_dropdown();
init_regions_store();
init_terrain_store();
var SAVE_DEBOUNCE_MS2 = 500;
var RegionsRenderer = class extends BaseModeRenderer2 {
  constructor() {
    super(...arguments);
    this.mode = "regions";
    this.regions = [];
    this.terrainNames = [];
    this.saveTimer = null;
    this.dirty = false;
  }
  async init() {
    await ensureRegionsFile(this.app);
    [this.regions, this.terrainNames] = await Promise.all([
      loadRegions(this.app),
      this.loadTerrainNames()
    ]);
    const stopRegions = watchRegions(this.app, async () => {
      if (this.isDisposed()) return;
      this.regions = await loadRegions(this.app);
      this.render();
    });
    const stopTerrains = watchTerrains(this.app, async () => {
      if (this.isDisposed()) return;
      this.terrainNames = await this.loadTerrainNames();
      this.render();
    });
    this.registerCleanup(stopRegions);
    this.registerCleanup(stopTerrains);
  }
  render() {
    if (this.isDisposed()) return;
    const list = this.container;
    list.empty();
    const q = this.query;
    const entries = this.regions.map((region, index) => ({ region, index, score: scoreName((region.name || "").toLowerCase(), q) })).filter((item) => (item.region.name || "").trim()).filter((item) => q ? item.score > -Infinity : true).sort((a, b) => b.score - a.score || (a.region.name || "").localeCompare(b.region.name || ""));
    for (const entry of entries) {
      const region = entry.region;
      const row = list.createDiv({ cls: "sm-cc-item" });
      const nameInp = row.createEl("input", { attr: { type: "text", placeholder: "(Name)" } });
      nameInp.value = region.name || "";
      nameInp.addEventListener("input", () => {
        region.name = nameInp.value;
        this.scheduleSave();
      });
      const terrSel = row.createEl("select");
      enhanceSelectToSearch(terrSel, "Search options\u2026");
      this.populateTerrainOptions(terrSel, region.terrain || "");
      terrSel.addEventListener("change", () => {
        region.terrain = terrSel.value;
        this.scheduleSave();
      });
      const encInp = row.createEl("input", { attr: { type: "number", min: "1", step: "1", placeholder: "Encounter 1/n" } });
      encInp.value = region.encounterOdds && region.encounterOdds > 0 ? String(region.encounterOdds) : "";
      encInp.addEventListener("input", () => {
        const val = parseInt(encInp.value, 10);
        region.encounterOdds = Number.isFinite(val) && val > 0 ? val : void 0;
        this.scheduleSave();
      });
      const delBtn = row.createEl("button", { text: "\u{1F5D1}" });
      delBtn.onclick = () => {
        this.removeRegion(entry.index);
      };
    }
    if (!entries.length) {
      list.createDiv({ cls: "sm-cc-item" }).setText("No regions available.");
    }
  }
  async handleCreate(name) {
    const trimmed = name.trim();
    if (!trimmed) return;
    const exists = this.regions.some((r) => (r.name || "").toLowerCase() === trimmed.toLowerCase());
    if (exists) return;
    this.regions.push({ name: trimmed, terrain: "" });
    this.render();
    this.scheduleSave();
  }
  async destroy() {
    await this.flushSave();
    await super.destroy();
  }
  populateTerrainOptions(select, selected) {
    select.empty();
    const options = Array.from(/* @__PURE__ */ new Set(["", ...this.terrainNames]));
    for (const name of options) {
      const option = select.createEl("option", { text: name || "(empty)", value: name });
      option.selected = name === selected;
    }
  }
  async loadTerrainNames() {
    const terrains = await loadTerrains(this.app);
    return Object.keys(terrains || {});
  }
  removeRegion(index) {
    if (!this.regions[index]) return;
    this.regions.splice(index, 1);
    this.render();
    this.scheduleSave();
  }
  scheduleSave() {
    if (this.isDisposed()) return;
    this.dirty = true;
    if (this.saveTimer) clearTimeout(this.saveTimer);
    this.saveTimer = setTimeout(() => {
      void this.flushSave();
    }, SAVE_DEBOUNCE_MS2);
  }
  async flushSave() {
    if (!this.dirty) {
      if (this.saveTimer) {
        clearTimeout(this.saveTimer);
        this.saveTimer = null;
      }
      return;
    }
    this.dirty = false;
    if (this.saveTimer) {
      clearTimeout(this.saveTimer);
      this.saveTimer = null;
    }
    await saveRegions(this.app, this.regions);
    this.regions = await loadRegions(this.app);
    if (!this.isDisposed()) this.render();
  }
};

// src/apps/library/core/sources.ts
init_creature_files();
init_spell_files();
init_item_files();
init_equipment_files();
init_terrain_store();
init_regions_store();
var SOURCE_MAP = Object.freeze({
  creatures: {
    ensure: ensureCreatureDir,
    description: `${CREATURES_DIR}/`
  },
  spells: {
    ensure: ensureSpellDir,
    description: `${SPELLS_DIR}/`
  },
  items: {
    ensure: ensureItemDir,
    description: `${ITEMS_DIR}/`
  },
  equipment: {
    ensure: ensureEquipmentDir,
    description: `${EQUIPMENT_DIR}/`
  },
  terrains: {
    ensure: ensureTerrainFile,
    description: TERRAIN_FILE
  },
  regions: {
    ensure: ensureRegionsFile,
    description: REGIONS_FILE
  }
});
var LIBRARY_SOURCE_IDS = Object.freeze(Object.keys(SOURCE_MAP));
async function ensureLibrarySource(app, source) {
  const spec = SOURCE_MAP[source];
  if (!spec) throw new Error(`Unknown library source: ${source}`);
  await spec.ensure(app);
}
async function ensureLibrarySources(app, sources) {
  const requested = sources ? Array.from(new Set(sources)) : LIBRARY_SOURCE_IDS;
  await Promise.all(requested.map((source) => ensureLibrarySource(app, source)));
}
function describeLibrarySource(source) {
  const spec = SOURCE_MAP[source];
  if (!spec) throw new Error(`Unknown library source: ${source}`);
  return spec.description;
}

// src/apps/library/view.ts
var LIBRARY_COPY = {
  title: "Library",
  searchPlaceholder: "Search the library or enter a name\u2026",
  createButton: "Create entry",
  modes: {
    creatures: "Creatures",
    spells: "Spells",
    items: "Items",
    equipment: "Equipment",
    terrains: "Terrains",
    regions: "Regions"
  },
  sources: {
    prefix: "Source: "
  }
};
var VIEW_LIBRARY = "salt-library";
var LibraryView = class extends import_obsidian29.ItemView {
  constructor() {
    super(...arguments);
    this.mode = "creatures";
    this.queries = /* @__PURE__ */ new Map();
    this.watchers = new LibrarySourceWatcherHub();
  }
  getViewType() {
    return VIEW_LIBRARY;
  }
  getDisplayText() {
    return LIBRARY_COPY.title;
  }
  getIcon() {
    return "library";
  }
  async onOpen() {
    this.contentEl.addClass("sm-library");
    await ensureLibrarySources(this.app);
    this.renderShell();
    await this.activateMode(this.mode);
  }
  async onClose() {
    await this.activeRenderer?.destroy();
    this.activeRenderer = void 0;
    this.tabNav?.destroy();
    this.watchers.destroy();
    this.contentEl.removeClass("sm-library");
  }
  renderShell() {
    const root = this.contentEl;
    root.empty();
    root.createEl("h2", { text: LIBRARY_COPY.title });
    const tabs = [
      { id: "creatures", label: LIBRARY_COPY.modes.creatures },
      { id: "spells", label: LIBRARY_COPY.modes.spells },
      { id: "items", label: LIBRARY_COPY.modes.items },
      { id: "equipment", label: LIBRARY_COPY.modes.equipment },
      { id: "terrains", label: LIBRARY_COPY.modes.terrains },
      { id: "regions", label: LIBRARY_COPY.modes.regions }
    ];
    this.tabNav = createTabNavigation(root, {
      tabs,
      activeTab: this.mode,
      className: "sm-lib-header",
      onSelect: (mode) => {
        void this.activateMode(mode);
      }
    });
    const bar = root.createDiv({ cls: "sm-cc-searchbar" });
    const search = bar.createEl("input", { attr: { type: "text", placeholder: LIBRARY_COPY.searchPlaceholder } });
    search.value = this.getQueryForMode(this.mode);
    search.oninput = () => {
      const trimmed = search.value.trim();
      this.queries.set(this.mode, trimmed);
      this.activeRenderer?.setQuery(trimmed);
    };
    this.searchInput = search;
    const createBtn = bar.createEl("button", { text: LIBRARY_COPY.createButton });
    createBtn.onclick = () => {
      void this.onCreate(search.value.trim());
    };
    this.descEl = root.createDiv({ cls: "desc" });
    this.listEl = root.createDiv({ cls: "sm-cc-list" });
  }
  async activateMode(mode) {
    if (this.activeRenderer?.mode === mode) {
      this.mode = mode;
      this.tabNav?.setActiveTab(mode);
      this.updateSourceDescription();
      const query2 = this.getQueryForMode(mode);
      if (this.searchInput) this.searchInput.value = query2;
      this.activeRenderer.setQuery(query2);
      this.activeRenderer.render();
      return;
    }
    if (this.activeRenderer) {
      await this.activeRenderer.destroy();
      this.activeRenderer = void 0;
    }
    this.mode = mode;
    this.tabNav?.setActiveTab(mode);
    this.updateSourceDescription();
    if (!this.listEl) return;
    const renderer = this.createRenderer(mode, this.listEl);
    this.activeRenderer = renderer;
    await renderer.init();
    const query = this.getQueryForMode(mode);
    if (this.searchInput) this.searchInput.value = query;
    renderer.setQuery(query);
    renderer.render();
  }
  createRenderer(mode, container) {
    switch (mode) {
      case "creatures":
        return new CreaturesRenderer(this.app, container, this.watchers);
      case "spells":
        return new SpellsRenderer(this.app, container, this.watchers);
      case "items":
        return new ItemsRenderer(this.app, container, this.watchers);
      case "equipment":
        return new EquipmentRenderer(this.app, container, this.watchers);
      case "terrains":
        return new TerrainsRenderer(this.app, container);
      case "regions":
        return new RegionsRenderer(this.app, container);
      default:
        throw new Error(`Unsupported mode: ${mode}`);
    }
  }
  updateSourceDescription() {
    if (!this.descEl) return;
    const text = `${LIBRARY_COPY.sources.prefix}${describeLibrarySource(this.mode)}`;
    this.descEl.setText(text);
  }
  async onCreate(name) {
    if (!name && this.mode !== "creatures" && this.mode !== "spells" && this.mode !== "items") return;
    if (!this.activeRenderer) return;
    if (this.activeRenderer.handleCreate) {
      await this.activeRenderer.handleCreate(name);
    }
    this.searchInput?.focus();
  }
  getQueryForMode(mode) {
    return this.queries.get(mode) ?? "";
  }
};
async function openLibrary(app) {
  const leaf = app.workspace.getLeaf(true);
  await leaf.setViewState({ type: VIEW_LIBRARY, active: true });
  app.workspace.revealLeaf(leaf);
}

// src/apps/almanac/index.ts
var import_obsidian33 = require("obsidian");

// src/apps/almanac/mode/almanac-controller.ts
var import_obsidian31 = require("obsidian");
init_calendar_schema();
init_calendar_timestamp();
init_time_arithmetic();

// src/apps/almanac/data/in-memory-repository.ts
init_calendar_event();
init_calendar_timestamp();

// src/apps/almanac/data/almanac-repository.ts
var AlmanacRepositoryError = class extends Error {
  constructor(code, message, details) {
    super(message);
    this.scope = "phenomenon";
    this.name = "AlmanacRepositoryError";
    this.code = code;
    this.details = details;
  }
};

// src/apps/almanac/data/in-memory-repository.ts
function cloneCalendar(schema, defaults) {
  return {
    ...schema,
    isDefaultGlobal: defaults.global === schema.id,
    defaultTravelIds: Object.entries(defaults.travel).filter(([, calendarId]) => calendarId === schema.id).map(([travelId]) => travelId)
  };
}
function toDefaultsSnapshot(global, travelDefaults) {
  const travel = {};
  for (const [travelId, calendarId] of travelDefaults.entries()) {
    if (calendarId) {
      travel[travelId] = calendarId;
    }
  }
  return { global, travel };
}
var InMemoryCalendarRepository = class {
  constructor() {
    this.calendars = /* @__PURE__ */ new Map();
    this.globalDefault = null;
    this.travelDefaults = /* @__PURE__ */ new Map();
  }
  async listCalendars() {
    const snapshot = toDefaultsSnapshot(this.globalDefault, this.travelDefaults);
    return Array.from(this.calendars.values()).map((calendar) => cloneCalendar(calendar, snapshot));
  }
  async getCalendar(id) {
    const calendar = this.calendars.get(id);
    if (!calendar) {
      return null;
    }
    const snapshot = toDefaultsSnapshot(this.globalDefault, this.travelDefaults);
    return cloneCalendar(calendar, snapshot);
  }
  async createCalendar(input) {
    if (this.calendars.has(input.id)) {
      throw new Error(`Calendar with ID ${input.id} already exists`);
    }
    this.calendars.set(input.id, { ...input });
    if (input.isDefaultGlobal) {
      this.globalDefault = input.id;
    }
  }
  async updateCalendar(id, updates) {
    const existing = this.calendars.get(id);
    if (!existing) {
      throw new Error(`Calendar with ID ${id} not found`);
    }
    this.calendars.set(id, { ...existing, ...updates });
    if (updates.isDefaultGlobal) {
      this.globalDefault = id;
    } else if (updates.isDefaultGlobal === false && this.globalDefault === id) {
      this.globalDefault = null;
    }
  }
  async deleteCalendar(id) {
    if (!this.calendars.delete(id)) {
      throw new Error(`Calendar with ID ${id} not found`);
    }
    if (this.globalDefault === id) {
      this.globalDefault = null;
    }
    for (const [travelId, calendarId] of this.travelDefaults.entries()) {
      if (calendarId === id) {
        this.travelDefaults.delete(travelId);
      }
    }
  }
  async setDefault(input) {
    if (!this.calendars.has(input.calendarId)) {
      throw new Error(`Calendar with ID ${input.calendarId} not found`);
    }
    if (input.scope === "global") {
      this.globalDefault = input.calendarId;
      return;
    }
    if (!input.travelId) {
      throw new Error("Travel ID required for travel scope");
    }
    this.travelDefaults.set(input.travelId, input.calendarId);
  }
  async getDefaults() {
    return toDefaultsSnapshot(this.globalDefault, this.travelDefaults);
  }
  async getGlobalDefault() {
    return this.globalDefault;
  }
  async getTravelDefault(travelId) {
    return this.travelDefaults.get(travelId) ?? null;
  }
  async clearTravelDefault(travelId) {
    this.travelDefaults.delete(travelId);
  }
  async setGlobalDefault(calendarId) {
    await this.setDefault({ calendarId, scope: "global" });
  }
  async setTravelDefault(travelId, calendarId) {
    await this.setDefault({ calendarId, scope: "travel", travelId });
  }
  async getGlobalDefaultCalendar() {
    const id = await this.getGlobalDefault();
    return id ? this.getCalendar(id) : null;
  }
  seed(schemas) {
    schemas.forEach((schema) => {
      this.calendars.set(schema.id, schema);
      if (schema.isDefaultGlobal) {
        this.globalDefault = schema.id;
      }
    });
  }
  clear() {
    this.calendars.clear();
    this.travelDefaults.clear();
    this.globalDefault = null;
  }
};
var InMemoryEventRepository = class {
  constructor(resolver) {
    this.events = /* @__PURE__ */ new Map();
    this.resolveSchema = resolver ?? (() => null);
  }
  bindCalendarRepository(repository) {
    this.resolveSchema = async (id) => {
      const calendar = await repository.getCalendar(id);
      return calendar ?? null;
    };
  }
  async listEvents(calendarId, range) {
    const schema = await this.requireSchema(calendarId);
    const events = this.collectForCalendar(calendarId, schema);
    if (!range) {
      return events;
    }
    const start = range.start;
    const end = range.end;
    const rangeStart = compareTimestampsWithSchema(schema, start, end) <= 0 ? start : end;
    const rangeEnd = rangeStart === start ? end : start;
    return events.filter((event) => {
      const anchor = getEventAnchorTimestamp(event) ?? event.date;
      const afterStart = compareTimestampsWithSchema(schema, anchor, rangeStart) >= 0;
      const beforeEnd = compareTimestampsWithSchema(schema, anchor, rangeEnd) <= 0;
      return afterStart && beforeEnd;
    });
  }
  async listUpcoming(calendarId, limit) {
    const schema = await this.requireSchema(calendarId);
    return this.collectForCalendar(calendarId, schema).slice(0, limit);
  }
  async createEvent(event) {
    if (this.events.has(event.id)) {
      throw new Error(`Event with ID ${event.id} already exists`);
    }
    this.events.set(event.id, event);
  }
  async updateEvent(id, updates) {
    const existing = this.events.get(id);
    if (!existing) {
      throw new Error(`Event with ID ${id} not found`);
    }
    this.events.set(id, { ...existing, ...updates });
  }
  async deleteEvent(id) {
    if (!this.events.delete(id)) {
      throw new Error(`Event with ID ${id} not found`);
    }
  }
  async getEventsInRange(calendarId, schema, start, end) {
    const range = { calendarId, start, end };
    return this.listEvents(calendarId, range);
  }
  async getUpcomingEvents(calendarId, schema, from, limit) {
    const events = await this.listEvents(calendarId);
    return events.filter((event) => compareTimestampsWithSchema(schema, getEventAnchorTimestamp(event) ?? event.date, from) >= 0).slice(0, limit);
  }
  seed(events) {
    events.forEach((event) => {
      this.events.set(event.id, event);
    });
  }
  clear() {
    this.events.clear();
  }
  async requireSchema(calendarId) {
    const resolved = await this.resolveSchema(calendarId);
    if (!resolved) {
      throw new Error(`Calendar schema for ${calendarId} not available`);
    }
    return resolved;
  }
  collectForCalendar(calendarId, schema) {
    return Array.from(this.events.values()).filter((event) => event.calendarId === calendarId).sort((a, b) => {
      const left = getEventAnchorTimestamp(a) ?? a.date;
      const right = getEventAnchorTimestamp(b) ?? b.date;
      return compareTimestampsWithSchema(schema, left, right);
    });
  }
};
var DEFAULT_PAGE_SIZE = 25;
var InMemoryPhenomenonRepository = class {
  constructor() {
    this.phenomena = /* @__PURE__ */ new Map();
  }
  async listPhenomena(input) {
    if (!input) {
      return Array.from(this.phenomena.values()).map((phenomenon) => ({ ...phenomenon }));
    }
    const filters = input.filters;
    const filtered = Array.from(this.phenomena.values()).filter((phenomenon) => matchesPhenomenonFilters(phenomenon, filters));
    const summaries = filtered.map((phenomenon) => toSummary(phenomenon));
    const sorted = sortSummariesForInMemory(filtered, summaries, input.sort);
    const { items, nextCursor } = paginate(sorted, input.pagination ?? { limit: DEFAULT_PAGE_SIZE });
    return {
      items: items.map((entry) => entry.summary),
      pagination: { cursor: nextCursor, hasMore: nextCursor !== void 0 },
      generatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  async getPhenomenon(id) {
    const phenomenon = this.phenomena.get(id);
    return phenomenon ? { ...phenomenon } : null;
  }
  async upsertPhenomenon(draft) {
    this.phenomena.set(draft.id, { ...draft });
    const stored = this.phenomena.get(draft.id);
    if (!stored) {
      throw new Error(`Failed to upsert phenomenon ${draft.id}`);
    }
    return { ...stored };
  }
  async deletePhenomenon(id) {
    if (!this.phenomena.delete(id)) {
      throw new Error(`Phenomenon with ID ${id} not found`);
    }
  }
  async updateLinks(update) {
    const existing = this.phenomena.get(update.phenomenonId);
    if (!existing) {
      throw new AlmanacRepositoryError("validation_error", `Phenomenon ${update.phenomenonId} not found`);
    }
    const duplicates = findDuplicateCalendarIds(update.calendarLinks);
    if (duplicates.length) {
      throw new AlmanacRepositoryError("phenomenon_conflict", "Duplicate calendar links", { duplicates });
    }
    if (existing.rule.type === "astronomical") {
      const hasReference = Boolean(existing.rule.referenceCalendarId);
      const hasHookReference = update.calendarLinks.some(
        (link) => typeof link.hook?.config?.referenceCalendarId === "string"
      );
      if (!hasReference && !hasHookReference) {
        throw new AlmanacRepositoryError(
          "astronomy_source_missing",
          "Astronomical phenomena require a reference calendar"
        );
      }
    }
    const appliesToCalendarIds = update.calendarLinks.map((link) => link.calendarId);
    const visibility = appliesToCalendarIds.length ? "selected" : "all_calendars";
    const hooks = update.calendarLinks.filter((link) => Boolean(link.hook)).map((link) => ({ ...link.hook, priority: link.priority }));
    const priority = update.calendarLinks.reduce((max, link) => Math.max(max, link.priority), existing.priority);
    const updated = {
      ...existing,
      appliesToCalendarIds,
      visibility,
      hooks: hooks.length ? hooks : existing.hooks,
      priority
    };
    this.phenomena.set(existing.id, updated);
    return { ...updated };
  }
  async listTemplates() {
    return Array.from(this.phenomena.values()).filter((phenomenon) => phenomenon.template).map((phenomenon) => ({
      id: phenomenon.id,
      name: phenomenon.name,
      category: phenomenon.category,
      rule: phenomenon.rule,
      effects: phenomenon.effects
    }));
  }
  seed(phenomena) {
    phenomena.forEach((phenomenon) => {
      this.phenomena.set(phenomenon.id, { ...phenomenon });
    });
  }
  clear() {
    this.phenomena.clear();
  }
};
function matchesPhenomenonFilters(phenomenon, filters) {
  if (filters.categories?.length && !filters.categories.includes(phenomenon.category)) {
    return false;
  }
  if (filters.calendarIds?.length) {
    if (phenomenon.visibility === "selected") {
      return phenomenon.appliesToCalendarIds.some((id) => filters.calendarIds.includes(id));
    }
    return true;
  }
  return true;
}
function toSummary(phenomenon) {
  return {
    id: phenomenon.id,
    name: phenomenon.name,
    category: phenomenon.category,
    linkedCalendars: phenomenon.appliesToCalendarIds,
    badge: phenomenon.tags?.[0]
  };
}
function sortSummariesForInMemory(phenomena, summaries, sort) {
  const paired = phenomena.map((phenomenon, index) => ({ phenomenon, summary: summaries[index] }));
  paired.sort((a, b) => {
    if (sort === "priority_desc") {
      return b.phenomenon.priority - a.phenomenon.priority || a.summary.name.localeCompare(b.summary.name);
    }
    if (sort === "category_asc") {
      return a.summary.category.localeCompare(b.summary.category) || a.summary.name.localeCompare(b.summary.name);
    }
    return a.summary.name.localeCompare(b.summary.name);
  });
  return paired;
}
function paginate(entries, pagination) {
  const offset = pagination.cursor ? Number.parseInt(pagination.cursor, 10) || 0 : 0;
  const limit = pagination.limit ?? DEFAULT_PAGE_SIZE;
  const slice = entries.slice(offset, offset + limit);
  const nextOffset = offset + slice.length;
  const hasMore = nextOffset < entries.length;
  return { items: slice, nextCursor: hasMore ? String(nextOffset) : void 0 };
}
function findDuplicateCalendarIds(links) {
  const counts = /* @__PURE__ */ new Map();
  for (const link of links) {
    counts.set(link.calendarId, (counts.get(link.calendarId) ?? 0) + 1);
  }
  return Array.from(counts.entries()).filter(([, count]) => count > 1).map(([calendarId]) => calendarId);
}

// src/apps/almanac/data/in-memory-gateway.ts
init_calendar_event();
init_calendar_schema();
init_calendar_timestamp();

// src/apps/almanac/domain/phenomenon.ts
var DEFAULT_PHENOMENON_PRIORITY = 0;
function isPhenomenonVisibleForCalendar(phenomenon, calendarId) {
  if (phenomenon.visibility === "all_calendars") {
    return true;
  }
  return phenomenon.appliesToCalendarIds.includes(calendarId);
}
function requiresOffsetComputation(phenomenon) {
  return phenomenon.timePolicy === "offset";
}
function getPhenomenonPriority(phenomenon) {
  return phenomenon.priority ?? DEFAULT_PHENOMENON_PRIORITY;
}
function getPhenomenonHooks(phenomenon) {
  return phenomenon.hooks ?? [];
}
function getPhenomenonEffects(phenomenon) {
  return phenomenon.effects ?? [];
}

// src/apps/almanac/domain/phenomenon-engine.ts
init_calendar_schema();
init_calendar_timestamp();
init_repeat_rule();
init_time_arithmetic();
init_hook_descriptor();
var UnsupportedTimePolicyError = class extends Error {
  constructor(policy) {
    super(`Phenomenon time policy "${policy}" is not supported yet.`);
    this.name = "UnsupportedTimePolicyError";
  }
};
function computeNextPhenomenonOccurrence(phenomenon, schema, calendarId, start, options = {}) {
  const { services, ...ruleOptions } = options;
  const baseTimestamp = calculateNextOccurrence(
    schema,
    calendarId,
    phenomenon.rule,
    start,
    ruleOptions,
    services
  );
  if (!baseTimestamp) {
    return null;
  }
  return buildPhenomenonOccurrence(phenomenon, schema, calendarId, baseTimestamp);
}
function computePhenomenonOccurrencesInRange(phenomenon, schema, calendarId, rangeStart, rangeEnd, options = {}) {
  const { services, ...ruleOptions } = options;
  const baseOccurrences = calculateOccurrencesInRange(
    schema,
    calendarId,
    phenomenon.rule,
    rangeStart,
    rangeEnd,
    ruleOptions,
    services
  );
  return baseOccurrences.map((timestamp) => buildPhenomenonOccurrence(phenomenon, schema, calendarId, timestamp));
}
function buildPhenomenonOccurrence(phenomenon, schema, calendarId, baseTimestamp) {
  const { start, end, durationMinutes } = applyTimePolicy(phenomenon, schema, calendarId, baseTimestamp);
  return {
    phenomenonId: phenomenon.id,
    name: phenomenon.name,
    calendarId,
    timestamp: start,
    endTimestamp: end,
    category: phenomenon.category,
    priority: getPhenomenonPriority(phenomenon),
    durationMinutes,
    hooks: sortHooksByPriority(getPhenomenonHooks(phenomenon)),
    effects: getPhenomenonEffects(phenomenon)
  };
}
function applyTimePolicy(phenomenon, schema, calendarId, baseTimestamp) {
  const { hoursPerDay, minutesPerHour } = getTimeDefinition(schema);
  const minutesPerDay = hoursPerDay * minutesPerHour;
  if (phenomenon.timePolicy === "all_day") {
    const duration2 = phenomenon.durationMinutes ?? minutesPerDay;
    const end2 = duration2 > 0 ? advanceTime(schema, baseTimestamp, duration2, "minute").timestamp : baseTimestamp;
    return { start: baseTimestamp, end: end2, durationMinutes: duration2 };
  }
  if (phenomenon.timePolicy === "fixed") {
    const startTime = phenomenon.startTime ?? { hour: 0, minute: 0 };
    const hour = clamp(startTime.hour, 0, Math.max(0, hoursPerDay - 1));
    const minute = clamp(startTime.minute ?? 0, 0, Math.max(0, minutesPerHour - 1));
    const start2 = createMinuteTimestamp(calendarId, baseTimestamp.year, baseTimestamp.monthId, baseTimestamp.day, hour, minute);
    const duration2 = phenomenon.durationMinutes ?? 0;
    const end2 = duration2 > 0 ? advanceTime(schema, start2, duration2, "minute").timestamp : start2;
    return { start: start2, end: end2, durationMinutes: duration2 };
  }
  if (!requiresOffsetComputation(phenomenon)) {
    throw new UnsupportedTimePolicyError(phenomenon.timePolicy);
  }
  const offset = phenomenon.offsetMinutes ?? 0;
  const start = advanceTime(schema, baseTimestamp, offset, "minute").timestamp;
  const duration = phenomenon.durationMinutes ?? 0;
  const end = duration > 0 ? advanceTime(schema, start, duration, "minute").timestamp : start;
  return { start, end, durationMinutes: duration };
}
function clamp(value, min, max) {
  if (value === void 0 || Number.isNaN(value)) return min;
  if (value < min) return min;
  if (value > max) return max;
  return value;
}
function sortOccurrencesByTimestamp(schema, occurrences) {
  return [...occurrences].sort((a, b) => compareTimestampsWithSchema(schema, a.timestamp, b.timestamp));
}

// src/apps/almanac/data/in-memory-gateway.ts
init_time_arithmetic();

// src/apps/almanac/data/calendar-state-gateway.ts
var CalendarGatewayError = class extends Error {
  constructor(code, message, context) {
    super(message);
    this.name = "CalendarGatewayError";
    this.code = code;
    this.context = context;
  }
};
function createGatewayValidationError(message, context) {
  return new CalendarGatewayError("validation_error", message, context);
}
function createGatewayIoError(message, context) {
  return new CalendarGatewayError("io_error", message, context);
}
function isCalendarGatewayError(error) {
  return error instanceof CalendarGatewayError;
}

// src/app/integration-telemetry.ts
var import_obsidian30 = require("obsidian");
var notifiedOperations = /* @__PURE__ */ new Set();
function reportIntegrationIssue(payload) {
  const { integrationId, operation, error, userMessage } = payload;
  const logPrefix = `[salt-marcher] integration(${integrationId}) ${operation} failed`;
  console.error(logPrefix, error);
  const dedupeKey = `${integrationId}:${operation}`;
  if (notifiedOperations.has(dedupeKey)) return;
  notifiedOperations.add(dedupeKey);
  new import_obsidian30.Notice(userMessage);
}

// src/apps/almanac/telemetry.ts
var ALMANAC_INTEGRATION_ID = "obsidian:almanac-view";
var defaultReporter = (event) => {
  const { type, ...payload } = event;
  console.info("[almanac:telemetry]", type, payload);
};
var reporter = defaultReporter;
function emitAlmanacEvent(event) {
  reporter(event);
}
var DEFAULT_USER_MESSAGES = {
  io_error: "The Almanac data store is currently unavailable. Please check the developer console for details.",
  validation_error: "The Almanac input could not be validated. Please review the provided data and try again.",
  conflict: "The Almanac detected a conflicting calendar configuration.",
  phenomenon_conflict: "The phenomenon cannot be linked because it conflicts with existing calendar rules."
};
function reportAlmanacGatewayIssue(payload) {
  const { operation, scope, code, error } = payload;
  const userMessage = payload.userMessage ?? DEFAULT_USER_MESSAGES[code];
  const logContext = { scope, code, ...payload.context ?? {} };
  console.error(`[almanac] ${operation} failed`, logContext, error);
  if (code === "io_error") {
    reportIntegrationIssue({
      integrationId: ALMANAC_INTEGRATION_ID,
      operation: "prime-dataset",
      error,
      userMessage
    });
  }
}

// src/apps/almanac/data/in-memory-gateway.ts
var GLOBAL_SCOPE = "__global__";
var InMemoryStateGateway = class {
  constructor(calendarRepo, eventRepo, phenomenonRepo, hookDispatcher) {
    this.calendarRepo = calendarRepo;
    this.eventRepo = eventRepo;
    this.phenomenonRepo = phenomenonRepo;
    this.hookDispatcher = hookDispatcher;
    this.scopeState = /* @__PURE__ */ new Map([
      [GLOBAL_SCOPE, { activeCalendarId: null, currentTimestamp: null }]
    ]);
    this.travelLeafPrefs = /* @__PURE__ */ new Map();
    this.preferences = {};
    this.pendingMutations = [];
    this.pendingFlushPromise = null;
    this.pendingFlushResolve = null;
    this.pendingFlushReject = null;
    this.pendingFlushTimer = null;
    this.activeFlush = null;
    this.persistenceDebounceMs = 0;
  }
  async loadSnapshot(options) {
    const travelId = options?.travelId ?? null;
    const scope = this.ensureScope(travelId);
    const effective = await this.resolveEffectiveCalendar(travelId);
    const travelDefaultCalendarId = travelId ? await this.calendarRepo.getTravelDefault(travelId) : null;
    if (!effective?.calendar) {
      return {
        activeCalendar: null,
        currentTimestamp: null,
        upcomingEvents: [],
        upcomingPhenomena: [],
        defaultCalendarId: effective?.isGlobalDefault ? effective.calendarId ?? null : null,
        travelDefaultCalendarId,
        isGlobalDefault: effective?.isGlobalDefault ?? false,
        wasAutoSelected: effective?.wasAutoSelected ?? false
      };
    }
    const activeCalendar = scope.activeCalendarId ? await this.calendarRepo.getCalendar(scope.activeCalendarId) : effective.calendar;
    if (!activeCalendar) {
      return {
        activeCalendar: null,
        currentTimestamp: null,
        upcomingEvents: [],
        upcomingPhenomena: [],
        defaultCalendarId: effective.isGlobalDefault ? effective.calendar.id : null,
        travelDefaultCalendarId,
        isGlobalDefault: effective.isGlobalDefault,
        wasAutoSelected: effective.wasAutoSelected
      };
    }
    const upcomingEvents = scope.currentTimestamp ? await this.eventRepo.getUpcomingEvents(
      activeCalendar.id,
      activeCalendar,
      scope.currentTimestamp,
      5
    ) : [];
    const visiblePhenomena = await this.listVisiblePhenomena(activeCalendar);
    const upcomingPhenomena = this.computeUpcomingPhenomenaForCalendar(
      activeCalendar,
      visiblePhenomena,
      scope.currentTimestamp
    );
    return {
      activeCalendar,
      currentTimestamp: scope.currentTimestamp,
      upcomingEvents,
      upcomingPhenomena,
      defaultCalendarId: effective.isGlobalDefault ? effective.calendar.id : null,
      travelDefaultCalendarId,
      isGlobalDefault: effective.isGlobalDefault,
      wasAutoSelected: effective.wasAutoSelected
    };
  }
  async setActiveCalendar(calendarId, options) {
    const calendar = await this.calendarRepo.getCalendar(calendarId);
    if (!calendar) {
      const error = createGatewayValidationError(`Calendar with ID ${calendarId} not found`, {
        calendarId,
        travelId: options?.travelId ?? null
      });
      reportAlmanacGatewayIssue({
        operation: "calendar.gateway.setActiveCalendar",
        scope: options?.travelId ? "travel" : "calendar",
        code: error.code,
        error,
        context: error.context
      });
      throw error;
    }
    const scope = this.ensureScope(options?.travelId ?? null);
    scope.activeCalendarId = calendarId;
    if (options?.initialTimestamp) {
      scope.currentTimestamp = { ...options.initialTimestamp };
      return;
    }
    if (scope.currentTimestamp && scope.currentTimestamp.calendarId === calendarId) {
      return;
    }
    const firstMonth = calendar.months[0] ?? getMonthById(calendar, calendar.epoch.monthId);
    const fallback = createDayTimestamp(
      calendar.id,
      calendar.epoch.year,
      firstMonth?.id ?? calendar.epoch.monthId,
      calendar.epoch.day
    );
    scope.currentTimestamp = fallback;
  }
  async setDefaultCalendar(calendarId, options) {
    const scope = options?.scope ?? "global";
    if (scope === "travel") {
      const travelId = options?.travelId;
      if (!travelId) {
        const error = createGatewayValidationError("Travel ID required when persisting travel default", {
          calendarId
        });
        reportAlmanacGatewayIssue({
          operation: "calendar.gateway.setDefaultCalendar",
          scope: "travel",
          code: error.code,
          error,
          context: error.context
        });
        throw error;
      }
      await this.calendarRepo.setDefault({ calendarId, scope: "travel", travelId });
      return;
    }
    await this.calendarRepo.setDefault({ calendarId, scope: "global" });
  }
  async setCurrentTimestamp(timestamp, options) {
    const scope = this.ensureScope(options?.travelId ?? null);
    if (!scope.activeCalendarId) {
      const error = createGatewayValidationError("No active calendar set", {
        travelId: options?.travelId ?? null
      });
      reportAlmanacGatewayIssue({
        operation: "calendar.gateway.setCurrentTimestamp",
        scope: options?.travelId ? "travel" : "calendar",
        code: error.code,
        error,
        context: error.context
      });
      throw error;
    }
    if (timestamp.calendarId !== scope.activeCalendarId) {
      const error = createGatewayValidationError("Timestamp calendar does not match active calendar", {
        travelId: options?.travelId ?? null,
        calendarId: timestamp.calendarId,
        activeCalendarId: scope.activeCalendarId
      });
      reportAlmanacGatewayIssue({
        operation: "calendar.gateway.setCurrentTimestamp",
        scope: options?.travelId ? "travel" : "calendar",
        code: error.code,
        error,
        context: error.context
      });
      throw error;
    }
    scope.currentTimestamp = { ...timestamp };
  }
  async advanceTimeBy(amount, unit, options) {
    const scopeId = options?.travelId ?? null;
    const scope = this.ensureScope(scopeId);
    if (!scope.activeCalendarId || !scope.currentTimestamp) {
      const error = createGatewayValidationError("No active calendar or current timestamp set", {
        travelId: scopeId,
        activeCalendarId: scope.activeCalendarId
      });
      reportAlmanacGatewayIssue({
        operation: "calendar.gateway.advanceTimeBy",
        scope: scopeId ? "travel" : "calendar",
        code: error.code,
        error,
        context: error.context
      });
      throw error;
    }
    const calendar = await this.calendarRepo.getCalendar(scope.activeCalendarId);
    if (!calendar) {
      const error = createGatewayValidationError(`Calendar ${scope.activeCalendarId} not found`, {
        travelId: scopeId,
        calendarId: scope.activeCalendarId
      });
      reportAlmanacGatewayIssue({
        operation: "calendar.gateway.advanceTimeBy",
        scope: scopeId ? "travel" : "calendar",
        code: error.code,
        error,
        context: error.context
      });
      throw error;
    }
    const visiblePhenomena = await this.listVisiblePhenomena(calendar);
    const previousTimestamp = { ...scope.currentTimestamp };
    const result = advanceTime(calendar, previousTimestamp, amount, unit);
    scope.currentTimestamp = result.timestamp;
    const [triggeredEvents, triggeredPhenomena] = await Promise.all([
      this.eventRepo.getEventsInRange(
        scope.activeCalendarId,
        calendar,
        previousTimestamp,
        result.timestamp
      ),
      Promise.resolve(
        this.computeTriggeredPhenomenaBetween(
          calendar,
          visiblePhenomena,
          previousTimestamp,
          result.timestamp
        )
      )
    ]);
    const relevantEvents = triggeredEvents.filter(
      (event) => compareTimestampsWithSchema(
        calendar,
        getEventAnchorTimestamp(event) ?? event.date,
        previousTimestamp
      ) > 0
    );
    const upcomingPhenomena = this.computeUpcomingPhenomenaForCalendar(
      calendar,
      visiblePhenomena,
      result.timestamp
    );
    if (this.hookDispatcher && (relevantEvents.length > 0 || triggeredPhenomena.length > 0)) {
      try {
        await this.hookDispatcher.dispatchHooks(relevantEvents, triggeredPhenomena, {
          scope: scopeId ? "travel" : "global",
          travelId: scopeId,
          reason: "advance",
          ...options?.hookContext
        });
      } catch (error) {
        const causeMessage = error instanceof Error && error.message ? `: ${error.message}` : "";
        const gatewayError = new CalendarGatewayError(
          "io_error",
          `Failed to dispatch hooks for time advance${causeMessage}`,
          {
            travelId: scopeId,
            scope: scopeId ? "travel" : "global"
          }
        );
        reportAlmanacGatewayIssue({
          operation: "calendar.gateway.advanceTimeBy",
          scope: scopeId ? "travel" : "calendar",
          code: gatewayError.code,
          error,
          context: gatewayError.context
        });
        throw gatewayError;
      }
    }
    return { timestamp: result.timestamp, triggeredEvents: relevantEvents, triggeredPhenomena, upcomingPhenomena };
  }
  async loadPreferences() {
    return clonePreferences(this.preferences);
  }
  async savePreferences(partial) {
    await this.persistState((state) => {
      const next = {
        ...state.preferences,
        ...partial
      };
      if (partial.lastZoomByMode) {
        next.lastZoomByMode = {
          ...state.preferences.lastZoomByMode ?? {},
          ...partial.lastZoomByMode
        };
      }
      if (partial.eventsFilters) {
        next.eventsFilters = {
          categories: [...partial.eventsFilters.categories ?? []],
          calendarIds: [...partial.eventsFilters.calendarIds ?? []]
        };
      }
      state.preferences = next;
    }, { debounce: true });
  }
  getCurrentTimestamp(options) {
    const scope = this.ensureScope(options?.travelId ?? null);
    return scope.currentTimestamp ? { ...scope.currentTimestamp } : null;
  }
  getActiveCalendarId(options) {
    const scope = this.ensureScope(options?.travelId ?? null);
    return scope.activeCalendarId;
  }
  async getTravelLeafPreferences(travelId) {
    const prefs = this.travelLeafPrefs.get(travelId);
    return prefs ? { ...prefs } : null;
  }
  async saveTravelLeafPreferences(travelId, prefs) {
    await this.persistState((state) => {
      state.travelLeaf.set(travelId, { ...prefs });
    }, { debounce: true });
  }
  async flushPendingPersistence() {
    await this.flushDebouncedPersist();
  }
  async persistState(mutator, options) {
    if (options?.debounce) {
      return this.enqueueDebouncedPersist(mutator);
    }
    await this.flushDebouncedPersist();
    await this.commitMutations([mutator]);
  }
  enqueueDebouncedPersist(mutator) {
    this.pendingMutations.push(mutator);
    if (!this.pendingFlushPromise) {
      this.pendingFlushPromise = new Promise((resolve, reject) => {
        this.pendingFlushResolve = resolve;
        this.pendingFlushReject = reject;
      });
    }
    if (this.pendingFlushTimer) {
      clearTimeout(this.pendingFlushTimer);
    }
    this.pendingFlushTimer = setTimeout(() => {
      void this.flushDebouncedPersist();
    }, this.persistenceDebounceMs);
    return this.pendingFlushPromise;
  }
  async flushDebouncedPersist() {
    if (this.pendingFlushTimer) {
      clearTimeout(this.pendingFlushTimer);
      this.pendingFlushTimer = null;
    }
    if (this.activeFlush) {
      return this.activeFlush;
    }
    if (this.pendingMutations.length === 0) {
      if (this.pendingFlushPromise) {
        this.pendingFlushResolve?.();
        this.pendingFlushPromise = null;
        this.pendingFlushResolve = null;
        this.pendingFlushReject = null;
      }
      return;
    }
    const mutations = this.pendingMutations;
    this.pendingMutations = [];
    const resolve = this.pendingFlushResolve;
    const reject = this.pendingFlushReject;
    this.pendingFlushPromise = null;
    this.pendingFlushResolve = null;
    this.pendingFlushReject = null;
    const flushOperation = this.commitMutations(mutations).then(() => {
      resolve?.();
    }).catch((error) => {
      reject?.(error);
      throw error;
    }).finally(() => {
      this.activeFlush = null;
      if (this.pendingMutations.length > 0) {
        void this.flushDebouncedPersist();
      }
    });
    this.activeFlush = flushOperation;
    await flushOperation;
  }
  async commitMutations(mutations) {
    const snapshot = {
      preferences: clonePreferences(this.preferences),
      travelLeaf: cloneTravelLeafMap(this.travelLeafPrefs)
    };
    for (const mutate of mutations) {
      mutate(snapshot);
    }
    this.preferences = snapshot.preferences;
    this.travelLeafPrefs.clear();
    for (const [key, value] of snapshot.travelLeaf.entries()) {
      this.travelLeafPrefs.set(key, { ...value });
    }
  }
  ensureScope(travelId) {
    const key = travelId ?? GLOBAL_SCOPE;
    if (!this.scopeState.has(key)) {
      this.scopeState.set(key, { activeCalendarId: null, currentTimestamp: null });
    }
    return this.scopeState.get(key);
  }
  async resolveEffectiveCalendar(travelId) {
    if (travelId) {
      const travelDefaultId = await this.calendarRepo.getTravelDefault(travelId);
      if (travelDefaultId) {
        const travelCalendar = await this.calendarRepo.getCalendar(travelDefaultId);
        if (travelCalendar) {
          return {
            calendar: travelCalendar,
            calendarId: travelDefaultId,
            isGlobalDefault: false,
            wasAutoSelected: false
          };
        }
      }
    }
    const globalDefault = await this.calendarRepo.getGlobalDefault();
    if (globalDefault) {
      const calendar = await this.calendarRepo.getCalendar(globalDefault);
      if (calendar) {
        return {
          calendar,
          calendarId: globalDefault,
          isGlobalDefault: true,
          wasAutoSelected: false
        };
      }
    }
    const calendars = await this.calendarRepo.listCalendars();
    if (calendars.length > 0) {
      return {
        calendar: calendars[0],
        calendarId: calendars[0].id,
        isGlobalDefault: false,
        wasAutoSelected: true
      };
    }
    return null;
  }
  async listVisiblePhenomena(calendar) {
    const phenomena = await this.phenomenonRepo.listPhenomena();
    return phenomena.filter((phenomenon) => isPhenomenonVisibleForCalendar(phenomenon, calendar.id));
  }
  computeUpcomingPhenomenaForCalendar(calendar, phenomena, from, limit = 5) {
    if (phenomena.length === 0) {
      return [];
    }
    const anchor = from ?? createDayTimestamp(calendar.id, calendar.epoch.year, calendar.epoch.monthId, calendar.epoch.day);
    const occurrences = [];
    for (const phenomenon of phenomena) {
      try {
        const occurrence = computeNextPhenomenonOccurrence(
          phenomenon,
          calendar,
          calendar.id,
          anchor,
          { includeStart: true }
        );
        if (occurrence) {
          occurrences.push(occurrence);
        }
      } catch {
        continue;
      }
    }
    return sortOccurrencesByTimestamp(calendar, occurrences).slice(0, limit);
  }
  computeTriggeredPhenomenaBetween(calendar, phenomena, start, end) {
    if (phenomena.length === 0) {
      return [];
    }
    const occurrences = [];
    for (const phenomenon of phenomena) {
      try {
        const result = computePhenomenonOccurrencesInRange(
          phenomenon,
          calendar,
          calendar.id,
          start,
          end
        );
        occurrences.push(...result);
      } catch {
        continue;
      }
    }
    return sortOccurrencesByTimestamp(calendar, occurrences);
  }
};
function clonePreferences(preferences) {
  const base = preferences ?? {};
  return {
    ...base,
    lastZoomByMode: base.lastZoomByMode ? { ...base.lastZoomByMode } : void 0,
    eventsFilters: base.eventsFilters ? {
      categories: [...base.eventsFilters.categories],
      calendarIds: [...base.eventsFilters.calendarIds]
    } : void 0
  };
}
function cloneTravelLeafMap(source) {
  const clone2 = /* @__PURE__ */ new Map();
  for (const [key, value] of source.entries()) {
    clone2.set(key, { ...value });
  }
  return clone2;
}

// src/apps/almanac/mode/contracts.ts
var DEFAULT_ALMANAC_MODE = "dashboard";
var DEFAULT_MANAGER_VIEW_MODE = "calendar";
var DEFAULT_EVENTS_VIEW_MODE = "timeline";
var DEFAULT_MANAGER_ZOOM = "month";
function createDefaultCalendarDraft() {
  return {
    id: "",
    name: "",
    description: "",
    daysPerWeek: "7",
    monthCount: "12",
    monthLength: "30",
    hoursPerDay: "24",
    minutesPerHour: "60",
    minuteStep: "1",
    epochYear: "1",
    epochDay: "1"
  };
}
function createEmptySingleEventDraft(calendarId, reference) {
  return {
    kind: "single",
    id: "",
    calendarId,
    title: "",
    category: "",
    note: "",
    allDay: true,
    year: reference ? String(reference.year) : "",
    monthId: reference ? reference.monthId : "",
    day: reference ? String(reference.day) : "",
    hour: "0",
    minute: "0",
    durationMinutes: "",
    timePrecision: "day"
  };
}
function createEmptyRecurringEventDraft(calendarId, reference) {
  return {
    kind: "recurring",
    id: "",
    calendarId,
    title: "",
    category: "",
    note: "",
    allDay: true,
    year: reference ? String(reference.year) : "",
    monthId: reference ? reference.monthId : "",
    day: reference ? String(reference.day) : "",
    hour: "0",
    minute: "0",
    durationMinutes: "",
    ruleType: "weekly_dayIndex",
    ruleDayIndex: "0",
    ruleInterval: "1",
    ruleMonthId: reference ? reference.monthId : "",
    ruleDay: reference ? String(reference.day) : "1",
    timePolicy: "all_day",
    boundsEndYear: "",
    boundsEndMonthId: "",
    boundsEndDay: ""
  };
}
function createCalendarDraftFromSchema(schema) {
  const firstMonthLength = schema.months[0]?.length ?? 30;
  return {
    id: schema.id,
    name: schema.name,
    description: schema.description ?? "",
    daysPerWeek: String(schema.daysPerWeek),
    monthCount: String(schema.months.length),
    monthLength: String(firstMonthLength),
    hoursPerDay: String(schema.hoursPerDay ?? 24),
    minutesPerHour: String(schema.minutesPerHour ?? 60),
    minuteStep: String(schema.minuteStep ?? 1),
    epochYear: String(schema.epoch.year),
    epochDay: String(schema.epoch.day)
  };
}
function createInitialAlmanacState() {
  return {
    calendarState: {
      calendars: [],
      activeCalendarId: null,
      defaultCalendarId: null,
      travelDefaultCalendarId: null,
      currentTimestamp: null,
      timeDefinition: void 0,
      lastAdvanceStep: void 0,
      upcomingEvents: [],
      triggeredEvents: [],
      upcomingPhenomena: [],
      triggeredPhenomena: [],
      isPersisting: false
    },
    almanacUiState: {
      mode: DEFAULT_ALMANAC_MODE,
      modeHistory: [DEFAULT_ALMANAC_MODE],
      statusSummary: void 0,
      drawerOpen: false,
      lastZoomByMode: {},
      lastFiltersByMode: {},
      isLoading: false,
      error: void 0
    },
    calendarViewState: {
      mode: "month",
      zoom: DEFAULT_MANAGER_ZOOM,
      anchorTimestamp: null,
      events: [],
      isLoading: false,
      error: void 0
    },
    managerUiState: {
      viewMode: DEFAULT_MANAGER_VIEW_MODE,
      isLoading: false,
      error: void 0,
      selection: [],
      layout: "grid",
      anchorTimestamp: null,
      agendaItems: [],
      jumpPreview: [],
      createDraft: createDefaultCalendarDraft(),
      createErrors: [],
      isCreating: false,
      editStateById: {},
      deleteDialog: null,
      conflictDialog: null
    },
    eventsUiState: {
      viewMode: DEFAULT_EVENTS_VIEW_MODE,
      isLoading: false,
      filterCount: 0,
      error: void 0,
      filters: { categories: [], calendarIds: [] },
      availableCategories: [],
      availableCalendars: [],
      mapMarkers: [],
      phenomena: [],
      selectedPhenomenonId: null,
      selectedPhenomenonDetail: null,
      isDetailLoading: false,
      isEditorOpen: false,
      editorDraft: null,
      isSaving: false,
      editorError: void 0,
      bulkSelection: [],
      lastExportPayload: void 0,
      isImportDialogOpen: false,
      importError: void 0,
      importSummary: null,
      isEventEditorOpen: false,
      eventEditorMode: null,
      eventEditorDraft: null,
      eventEditorErrors: [],
      eventEditorPreview: [],
      isEventSaving: false,
      eventEditorError: void 0
    },
    travelLeafState: {
      travelId: null,
      visible: false,
      mode: "upcoming",
      currentTimestamp: null,
      minuteStep: 1,
      lastQuickStep: void 0,
      isLoading: false,
      error: void 0
    }
  };
}

// src/apps/almanac/data/phenomena-serialization.ts
function assertString(value, path) {
  if (typeof value !== "string") {
    throw new Error(`${path} must be a string`);
  }
  return value;
}
function assertArray(value, path) {
  if (!Array.isArray(value)) {
    throw new Error(`${path} must be an array`);
  }
  return value;
}
function normalisePhenomenon(input, index) {
  if (typeof input !== "object" || input === null) {
    throw new Error(`Entry ${index + 1} must be an object`);
  }
  const record = input;
  const id = assertString(record.id, `phenomena[${index}].id`).trim();
  const name = assertString(record.name, `phenomena[${index}].name`).trim();
  const category = assertString(record.category ?? "custom", `phenomena[${index}].category`).trim();
  const visibility = assertString(
    record.visibility ?? "all_calendars",
    `phenomena[${index}].visibility`
  );
  const appliesTo = assertArray(
    record.appliesToCalendarIds ?? [],
    `phenomena[${index}].appliesToCalendarIds`
  ).map((value) => assertString(value, `phenomena[${index}].appliesToCalendarIds[]`));
  const rule = record.rule ?? { type: "annual", offsetDayOfYear: 0 };
  const timePolicy = record.timePolicy ?? "all_day";
  const priority = typeof record.priority === "number" ? record.priority : 0;
  const schemaVersion = assertString(
    record.schemaVersion ?? "1.0.0",
    `phenomena[${index}].schemaVersion`
  );
  const base = {
    id,
    name,
    category: category || "custom",
    visibility: visibility === "selected" ? "selected" : "all_calendars",
    appliesToCalendarIds: appliesTo,
    rule,
    timePolicy,
    priority,
    schemaVersion
  };
  const optionalKeys = [
    "notes",
    "tags",
    "effects",
    "hooks",
    "startTime",
    "offsetMinutes",
    "durationMinutes"
  ];
  for (const key of optionalKeys) {
    if (record[key] !== void 0) {
      base[key] = record[key];
    }
  }
  return base;
}
function parsePhenomenaImport(source) {
  const trimmed = source.trim();
  if (!trimmed) {
    return [];
  }
  let data;
  try {
    data = JSON.parse(trimmed);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Import payload is not valid JSON: ${message}`);
  }
  if (!Array.isArray(data)) {
    throw new Error("Import payload must be a JSON array");
  }
  return data.map((entry, index) => normalisePhenomenon(entry, index));
}
function formatPhenomenaExport(entries) {
  const payload = entries.map((entry) => ({
    id: entry.id,
    name: entry.name,
    category: entry.category,
    visibility: entry.visibility,
    appliesToCalendarIds: entry.appliesToCalendarIds,
    rule: entry.rule,
    timePolicy: entry.timePolicy,
    priority: entry.priority,
    schemaVersion: entry.schemaVersion,
    notes: entry.notes,
    tags: entry.tags,
    effects: entry.effects,
    hooks: entry.hooks,
    startTime: entry.startTime,
    offsetMinutes: entry.offsetMinutes,
    durationMinutes: entry.durationMinutes
  }));
  return JSON.stringify(payload, null, 2);
}

// src/apps/almanac/mode/state-machine.ts
init_calendar_schema();
init_calendar_event();
init_calendar_timestamp();
init_time_arithmetic();
init_cartographer_gateway();
var MAX_TRIGGERED_EVENTS = 10;
var MAX_TRIGGERED_PHENOMENA = 10;
var ZOOM_LABEL = {
  month: "Month view",
  week: "Week view",
  day: "Day view",
  hour: "Hour view"
};
var AlmanacStateMachine = class {
  constructor(calendarRepo, eventRepo, gateway, phenomenonRepo, cartographerGateway = cartographerHookGateway) {
    this.calendarRepo = calendarRepo;
    this.eventRepo = eventRepo;
    this.gateway = gateway;
    this.phenomenonRepo = phenomenonRepo;
    this.state = createInitialAlmanacState();
    this.listeners = /* @__PURE__ */ new Set();
    this.initialised = false;
    this.phenomenaSource = [];
    this.phenomenaDefinitions = [];
    this.phenomenonIdCounter = 0;
    this.eventIdCounter = 0;
    this.travelId = null;
    this.travelLeafPreferences = null;
    this.cartographerGateway = cartographerGateway;
  }
  getState() {
    return this.state;
  }
  subscribe(listener) {
    this.listeners.add(listener);
    listener(this.state);
    return () => this.listeners.delete(listener);
  }
  async dispatch(event) {
    switch (event.type) {
      case "INIT_ALMANAC":
        await this.handleInit(event.travelId ?? null, event.overrides ?? null);
        break;
      case "ALMANAC_MODE_SELECTED":
        await this.handleModeSelected(event.mode);
        break;
      case "MANAGER_VIEW_MODE_CHANGED":
        await this.handleManagerViewMode(event.viewMode);
        break;
      case "MANAGER_ZOOM_CHANGED":
        await this.handleManagerZoom(event.zoom);
        break;
      case "MANAGER_NAVIGATION_REQUESTED":
        this.handleManagerNavigation(event.direction);
        break;
      case "MANAGER_CREATE_FORM_UPDATED":
        this.handleCreateFormUpdated(event.field, event.value);
        break;
      case "CALENDAR_CREATE_REQUESTED":
        await this.handleCalendarCreate();
        break;
      case "CALENDAR_EDIT_REQUESTED":
        this.handleCalendarEditRequested(event.calendarId);
        break;
      case "CALENDAR_EDIT_CANCELLED":
        this.handleCalendarEditCancelled(event.calendarId);
        break;
      case "CALENDAR_EDIT_FORM_UPDATED":
        this.handleCalendarEditFormUpdated(event.calendarId, event.field, event.value);
        break;
      case "CALENDAR_UPDATE_REQUESTED":
        await this.handleCalendarUpdate(event.calendarId);
        break;
      case "CALENDAR_DELETE_REQUESTED":
        await this.handleCalendarDeleteRequested(event.calendarId);
        break;
      case "CALENDAR_DELETE_CONFIRMED":
        await this.handleCalendarDeleteConfirmed(event.calendarId);
        break;
      case "CALENDAR_DELETE_CANCELLED":
        this.handleCalendarDeleteCancelled();
        break;
      case "CALENDAR_CONFLICT_DISMISSED":
        this.handleConflictDismissed();
        break;
      case "TIME_JUMP_PREVIEW_REQUESTED":
        await this.handleTimeJumpPreview(event.timestamp);
        break;
      case "EVENTS_VIEW_MODE_CHANGED":
        await this.handleEventsViewMode(event.viewMode);
        break;
      case "EVENTS_FILTER_CHANGED":
        this.handleEventsFilterChange(event.filters);
        break;
      case "EVENTS_PHENOMENON_SELECTED":
        await this.handlePhenomenonSelected(event.phenomenonId);
        break;
      case "EVENTS_PHENOMENON_DETAIL_CLOSED":
        this.handlePhenomenonDetailClosed();
        break;
      case "EVENTS_BULK_SELECTION_UPDATED":
        this.handleEventsBulkSelection(event.selection);
        break;
      case "PHENOMENON_EDIT_REQUESTED":
        await this.handlePhenomenonEditRequest(event.phenomenonId ?? null);
        break;
      case "PHENOMENON_EDIT_CANCELLED":
        this.handlePhenomenonEditCancelled();
        break;
      case "PHENOMENON_SAVE_REQUESTED":
        await this.handlePhenomenonSave(event.draft);
        break;
      case "EVENT_BULK_ACTION_REQUESTED":
        await this.handleEventBulkAction(event.action, event.ids);
        break;
      case "EVENT_EXPORT_CLEARED":
        this.handleEventExportCleared();
        break;
      case "EVENT_IMPORT_REQUESTED":
        this.handleEventImportRequested();
        break;
      case "EVENT_IMPORT_CANCELLED":
        this.handleEventImportCancelled();
        break;
      case "EVENT_IMPORT_SUBMITTED":
        await this.handleEventImportSubmitted(event.payload);
        break;
      case "EVENT_CREATE_REQUESTED":
        await this.handleEventCreateRequested(event.mode, event.calendarId);
        break;
      case "EVENT_EDIT_REQUESTED":
        await this.handleEventEditRequested(event.eventId);
        break;
      case "EVENT_EDITOR_UPDATED":
        this.handleEventEditorUpdated(event.update);
        break;
      case "EVENT_EDITOR_CANCELLED":
        this.handleEventEditorCancelled();
        break;
      case "EVENT_EDITOR_SAVE_REQUESTED":
        await this.handleEventEditorSave();
        break;
      case "EVENT_DELETE_REQUESTED":
        await this.handleEventDelete(event.eventId);
        break;
      case "MANAGER_SELECTION_CHANGED":
        this.handleManagerSelectionChanged(event.selection);
        break;
      case "CALENDAR_SELECT_REQUESTED":
        await this.handleCalendarSelect(event.calendarId);
        break;
      case "CALENDAR_DEFAULT_SET_REQUESTED":
        await this.handleCalendarDefault(event.calendarId);
        break;
      case "TIME_ADVANCE_REQUESTED":
        await this.handleTimeAdvance(event.amount, event.unit);
        break;
      case "TIME_JUMP_REQUESTED":
        await this.handleTimeJump(event.timestamp);
        break;
      case "CALENDAR_DATA_REFRESH_REQUESTED":
        await this.refreshCalendarData();
        break;
      case "TRAVEL_LEAF_MOUNTED":
        await this.handleTravelLeafMounted(event.travelId);
        break;
      case "TRAVEL_MODE_CHANGED":
        await this.handleTravelModeChanged(event.mode);
        break;
      case "TRAVEL_TIME_ADVANCE_REQUESTED":
        await this.handleTimeAdvance(event.amount, event.unit, "travel");
        break;
      case "ERROR_OCCURRED":
        this.setState((draft) => {
          if (event.scope === "almanac") {
            draft.almanacUiState = {
              ...draft.almanacUiState,
              isLoading: false,
              error: event.message
            };
          } else if (event.scope === "manager") {
            draft.managerUiState = {
              ...draft.managerUiState,
              isLoading: false,
              error: event.message
            };
          } else if (event.scope === "events") {
            draft.eventsUiState = {
              ...draft.eventsUiState,
              isLoading: false,
              error: event.message
            };
          } else {
            draft.travelLeafState = {
              ...draft.travelLeafState,
              isLoading: false,
              error: event.message
            };
          }
        });
        break;
      default:
        const _never = event;
        return _never;
    }
  }
  notify() {
    for (const listener of this.listeners) {
      listener(this.state);
    }
  }
  setState(mutator) {
    const next = cloneState(this.state);
    mutator(next);
    next.almanacUiState = {
      ...next.almanacUiState,
      statusSummary: this.computeStatusSummary(next)
    };
    this.state = next;
    this.notify();
  }
  computeStatusSummary(state) {
    switch (state.almanacUiState.mode) {
      case "dashboard": {
        const upcoming = state.calendarState.upcomingEvents.length;
        return upcoming === 0 ? void 0 : { filterCount: upcoming };
      }
      case "manager": {
        const zoomLabel = ZOOM_LABEL[state.calendarViewState.zoom];
        const filterCount = state.managerUiState.selection.length;
        return { zoomLabel, filterCount: filterCount > 0 ? filterCount : void 0 };
      }
      case "events": {
        const filterCount = state.eventsUiState.filterCount;
        return filterCount > 0 ? { filterCount } : void 0;
      }
      default:
        return void 0;
    }
  }
  async handleInit(travelId, overrides) {
    const effectiveTravelId = overrides?.travelId ?? travelId ?? this.travelId ?? null;
    this.travelId = effectiveTravelId;
    const hasOverrides = Boolean(
      overrides && (overrides.mode !== void 0 || overrides.managerView !== void 0 || overrides.managerZoom !== void 0 || overrides.eventsView !== void 0 || overrides.travelId !== void 0 || Object.prototype.hasOwnProperty.call(overrides, "selectedPhenomenonId"))
    );
    if (this.initialised && !hasOverrides) {
      await this.refreshCalendarData();
      return;
    }
    this.setState((draft) => {
      draft.almanacUiState = {
        ...draft.almanacUiState,
        isLoading: true,
        error: void 0
      };
    });
    try {
      const [calendars, snapshot, preferences, phenomena, travelPreferences] = await Promise.all([
        this.calendarRepo.listCalendars(),
        this.gateway.loadSnapshot(effectiveTravelId ? { travelId: effectiveTravelId } : void 0),
        this.gateway.loadPreferences(),
        this.phenomenonRepo.listPhenomena(),
        effectiveTravelId ? this.gateway.getTravelLeafPreferences(effectiveTravelId) : Promise.resolve(null)
      ]);
      this.travelLeafPreferences = travelPreferences;
      this.phenomenaDefinitions = phenomena.map((item) => this.toPhenomenon(item));
      this.phenomenaSource = this.buildPhenomenonViewModels(
        this.phenomenaDefinitions,
        calendars,
        snapshot.activeCalendar?.id ?? null,
        snapshot.currentTimestamp
      );
      const filters = preferences.eventsFilters ?? { categories: [], calendarIds: [] };
      const filteredPhenomena = this.applyPhenomenaFilters(filters);
      const availableCategories = getUniqueCategories(this.phenomenaSource);
      const filterCount = filters.categories.length + filters.calendarIds.length;
      let preferredPhenomenonId = preferences.lastSelectedPhenomenonId ?? null;
      if (overrides && Object.prototype.hasOwnProperty.call(overrides, "selectedPhenomenonId")) {
        preferredPhenomenonId = overrides.selectedPhenomenonId ?? null;
      }
      let initialSelectedId = null;
      let initialDetail = null;
      if (preferredPhenomenonId && filteredPhenomena.some((item) => item.id === preferredPhenomenonId)) {
        initialDetail = this.buildPhenomenonDetailForId(
          preferredPhenomenonId,
          calendars,
          snapshot.currentTimestamp
        );
        initialSelectedId = initialDetail ? preferredPhenomenonId : null;
      }
      if (!initialSelectedId && filteredPhenomena.length > 0) {
        const firstId = filteredPhenomena[0].id;
        initialDetail = this.buildPhenomenonDetailForId(firstId, calendars, snapshot.currentTimestamp);
        initialSelectedId = initialDetail ? firstId : null;
      }
      const mode = overrides?.mode ?? preferences.lastMode ?? DEFAULT_ALMANAC_MODE;
      const managerViewMode = overrides?.managerView ?? preferences.managerViewMode ?? DEFAULT_MANAGER_VIEW_MODE;
      const eventsViewMode = overrides?.eventsView ?? preferences.eventsViewMode ?? DEFAULT_EVENTS_VIEW_MODE;
      const zoom = overrides?.managerZoom ?? preferences.lastZoomByMode?.["manager"] ?? DEFAULT_MANAGER_ZOOM;
      const activeCalendarId = snapshot.activeCalendar?.id ?? null;
      const timeDefinition = snapshot.activeCalendar ? (() => {
        const { hoursPerDay, minutesPerHour, minuteStep } = getTimeDefinition(
          snapshot.activeCalendar
        );
        return { hoursPerDay, minutesPerHour, minuteStep };
      })() : void 0;
      const defaultCalendarId = snapshot.defaultCalendarId ?? calendars.find((schema) => schema.isDefaultGlobal)?.id ?? null;
      const calendarSlice = {
        calendars,
        activeCalendarId,
        defaultCalendarId,
        travelDefaultCalendarId: snapshot.travelDefaultCalendarId ?? null,
        currentTimestamp: snapshot.currentTimestamp,
        timeDefinition,
        lastAdvanceStep: void 0,
        upcomingEvents: snapshot.upcomingEvents,
        triggeredEvents: [],
        upcomingPhenomena: snapshot.upcomingPhenomena,
        triggeredPhenomena: [],
        isPersisting: false
      };
      const mapMarkers = this.buildPhenomenonMapMarkers(filteredPhenomena, calendars);
      this.setState((draft) => {
        draft.calendarState = calendarSlice;
        const lastZoomByMode = { ...preferences.lastZoomByMode ?? {} };
        if (overrides?.managerZoom) {
          lastZoomByMode["manager"] = overrides.managerZoom;
        }
        draft.almanacUiState = {
          ...draft.almanacUiState,
          mode,
          modeHistory: [mode],
          isLoading: false,
          error: void 0,
          lastZoomByMode
        };
        draft.calendarViewState = {
          mode: "month",
          zoom,
          anchorTimestamp: calendarSlice.currentTimestamp,
          events: calendarSlice.upcomingEvents,
          isLoading: false,
          error: void 0
        };
        draft.managerUiState = {
          ...draft.managerUiState,
          viewMode: managerViewMode,
          isLoading: false,
          error: void 0,
          selection: [],
          layout: "grid"
        };
        draft.eventsUiState = {
          ...draft.eventsUiState,
          viewMode: eventsViewMode,
          isLoading: false,
          error: void 0,
          filterCount,
          filters: { ...filters },
          availableCategories,
          availableCalendars: calendars.map((schema) => ({ id: schema.id, name: schema.name })),
          mapMarkers,
          phenomena: filteredPhenomena,
          selectedPhenomenonId: initialSelectedId,
          selectedPhenomenonDetail: initialDetail,
          isDetailLoading: false
        };
        draft.travelLeafState = {
          ...draft.travelLeafState,
          travelId: effectiveTravelId,
          visible: travelPreferences?.visible ?? false,
          mode: travelPreferences?.mode ?? draft.travelLeafState.mode,
          currentTimestamp: calendarSlice.currentTimestamp,
          minuteStep: calendarSlice.timeDefinition?.minuteStep ?? draft.travelLeafState.minuteStep,
          lastQuickStep: void 0,
          isLoading: false,
          error: void 0
        };
      });
      const initialPanel = {
        travelId: this.travelId,
        currentTimestamp: snapshot.currentTimestamp,
        triggeredEvents: [],
        triggeredPhenomena: [],
        skippedEvents: [],
        skippedPhenomena: [],
        reason: "init"
      };
      await this.cartographerGateway.notifyTravelPanel(initialPanel);
      this.initialised = true;
      this.ensurePhenomenonSelection();
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unbekannter Fehler beim Initialisieren";
      this.setState((draft) => {
        draft.almanacUiState = {
          ...draft.almanacUiState,
          isLoading: false,
          error: message
        };
      });
      throw error;
    }
  }
  async refreshCalendarData() {
    this.setState((draft) => {
      draft.almanacUiState = {
        ...draft.almanacUiState,
        isLoading: true
      };
    });
    try {
      const [calendars, snapshot, phenomena] = await Promise.all([
        this.calendarRepo.listCalendars(),
        this.gateway.loadSnapshot(this.travelId ? { travelId: this.travelId } : void 0),
        this.phenomenonRepo.listPhenomena()
      ]);
      this.phenomenaDefinitions = phenomena.map((item) => this.toPhenomenon(item));
      this.phenomenaSource = this.buildPhenomenonViewModels(
        this.phenomenaDefinitions,
        calendars,
        snapshot.activeCalendar?.id ?? null,
        snapshot.currentTimestamp
      );
      const filters = {
        categories: [...this.state.eventsUiState.filters.categories],
        calendarIds: [...this.state.eventsUiState.filters.calendarIds]
      };
      const filteredPhenomena = this.applyPhenomenaFilters(filters);
      const availableCategories = getUniqueCategories(this.phenomenaSource);
      const filterCount = filters.categories.length + filters.calendarIds.length;
      const currentSelectedId = this.state.eventsUiState.selectedPhenomenonId ?? null;
      let nextSelectedId = null;
      let nextDetail = null;
      if (currentSelectedId && filteredPhenomena.some((item) => item.id === currentSelectedId)) {
        nextDetail = this.buildPhenomenonDetailForId(
          currentSelectedId,
          calendars,
          snapshot.currentTimestamp
        );
        nextSelectedId = nextDetail ? currentSelectedId : null;
      }
      if (!nextSelectedId && filteredPhenomena.length > 0) {
        const firstId = filteredPhenomena[0].id;
        nextDetail = this.buildPhenomenonDetailForId(firstId, calendars, snapshot.currentTimestamp);
        nextSelectedId = nextDetail ? firstId : null;
      }
      const activeCalendarId = snapshot.activeCalendar?.id ?? null;
      const timeDefinition = snapshot.activeCalendar ? (() => {
        const { hoursPerDay, minutesPerHour, minuteStep } = getTimeDefinition(
          snapshot.activeCalendar
        );
        return { hoursPerDay, minutesPerHour, minuteStep };
      })() : void 0;
      const anchor = this.state.managerUiState.anchorTimestamp ?? snapshot.currentTimestamp ?? this.getAnchorFallback();
      const agendaItems = anchor ? this.collectAgendaItems(anchor, this.state.calendarViewState.zoom, snapshot.upcomingEvents) : [];
      const defaultCalendarId = snapshot.defaultCalendarId ?? calendars.find((schema) => schema.isDefaultGlobal)?.id ?? null;
      const mapMarkers = this.buildPhenomenonMapMarkers(filteredPhenomena, calendars);
      this.setState((draft) => {
        const anchor2 = draft.managerUiState.anchorTimestamp ?? snapshot.currentTimestamp ?? this.getAnchorFallback();
        const agendaItems2 = anchor2 ? this.collectAgendaItems(anchor2, draft.calendarViewState.zoom, snapshot.upcomingEvents) : [];
        draft.calendarState = {
          ...draft.calendarState,
          calendars,
          activeCalendarId,
          defaultCalendarId,
          travelDefaultCalendarId: snapshot.travelDefaultCalendarId ?? null,
          currentTimestamp: snapshot.currentTimestamp,
          timeDefinition,
          upcomingEvents: snapshot.upcomingEvents,
          upcomingPhenomena: snapshot.upcomingPhenomena,
          isPersisting: false
        };
        draft.almanacUiState = {
          ...draft.almanacUiState,
          isLoading: false,
          error: void 0
        };
        draft.calendarViewState = {
          ...draft.calendarViewState,
          anchorTimestamp: snapshot.currentTimestamp,
          events: snapshot.upcomingEvents
        };
        draft.managerUiState = {
          ...draft.managerUiState,
          anchorTimestamp: draft.managerUiState.anchorTimestamp ?? snapshot.currentTimestamp,
          agendaItems: agendaItems2,
          jumpPreview: []
        };
        draft.eventsUiState = {
          ...draft.eventsUiState,
          filterCount,
          filters: { ...filters },
          availableCategories,
          availableCalendars: calendars.map((schema) => ({ id: schema.id, name: schema.name })),
          mapMarkers,
          phenomena: filteredPhenomena,
          selectedPhenomenonId: nextSelectedId,
          selectedPhenomenonDetail: nextDetail,
          isDetailLoading: false
        };
        draft.travelLeafState = {
          ...draft.travelLeafState,
          travelId: this.travelId,
          currentTimestamp: snapshot.currentTimestamp,
          minuteStep: timeDefinition?.minuteStep ?? draft.travelLeafState.minuteStep
        };
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : "Kalenderdaten konnten nicht geladen werden";
      this.setState((draft) => {
        draft.almanacUiState = {
          ...draft.almanacUiState,
          isLoading: false,
          error: message
        };
        draft.calendarState = {
          ...draft.calendarState,
          isPersisting: false
        };
      });
    }
  }
  async handleModeSelected(mode) {
    if (mode === this.state.almanacUiState.mode) {
      return;
    }
    const previousMode = this.state.almanacUiState.mode;
    this.setState((draft) => {
      draft.almanacUiState = {
        ...draft.almanacUiState,
        mode,
        modeHistory: [...draft.almanacUiState.modeHistory, mode].slice(-5),
        error: void 0
      };
    });
    emitAlmanacEvent({
      type: "calendar.almanac.mode_change",
      mode,
      previousMode,
      history: this.state.almanacUiState.modeHistory
    });
    await this.persistPreferences({ lastMode: mode });
    if (mode === "events") {
      this.ensurePhenomenonSelection();
    }
  }
  async handleManagerViewMode(viewMode) {
    if (viewMode === this.state.managerUiState.viewMode) {
      return;
    }
    const anchorBase = this.getAnchorBase();
    this.setState((draft) => {
      draft.managerUiState = {
        ...draft.managerUiState,
        viewMode,
        isLoading: false,
        error: void 0,
        anchorTimestamp: anchorBase ?? draft.managerUiState.anchorTimestamp,
        agendaItems: anchorBase ? this.collectAgendaItems(anchorBase, draft.calendarViewState.zoom) : []
      };
    });
    await this.persistPreferences({ managerViewMode: viewMode });
  }
  async handleManagerZoom(zoom) {
    if (zoom === this.state.calendarViewState.zoom) {
      return;
    }
    const anchorBase = this.getAnchorBase();
    const agendaItems = anchorBase ? this.collectAgendaItems(anchorBase, zoom) : [];
    this.setState((draft) => {
      draft.calendarViewState = {
        ...draft.calendarViewState,
        zoom
      };
      draft.managerUiState = {
        ...draft.managerUiState,
        anchorTimestamp: anchorBase ?? draft.managerUiState.anchorTimestamp,
        agendaItems,
        jumpPreview: []
      };
      draft.almanacUiState = {
        ...draft.almanacUiState,
        lastZoomByMode: {
          ...draft.almanacUiState.lastZoomByMode,
          manager: zoom
        }
      };
    });
    await this.persistPreferences({
      lastZoomByMode: {
        ...this.state.almanacUiState.lastZoomByMode,
        manager: zoom
      }
    });
  }
  handleManagerNavigation(direction) {
    const activeCalendarId = this.state.calendarState.activeCalendarId;
    if (!activeCalendarId) {
      return;
    }
    const schema = this.getCalendarSchema(activeCalendarId);
    if (!schema) {
      return;
    }
    const baseAnchor = this.state.managerUiState.anchorTimestamp ?? this.state.calendarState.currentTimestamp ?? createDayTimestamp(activeCalendarId, schema.epoch.year, schema.epoch.monthId, schema.epoch.day);
    const nextAnchor = direction === "today" ? this.state.calendarState.currentTimestamp ?? baseAnchor : this.shiftAnchorTimestamp(schema, baseAnchor, this.state.calendarViewState.zoom, direction);
    this.setState((draft) => {
      draft.managerUiState = {
        ...draft.managerUiState,
        anchorTimestamp: nextAnchor,
        agendaItems: this.collectAgendaItems(nextAnchor, draft.calendarViewState.zoom),
        jumpPreview: []
      };
    });
  }
  async handleEventsViewMode(viewMode) {
    if (viewMode === this.state.eventsUiState.viewMode) {
      return;
    }
    this.setState((draft) => {
      draft.eventsUiState = {
        ...draft.eventsUiState,
        viewMode,
        error: void 0
      };
    });
    await this.persistPreferences({ eventsViewMode: viewMode });
    if (this.state.almanacUiState.mode === "events") {
      this.ensurePhenomenonSelection();
    }
  }
  handleEventsFilterChange(filters) {
    const normalised = {
      categories: Array.from(new Set(filters.categories.filter(Boolean))),
      calendarIds: Array.from(new Set(filters.calendarIds.filter(Boolean)))
    };
    const filteredPhenomena = this.applyPhenomenaFilters(normalised);
    const filterCount = normalised.categories.length + normalised.calendarIds.length;
    const selectedCandidate = this.state.eventsUiState.selectedPhenomenonId ?? null;
    const calendars = this.state.calendarState.calendars;
    const referenceTimestamp = this.state.calendarState.currentTimestamp;
    let nextSelectedId = null;
    let nextDetail = null;
    if (selectedCandidate && filteredPhenomena.some((item) => item.id === selectedCandidate)) {
      nextDetail = this.buildPhenomenonDetailForId(selectedCandidate, calendars, referenceTimestamp);
      nextSelectedId = nextDetail ? selectedCandidate : null;
    }
    if (!nextSelectedId && filteredPhenomena.length > 0) {
      const firstId = filteredPhenomena[0].id;
      nextDetail = this.buildPhenomenonDetailForId(firstId, calendars, referenceTimestamp);
      nextSelectedId = nextDetail ? firstId : null;
    }
    const mapMarkers = this.buildPhenomenonMapMarkers(filteredPhenomena, calendars);
    this.setState((draft) => {
      draft.eventsUiState = {
        ...draft.eventsUiState,
        filters: normalised,
        filterCount,
        mapMarkers,
        phenomena: filteredPhenomena,
        selectedPhenomenonId: nextSelectedId,
        selectedPhenomenonDetail: nextDetail,
        isDetailLoading: false
      };
    });
    void this.persistPreferences({
      eventsFilters: normalised,
      lastSelectedPhenomenonId: nextSelectedId ?? void 0
    });
  }
  async handlePhenomenonSelected(phenomenonId) {
    this.setState((draft) => {
      draft.eventsUiState = {
        ...draft.eventsUiState,
        selectedPhenomenonId: phenomenonId,
        isDetailLoading: true,
        error: void 0
      };
    });
    try {
      const phenomenonDto = await this.phenomenonRepo.getPhenomenon(phenomenonId);
      if (!phenomenonDto) {
        throw new Error(`Phenomenon ${phenomenonId} not found`);
      }
      const normalised = this.toPhenomenon(phenomenonDto);
      this.phenomenaDefinitions = [
        ...this.phenomenaDefinitions.filter((item) => item.id !== normalised.id),
        normalised
      ];
      const detail = this.buildPhenomenonDetailView(
        normalised,
        this.state.calendarState.calendars,
        this.state.calendarState.currentTimestamp
      );
      this.setState((draft) => {
        draft.eventsUiState = {
          ...draft.eventsUiState,
          selectedPhenomenonId: phenomenonId,
          selectedPhenomenonDetail: detail,
          isDetailLoading: false
        };
      });
      await this.persistPreferences({ lastSelectedPhenomenonId: phenomenonId });
    } catch (error) {
      const message = error instanceof Error ? error.message : "Phenomenon could not be loaded";
      this.setState((draft) => {
        draft.eventsUiState = {
          ...draft.eventsUiState,
          selectedPhenomenonId: null,
          selectedPhenomenonDetail: null,
          isDetailLoading: false,
          error: message
        };
      });
      await this.persistPreferences({ lastSelectedPhenomenonId: void 0 });
    }
  }
  handlePhenomenonDetailClosed() {
    this.setState((draft) => {
      draft.eventsUiState = {
        ...draft.eventsUiState,
        selectedPhenomenonId: null,
        selectedPhenomenonDetail: null,
        isDetailLoading: false
      };
    });
    void this.persistPreferences({ lastSelectedPhenomenonId: void 0 });
  }
  handleEventsBulkSelection(selection) {
    const validIds = new Set(this.phenomenaDefinitions.map((item) => item.id));
    const unique = Array.from(new Set(selection)).filter((id) => validIds.has(id));
    this.setState((draft) => {
      draft.eventsUiState = {
        ...draft.eventsUiState,
        bulkSelection: unique
      };
    });
  }
  async handlePhenomenonEditRequest(phenomenonId) {
    const base = phenomenonId ? this.phenomenaDefinitions.find((item) => item.id === phenomenonId) ?? null : null;
    const draft = base ? this.createEditorDraftFromPhenomenon(base) : this.createDefaultEditorDraft(phenomenonId);
    this.setState((next) => {
      next.eventsUiState = {
        ...next.eventsUiState,
        isEditorOpen: true,
        editorDraft: draft,
        isSaving: false,
        editorError: void 0
      };
    });
    if (phenomenonId && !base) {
      try {
        const loaded = await this.phenomenonRepo.getPhenomenon(phenomenonId);
        if (!loaded) {
          throw new Error(`Phenomenon ${phenomenonId} not found`);
        }
        const normalised = this.toPhenomenon(loaded);
        this.phenomenaDefinitions = [
          ...this.phenomenaDefinitions.filter((item) => item.id !== normalised.id),
          normalised
        ];
        this.setState((next) => {
          next.eventsUiState = {
            ...next.eventsUiState,
            editorDraft: this.createEditorDraftFromPhenomenon(normalised)
          };
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : "Editor konnte nicht ge\xF6ffnet werden";
        this.setState((next) => {
          next.eventsUiState = {
            ...next.eventsUiState,
            editorError: message
          };
        });
      }
    }
  }
  handlePhenomenonEditCancelled() {
    this.setState((draft) => {
      draft.eventsUiState = {
        ...draft.eventsUiState,
        isEditorOpen: false,
        editorDraft: null,
        isSaving: false,
        editorError: void 0
      };
    });
  }
  async handlePhenomenonSave(draft) {
    const trimmedName = draft.name.trim();
    if (!trimmedName) {
      this.setState((next) => {
        next.eventsUiState = {
          ...next.eventsUiState,
          editorError: "Name darf nicht leer sein."
        };
      });
      return;
    }
    this.setState((next) => {
      next.eventsUiState = {
        ...next.eventsUiState,
        isSaving: true,
        editorError: void 0
      };
    });
    try {
      const existing = this.phenomenaDefinitions.find((item) => item.id === draft.id) ?? null;
      const dto = this.buildPhenomenonFromDraft(draft, existing);
      const stored = await this.phenomenonRepo.upsertPhenomenon(dto);
      const normalised = this.toPhenomenon(stored);
      this.phenomenaDefinitions = [
        ...this.phenomenaDefinitions.filter((item) => item.id !== normalised.id),
        normalised
      ];
      this.rebuildPhenomenaListing(normalised.id, {
        bulkSelection: this.state.eventsUiState.bulkSelection,
        exportPayload: this.state.eventsUiState.lastExportPayload ?? void 0,
        importSummary: this.state.eventsUiState.importSummary ?? null
      });
      this.setState((next) => {
        next.eventsUiState = {
          ...next.eventsUiState,
          isEditorOpen: false,
          editorDraft: null,
          isSaving: false,
          editorError: void 0
        };
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : "Speichern fehlgeschlagen";
      const code = error instanceof AlmanacRepositoryError ? error.code : "io_error";
      reportAlmanacGatewayIssue({
        operation: "stateMachine.phenomenon.save",
        scope: "phenomenon",
        code,
        error,
        context: { phenomenonId: draft.id }
      });
      if (error instanceof AlmanacRepositoryError && error.code === "phenomenon_conflict") {
        emitAlmanacEvent({
          type: "calendar.event.conflict",
          code: "phenomenon",
          message,
          context: error.details
        });
      }
      this.setState((next) => {
        next.eventsUiState = {
          ...next.eventsUiState,
          isSaving: false,
          editorError: message
        };
      });
    }
  }
  async handleEventCreateRequested(mode, calendarId) {
    const fallbackCalendarId = calendarId ?? this.state.calendarState.activeCalendarId ?? this.state.calendarState.defaultCalendarId ?? (this.state.calendarState.calendars[0]?.id ?? null);
    if (!fallbackCalendarId) {
      const message = "Kein Kalender verf\xFCgbar.";
      this.setState((next) => {
        next.eventsUiState = {
          ...next.eventsUiState,
          isEventEditorOpen: true,
          eventEditorMode: mode,
          eventEditorDraft: null,
          eventEditorErrors: [message],
          eventEditorPreview: [],
          isEventSaving: false,
          eventEditorError: message
        };
      });
      return;
    }
    const schema = this.getCalendarSchema(fallbackCalendarId);
    const referenceTimestamp = this.state.calendarState.currentTimestamp;
    const reference = referenceTimestamp && referenceTimestamp.calendarId === fallbackCalendarId ? { year: referenceTimestamp.year, monthId: referenceTimestamp.monthId, day: referenceTimestamp.day } : schema ? { year: schema.epoch.year, monthId: schema.epoch.monthId, day: schema.epoch.day } : void 0;
    const draft = mode === "single" ? createEmptySingleEventDraft(fallbackCalendarId, reference) : createEmptyRecurringEventDraft(fallbackCalendarId, reference);
    const { errors, preview } = this.validateAndPreviewDraft(draft);
    this.setState((next) => {
      next.eventsUiState = {
        ...next.eventsUiState,
        isEventEditorOpen: true,
        eventEditorMode: mode,
        eventEditorDraft: draft,
        eventEditorErrors: errors,
        eventEditorPreview: preview,
        isEventSaving: false,
        eventEditorError: void 0
      };
    });
  }
  async handleEventEditRequested(eventId) {
    try {
      const event = await this.loadEventById(eventId);
      if (!event) {
        throw new Error(`Event ${eventId} konnte nicht gefunden werden.`);
      }
      const draft = this.createDraftFromEvent(event);
      const { errors, preview } = this.validateAndPreviewDraft(draft);
      this.setState((next) => {
        next.eventsUiState = {
          ...next.eventsUiState,
          isEventEditorOpen: true,
          eventEditorMode: draft.kind === "recurring" ? "recurring" : "single",
          eventEditorDraft: draft,
          eventEditorErrors: errors,
          eventEditorPreview: preview,
          isEventSaving: false,
          eventEditorError: void 0
        };
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : "Ereignis konnte nicht geladen werden.";
      reportAlmanacGatewayIssue({
        operation: "stateMachine.event.load",
        scope: "events",
        code: "io_error",
        error,
        context: { eventId }
      });
      this.setState((next) => {
        next.eventsUiState = {
          ...next.eventsUiState,
          isEventEditorOpen: false,
          eventEditorMode: null,
          eventEditorDraft: null,
          eventEditorErrors: [message],
          eventEditorPreview: [],
          isEventSaving: false,
          eventEditorError: message
        };
      });
    }
  }
  handleEventEditorUpdated(update) {
    const current = this.state.eventsUiState.eventEditorDraft;
    if (!current) {
      return;
    }
    const nextDraft = { ...current, ...update };
    const { errors, preview } = this.validateAndPreviewDraft(nextDraft);
    this.setState((next) => {
      next.eventsUiState = {
        ...next.eventsUiState,
        eventEditorDraft: nextDraft,
        eventEditorMode: nextDraft.kind === "recurring" ? "recurring" : "single",
        eventEditorErrors: errors,
        eventEditorPreview: preview,
        eventEditorError: void 0
      };
    });
  }
  handleEventEditorCancelled() {
    this.setState((next) => {
      next.eventsUiState = {
        ...next.eventsUiState,
        isEventEditorOpen: false,
        eventEditorMode: null,
        eventEditorDraft: null,
        eventEditorErrors: [],
        eventEditorPreview: [],
        isEventSaving: false,
        eventEditorError: void 0
      };
    });
  }
  async handleEventEditorSave() {
    const draft = this.state.eventsUiState.eventEditorDraft;
    if (!draft) {
      return;
    }
    const validation = this.validateEventDraft(draft);
    if (validation.errors.length > 0 || !validation.event) {
      this.setState((next) => {
        next.eventsUiState = {
          ...next.eventsUiState,
          eventEditorErrors: validation.errors,
          eventEditorPreview: [],
          isEventSaving: false,
          eventEditorError: validation.errors[0] ?? void 0
        };
      });
      return;
    }
    const isNew = !draft.id;
    const targetId = isNew ? this.generateEventId() : draft.id;
    const event = validation.event;
    const payload = isSingleEvent(event) ? { ...event, id: targetId } : { ...event, id: targetId };
    this.setState((next) => {
      next.eventsUiState = {
        ...next.eventsUiState,
        isEventSaving: true,
        eventEditorErrors: validation.errors,
        eventEditorPreview: validation.schema ? this.computeEventPreview(event, validation.schema) : [],
        eventEditorError: void 0
      };
    });
    try {
      if (isNew) {
        await this.eventRepo.createEvent(payload);
      } else {
        await this.eventRepo.updateEvent(targetId, payload);
      }
      await this.refreshCalendarData();
      this.setState((next) => {
        next.eventsUiState = {
          ...next.eventsUiState,
          isEventEditorOpen: false,
          eventEditorMode: null,
          eventEditorDraft: null,
          eventEditorErrors: [],
          eventEditorPreview: [],
          isEventSaving: false,
          eventEditorError: void 0
        };
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : "Ereignis konnte nicht gespeichert werden.";
      reportAlmanacGatewayIssue({
        operation: "stateMachine.event.save",
        scope: "events",
        code: "io_error",
        error,
        context: { eventId: targetId, mode: isNew ? "create" : "update" }
      });
      this.setState((next) => {
        next.eventsUiState = {
          ...next.eventsUiState,
          isEventSaving: false,
          eventEditorError: message
        };
      });
    }
  }
  async handleEventDelete(eventId) {
    try {
      await this.eventRepo.deleteEvent(eventId);
      await this.refreshCalendarData();
      this.setState((next) => {
        const isEditingDeleted = next.eventsUiState.eventEditorDraft?.id === eventId;
        next.eventsUiState = {
          ...next.eventsUiState,
          bulkSelection: next.eventsUiState.bulkSelection.filter((id) => id !== eventId),
          ...isEditingDeleted ? {
            isEventEditorOpen: false,
            eventEditorMode: null,
            eventEditorDraft: null,
            eventEditorErrors: [],
            eventEditorPreview: [],
            isEventSaving: false,
            eventEditorError: void 0
          } : {}
        };
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : "Ereignis konnte nicht gel\xF6scht werden.";
      reportAlmanacGatewayIssue({
        operation: "stateMachine.event.delete",
        scope: "events",
        code: "io_error",
        error,
        context: { eventId }
      });
      this.setState((next) => {
        next.eventsUiState = {
          ...next.eventsUiState,
          eventEditorError: message
        };
      });
    }
  }
  validateAndPreviewDraft(draft) {
    const validation = this.validateEventDraft(draft);
    const preview = validation.event && validation.schema ? this.computeEventPreview(validation.event, validation.schema) : [];
    return { errors: validation.errors, preview };
  }
  validateEventDraft(draft) {
    const schema = this.getCalendarSchema(draft.calendarId);
    if (!schema) {
      return { errors: ["Kalender konnte nicht gefunden werden."], event: null, schema: null };
    }
    const errors = [];
    const title = draft.title.trim();
    if (!title) {
      errors.push("Titel darf nicht leer sein.");
    }
    if (!draft.calendarId) {
      errors.push("Kalender erforderlich.");
    }
    const year = Number.parseInt(draft.year, 10);
    if (Number.isNaN(year)) {
      errors.push("Jahr ist ung\xFCltig.");
    }
    const month = draft.monthId ? getMonthById(schema, draft.monthId) : null;
    if (!month) {
      errors.push("Monat ist ung\xFCltig.");
    }
    const day = Number.parseInt(draft.day, 10);
    if (Number.isNaN(day)) {
      errors.push("Tag ist ung\xFCltig.");
    } else if (month && (day < 1 || day > month.length)) {
      errors.push("Tag liegt au\xDFerhalb des Monats.");
    }
    const definition = getTimeDefinition(schema);
    const hoursPerDay = definition.hoursPerDay;
    const minutesPerHour = definition.minutesPerHour;
    const minuteStep = definition.minuteStep;
    let hourValue = 0;
    let minuteValue = 0;
    if (!draft.allDay) {
      hourValue = Number.parseInt(draft.hour, 10);
      if (Number.isNaN(hourValue)) {
        errors.push("Stunde ist ung\xFCltig.");
      } else if (hourValue < 0 || hourValue >= hoursPerDay) {
        errors.push(`Stunde muss zwischen 0 und ${hoursPerDay - 1} liegen.`);
      }
      minuteValue = Number.parseInt(draft.minute, 10);
      const requiresMinute = draft.kind === "single" ? draft.timePrecision === "minute" && !draft.allDay : !draft.allDay && draft.timePolicy !== "all_day";
      if (requiresMinute) {
        if (Number.isNaN(minuteValue)) {
          errors.push("Minute ist ung\xFCltig.");
        } else if (minuteValue < 0 || minuteValue >= minutesPerHour) {
          errors.push(`Minute muss zwischen 0 und ${minutesPerHour - 1} liegen.`);
        } else if (minuteValue % minuteStep !== 0) {
          errors.push(`Minute muss im Schritt von ${minuteStep} liegen.`);
        }
      } else {
        minuteValue = 0;
      }
    }
    const duration = draft.durationMinutes.trim() ? Number.parseInt(draft.durationMinutes, 10) : void 0;
    if (duration !== void 0 && (Number.isNaN(duration) || duration < 0)) {
      errors.push("Dauer muss eine positive Zahl sein.");
    }
    if (draft.kind === "recurring" && draft.timePolicy === "offset" && (duration === void 0 || duration < 0)) {
      errors.push("Offset ben\xF6tigt Minutenangabe.");
    }
    if (draft.kind === "recurring" && draft.allDay && draft.timePolicy !== "all_day") {
      errors.push("Ganzt\xE4gige Ereignisse ben\xF6tigen die Zeitstrategie 'Ganzt\xE4gig'.");
    }
    if (errors.length > 0 || !month || Number.isNaN(year) || Number.isNaN(day)) {
      return { errors, event: null, schema };
    }
    const normalisedDay = Math.max(1, Math.min(day, month.length));
    const note = draft.note.trim() || void 0;
    const category = draft.category.trim() || void 0;
    const durationMinutes = duration !== void 0 && duration >= 0 ? duration : void 0;
    if (draft.kind === "single") {
      let timestamp;
      if (draft.allDay || draft.timePrecision === "day") {
        timestamp = createDayTimestamp(draft.calendarId, year, draft.monthId, normalisedDay);
      } else if (draft.timePrecision === "hour") {
        timestamp = createHourTimestamp(draft.calendarId, year, draft.monthId, normalisedDay, hourValue);
      } else {
        timestamp = createMinuteTimestamp(
          draft.calendarId,
          year,
          draft.monthId,
          normalisedDay,
          hourValue,
          minuteValue
        );
      }
      const startTime2 = draft.allDay ? void 0 : {
        hour: hourValue,
        ...draft.timePrecision === "minute" ? { minute: minuteValue } : {}
      };
      const event = createSingleEvent(draft.id || "__preview__", draft.calendarId, title, timestamp, {
        allDay: draft.allDay,
        category,
        note,
        durationMinutes,
        startTime: startTime2,
        timePrecision: draft.timePrecision
      });
      return { errors, event, schema };
    }
    let rule = null;
    if (draft.ruleType === "weekly_dayIndex") {
      const dayIndex = Number.parseInt(draft.ruleDayIndex, 10);
      if (Number.isNaN(dayIndex) || dayIndex < 0 || dayIndex >= schema.daysPerWeek) {
        errors.push("Wochentag ist ung\xFCltig.");
      } else {
        const intervalValue = Number.parseInt(draft.ruleInterval, 10);
        rule = {
          type: "weekly_dayIndex",
          dayIndex,
          ...Number.isNaN(intervalValue) || intervalValue <= 1 ? {} : { interval: intervalValue }
        };
      }
    } else if (draft.ruleType === "monthly_position") {
      const monthId = draft.ruleMonthId || draft.monthId;
      const monthForRule = getMonthById(schema, monthId);
      if (!monthForRule) {
        errors.push("Monat f\xFCr Regel ist ung\xFCltig.");
      } else {
        const ruleDay = Number.parseInt(draft.ruleDay, 10);
        if (Number.isNaN(ruleDay) || ruleDay < 1) {
          errors.push("Tag der Regel ist ung\xFCltig.");
        } else {
          const clamped = Math.min(ruleDay, monthForRule.length);
          rule = { type: "monthly_position", monthId, day: clamped };
        }
      }
    } else {
      const monthId = draft.ruleMonthId || draft.monthId;
      const monthForRule = getMonthById(schema, monthId);
      if (!monthForRule) {
        errors.push("Monat f\xFCr Offset ist ung\xFCltig.");
      } else {
        const ruleDay = Number.parseInt(draft.ruleDay, 10);
        if (Number.isNaN(ruleDay) || ruleDay < 1) {
          errors.push("Tag f\xFCr Offset ist ung\xFCltig.");
        } else {
          const clamped = Math.min(ruleDay, monthForRule.length);
          const offset = this.getDayOfYearForMonth(schema, monthId, clamped);
          rule = { type: "annual_offset", offsetDayOfYear: offset };
        }
      }
    }
    const endRequested = Boolean(
      draft.boundsEndYear || draft.boundsEndMonthId || draft.boundsEndDay
    );
    let boundsEnd;
    if (endRequested) {
      if (!draft.boundsEndYear || !draft.boundsEndMonthId || !draft.boundsEndDay) {
        errors.push("Enddatum muss Jahr, Monat und Tag enthalten.");
      } else {
        const endMonth = getMonthById(schema, draft.boundsEndMonthId);
        const endYear = Number.parseInt(draft.boundsEndYear, 10);
        const endDay = Number.parseInt(draft.boundsEndDay, 10);
        if (!endMonth || Number.isNaN(endYear) || Number.isNaN(endDay)) {
          errors.push("Enddatum ist ung\xFCltig.");
        } else {
          const clampedEnd = Math.min(Math.max(endDay, 1), endMonth.length);
          boundsEnd = createDayTimestamp(
            draft.calendarId,
            endYear,
            draft.boundsEndMonthId,
            clampedEnd
          );
        }
      }
    }
    if (!rule) {
      errors.push("Wiederholregel ist ung\xFCltig.");
      return { errors, event: null, schema };
    }
    const anchorTimestamp = draft.allDay ? createDayTimestamp(draft.calendarId, year, draft.monthId, normalisedDay) : minuteValue > 0 ? createMinuteTimestamp(
      draft.calendarId,
      year,
      draft.monthId,
      normalisedDay,
      hourValue,
      minuteValue
    ) : createHourTimestamp(draft.calendarId, year, draft.monthId, normalisedDay, hourValue);
    const startTime = draft.allDay ? void 0 : { hour: hourValue, minute: minuteValue };
    const recurring = {
      kind: "recurring",
      id: draft.id || "__preview__",
      calendarId: draft.calendarId,
      title,
      note,
      category,
      date: anchorTimestamp,
      allDay: draft.allDay,
      rule,
      timePolicy: draft.timePolicy,
      startTime: draft.allDay ? void 0 : startTime,
      offsetMinutes: draft.timePolicy === "offset" ? durationMinutes ?? 0 : void 0,
      durationMinutes: draft.timePolicy === "offset" ? void 0 : durationMinutes,
      bounds: boundsEnd ? { start: anchorTimestamp, end: boundsEnd } : { start: anchorTimestamp }
    };
    return { errors, event: recurring, schema };
  }
  computeEventPreview(event, schema) {
    const occurrences = [];
    const reference = this.state.calendarState.currentTimestamp && this.state.calendarState.currentTimestamp.calendarId === event.calendarId ? this.state.calendarState.currentTimestamp : event.date;
    let cursor = reference;
    let includeStart = true;
    for (let index = 0; index < 5; index += 1) {
      const next = computeNextEventOccurrence(event, schema, event.calendarId, cursor, { includeStart });
      if (!next) {
        break;
      }
      const monthName = getMonthById(schema, next.start.monthId)?.name ?? next.start.monthId;
      occurrences.push({
        id: `${event.id}-${index}`,
        timestamp: next.start,
        label: formatTimestamp(next.start, monthName)
      });
      includeStart = false;
      const precision = next.start.precision;
      const unit = precision === "minute" ? "minute" : precision === "hour" ? "hour" : "day";
      cursor = advanceTime(schema, next.start, 1, unit).timestamp;
    }
    if (occurrences.length === 0 && isSingleEvent(event)) {
      const monthName = getMonthById(schema, event.date.monthId)?.name ?? event.date.monthId;
      occurrences.push({
        id: `${event.id}-0`,
        timestamp: event.date,
        label: formatTimestamp(event.date, monthName)
      });
    }
    return occurrences.slice(0, 5);
  }
  createDraftFromEvent(event) {
    const schema = this.getCalendarSchema(event.calendarId);
    if (isSingleEvent(event)) {
      const draft2 = createEmptySingleEventDraft(event.calendarId, {
        year: event.date.year,
        monthId: event.date.monthId,
        day: event.date.day
      });
      return {
        ...draft2,
        id: event.id,
        title: event.title,
        category: event.category ?? "",
        note: event.note ?? "",
        allDay: event.allDay,
        hour: String(event.startTime?.hour ?? event.date.hour ?? 0),
        minute: String(event.startTime?.minute ?? event.date.minute ?? 0),
        durationMinutes: event.durationMinutes != null ? String(event.durationMinutes) : "",
        timePrecision: event.timePrecision
      };
    }
    const draft = createEmptyRecurringEventDraft(event.calendarId, {
      year: event.date.year,
      monthId: event.date.monthId,
      day: event.date.day
    });
    let ruleDayIndex = draft.ruleDayIndex;
    let ruleInterval = draft.ruleInterval;
    let ruleMonthId = draft.ruleMonthId;
    let ruleDay = draft.ruleDay;
    if (event.rule.type === "weekly_dayIndex") {
      ruleDayIndex = String(event.rule.dayIndex);
      ruleInterval = event.rule.interval ? String(event.rule.interval) : "1";
    } else if (event.rule.type === "monthly_position") {
      ruleMonthId = event.rule.monthId;
      ruleDay = String(event.rule.day);
    } else if (event.rule.type === "annual_offset" && schema) {
      const months = schema.months;
      let remaining = event.rule.offsetDayOfYear;
      for (const monthSchema of months) {
        if (remaining <= monthSchema.length) {
          ruleMonthId = monthSchema.id;
          ruleDay = String(remaining);
          break;
        }
        remaining -= monthSchema.length;
      }
    }
    const boundsEnd = event.bounds?.end;
    return {
      ...draft,
      id: event.id,
      title: event.title,
      category: event.category ?? "",
      note: event.note ?? "",
      allDay: event.allDay,
      hour: String(event.startTime?.hour ?? event.date.hour ?? 0),
      minute: String(event.startTime?.minute ?? event.date.minute ?? 0),
      durationMinutes: event.timePolicy === "offset" ? String(event.offsetMinutes ?? 0) : event.durationMinutes != null ? String(event.durationMinutes) : "",
      ruleType: event.rule.type,
      ruleDayIndex,
      ruleInterval,
      ruleMonthId: ruleMonthId || draft.ruleMonthId,
      ruleDay,
      timePolicy: event.timePolicy,
      boundsEndYear: boundsEnd ? String(boundsEnd.year) : "",
      boundsEndMonthId: boundsEnd ? boundsEnd.monthId : "",
      boundsEndDay: boundsEnd ? String(boundsEnd.day) : ""
    };
  }
  async loadEventById(eventId) {
    const known = [
      ...this.state.calendarState.upcomingEvents,
      ...this.state.calendarState.triggeredEvents,
      ...this.state.managerUiState.agendaItems
    ].find((event) => event.id === eventId);
    if (known) {
      return known;
    }
    for (const calendar of this.state.calendarState.calendars) {
      const events = await this.eventRepo.listEvents(calendar.id);
      const found = events.find((event) => event.id === eventId);
      if (found) {
        return found;
      }
    }
    return null;
  }
  generateEventId() {
    this.eventIdCounter += 1;
    return `event-${this.eventIdCounter}`;
  }
  getDayOfYearForMonth(schema, monthId, day) {
    const index = getMonthIndex(schema, monthId);
    if (index === -1) {
      return day;
    }
    let total = 0;
    for (let i = 0; i < index; i += 1) {
      total += schema.months[i]?.length ?? 0;
    }
    return total + day;
  }
  async handleEventBulkAction(action, ids) {
    const selection = ids && ids.length ? Array.from(ids) : [...this.state.eventsUiState.bulkSelection];
    const unique = Array.from(new Set(selection));
    if (unique.length === 0) {
      return;
    }
    if (action === "export") {
      const entries = this.phenomenaDefinitions.filter((item) => unique.includes(item.id));
      const payload = formatPhenomenaExport(entries);
      this.setState((next) => {
        next.eventsUiState = {
          ...next.eventsUiState,
          lastExportPayload: payload,
          error: void 0
        };
      });
      return;
    }
    this.setState((next) => {
      next.eventsUiState = {
        ...next.eventsUiState,
        isLoading: true,
        error: void 0
      };
    });
    try {
      for (const id of unique) {
        await this.phenomenonRepo.deletePhenomenon(id);
      }
      this.phenomenaDefinitions = this.phenomenaDefinitions.filter((item) => !unique.includes(item.id));
      this.rebuildPhenomenaListing(null, {
        bulkSelection: [],
        exportPayload: this.state.eventsUiState.lastExportPayload ?? void 0,
        importSummary: this.state.eventsUiState.importSummary ?? null
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : "Bulk-Aktion fehlgeschlagen";
      const code = error instanceof AlmanacRepositoryError ? error.code : "io_error";
      reportAlmanacGatewayIssue({
        operation: "stateMachine.phenomenon.bulk",
        scope: "phenomenon",
        code,
        error,
        context: { ids: unique }
      });
      if (error instanceof AlmanacRepositoryError && error.code === "phenomenon_conflict") {
        emitAlmanacEvent({
          type: "calendar.event.conflict",
          code: "phenomenon",
          message,
          context: error.details
        });
      }
      this.setState((next) => {
        next.eventsUiState = {
          ...next.eventsUiState,
          error: message
        };
      });
    } finally {
      this.setState((next) => {
        next.eventsUiState = {
          ...next.eventsUiState,
          isLoading: false
        };
      });
    }
  }
  handleEventExportCleared() {
    this.setState((next) => {
      next.eventsUiState = {
        ...next.eventsUiState,
        lastExportPayload: void 0
      };
    });
  }
  handleEventImportRequested() {
    this.setState((next) => {
      next.eventsUiState = {
        ...next.eventsUiState,
        isImportDialogOpen: true,
        importError: void 0
      };
    });
  }
  handleEventImportCancelled() {
    this.setState((next) => {
      next.eventsUiState = {
        ...next.eventsUiState,
        isImportDialogOpen: false,
        importError: void 0
      };
    });
  }
  async handleEventImportSubmitted(payload) {
    this.setState((next) => {
      next.eventsUiState = {
        ...next.eventsUiState,
        isLoading: true,
        importError: void 0
      };
    });
    try {
      const parsed = parsePhenomenaImport(payload);
      let imported = 0;
      for (const entry of parsed) {
        const stored = await this.phenomenonRepo.upsertPhenomenon(entry);
        const normalised = this.toPhenomenon(stored);
        this.phenomenaDefinitions = [
          ...this.phenomenaDefinitions.filter((item) => item.id !== normalised.id),
          normalised
        ];
        imported += 1;
      }
      const summary = { imported, failed: 0 };
      this.rebuildPhenomenaListing(null, {
        bulkSelection: this.state.eventsUiState.bulkSelection,
        exportPayload: this.state.eventsUiState.lastExportPayload ?? void 0,
        importSummary: summary
      });
      this.setState((next) => {
        next.eventsUiState = {
          ...next.eventsUiState,
          isImportDialogOpen: false
        };
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : "Import fehlgeschlagen";
      const code = error instanceof AlmanacRepositoryError ? error.code : "io_error";
      reportAlmanacGatewayIssue({
        operation: "stateMachine.phenomenon.import",
        scope: "phenomenon",
        code,
        error,
        context: { imported: payload.slice(0, 32) }
      });
      if (error instanceof AlmanacRepositoryError && error.code === "phenomenon_conflict") {
        emitAlmanacEvent({
          type: "calendar.event.conflict",
          code: "phenomenon",
          message,
          context: error.details
        });
      }
      this.setState((next) => {
        next.eventsUiState = {
          ...next.eventsUiState,
          importError: message
        };
      });
    } finally {
      this.setState((next) => {
        next.eventsUiState = {
          ...next.eventsUiState,
          isLoading: false
        };
      });
    }
  }
  handleManagerSelectionChanged(selection) {
    const unique = Array.from(new Set(selection));
    this.setState((draft) => {
      draft.managerUiState = {
        ...draft.managerUiState,
        selection: unique
      };
    });
  }
  handleCreateFormUpdated(field, value) {
    const numericFields = [
      "daysPerWeek",
      "monthCount",
      "monthLength",
      "hoursPerDay",
      "minutesPerHour",
      "minuteStep",
      "epochYear",
      "epochDay"
    ];
    let nextValue = value;
    if (field === "id") {
      nextValue = this.slugify(value);
    } else if (numericFields.includes(field)) {
      nextValue = value.replace(/[^0-9]/g, "");
    }
    this.setState((draft) => {
      draft.managerUiState = {
        ...draft.managerUiState,
        createDraft: {
          ...draft.managerUiState.createDraft,
          [field]: nextValue
        },
        createErrors: []
      };
    });
  }
  async handleCalendarCreate() {
    const draft = this.state.managerUiState.createDraft;
    this.setState((draftState) => {
      draftState.managerUiState = {
        ...draftState.managerUiState,
        isCreating: true,
        createErrors: []
      };
    });
    const { schema, errors } = await this.buildCalendarSchemaFromDraft(draft);
    if (!schema || errors.length > 0) {
      this.setState((draftState) => {
        draftState.managerUiState = {
          ...draftState.managerUiState,
          isCreating: false,
          createErrors: errors.length > 0 ? errors : ["Unable to create calendar with current data."]
        };
      });
      return;
    }
    try {
      const initialTimestamp = createDayTimestamp(
        schema.id,
        schema.epoch.year,
        schema.epoch.monthId,
        schema.epoch.day
      );
      await this.calendarRepo.createCalendar(schema);
      await this.gateway.setActiveCalendar(schema.id, { initialTimestamp });
      await this.refreshCalendarData();
      const currentTimestamp = this.state.calendarState.currentTimestamp ?? initialTimestamp;
      this.setState((draftState) => {
        draftState.managerUiState = {
          ...draftState.managerUiState,
          isCreating: false,
          createErrors: [],
          createDraft: createDefaultCalendarDraft(),
          anchorTimestamp: currentTimestamp,
          selection: []
        };
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : "Failed to create calendar";
      const code = isCalendarGatewayError(error) ? error.code : "io_error";
      reportAlmanacGatewayIssue({
        operation: "stateMachine.createCalendar",
        scope: "calendar",
        code,
        error,
        context: { calendarId: schema.id }
      });
      this.setState((draftState) => {
        draftState.managerUiState = {
          ...draftState.managerUiState,
          isCreating: false,
          createErrors: [message]
        };
      });
    }
  }
  handleCalendarEditRequested(calendarId) {
    const schema = this.getCalendarSchema(calendarId);
    if (!schema) {
      return;
    }
    const draft = createCalendarDraftFromSchema(schema);
    const warnings = this.computeEditWarnings(schema, draft);
    this.setState((draftState) => {
      const current = draftState.managerUiState.editStateById[calendarId];
      const nextState = {
        draft,
        errors: [],
        warnings,
        isSaving: false
      };
      draftState.managerUiState = {
        ...draftState.managerUiState,
        editStateById: {
          ...draftState.managerUiState.editStateById,
          [calendarId]: current ? { ...current, ...nextState } : nextState
        },
        conflictDialog: draftState.managerUiState.conflictDialog?.calendarId === calendarId ? null : draftState.managerUiState.conflictDialog
      };
    });
  }
  handleCalendarEditCancelled(calendarId) {
    this.setState((draft) => {
      const { [calendarId]: _removed, ...rest } = draft.managerUiState.editStateById;
      draft.managerUiState = {
        ...draft.managerUiState,
        editStateById: rest
      };
    });
  }
  handleCalendarEditFormUpdated(calendarId, field, value) {
    const editableFields = [
      "name",
      "description",
      "hoursPerDay",
      "minutesPerHour",
      "minuteStep"
    ];
    if (!editableFields.includes(field)) {
      return;
    }
    const existing = this.state.managerUiState.editStateById[calendarId];
    if (!existing) {
      return;
    }
    const numericFields = ["hoursPerDay", "minutesPerHour", "minuteStep"];
    let nextValue = value;
    if (numericFields.includes(field)) {
      nextValue = value.replace(/[^0-9]/g, "");
    }
    const nextDraft = {
      ...existing.draft,
      [field]: nextValue
    };
    const schema = this.getCalendarSchema(calendarId);
    const warnings = schema ? this.computeEditWarnings(schema, nextDraft) : [];
    this.setState((draftState) => {
      const current = draftState.managerUiState.editStateById[calendarId];
      if (!current) {
        return;
      }
      draftState.managerUiState = {
        ...draftState.managerUiState,
        editStateById: {
          ...draftState.managerUiState.editStateById,
          [calendarId]: {
            ...current,
            draft: nextDraft,
            warnings,
            errors: []
          }
        }
      };
    });
  }
  async handleCalendarUpdate(calendarId) {
    const editState = this.state.managerUiState.editStateById[calendarId];
    const schema = this.getCalendarSchema(calendarId);
    if (!editState || !schema) {
      return;
    }
    const errors = [];
    const trimmedName = editState.draft.name.trim();
    if (!trimmedName) {
      errors.push("Name is required.");
    }
    const description = editState.draft.description.trim();
    const hoursPerDay = Number(editState.draft.hoursPerDay || String(schema.hoursPerDay ?? 24));
    const minutesPerHour = Number(editState.draft.minutesPerHour || String(schema.minutesPerHour ?? 60));
    const minuteStep = Number(editState.draft.minuteStep || String(schema.minuteStep ?? 1));
    if (!Number.isFinite(hoursPerDay) || hoursPerDay < 1) {
      errors.push("Hours per day must be at least 1.");
    }
    if (!Number.isFinite(minutesPerHour) || minutesPerHour < 1) {
      errors.push("Minutes per hour must be at least 1.");
    }
    if (!Number.isFinite(minuteStep) || minuteStep < 1) {
      errors.push("Minute step must be at least 1.");
    } else if (minuteStep > minutesPerHour) {
      errors.push("Minute step must not exceed minutes per hour.");
    }
    if (errors.length > 0) {
      this.setState((draftState) => {
        const current = draftState.managerUiState.editStateById[calendarId];
        if (!current) {
          return;
        }
        draftState.managerUiState = {
          ...draftState.managerUiState,
          editStateById: {
            ...draftState.managerUiState.editStateById,
            [calendarId]: { ...current, errors, isSaving: false }
          }
        };
      });
      return;
    }
    const updates = {};
    if (trimmedName !== schema.name) {
      updates.name = trimmedName;
    }
    if ((schema.description ?? "") !== description) {
      updates.description = description || void 0;
    }
    const safeHoursPerDay = Math.max(1, Math.floor(hoursPerDay));
    const safeMinutesPerHour = Math.max(1, Math.floor(minutesPerHour));
    const safeMinuteStep = Math.max(1, Math.floor(minuteStep));
    if ((schema.hoursPerDay ?? 24) !== safeHoursPerDay) {
      updates.hoursPerDay = safeHoursPerDay;
    }
    if ((schema.minutesPerHour ?? 60) !== safeMinutesPerHour) {
      updates.minutesPerHour = safeMinutesPerHour;
    }
    if ((schema.minuteStep ?? 1) !== safeMinuteStep) {
      updates.minuteStep = safeMinuteStep;
    }
    if (Object.keys(updates).length === 0) {
      const warnings = this.computeEditWarnings(schema, editState.draft);
      this.setState((draftState) => {
        const current = draftState.managerUiState.editStateById[calendarId];
        if (!current) {
          return;
        }
        draftState.managerUiState = {
          ...draftState.managerUiState,
          editStateById: {
            ...draftState.managerUiState.editStateById,
            [calendarId]: { ...current, warnings, errors: [], isSaving: false }
          }
        };
      });
      return;
    }
    const conflicts = await this.detectCalendarConflicts(calendarId, updates);
    if (conflicts.length > 0) {
      this.setState((draftState) => {
        const current = draftState.managerUiState.editStateById[calendarId];
        if (!current) {
          return;
        }
        const conflictDialog = {
          calendarId,
          kind: "update",
          message: "Existing events conflict with the new time definition.",
          details: conflicts
        };
        draftState.managerUiState = {
          ...draftState.managerUiState,
          conflictDialog,
          editStateById: {
            ...draftState.managerUiState.editStateById,
            [calendarId]: { ...current, errors: conflicts, isSaving: false }
          }
        };
      });
      return;
    }
    this.setState((draftState) => {
      const current = draftState.managerUiState.editStateById[calendarId];
      if (!current) {
        return;
      }
      draftState.managerUiState = {
        ...draftState.managerUiState,
        conflictDialog: draftState.managerUiState.conflictDialog?.calendarId === calendarId ? null : draftState.managerUiState.conflictDialog,
        editStateById: {
          ...draftState.managerUiState.editStateById,
          [calendarId]: { ...current, errors: [], isSaving: true }
        }
      };
    });
    try {
      await this.calendarRepo.updateCalendar(calendarId, updates);
      await this.refreshCalendarData();
      const updatedSchema = this.getCalendarSchema(calendarId) ?? schema;
      const nextDraft = createCalendarDraftFromSchema(updatedSchema);
      const warnings = this.computeEditWarnings(updatedSchema, nextDraft);
      this.setState((draftState) => {
        const current = draftState.managerUiState.editStateById[calendarId];
        if (!current) {
          return;
        }
        draftState.managerUiState = {
          ...draftState.managerUiState,
          editStateById: {
            ...draftState.managerUiState.editStateById,
            [calendarId]: {
              draft: nextDraft,
              warnings,
              errors: [],
              isSaving: false
            }
          }
        };
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : "Failed to update calendar";
      const code = isCalendarGatewayError(error) ? error.code : "io_error";
      reportAlmanacGatewayIssue({
        operation: "stateMachine.updateCalendar",
        scope: "calendar",
        code,
        error,
        context: { calendarId }
      });
      this.setState((draftState) => {
        const current = draftState.managerUiState.editStateById[calendarId];
        if (!current) {
          return;
        }
        draftState.managerUiState = {
          ...draftState.managerUiState,
          editStateById: {
            ...draftState.managerUiState.editStateById,
            [calendarId]: { ...current, errors: [message], isSaving: false }
          }
        };
      });
    }
  }
  async handleCalendarDeleteRequested(calendarId) {
    const schema = this.getCalendarSchema(calendarId);
    if (!schema) {
      return;
    }
    const linkedPhenomena = this.phenomenaDefinitions.filter((phenomenon) => phenomenon.appliesToCalendarIds.includes(calendarId)).map((phenomenon) => phenomenon.name);
    const linkedTravelIds = await this.collectTravelDefaultIds(calendarId);
    const requiresFallback = this.state.calendarState.defaultCalendarId === calendarId;
    this.setState((draft) => {
      draft.managerUiState = {
        ...draft.managerUiState,
        deleteDialog: {
          calendarId,
          calendarName: schema.name,
          requiresFallback,
          linkedTravelIds,
          linkedPhenomena,
          isDeleting: false,
          error: void 0
        }
      };
    });
  }
  handleCalendarDeleteCancelled() {
    this.setState((draft) => {
      draft.managerUiState = {
        ...draft.managerUiState,
        deleteDialog: null
      };
    });
  }
  async handleCalendarDeleteConfirmed(calendarId) {
    const dialog = this.state.managerUiState.deleteDialog;
    if (!dialog || dialog.calendarId !== calendarId) {
      return;
    }
    if (dialog.linkedPhenomena.length > 0) {
      const message = "Calendar is linked to phenomena and cannot be deleted.";
      this.setState((draft) => {
        draft.managerUiState = {
          ...draft.managerUiState,
          conflictDialog: {
            calendarId,
            kind: "delete",
            message,
            details: dialog.linkedPhenomena
          },
          deleteDialog: { ...dialog, error: message }
        };
      });
      return;
    }
    const fallbackCandidate = this.state.calendarState.calendars.find((schema) => schema.id !== calendarId)?.id ?? null;
    if (dialog.requiresFallback && !fallbackCandidate) {
      const message = "Cannot delete the last remaining calendar.";
      this.setState((draft) => {
        draft.managerUiState = {
          ...draft.managerUiState,
          conflictDialog: {
            calendarId,
            kind: "delete",
            message,
            details: []
          },
          deleteDialog: { ...dialog, error: message }
        };
      });
      return;
    }
    this.setState((draft) => {
      draft.managerUiState = {
        ...draft.managerUiState,
        deleteDialog: { ...dialog, isDeleting: true, error: void 0 }
      };
    });
    try {
      const defaultsRepo = this.getCalendarDefaultsRepository();
      if (defaultsRepo) {
        for (const travelId of dialog.linkedTravelIds) {
          await defaultsRepo.clearTravelDefault(travelId);
        }
      }
      await this.calendarRepo.deleteCalendar(calendarId);
      if (dialog.requiresFallback && fallbackCandidate) {
        await this.gateway.setDefaultCalendar(fallbackCandidate, { scope: "global" });
      }
      if (this.state.calendarState.activeCalendarId === calendarId && fallbackCandidate) {
        await this.gateway.setActiveCalendar(fallbackCandidate);
      }
      await this.refreshCalendarData();
      this.setState((draft) => {
        const { [calendarId]: _removed, ...rest } = draft.managerUiState.editStateById;
        draft.managerUiState = {
          ...draft.managerUiState,
          deleteDialog: null,
          conflictDialog: null,
          selection: draft.managerUiState.selection.filter((id) => id !== calendarId),
          editStateById: rest
        };
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : "Failed to delete calendar";
      const code = isCalendarGatewayError(error) ? error.code : "io_error";
      reportAlmanacGatewayIssue({
        operation: "stateMachine.deleteCalendar",
        scope: "calendar",
        code,
        error,
        context: { calendarId }
      });
      this.setState((draft) => {
        const currentDialog = draft.managerUiState.deleteDialog;
        if (!currentDialog || currentDialog.calendarId !== calendarId) {
          return;
        }
        draft.managerUiState = {
          ...draft.managerUiState,
          deleteDialog: { ...currentDialog, isDeleting: false, error: message }
        };
      });
    }
  }
  handleConflictDismissed() {
    this.setState((draft) => {
      draft.managerUiState = {
        ...draft.managerUiState,
        conflictDialog: null
      };
    });
  }
  async handleCalendarSelect(calendarId) {
    if (calendarId === this.state.calendarState.activeCalendarId) {
      return;
    }
    const previousActive = this.state.calendarState.activeCalendarId;
    this.setState((draft) => {
      draft.calendarState = {
        ...draft.calendarState,
        activeCalendarId: calendarId,
        isPersisting: true
      };
      draft.almanacUiState = {
        ...draft.almanacUiState,
        error: void 0
      };
    });
    try {
      const existingTimestamp = this.state.calendarState.currentTimestamp;
      const timestamp = existingTimestamp?.calendarId === calendarId ? existingTimestamp : void 0;
      await this.gateway.setActiveCalendar(calendarId, { initialTimestamp: timestamp ?? void 0 });
      await this.refreshCalendarData();
      const currentTimestamp = this.state.calendarState.currentTimestamp;
      if (currentTimestamp) {
        this.setState((draft) => {
          draft.managerUiState = {
            ...draft.managerUiState,
            anchorTimestamp: currentTimestamp,
            agendaItems: this.collectAgendaItems(currentTimestamp, draft.calendarViewState.zoom),
            jumpPreview: []
          };
        });
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : "Kalender konnte nicht gesetzt werden";
      const code = isCalendarGatewayError(error) ? error.code : "io_error";
      reportAlmanacGatewayIssue({
        operation: "stateMachine.setActiveCalendar",
        scope: this.travelId ? "travel" : "calendar",
        code,
        error,
        context: { calendarId, travelId: this.travelId }
      });
      this.setState((draft) => {
        draft.calendarState = {
          ...draft.calendarState,
          activeCalendarId: previousActive ?? null,
          isPersisting: false
        };
        draft.almanacUiState = {
          ...draft.almanacUiState,
          error: message
        };
      });
    }
  }
  async handleCalendarDefault(calendarId) {
    const previousDefault = this.state.calendarState.defaultCalendarId ?? null;
    this.setState((draft) => {
      draft.calendarState = {
        ...draft.calendarState,
        isPersisting: true
      };
      draft.almanacUiState = {
        ...draft.almanacUiState,
        error: void 0
      };
    });
    try {
      await this.gateway.setDefaultCalendar(calendarId, { scope: "global" });
      await this.refreshCalendarData();
      this.setState((draft) => {
        draft.calendarState = {
          ...draft.calendarState,
          defaultCalendarId: calendarId,
          calendars: draft.calendarState.calendars.map(
            (schema) => schema.id === calendarId ? { ...schema, isDefaultGlobal: true } : { ...schema, isDefaultGlobal: false }
          )
        };
      });
      emitAlmanacEvent({
        type: "calendar.default.change",
        scope: "global",
        calendarId,
        previousDefaultId: previousDefault,
        travelId: this.travelId,
        wasAutoSelected: false
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : "Standardkalender konnte nicht aktualisiert werden";
      const code = isCalendarGatewayError(error) ? error.code : "io_error";
      reportAlmanacGatewayIssue({
        operation: "stateMachine.setDefault",
        scope: "default",
        code,
        error,
        context: { calendarId, travelId: this.travelId }
      });
      this.setState((draft) => {
        draft.calendarState = {
          ...draft.calendarState,
          isPersisting: false
        };
        draft.almanacUiState = {
          ...draft.almanacUiState,
          error: message
        };
      });
    }
  }
  async handleTravelLeafMounted(travelId) {
    this.travelId = travelId;
    this.setState((draft) => {
      draft.travelLeafState = {
        ...draft.travelLeafState,
        travelId,
        visible: true,
        isLoading: true,
        error: void 0
      };
    });
    try {
      const prefs = await this.gateway.getTravelLeafPreferences(travelId);
      this.travelLeafPreferences = prefs;
      this.setState((draft) => {
        draft.travelLeafState = {
          ...draft.travelLeafState,
          travelId,
          visible: true,
          mode: prefs?.mode ?? draft.travelLeafState.mode,
          currentTimestamp: draft.calendarState.currentTimestamp,
          minuteStep: draft.calendarState.timeDefinition?.minuteStep ?? draft.travelLeafState.minuteStep,
          isLoading: false,
          error: void 0
        };
      });
      await this.persistTravelLeafPreferences({
        visible: true,
        mode: this.state.travelLeafState.mode,
        lastViewedTimestamp: this.state.calendarState.currentTimestamp ?? null
      });
      emitAlmanacEvent({
        type: "calendar.travel.lifecycle",
        phase: "mount",
        travelId,
        visible: true,
        mode: this.state.travelLeafState.mode,
        timestamp: this.state.calendarState.currentTimestamp
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : "Travel-Leaf konnte nicht initialisiert werden";
      const code = isCalendarGatewayError(error) ? error.code : "io_error";
      reportAlmanacGatewayIssue({
        operation: "stateMachine.travelLeaf.mount",
        scope: "travel",
        code,
        error,
        context: { travelId }
      });
      this.setState((draft) => {
        draft.travelLeafState = {
          ...draft.travelLeafState,
          isLoading: false,
          error: message
        };
      });
    }
  }
  async handleTravelModeChanged(mode) {
    if (mode === this.state.travelLeafState.mode) {
      return;
    }
    this.setState((draft) => {
      draft.travelLeafState = {
        ...draft.travelLeafState,
        mode
      };
    });
    emitAlmanacEvent({
      type: "calendar.travel.lifecycle",
      phase: "mode-change",
      travelId: this.state.travelLeafState.travelId,
      visible: this.state.travelLeafState.visible,
      mode,
      timestamp: this.state.travelLeafState.currentTimestamp
    });
    await this.persistTravelLeafPreferences({ mode });
  }
  async handleTimeAdvance(amount, unit, source = "global") {
    const activeCalendarId = this.state.calendarState.activeCalendarId;
    if (!activeCalendarId) {
      return;
    }
    this.setState((draft) => {
      draft.calendarState = {
        ...draft.calendarState,
        lastAdvanceStep: { amount, unit }
      };
      if (source === "global") {
        draft.almanacUiState = {
          ...draft.almanacUiState,
          isLoading: true,
          error: void 0
        };
      } else {
        draft.travelLeafState = {
          ...draft.travelLeafState,
          isLoading: true,
          error: void 0,
          lastQuickStep: { amount, unit }
        };
      }
    });
    try {
      const advanceOptions = this.travelId ? {
        travelId: this.travelId,
        hookContext: { scope: "travel", travelId: this.travelId, reason: "advance" }
      } : { hookContext: { scope: "global", reason: "advance" } };
      const result = await this.gateway.advanceTimeBy(amount, unit, advanceOptions);
      const schema = this.getCalendarSchema(activeCalendarId);
      let upcoming = this.state.calendarState.upcomingEvents;
      if (schema) {
        upcoming = await this.eventRepo.getUpcomingEvents(
          activeCalendarId,
          schema,
          result.timestamp,
          5
        );
      }
      if (this.phenomenaDefinitions.length === 0) {
        const freshPhenomena = await this.phenomenonRepo.listPhenomena();
        this.phenomenaDefinitions = freshPhenomena.map((item) => this.toPhenomenon(item));
      }
      this.phenomenaSource = this.buildPhenomenonViewModels(
        this.phenomenaDefinitions,
        this.state.calendarState.calendars,
        activeCalendarId,
        result.timestamp
      );
      const filters = this.state.eventsUiState.filters;
      const filteredPhenomena = this.applyPhenomenaFilters(filters);
      const availableCategories = getUniqueCategories(this.phenomenaSource);
      const filterCount = filters.categories.length + filters.calendarIds.length;
      const calendars = this.state.calendarState.calendars;
      const currentSelectedId = this.state.eventsUiState.selectedPhenomenonId ?? null;
      let nextSelectedId = null;
      let nextDetail = null;
      if (currentSelectedId && filteredPhenomena.some((item) => item.id === currentSelectedId)) {
        nextDetail = this.buildPhenomenonDetailForId(currentSelectedId, calendars, result.timestamp);
        nextSelectedId = nextDetail ? currentSelectedId : null;
      }
      if (!nextSelectedId && filteredPhenomena.length > 0) {
        const firstId = filteredPhenomena[0].id;
        nextDetail = this.buildPhenomenonDetailForId(firstId, calendars, result.timestamp);
        nextSelectedId = nextDetail ? firstId : null;
      }
      const mapMarkers = this.buildPhenomenonMapMarkers(filteredPhenomena, calendars);
      this.setState((draft) => {
        const mergedTriggered = [
          ...result.triggeredEvents,
          ...draft.calendarState.triggeredEvents
        ].slice(0, MAX_TRIGGERED_EVENTS);
        const mergedPhenomena = [
          ...result.triggeredPhenomena,
          ...draft.calendarState.triggeredPhenomena
        ].slice(0, MAX_TRIGGERED_PHENOMENA);
        draft.calendarState = {
          ...draft.calendarState,
          currentTimestamp: result.timestamp,
          upcomingEvents: upcoming,
          triggeredEvents: mergedTriggered,
          upcomingPhenomena: result.upcomingPhenomena,
          triggeredPhenomena: mergedPhenomena
        };
        if (source === "global") {
          draft.almanacUiState = {
            ...draft.almanacUiState,
            isLoading: false
          };
        }
        const minuteStep = draft.calendarState.timeDefinition?.minuteStep ?? draft.travelLeafState.minuteStep;
        draft.travelLeafState = {
          ...draft.travelLeafState,
          travelId: this.travelId,
          currentTimestamp: result.timestamp,
          minuteStep,
          ...source === "travel" ? { isLoading: false, error: void 0, lastQuickStep: { amount, unit } } : {}
        };
        draft.eventsUiState = {
          ...draft.eventsUiState,
          filterCount,
          filters: { ...filters },
          availableCategories,
          mapMarkers,
          phenomena: filteredPhenomena,
          selectedPhenomenonId: nextSelectedId,
          selectedPhenomenonDetail: nextDetail,
          isDetailLoading: false
        };
        draft.managerUiState = {
          ...draft.managerUiState,
          anchorTimestamp: result.timestamp,
          agendaItems: this.collectAgendaItems(result.timestamp, draft.calendarViewState.zoom, upcoming),
          jumpPreview: []
        };
      });
      await this.cartographerGateway.notifyTravelPanel({
        travelId: this.travelId,
        currentTimestamp: result.timestamp,
        triggeredEvents: result.triggeredEvents,
        triggeredPhenomena: result.triggeredPhenomena,
        skippedEvents: [],
        skippedPhenomena: [],
        lastAdvanceStep: { amount, unit },
        reason: "advance"
      });
      emitAlmanacEvent({
        type: "calendar.time.advance",
        scope: source,
        reason: "advance",
        unit,
        amount,
        triggeredEvents: result.triggeredEvents.length,
        triggeredPhenomena: result.triggeredPhenomena.length,
        skippedEvents: 0,
        travelId: source === "travel" ? this.travelId : null,
        timestamp: result.timestamp
      });
      void this.persistPreferences({
        lastSelectedPhenomenonId: nextSelectedId ?? void 0
      });
      if (this.travelId) {
        void this.persistTravelLeafPreferences({ lastViewedTimestamp: result.timestamp });
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : "Zeitfortschritt fehlgeschlagen";
      const code = error instanceof AlmanacRepositoryError ? error.code : isCalendarGatewayError(error) ? error.code : "io_error";
      reportAlmanacGatewayIssue({
        operation: "stateMachine.timeAdvance",
        scope: source === "travel" ? "travel" : "calendar",
        code,
        error,
        context: { amount, unit, travelId: this.travelId }
      });
      if (error instanceof AlmanacRepositoryError && error.code === "phenomenon_conflict") {
        emitAlmanacEvent({
          type: "calendar.event.conflict",
          code: "phenomenon",
          message,
          context: error.details
        });
      }
      this.setState((draft) => {
        if (source === "global") {
          draft.almanacUiState = {
            ...draft.almanacUiState,
            isLoading: false,
            error: message
          };
        } else {
          draft.travelLeafState = {
            ...draft.travelLeafState,
            isLoading: false,
            error: message
          };
        }
      });
    }
  }
  async handleTimeJumpPreview(target) {
    const activeCalendarId = this.state.calendarState.activeCalendarId;
    if (!activeCalendarId) {
      this.clearJumpPreview();
      return;
    }
    if (target.calendarId !== activeCalendarId) {
      target = { ...target, calendarId: activeCalendarId };
    }
    const schema = this.getCalendarSchema(activeCalendarId) ?? await this.calendarRepo.getCalendar(activeCalendarId);
    const currentTimestamp = this.state.calendarState.currentTimestamp;
    if (!schema || !currentTimestamp) {
      this.clearJumpPreview();
      return;
    }
    const preview = await this.eventRepo.getEventsInRange(activeCalendarId, schema, currentTimestamp, target);
    this.setState((draft) => {
      draft.managerUiState = {
        ...draft.managerUiState,
        jumpPreview: preview
      };
    });
  }
  async handleTimeJump(target) {
    const activeCalendarId = this.state.calendarState.activeCalendarId;
    if (!activeCalendarId) {
      return;
    }
    if (target.calendarId !== activeCalendarId) {
      target = { ...target, calendarId: activeCalendarId };
    }
    this.setState((draft) => {
      draft.almanacUiState = {
        ...draft.almanacUiState,
        isLoading: true,
        error: void 0
      };
    });
    try {
      let schema = this.getCalendarSchema(activeCalendarId) ?? await this.calendarRepo.getCalendar(activeCalendarId);
      const currentTimestamp = this.state.calendarState.currentTimestamp;
      let preview = [];
      if (schema && currentTimestamp) {
        preview = await this.eventRepo.getEventsInRange(activeCalendarId, schema, currentTimestamp, target);
      }
      const setOptions = this.travelId ? { travelId: this.travelId } : void 0;
      await this.gateway.setCurrentTimestamp(target, setOptions);
      const snapshotAfterJump = await this.gateway.loadSnapshot(
        this.travelId ? { travelId: this.travelId } : void 0
      );
      const upcoming = snapshotAfterJump.upcomingEvents;
      const upcomingPhenomena = snapshotAfterJump.upcomingPhenomena;
      if (this.phenomenaDefinitions.length === 0) {
        const freshPhenomena = await this.phenomenonRepo.listPhenomena();
        this.phenomenaDefinitions = freshPhenomena.map((item) => this.toPhenomenon(item));
      }
      this.phenomenaSource = this.buildPhenomenonViewModels(
        this.phenomenaDefinitions,
        this.state.calendarState.calendars,
        activeCalendarId,
        target
      );
      const filters = this.state.eventsUiState.filters;
      const filteredPhenomena = this.applyPhenomenaFilters(filters);
      const availableCategories = getUniqueCategories(this.phenomenaSource);
      const filterCount = filters.categories.length + filters.calendarIds.length;
      const calendars = this.state.calendarState.calendars;
      const currentSelectedId = this.state.eventsUiState.selectedPhenomenonId ?? null;
      let nextSelectedId = null;
      let nextDetail = null;
      if (currentSelectedId && filteredPhenomena.some((item) => item.id === currentSelectedId)) {
        nextDetail = this.buildPhenomenonDetailForId(currentSelectedId, calendars, target);
        nextSelectedId = nextDetail ? currentSelectedId : null;
      }
      if (!nextSelectedId && filteredPhenomena.length > 0) {
        const firstId = filteredPhenomena[0].id;
        nextDetail = this.buildPhenomenonDetailForId(firstId, calendars, target);
        nextSelectedId = nextDetail ? firstId : null;
      }
      const mapMarkers = this.buildPhenomenonMapMarkers(filteredPhenomena, calendars);
      this.setState((draft) => {
        draft.calendarState = {
          ...draft.calendarState,
          currentTimestamp: target,
          upcomingEvents: upcoming,
          triggeredEvents: preview,
          upcomingPhenomena
        };
        draft.almanacUiState = {
          ...draft.almanacUiState,
          isLoading: false
        };
        draft.eventsUiState = {
          ...draft.eventsUiState,
          filterCount,
          filters: { ...filters },
          availableCategories,
          mapMarkers,
          phenomena: filteredPhenomena,
          selectedPhenomenonId: nextSelectedId,
          selectedPhenomenonDetail: nextDetail,
          isDetailLoading: false
        };
        draft.managerUiState = {
          ...draft.managerUiState,
          anchorTimestamp: target,
          agendaItems: this.collectAgendaItems(target, draft.calendarViewState.zoom, upcoming),
          jumpPreview: []
        };
      });
      await this.cartographerGateway.notifyTravelPanel({
        travelId: this.travelId,
        currentTimestamp: target,
        triggeredEvents: [],
        triggeredPhenomena: [],
        skippedEvents: preview,
        skippedPhenomena: [],
        reason: "jump"
      });
      emitAlmanacEvent({
        type: "calendar.time.advance",
        scope: this.travelId ? "travel" : "global",
        reason: "jump",
        unit: "day",
        amount: 0,
        triggeredEvents: 0,
        triggeredPhenomena: 0,
        skippedEvents: preview.length,
        travelId: this.travelId,
        timestamp: target
      });
      void this.persistPreferences({
        lastSelectedPhenomenonId: nextSelectedId ?? void 0
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : "Zeit konnte nicht gesetzt werden";
      const code = error instanceof AlmanacRepositoryError ? error.code : isCalendarGatewayError(error) ? error.code : "io_error";
      reportAlmanacGatewayIssue({
        operation: "stateMachine.timeJump",
        scope: this.travelId ? "travel" : "calendar",
        code,
        error,
        context: { travelId: this.travelId }
      });
      if (error instanceof AlmanacRepositoryError && error.code === "phenomenon_conflict") {
        emitAlmanacEvent({
          type: "calendar.event.conflict",
          code: "phenomenon",
          message,
          context: error.details
        });
      }
      this.setState((draft) => {
        draft.almanacUiState = {
          ...draft.almanacUiState,
          isLoading: false,
          error: message
        };
      });
    }
  }
  getCalendarSchema(id) {
    return this.state.calendarState.calendars.find((calendar) => calendar.id === id) ?? null;
  }
  buildPhenomenonViewModels(phenomena, calendars, activeCalendarId, referenceTimestamp) {
    const calendarMap = new Map(calendars.map((schema) => [schema.id, schema]));
    return phenomena.map((phenomenon) => {
      const linkedIdsBase = phenomenon.visibility === "all_calendars" ? calendars.map((schema) => schema.id) : phenomenon.appliesToCalendarIds;
      const linkedCalendars = Array.from(new Set(linkedIdsBase)).filter((id) => calendarMap.has(id));
      const occurrences = linkedCalendars.flatMap((calendarId) => {
        const schema = calendarMap.get(calendarId);
        if (!schema) return [];
        const anchor = referenceTimestamp && referenceTimestamp.calendarId === calendarId ? referenceTimestamp : createDayTimestamp(
          calendarId,
          schema.epoch.year,
          schema.epoch.monthId,
          schema.epoch.day
        );
        try {
          const occurrence = computeNextPhenomenonOccurrence(
            phenomenon,
            schema,
            calendarId,
            anchor,
            { includeStart: true }
          );
          if (!occurrence) {
            return [];
          }
          const monthName = getMonthById(schema, occurrence.timestamp.monthId)?.name ?? occurrence.timestamp.monthId;
          const label = `${formatTimestamp(occurrence.timestamp, monthName)} \u2022 ${schema.name}`;
          const monthIndex = Math.max(0, getMonthIndex(schema, occurrence.timestamp.monthId));
          const sortKey = [
            occurrence.timestamp.year.toString().padStart(6, "0"),
            monthIndex.toString().padStart(2, "0"),
            occurrence.timestamp.day.toString().padStart(2, "0"),
            String(occurrence.timestamp.hour ?? 0).padStart(2, "0"),
            String(occurrence.timestamp.minute ?? 0).padStart(2, "0")
          ].join("-");
          return [{ label, sortKey }];
        } catch {
          return [];
        }
      });
      occurrences.sort((a, b) => a.sortKey.localeCompare(b.sortKey));
      return {
        id: phenomenon.id,
        title: phenomenon.name,
        category: phenomenon.category,
        linkedCalendars,
        nextOccurrence: occurrences[0]?.label
      };
    });
  }
  buildPhenomenonMapMarkers(phenomena, calendars) {
    if (phenomena.length === 0) {
      return [];
    }
    const calendarNames = new Map(calendars.map((schema) => [schema.id, schema.name]));
    const total = phenomena.length;
    const columns = Math.max(1, Math.ceil(Math.sqrt(total)));
    const rows = Math.max(1, Math.ceil(total / columns));
    return phenomena.map((phenomenon, index) => {
      const column = index % columns;
      const row = Math.floor(index / columns);
      const x = clampCoordinate((column + 0.5) / columns);
      const y = clampCoordinate((row + 0.5) / rows);
      return {
        id: phenomenon.id,
        title: phenomenon.title,
        category: phenomenon.category,
        nextOccurrence: phenomenon.nextOccurrence,
        coordinates: { x, y },
        calendars: phenomenon.linkedCalendars.map((calendarId) => ({
          id: calendarId,
          name: calendarNames.get(calendarId) ?? calendarId
        }))
      };
    });
  }
  buildPhenomenonDetailForId(phenomenonId, calendars, referenceTimestamp) {
    const phenomenon = this.phenomenaDefinitions.find((item) => item.id === phenomenonId);
    if (!phenomenon) {
      return null;
    }
    return this.buildPhenomenonDetailView(phenomenon, calendars, referenceTimestamp);
  }
  buildPhenomenonDetailView(phenomenon, calendars, referenceTimestamp) {
    const calendarMap = new Map(calendars.map((schema) => [schema.id, schema]));
    const linkedIdsBase = phenomenon.visibility === "all_calendars" ? calendars.map((schema) => schema.id) : phenomenon.appliesToCalendarIds;
    const linkedCalendars = Array.from(new Set(linkedIdsBase)).map((id) => {
      const schema = calendarMap.get(id);
      return schema ? { id, name: schema.name } : null;
    }).filter(Boolean);
    const upcomingOccurrences = linkedCalendars.flatMap((link) => {
      const schema = calendarMap.get(link.id);
      if (!schema) return [];
      const anchor = referenceTimestamp && referenceTimestamp.calendarId === link.id ? referenceTimestamp : createDayTimestamp(link.id, schema.epoch.year, schema.epoch.monthId, schema.epoch.day);
      const occurrences = this.collectUpcomingOccurrences(phenomenon, schema, link.id, anchor, 3);
      if (occurrences.length === 0) {
        return [];
      }
      const [first, ...rest] = occurrences;
      const nextMonthName = getMonthById(schema, first.timestamp.monthId)?.name ?? first.timestamp.monthId;
      const nextLabel = formatTimestamp(first.timestamp, nextMonthName);
      const subsequent = rest.map((item) => {
        const monthName = getMonthById(schema, item.timestamp.monthId)?.name ?? item.timestamp.monthId;
        return formatTimestamp(item.timestamp, monthName);
      });
      return [
        {
          calendarId: link.id,
          calendarName: link.name,
          nextLabel,
          nextTimestamp: first.timestamp,
          subsequent
        }
      ];
    });
    return {
      id: phenomenon.id,
      name: phenomenon.name,
      category: phenomenon.category,
      notes: phenomenon.notes,
      linkedCalendars,
      upcomingOccurrences
    };
  }
  collectUpcomingOccurrences(phenomenon, schema, calendarId, start, limit) {
    const occurrences = [];
    let anchor = start;
    let includeStart = true;
    for (let index = 0; index < limit; index++) {
      let occurrence = null;
      try {
        occurrence = computeNextPhenomenonOccurrence(
          phenomenon,
          schema,
          calendarId,
          anchor,
          { includeStart }
        );
      } catch {
        break;
      }
      if (!occurrence) {
        break;
      }
      occurrences.push(occurrence);
      anchor = advanceTime(schema, occurrence.timestamp, 1, "minute").timestamp;
      includeStart = false;
    }
    return occurrences;
  }
  ensurePhenomenonSelection() {
    if (this.state.eventsUiState.selectedPhenomenonId && this.state.eventsUiState.selectedPhenomenonDetail) {
      return;
    }
    const first = this.state.eventsUiState.phenomena[0];
    if (first) {
      void this.handlePhenomenonSelected(first.id);
    }
  }
  applyPhenomenaFilters(filters) {
    return this.phenomenaSource.filter((phenomenon) => {
      const categoryMatch = filters.categories.length === 0 || (phenomenon.category ? filters.categories.includes(phenomenon.category) : false);
      const calendarMatch = filters.calendarIds.length === 0 || phenomenon.linkedCalendars.some((calendarId) => filters.calendarIds.includes(calendarId));
      return categoryMatch && calendarMatch;
    });
  }
  rebuildPhenomenaListing(preferredId = null, options = {}) {
    const calendars = this.state.calendarState.calendars;
    const activeCalendarId = this.state.calendarState.activeCalendarId;
    const referenceTimestamp = this.state.calendarState.currentTimestamp;
    this.phenomenaSource = this.buildPhenomenonViewModels(
      this.phenomenaDefinitions,
      calendars,
      activeCalendarId,
      referenceTimestamp
    );
    const filters = this.state.eventsUiState.filters;
    const filtered = this.applyPhenomenaFilters(filters);
    const availableCategories = getUniqueCategories(this.phenomenaSource);
    const filterCount = filters.categories.length + filters.calendarIds.length;
    const validIds = new Set(this.phenomenaDefinitions.map((item) => item.id));
    let nextSelectedId = preferredId ?? this.state.eventsUiState.selectedPhenomenonId ?? null;
    if (nextSelectedId && !validIds.has(nextSelectedId)) {
      nextSelectedId = filtered[0]?.id ?? null;
    }
    const nextDetail = nextSelectedId ? this.buildPhenomenonDetailForId(nextSelectedId, calendars, referenceTimestamp) : null;
    const selectionSource = options.bulkSelection !== void 0 ? options.bulkSelection : this.state.eventsUiState.bulkSelection;
    const nextSelection = selectionSource.filter((id) => validIds.has(id));
    const exportPayload = options.exportPayload !== void 0 ? options.exportPayload === null ? void 0 : options.exportPayload : this.state.eventsUiState.lastExportPayload;
    const importSummary = options.importSummary !== void 0 ? options.importSummary : this.state.eventsUiState.importSummary ?? null;
    const mapMarkers = this.buildPhenomenonMapMarkers(filtered, calendars);
    this.setState((draft) => {
      draft.eventsUiState = {
        ...draft.eventsUiState,
        availableCategories,
        mapMarkers,
        phenomena: filtered,
        filterCount,
        selectedPhenomenonId: nextSelectedId,
        selectedPhenomenonDetail: nextDetail,
        bulkSelection: nextSelection,
        lastExportPayload: exportPayload,
        importSummary
      };
    });
    void this.persistPreferences({
      lastSelectedPhenomenonId: nextSelectedId ?? void 0
    });
  }
  createEditorDraftFromPhenomenon(phenomenon) {
    return {
      id: phenomenon.id,
      name: phenomenon.name,
      category: phenomenon.category,
      visibility: phenomenon.visibility,
      appliesToCalendarIds: [...phenomenon.appliesToCalendarIds],
      notes: phenomenon.notes ?? ""
    };
  }
  createDefaultEditorDraft(seedId) {
    const id = seedId && seedId.trim().length > 0 ? seedId : this.generatePhenomenonId();
    const activeCalendarId = this.state.calendarState.activeCalendarId;
    const appliesTo = activeCalendarId ? [activeCalendarId] : [];
    return {
      id,
      name: "",
      category: "custom",
      visibility: appliesTo.length ? "selected" : "all_calendars",
      appliesToCalendarIds: appliesTo,
      notes: ""
    };
  }
  generatePhenomenonId() {
    this.phenomenonIdCounter += 1;
    return `phen-${Date.now().toString(36)}-${this.phenomenonIdCounter.toString(36)}`;
  }
  buildPhenomenonFromDraft(draft, base) {
    const trimmedName = draft.name.trim();
    const category = this.normaliseCategory(draft.category);
    const appliesTo = draft.visibility === "all_calendars" ? [] : Array.from(new Set(draft.appliesToCalendarIds.filter(Boolean)));
    const defaults = base ?? {
      id: draft.id,
      name: trimmedName,
      category,
      visibility: draft.visibility,
      appliesToCalendarIds: appliesTo,
      rule: { type: "annual", offsetDayOfYear: 0 },
      timePolicy: "all_day",
      priority: 0,
      schemaVersion: "1.0.0"
    };
    const notes = draft.notes?.trim() ?? "";
    return {
      ...defaults,
      id: draft.id,
      name: trimmedName,
      category,
      visibility: draft.visibility,
      appliesToCalendarIds: appliesTo,
      notes: notes.length ? notes : void 0
    };
  }
  normaliseCategory(value) {
    const allowed = [
      "season",
      "astronomy",
      "weather",
      "tide",
      "holiday",
      "custom"
    ];
    return allowed.includes(value) ? value : "custom";
  }
  toPhenomenon(dto) {
    const { template: _template, ...rest } = dto;
    const base = rest;
    return {
      ...base,
      appliesToCalendarIds: [...base.appliesToCalendarIds],
      hooks: base.hooks ? base.hooks.map((hook) => ({ ...hook })) : base.hooks,
      effects: base.effects ? base.effects.map((effect) => ({ ...effect, payload: { ...effect.payload } })) : base.effects,
      tags: base.tags ? [...base.tags] : base.tags
    };
  }
  shiftAnchorTimestamp(schema, anchor, zoom, direction) {
    const step = direction === "next" ? 1 : -1;
    if (zoom === "month") {
      let monthIndex = getMonthIndex(schema, anchor.monthId);
      if (monthIndex === -1) {
        monthIndex = 0;
      }
      monthIndex += step;
      let year = anchor.year;
      if (monthIndex < 0) {
        monthIndex = schema.months.length - 1;
        year -= 1;
      } else if (monthIndex >= schema.months.length) {
        monthIndex = 0;
        year += 1;
      }
      const month = schema.months[monthIndex];
      const day = Math.min(anchor.day, month.length);
      return {
        ...anchor,
        year,
        monthId: month.id,
        day
      };
    }
    if (zoom === "week") {
      return advanceTime(schema, anchor, step * 7, "day").timestamp;
    }
    if (zoom === "day") {
      return advanceTime(schema, anchor, step, "day").timestamp;
    }
    return advanceTime(schema, anchor, step * 6, "hour").timestamp;
  }
  collectAgendaItems(anchor, zoom, eventsOverride) {
    const events = [
      ...eventsOverride ?? this.state.calendarState.upcomingEvents,
      ...this.state.calendarState.triggeredEvents
    ];
    if (events.length === 0) {
      return [];
    }
    if (zoom === "month") {
      return events.filter(
        (event) => event.date.calendarId === anchor.calendarId && event.date.year === anchor.year && event.date.monthId === anchor.monthId
      );
    }
    if (zoom === "week") {
      const weekEvents = [];
      const schema = this.getCalendarSchema(anchor.calendarId);
      if (!schema) return weekEvents;
      for (let offset = 0; offset < schema.daysPerWeek; offset++) {
        const dayTs = advanceTime(schema, anchor, offset, "day").timestamp;
        weekEvents.push(...events.filter(
          (event) => event.date.calendarId === dayTs.calendarId && event.date.year === dayTs.year && event.date.monthId === dayTs.monthId && event.date.day === dayTs.day
        ));
      }
      return weekEvents;
    }
    return events.filter(
      (event) => event.date.calendarId === anchor.calendarId && event.date.year === anchor.year && event.date.monthId === anchor.monthId && event.date.day === anchor.day
    );
  }
  getAnchorBase() {
    return this.state.managerUiState.anchorTimestamp ?? this.state.calendarState.currentTimestamp ?? this.gateway.getCurrentTimestamp() ?? this.getAnchorFallback();
  }
  clearJumpPreview() {
    this.setState((draft) => {
      draft.managerUiState = {
        ...draft.managerUiState,
        jumpPreview: []
      };
    });
  }
  getAnchorFallback() {
    const activeId = this.state.calendarState.activeCalendarId ?? this.gateway.getActiveCalendarId() ?? this.state.calendarState.calendars[0]?.id;
    if (!activeId) {
      return null;
    }
    const schema = this.getCalendarSchema(activeId) ?? this.state.calendarState.calendars.find((c) => c.id === activeId);
    if (!schema) {
      return null;
    }
    const firstMonth = schema.months[0] ?? { id: schema.epoch.monthId, length: schema.months[0]?.length ?? 30 };
    return createDayTimestamp(activeId, schema.epoch.year, firstMonth.id, schema.epoch.day);
  }
  computeEditWarnings(schema, draft) {
    const warnings = [];
    const currentHours = String(schema.hoursPerDay ?? 24);
    const currentMinutes = String(schema.minutesPerHour ?? 60);
    const currentStep = String(schema.minuteStep ?? 1);
    if (draft.hoursPerDay.trim() !== currentHours || draft.minutesPerHour.trim() !== currentMinutes || draft.minuteStep.trim() !== currentStep) {
      warnings.push("Updating the time definition may require migrating existing events.");
    }
    return warnings;
  }
  async detectCalendarConflicts(calendarId, updates) {
    if (!("hoursPerDay" in updates) && !("minutesPerHour" in updates) && !("minuteStep" in updates)) {
      return [];
    }
    const schema = this.getCalendarSchema(calendarId);
    if (!schema) {
      return [];
    }
    const hoursPerDay = updates.hoursPerDay ?? schema.hoursPerDay ?? 24;
    const minutesPerHour = updates.minutesPerHour ?? schema.minutesPerHour ?? 60;
    const minuteStep = updates.minuteStep ?? schema.minuteStep ?? 1;
    const events = await this.eventRepo.listEvents(calendarId);
    const conflicts = /* @__PURE__ */ new Set();
    const checkTime = (label, time, title) => {
      if (!time) {
        return;
      }
      if (time.hour >= hoursPerDay) {
        conflicts.add(`${title}: ${label} hour ${time.hour} exceeds ${hoursPerDay - 1}.`);
      }
      if (time.minute >= minutesPerHour) {
        conflicts.add(`${title}: ${label} minute ${time.minute} exceeds ${minutesPerHour - 1}.`);
      }
    };
    for (const event of events) {
      const title = event.title ?? event.id;
      if (isSingleEvent(event)) {
        checkTime("start", event.startTime, title);
        checkTime("end", event.endTime, title);
        const timestamp = event.date;
        if (timestamp.precision === "hour" || timestamp.precision === "minute") {
          if (timestamp.hour >= hoursPerDay) {
            conflicts.add(`${title}: hour ${timestamp.hour} exceeds ${hoursPerDay - 1}.`);
          }
          if (timestamp.minute >= minutesPerHour) {
            conflicts.add(`${title}: minute ${timestamp.minute} exceeds ${minutesPerHour - 1}.`);
          }
          if (timestamp.precision === "minute" && timestamp.minute % minuteStep !== 0) {
            conflicts.add(`${title}: start time is not aligned with the new minute step.`);
          }
        }
        if (event.durationMinutes && event.durationMinutes % minuteStep !== 0) {
          conflicts.add(`${title}: duration is not aligned with the new minute step.`);
        }
      } else if (isRecurringEvent(event)) {
        checkTime("start", event.startTime, title);
        if (event.offsetMinutes && event.offsetMinutes % minuteStep !== 0) {
          conflicts.add(`${title}: offset is not aligned with the new minute step.`);
        }
        if (event.durationMinutes && event.durationMinutes % minuteStep !== 0) {
          conflicts.add(`${title}: duration is not aligned with the new minute step.`);
        }
      }
    }
    return Array.from(conflicts);
  }
  getCalendarDefaultsRepository() {
    const candidate = this.calendarRepo;
    if (typeof candidate.getDefaults === "function" && typeof candidate.clearTravelDefault === "function") {
      return candidate;
    }
    return null;
  }
  async collectTravelDefaultIds(calendarId) {
    const defaultsRepo = this.getCalendarDefaultsRepository();
    if (!defaultsRepo) {
      return [];
    }
    try {
      const defaults = await defaultsRepo.getDefaults();
      return Object.entries(defaults.travel).filter(([, linkedId]) => linkedId === calendarId).map(([travelId]) => travelId);
    } catch {
      return [];
    }
  }
  async buildCalendarSchemaFromDraft(draft) {
    const errors = [];
    const rawId = draft.id.trim();
    const id = this.slugify(rawId);
    if (!id) {
      errors.push("Identifier is required.");
    }
    const name = draft.name.trim();
    if (!name) {
      errors.push("Name is required.");
    }
    const daysPerWeek = Number(draft.daysPerWeek || "0");
    if (!Number.isFinite(daysPerWeek) || daysPerWeek < 1) {
      errors.push("Days per week must be at least 1.");
    }
    const monthCount = Number(draft.monthCount || "0");
    if (!Number.isFinite(monthCount) || monthCount < 1) {
      errors.push("Month count must be at least 1.");
    }
    const monthLength = Number(draft.monthLength || "0");
    if (!Number.isFinite(monthLength) || monthLength < 1) {
      errors.push("Month length must be at least 1.");
    }
    const hoursPerDay = Number(draft.hoursPerDay || "24");
    if (!Number.isFinite(hoursPerDay) || hoursPerDay < 1) {
      errors.push("Hours per day must be at least 1.");
    }
    const minutesPerHour = Number(draft.minutesPerHour || "60");
    if (!Number.isFinite(minutesPerHour) || minutesPerHour < 1) {
      errors.push("Minutes per hour must be at least 1.");
    }
    const minuteStep = Number(draft.minuteStep || "1");
    if (!Number.isFinite(minuteStep) || minuteStep < 1) {
      errors.push("Minute step must be at least 1.");
    } else if (minuteStep > minutesPerHour) {
      errors.push("Minute step must not exceed minutes per hour.");
    }
    const epochYear = Number(draft.epochYear || "1");
    if (!Number.isFinite(epochYear) || epochYear < 1) {
      errors.push("Epoch year must be at least 1.");
    }
    const epochDay = Number(draft.epochDay || "1");
    if (!Number.isFinite(epochDay) || epochDay < 1) {
      errors.push("Epoch day must be at least 1.");
    } else if (epochDay > monthLength) {
      errors.push("Epoch day must not exceed the chosen month length.");
    }
    if (errors.length > 0) {
      return { schema: null, errors };
    }
    const existing = await this.calendarRepo.getCalendar(id);
    if (existing) {
      return { schema: null, errors: [`Calendar with id "${id}" already exists.`] };
    }
    const safeMonthCount = Math.max(1, Math.floor(monthCount));
    const safeMonthLength = Math.max(1, Math.floor(monthLength));
    const safeDaysPerWeek = Math.max(1, Math.floor(daysPerWeek));
    const safeHoursPerDay = Math.max(1, Math.floor(hoursPerDay));
    const safeMinutesPerHour = Math.max(1, Math.floor(minutesPerHour));
    const safeMinuteStep = Math.max(1, Math.floor(minuteStep));
    const safeEpochYear = Math.max(1, Math.floor(epochYear));
    const safeEpochDay = Math.max(1, Math.min(Math.floor(epochDay), safeMonthLength));
    const monthPrefix = this.slugify(name || id) || "month";
    const months = Array.from({ length: safeMonthCount }, (_, index) => ({
      id: `${monthPrefix}-m${index + 1}`,
      name: `Month ${index + 1}`,
      length: safeMonthLength
    }));
    if (months.length === 0) {
      return { schema: null, errors: ["Calendar must include at least one month."] };
    }
    const epochMonthId = months[0]?.id ?? `${monthPrefix}-m1`;
    const schema = {
      id,
      name,
      description: draft.description.trim() || void 0,
      daysPerWeek: safeDaysPerWeek,
      months,
      hoursPerDay: safeHoursPerDay,
      minutesPerHour: safeMinutesPerHour,
      minuteStep: safeMinuteStep,
      secondsPerMinute: 60,
      epoch: {
        year: safeEpochYear,
        monthId: epochMonthId,
        day: safeEpochDay
      },
      isDefaultGlobal: false,
      schemaVersion: "1.0.0"
    };
    return { schema, errors: [] };
  }
  slugify(value) {
    return value.trim().toLowerCase().replace(/[^a-z0-9-]+/g, "-").replace(/^-+|-+$/g, "").replace(/--+/g, "-");
  }
  async persistTravelLeafPreferences(partial) {
    if (!this.travelId) {
      return;
    }
    const base = {
      visible: this.state.travelLeafState.visible,
      mode: this.state.travelLeafState.mode,
      lastViewedTimestamp: this.state.travelLeafState.currentTimestamp ?? null,
      ...this.travelLeafPreferences
    };
    const next = {
      ...base,
      ...partial
    };
    if (partial.lastViewedTimestamp === void 0) {
      next.lastViewedTimestamp = base.lastViewedTimestamp ?? this.state.travelLeafState.currentTimestamp ?? null;
    }
    try {
      await this.gateway.saveTravelLeafPreferences(this.travelId, next);
      this.travelLeafPreferences = next;
    } catch (error) {
      console.warn("Failed to persist travel leaf preferences", error);
    }
  }
  async persistPreferences(partial) {
    try {
      await this.gateway.savePreferences(partial);
    } catch (error) {
      console.warn("Failed to persist Almanac preferences", error);
    }
  }
};
function cloneState(value) {
  try {
    return structuredClone(value);
  } catch (error) {
    return JSON.parse(JSON.stringify(value));
  }
}
function clampCoordinate(value) {
  const clamped = Math.min(0.95, Math.max(0.05, value));
  return Number(clamped.toFixed(4));
}
function getUniqueCategories(phenomena) {
  const set = /* @__PURE__ */ new Set();
  for (const item of phenomena) {
    if (item.category) {
      set.add(item.category);
    }
  }
  return Array.from(set.values()).sort();
}

// src/apps/almanac/mode/almanac-controller.ts
init_cartographer_bridge();

// src/apps/almanac/mode/events/events-map.ts
function renderEventsMap(host, props) {
  const container = document.createElement("div");
  container.classList.add("almanac-events-map");
  container.dataset.component = "events-map";
  host.appendChild(container);
  const summary = document.createElement("div");
  summary.classList.add("almanac-events-map__summary");
  summary.dataset.role = "map-summary";
  const categorySet = /* @__PURE__ */ new Set();
  const calendarSet = /* @__PURE__ */ new Set();
  for (const marker of props.markers) {
    if (marker.category) {
      categorySet.add(marker.category);
    }
    for (const calendar of marker.calendars) {
      calendarSet.add(calendar.name);
    }
  }
  const summaryParts = [];
  summaryParts.push(`${props.markers.length} phenomena plotted`);
  if (categorySet.size > 0) {
    summaryParts.push(`${categorySet.size} categories`);
  }
  if (calendarSet.size > 0) {
    summaryParts.push(`${calendarSet.size} calendars`);
  }
  summary.textContent = summaryParts.join(" \u2022 ");
  container.appendChild(summary);
  const board = document.createElement("div");
  board.classList.add("almanac-events-map__board");
  board.dataset.role = "map-board";
  board.style.position = "relative";
  board.style.minHeight = "240px";
  board.style.border = "1px solid var(--background-modifier-border, #3a3a3a)";
  board.style.borderRadius = "12px";
  board.style.background = "var(--background-secondary, rgba(255,255,255,0.02))";
  board.style.overflow = "hidden";
  board.style.isolation = "isolate";
  container.appendChild(board);
  props.markers.forEach((marker) => {
    const markerButton = document.createElement("button");
    markerButton.type = "button";
    markerButton.classList.add("almanac-events-map__marker");
    markerButton.dataset.role = "map-marker";
    markerButton.dataset.phenomenonId = marker.id;
    markerButton.style.position = "absolute";
    markerButton.style.width = "20px";
    markerButton.style.height = "20px";
    markerButton.style.borderRadius = "50%";
    markerButton.style.border = "2px solid var(--interactive-accent, #9c6bff)";
    markerButton.style.background = "var(--background-primary, #1a1a1a)";
    markerButton.style.transform = "translate(-50%, -50%)";
    markerButton.style.left = `${(marker.coordinates.x * 100).toFixed(2)}%`;
    markerButton.style.top = `${(marker.coordinates.y * 100).toFixed(2)}%`;
    markerButton.setAttribute("aria-label", buildMarkerLabel(marker));
    markerButton.title = buildMarkerLabel(marker);
    const markerLabel = document.createElement("span");
    markerLabel.classList.add("almanac-events-map__marker-label");
    markerLabel.textContent = marker.title;
    markerLabel.style.position = "absolute";
    markerLabel.style.top = "100%";
    markerLabel.style.left = "50%";
    markerLabel.style.transform = "translate(-50%, 4px)";
    markerLabel.style.whiteSpace = "nowrap";
    markerLabel.style.fontSize = "10px";
    markerLabel.style.pointerEvents = "none";
    markerButton.appendChild(markerLabel);
    board.appendChild(markerButton);
  });
  const legendHeading = document.createElement("h3");
  legendHeading.classList.add("almanac-events-map__legend-heading");
  legendHeading.textContent = "Map Markers";
  container.appendChild(legendHeading);
  const legendList = document.createElement("ul");
  legendList.classList.add("almanac-events-map__legend");
  legendList.dataset.role = "map-legend";
  container.appendChild(legendList);
  props.markers.forEach((marker) => {
    const item = document.createElement("li");
    item.classList.add("almanac-events-map__legend-item");
    item.dataset.role = "map-legend-item";
    item.dataset.phenomenonId = marker.id;
    const title = document.createElement("strong");
    title.textContent = marker.title;
    item.appendChild(title);
    if (marker.category) {
      const category = document.createElement("span");
      category.classList.add("almanac-events-map__legend-category");
      category.textContent = ` (${marker.category})`;
      item.appendChild(category);
    }
    const calendars = document.createElement("div");
    calendars.classList.add("almanac-events-map__legend-calendars");
    calendars.textContent = marker.calendars.length ? `Calendars: ${marker.calendars.map((calendar) => calendar.name).join(", ")}` : "Calendars: \u2014";
    item.appendChild(calendars);
    if (marker.nextOccurrence) {
      const next = document.createElement("div");
      next.classList.add("almanac-events-map__legend-occurrence");
      next.textContent = `Next: ${marker.nextOccurrence}`;
      item.appendChild(next);
    }
    const coordinates = document.createElement("div");
    coordinates.classList.add("almanac-events-map__legend-coordinates");
    coordinates.textContent = `Position: ${(marker.coordinates.x * 100).toFixed(1)}%, ${(marker.coordinates.y * 100).toFixed(1)}%`;
    item.appendChild(coordinates);
    legendList.appendChild(item);
  });
  return container;
}
function buildMarkerLabel(marker) {
  const calendars = marker.calendars.length ? marker.calendars.map((calendar) => calendar.name).join(", ") : "No calendar link";
  const segments = [marker.title];
  if (marker.category) {
    segments.push(marker.category);
  }
  if (marker.nextOccurrence) {
    segments.push(marker.nextOccurrence);
  }
  segments.push(`Calendars: ${calendars}`);
  return segments.join(" \u2022 ");
}

// src/apps/almanac/mode/components/calendar-view-container.ts
function createCalendarViewContainer(app, parent, config) {
  const container = parent.createDiv({ cls: "almanac-calendar-view" });
  const header = container.createDiv({ cls: "almanac-calendar-view__header" });
  const tabs = [
    { id: "month", label: "Month", icon: "calendar-days" },
    { id: "week", label: "Week", icon: "calendar-range" },
    { id: "day", label: "Day", icon: "calendar-clock" },
    { id: "upcoming", label: "Next", icon: "list-ordered" }
  ];
  const tabNav = createTabNavigation(header, {
    tabs,
    activeTab: config.mode,
    className: "almanac-calendar-view__tabs",
    onSelect: config.onModeChange
  });
  const navControls = header.createDiv({ cls: "almanac-calendar-view__nav" });
  const prevBtn = navControls.createEl("button", { text: "\u25C0", attr: { "aria-label": "Previous" } });
  const todayBtn = navControls.createEl("button", { text: "Today" });
  const nextBtn = navControls.createEl("button", { text: "\u25B6", attr: { "aria-label": "Next" } });
  prevBtn.onclick = () => config.onNavigate("prev");
  todayBtn.onclick = () => config.onNavigate("today");
  nextBtn.onclick = () => config.onNavigate("next");
  const content = container.createDiv({ cls: "almanac-calendar-view__content" });
  const renderContent = (state) => {
    content.empty();
    if (state.isLoading) {
      content.createDiv({ cls: "sm-mode-loading", text: "Loading..." });
      return;
    }
    if (state.error) {
      content.createDiv({ cls: "sm-mode-error", text: state.error });
      return;
    }
    switch (config.mode) {
      case "month":
        renderMonthView(content, state);
        break;
      case "week":
        renderWeekView(content, state);
        break;
      case "day":
        renderDayView(content, state);
        break;
      case "upcoming":
        renderUpcomingView(content, state);
        break;
    }
  };
  const renderMonthView = (container2, state) => {
    const grid = container2.createDiv({ cls: "almanac-calendar-grid almanac-calendar-grid--month" });
    grid.createDiv({ text: `Month view - ${state.events.length} events` });
  };
  const renderWeekView = (container2, state) => {
    const grid = container2.createDiv({ cls: "almanac-calendar-grid almanac-calendar-grid--week" });
    grid.createDiv({ text: `Week view - ${state.events.length} events` });
  };
  const renderDayView = (container2, state) => {
    const timeline = container2.createDiv({ cls: "almanac-calendar-timeline" });
    timeline.createDiv({ text: `Day view - ${state.events.length} events` });
  };
  const renderUpcomingView = (container2, state) => {
    const list = container2.createDiv({ cls: "almanac-upcoming-list" });
    if (state.events.length === 0) {
      list.createDiv({ cls: "sm-mode-empty", text: "No upcoming events" });
      return;
    }
    for (const event of state.events) {
      const item = list.createDiv({ cls: "almanac-upcoming-item" });
      item.createDiv({ cls: "almanac-upcoming-item__title", text: event.title });
      item.createDiv({ cls: "almanac-upcoming-item__time", text: "TODO: Format time" });
      item.onclick = () => config.onEventSelect(event.id);
    }
  };
  renderContent(config.state);
  return {
    element: container,
    setMode(mode) {
      tabNav.setActiveTab(mode);
    },
    update(state) {
      renderContent(state);
    },
    destroy() {
      tabNav.destroy();
      container.remove();
    }
  };
}

// src/apps/almanac/mode/components/almanac-content-container.ts
function createAlmanacContentContainer(app, parent, config) {
  const container = parent.createDiv({ cls: "almanac-content-tabs" });
  const header = container.createDiv({ cls: "almanac-content-tabs__header" });
  const tabs = [
    { id: "dashboard", label: "Dashboard", icon: "layout-dashboard" },
    { id: "events", label: "Events", icon: "calendar-search" },
    { id: "manager", label: "Manager", icon: "settings" }
  ];
  const tabNav = createTabNavigation(header, {
    tabs,
    activeTab: config.mode,
    className: "almanac-content-tabs__nav",
    onSelect: config.onModeChange
  });
  const body = container.createDiv({ cls: "almanac-content-tabs__body" });
  const dashboardContainer = body.createDiv({ cls: "almanac-dashboard-content" });
  const eventsContainer = body.createDiv({ cls: "almanac-events-content" });
  const managerContainer = body.createDiv({ cls: "almanac-manager-content" });
  let currentMode = config.mode;
  const updateVisibility = () => {
    dashboardContainer.style.display = currentMode === "dashboard" ? "" : "none";
    eventsContainer.style.display = currentMode === "events" ? "" : "none";
    managerContainer.style.display = currentMode === "manager" ? "" : "none";
  };
  updateVisibility();
  return {
    element: container,
    dashboardElement: dashboardContainer,
    eventsElement: eventsContainer,
    managerElement: managerContainer,
    setMode(mode) {
      currentMode = mode;
      tabNav.setActiveTab(mode);
      updateVisibility();
    },
    update(state) {
    },
    destroy() {
      tabNav.destroy();
      container.remove();
    }
  };
}

// src/apps/almanac/fixtures/gregorian.fixture.ts
init_calendar_timestamp();
init_calendar_event();
var GREGORIAN_CALENDAR_ID = "gregorian-standard";
var gregorianSchema = {
  id: GREGORIAN_CALENDAR_ID,
  name: "Gregorian Calendar",
  description: "Standard Earth calendar with 12 months (24-hour days)",
  daysPerWeek: 7,
  hoursPerDay: 24,
  minutesPerHour: 60,
  secondsPerMinute: 60,
  minuteStep: 15,
  months: [
    { id: "jan", name: "January", length: 31 },
    { id: "feb", name: "February", length: 28 },
    // Simplified: no leap years for MVP
    { id: "mar", name: "March", length: 31 },
    { id: "apr", name: "April", length: 30 },
    { id: "may", name: "May", length: 31 },
    { id: "jun", name: "June", length: 30 },
    { id: "jul", name: "July", length: 31 },
    { id: "aug", name: "August", length: 31 },
    { id: "sep", name: "September", length: 30 },
    { id: "oct", name: "October", length: 31 },
    { id: "nov", name: "November", length: 30 },
    { id: "dec", name: "December", length: 31 }
  ],
  epoch: {
    year: 2024,
    monthId: "jan",
    day: 1
  },
  schemaVersion: "1.0.0"
};

// src/apps/almanac/data/calendar-presets.ts
async function ensureDefaultCalendar(repo) {
  const calendars = await repo.listCalendars();
  if (calendars.length === 0) {
    await repo.createCalendar({
      ...gregorianSchema,
      isDefaultGlobal: true
    });
  } else {
    const hasDefault = calendars.some((cal) => cal.isDefaultGlobal);
    if (!hasDefault) {
      await repo.setDefault({
        calendarId: calendars[0].id,
        scope: "global"
      });
    }
  }
}

// src/apps/almanac/mode/almanac-controller.ts
var MODE_COPY = {
  dashboard: { label: "Dashboard", description: "Current date, quick actions and upcoming events" },
  manager: { label: "Manager", description: "Manage calendars, zoom levels and defaults" },
  events: { label: "Events", description: "Cross-calendar phenomena overview and filters" }
};
var MANAGER_ZOOM_OPTIONS = ["month", "week", "day", "hour"];
var MANAGER_VIEW_OPTIONS = ["calendar", "overview"];
var EVENT_VIEW_OPTIONS = ["timeline", "table", "map"];
var ALMANAC_PROTOCOL_BASE = "obsidian://saltmarcher";
var ALMANAC_PROTOCOL_HOSTS = /* @__PURE__ */ new Set(["saltmarcher", "salt-marcher"]);
var EventEditorModal = class extends import_obsidian31.Modal {
  constructor(app, draft, config) {
    super(app);
    this.container = null;
    this.draft = { ...draft };
    this.config = { ...config };
  }
  open() {
    super.open();
    this.render();
  }
  update(draft, config) {
    this.draft = { ...draft };
    this.config = { ...this.config, ...config };
    this.render();
  }
  close() {
    this.container?.remove();
    this.container = null;
    super.close();
  }
  ensureContainer() {
    if (!this.container) {
      this.container = document.createElement("div");
      this.container.classList.add("almanac-modal");
      this.container.dataset.modal = "event-editor";
      document.body.appendChild(this.container);
    }
    return this.container;
  }
  getHost() {
    const contentEl = this.contentEl;
    if (contentEl) {
      return contentEl;
    }
    return this.ensureContainer();
  }
  render() {
    const host = this.getHost();
    host.textContent = "";
    const wrapper = document.createElement("div");
    wrapper.classList.add("almanac-modal");
    wrapper.dataset.modal = "event-editor";
    host.appendChild(wrapper);
    const form = document.createElement("form");
    form.classList.add("almanac-modal__form");
    wrapper.appendChild(form);
    form.addEventListener("submit", (event) => {
      event.preventDefault();
      if (!this.config.isSaving) {
        this.config.onSubmit();
      }
    });
    const heading = document.createElement("h2");
    heading.textContent = this.draft.kind === "recurring" ? "Recurring event" : "Single event";
    heading.dataset.mode = this.draft.kind;
    form.appendChild(heading);
    if (this.config.submitError) {
      const errorBanner = document.createElement("div");
      errorBanner.classList.add("almanac-section", "almanac-section--error");
      errorBanner.textContent = this.config.submitError;
      form.appendChild(errorBanner);
    }
    if (this.config.errors.length > 0) {
      const errorList = document.createElement("ul");
      errorList.classList.add("almanac-form-errors");
      this.config.errors.forEach((message) => {
        const item = document.createElement("li");
        item.textContent = message;
        errorList.appendChild(item);
      });
      form.appendChild(errorList);
    }
    const calendarOption = this.config.calendars.find((option) => option.id === this.draft.calendarId) ?? this.config.calendars[0] ?? null;
    const calendarField = document.createElement("label");
    calendarField.classList.add("almanac-modal__field");
    calendarField.textContent = "Calendar";
    const calendarSelect = document.createElement("select");
    calendarSelect.disabled = this.config.isSaving;
    this.config.calendars.forEach((option) => {
      const opt = document.createElement("option");
      opt.value = option.id;
      opt.textContent = option.name;
      calendarSelect.appendChild(opt);
    });
    if (this.draft.calendarId) {
      calendarSelect.value = this.draft.calendarId;
    }
    calendarSelect.addEventListener("change", () => {
      this.config.onUpdate({ calendarId: calendarSelect.value });
    });
    calendarField.appendChild(calendarSelect);
    form.appendChild(calendarField);
    const titleField = document.createElement("label");
    titleField.classList.add("almanac-modal__field");
    titleField.textContent = "Title";
    const titleInput = document.createElement("input");
    titleInput.type = "text";
    titleInput.required = true;
    titleInput.value = this.draft.title;
    titleInput.disabled = this.config.isSaving;
    titleInput.addEventListener("input", () => {
      this.config.onUpdate({ title: titleInput.value });
    });
    titleField.appendChild(titleInput);
    form.appendChild(titleField);
    const categoryField = document.createElement("label");
    categoryField.classList.add("almanac-modal__field");
    categoryField.textContent = "Category";
    const categoryInput = document.createElement("input");
    categoryInput.type = "text";
    categoryInput.value = this.draft.category;
    categoryInput.disabled = this.config.isSaving;
    categoryInput.addEventListener("input", () => {
      this.config.onUpdate({ category: categoryInput.value });
    });
    categoryField.appendChild(categoryInput);
    form.appendChild(categoryField);
    const noteField = document.createElement("label");
    noteField.classList.add("almanac-modal__field");
    noteField.textContent = "Notes";
    const noteInput = document.createElement("textarea");
    noteInput.rows = 3;
    noteInput.value = this.draft.note;
    noteInput.disabled = this.config.isSaving;
    noteInput.addEventListener("input", () => {
      this.config.onUpdate({ note: noteInput.value });
    });
    noteField.appendChild(noteInput);
    form.appendChild(noteField);
    const dateGroup = document.createElement("div");
    dateGroup.classList.add("almanac-modal__field", "almanac-modal__field--inline");
    const dateLabel = document.createElement("span");
    dateLabel.textContent = "Date";
    dateGroup.appendChild(dateLabel);
    const yearInput = document.createElement("input");
    yearInput.type = "number";
    yearInput.min = "1";
    yearInput.value = this.draft.year;
    yearInput.disabled = this.config.isSaving;
    yearInput.addEventListener("input", () => {
      this.config.onUpdate({ year: yearInput.value });
    });
    dateGroup.appendChild(yearInput);
    const monthSelect = document.createElement("select");
    monthSelect.disabled = this.config.isSaving;
    const months = calendarOption?.months ?? [];
    months.forEach((month) => {
      const opt = document.createElement("option");
      opt.value = month.id;
      opt.textContent = month.name;
      monthSelect.appendChild(opt);
    });
    if (this.draft.monthId) {
      monthSelect.value = this.draft.monthId;
    }
    const dayInput = document.createElement("input");
    dayInput.type = "number";
    dayInput.min = "1";
    dayInput.value = this.draft.day;
    dayInput.disabled = this.config.isSaving;
    const updateDayLimit = () => {
      const month = months.find((item) => item.id === monthSelect.value);
      if (month) {
        dayInput.max = String(month.length);
      } else {
        dayInput.removeAttribute("max");
      }
    };
    updateDayLimit();
    monthSelect.addEventListener("change", () => {
      this.config.onUpdate({ monthId: monthSelect.value });
      updateDayLimit();
    });
    dateGroup.appendChild(monthSelect);
    dayInput.addEventListener("input", () => {
      this.config.onUpdate({ day: dayInput.value });
    });
    dateGroup.appendChild(dayInput);
    form.appendChild(dateGroup);
    const allDayField = document.createElement("label");
    allDayField.classList.add("almanac-modal__checkbox");
    const allDayInput = document.createElement("input");
    allDayInput.type = "checkbox";
    allDayInput.checked = this.draft.allDay;
    allDayInput.disabled = this.config.isSaving;
    allDayInput.addEventListener("change", () => {
      this.config.onUpdate({ allDay: allDayInput.checked });
    });
    allDayField.appendChild(allDayInput);
    allDayField.appendChild(document.createTextNode("All-day event"));
    form.appendChild(allDayField);
    const needsTimeFields = !this.draft.allDay;
    if (this.draft.kind === "single") {
      const precisionField = document.createElement("label");
      precisionField.classList.add("almanac-modal__field");
      precisionField.textContent = "Time precision";
      const precisionSelect = document.createElement("select");
      precisionSelect.disabled = this.config.isSaving || this.draft.allDay;
      ["day", "hour", "minute"].forEach((value) => {
        const opt = document.createElement("option");
        opt.value = value;
        opt.textContent = value.charAt(0).toUpperCase() + value.slice(1);
        precisionSelect.appendChild(opt);
      });
      precisionSelect.value = this.draft.timePrecision;
      precisionSelect.addEventListener("change", () => {
        this.config.onUpdate({ timePrecision: precisionSelect.value });
      });
      precisionField.appendChild(precisionSelect);
      form.appendChild(precisionField);
    }
    if (needsTimeFields) {
      const timeGroup = document.createElement("div");
      timeGroup.classList.add("almanac-modal__field", "almanac-modal__field--inline");
      const timeLabel = document.createElement("span");
      timeLabel.textContent = "Time";
      timeGroup.appendChild(timeLabel);
      const hourInput = document.createElement("input");
      hourInput.type = "number";
      hourInput.min = "0";
      hourInput.value = this.draft.hour;
      hourInput.disabled = this.config.isSaving;
      hourInput.addEventListener("input", () => {
        this.config.onUpdate({ hour: hourInput.value });
      });
      timeGroup.appendChild(hourInput);
      const minuteInput = document.createElement("input");
      minuteInput.type = "number";
      minuteInput.min = "0";
      minuteInput.value = this.draft.minute;
      minuteInput.disabled = this.config.isSaving;
      minuteInput.addEventListener("input", () => {
        this.config.onUpdate({ minute: minuteInput.value });
      });
      timeGroup.appendChild(minuteInput);
      form.appendChild(timeGroup);
    }
    const durationField = document.createElement("label");
    durationField.classList.add("almanac-modal__field");
    durationField.textContent = "Duration (minutes)";
    const durationInput = document.createElement("input");
    durationInput.type = "number";
    durationInput.min = "0";
    durationInput.value = this.draft.durationMinutes;
    durationInput.disabled = this.config.isSaving;
    durationInput.addEventListener("input", () => {
      this.config.onUpdate({ durationMinutes: durationInput.value });
    });
    durationField.appendChild(durationInput);
    form.appendChild(durationField);
    if (this.draft.kind === "recurring") {
      const ruleField = document.createElement("label");
      ruleField.classList.add("almanac-modal__field");
      ruleField.textContent = "Rule type";
      const ruleSelect = document.createElement("select");
      ruleSelect.disabled = this.config.isSaving;
      const ruleOptions = [
        { value: "weekly_dayIndex", label: "Weekly" },
        { value: "monthly_position", label: "Monthly position" },
        { value: "annual_offset", label: "Annual offset" }
      ];
      ruleOptions.forEach((option) => {
        const opt = document.createElement("option");
        opt.value = option.value;
        opt.textContent = option.label;
        ruleSelect.appendChild(opt);
      });
      ruleSelect.value = this.draft.ruleType;
      ruleSelect.addEventListener("change", () => {
        this.config.onUpdate({ ruleType: ruleSelect.value });
      });
      ruleField.appendChild(ruleSelect);
      form.appendChild(ruleField);
      if (this.draft.ruleType === "weekly_dayIndex") {
        const weeklyField = document.createElement("label");
        weeklyField.classList.add("almanac-modal__field");
        weeklyField.textContent = "Day of week";
        const weeklySelect = document.createElement("select");
        weeklySelect.disabled = this.config.isSaving;
        const days = calendarOption ? calendarOption.daysPerWeek : 7;
        for (let i = 0; i < days; i += 1) {
          const opt = document.createElement("option");
          opt.value = String(i);
          opt.textContent = `Day ${i + 1}`;
          weeklySelect.appendChild(opt);
        }
        weeklySelect.value = this.draft.ruleDayIndex;
        weeklySelect.addEventListener("change", () => {
          this.config.onUpdate({ ruleDayIndex: weeklySelect.value });
        });
        weeklyField.appendChild(weeklySelect);
        const intervalInput = document.createElement("input");
        intervalInput.type = "number";
        intervalInput.min = "1";
        intervalInput.value = this.draft.ruleInterval;
        intervalInput.disabled = this.config.isSaving;
        intervalInput.addEventListener("input", () => {
          this.config.onUpdate({ ruleInterval: intervalInput.value });
        });
        weeklyField.appendChild(intervalInput);
        form.appendChild(weeklyField);
      } else {
        const monthField = document.createElement("label");
        monthField.classList.add("almanac-modal__field");
        monthField.textContent = "Rule month";
        const ruleMonthSelect = document.createElement("select");
        ruleMonthSelect.disabled = this.config.isSaving;
        (calendarOption?.months ?? []).forEach((month) => {
          const opt = document.createElement("option");
          opt.value = month.id;
          opt.textContent = month.name;
          ruleMonthSelect.appendChild(opt);
        });
        ruleMonthSelect.value = this.draft.ruleMonthId || this.draft.monthId || "";
        ruleMonthSelect.addEventListener("change", () => {
          this.config.onUpdate({ ruleMonthId: ruleMonthSelect.value });
        });
        monthField.appendChild(ruleMonthSelect);
        const ruleDayInput = document.createElement("input");
        ruleDayInput.type = "number";
        ruleDayInput.min = "1";
        ruleDayInput.value = this.draft.ruleDay;
        ruleDayInput.disabled = this.config.isSaving;
        ruleDayInput.addEventListener("input", () => {
          this.config.onUpdate({ ruleDay: ruleDayInput.value });
        });
        monthField.appendChild(ruleDayInput);
        form.appendChild(monthField);
      }
      const policyField = document.createElement("label");
      policyField.classList.add("almanac-modal__field");
      policyField.textContent = "Time policy";
      const policySelect = document.createElement("select");
      policySelect.disabled = this.config.isSaving;
      const policies = [
        { value: "all_day", label: "All day" },
        { value: "fixed", label: "Fixed time" },
        { value: "offset", label: "Offset from start" }
      ];
      policies.forEach((option) => {
        const opt = document.createElement("option");
        opt.value = option.value;
        opt.textContent = option.label;
        policySelect.appendChild(opt);
      });
      policySelect.value = this.draft.timePolicy;
      policySelect.addEventListener("change", () => {
        this.config.onUpdate({ timePolicy: policySelect.value });
      });
      policyField.appendChild(policySelect);
      form.appendChild(policyField);
      const boundsField = document.createElement("div");
      boundsField.classList.add("almanac-modal__field", "almanac-modal__field--inline");
      const boundsLabel = document.createElement("span");
      boundsLabel.textContent = "End date";
      boundsField.appendChild(boundsLabel);
      const endYearInput = document.createElement("input");
      endYearInput.type = "number";
      endYearInput.min = "1";
      endYearInput.value = this.draft.boundsEndYear;
      endYearInput.disabled = this.config.isSaving;
      endYearInput.addEventListener("input", () => {
        this.config.onUpdate({ boundsEndYear: endYearInput.value });
      });
      boundsField.appendChild(endYearInput);
      const endMonthSelect = document.createElement("select");
      endMonthSelect.disabled = this.config.isSaving;
      (calendarOption?.months ?? []).forEach((month) => {
        const opt = document.createElement("option");
        opt.value = month.id;
        opt.textContent = month.name;
        endMonthSelect.appendChild(opt);
      });
      endMonthSelect.value = this.draft.boundsEndMonthId || "";
      endMonthSelect.addEventListener("change", () => {
        this.config.onUpdate({ boundsEndMonthId: endMonthSelect.value });
      });
      boundsField.appendChild(endMonthSelect);
      const endDayInput = document.createElement("input");
      endDayInput.type = "number";
      endDayInput.min = "1";
      endDayInput.value = this.draft.boundsEndDay;
      endDayInput.disabled = this.config.isSaving;
      endDayInput.addEventListener("input", () => {
        this.config.onUpdate({ boundsEndDay: endDayInput.value });
      });
      boundsField.appendChild(endDayInput);
      form.appendChild(boundsField);
    }
    const previewSection = document.createElement("div");
    previewSection.classList.add("almanac-modal__preview");
    form.appendChild(previewSection);
    const previewHeading = document.createElement("h3");
    previewHeading.textContent = "Upcoming occurrences";
    previewSection.appendChild(previewHeading);
    if (this.config.preview.length === 0) {
      const emptyPreview = document.createElement("p");
      emptyPreview.textContent = "No preview available yet.";
      previewSection.appendChild(emptyPreview);
    } else {
      const list = document.createElement("ul");
      this.config.preview.slice(0, 5).forEach((item) => {
        const listItem = document.createElement("li");
        listItem.textContent = item.label;
        list.appendChild(listItem);
      });
      previewSection.appendChild(list);
    }
    const actions = document.createElement("div");
    actions.classList.add("almanac-modal__actions");
    form.appendChild(actions);
    const saveButton = document.createElement("button");
    saveButton.type = "submit";
    saveButton.textContent = this.config.isSaving ? "Saving\u2026" : "Save event";
    saveButton.classList.add("almanac-control-button");
    saveButton.dataset.role = "save-event";
    saveButton.disabled = this.config.isSaving;
    actions.appendChild(saveButton);
    const cancelButton = document.createElement("button");
    cancelButton.type = "button";
    cancelButton.textContent = "Cancel";
    cancelButton.classList.add("almanac-control-button");
    cancelButton.disabled = this.config.isSaving;
    cancelButton.addEventListener("click", () => {
      this.config.onCancel();
    });
    actions.appendChild(cancelButton);
    if (this.config.onDelete && this.draft.id) {
      const deleteButton = document.createElement("button");
      deleteButton.type = "button";
      deleteButton.textContent = "Delete";
      deleteButton.classList.add("almanac-control-button");
      deleteButton.dataset.role = "delete-event";
      deleteButton.disabled = this.config.isSaving;
      deleteButton.addEventListener("click", () => {
        this.config.onDelete?.();
      });
      actions.appendChild(deleteButton);
    }
  }
};
var PhenomenonEditorModal = class extends import_obsidian31.Modal {
  constructor(app, draft, config) {
    super(app);
    this.container = null;
    this.nameInput = null;
    this.categoryInput = null;
    this.visibilitySelect = null;
    this.notesInput = null;
    this.calendarCheckboxes = /* @__PURE__ */ new Map();
    this.saveButton = null;
    this.cancelButton = null;
    this.errorEl = null;
    this.draft = { ...draft };
    this.calendars = config.calendars;
    this.isSaving = config.isSaving;
    this.error = config.error;
    this.onSave = config.onSave;
    this.onCancel = config.onCancel;
  }
  open() {
    super.open();
    this.render();
  }
  update(draft, config) {
    this.draft = { ...draft };
    if (config.calendars) {
      this.calendars = config.calendars;
      this.renderCalendars();
    }
    this.isSaving = config.isSaving;
    this.error = config.error;
    this.syncForm();
  }
  close() {
    this.container?.remove();
    this.container = null;
    this.calendarCheckboxes.clear();
    super.close();
  }
  render() {
    this.container = document.createElement("div");
    this.container.classList.add("almanac-modal");
    this.container.dataset.modal = "phenomenon-editor";
    const form = document.createElement("form");
    form.classList.add("almanac-modal__form");
    this.container.appendChild(form);
    const heading = document.createElement("h2");
    heading.textContent = "Phenomenon Editor";
    form.appendChild(heading);
    const nameField = document.createElement("label");
    nameField.classList.add("almanac-modal__field");
    nameField.textContent = "Name";
    this.nameInput = document.createElement("input");
    this.nameInput.type = "text";
    this.nameInput.required = true;
    this.nameInput.addEventListener("input", () => {
      this.draft = { ...this.draft, name: this.nameInput.value };
    });
    nameField.appendChild(this.nameInput);
    form.appendChild(nameField);
    const categoryField = document.createElement("label");
    categoryField.classList.add("almanac-modal__field");
    categoryField.textContent = "Category";
    this.categoryInput = document.createElement("input");
    this.categoryInput.type = "text";
    this.categoryInput.addEventListener("input", () => {
      this.draft = { ...this.draft, category: this.categoryInput.value };
    });
    categoryField.appendChild(this.categoryInput);
    form.appendChild(categoryField);
    const visibilityField = document.createElement("label");
    visibilityField.classList.add("almanac-modal__field");
    visibilityField.textContent = "Visibility";
    this.visibilitySelect = document.createElement("select");
    const optionAll = document.createElement("option");
    optionAll.value = "all_calendars";
    optionAll.textContent = "All calendars";
    this.visibilitySelect.appendChild(optionAll);
    const optionSelected = document.createElement("option");
    optionSelected.value = "selected";
    optionSelected.textContent = "Selected calendars";
    this.visibilitySelect.appendChild(optionSelected);
    this.visibilitySelect.addEventListener("change", () => {
      const visibility = this.visibilitySelect.value;
      const appliesTo = visibility === "all_calendars" ? [] : this.draft.appliesToCalendarIds;
      this.draft = { ...this.draft, visibility, appliesToCalendarIds: appliesTo };
      this.syncCalendarCheckboxes();
    });
    visibilityField.appendChild(this.visibilitySelect);
    form.appendChild(visibilityField);
    const calendarWrapper = document.createElement("div");
    calendarWrapper.classList.add("almanac-modal__field");
    const calendarLabel = document.createElement("span");
    calendarLabel.textContent = "Calendars";
    calendarWrapper.appendChild(calendarLabel);
    const calendarList = document.createElement("div");
    calendarList.classList.add("almanac-modal__checkboxes");
    calendarWrapper.appendChild(calendarList);
    form.appendChild(calendarWrapper);
    this.renderCalendars(calendarList);
    const notesField = document.createElement("label");
    notesField.classList.add("almanac-modal__field");
    notesField.textContent = "Notes";
    this.notesInput = document.createElement("textarea");
    this.notesInput.rows = 4;
    this.notesInput.addEventListener("input", () => {
      this.draft = { ...this.draft, notes: this.notesInput.value };
    });
    notesField.appendChild(this.notesInput);
    form.appendChild(notesField);
    this.errorEl = document.createElement("div");
    this.errorEl.classList.add("almanac-modal__error");
    form.appendChild(this.errorEl);
    const actions = document.createElement("div");
    actions.classList.add("almanac-modal__actions");
    this.cancelButton = document.createElement("button");
    this.cancelButton.type = "button";
    this.cancelButton.textContent = "Cancel";
    this.cancelButton.addEventListener("click", (event) => {
      event.preventDefault();
      this.onCancel();
    });
    actions.appendChild(this.cancelButton);
    this.saveButton = document.createElement("button");
    this.saveButton.type = "submit";
    this.saveButton.textContent = "Save";
    actions.appendChild(this.saveButton);
    form.appendChild(actions);
    form.addEventListener("submit", (event) => {
      event.preventDefault();
      this.onSave({ ...this.draft });
    });
    document.body.appendChild(this.container);
    this.syncForm();
  }
  renderCalendars(host) {
    const target = host ?? this.container?.querySelector(".almanac-modal__checkboxes");
    if (!target) {
      return;
    }
    target.textContent = "";
    this.calendarCheckboxes.clear();
    this.calendars.forEach((calendar) => {
      const label = document.createElement("label");
      label.classList.add("almanac-modal__checkbox");
      const input = document.createElement("input");
      input.type = "checkbox";
      input.value = calendar.id;
      input.addEventListener("change", () => {
        const existing = new Set(this.draft.appliesToCalendarIds);
        if (input.checked) {
          existing.add(calendar.id);
        } else {
          existing.delete(calendar.id);
        }
        this.draft = { ...this.draft, appliesToCalendarIds: Array.from(existing) };
      });
      label.appendChild(input);
      const span = document.createElement("span");
      span.textContent = calendar.name;
      label.appendChild(span);
      target.appendChild(label);
      this.calendarCheckboxes.set(calendar.id, input);
    });
    this.syncCalendarCheckboxes();
  }
  syncCalendarCheckboxes() {
    for (const [id, checkbox] of this.calendarCheckboxes.entries()) {
      checkbox.checked = this.draft.appliesToCalendarIds.includes(id);
      checkbox.disabled = this.draft.visibility === "all_calendars";
    }
  }
  syncForm() {
    if (!this.container) {
      return;
    }
    if (this.nameInput) {
      this.nameInput.value = this.draft.name;
    }
    if (this.categoryInput) {
      this.categoryInput.value = this.draft.category;
    }
    if (this.visibilitySelect) {
      this.visibilitySelect.value = this.draft.visibility;
    }
    if (this.notesInput) {
      this.notesInput.value = this.draft.notes ?? "";
    }
    this.syncCalendarCheckboxes();
    if (this.saveButton) {
      this.saveButton.disabled = this.isSaving;
    }
    if (this.cancelButton) {
      this.cancelButton.disabled = this.isSaving;
    }
    if (this.errorEl) {
      this.errorEl.textContent = this.error ?? "";
      this.errorEl.classList.toggle("is-visible", Boolean(this.error));
    }
  }
};
var EventImportDialog = class extends import_obsidian31.Modal {
  constructor(app, config) {
    super(app);
    this.value = "";
    this.container = null;
    this.textarea = null;
    this.saveButton = null;
    this.cancelButton = null;
    this.errorEl = null;
    this.isLoading = config.isLoading;
    this.error = config.error;
    this.onSubmit = config.onSubmit;
    this.onCancel = config.onCancel;
  }
  open() {
    super.open();
    this.render();
  }
  update(config) {
    this.isLoading = config.isLoading;
    this.error = config.error;
    this.sync();
  }
  close() {
    this.container?.remove();
    this.container = null;
    super.close();
  }
  render() {
    this.container = document.createElement("div");
    this.container.classList.add("almanac-modal");
    this.container.dataset.modal = "event-import";
    const form = document.createElement("form");
    form.classList.add("almanac-modal__form");
    this.container.appendChild(form);
    const heading = document.createElement("h2");
    heading.textContent = "Import Phenomena";
    form.appendChild(heading);
    this.textarea = document.createElement("textarea");
    this.textarea.rows = 8;
    this.textarea.dataset.role = "import-input";
    this.textarea.addEventListener("input", () => {
      this.value = this.textarea.value;
    });
    form.appendChild(this.textarea);
    this.errorEl = document.createElement("div");
    this.errorEl.classList.add("almanac-modal__error");
    form.appendChild(this.errorEl);
    const actions = document.createElement("div");
    actions.classList.add("almanac-modal__actions");
    this.cancelButton = document.createElement("button");
    this.cancelButton.type = "button";
    this.cancelButton.textContent = "Cancel";
    this.cancelButton.addEventListener("click", (event) => {
      event.preventDefault();
      this.onCancel();
    });
    actions.appendChild(this.cancelButton);
    this.saveButton = document.createElement("button");
    this.saveButton.type = "submit";
    this.saveButton.textContent = "Import";
    actions.appendChild(this.saveButton);
    form.appendChild(actions);
    form.addEventListener("submit", (event) => {
      event.preventDefault();
      this.onSubmit(this.value);
    });
    document.body.appendChild(this.container);
    this.sync();
  }
  sync() {
    if (this.textarea && this.textarea.value !== this.value) {
      this.textarea.value = this.value;
    }
    if (this.saveButton) {
      this.saveButton.disabled = this.isLoading;
    }
    if (this.cancelButton) {
      this.cancelButton.disabled = this.isLoading;
    }
    if (this.errorEl) {
      this.errorEl.textContent = this.error ?? "";
      this.errorEl.classList.toggle("is-visible", Boolean(this.error));
    }
  }
};
var AlmanacController = class {
  constructor(app, deps = {}) {
    this.app = app;
    this.containerEl = null;
    this.unsubscribe = null;
    this.currentState = null;
    this.showTimeJumpForm = false;
    this.phenomenonEditorModal = null;
    this.eventEditorModal = null;
    this.eventImportModal = null;
    this.cartographerBridge = null;
    this.protocolRef = null;
    this.pendingDeepLink = null;
    this.isSyncingDeepLink = false;
    this.lastDeepLinkUrl = null;
    this.allowDeepLinkSync = false;
    // Split-view components
    this.splitView = null;
    this.calendarView = null;
    this.contentContainer = null;
    this.handleProtocolUrl = (rawUrl) => {
      if (this.isSyncingDeepLink) {
        return;
      }
      const overrides = this.parseDeepLink(rawUrl);
      if (!overrides) {
        return;
      }
      this.pendingDeepLink = overrides;
      if (!this.containerEl) {
        return;
      }
      this.allowDeepLinkSync = false;
      const travelId = overrides && Object.prototype.hasOwnProperty.call(overrides, "travelId") ? overrides.travelId ?? null : void 0;
      void this.runDispatch({ type: "INIT_ALMANAC", travelId, overrides }).finally(() => {
        this.pendingDeepLink = null;
        this.allowDeepLinkSync = true;
        if (this.currentState) {
          this.syncDeepLink(this.currentState);
        }
      });
    };
    const calendarRepo = deps.calendarRepo ?? new InMemoryCalendarRepository();
    const eventRepo = deps.eventRepo ?? new InMemoryEventRepository();
    if (eventRepo instanceof InMemoryEventRepository) {
      eventRepo.bindCalendarRepository(calendarRepo);
    }
    const phenomenonRepo = deps.phenomenonRepo ?? new InMemoryPhenomenonRepository();
    const gateway = deps.gateway ?? new InMemoryStateGateway(calendarRepo, eventRepo, phenomenonRepo);
    this.calendarRepo = calendarRepo;
    this.eventRepo = eventRepo;
    this.phenomenonRepo = phenomenonRepo;
    this.gateway = gateway;
    this.stateMachine = new AlmanacStateMachine(
      this.calendarRepo,
      this.eventRepo,
      this.gateway,
      this.phenomenonRepo
    );
    this.ensureProtocolHandler();
  }
  async onOpen(container) {
    await this.onClose();
    this.containerEl = container;
    container.empty();
    container.addClass("almanac-container");
    this.lastDeepLinkUrl = null;
    this.ensureProtocolHandler();
    this.allowDeepLinkSync = false;
    this.cartographerBridge = registerCartographerBridge(this.stateMachine, {
      onRequestJump: () => this.openTimeJumpFromCartographer(),
      onFollowUp: (eventId) => this.handleTravelFollowUp(eventId)
    });
    await ensureDefaultCalendar(this.calendarRepo);
    const activeCalendarId = this.gateway.getActiveCalendarId();
    if (!activeCalendarId) {
      const calendars = await this.calendarRepo.listCalendars();
      const fallback = calendars.find((calendar) => calendar.isDefaultGlobal) ?? calendars[0];
      if (fallback) {
        const initialTimestamp = createDayTimestamp(
          fallback.id,
          fallback.epoch.year,
          fallback.epoch.monthId,
          fallback.epoch.day
        );
        await this.gateway.setActiveCalendar(fallback.id, { initialTimestamp });
      }
    }
    this.unsubscribe = this.stateMachine.subscribe((state) => {
      this.currentState = state;
      this.render(state);
      this.syncDeepLink(state);
    });
    const overrides = this.pendingDeepLink ?? null;
    const travelId = overrides && Object.prototype.hasOwnProperty.call(overrides, "travelId") ? overrides.travelId ?? null : void 0;
    await this.stateMachine.dispatch({
      type: "INIT_ALMANAC",
      travelId,
      overrides: overrides ?? void 0
    });
    this.pendingDeepLink = null;
    this.allowDeepLinkSync = true;
    if (this.currentState) {
      this.syncDeepLink(this.currentState);
    }
  }
  async onClose() {
    this.unsubscribe?.();
    this.unsubscribe = null;
    this.phenomenonEditorModal?.close();
    this.phenomenonEditorModal = null;
    this.eventImportModal?.close();
    this.eventImportModal = null;
    this.eventEditorModal?.close();
    this.eventEditorModal = null;
    this.calendarView?.destroy();
    this.calendarView = null;
    this.contentContainer?.destroy();
    this.contentContainer = null;
    this.splitView?.destroy();
    this.splitView = null;
    this.containerEl = null;
    this.cartographerBridge?.release();
    this.cartographerBridge = null;
    this.allowDeepLinkSync = false;
  }
  render(state) {
    if (!this.containerEl) return;
    if (!this.splitView || !this.calendarView || !this.contentContainer) {
      this.initializeSplitView(state);
    }
    if (this.calendarView && state.calendarViewState) {
      this.calendarView.update(state.calendarViewState);
    }
    if (this.contentContainer) {
      const mode = state.almanacUiState.mode;
      this.contentContainer.setMode(mode);
      switch (mode) {
        case "dashboard":
          this.renderDashboard(this.contentContainer.dashboardElement, state);
          break;
        case "manager":
          this.renderManager(this.contentContainer.managerElement, state);
          break;
        case "events":
          this.renderEvents(this.contentContainer.eventsElement, state);
          break;
      }
    }
    this.syncDialogs(state);
  }
  initializeSplitView(state) {
    if (!this.containerEl) return;
    this.containerEl.empty();
    this.containerEl.addClass("almanac-container");
    this.splitView = createSplitView(this.containerEl, {
      className: "almanac-split-layout",
      initialSplit: 0.6,
      // 60% upper, 40% lower
      minUpperSize: 200,
      minLowerSize: 200,
      orientation: "horizontal",
      resizable: true
    });
    const calendarMode = "month";
    this.calendarView = createCalendarViewContainer(this.app, this.splitView.upperElement, {
      mode: calendarMode,
      state: state.calendarViewState || {
        mode: calendarMode,
        zoom: "month",
        anchorTimestamp: state.calendarState.currentTimestamp,
        events: state.calendarState.upcomingEvents,
        isLoading: false
      },
      onModeChange: (mode) => {
        console.log("Calendar view mode changed:", mode);
      },
      onNavigate: (direction) => {
        if (direction === "prev" || direction === "next") {
          void this.runDispatch({
            type: "MANAGER_NAVIGATION_REQUESTED",
            direction
          });
        } else {
          void this.runDispatch({
            type: "MANAGER_NAVIGATION_REQUESTED",
            direction: "today"
          });
        }
      },
      onEventCreate: (timestamp) => {
        void this.runDispatch({
          type: "EVENT_CREATE_REQUESTED",
          mode: "single",
          calendarId: state.calendarState.activeCalendarId ?? void 0
        });
      },
      onEventSelect: (eventId) => {
        void this.runDispatch({
          type: "EVENT_EDIT_REQUESTED",
          eventId
        });
      }
    });
    const contentMode = state.almanacUiState.mode;
    this.contentContainer = createAlmanacContentContainer(this.app, this.splitView.lowerElement, {
      mode: contentMode,
      onModeChange: (mode) => {
        void this.runDispatch({
          type: "ALMANAC_MODE_SELECTED",
          mode
        });
      }
    });
  }
  renderTitle(host, state) {
    const titleRow = host.createDiv({ cls: "almanac-shell__title-row" });
    const titleGroup = titleRow.createDiv({ cls: "almanac-shell__title-group" });
    titleGroup.createEl("h1", { text: "Almanac" });
    const activeCalendar = this.getActiveCalendar(state);
    const subtitle = titleGroup.createDiv({ cls: "almanac-shell__subtitle" });
    if (activeCalendar) {
      const isDefault = activeCalendar.id === state.calendarState.defaultCalendarId;
      subtitle.setText(`Active calendar: ${activeCalendar.name}${isDefault ? " (Default)" : ""}`);
    } else {
      subtitle.setText("No calendar selected");
    }
    const controls = titleRow.createDiv({ cls: "almanac-shell__controls" });
    this.renderCalendarSelector(controls, state);
  }
  renderCalendarSelector(host, state) {
    if (state.calendarState.calendars.length === 0) {
      const emptyState = host.createDiv({ cls: "almanac-empty-state" });
      emptyState.createEl("h2", { text: "No calendars available" });
      emptyState.createEl("p", {
        text: "Create your first calendar to start planning events."
      });
      const createButton = emptyState.createEl("button", {
        text: "Create calendar",
        cls: "almanac-control-button",
        attr: { "data-action": "create-first-calendar" }
      });
      createButton.disabled = state.almanacUiState.isLoading || state.calendarState.isPersisting;
      createButton.addEventListener("click", () => {
        emitAlmanacEvent({
          type: "calendar.almanac.create_flow",
          source: "calendar-selector",
          availableCalendars: state.calendarState.calendars.length
        });
        void this.runDispatch({ type: "ALMANAC_MODE_SELECTED", mode: "manager" });
        void this.runDispatch({ type: "MANAGER_CREATE_FORM_UPDATED", field: "name", value: "" });
        void this.runDispatch({ type: "MANAGER_CREATE_FORM_UPDATED", field: "id", value: "" });
      });
      return;
    }
    const select = host.createEl("select", { cls: "almanac-calendar-select" });
    select.disabled = state.calendarState.isPersisting || state.almanacUiState.isLoading;
    state.calendarState.calendars.forEach((schema) => {
      const option = select.createEl("option", {
        text: this.describeCalendarOption(schema, state),
        attr: { value: schema.id }
      });
      if (schema.id === state.calendarState.activeCalendarId) {
        option.selected = true;
      }
    });
    select.addEventListener("change", (event) => {
      const target = event.target;
      if (!target.value) return;
      this.runDispatch({ type: "CALENDAR_SELECT_REQUESTED", calendarId: target.value });
    });
    const activeCalendarId = state.calendarState.activeCalendarId;
    if (activeCalendarId) {
      const defaultButton = host.createEl("button", {
        text: "Set as default",
        cls: "almanac-control-button"
      });
      const isDefault = activeCalendarId === state.calendarState.defaultCalendarId;
      defaultButton.disabled = isDefault || state.calendarState.isPersisting;
      if (isDefault) {
        defaultButton.setText("Default calendar");
        defaultButton.disabled = true;
      } else {
        defaultButton.addEventListener("click", () => {
          this.runDispatch({ type: "CALENDAR_DEFAULT_SET_REQUESTED", calendarId: activeCalendarId });
        });
      }
    }
  }
  describeCalendarOption(schema, state) {
    const markers = [];
    if (schema.id === state.calendarState.activeCalendarId) markers.push("active");
    if (schema.id === state.calendarState.defaultCalendarId || schema.isDefaultGlobal) markers.push("default");
    const suffix = markers.length ? ` (${markers.join(", ")})` : "";
    return `${schema.name}${suffix}`;
  }
  renderModeSwitcher(host, state) {
    const switcher = host.createDiv({ cls: "almanac-mode-switcher" });
    ["dashboard", "manager", "events"].forEach((mode) => {
      const entry = MODE_COPY[mode];
      const button = switcher.createEl("button", {
        text: entry.label,
        cls: "almanac-mode-switcher__item"
      });
      button.setAttribute("title", entry.description);
      button.classList.toggle("is-active", state.almanacUiState.mode === mode);
      button.addEventListener("click", () => this.runDispatch({ type: "ALMANAC_MODE_SELECTED", mode }));
    });
  }
  renderStatusBar(host, state) {
    const statusContainer = host.createDiv({ cls: "almanac-shell__status" });
    if (state.almanacUiState.isLoading) {
      statusContainer.addClass("is-loading");
      statusContainer.setText("Loading data\u2026");
      return;
    }
    const summary = state.almanacUiState.statusSummary;
    const tokens = [];
    if (state.calendarState.isPersisting) tokens.push("Saving\u2026");
    if (summary?.zoomLabel) tokens.push(summary.zoomLabel);
    if (summary?.filterCount !== void 0) tokens.push(`Filters: ${summary.filterCount}`);
    if (tokens.length === 0) tokens.push("Ready");
    statusContainer.setText(tokens.join(" \u2022 "));
  }
  renderDashboard(host, state) {
    const calendar = this.getActiveCalendar(state);
    if (!calendar) {
      host.createEl("p", {
        text: "No calendars available. Open the Manager to create one.",
        cls: "almanac-empty"
      });
      return;
    }
    const currentTimestamp = state.calendarState.currentTimestamp;
    const content = host.createDiv({ cls: "almanac-dashboard" });
    const currentSection = content.createDiv({ cls: "almanac-section" });
    currentSection.createEl("h2", { text: "Current Date & Time" });
    if (currentTimestamp) {
      const formatted = this.formatCalendarTimestamp(calendar, currentTimestamp);
      currentSection.createDiv({ cls: "almanac-time-card", text: formatted });
    } else {
      currentSection.createEl("p", { text: "No current timestamp available." });
    }
    this.renderQuickActions(content, state);
    this.renderUpcomingEvents(content, calendar, state.calendarState.upcomingEvents);
    this.renderTriggeredEvents(content, calendar, state.calendarState.triggeredEvents);
    this.renderUpcomingPhenomena(content, calendar, state.calendarState.upcomingPhenomena);
  }
  renderQuickActions(host, state) {
    const section = host.createDiv({ cls: "almanac-section" });
    section.createEl("h2", { text: "Quick Actions" });
    const buttons = section.createDiv({ cls: "almanac-actions" });
    const createButton = (label, amount, unit) => {
      const btn = buttons.createEl("button", { text: label });
      btn.disabled = state.calendarState.isPersisting || state.almanacUiState.isLoading;
      btn.addEventListener("click", () => this.runDispatch({
        type: "TIME_ADVANCE_REQUESTED",
        amount,
        unit
      }));
    };
    createButton("+1 Day", 1, "day");
    createButton("+1 Hour", 1, "hour");
    createButton("+15 Min", 15, "minute");
    const advancedBtn = buttons.createEl("button", { text: "Set Date & Time" });
    advancedBtn.disabled = state.almanacUiState.isLoading;
    advancedBtn.addEventListener("click", () => {
      this.showTimeJumpForm = !this.showTimeJumpForm;
      if (this.currentState) {
        this.render(this.currentState);
      }
    });
    if (this.showTimeJumpForm) {
      this.renderTimeJumpForm(section, state);
    }
  }
  renderTimeJumpForm(section, state) {
    const calendar = this.getActiveCalendar(state);
    if (!calendar) {
      section.createEl("p", { text: "No calendar available for time jump.", cls: "almanac-empty" });
      return;
    }
    const current = state.calendarState.currentTimestamp ?? this.getFallbackTimestamp(state) ?? createDayTimestamp(calendar.id, calendar.epoch.year, calendar.epoch.monthId, calendar.epoch.day);
    const timeDefinition = state.calendarState.timeDefinition;
    const form = section.createEl("form", { cls: "almanac-timejump-form" });
    const row = form.createDiv({ cls: "almanac-timejump-row" });
    const yearInput = row.createEl("input", {
      attr: { type: "number", name: "year", value: String(current.year) }
    });
    const monthSelect = row.createEl("select", { attr: { name: "month" } });
    calendar.months.forEach((month) => {
      const option = monthSelect.createEl("option", { value: month.id, text: month.name });
      if (month.id === current.monthId) option.selected = true;
    });
    const dayInput = row.createEl("input", {
      attr: { type: "number", name: "day", value: String(current.day), min: "1", max: String(this.getMonthLength(calendar, current.monthId)) }
    });
    const timeRow = form.createDiv({ cls: "almanac-timejump-row" });
    const hourInput = timeRow.createEl("input", {
      attr: { type: "number", name: "hour", value: String(current.hour ?? 0), min: "0", max: String((timeDefinition?.hoursPerDay ?? 24) - 1) }
    });
    const minuteInput = timeRow.createEl("input", {
      attr: { type: "number", name: "minute", value: String(current.minute ?? 0), min: "0", max: String((timeDefinition?.minutesPerHour ?? 60) - 1) }
    });
    const note = form.createDiv({ cls: "almanac-timejump-note" });
    note.setText("Enter a target date/time for the active calendar. Minute precision respects the configured schema.");
    const buildTargetTimestamp = () => {
      const year = Number(yearInput.value);
      const monthId = monthSelect.value || calendar.months[0]?.id;
      const dayValue = Number(dayInput.value);
      if (!monthId || Number.isNaN(year) || Number.isNaN(dayValue) || year <= 0) {
        return null;
      }
      const monthLength = this.getMonthLength(calendar, monthId);
      const clampedDay = Math.max(1, Math.min(dayValue, monthLength));
      if (timeDefinition) {
        const hoursPerDay = timeDefinition.hoursPerDay ?? 24;
        const minutesPerHour = timeDefinition.minutesPerHour ?? 60;
        const minuteStep = timeDefinition.minuteStep ?? 1;
        const hourValue2 = Number(hourInput.value ?? 0);
        const minuteValue = Number(minuteInput.value ?? 0);
        const clampedHour = Math.max(0, Math.min(isNaN(hourValue2) ? 0 : hourValue2, hoursPerDay - 1));
        const clampedMinuteRaw = Math.max(0, Math.min(isNaN(minuteValue) ? 0 : minuteValue, minutesPerHour - 1));
        const clampedMinute = Math.floor(clampedMinuteRaw / minuteStep) * minuteStep;
        return createMinuteTimestamp(calendar.id, year, monthId, clampedDay, clampedHour, clampedMinute);
      }
      const hourValue = Number(hourInput.value ?? 0);
      if (!Number.isNaN(hourValue)) {
        const clampedHour = Math.max(0, Math.min(hourValue, 23));
        return createHourTimestamp(calendar.id, year, monthId, clampedDay, clampedHour);
      }
      return createDayTimestamp(calendar.id, year, monthId, clampedDay);
    };
    const actions = form.createDiv({ cls: "almanac-timejump-actions" });
    const previewBtn = actions.createEl("button", { text: "Preview", attr: { type: "button" } });
    previewBtn.disabled = state.almanacUiState.isLoading;
    const applyBtn = actions.createEl("button", { text: "Apply", attr: { type: "submit" } });
    applyBtn.disabled = state.almanacUiState.isLoading;
    const cancelBtn = actions.createEl("button", { text: "Cancel", attr: { type: "button" } });
    cancelBtn.addEventListener("click", () => {
      this.showTimeJumpForm = false;
      if (this.currentState) {
        this.render(this.currentState);
      }
    });
    previewBtn.addEventListener("click", async () => {
      const target = buildTargetTimestamp();
      if (!target) {
        console.warn("Invalid preview target supplied");
        return;
      }
      await this.runDispatch({ type: "TIME_JUMP_PREVIEW_REQUESTED", timestamp: target });
    });
    form.addEventListener("submit", (event) => {
      event.preventDefault();
      const year = Number(yearInput.value);
      const monthId = monthSelect.value || calendar.months[0]?.id;
      const day = Number(dayInput.value);
      const hour = Number(hourInput.value);
      const minute = Number(minuteInput.value);
      if (!monthId || Number.isNaN(year) || Number.isNaN(day) || year <= 0 || day <= 0) {
        console.warn("Invalid date supplied");
        return;
      }
      const monthLength = this.getMonthLength(calendar, monthId);
      const clampedDay = Math.max(1, Math.min(day, monthLength));
      let target;
      if (timeDefinition) {
        const clampedHour = Math.max(0, Math.min(hour, timeDefinition.hoursPerDay - 1));
        const clampedMinute = Math.max(0, Math.min(minute, timeDefinition.minutesPerHour - 1));
        target = createMinuteTimestamp(calendar.id, year, monthId, clampedDay, clampedHour, clampedMinute);
      } else if (!Number.isNaN(hour)) {
        const clampedHour = Math.max(0, Math.min(hour, 23));
        target = createHourTimestamp(calendar.id, year, monthId, clampedDay, clampedHour);
      } else {
        target = createDayTimestamp(calendar.id, year, monthId, clampedDay);
      }
      const dispatchResult = this.runDispatch({ type: "TIME_JUMP_REQUESTED", timestamp: target });
      dispatchResult?.finally(() => {
        this.showTimeJumpForm = false;
        if (this.currentState) {
          this.render(this.currentState);
        }
      });
    });
    if (state.managerUiState.jumpPreview.length > 0) {
      const previewBox = form.createDiv({ cls: "almanac-timejump-warnings" });
      previewBox.createEl("strong", { text: "Events affected:" });
      const list = previewBox.createEl("ul");
      state.managerUiState.jumpPreview.forEach((event) => {
        const item = list.createEl("li");
        item.setText(`${event.title} \u2014 ${this.formatCalendarTimestamp(calendar, event.date)}`);
      });
    }
  }
  getMonthLength(calendar, monthId) {
    const month = calendar.months.find((m) => m.id === monthId);
    return month?.length ?? calendar.months[0]?.length ?? 30;
  }
  renderUpcomingEvents(host, calendar, events) {
    const section = host.createDiv({ cls: "almanac-section" });
    section.createEl("h2", { text: "Upcoming Events" });
    if (events.length === 0) {
      section.createEl("p", { text: "No upcoming events", cls: "almanac-empty" });
      return;
    }
    this.renderEventList(section, calendar, events);
  }
  renderTriggeredEvents(host, calendar, events) {
    if (events.length === 0) return;
    const section = host.createDiv({ cls: "almanac-section" });
    section.createEl("h2", { text: "Recently Triggered" });
    this.renderEventList(section, calendar, events);
  }
  renderUpcomingPhenomena(host, calendar, phenomena) {
    if (phenomena.length === 0) {
      return;
    }
    const section = host.createDiv({ cls: "almanac-section" });
    section.createEl("h2", { text: "Upcoming Phenomena" });
    const list = section.createEl("ul", { cls: "almanac-event-list" });
    phenomena.forEach((occurrence) => {
      const item = list.createEl("li", { cls: "almanac-event-item" });
      item.createEl("strong", { text: occurrence.name });
      item.createEl("span", {
        text: ` \u2014 ${formatTimestamp(occurrence.timestamp, getMonthById(calendar, occurrence.timestamp.monthId)?.name ?? occurrence.timestamp.monthId)} (${occurrence.category})`
      });
    });
  }
  renderEventList(host, calendar, events) {
    const list = host.createEl("ul", { cls: "almanac-event-list" });
    events.forEach((event) => {
      const item = list.createEl("li", { cls: "almanac-event-item" });
      item.createEl("strong", { text: event.title });
      item.createEl("span", {
        text: ` \u2014 ${this.formatCalendarTimestamp(calendar, event.date)}`,
        cls: "almanac-event-time"
      });
      if (event.description) {
        item.createEl("div", { text: event.description, cls: "almanac-event-desc" });
      }
    });
  }
  renderManager(host, state) {
    const section = host.createDiv({ cls: "almanac-manager" });
    const creationSection = section.createDiv({ cls: "almanac-section almanac-manager__create" });
    this.renderCalendarCreateForm(creationSection, state);
    const eventCreateSection = creationSection.createDiv({ cls: "almanac-manager__event-create" });
    eventCreateSection.createEl("h3", { text: "Create event" });
    const eventButtons = eventCreateSection.createDiv({ cls: "almanac-manager__event-buttons" });
    const managerSingleButton = eventButtons.createEl("button", {
      text: "Single event",
      cls: "almanac-control-button",
      attr: { "data-action": "manager-event-single" }
    });
    managerSingleButton.addEventListener("click", () => {
      this.runDispatch({ type: "EVENT_CREATE_REQUESTED", mode: "single" });
    });
    const managerRecurringButton = eventButtons.createEl("button", {
      text: "Recurring event",
      cls: "almanac-control-button",
      attr: { "data-action": "manager-event-recurring" }
    });
    managerRecurringButton.addEventListener("click", () => {
      this.runDispatch({ type: "EVENT_CREATE_REQUESTED", mode: "recurring" });
    });
    const header = section.createDiv({ cls: "almanac-manager__controls" });
    const modeGroup = header.createDiv({ cls: "almanac-toggle-group" });
    MANAGER_VIEW_OPTIONS.forEach((option) => {
      const btn = modeGroup.createEl("button", { text: option === "calendar" ? "Calendar" : "Overview" });
      btn.classList.toggle("is-active", state.managerUiState.viewMode === option);
      btn.addEventListener("click", () => this.runDispatch({
        type: "MANAGER_VIEW_MODE_CHANGED",
        viewMode: option
      }));
    });
    const zoomGroup = header.createDiv({ cls: "almanac-toggle-group" });
    MANAGER_ZOOM_OPTIONS.forEach((option) => {
      const label = option.charAt(0).toUpperCase() + option.slice(1);
      const btn = zoomGroup.createEl("button", { text: label });
      btn.classList.toggle("is-active", state.managerUiState.zoom === option);
      btn.addEventListener("click", () => this.runDispatch({
        type: "MANAGER_ZOOM_CHANGED",
        zoom: option
      }));
    });
    if (state.managerUiState.error) {
      const err = section.createDiv({ cls: "almanac-section almanac-section--error" });
      err.setText(state.managerUiState.error);
    }
    if (state.managerUiState.viewMode === "overview") {
      this.renderCalendarOverview(section, state);
    } else {
      this.renderManagerCalendarView(section, state);
    }
  }
  renderCalendarCreateForm(host, state) {
    host.createEl("h2", { text: "Create calendar" });
    host.createEl("p", {
      text: "Define a quick calendar skeleton. You can refine months and events later in the manager.",
      cls: "almanac-section__helper"
    });
    if (state.managerUiState.createErrors.length > 0) {
      const errorList = host.createEl("ul", { cls: "almanac-form-errors" });
      state.managerUiState.createErrors.forEach((message) => {
        errorList.createEl("li", { text: message });
      });
    }
    const form = host.createEl("form", { cls: "almanac-create-form" });
    form.addEventListener("submit", (event) => {
      event.preventDefault();
      void this.runDispatch({ type: "CALENDAR_CREATE_REQUESTED" });
    });
    const grid = form.createDiv({ cls: "almanac-create-form__grid" });
    const { createDraft, isCreating } = state.managerUiState;
    const isDisabled = isCreating || state.calendarState.isPersisting;
    const buildInput = (field, label, options = {}) => {
      const wrapper = grid.createDiv({ cls: "almanac-form-field" });
      wrapper.createEl("label", { text: label, attr: { for: `almanac-${field}` } });
      const input = wrapper.createEl("input", {
        attr: {
          id: `almanac-${field}`,
          name: `almanac-${field}`,
          type: options.type ?? "text",
          value: createDraft[field],
          ...options.min ? { min: options.min } : {},
          ...options.step ? { step: options.step } : {}
        }
      });
      input.disabled = isDisabled;
      input.addEventListener("input", () => {
        void this.runDispatch({
          type: "MANAGER_CREATE_FORM_UPDATED",
          field,
          value: input.value
        });
      });
      return input;
    };
    buildInput("id", "Identifier");
    buildInput("name", "Name");
    const descriptionWrapper = grid.createDiv({ cls: "almanac-form-field almanac-form-field--wide" });
    descriptionWrapper.createEl("label", { text: "Description", attr: { for: "almanac-description" } });
    const description = descriptionWrapper.createEl("textarea", {
      attr: { id: "almanac-description", rows: "2" },
      text: createDraft.description
    });
    description.disabled = isDisabled;
    description.addEventListener("input", () => {
      void this.runDispatch({
        type: "MANAGER_CREATE_FORM_UPDATED",
        field: "description",
        value: description.value
      });
    });
    buildInput("daysPerWeek", "Days per week", { type: "number", min: "1", step: "1" });
    buildInput("monthCount", "Months per year", { type: "number", min: "1", step: "1" });
    buildInput("monthLength", "Days per month", { type: "number", min: "1", step: "1" });
    buildInput("hoursPerDay", "Hours per day", { type: "number", min: "1", step: "1" });
    buildInput("minutesPerHour", "Minutes per hour", { type: "number", min: "1", step: "1" });
    buildInput("minuteStep", "Minute step", { type: "number", min: "1", step: "1" });
    buildInput("epochYear", "Epoch year", { type: "number", min: "1", step: "1" });
    buildInput("epochDay", "Epoch day", { type: "number", min: "1", step: "1" });
    const actions = form.createDiv({ cls: "almanac-create-form__actions" });
    const submit = actions.createEl("button", {
      text: isCreating ? "Creating\u2026" : "Create calendar",
      attr: { type: "submit" }
    });
    submit.disabled = isDisabled;
  }
  renderCalendarOverview(host, state) {
    const conflict = state.managerUiState.conflictDialog;
    if (conflict) {
      const banner = host.createDiv({ cls: "almanac-section almanac-section--error" });
      banner.createEl("h3", { text: "Calendar conflict" });
      banner.createEl("p", { text: conflict.message });
      if (conflict.details.length > 0) {
        const list = banner.createEl("ul", { cls: "almanac-form-errors" });
        conflict.details.forEach((detail) => list.createEl("li", { text: detail }));
      }
      const dismiss = banner.createEl("button", { text: "Dismiss" });
      dismiss.addEventListener("click", () => {
        void this.runDispatch({ type: "CALENDAR_CONFLICT_DISMISSED" });
      });
    }
    const deleteDialog = state.managerUiState.deleteDialog;
    if (deleteDialog) {
      const dialog = host.createDiv({ cls: "almanac-section almanac-section--warning" });
      dialog.createEl("h3", { text: `Delete ${deleteDialog.calendarName}?` });
      dialog.createEl("p", {
        text: "Deleting a calendar removes it from the Almanac. This action cannot be undone."
      });
      if (deleteDialog.requiresFallback) {
        dialog.createEl("p", { text: "A different calendar will be promoted to the default selection." });
      }
      if (deleteDialog.linkedTravelIds.length > 0) {
        const travelList = dialog.createEl("ul");
        dialog.createEl("p", { text: "Travel defaults to clear:" });
        deleteDialog.linkedTravelIds.forEach((travelId) => travelList.createEl("li", { text: travelId }));
      }
      if (deleteDialog.linkedPhenomena.length > 0) {
        const phenomenaList = dialog.createEl("ul", { cls: "almanac-form-errors" });
        dialog.createEl("p", { text: "Linked phenomena preventing deletion:" });
        deleteDialog.linkedPhenomena.forEach((name) => phenomenaList.createEl("li", { text: name }));
      }
      if (deleteDialog.error) {
        dialog.createEl("p", { text: deleteDialog.error, cls: "almanac-form-errors" });
      }
      const actions = dialog.createDiv({ cls: "almanac-create-form__actions" });
      const confirm = actions.createEl("button", {
        text: deleteDialog.isDeleting ? "Deleting\u2026" : "Delete calendar",
        attr: { type: "button" }
      });
      confirm.disabled = deleteDialog.isDeleting || deleteDialog.linkedPhenomena.length > 0;
      confirm.addEventListener("click", () => {
        void this.runDispatch({
          type: "CALENDAR_DELETE_CONFIRMED",
          calendarId: deleteDialog.calendarId
        });
      });
      const cancel = actions.createEl("button", { text: "Cancel", attr: { type: "button" } });
      cancel.disabled = deleteDialog.isDeleting;
      cancel.addEventListener("click", () => {
        void this.runDispatch({ type: "CALENDAR_DELETE_CANCELLED" });
      });
    }
    const table = host.createEl("table", { cls: "almanac-table" });
    const thead = table.createEl("thead");
    const headRow = thead.createEl("tr");
    const selectAllHeader = headRow.createEl("th");
    const selectAll = selectAllHeader.createEl("input", { attr: { type: "checkbox" } });
    const totalCalendars = state.calendarState.calendars.length;
    const selectedCount = state.managerUiState.selection.length;
    selectAll.indeterminate = selectedCount > 0 && selectedCount < totalCalendars;
    selectAll.checked = selectedCount > 0 && selectedCount === totalCalendars;
    selectAll.addEventListener("change", () => {
      const nextSelection = selectAll.checked ? state.calendarState.calendars.map((schema) => schema.id) : [];
      this.runDispatch({ type: "MANAGER_SELECTION_CHANGED", selection: nextSelection });
    });
    ["Name", "Identifier", "Default", "Months", "Actions"].forEach((label) => headRow.createEl("th", { text: label }));
    const body = table.createEl("tbody");
    if (state.calendarState.calendars.length === 0) {
      const row = body.createEl("tr");
      const cell = row.createEl("td", { text: "No calendars registered", cls: "almanac-empty" });
      cell.setAttr("colspan", "6");
      return;
    }
    state.calendarState.calendars.forEach((schema) => {
      const row = body.createEl("tr");
      const isActive = schema.id === state.calendarState.activeCalendarId;
      if (isActive) row.addClass("is-active");
      const selectCell = row.createEl("td", { cls: "almanac-row-select-cell" });
      const checkboxLabel = selectCell.createEl("label", { cls: "almanac-row-select" });
      const checkbox = checkboxLabel.createEl("input", {
        attr: { type: "checkbox", value: schema.id }
      });
      checkbox.checked = state.managerUiState.selection.includes(schema.id);
      checkbox.addEventListener("change", () => {
        const currentSelection = this.currentState?.managerUiState.selection ?? [];
        const nextSelection = checkbox.checked ? [...currentSelection, schema.id] : currentSelection.filter((id) => id !== schema.id);
        this.runDispatch({ type: "MANAGER_SELECTION_CHANGED", selection: nextSelection });
      });
      checkboxLabel.createEl("span", { text: "Select" });
      const nameCell = row.createEl("td", { cls: "almanac-table__name-cell" });
      nameCell.createDiv({ text: schema.name, cls: "almanac-table__name" });
      if (schema.description) {
        nameCell.createDiv({ text: schema.description, cls: "almanac-table__description" });
      }
      row.createEl("td", { text: schema.id });
      const defaultCell = row.createEl("td");
      const isDefault = schema.id === state.calendarState.defaultCalendarId || schema.isDefaultGlobal;
      defaultCell.setText(isDefault ? "Default" : "\u2014");
      row.createEl("td", { text: String(schema.months.length) });
      const actions = row.createEl("td");
      const editState = state.managerUiState.editStateById[schema.id];
      const selectBtn = actions.createEl("button", { text: isActive ? "Active" : "Activate" });
      selectBtn.disabled = isActive || state.calendarState.isPersisting;
      if (!isActive) {
        selectBtn.addEventListener("click", () => {
          this.runDispatch({ type: "CALENDAR_SELECT_REQUESTED", calendarId: schema.id });
        });
      }
      const defaultBtn = actions.createEl("button", { text: "Set Default" });
      defaultBtn.disabled = isDefault || state.calendarState.isPersisting;
      if (isDefault) {
        defaultBtn.setText("Default");
      } else {
        defaultBtn.addEventListener("click", () => {
          this.runDispatch({ type: "CALENDAR_DEFAULT_SET_REQUESTED", calendarId: schema.id });
        });
      }
      const editBtn = actions.createEl("button", { text: "Edit" });
      editBtn.disabled = Boolean(state.calendarState.isPersisting || editState?.isSaving);
      editBtn.addEventListener("click", () => {
        void this.runDispatch({ type: "CALENDAR_EDIT_REQUESTED", calendarId: schema.id });
      });
      const deleteBtn = actions.createEl("button", { text: "Delete" });
      deleteBtn.classList.add("almanac-button--danger");
      deleteBtn.disabled = Boolean(state.managerUiState.deleteDialog?.isDeleting);
      deleteBtn.addEventListener("click", () => {
        void this.runDispatch({ type: "CALENDAR_DELETE_REQUESTED", calendarId: schema.id });
      });
      if (editState) {
        const editRow = body.createEl("tr", { cls: "almanac-calendar-edit-row" });
        const editCell = editRow.createEl("td", { attr: { colspan: "6" } });
        const form = editCell.createEl("form", { cls: "almanac-edit-form" });
        form.addEventListener("submit", (event) => {
          event.preventDefault();
          void this.runDispatch({ type: "CALENDAR_UPDATE_REQUESTED", calendarId: schema.id });
        });
        form.createEl("h4", { text: `Edit ${schema.name}` });
        if (editState.errors.length > 0) {
          const errorList = form.createEl("ul", { cls: "almanac-form-errors" });
          editState.errors.forEach((message) => errorList.createEl("li", { text: message }));
        }
        if (editState.warnings.length > 0) {
          const warningList = form.createEl("ul", { cls: "almanac-form-errors almanac-form-errors--warning" });
          editState.warnings.forEach((message) => warningList.createEl("li", { text: message }));
        }
        const buildField = (label, field, options) => {
          const wrapper = form.createEl("label", { cls: "almanac-modal__field" });
          wrapper.createEl("span", { text: label });
          if (options.multiline) {
            const textarea = wrapper.createEl("textarea");
            textarea.value = editState.draft[field];
            textarea.disabled = editState.isSaving;
            textarea.addEventListener("input", () => {
              void this.runDispatch({
                type: "CALENDAR_EDIT_FORM_UPDATED",
                calendarId: schema.id,
                field,
                value: textarea.value
              });
            });
          } else {
            const input = wrapper.createEl("input");
            input.type = options.type;
            if (options.min) input.min = options.min;
            if (options.step) input.step = options.step;
            input.value = editState.draft[field];
            input.disabled = editState.isSaving;
            input.addEventListener("input", () => {
              void this.runDispatch({
                type: "CALENDAR_EDIT_FORM_UPDATED",
                calendarId: schema.id,
                field,
                value: input.value
              });
            });
          }
        };
        buildField("Name", "name", { type: "text" });
        buildField("Description", "description", { type: "text", multiline: true });
        buildField("Hours per day", "hoursPerDay", { type: "number", min: "1", step: "1" });
        buildField("Minutes per hour", "minutesPerHour", { type: "number", min: "1", step: "1" });
        buildField("Minute step", "minuteStep", { type: "number", min: "1", step: "1" });
        const formActions = form.createDiv({ cls: "almanac-create-form__actions" });
        const save = formActions.createEl("button", {
          text: editState.isSaving ? "Saving\u2026" : "Save changes",
          attr: { type: "submit" }
        });
        save.disabled = editState.isSaving;
        const cancel = formActions.createEl("button", { text: "Cancel", attr: { type: "button" } });
        cancel.disabled = editState.isSaving;
        cancel.addEventListener("click", () => {
          void this.runDispatch({ type: "CALENDAR_EDIT_CANCELLED", calendarId: schema.id });
        });
      }
    });
  }
  renderManagerCalendarView(host, state) {
    const conflict = state.managerUiState.conflictDialog;
    if (conflict) {
      const banner = host.createDiv({ cls: "almanac-section almanac-section--error" });
      banner.createEl("h3", { text: "Calendar conflict" });
      banner.createEl("p", { text: conflict.message });
      if (conflict.details.length > 0) {
        const list = banner.createEl("ul", { cls: "almanac-form-errors" });
        conflict.details.forEach((detail) => list.createEl("li", { text: detail }));
      }
      const dismiss = banner.createEl("button", { text: "Dismiss" });
      dismiss.addEventListener("click", () => {
        void this.runDispatch({ type: "CALENDAR_CONFLICT_DISMISSED" });
      });
    }
    const calendar = this.getActiveCalendar(state);
    if (!calendar) {
      host.createEl("p", { text: "No calendar selected.", cls: "almanac-empty" });
      return;
    }
    const anchor = state.managerUiState.anchorTimestamp ?? state.calendarState.currentTimestamp ?? createDayTimestamp(calendar.id, calendar.epoch.year, calendar.epoch.monthId, calendar.epoch.day);
    const zoom = state.managerUiState.zoom;
    const navBar = host.createDiv({ cls: "almanac-calendar-nav" });
    const prevBtn = navBar.createEl("button", { text: "Previous" });
    prevBtn.disabled = state.almanacUiState.isLoading;
    prevBtn.addEventListener("click", () => this.runDispatch({ type: "MANAGER_NAVIGATION_REQUESTED", direction: "prev" }));
    const todayBtn = navBar.createEl("button", { text: "Today" });
    todayBtn.disabled = state.almanacUiState.isLoading;
    todayBtn.addEventListener("click", () => this.runDispatch({ type: "MANAGER_NAVIGATION_REQUESTED", direction: "today" }));
    const nextBtn = navBar.createEl("button", { text: "Next" });
    nextBtn.disabled = state.almanacUiState.isLoading;
    nextBtn.addEventListener("click", () => this.runDispatch({ type: "MANAGER_NAVIGATION_REQUESTED", direction: "next" }));
    if (state.managerUiState.selection.length > 0) {
      const selectionSummary = navBar.createDiv({ cls: "almanac-calendar-nav__selection" });
      selectionSummary.setText(`${state.managerUiState.selection.length} selected`);
    }
    navBar.createEl("span", {
      text: this.describeAnchorLabel(anchor, zoom, calendar),
      cls: "almanac-calendar-nav__label"
    });
    const container = host.createDiv({ cls: "almanac-calendar-view" });
    switch (zoom) {
      case "month":
        this.renderMonthGrid(container, calendar, anchor, state);
        break;
      case "week":
        this.renderWeekView(container, calendar, anchor, state);
        break;
      case "day":
        this.renderDayView(container, calendar, anchor, state);
        break;
      case "hour":
        this.renderHourView(container, calendar, anchor, state);
        break;
    }
  }
  describeAnchorLabel(anchor, zoom, calendar) {
    const monthName = getMonthById(calendar, anchor.monthId)?.name ?? anchor.monthId;
    switch (zoom) {
      case "month":
        return `${monthName} ${anchor.year}`;
      case "week":
        return `Week of ${formatTimestamp(anchor, monthName)}`;
      case "day":
        return `Day view \u2013 ${formatTimestamp(anchor, monthName)}`;
      case "hour":
        return `Hour view \u2013 ${formatTimestamp(anchor, monthName)}`;
      default:
        return formatTimestamp(anchor, monthName);
    }
  }
  renderMonthGrid(container, calendar, anchor, state) {
    const table = container.createEl("table", { cls: "almanac-month-grid" });
    const headerRow = table.createEl("thead").createEl("tr");
    for (let i = 0; i < calendar.daysPerWeek; i++) {
      headerRow.createEl("th", { text: `Day ${i + 1}` });
    }
    const body = table.createEl("tbody");
    const monthIndex = getMonthIndex(calendar, anchor.monthId);
    const month = monthIndex >= 0 ? calendar.months[monthIndex] : calendar.months[0];
    const weeks = [];
    let currentWeek = new Array(calendar.daysPerWeek).fill(null);
    for (let day = 1; day <= month.length; day++) {
      const slot = (day - 1) % calendar.daysPerWeek;
      currentWeek[slot] = day;
      if (slot === calendar.daysPerWeek - 1 || day === month.length) {
        weeks.push(currentWeek);
        currentWeek = new Array(calendar.daysPerWeek).fill(null);
      }
    }
    const eventsByDay = this.groupEventsByDay(state, calendar.id, anchor.year, month.id);
    weeks.forEach((week) => {
      const row = body.createEl("tr");
      week.forEach((dayNumber) => {
        const cell = row.createEl("td", { cls: "almanac-month-grid__cell" });
        if (dayNumber === null) {
          cell.addClass("is-empty");
          return;
        }
        const dayHeader = cell.createDiv({ text: String(dayNumber), cls: "almanac-month-grid__day" });
        if (dayNumber === anchor.day) {
          cell.addClass("is-anchor");
          dayHeader.addClass("is-anchor");
        }
        const events = eventsByDay.get(dayNumber) ?? [];
        events.slice(0, 2).forEach((event) => {
          cell.createDiv({ text: `${this.formatEventTime(event)} \u2022 ${event.title}`, cls: "almanac-month-grid__event" });
        });
        if (events.length > 2) {
          cell.createDiv({ text: `+${events.length - 2} more`, cls: "almanac-month-grid__more" });
        }
      });
    });
  }
  renderWeekView(container, calendar, anchor, state) {
    const list = container.createDiv({ cls: "almanac-week-view" });
    for (let offset = 0; offset < calendar.daysPerWeek; offset++) {
      const dayTimestamp = this.getOffsetTimestamp(calendar, anchor, offset);
      const dayBox = list.createDiv({ cls: "almanac-week-view__day" });
      const monthName = getMonthById(calendar, dayTimestamp.monthId)?.name ?? dayTimestamp.monthId;
      dayBox.createDiv({ text: formatTimestamp(dayTimestamp, monthName), cls: "almanac-week-view__heading" });
      const events = this.getEventsForDate(state, calendar.id, dayTimestamp.year, dayTimestamp.monthId, dayTimestamp.day);
      if (events.length === 0) {
        dayBox.createDiv({ text: "No events", cls: "almanac-week-view__empty" });
        continue;
      }
      events.forEach((event) => {
        dayBox.createDiv({ text: `${this.formatEventTime(event)} \u2022 ${event.title}`, cls: "almanac-week-view__event" });
      });
    }
  }
  renderDayView(container, calendar, anchor, state) {
    const events = this.getEventsForDate(state, calendar.id, anchor.year, anchor.monthId, anchor.day);
    const list = container.createDiv({ cls: "almanac-day-view" });
    list.createDiv({ text: `Events for ${formatTimestamp(anchor, getMonthById(calendar, anchor.monthId)?.name)}`, cls: "almanac-day-view__heading" });
    if (events.length === 0) {
      list.createDiv({ text: "No events scheduled.", cls: "almanac-day-view__empty" });
      return;
    }
    events.slice().sort((a, b) => (a.date.hour ?? 0) - (b.date.hour ?? 0)).forEach((event) => {
      list.createDiv({ text: `${this.formatEventTime(event)} \u2022 ${event.title}`, cls: "almanac-day-view__event" });
    });
  }
  renderHourView(container, calendar, anchor, state) {
    const events = this.getEventsForDate(state, calendar.id, anchor.year, anchor.monthId, anchor.day);
    const segments = [0, 6, 12, 18];
    const view = container.createDiv({ cls: "almanac-hour-view" });
    segments.forEach((startHour) => {
      const endHour = startHour + 5;
      const bucket = view.createDiv({ cls: "almanac-hour-view__segment" });
      bucket.createDiv({ text: `${String(startHour).padStart(2, "0")}:00 \u2013 ${String(endHour + 1).padStart(2, "0")}:00`, cls: "almanac-hour-view__segment-heading" });
      const segmentEvents = events.filter((event) => {
        const hour = event.date.hour ?? 0;
        return hour >= startHour && hour <= endHour;
      });
      if (segmentEvents.length === 0) {
        bucket.createDiv({ text: "\u2014", cls: "almanac-hour-view__empty" });
        return;
      }
      segmentEvents.forEach((event) => {
        bucket.createDiv({ text: `${this.formatEventTime(event)} \u2022 ${event.title}`, cls: "almanac-hour-view__event" });
      });
    });
  }
  getOffsetTimestamp(calendar, anchor, offsetDays) {
    if (offsetDays === 0) {
      return anchor;
    }
    return advanceTime(calendar, anchor, offsetDays, "day").timestamp;
  }
  groupEventsByDay(state, calendarId, year, monthId) {
    const events = [...state.calendarState.upcomingEvents, ...state.calendarState.triggeredEvents];
    const map = /* @__PURE__ */ new Map();
    events.forEach((event) => {
      if (event.date.calendarId !== calendarId) return;
      if (event.date.year !== year) return;
      if (event.date.monthId !== monthId) return;
      const day = event.date.day;
      if (!map.has(day)) {
        map.set(day, []);
      }
      map.get(day).push(event);
    });
    return map;
  }
  getEventsForDate(state, calendarId, year, monthId, day) {
    const pool = [...state.calendarState.upcomingEvents, ...state.calendarState.triggeredEvents];
    return pool.filter(
      (event) => event.date.calendarId === calendarId && event.date.year === year && event.date.monthId === monthId && event.date.day === day
    );
  }
  formatEventTime(event) {
    if (event.date.hour === void 0) {
      return "All day";
    }
    const hour = String(event.date.hour).padStart(2, "0");
    const minute = String(event.date.minute ?? 0).padStart(2, "0");
    return `${hour}:${minute}`;
  }
  getFallbackTimestamp(state) {
    if (state.managerUiState.anchorTimestamp) {
      return state.managerUiState.anchorTimestamp;
    }
    if (state.calendarState.currentTimestamp) {
      return state.calendarState.currentTimestamp;
    }
    const calendar = this.getActiveCalendar(state) ?? state.calendarState.calendars[0] ?? null;
    if (!calendar) {
      return null;
    }
    const firstMonth = calendar.months[0] ?? { id: calendar.epoch.monthId, length: calendar.months[0]?.length ?? 30 };
    return createDayTimestamp(calendar.id, calendar.epoch.year, firstMonth.id, calendar.epoch.day);
  }
  renderEvents(host, state) {
    const section = host.createDiv({ cls: "almanac-events" });
    const controls = section.createDiv({ cls: "almanac-toggle-group" });
    EVENT_VIEW_OPTIONS.forEach((option) => {
      const label = option.charAt(0).toUpperCase() + option.slice(1);
      const btn = controls.createEl("button", { text: label });
      btn.classList.toggle("is-active", state.eventsUiState.viewMode === option);
      btn.addEventListener("click", () => this.runDispatch({
        type: "EVENTS_VIEW_MODE_CHANGED",
        viewMode: option
      }));
    });
    this.renderEventsActions(section, state);
    this.renderEventsFilters(section, state);
    if (state.eventsUiState.error) {
      const err = section.createDiv({ cls: "almanac-section almanac-section--error" });
      err.setText(state.eventsUiState.error);
    }
    const contentSection = section.createDiv({ cls: "almanac-section" });
    contentSection.createEl("h2", { text: this.describeEventsViewHeading(state.eventsUiState.viewMode) });
    if (!state.eventsUiState.phenomena.length) {
      contentSection.createEl("p", { text: "No phenomena match the current filters.", cls: "almanac-empty" });
      this.renderPhenomenonDetail(section, state);
      this.renderEventsFooter(section, state);
      return;
    }
    switch (state.eventsUiState.viewMode) {
      case "timeline":
        this.renderEventsTimeline(contentSection, state);
        break;
      case "table":
        this.renderEventsTable(contentSection, state);
        break;
      case "map":
        this.renderEventsMap(contentSection, state);
        break;
    }
    this.renderPhenomenonDetail(section, state);
    this.renderEventsFooter(section, state);
  }
  renderPhenomenonDetail(section, state) {
    const detailSection = section.createDiv({ cls: "almanac-section almanac-phenomenon-detail" });
    if (state.eventsUiState.isDetailLoading) {
      detailSection.createEl("p", { text: "Loading phenomenon\u2026", cls: "almanac-empty" });
      return;
    }
    const detail = state.eventsUiState.selectedPhenomenonDetail;
    if (!state.eventsUiState.selectedPhenomenonId || !detail) {
      detailSection.createEl("p", { text: "Select a phenomenon to view details.", cls: "almanac-empty" });
      return;
    }
    const header = detailSection.createDiv({ cls: "almanac-phenomenon-detail__header" });
    const title = header.createEl("h3", { text: detail.name, cls: "almanac-phenomenon-detail__title" });
    if (detail.category) {
      title.createEl("span", { text: ` (${detail.category})`, cls: "almanac-phenomenon-detail__category" });
    }
    const actions = header.createDiv({ cls: "almanac-phenomenon-detail__actions" });
    const editButton = actions.createEl("button", {
      text: "Edit",
      cls: "almanac-control-button",
      attr: { "data-action": "edit-phenomenon" }
    });
    editButton.addEventListener("click", () => {
      this.runDispatch({ type: "PHENOMENON_EDIT_REQUESTED", phenomenonId: detail.id });
    });
    const closeButton = actions.createEl("button", {
      text: "Close",
      cls: "almanac-control-button",
      attr: { "data-action": "close-detail" }
    });
    closeButton.addEventListener("click", () => this.runDispatch({ type: "EVENTS_PHENOMENON_DETAIL_CLOSED" }));
    if (detail.notes) {
      detailSection.createEl("p", { text: detail.notes, cls: "almanac-phenomenon-detail__notes" });
    }
    if (detail.linkedCalendars.length > 0) {
      const calendarsRow = detailSection.createDiv({ cls: "almanac-phenomenon-detail__calendars" });
      calendarsRow.createEl("strong", { text: "Linked calendars:" });
      calendarsRow.createEl("span", { text: detail.linkedCalendars.map((item) => item.name).join(", ") });
    }
    if (detail.upcomingOccurrences.length > 0) {
      const occurrencesList = detailSection.createEl("ul", { cls: "almanac-phenomenon-detail__occurrences" });
      detail.upcomingOccurrences.forEach((occurrence) => {
        const item = occurrencesList.createEl("li");
        item.createEl("strong", { text: `${occurrence.calendarName}: ${occurrence.nextLabel}` });
        if (occurrence.subsequent.length > 0) {
          const subsequentList = item.createEl("ul", { cls: "almanac-phenomenon-detail__subsequent" });
          occurrence.subsequent.forEach((label) => {
            subsequentList.createEl("li", { text: label });
          });
        }
      });
    } else {
      detailSection.createEl("p", { text: "No upcoming occurrences scheduled.", cls: "almanac-empty" });
    }
  }
  describeEventsViewHeading(viewMode) {
    if (viewMode === "timeline") return "Phenomena Timeline";
    if (viewMode === "table") return "Phenomena Table";
    return "Phenomena Map";
  }
  renderEventsTimeline(section, state) {
    const list = section.createEl("ol", { cls: "almanac-phenomena-timeline" });
    const selectedId = state.eventsUiState.selectedPhenomenonId ?? null;
    const sorted = [...state.eventsUiState.phenomena].sort((a, b) => {
      const aKey = a.nextOccurrence ?? "";
      const bKey = b.nextOccurrence ?? "";
      return aKey.localeCompare(bKey);
    });
    sorted.forEach((item) => {
      const entry = list.createEl("li", { cls: "almanac-phenomena-timeline__entry" });
      entry.classList.toggle("is-active", item.id === selectedId);
      entry.tabIndex = 0;
      entry.setAttribute("role", "button");
      const selectWrapper = entry.createDiv({ cls: "almanac-phenomena-timeline__select" });
      const selectionCheckbox = selectWrapper.createEl("input", {
        attr: { type: "checkbox", value: item.id, "data-role": "bulk-select" }
      });
      selectionCheckbox.checked = state.eventsUiState.bulkSelection.includes(item.id);
      selectionCheckbox.addEventListener("change", () => {
        this.toggleBulkSelection(item.id, selectionCheckbox.checked);
      });
      const selectPhenomenon = () => {
        this.runDispatch({ type: "EVENTS_PHENOMENON_SELECTED", phenomenonId: item.id });
      };
      entry.addEventListener("click", selectPhenomenon);
      entry.addEventListener("keydown", (event) => {
        if (event instanceof KeyboardEvent && (event.key === "Enter" || event.key === " ")) {
          event.preventDefault();
          selectPhenomenon();
        }
      });
      const heading = entry.createDiv({ cls: "almanac-phenomena-timeline__title" });
      heading.createEl("strong", { text: item.title });
      if (item.category) {
        heading.createEl("span", { text: ` (${item.category})`, cls: "almanac-phenomena-category" });
      }
      if (item.nextOccurrence) {
        entry.createDiv({ text: item.nextOccurrence, cls: "almanac-phenomena-occurrence" });
      }
      if (item.linkedCalendars && item.linkedCalendars.length > 0) {
        entry.createDiv({
          text: `Linked calendars: ${item.linkedCalendars.join(", ")}`,
          cls: "almanac-phenomena-calendars"
        });
      }
    });
  }
  renderEventsTable(section, state) {
    const table = section.createEl("table", { cls: "almanac-phenomena-table" });
    const thead = table.createEl("thead");
    const headRow = thead.createEl("tr");
    headRow.createEl("th", { text: "Select" });
    ["Name", "Category", "Next Occurrence", "Calendars"].forEach((label) => headRow.createEl("th", { text: label }));
    const tbody = table.createEl("tbody");
    state.eventsUiState.phenomena.forEach((item) => {
      const row = tbody.createEl("tr");
      row.classList.toggle("is-active", item.id === state.eventsUiState.selectedPhenomenonId);
      row.tabIndex = 0;
      row.setAttribute("role", "button");
      const selectCell = row.createEl("td", { cls: "almanac-phenomena-table__select" });
      const selectCheckbox = selectCell.createEl("input", {
        attr: { type: "checkbox", value: item.id, "data-role": "bulk-select" }
      });
      selectCheckbox.checked = state.eventsUiState.bulkSelection.includes(item.id);
      selectCheckbox.addEventListener("change", () => {
        this.toggleBulkSelection(item.id, selectCheckbox.checked);
      });
      const selectPhenomenon = () => {
        this.runDispatch({ type: "EVENTS_PHENOMENON_SELECTED", phenomenonId: item.id });
      };
      row.addEventListener("click", selectPhenomenon);
      row.addEventListener("keydown", (event) => {
        if (event instanceof KeyboardEvent && (event.key === "Enter" || event.key === " ")) {
          event.preventDefault();
          selectPhenomenon();
        }
      });
      row.createEl("td", { text: item.title });
      row.createEl("td", { text: item.category ?? "\u2014" });
      row.createEl("td", { text: item.nextOccurrence ?? "\u2014" });
      row.createEl("td", { text: item.linkedCalendars?.join(", ") ?? "\u2014" });
    });
  }
  renderEventsMap(section, state) {
    const wrapper = document.createElement("div");
    wrapper.classList.add("almanac-events__map");
    wrapper.dataset.role = "events-map-container";
    section.appendChild(wrapper);
    renderEventsMap(wrapper, {
      markers: state.eventsUiState.mapMarkers
    });
  }
  renderEventsFilters(section, state) {
    const filtersBar = section.createDiv({ cls: "almanac-events__filters" });
    const categoryWrapper = filtersBar.createDiv({ cls: "almanac-filter-group", attr: { "data-filter-group": "category" } });
    categoryWrapper.createEl("div", { text: "Categories", cls: "almanac-filter-label" });
    const categoryList = categoryWrapper.createDiv({ cls: "almanac-filter-checkboxes" });
    const currentCategoryFilters = state.eventsUiState.filters.categories;
    state.eventsUiState.availableCategories.forEach((category) => {
      const label = categoryList.createEl("label", { cls: "almanac-filter-checkbox", attr: { "data-filter": "category" } });
      const input = label.createEl("input", {
        attr: { type: "checkbox", value: category }
      });
      input.checked = currentCategoryFilters.includes(category);
      input.addEventListener("change", () => {
        const currentFilters = this.currentState?.eventsUiState.filters ?? { categories: [], calendarIds: [] };
        const nextCategories = input.checked ? [...currentFilters.categories, category] : currentFilters.categories.filter((id) => id !== category);
        this.runDispatch({
          type: "EVENTS_FILTER_CHANGED",
          filters: {
            categories: nextCategories,
            calendarIds: currentFilters.calendarIds
          }
        });
      });
      label.createEl("span", { text: category });
    });
    const calendarWrapper = filtersBar.createDiv({ cls: "almanac-filter-group", attr: { "data-filter-group": "calendar" } });
    calendarWrapper.createEl("div", { text: "Calendars", cls: "almanac-filter-label" });
    const calendarList = calendarWrapper.createDiv({ cls: "almanac-filter-checkboxes" });
    state.eventsUiState.availableCalendars.forEach((calendar) => {
      const label = calendarList.createEl("label", { cls: "almanac-filter-checkbox", attr: { "data-filter": "calendar" } });
      const input = label.createEl("input", {
        attr: { type: "checkbox", value: calendar.id }
      });
      input.checked = state.eventsUiState.filters.calendarIds.includes(calendar.id);
      input.addEventListener("change", () => {
        const currentFilters = this.currentState?.eventsUiState.filters ?? { categories: [], calendarIds: [] };
        const nextIds = input.checked ? [...currentFilters.calendarIds, calendar.id] : currentFilters.calendarIds.filter((id) => id !== calendar.id);
        this.runDispatch({
          type: "EVENTS_FILTER_CHANGED",
          filters: {
            categories: currentFilters.categories,
            calendarIds: nextIds
          }
        });
      });
      label.createEl("span", { text: calendar.name });
    });
    const resetButton = filtersBar.createEl("button", {
      text: "Reset filters",
      cls: "almanac-control-button",
      attr: { "data-action": "reset-filters" }
    });
    resetButton.disabled = state.eventsUiState.filterCount === 0;
    resetButton.addEventListener("click", () => {
      this.runDispatch({
        type: "EVENTS_FILTER_CHANGED",
        filters: { categories: [], calendarIds: [] }
      });
    });
  }
  renderEventsActions(section, state) {
    const actions = section.createDiv({ cls: "almanac-events__actions" });
    const addButton = actions.createEl("button", {
      text: "Add phenomenon",
      cls: "almanac-control-button",
      attr: { "data-action": "add-phenomenon" }
    });
    addButton.addEventListener("click", () => {
      this.runDispatch({ type: "PHENOMENON_EDIT_REQUESTED" });
    });
    const addSingleEventButton = actions.createEl("button", {
      text: "Add single event",
      cls: "almanac-control-button",
      attr: { "data-action": "add-event-single" }
    });
    addSingleEventButton.addEventListener("click", () => {
      this.runDispatch({ type: "EVENT_CREATE_REQUESTED", mode: "single" });
    });
    const addRecurringEventButton = actions.createEl("button", {
      text: "Add recurring event",
      cls: "almanac-control-button",
      attr: { "data-action": "add-event-recurring" }
    });
    addRecurringEventButton.addEventListener("click", () => {
      this.runDispatch({ type: "EVENT_CREATE_REQUESTED", mode: "recurring" });
    });
    const importButton = actions.createEl("button", {
      text: "Import",
      cls: "almanac-control-button",
      attr: { "data-action": "import-phenomena" }
    });
    importButton.addEventListener("click", () => {
      this.runDispatch({ type: "EVENT_IMPORT_REQUESTED" });
    });
    const exportButton = actions.createEl("button", {
      text: "Export selected",
      cls: "almanac-control-button",
      attr: { "data-action": "export-selected" }
    });
    exportButton.disabled = state.eventsUiState.bulkSelection.length === 0;
    exportButton.addEventListener("click", () => {
      this.runDispatch({ type: "EVENT_BULK_ACTION_REQUESTED", action: "export" });
    });
    const deleteButton = actions.createEl("button", {
      text: "Delete selected",
      cls: "almanac-control-button",
      attr: { "data-action": "delete-selected" }
    });
    deleteButton.disabled = state.eventsUiState.bulkSelection.length === 0;
    deleteButton.addEventListener("click", () => {
      this.runDispatch({ type: "EVENT_BULK_ACTION_REQUESTED", action: "delete" });
    });
  }
  renderEventsFooter(section, state) {
    if (state.eventsUiState.lastExportPayload) {
      const exportSection = section.createDiv({ cls: "almanac-section almanac-events__export" });
      exportSection.createEl("h3", { text: "Export Preview" });
      const preview = exportSection.createEl("textarea", {
        cls: "almanac-events__export-output",
        attr: { readonly: "true", "data-role": "export-output" }
      });
      preview.rows = 6;
      preview.spellcheck = false;
      preview.value = state.eventsUiState.lastExportPayload;
      const clearButton = exportSection.createEl("button", {
        text: "Clear export",
        cls: "almanac-control-button",
        attr: { "data-action": "clear-export" }
      });
      clearButton.addEventListener("click", () => {
        this.runDispatch({ type: "EVENT_EXPORT_CLEARED" });
      });
    }
    const summary = state.eventsUiState.importSummary;
    if (summary) {
      const summarySection = section.createDiv({
        cls: "almanac-events__import-summary",
        attr: { "data-role": "import-summary" }
      });
      const parts = [`Imported ${summary.imported} phenomena`];
      if (summary.failed > 0) {
        parts.push(`Failed: ${summary.failed}`);
      }
      summarySection.setText(parts.join(" \u2022 "));
    }
  }
  toggleBulkSelection(id, checked) {
    const current = new Set(this.currentState?.eventsUiState.bulkSelection ?? []);
    if (checked) {
      current.add(id);
    } else {
      current.delete(id);
    }
    void this.runDispatch({
      type: "EVENTS_BULK_SELECTION_UPDATED",
      selection: Array.from(current)
    });
  }
  syncDialogs(state) {
    const eventsState = state.eventsUiState;
    const phenomenonCalendars = state.calendarState.calendars.map((schema) => ({ id: schema.id, name: schema.name }));
    const calendarOptions = state.calendarState.calendars.map((schema) => ({
      id: schema.id,
      name: schema.name,
      daysPerWeek: schema.daysPerWeek,
      months: schema.months.map((month) => ({
        id: month.id,
        name: month.name,
        length: month.length
      }))
    }));
    if (eventsState.isEditorOpen && eventsState.editorDraft) {
      if (!this.phenomenonEditorModal) {
        this.phenomenonEditorModal = new PhenomenonEditorModal(this.app, eventsState.editorDraft, {
          calendars: phenomenonCalendars,
          isSaving: eventsState.isSaving,
          error: eventsState.editorError,
          onSave: (draft) => {
            void this.runDispatch({ type: "PHENOMENON_SAVE_REQUESTED", draft });
          },
          onCancel: () => {
            void this.runDispatch({ type: "PHENOMENON_EDIT_CANCELLED" });
          }
        });
        this.phenomenonEditorModal.open();
      } else {
        this.phenomenonEditorModal.update(eventsState.editorDraft, {
          isSaving: eventsState.isSaving,
          error: eventsState.editorError,
          calendars: phenomenonCalendars
        });
      }
    } else if (this.phenomenonEditorModal) {
      this.phenomenonEditorModal.close();
      this.phenomenonEditorModal = null;
    }
    if (eventsState.isEventEditorOpen && eventsState.eventEditorDraft) {
      const mode = eventsState.eventEditorDraft.kind === "recurring" ? "recurring" : "single";
      const config = {
        mode,
        calendars: calendarOptions,
        errors: eventsState.eventEditorErrors,
        preview: eventsState.eventEditorPreview,
        isSaving: eventsState.isEventSaving,
        submitError: eventsState.eventEditorError,
        onUpdate: (update) => {
          void this.runDispatch({ type: "EVENT_EDITOR_UPDATED", update });
        },
        onSubmit: () => {
          void this.runDispatch({ type: "EVENT_EDITOR_SAVE_REQUESTED" });
        },
        onCancel: () => {
          void this.runDispatch({ type: "EVENT_EDITOR_CANCELLED" });
        },
        onDelete: eventsState.eventEditorDraft.id ? () => {
          void this.runDispatch({
            type: "EVENT_DELETE_REQUESTED",
            eventId: eventsState.eventEditorDraft.id
          });
        } : void 0
      };
      if (!this.eventEditorModal) {
        this.eventEditorModal = new EventEditorModal(this.app, eventsState.eventEditorDraft, config);
        this.eventEditorModal.open();
      } else {
        this.eventEditorModal.update(eventsState.eventEditorDraft, {
          mode: config.mode,
          calendars: config.calendars,
          errors: config.errors,
          preview: config.preview,
          isSaving: config.isSaving,
          submitError: config.submitError,
          onDelete: config.onDelete
        });
      }
    } else if (this.eventEditorModal) {
      this.eventEditorModal.close();
      this.eventEditorModal = null;
    }
    if (eventsState.isImportDialogOpen) {
      if (!this.eventImportModal) {
        this.eventImportModal = new EventImportDialog(this.app, {
          isLoading: eventsState.isLoading,
          error: eventsState.importError,
          onSubmit: (payload) => {
            void this.runDispatch({ type: "EVENT_IMPORT_SUBMITTED", payload });
          },
          onCancel: () => {
            void this.runDispatch({ type: "EVENT_IMPORT_CANCELLED" });
          }
        });
        this.eventImportModal.open();
      } else {
        this.eventImportModal.update({
          isLoading: eventsState.isLoading,
          error: eventsState.importError
        });
      }
    } else if (this.eventImportModal) {
      this.eventImportModal.close();
      this.eventImportModal = null;
    }
  }
  getActiveCalendar(state) {
    const activeId = state.calendarState.activeCalendarId;
    if (!activeId) return null;
    return state.calendarState.calendars.find((calendar) => calendar.id === activeId) ?? null;
  }
  formatCalendarTimestamp(schema, timestamp) {
    const month = getMonthById(schema, timestamp.monthId);
    return formatTimestamp(timestamp, month?.name);
  }
  ensureProtocolHandler() {
    if (this.protocolRef || typeof this.app.workspace?.on !== "function") {
      return;
    }
    const ref = this.app.workspace.on("url", this.handleProtocolUrl);
    if (ref && typeof this.app.workspace?.offref === "function") {
      this.protocolRef = ref;
    }
  }
  parseDeepLink(rawUrl) {
    if (!rawUrl) {
      return null;
    }
    let url;
    try {
      url = new URL(rawUrl);
    } catch (error) {
      return null;
    }
    if (url.protocol !== "obsidian:") {
      return null;
    }
    const host = url.hostname.toLowerCase();
    if (!ALMANAC_PROTOCOL_HOSTS.has(host)) {
      return null;
    }
    const overrides = {};
    const segments = url.pathname.split("/").map((segment) => segment.trim().toLowerCase()).filter(Boolean);
    if (segments[0] === "almanac") {
      segments.shift();
    }
    if (segments[0]) {
      const segmentMode = segments[0];
      if (segmentMode === "dashboard" || segmentMode === "manager" || segmentMode === "events") {
        overrides.mode = segmentMode;
      }
    }
    const params = url.searchParams;
    const modeParam = params.get("mode");
    if (modeParam === "dashboard" || modeParam === "manager" || modeParam === "events") {
      overrides.mode = modeParam;
    }
    const viewParam = params.get("view");
    if (viewParam) {
      if (MANAGER_VIEW_OPTIONS.includes(viewParam)) {
        overrides.managerView = viewParam;
      }
      if (EVENT_VIEW_OPTIONS.includes(viewParam)) {
        overrides.eventsView = viewParam;
      }
    }
    const zoomParam = params.get("zoom");
    if (zoomParam && MANAGER_ZOOM_OPTIONS.includes(zoomParam)) {
      overrides.managerZoom = zoomParam;
    }
    if (params.has("phenomenon")) {
      const focus = params.get("phenomenon");
      overrides.selectedPhenomenonId = focus && focus.length > 0 ? focus : null;
    }
    if (params.has("travelId") || params.has("travel")) {
      const travelId = params.get("travelId") ?? params.get("travel");
      overrides.travelId = travelId && travelId.length > 0 ? travelId : null;
    }
    const hasValues = overrides.mode !== void 0 || overrides.managerView !== void 0 || overrides.managerZoom !== void 0 || overrides.eventsView !== void 0 || overrides.travelId !== void 0 || Object.prototype.hasOwnProperty.call(overrides, "selectedPhenomenonId");
    return hasValues ? overrides : null;
  }
  syncDeepLink(state) {
    if (!this.allowDeepLinkSync) {
      return;
    }
    const url = this.buildDeepLinkUrl(state);
    if (!url || url === this.lastDeepLinkUrl) {
      return;
    }
    this.lastDeepLinkUrl = url;
    if (typeof this.app.workspace?.trigger === "function") {
      this.isSyncingDeepLink = true;
      try {
        this.app.workspace.trigger("url", url);
      } finally {
        this.isSyncingDeepLink = false;
      }
    }
  }
  buildDeepLinkUrl(state) {
    const params = [];
    const mode = state.almanacUiState.mode;
    params.push(`mode=${encodeURIComponent(mode)}`);
    const travelId = state.travelLeafState.travelId;
    if (travelId) {
      params.push(`travelId=${encodeURIComponent(travelId)}`);
    }
    if (mode === "manager") {
      params.push(`view=${encodeURIComponent(state.managerUiState.viewMode)}`);
      params.push(`zoom=${encodeURIComponent(state.managerUiState.zoom)}`);
    } else if (mode === "events") {
      params.push(`view=${encodeURIComponent(state.eventsUiState.viewMode)}`);
      if (state.eventsUiState.selectedPhenomenonId) {
        params.push(`phenomenon=${encodeURIComponent(state.eventsUiState.selectedPhenomenonId)}`);
      }
    }
    const query = params.length > 0 ? `?${params.join("&")}` : "";
    return `${ALMANAC_PROTOCOL_BASE}${query}`;
  }
  runDispatch(event) {
    return this.stateMachine.dispatch(event).catch((error) => {
      console.error("Almanac dispatch error", error);
    });
  }
  async openTimeJumpFromCartographer() {
    this.showTimeJumpForm = true;
    if (this.currentState && this.containerEl) {
      this.render(this.currentState);
    }
  }
  async handleTravelFollowUp(eventId) {
    console.info("[almanac] travel follow-up requested", { eventId });
    await this.runDispatch({ type: "ALMANAC_MODE_SELECTED", mode: "events" });
  }
};

// src/apps/almanac/data/json-store.ts
var import_obsidian32 = require("obsidian");
var JsonStore = class {
  constructor(vault, config) {
    this.vault = vault;
    this.config = config;
    this.normalizedPath = (0, import_obsidian32.normalizePath)(config.path);
  }
  async read() {
    const payload = await this.ensurePayload();
    return clone(payload.data);
  }
  async update(updater) {
    const payload = await this.ensurePayload();
    const draft = clone(payload.data);
    const result = updater(draft);
    const nextData = result !== void 0 ? result : draft;
    const nextPayload = { version: this.config.currentVersion, data: clone(nextData) };
    await this.writePayload(nextPayload);
    return clone(nextData);
  }
  async ensurePayload() {
    const file = await this.ensureFile();
    const raw = await this.vault.read(file);
    if (!raw.trim()) {
      const fallback = { version: this.config.currentVersion, data: this.config.initialData() };
      await this.writePayload(fallback);
      return fallback;
    }
    try {
      const parsed = JSON.parse(raw);
      const normalized = this.normalisePayload(parsed);
      if (normalized.version !== this.config.currentVersion) {
        const migrated = this.applyMigrations(normalized);
        if (migrated.version !== this.config.currentVersion) {
          const coerced = {
            version: this.config.currentVersion,
            data: migrated.data ?? this.config.initialData()
          };
          await this.writePayload(coerced);
          return coerced;
        }
        await this.writePayload(migrated);
        return migrated;
      }
      return normalized;
    } catch (error) {
      console.warn(`[salt-marcher] Failed to parse ${this.normalizedPath}, resetting file`, error);
      const fallback = { version: this.config.currentVersion, data: this.config.initialData() };
      await this.writePayload(fallback);
      return fallback;
    }
  }
  applyMigrations(payload) {
    const migrations = this.config.migrations ?? {};
    let current = payload;
    const visited = /* @__PURE__ */ new Set();
    while (current.version !== this.config.currentVersion) {
      if (visited.has(current.version)) {
        break;
      }
      visited.add(current.version);
      const migrate = migrations[current.version];
      if (!migrate) {
        break;
      }
      current = migrate(current);
    }
    return current;
  }
  normalisePayload(payload) {
    if (!payload || typeof payload !== "object") {
      return { version: "0.0.0", data: this.config.initialData() };
    }
    const version = typeof payload.version === "string" && payload.version ? payload.version : "0.0.0";
    const data = payload.data ?? this.config.initialData();
    return { version, data };
  }
  async ensureFile() {
    const existing = this.vault.getAbstractFileByPath(this.normalizedPath);
    if (existing instanceof import_obsidian32.TFile) {
      return existing;
    }
    await this.ensureParentFolder(this.normalizedPath);
    const payload = { version: this.config.currentVersion, data: this.config.initialData() };
    return this.vault.create(this.normalizedPath, serialise(payload));
  }
  async ensureParentFolder(path) {
    const segments = path.split("/").slice(0, -1);
    let current = "";
    for (const segment of segments) {
      current = current ? `${current}/${segment}` : segment;
      const normalised = (0, import_obsidian32.normalizePath)(current);
      if (this.vault.getAbstractFileByPath(normalised)) {
        continue;
      }
      try {
        await this.vault.createFolder(normalised);
      } catch (error) {
        if (this.vault.getAbstractFileByPath(normalised)) {
          continue;
        }
        throw error;
      }
    }
  }
  async writePayload(payload) {
    const file = await this.ensureFile();
    await this.vault.modify(file, serialise(payload));
  }
};
function serialise(payload) {
  return `${JSON.stringify(payload, null, 2)}
`;
}
function clone(value) {
  return JSON.parse(JSON.stringify(value));
}

// src/apps/almanac/data/vault-calendar-repository.ts
var CALENDAR_STORE_VERSION = "1.4.0";
var CALENDAR_STORE_PATH = "SaltMarcher/Almanac/calendars.json";
var VaultCalendarRepository = class {
  constructor(vault) {
    this.store = new JsonStore(vault, {
      path: CALENDAR_STORE_PATH,
      currentVersion: CALENDAR_STORE_VERSION,
      initialData: () => ({ calendars: [], defaults: { global: null, travel: {} } }),
      migrations: {
        "0.0.0": (payload) => migrateLegacyCalendars(payload)
      }
    });
  }
  async listCalendars() {
    const { calendars, defaults } = await this.store.read();
    return calendars.map((calendar) => ({
      ...calendar,
      isDefaultGlobal: defaults.global === calendar.id,
      defaultTravelIds: computeDefaultTravelIds(calendar.id, defaults.travel)
    }));
  }
  async getCalendar(id) {
    const { calendars, defaults } = await this.store.read();
    const calendar = calendars.find((entry) => entry.id === id);
    if (!calendar) {
      return null;
    }
    return {
      ...calendar,
      isDefaultGlobal: defaults.global === calendar.id,
      defaultTravelIds: computeDefaultTravelIds(calendar.id, defaults.travel)
    };
  }
  async createCalendar(input) {
    try {
      await this.store.update((state) => {
        if (state.calendars.some((calendar) => calendar.id === input.id)) {
          throw new Error(`Calendar with ID ${input.id} already exists`);
        }
        const calendars = [...state.calendars, { ...input }];
        const defaults = ensureDefaultsState(state.defaults);
        if (input.isDefaultGlobal) {
          defaults.global = input.id;
        }
        return { calendars, defaults };
      });
    } catch (error) {
      reportAlmanacGatewayIssue({
        operation: "calendar.repository.createCalendar",
        scope: "calendar",
        code: isCalendarRepositoryValidationError(error) ? "validation_error" : "io_error",
        error,
        context: { calendarId: input.id }
      });
      throw error;
    }
  }
  async updateCalendar(id, input) {
    try {
      await this.store.update((state) => {
        const index = state.calendars.findIndex((calendar) => calendar.id === id);
        if (index === -1) {
          throw new Error(`Calendar with ID ${id} not found`);
        }
        const calendars = [...state.calendars];
        calendars[index] = { ...calendars[index], ...input };
        return { calendars, defaults: ensureDefaultsState(state.defaults) };
      });
    } catch (error) {
      reportAlmanacGatewayIssue({
        operation: "calendar.repository.updateCalendar",
        scope: "calendar",
        code: isCalendarRepositoryValidationError(error) ? "validation_error" : "io_error",
        error,
        context: { calendarId: id }
      });
      throw error;
    }
  }
  async deleteCalendar(id) {
    try {
      await this.store.update((state) => {
        if (!state.calendars.some((calendar) => calendar.id === id)) {
          throw new Error(`Calendar with ID ${id} not found`);
        }
        const calendars = state.calendars.filter((calendar) => calendar.id !== id);
        const defaults = ensureDefaultsState(state.defaults);
        if (defaults.global === id) {
          defaults.global = null;
        }
        const travelEntries = Object.entries(defaults.travel);
        for (const [travelId, calendarId] of travelEntries) {
          if (calendarId === id) {
            defaults.travel[travelId] = null;
          }
        }
        return { calendars, defaults };
      });
    } catch (error) {
      reportAlmanacGatewayIssue({
        operation: "calendar.repository.deleteCalendar",
        scope: "calendar",
        code: isCalendarRepositoryValidationError(error) ? "validation_error" : "io_error",
        error,
        context: { calendarId: id }
      });
      throw error;
    }
  }
  async setDefault(input) {
    try {
      await this.store.update((state) => {
        if (!state.calendars.some((calendar) => calendar.id === input.calendarId)) {
          throw new Error(`Calendar with ID ${input.calendarId} not found`);
        }
        const defaults = ensureDefaultsState(state.defaults);
        if (input.scope === "global") {
          defaults.global = input.calendarId;
        } else if (input.scope === "travel" && input.travelId) {
          defaults.travel[input.travelId] = input.calendarId;
        }
        return { calendars: state.calendars, defaults };
      });
    } catch (error) {
      reportAlmanacGatewayIssue({
        operation: "calendar.repository.setDefault",
        scope: input.scope === "travel" ? "travel" : "default",
        code: isCalendarRepositoryValidationError(error) ? "validation_error" : "io_error",
        error,
        context: { calendarId: input.calendarId, travelId: input.travelId ?? null }
      });
      throw error;
    }
  }
  async getDefaults() {
    const { defaults } = await this.store.read();
    return ensureDefaultsState(defaults);
  }
  async getGlobalDefault() {
    const { defaults } = await this.store.read();
    return ensureDefaultsState(defaults).global;
  }
  async getTravelDefault(travelId) {
    const { defaults } = await this.store.read();
    const snapshot = ensureDefaultsState(defaults);
    return snapshot.travel[travelId] ?? null;
  }
  async clearTravelDefault(travelId) {
    try {
      await this.store.update((state) => {
        const defaults = ensureDefaultsState(state.defaults);
        if (defaults.travel[travelId]) {
          defaults.travel[travelId] = null;
        }
        return { calendars: state.calendars, defaults };
      });
    } catch (error) {
      reportAlmanacGatewayIssue({
        operation: "calendar.repository.clearTravelDefault",
        scope: "travel",
        code: isCalendarRepositoryValidationError(error) ? "validation_error" : "io_error",
        error,
        context: { travelId }
      });
      throw error;
    }
  }
};
function ensureDefaultsState(snapshot) {
  return {
    global: snapshot?.global ?? null,
    travel: { ...snapshot?.travel ?? {} }
  };
}
function computeDefaultTravelIds(calendarId, travel) {
  return Object.entries(travel).filter(([, linkedId]) => linkedId === calendarId).map(([travelId]) => travelId);
}
function migrateLegacyCalendars(payload) {
  const defaults = ensureDefaultsState(payload.data.defaults);
  return {
    version: CALENDAR_STORE_VERSION,
    data: {
      calendars: payload.data.calendars ?? [],
      defaults
    }
  };
}
function isCalendarRepositoryValidationError(error) {
  if (!(error instanceof Error)) {
    return false;
  }
  return /already exists|not found|required/i.test(error.message);
}

// src/apps/almanac/data/vault-event-repository.ts
init_calendar_timestamp();
init_calendar_event();
var EVENT_STORE_VERSION = "1.4.0";
var EVENT_STORE_PATH = "SaltMarcher/Almanac/events.json";
var VaultEventRepository = class {
  constructor(calendars, vault) {
    this.calendars = calendars;
    this.store = new JsonStore(vault, {
      path: EVENT_STORE_PATH,
      currentVersion: EVENT_STORE_VERSION,
      initialData: () => ({ eventsByCalendar: {} })
    });
  }
  async listEvents(calendarId, range) {
    const schema = await this.requireCalendar(calendarId);
    const events = await this.readCalendarEvents(calendarId);
    if (!range) {
      return events;
    }
    const start = range.start;
    const end = range.end;
    return events.filter((event) => {
      const anchor = getEventAnchorTimestamp(event) ?? event.date;
      const afterStart = compareTimestampsWithSchema(schema, anchor, start) >= 0;
      const beforeEnd = compareTimestampsWithSchema(schema, anchor, end) <= 0;
      return afterStart && beforeEnd;
    });
  }
  async listUpcoming(calendarId, limit) {
    const schema = await this.requireCalendar(calendarId);
    const events = await this.readCalendarEvents(calendarId);
    const sorted = [...events].sort((a, b) => {
      const aAnchor = getEventAnchorTimestamp(a) ?? a.date;
      const bAnchor = getEventAnchorTimestamp(b) ?? b.date;
      return compareTimestampsWithSchema(schema, aAnchor, bAnchor);
    });
    return sorted.slice(0, limit);
  }
  async createEvent(event) {
    try {
      await this.store.update((state) => {
        const eventsByCalendar = { ...state.eventsByCalendar };
        const events = [...eventsByCalendar[event.calendarId] ?? []];
        if (events.some((entry) => entry.id === event.id)) {
          throw new Error(`Event with ID ${event.id} already exists`);
        }
        events.push(event);
        eventsByCalendar[event.calendarId] = events;
        return { eventsByCalendar };
      });
    } catch (error) {
      reportAlmanacGatewayIssue({
        operation: "event.repository.createEvent",
        scope: "event",
        code: isEventRepositoryValidationError(error) ? "validation_error" : "io_error",
        error,
        context: { calendarId: event.calendarId, eventId: event.id }
      });
      throw error;
    }
  }
  async updateEvent(id, event) {
    try {
      await this.store.update((state) => {
        const eventsByCalendar = { ...state.eventsByCalendar };
        let found = false;
        for (const [calendarId, events] of Object.entries(eventsByCalendar)) {
          const index = events.findIndex((entry) => entry.id === id);
          if (index === -1) {
            continue;
          }
          events[index] = { ...events[index], ...event };
          eventsByCalendar[calendarId] = [...events];
          found = true;
        }
        if (!found) {
          throw new Error(`Event with ID ${id} not found`);
        }
        return { eventsByCalendar };
      });
    } catch (error) {
      reportAlmanacGatewayIssue({
        operation: "event.repository.updateEvent",
        scope: "event",
        code: isEventRepositoryValidationError(error) ? "validation_error" : "io_error",
        error,
        context: { eventId: id }
      });
      throw error;
    }
  }
  async deleteEvent(id) {
    try {
      await this.store.update((state) => {
        const eventsByCalendar = {};
        let found = false;
        for (const [calendarId, events] of Object.entries(state.eventsByCalendar)) {
          const remaining = events.filter((event) => event.id !== id);
          if (remaining.length !== events.length) {
            found = true;
          }
          eventsByCalendar[calendarId] = remaining;
        }
        if (!found) {
          throw new Error(`Event with ID ${id} not found`);
        }
        return { eventsByCalendar };
      });
    } catch (error) {
      reportAlmanacGatewayIssue({
        operation: "event.repository.deleteEvent",
        scope: "event",
        code: isEventRepositoryValidationError(error) ? "validation_error" : "io_error",
        error,
        context: { eventId: id }
      });
      throw error;
    }
  }
  async getEventsInRange(calendarId, schema, start, end) {
    const range = { calendarId, start, end };
    return this.listEvents(calendarId, range);
  }
  async getUpcomingEvents(calendarId, schema, from, limit) {
    const events = await this.listEvents(calendarId);
    return events.filter((event) => {
      const anchor = getEventAnchorTimestamp(event) ?? event.date;
      return compareTimestampsWithSchema(schema, anchor, from) >= 0;
    }).slice(0, limit);
  }
  async readCalendarEvents(calendarId) {
    const state = await this.store.read();
    return [...state.eventsByCalendar[calendarId] ?? []];
  }
  async requireCalendar(calendarId) {
    const calendar = await this.calendars.getCalendar(calendarId);
    if (!calendar) {
      throw new Error(`Calendar with ID ${calendarId} not found`);
    }
    return calendar;
  }
};
function isEventRepositoryValidationError(error) {
  if (!(error instanceof Error)) {
    return false;
  }
  return /already exists|not found/i.test(error.message);
}

// src/apps/almanac/data/vault-almanac-repository.ts
init_calendar_timestamp();
var PHENOMENA_STORE_VERSION = "1.4.0";
var PHENOMENA_STORE_PATH = "SaltMarcher/Almanac/phenomena.json";
var DEFAULT_PAGE_SIZE2 = 25;
var VaultAlmanacRepository = class {
  constructor(calendars, vault) {
    this.calendars = calendars;
    this.store = new JsonStore(vault, {
      path: PHENOMENA_STORE_PATH,
      currentVersion: PHENOMENA_STORE_VERSION,
      initialData: () => ({ phenomena: [] })
    });
  }
  async listPhenomena(input) {
    if (!input) {
      const state2 = await this.store.read();
      return state2.phenomena.map((phenomenon) => ({ ...phenomenon }));
    }
    const state = await this.store.read();
    const calendars = await this.calendars.listCalendars();
    const calendarMap = new Map(calendars.map((calendar) => [calendar.id, calendar]));
    const visible = state.phenomena.filter((phenomenon) => matchesFilters(phenomenon, input.filters, calendarMap));
    const decorated = await Promise.all(
      visible.map(async (phenomenon) => ({
        phenomenon,
        summary: await this.buildSummary(phenomenon, calendars)
      }))
    );
    const sorted = sortSummaries(decorated, input.sort);
    const { items, nextCursor } = paginate2(sorted, input.pagination ?? { limit: DEFAULT_PAGE_SIZE2 });
    return {
      items: items.map((entry) => entry.summary),
      pagination: { cursor: nextCursor, hasMore: nextCursor !== void 0 },
      generatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  async getPhenomenon(id) {
    const state = await this.store.read();
    return state.phenomena.find((entry) => entry.id === id) ?? null;
  }
  async upsertPhenomenon(draft) {
    try {
      await this.store.update((state) => {
        const phenomena = [...state.phenomena];
        const index = phenomena.findIndex((entry) => entry.id === draft.id);
        if (index === -1) {
          phenomena.push({ ...draft });
        } else {
          phenomena[index] = { ...phenomena[index], ...draft };
        }
        return { phenomena };
      });
      const stored = await this.getPhenomenon(draft.id);
      if (!stored) {
        throw new AlmanacRepositoryError("validation_error", `Phenomenon ${draft.id} disappeared during update`);
      }
      return stored;
    } catch (error) {
      const code = error instanceof AlmanacRepositoryError ? error.code : "io_error";
      reportAlmanacGatewayIssue({
        operation: "phenomenon.repository.upsert",
        scope: "phenomenon",
        code,
        error,
        context: { phenomenonId: draft.id }
      });
      throw error;
    }
  }
  async deletePhenomenon(id) {
    try {
      await this.store.update((state) => {
        const remaining = state.phenomena.filter((entry) => entry.id !== id);
        if (remaining.length === state.phenomena.length) {
          throw new AlmanacRepositoryError("validation_error", `Phenomenon ${id} not found`);
        }
        return { phenomena: remaining };
      });
    } catch (error) {
      const code = error instanceof AlmanacRepositoryError ? error.code : "io_error";
      reportAlmanacGatewayIssue({
        operation: "phenomenon.repository.delete",
        scope: "phenomenon",
        code,
        error,
        context: { phenomenonId: id }
      });
      throw error;
    }
  }
  async updateLinks(update) {
    try {
      const phenomenon = await this.getPhenomenon(update.phenomenonId);
      if (!phenomenon) {
        throw new AlmanacRepositoryError("validation_error", `Phenomenon ${update.phenomenonId} not found`);
      }
      const calendars = await this.calendars.listCalendars();
      const calendarSet = new Set(calendars.map((calendar) => calendar.id));
      const duplicates = findDuplicateCalendarIds2(update.calendarLinks);
      if (duplicates.length > 0) {
        throw new AlmanacRepositoryError("phenomenon_conflict", "Calendar links contain duplicates", {
          duplicates
        });
      }
      for (const link of update.calendarLinks) {
        if (!calendarSet.has(link.calendarId)) {
          throw new AlmanacRepositoryError("validation_error", `Calendar ${link.calendarId} not found`, {
            calendarId: link.calendarId
          });
        }
      }
      if (phenomenon.rule.type === "astronomical") {
        const hasReference = Boolean(phenomenon.rule.referenceCalendarId);
        const hasHookReference = update.calendarLinks.some(
          (link) => link.hook && typeof link.hook.config?.referenceCalendarId === "string"
        );
        if (!hasReference && !hasHookReference) {
          throw new AlmanacRepositoryError(
            "astronomy_source_missing",
            "Astronomical phenomena require a reference calendar"
          );
        }
      }
      await this.store.update((state) => {
        const phenomena = [...state.phenomena];
        const index = phenomena.findIndex((entry) => entry.id === phenomenon.id);
        if (index === -1) {
          throw new AlmanacRepositoryError("validation_error", `Phenomenon ${phenomenon.id} disappeared during update`);
        }
        const appliesToCalendarIds = update.calendarLinks.map((link) => link.calendarId);
        const visibility = appliesToCalendarIds.length === 0 ? "all_calendars" : "selected";
        const hooks = buildHooksFromLinks(update.calendarLinks, phenomenon);
        const priority = update.calendarLinks.reduce((max, link) => Math.max(max, link.priority), phenomenon.priority);
        phenomena[index] = {
          ...phenomena[index],
          appliesToCalendarIds,
          visibility,
          hooks,
          priority
        };
        return { phenomena };
      });
      const stored = await this.getPhenomenon(update.phenomenonId);
      if (!stored) {
        throw new AlmanacRepositoryError(
          "validation_error",
          `Phenomenon ${update.phenomenonId} disappeared during update`
        );
      }
      return stored;
    } catch (error) {
      const code = error instanceof AlmanacRepositoryError ? error.code : "io_error";
      reportAlmanacGatewayIssue({
        operation: "phenomenon.repository.updateLinks",
        scope: "phenomenon",
        code,
        error,
        context: { phenomenonId: update.phenomenonId }
      });
      throw error;
    }
  }
  async listTemplates() {
    const state = await this.store.read();
    return state.phenomena.filter((phenomenon) => phenomenon.template).map((phenomenon) => ({
      id: phenomenon.id,
      name: phenomenon.name,
      category: phenomenon.category,
      rule: phenomenon.rule,
      effects: phenomenon.effects
    }));
  }
  async buildSummary(phenomenon, calendars) {
    const nextOccurrence = await this.computeNextOccurrence(phenomenon, calendars);
    const linkedCalendars = phenomenon.visibility === "all_calendars" ? calendars.map((calendar) => calendar.id) : phenomenon.appliesToCalendarIds;
    return {
      id: phenomenon.id,
      name: phenomenon.name,
      category: phenomenon.category,
      nextOccurrence,
      linkedCalendars,
      badge: phenomenon.tags?.[0]
    };
  }
  async computeNextOccurrence(phenomenon, calendars) {
    const candidates = [];
    for (const calendar of calendars) {
      if (!isPhenomenonVisibleForCalendar(phenomenon, calendar.id)) {
        continue;
      }
      const start = createDayTimestamp(
        calendar.id,
        calendar.epoch.year,
        calendar.epoch.monthId,
        calendar.epoch.day
      );
      const occurrence = computeNextPhenomenonOccurrence(phenomenon, calendar, calendar.id, start);
      if (!occurrence) {
        continue;
      }
      candidates.push({
        calendar,
        occurrence: {
          calendarId: occurrence.calendarId,
          occurrence: occurrence.timestamp,
          timeLabel: formatTimestamp(
            occurrence.timestamp,
            calendar.months.find((month) => month.id === occurrence.timestamp.monthId)?.name
          )
        }
      });
    }
    candidates.sort((a, b) => compareOccurrencesWithSchema(a, b));
    return candidates[0]?.occurrence;
  }
};
function matchesFilters(phenomenon, filters, calendars) {
  if (filters.categories?.length) {
    if (!filters.categories.includes(phenomenon.category)) {
      return false;
    }
  }
  if (filters.calendarIds?.length) {
    const visibleCalendars = phenomenon.visibility === "all_calendars" ? Array.from(calendars.keys()) : phenomenon.appliesToCalendarIds;
    const hasOverlap = filters.calendarIds.some((calendarId) => visibleCalendars.includes(calendarId));
    if (!hasOverlap) {
      return false;
    }
  }
  return true;
}
function sortSummaries(summaries, sort) {
  const copy = [...summaries];
  copy.sort((a, b) => {
    if (sort === "priority_desc") {
      return b.phenomenon.priority - a.phenomenon.priority || a.summary.name.localeCompare(b.summary.name);
    }
    if (sort === "category_asc") {
      return a.summary.category.localeCompare(b.summary.category) || a.summary.name.localeCompare(b.summary.name);
    }
    const aTime = a.summary.nextOccurrence?.occurrence;
    const bTime = b.summary.nextOccurrence?.occurrence;
    if (!aTime && !bTime) {
      return a.summary.name.localeCompare(b.summary.name);
    }
    if (!aTime) {
      return 1;
    }
    if (!bTime) {
      return -1;
    }
    return compareTimestampTuples(aTime, bTime);
  });
  return copy;
}
function paginate2(entries, pagination) {
  const offset = pagination.cursor ? Number.parseInt(pagination.cursor, 10) || 0 : 0;
  const limit = pagination.limit ?? DEFAULT_PAGE_SIZE2;
  const slice = entries.slice(offset, offset + limit);
  const nextOffset = offset + slice.length;
  const hasMore = nextOffset < entries.length;
  return {
    items: slice,
    nextCursor: hasMore ? String(nextOffset) : void 0
  };
}
function compareTimestampTuples(a, b) {
  if (a.year !== b.year) {
    return a.year - b.year;
  }
  if (a.monthId !== b.monthId) {
    return a.monthId.localeCompare(b.monthId);
  }
  if (a.day !== b.day) {
    return a.day - b.day;
  }
  if ((a.hour ?? 0) !== (b.hour ?? 0)) {
    return (a.hour ?? 0) - (b.hour ?? 0);
  }
  return (a.minute ?? 0) - (b.minute ?? 0);
}
function compareOccurrencesWithSchema(a, b) {
  const first = a.occurrence.occurrence;
  const second = b.occurrence.occurrence;
  if (first.calendarId === second.calendarId) {
    return compareTimestampsWithSchema(a.calendar, first, second);
  }
  return compareTimestampTuples(first, second);
}
function findDuplicateCalendarIds2(links) {
  const counts = /* @__PURE__ */ new Map();
  for (const link of links) {
    counts.set(link.calendarId, (counts.get(link.calendarId) ?? 0) + 1);
  }
  return Array.from(counts.entries()).filter(([, count]) => count > 1).map(([calendarId]) => calendarId);
}
function buildHooksFromLinks(links, phenomenon) {
  const existing = phenomenon.hooks ?? [];
  const linkedHooks = links.filter((link) => Boolean(link.hook)).map((link) => ({ ...link.hook, priority: link.priority }));
  if (linkedHooks.length === 0) {
    return existing;
  }
  return linkedHooks;
}

// src/apps/almanac/data/vault-calendar-state-gateway.ts
init_calendar_event();
init_calendar_schema();
init_calendar_timestamp();
init_time_arithmetic();
var GLOBAL_SCOPE2 = "__global__";
var STATE_STORE_VERSION = "1.0.0";
var STATE_STORE_PATH = "SaltMarcher/Almanac/state.json";
var VaultCalendarStateGateway = class {
  constructor(calendarRepo, eventRepo, phenomenonRepo, vault, hookDispatcher) {
    this.calendarRepo = calendarRepo;
    this.eventRepo = eventRepo;
    this.phenomenonRepo = phenomenonRepo;
    this.hookDispatcher = hookDispatcher;
    this.cache = createInitialStore();
    this.initialised = false;
    this.pendingMutations = [];
    this.pendingFlushPromise = null;
    this.pendingFlushResolve = null;
    this.pendingFlushReject = null;
    this.pendingFlushTimer = null;
    this.activeFlush = null;
    this.persistenceDebounceMs = 25;
    this.store = new JsonStore(vault, {
      path: STATE_STORE_PATH,
      currentVersion: STATE_STORE_VERSION,
      initialData: () => createInitialStore()
    });
    this.ready = this.store.read().then((data) => {
      this.cache = normaliseStore(data);
      this.initialised = true;
    }).catch((error) => {
      const gatewayError = createGatewayIoError("Failed to load calendar state store");
      reportAlmanacGatewayIssue({
        operation: "calendar.gateway.bootstrap",
        scope: "calendar",
        code: gatewayError.code,
        error,
        context: gatewayError.context
      });
      this.initialised = true;
    });
  }
  async loadSnapshot(options) {
    await this.ensureReady();
    const travelId = options?.travelId ?? null;
    const scope = this.ensureScope(travelId);
    const effective = await this.resolveEffectiveCalendar(travelId);
    const travelDefaultCalendarId = travelId ? await this.calendarRepo.getTravelDefault(travelId) : null;
    if (!effective?.calendar) {
      return {
        activeCalendar: null,
        currentTimestamp: null,
        upcomingEvents: [],
        upcomingPhenomena: [],
        defaultCalendarId: effective?.isGlobalDefault ? effective.calendarId ?? null : null,
        travelDefaultCalendarId,
        isGlobalDefault: effective?.isGlobalDefault ?? false,
        wasAutoSelected: effective?.wasAutoSelected ?? false
      };
    }
    const activeCalendar = scope.activeCalendarId ? await this.calendarRepo.getCalendar(scope.activeCalendarId) : effective.calendar;
    if (!activeCalendar) {
      return {
        activeCalendar: null,
        currentTimestamp: null,
        upcomingEvents: [],
        upcomingPhenomena: [],
        defaultCalendarId: effective.isGlobalDefault ? effective.calendar.id : null,
        travelDefaultCalendarId,
        isGlobalDefault: effective.isGlobalDefault,
        wasAutoSelected: effective.wasAutoSelected
      };
    }
    const upcomingEvents = scope.currentTimestamp ? await this.eventRepo.getUpcomingEvents(
      activeCalendar.id,
      activeCalendar,
      scope.currentTimestamp,
      5
    ) : [];
    const visiblePhenomena = await this.listVisiblePhenomena(activeCalendar);
    const upcomingPhenomena = this.computeUpcomingPhenomenaForCalendar(
      activeCalendar,
      visiblePhenomena,
      scope.currentTimestamp
    );
    return {
      activeCalendar,
      currentTimestamp: scope.currentTimestamp,
      upcomingEvents,
      upcomingPhenomena,
      defaultCalendarId: effective.isGlobalDefault ? effective.calendar.id : null,
      travelDefaultCalendarId,
      isGlobalDefault: effective.isGlobalDefault,
      wasAutoSelected: effective.wasAutoSelected
    };
  }
  async setActiveCalendar(calendarId, options) {
    await this.ensureReady();
    const calendar = await this.calendarRepo.getCalendar(calendarId);
    if (!calendar) {
      const error = createGatewayValidationError(`Calendar with ID ${calendarId} not found`, {
        calendarId,
        travelId: options?.travelId ?? null
      });
      reportAlmanacGatewayIssue({
        operation: "calendar.gateway.setActiveCalendar",
        scope: options?.travelId ? "travel" : "calendar",
        code: error.code,
        error,
        context: error.context
      });
      throw error;
    }
    await this.persistState((state) => {
      const scope = this.ensureScope(options?.travelId ?? null, state);
      scope.activeCalendarId = calendarId;
      if (options?.initialTimestamp) {
        scope.currentTimestamp = cloneTimestamp(options.initialTimestamp);
        return;
      }
      if (scope.currentTimestamp && scope.currentTimestamp.calendarId === calendarId) {
        return;
      }
      const firstMonth = calendar.months[0] ?? getMonthById(calendar, calendar.epoch.monthId);
      scope.currentTimestamp = createDayTimestamp(
        calendar.id,
        calendar.epoch.year,
        firstMonth?.id ?? calendar.epoch.monthId,
        calendar.epoch.day
      );
    });
  }
  async setDefaultCalendar(calendarId, options) {
    const scope = options?.scope ?? "global";
    if (scope === "travel") {
      const travelId = options?.travelId;
      if (!travelId) {
        const error = createGatewayValidationError("Travel ID required when persisting travel default", {
          calendarId
        });
        reportAlmanacGatewayIssue({
          operation: "calendar.gateway.setDefaultCalendar",
          scope: "travel",
          code: error.code,
          error,
          context: error.context
        });
        throw error;
      }
      await this.calendarRepo.setDefault({ calendarId, scope: "travel", travelId });
      return;
    }
    await this.calendarRepo.setDefault({ calendarId, scope: "global" });
  }
  async setCurrentTimestamp(timestamp, options) {
    await this.ensureReady();
    await this.persistState((state) => {
      const scope = this.ensureScope(options?.travelId ?? null, state);
      if (!scope.activeCalendarId) {
        const error = createGatewayValidationError("No active calendar set", {
          travelId: options?.travelId ?? null
        });
        reportAlmanacGatewayIssue({
          operation: "calendar.gateway.setCurrentTimestamp",
          scope: options?.travelId ? "travel" : "calendar",
          code: error.code,
          error,
          context: error.context
        });
        throw error;
      }
      if (timestamp.calendarId !== scope.activeCalendarId) {
        const error = createGatewayValidationError("Timestamp calendar does not match active calendar", {
          travelId: options?.travelId ?? null,
          calendarId: timestamp.calendarId,
          activeCalendarId: scope.activeCalendarId
        });
        reportAlmanacGatewayIssue({
          operation: "calendar.gateway.setCurrentTimestamp",
          scope: options?.travelId ? "travel" : "calendar",
          code: error.code,
          error,
          context: error.context
        });
        throw error;
      }
      scope.currentTimestamp = cloneTimestamp(timestamp);
    });
  }
  async advanceTimeBy(amount, unit, options) {
    await this.ensureReady();
    const travelId = options?.travelId ?? null;
    const scope = this.ensureScope(travelId);
    if (!scope.activeCalendarId || !scope.currentTimestamp) {
      const error = createGatewayValidationError("No active calendar or current timestamp set", {
        travelId,
        activeCalendarId: scope.activeCalendarId
      });
      reportAlmanacGatewayIssue({
        operation: "calendar.gateway.advanceTimeBy",
        scope: travelId ? "travel" : "calendar",
        code: error.code,
        error,
        context: error.context
      });
      throw error;
    }
    const calendar = await this.calendarRepo.getCalendar(scope.activeCalendarId);
    if (!calendar) {
      const error = createGatewayValidationError(`Calendar ${scope.activeCalendarId} not found`, {
        travelId,
        calendarId: scope.activeCalendarId
      });
      reportAlmanacGatewayIssue({
        operation: "calendar.gateway.advanceTimeBy",
        scope: travelId ? "travel" : "calendar",
        code: error.code,
        error,
        context: error.context
      });
      throw error;
    }
    const visiblePhenomena = await this.listVisiblePhenomena(calendar);
    const previousTimestamp = cloneTimestamp(scope.currentTimestamp);
    const result = advanceTime(calendar, previousTimestamp, amount, unit);
    const [triggeredEvents, triggeredPhenomena] = await Promise.all([
      this.eventRepo.getEventsInRange(
        scope.activeCalendarId,
        calendar,
        previousTimestamp,
        result.timestamp
      ),
      Promise.resolve(
        this.computeTriggeredPhenomenaBetween(
          calendar,
          visiblePhenomena,
          previousTimestamp,
          result.timestamp
        )
      )
    ]);
    const relevantEvents = triggeredEvents.filter(
      (event) => compareTimestampsWithSchema(
        calendar,
        getEventAnchorTimestamp(event) ?? event.date,
        previousTimestamp
      ) > 0
    );
    const upcomingPhenomena = this.computeUpcomingPhenomenaForCalendar(
      calendar,
      visiblePhenomena,
      result.timestamp
    );
    await this.persistState((state) => {
      const scoped = this.ensureScope(travelId, state);
      scoped.currentTimestamp = cloneTimestamp(result.timestamp);
    });
    if (this.hookDispatcher && (relevantEvents.length > 0 || triggeredPhenomena.length > 0)) {
      try {
        await this.hookDispatcher.dispatchHooks(relevantEvents, triggeredPhenomena, {
          scope: travelId ? "travel" : "global",
          travelId,
          reason: "advance",
          ...options?.hookContext
        });
      } catch (error) {
        const causeMessage = error instanceof Error && error.message ? `: ${error.message}` : "";
        const gatewayError = new CalendarGatewayError(
          "io_error",
          `Failed to dispatch hooks for time advance${causeMessage}`,
          {
            travelId,
            scope: travelId ? "travel" : "global"
          }
        );
        reportAlmanacGatewayIssue({
          operation: "calendar.gateway.advanceTimeBy",
          scope: travelId ? "travel" : "calendar",
          code: gatewayError.code,
          error,
          context: gatewayError.context
        });
        throw gatewayError;
      }
    }
    return {
      timestamp: result.timestamp,
      triggeredEvents: relevantEvents,
      triggeredPhenomena,
      upcomingPhenomena
    };
  }
  async loadPreferences() {
    await this.ensureReady();
    return clonePreferences2(this.cache.preferences);
  }
  async savePreferences(partial) {
    await this.ensureReady();
    await this.persistState((state) => {
      const merged = {
        ...state.preferences,
        ...partial
      };
      if (partial.lastZoomByMode) {
        merged.lastZoomByMode = {
          ...state.preferences.lastZoomByMode ?? {},
          ...partial.lastZoomByMode
        };
      }
      if (partial.eventsFilters) {
        merged.eventsFilters = {
          categories: [...partial.eventsFilters.categories ?? []],
          calendarIds: [...partial.eventsFilters.calendarIds ?? []]
        };
      }
      state.preferences = merged;
    }, { debounce: true });
  }
  getCurrentTimestamp(options) {
    if (!this.initialised) {
      return null;
    }
    const scope = this.ensureScope(options?.travelId ?? null);
    return scope.currentTimestamp ? cloneTimestamp(scope.currentTimestamp) : null;
  }
  getActiveCalendarId(options) {
    if (!this.initialised) {
      return null;
    }
    const scope = this.ensureScope(options?.travelId ?? null);
    return scope.activeCalendarId ?? null;
  }
  async getTravelLeafPreferences(travelId) {
    await this.ensureReady();
    const prefs = this.cache.travelLeaf[travelId];
    return prefs ? { ...prefs } : null;
  }
  async saveTravelLeafPreferences(travelId, prefs) {
    await this.ensureReady();
    await this.persistState((state) => {
      state.travelLeaf[travelId] = { ...prefs };
    }, { debounce: true });
  }
  async ensureReady() {
    if (this.initialised) {
      return;
    }
    await this.ready;
    this.initialised = true;
  }
  ensureScope(travelId, state = this.cache) {
    const key = travelId ?? GLOBAL_SCOPE2;
    if (!state.scopes[key]) {
      state.scopes[key] = { activeCalendarId: null, currentTimestamp: null };
    }
    if (state === this.cache) {
      this.cache.scopes[key] = state.scopes[key];
    }
    return state.scopes[key];
  }
  async resolveEffectiveCalendar(travelId) {
    if (travelId) {
      const travelDefaultId = await this.calendarRepo.getTravelDefault(travelId);
      if (travelDefaultId) {
        const travelCalendar = await this.calendarRepo.getCalendar(travelDefaultId);
        if (travelCalendar) {
          return {
            calendar: travelCalendar,
            calendarId: travelDefaultId,
            isGlobalDefault: false,
            wasAutoSelected: false
          };
        }
      }
    }
    const globalDefault = await this.calendarRepo.getGlobalDefault();
    if (globalDefault) {
      const calendar = await this.calendarRepo.getCalendar(globalDefault);
      if (calendar) {
        return {
          calendar,
          calendarId: globalDefault,
          isGlobalDefault: true,
          wasAutoSelected: false
        };
      }
    }
    const calendars = await this.calendarRepo.listCalendars();
    if (calendars.length > 0) {
      return {
        calendar: calendars[0],
        calendarId: calendars[0].id,
        isGlobalDefault: false,
        wasAutoSelected: true
      };
    }
    return null;
  }
  async flushPendingPersistence() {
    await this.flushDebouncedPersist();
  }
  async persistState(mutator, options) {
    if (options?.debounce) {
      return this.enqueueDebouncedPersist(mutator);
    }
    await this.flushDebouncedPersist();
    await this.commitMutations([mutator]);
  }
  enqueueDebouncedPersist(mutator) {
    this.pendingMutations.push(mutator);
    if (!this.pendingFlushPromise) {
      this.pendingFlushPromise = new Promise((resolve, reject) => {
        this.pendingFlushResolve = resolve;
        this.pendingFlushReject = reject;
      });
    }
    if (this.pendingFlushTimer) {
      clearTimeout(this.pendingFlushTimer);
    }
    this.pendingFlushTimer = setTimeout(() => {
      void this.flushDebouncedPersist();
    }, this.persistenceDebounceMs);
    return this.pendingFlushPromise;
  }
  async flushDebouncedPersist() {
    if (this.pendingFlushTimer) {
      clearTimeout(this.pendingFlushTimer);
      this.pendingFlushTimer = null;
    }
    if (this.activeFlush) {
      return this.activeFlush;
    }
    if (this.pendingMutations.length === 0) {
      if (this.pendingFlushPromise) {
        this.pendingFlushResolve?.();
        this.pendingFlushPromise = null;
        this.pendingFlushResolve = null;
        this.pendingFlushReject = null;
      }
      return;
    }
    const mutations = this.pendingMutations;
    this.pendingMutations = [];
    const resolve = this.pendingFlushResolve;
    const reject = this.pendingFlushReject;
    this.pendingFlushPromise = null;
    this.pendingFlushResolve = null;
    this.pendingFlushReject = null;
    const flushOperation = this.commitMutations(mutations).then(() => {
      resolve?.();
    }).catch((error) => {
      reject?.(error);
      throw error;
    }).finally(() => {
      this.activeFlush = null;
      if (this.pendingMutations.length > 0) {
        void this.flushDebouncedPersist();
      }
    });
    this.activeFlush = flushOperation;
    await flushOperation;
  }
  async commitMutations(mutations) {
    try {
      await this.store.update((state) => {
        const draft = normaliseStore(state);
        for (const mutate of mutations) {
          mutate(draft);
        }
        this.cache = normaliseStore(draft);
        return this.cache;
      });
    } catch (error) {
      const gatewayError = createGatewayIoError("Failed to persist calendar state");
      reportAlmanacGatewayIssue({
        operation: "calendar.gateway.persistState",
        scope: "calendar",
        code: gatewayError.code,
        error,
        context: gatewayError.context
      });
      throw gatewayError;
    }
  }
  async listVisiblePhenomena(calendar) {
    const phenomena = await this.phenomenonRepo.listPhenomena();
    return phenomena.filter((phenomenon) => isPhenomenonVisibleForCalendar(phenomenon, calendar.id));
  }
  computeUpcomingPhenomenaForCalendar(calendar, phenomena, from, limit = 5) {
    if (phenomena.length === 0) {
      return [];
    }
    const anchor = from ?? createDayTimestamp(calendar.id, calendar.epoch.year, calendar.epoch.monthId, calendar.epoch.day);
    const occurrences = [];
    for (const phenomenon of phenomena) {
      try {
        const occurrence = computeNextPhenomenonOccurrence(
          phenomenon,
          calendar,
          calendar.id,
          anchor,
          { includeStart: true }
        );
        if (occurrence) {
          occurrences.push(occurrence);
        }
      } catch {
        continue;
      }
    }
    return sortOccurrencesByTimestamp(calendar, occurrences).slice(0, limit);
  }
  computeTriggeredPhenomenaBetween(calendar, phenomena, start, end) {
    if (phenomena.length === 0) {
      return [];
    }
    const occurrences = [];
    for (const phenomenon of phenomena) {
      try {
        const result = computePhenomenonOccurrencesInRange(
          phenomenon,
          calendar,
          calendar.id,
          start,
          end
        );
        occurrences.push(...result);
      } catch {
        continue;
      }
    }
    return sortOccurrencesByTimestamp(calendar, occurrences);
  }
};
function clonePreferences2(preferences) {
  const base = preferences ?? {};
  return {
    ...base,
    lastZoomByMode: base.lastZoomByMode ? { ...base.lastZoomByMode } : void 0,
    eventsFilters: base.eventsFilters ? {
      categories: [...base.eventsFilters.categories],
      calendarIds: [...base.eventsFilters.calendarIds]
    } : void 0
  };
}
function cloneTimestamp(timestamp) {
  return { ...timestamp };
}
function normaliseStore(input) {
  const scopes = { ...input.scopes };
  if (!scopes[GLOBAL_SCOPE2]) {
    scopes[GLOBAL_SCOPE2] = { activeCalendarId: null, currentTimestamp: null };
  }
  return {
    scopes,
    preferences: clonePreferences2(input.preferences),
    travelLeaf: { ...input.travelLeaf ?? {} }
  };
}
function createInitialStore() {
  return {
    scopes: { [GLOBAL_SCOPE2]: { activeCalendarId: null, currentTimestamp: null } },
    preferences: {},
    travelLeaf: {}
  };
}

// src/apps/almanac/index.ts
init_cartographer_gateway();
function createAlmanacController(app) {
  const calendarRepo = new VaultCalendarRepository(app.vault);
  const eventRepo = new VaultEventRepository(calendarRepo, app.vault);
  const almanacRepo = new VaultAlmanacRepository(calendarRepo, app.vault);
  const gateway = new VaultCalendarStateGateway(
    calendarRepo,
    eventRepo,
    almanacRepo,
    app.vault,
    cartographerHookGateway
  );
  return new AlmanacController(app, {
    calendarRepo,
    eventRepo,
    phenomenonRepo: almanacRepo,
    gateway
  });
}
var VIEW_TYPE_ALMANAC = "almanac-view";
var VIEW_ALMANAC = VIEW_TYPE_ALMANAC;
var AlmanacView = class extends import_obsidian33.ItemView {
  constructor(leaf) {
    super(leaf);
    this.hostEl = null;
    this.controller = createAlmanacController(this.app);
  }
  getViewType() {
    return VIEW_TYPE_ALMANAC;
  }
  getDisplayText() {
    return "Almanac";
  }
  getIcon() {
    return "calendar";
  }
  async onOpen() {
    const container = this.containerEl;
    const content = container.children[1];
    content.empty();
    this.hostEl = content.createDiv({ cls: "almanac-host" });
    await this.controller.onOpen(this.hostEl);
  }
  async onClose() {
    await this.controller.onClose();
    this.hostEl = null;
  }
};
async function openAlmanac(app) {
  const { workspace } = app;
  const existingLeaves = workspace.getLeavesOfType(VIEW_TYPE_ALMANAC);
  if (existingLeaves.length > 0) {
    workspace.revealLeaf(existingLeaves[0]);
    return;
  }
  const leaf = workspace.getLeaf(true);
  await leaf.setViewState({ type: VIEW_TYPE_ALMANAC, active: true });
  workspace.revealLeaf(leaf);
}

// src/apps/view-manifest.ts
var VIEW_MANIFEST = [
  {
    viewType: VIEW_CARTOGRAPHER,
    integrationId: "obsidian:cartographer-view",
    displayName: "Cartographer",
    viewIcon: "compass",
    createView: (leaf) => new CartographerView(leaf),
    activation: {
      open: (app) => openCartographer(app),
      ribbon: {
        icon: "compass",
        title: "Open Cartographer"
      },
      commands: [
        {
          id: "open-cartographer",
          name: "Open Cartographer"
        }
      ]
    }
  },
  {
    viewType: VIEW_ENCOUNTER,
    integrationId: "obsidian:encounter-view",
    displayName: "Encounter",
    viewIcon: "swords",
    createView: (leaf) => new EncounterView(leaf)
  },
  {
    viewType: VIEW_LIBRARY,
    integrationId: "obsidian:library-view",
    displayName: "Library",
    viewIcon: "library",
    createView: (leaf) => new LibraryView(leaf),
    activation: {
      open: (app) => openLibrary(app),
      ribbon: {
        icon: "book",
        title: "Open Library"
      },
      commands: [
        {
          id: "open-library",
          name: "Open Library"
        }
      ]
    }
  },
  {
    viewType: VIEW_ALMANAC,
    integrationId: "obsidian:almanac-view",
    displayName: "Almanac",
    viewIcon: "calendar",
    createView: (leaf) => new AlmanacView(leaf),
    activation: {
      open: (app) => openAlmanac(app),
      ribbon: {
        icon: "calendar",
        title: "Open Almanac (MVP)"
      },
      commands: [
        {
          id: "open-almanac",
          name: "Open Almanac"
        }
      ]
    }
  }
];

// src/app/css.ts
var viewContainerCss = `
/* === View Container === */
.sm-view-container {
    position: relative;
    display: flex;
    align-items: stretch;
    justify-content: stretch;
    border-radius: 12px;
    border: 1px solid var(--background-modifier-border);
    background: var(--background-primary);
    overflow: hidden;
}

.sm-view-container__viewport {
    position: relative;
    flex: 1;
    overflow: hidden;
    cursor: grab;
    touch-action: none;
    background: color-mix(in srgb, var(--background-secondary) 90%, transparent);
}

.sm-view-container__viewport.is-panning {
    cursor: grabbing;
}

.sm-view-container__stage {
    position: relative;
    width: 100%;
    height: 100%;
    transform-origin: top left;
    display: flex;
    align-items: stretch;
    justify-content: stretch;
}

.sm-view-container__stage > * {
    flex: 1 1 auto;
}

.sm-view-container__overlay {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 1.25rem;
    background: linear-gradient(180deg, rgba(15, 23, 42, 0.45), rgba(15, 23, 42, 0.65));
    color: #fff;
    opacity: 0;
    pointer-events: none;
    transition: opacity 160ms ease;
}

.sm-view-container__overlay.is-visible {
    opacity: 1;
    pointer-events: auto;
}

.sm-view-container__overlay-message {
    max-width: 480px;
    font-size: 0.95rem;
    line-height: 1.4;
}
`;
var mapAndPreviewCss = `
/* === Map-Container & SVG === */
.hex3x3-container {
    width: 100%;
    overflow: hidden;
}

.hex3x3-map {
    display: block;
    width: 100%;
    max-width: 700px;
    margin: .5rem 0;
    user-select: none;
    touch-action: none;
}

.hex3x3-map polygon {
    /* Basis: unbemalt transparent \u2014 Inline-Styles vom Renderer d\xFCrfen das \xFCberschreiben */
    fill: transparent;
    stroke: var(--text-muted);
    stroke-width: 2;
    cursor: pointer;
    transition: fill 120ms ease, fill-opacity 120ms ease, stroke 120ms ease;
}

/* Hover: nur den Rahmen highlighten */
.hex3x3-map polygon:hover { stroke: var(--interactive-accent); }

/* Optional: Hover-F\xFCllung nur f\xFCr unbemalte Tiles */
.hex3x3-map polygon:not([data-painted="1"]):hover { fill-opacity: .15; }

.hex3x3-map text {
    font-size: 12px;
    fill: var(--text-muted);
    pointer-events: none;
    user-select: none;
}

/* Brush-Widget (Kreis) */
.hex3x3-map circle {
    transition: opacity 120ms ease, r 120ms ease, cx 60ms ease, cy 60ms ease;
}

/* === Live-Preview: Interaktion im Codeblock erlauben (optional) === */
.markdown-source-view .cm-preview-code-block .hex3x3-container,
.markdown-source-view .cm-preview-code-block .hex3x3-map { pointer-events: auto; }
.markdown-source-view .cm-preview-code-block .edit-block-button { pointer-events: none; }
`;
var editorLayoutsCss = `
/* === Terrain Editor === */
.sm-terrain-editor { padding:.5rem 0; }
.sm-terrain-editor .desc { color: var(--text-muted); margin-bottom:.25rem; }
.sm-terrain-editor .rows { margin-top:.5rem; }
.sm-terrain-editor .row { display:flex; gap:.5rem; align-items:center; margin:.25rem 0; }
.sm-terrain-editor .row input[type="text"] { flex:1; min-width:0; }
.sm-terrain-editor .addbar { display:flex; gap:.5rem; margin-top:.5rem; }
.sm-terrain-editor .addbar input[type="text"] { flex:1; min-width:0; }

/* Creature Compendium \u2013 nutzt die gleichen Layout-Hilfsklassen */
.sm-creature-compendium { padding:.5rem 0; }
.sm-creature-compendium .desc { color: var(--text-muted); margin-bottom:.25rem; }
.sm-creature-compendium .rows { margin-top:.5rem; }
.sm-creature-compendium .row { display:flex; gap:.5rem; align-items:center; margin:.25rem 0; }
.sm-creature-compendium .row input[type="text"] { flex:1; min-width:0; }
.sm-creature-compendium .addbar { display:flex; gap:.5rem; margin-top:.5rem; }
.sm-creature-compendium .addbar input[type="text"] { flex:1; min-width:0; }

/* Creature Compendium \u2013 Search, Lists & Filters */
.sm-cc-searchbar {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: .5rem;
    margin: .5rem 0;
}
.sm-cc-searchbar > * {
    flex: 1 1 200px;
    min-width: 160px;
}
.sm-cc-searchbar button {
    flex: 0 0 auto;
}

.sm-cc-entry-filter {
    display: inline-flex;
    flex-wrap: wrap;
    align-items: center;
    gap: .35rem;
    padding: .35rem;
    margin: .35rem 0 .65rem;
    border: 1px solid var(--background-modifier-border);
    border-radius: 999px;
    background: color-mix(in srgb, var(--background-secondary) 85%, transparent);
}
.sm-cc-entry-filter button {
    border: none;
    background: transparent;
    padding: .25rem .75rem;
    border-radius: 999px;
    font-size: .85em;
    letter-spacing: .04em;
    text-transform: uppercase;
    font-weight: 600;
    color: var(--text-muted);
    cursor: pointer;
    transition: background 120ms ease, color 120ms ease, box-shadow 120ms ease;
}
.sm-cc-entry-filter button:hover {
    color: var(--text-normal);
}
.sm-cc-entry-filter button.is-active {
    background: var(--interactive-accent);
    color: var(--text-on-accent, #fff);
    box-shadow: 0 0 0 1px color-mix(in srgb, var(--interactive-accent) 55%, transparent);
}

.sm-cc-list {
    display: flex;
    flex-direction: column;
    gap: .45rem;
    margin-top: .35rem;
}
.sm-cc-item {
    display: flex;
    gap: .5rem;
    align-items: center;
    justify-content: space-between;
    padding: .45rem .65rem;
    border: 1px solid var(--background-modifier-border);
    border-radius: 10px;
    background: var(--background-primary);
    box-shadow: 0 3px 10px rgba(15, 23, 42, .04);
}
.sm-cc-item__name { font-weight: 600; }

/* Creature Creator \u2013 Modal Layout */
.modal.sm-cc-create-modal-host {
    width: min(1120px, calc(100vw - 32px));
    max-width: min(1120px, calc(100vw - 32px));
    min-width: min(880px, calc(100vw - 32px));
}
.modal.sm-cc-create-modal-host .modal-content { max-height: calc(100vh - 96px); }
.sm-cc-modal-header { display:flex; flex-direction:column; gap:.35rem; margin-bottom:1rem; }
.sm-cc-modal-header h2 { margin:0; font-size:1.35rem; }
.sm-cc-modal-subtitle { margin:0; color: var(--text-muted); font-size:.95em; }
.sm-cc-shell { display:grid; grid-template-columns:minmax(0, 260px) minmax(0, 1fr); gap:1.5rem; align-items:flex-start; }
.sm-cc-shell__nav { position:sticky; top:0; align-self:start; display:flex; flex-direction:column; gap:.75rem; padding:1rem; border:1px solid var(--background-modifier-border); border-radius:16px; background:color-mix(in srgb, var(--background-secondary) 88%, transparent); box-shadow:0 12px 28px rgba(15,23,42,.08); }
.sm-cc-shell__nav-label { margin:0; font-size:.75rem; letter-spacing:.08em; text-transform:uppercase; color:var(--text-muted); }
.sm-cc-shell__nav-list { display:flex; flex-direction:column; gap:.4rem; }
.sm-cc-shell__nav-button { display:flex; align-items:center; gap:.45rem; width:100%; padding:.45rem .75rem; border-radius:999px; border:1px solid transparent; background:transparent; color:var(--text-muted); font-size:.82rem; letter-spacing:.06em; text-transform:uppercase; font-weight:600; cursor:pointer; transition:background 160ms ease, color 160ms ease, border 160ms ease, box-shadow 160ms ease; }
.sm-cc-shell__nav-button:hover { color:var(--text-normal); }
.sm-cc-shell__nav-button:focus-visible { outline:2px solid var(--interactive-accent); outline-offset:2px; }
.sm-cc-shell__nav-button.is-active { background:var(--interactive-accent); color:var(--text-on-accent, #fff); box-shadow:0 8px 20px color-mix(in srgb, var(--interactive-accent) 35%, transparent); }
.sm-cc-shell__content { display:flex; flex-direction:column; gap:1.5rem; min-width:0; }
.sm-cc-card {
    border:1px solid var(--background-modifier-border);
    border-radius:12px;
    background:var(--background-primary);
    box-shadow:0 6px 18px rgba(0,0,0,.06);
    display:flex;
    flex-direction:column;
    overflow:hidden;
}
.sm-cc-card__head { padding:.9rem 1rem .65rem; border-bottom:1px solid var(--background-modifier-border); display:flex; flex-direction:column; gap:.35rem; }
.sm-cc-card__heading { display:flex; align-items:flex-start; gap:.65rem; justify-content:space-between; }
.sm-cc-card__title { margin:0; font-size:1.05rem; }
.sm-cc-card__subtitle { margin:0; font-size:.9em; color: var(--text-muted); }
.sm-cc-card__status {
    display: inline-flex;
    align-items: center;
    gap: .35rem;
    padding: .25rem .65rem;
    border-radius: 999px;
    font-size: .75rem;
    font-weight: 600;
    letter-spacing: .08em;
    text-transform: uppercase;
    background: color-mix(in srgb, var(--color-red, #e11d48) 12%, var(--background-secondary));
    color: color-mix(in srgb, var(--color-red, #e11d48) 85%, var(--text-normal));
    border: 1px solid color-mix(in srgb, var(--color-red, #e11d48) 45%, transparent);
    white-space: nowrap;
    transition: background 120ms ease, color 120ms ease, border 120ms ease, box-shadow 120ms ease;
}
.sm-cc-card__status::before {
    content: "!";
    font-weight: 700;
    font-size: .85em;
    line-height: 1;
}
.sm-cc-card__status[hidden] { display:none; }
.sm-cc-card__status.is-active { box-shadow:0 0 0 1px color-mix(in srgb, var(--color-red, #e11d48) 35%, transparent); }
.sm-cc-card__validation { display:none; padding:.6rem .95rem; border-top:1px solid color-mix(in srgb, var(--color-red, #e11d48) 30%, transparent); background:color-mix(in srgb, var(--color-red, #e11d48) 12%, var(--background-secondary)); color: var(--color-red, #e11d48); font-size:.9em; }
.sm-cc-card__validation.is-visible { display:block; }
.sm-cc-card__validation-list { margin:0; padding-left:1.2rem; display:flex; flex-direction:column; gap:.25rem; }
.sm-cc-card__body { padding:.95rem; display:flex; flex-direction:column; gap:1.1rem; }
.sm-cc-card.is-invalid { border-color: color-mix(in srgb, var(--color-red, #e11d48) 35%, transparent); box-shadow:0 0 0 1px color-mix(in srgb, var(--color-red, #e11d48) 22%, transparent) inset; }
.sm-cc-modal-footer { margin-top:1.25rem; display:flex; justify-content:flex-end; }
.sm-cc-modal-footer .setting-item { margin:0; padding:0; border:none; background:none; }
.sm-cc-modal-footer .setting-item-control { margin-left:0; display:flex; gap:.6rem; }
.sm-cc-modal-footer button { min-width:120px; }
/* Keyboard Shortcut Flash Effect */
.sm-cc-shortcut-flash {
    animation: sm-cc-flash 300ms ease-out;
}

@keyframes sm-cc-flash {
    0% {
        box-shadow: 0 0 0 0 var(--interactive-accent);
        background: var(--background-primary);
    }
    50% {
        box-shadow: 0 0 0 4px color-mix(in srgb, var(--interactive-accent) 35%, transparent);
        background: color-mix(in srgb, var(--interactive-accent) 12%, var(--background-primary));
    }
    100% {
        box-shadow: 0 0 0 0 transparent;
        background: var(--background-primary);
    }
}


/* Creature Creator \u2013 Basics Section */
.sm-cc-card--basics {
    border: 1px solid var(--background-modifier-border);
    border-radius: 12px;
    background: color-mix(in srgb, var(--background-secondary) 78%, transparent);
    box-shadow: 0 6px 18px rgba(15, 23, 42, .05);
}
.sm-cc-card--basics + .sm-cc-card--basics {
    margin-top: 1.1rem;
}
.sm-cc-card--basics .sm-cc-card__head {
    padding: .85rem .95rem .4rem;
}
.sm-cc-card--basics .sm-cc-card__title {
    font-size: .95rem;
    letter-spacing: .02em;
}
.sm-cc-card--basics .sm-cc-card__subtitle {
    margin-top: .35rem;
    font-size: .78rem;
    letter-spacing: .04em;
    text-transform: uppercase;
    color: var(--text-muted);
}
.sm-cc-card__body--basics {
    display: flex;
    flex-direction: column;
    gap: 1.35rem;
    padding: .85rem .95rem 1.15rem;
}
.sm-cc-card__section--basics {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}
.sm-cc-field-grid {
    display: grid;
    gap: .75rem;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
}
.sm-cc-field-grid--basics {
    gap: 1rem;
}
.sm-cc-field-grid--summary { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
.sm-cc-field-grid--classification { grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); }
.sm-cc-field-grid--vitals { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
.sm-cc-field-grid--speeds { grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); }
.sm-cc-setting.setting-item {
    border: none;
    padding: 0;
    margin: 0;
    background: none;
}
.sm-cc-setting .setting-item-info { display: none; }
.sm-cc-setting .setting-item-name {
    font-weight: 600;
    font-size: .88rem;
    color: var(--text-muted);
}
.sm-cc-setting .setting-item-control {
    margin-left: 0;
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: .45rem;
}
.sm-cc-setting--textarea .setting-item-control { align-items: stretch; }
.sm-cc-setting--textarea .sm-cc-textarea { min-height: 120px; }
.sm-cc-setting--show-name .setting-item-info {
    display: block;
    min-width: max-content;
}
.sm-cc-setting--show-name .setting-item-name {
    font-size: .75rem;
    letter-spacing: .06em;
    text-transform: uppercase;
    white-space: nowrap;
    overflow: visible;
    text-overflow: clip;
    line-height: 1.25;
    max-width: none;
    width: max-content;
}
.sm-cc-setting--span-2 { grid-column: 1 / -1; }
.sm-cc-setting--stack .setting-item-control {
    gap: .6rem;
}
.sm-cc-setting--token-editor .setting-item-control {
    flex-direction: row;
    flex-wrap: wrap;
    gap: .5rem;
}
.sm-cc-setting--token-editor .setting-item-control input {
    flex: 1 1 240px;
    min-width: 200px;
}
.sm-cc-setting--token-editor .setting-item-control button {
    align-self: flex-start;
}

.sm-cc-input {
    width: 100%;
    min-height: 34px;
    padding: .3rem .55rem;
    box-sizing: border-box;
    border-radius: 8px;
}
.sm-cc-input--small { max-width: 120px; }
.sm-cc-select {
    width: 100%;
    min-height: 34px;
    box-sizing: border-box;
    border-radius: 8px;
}
.sm-cc-textarea {
    width: 100%;
    min-height: 140px;
    resize: vertical;
    padding: .45rem .6rem;
    border-radius: 8px;
}

.sm-cc-setting--alignment-override {
    border-radius: 10px;
    border: 1px dashed var(--background-modifier-border);
    background: color-mix(in srgb, var(--background-secondary) 65%, transparent);
    padding: .5rem .65rem;
}
.sm-cc-setting--alignment-override .setting-item-info { margin-bottom: .35rem; }
.sm-cc-setting--alignment-override .setting-item-control {
    width: 100%;
}
.sm-cc-input--alignment-override {
    background: transparent;
}

.sm-cc-speeds-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
}
@media (max-width: 680px) {
    .sm-cc-speeds-grid { grid-template-columns: minmax(0, 1fr); }
}
.sm-cc-speed {
    display: flex;
    flex-direction: column;
    gap: .45rem;
    padding: .55rem .6rem;
    border-radius: 10px;
    border: 1px solid var(--background-modifier-border);
    background: var(--background-primary);
    box-shadow: 0 4px 12px rgba(15, 23, 42, .04);
}
.sm-cc-speed__head {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: .5rem;
}
.sm-cc-speed__label {
    font-size: .8rem;
    font-weight: 600;
    letter-spacing: .06em;
    text-transform: uppercase;
    color: var(--text-muted);
}
.sm-cc-speed__badge {
    border: 1px solid var(--background-modifier-border);
    border-radius: 999px;
    padding: .1rem .6rem;
    font-size: .7rem;
    letter-spacing: .08em;
    text-transform: uppercase;
    background: var(--background-secondary);
    color: var(--text-muted);
    cursor: pointer;
    transition: background 120ms ease, color 120ms ease, border 120ms ease, box-shadow 120ms ease;
}
.sm-cc-speed__badge.is-active {
    background: var(--interactive-accent);
    color: var(--text-on-accent, #fff);
    border-color: color-mix(in srgb, var(--interactive-accent) 55%, transparent);
    box-shadow: 0 4px 12px color-mix(in srgb, var(--interactive-accent) 35%, transparent);
}
.sm-cc-speed__input { width: 100%; }

/* Create Creature Modal helpers */
.sm-cc-create-modal .sm-cc-grid {
    display: grid;
    grid-template-columns: max-content 140px max-content;
    gap: .35rem .75rem;
    align-items: center;
    margin: .25rem 0 .5rem;
}
.sm-cc-grid__row { display: contents; }
.sm-cc-grid__save { display: flex; align-items: center; gap: .35rem; }

.sm-cc-skills { margin-top: .5rem; }
.sm-cc-skill-group { border: 1px solid var(--background-modifier-border); border-radius: 8px; padding: .5rem; margin: .35rem 0; }
.sm-cc-skill-group__title { font-weight: 600; margin-bottom: .25rem; }
.sm-cc-skill { display: grid; grid-template-columns: 1fr max-content max-content; gap: .5rem; align-items: center; margin: .15rem 0; }

.sm-cc-chips { display:flex; gap:.4rem; flex-wrap:wrap; margin:.35rem 0 .6rem; }
.sm-cc-chip {
    display:inline-flex;
    align-items:center;
    gap:.3rem;
    border:1px solid var(--background-modifier-border);
    border-radius:999px;
    padding:.2rem .6rem;
    background: color-mix(in srgb, var(--background-secondary) 80%, transparent);
    font-size:.85em;
    color: var(--text-muted);
    box-shadow:0 3px 8px rgba(15,23,42,.04);
}
.sm-cc-damage-row { align-items:center; }
.sm-cc-damage-type { display:inline-flex; align-items:center; gap:.35rem; flex-wrap:wrap; justify-content:flex-start; }
.sm-cc-damage-type__label { font-size:.85em; color: var(--text-muted); }
.sm-cc-damage-type__buttons { display:inline-flex; border:1px solid var(--background-modifier-border); border-radius:999px; overflow:hidden; background: var(--background-primary); }
.sm-cc-damage-type__btn { border:none; background:transparent; padding:.2rem .75rem; font-size:.85em; color: var(--text-muted); cursor:pointer; transition: background 120ms ease, color 120ms ease; }
.sm-cc-damage-type__btn:hover { color: var(--text-normal); }
.sm-cc-damage-type__btn.is-active { background: var(--interactive-accent); color: var(--text-on-accent, #fff); }
.sm-cc-damage-type__btn.is-active:hover { color: var(--text-on-accent, #fff); }
.sm-cc-damage-chips { margin-top:.25rem; }
.sm-cc-damage-chip { align-items:center; gap:.4rem; padding-right:.5rem; }
.sm-cc-damage-chip__name { font-weight:500; }
.sm-cc-damage-chip__badge { font-size:.75em; font-weight:600; border-radius:999px; padding:.1rem .45rem; text-transform:uppercase; letter-spacing:.03em; }
.sm-cc-damage-chip--res {
    border-color: rgba(37,99,235,.45);
    background-color: rgba(37,99,235,.08);
    border-color: color-mix(in srgb, var(--interactive-accent) 45%, transparent);
    background-color: color-mix(in srgb, var(--interactive-accent) 12%, var(--background-secondary));
}
.sm-cc-damage-chip--res .sm-cc-damage-chip__badge {
    background-color: rgba(37,99,235,.18);
    color:#2563eb;
    background-color: color-mix(in srgb, var(--interactive-accent) 22%, transparent);
    color: var(--interactive-accent);
}
.sm-cc-damage-chip--imm {
    border-color: rgba(124,58,237,.45);
    background-color: rgba(124,58,237,.08);
    border-color: color-mix(in srgb, var(--color-purple, #7c3aed) 45%, transparent);
    background-color: color-mix(in srgb, var(--color-purple, #7c3aed) 12%, var(--background-secondary));
}
.sm-cc-damage-chip--imm .sm-cc-damage-chip__badge {
    background-color: rgba(124,58,237,.18);
    color:#7c3aed;
    background-color: color-mix(in srgb, var(--color-purple, #7c3aed) 22%, transparent);
    color: var(--color-purple, #7c3aed);
}
.sm-cc-damage-chip--vuln {
    border-color: rgba(234,88,12,.45);
    background-color: rgba(234,88,12,.08);
    border-color: color-mix(in srgb, var(--color-orange, #ea580c) 45%, transparent);
    background-color: color-mix(in srgb, var(--color-orange, #ea580c) 12%, var(--background-secondary));
}
.sm-cc-damage-chip--vuln .sm-cc-damage-chip__badge {
    background-color: rgba(234,88,12,.18);
    color:#ea580c;
    background-color: color-mix(in srgb, var(--color-orange, #ea580c) 22%, transparent);
    color: var(--color-orange, #ea580c);
}
.sm-cc-skill-editor { display:flex; flex-direction:column; gap:.35rem; }
.sm-cc-skill-search {
    display:flex;
    align-items:center;
    justify-content:flex-end;
    margin-left:auto;
    width:100%;
    max-width:420px;
}
.sm-cc-skill-search select,
.sm-cc-skill-search .sm-sd {
    flex:1 1 260px;
    min-width:220px;
}
.sm-cc-skill-search button {
    flex:0 0 auto;
}

.sm-cc-defenses .sm-cc-senses-block {
    border-top: 1px solid var(--background-modifier-border);
    margin-top: .65rem;
    padding-top: .65rem;
}
.sm-cc-defenses .sm-cc-senses-setting .setting-item-control {
    display: flex;
    justify-content: flex-end;
}
.sm-cc-defense-summary {
    display:flex;
    align-items:center;
    flex-wrap:wrap;
    gap:.4rem;
    margin:.35rem 0 .75rem;
}
.sm-cc-defense-pill {
    display:inline-flex;
    align-items:center;
    gap:.35rem;
    border:1px solid var(--background-modifier-border);
    border-radius:999px;
    padding:.2rem .7rem;
    background: color-mix(in srgb, var(--background-secondary) 80%, transparent);
    font-size:.85em;
    color: var(--text-muted);
    box-shadow:0 3px 8px rgba(15,23,42,.05);
    transition: background 120ms ease, border-color 120ms ease, color 120ms ease, box-shadow 120ms ease;
}
.sm-cc-defense-pill__label {
    font-weight:600;
    color: var(--text-normal);
}
.sm-cc-defense-pill__count {
    font-weight:700;
    font-variant-numeric: tabular-nums;
}
.sm-cc-defense-pill.is-empty {
    opacity:.65;
}
.sm-cc-defense-pill--res {
    border-color: color-mix(in srgb, var(--interactive-accent) 45%, transparent);
    background: color-mix(in srgb, var(--interactive-accent) 12%, var(--background-secondary));
}
.sm-cc-defense-pill--res .sm-cc-defense-pill__label,
.sm-cc-defense-pill--res .sm-cc-defense-pill__count {
    color: var(--interactive-accent);
}
.sm-cc-defense-pill--imm {
    border-color: color-mix(in srgb, var(--color-purple, #7c3aed) 45%, transparent);
    background: color-mix(in srgb, var(--color-purple, #7c3aed) 12%, var(--background-secondary));
}
.sm-cc-defense-pill--imm .sm-cc-defense-pill__label,
.sm-cc-defense-pill--imm .sm-cc-defense-pill__count {
    color: var(--color-purple, #7c3aed);
}
.sm-cc-defense-pill--vuln {
    border-color: color-mix(in srgb, var(--color-orange, #ea580c) 45%, transparent);
    background: color-mix(in srgb, var(--color-orange, #ea580c) 12%, var(--background-secondary));
}
.sm-cc-defense-pill--vuln .sm-cc-defense-pill__label,
.sm-cc-defense-pill--vuln .sm-cc-defense-pill__count {
    color: var(--color-orange, #ea580c);
}
.sm-cc-defense-pill--cond {
    border-color: color-mix(in srgb, var(--color-green, #10b981) 45%, transparent);
    background: color-mix(in srgb, var(--color-green, #10b981) 12%, var(--background-secondary));
}
.sm-cc-defense-pill--cond .sm-cc-defense-pill__label,
.sm-cc-defense-pill--cond .sm-cc-defense-pill__count {
    color: var(--color-green, #10b981);
}
.sm-cc-defense-pill__empty {
    font-size:.85em;
    color: var(--text-muted);
    font-style: italic;
}
.sm-cc-defenses .sm-cc-senses-search {
    display: flex;
    align-items: center;
    gap: .35rem;
    justify-content: flex-end;
    margin-left: 0;
    width: auto;
}
.sm-cc-defenses .sm-cc-senses-search select,
.sm-cc-defenses .sm-cc-senses-search .sm-sd {
    flex: 0 0 280px;
    min-width: 280px;
    max-width: 280px;
}
.sm-cc-defenses .sm-cc-senses-search button {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: .2rem .45rem;
    min-width: 1.9rem;
    height: 1.9rem;
    border-radius: 4px;
    font-size: .85em;
    border: 1px solid var(--background-modifier-border);
    background: var(--background-secondary);
}
.sm-cc-skill-chips { gap:.45rem; }
.sm-cc-skill-chip { align-items:center; gap:.4rem; padding-right:.5rem; }
.sm-cc-skill-chip__name { font-weight:500; }
.sm-cc-skill-chip__mod { font-weight:600; color: var(--text-normal); }
.sm-cc-skill-chip__exp { display:inline-flex; align-items:center; gap:.25rem; font-size:.85em; color: var(--text-muted); }
.sm-cc-skill-chip__exp input { margin:0; }
.sm-cc-chip__remove { background:none; border:none; cursor:pointer; font-size:.85rem; line-height:1; padding:0; color: var(--text-muted); }
.sm-cc-chip__remove:hover { color: var(--text-normal); }

/* Movement Editor */
.sm-cc-movement-row { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
.sm-cc-movement-select { flex:1 1 220px; min-width:200px; }
.sm-cc-movement-distance { flex:0 0 120px; min-width:100px; }
.sm-cc-movement-hover { display:inline-flex; align-items:center; gap:.35rem; flex:0 0 auto; }
.sm-cc-movement-hover input { margin:0; }
.sm-cc-movement-add { flex:0 0 auto; margin-left:auto; }
.sm-cc-movement-chips { gap:.45rem; }
.sm-cc-movement-chip { align-items:center; gap:.4rem; padding-right:.5rem; }
.sm-cc-movement-chip__label { font-weight:600; color: var(--text-normal); }
.sm-cc-movement-chip__distance { font-weight:500; }
.sm-cc-movement-chip__badge { font-size:.75em; font-weight:600; border-radius:999px; padding:.1rem .45rem; text-transform:uppercase; letter-spacing:.03em; background-color: color-mix(in srgb, var(--interactive-accent) 18%, transparent); color: var(--interactive-accent); }

/* Creature Spellcasting \u2013 Layout & Preview */
.sm-cc-spellcasting {
    display: grid;
    gap: 1.25rem;
}
@media (min-width: 1080px) {
    .sm-cc-spellcasting {
        grid-template-columns: minmax(0, 3fr) minmax(0, 2fr);
        align-items: start;
    }
}
.sm-cc-spellcasting__ability .setting-item-control {
    gap: .65rem;
    align-items: flex-start;
}
.sm-cc-spellcasting__computed {
    display: inline-flex;
    flex-wrap: wrap;
    gap: .35rem;
    align-items: center;
    margin-top: .25rem;
}
.sm-cc-spellcasting__computed-save,
.sm-cc-spellcasting__computed-attack {
    display: inline-flex;
    align-items: center;
    gap: .3rem;
    padding: .2rem .6rem;
    border-radius: 999px;
    font-size: .75rem;
    letter-spacing: .06em;
    text-transform: uppercase;
    font-weight: 600;
    background: color-mix(in srgb, var(--background-secondary) 85%, transparent);
    border: 1px solid var(--background-modifier-border);
    color: var(--text-muted);
}
.sm-cc-spellcasting__overrides {
    display: flex;
    flex-wrap: wrap;
    gap: .5rem;
    margin-top: .35rem;
}
.sm-cc-spellcasting__overrides .sm-cc-input--small {
    flex: 0 0 120px;
}

.sm-cc-spellcasting__toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: .5rem;
    align-items: center;
    margin: .75rem 0 .5rem;
}
.sm-cc-button {
    border: 1px solid var(--background-modifier-border);
    border-radius: 999px;
    padding: .35rem .9rem;
    background: var(--background-primary);
    font-weight: 600;
    font-size: .85em;
    letter-spacing: .04em;
    text-transform: uppercase;
    cursor: pointer;
    transition: background 120ms ease, color 120ms ease, border 120ms ease, box-shadow 120ms ease;
}
.sm-cc-button:hover { color: var(--text-normal); }
.sm-cc-button:focus-visible { outline: 2px solid var(--interactive-accent); outline-offset: 1px; }

.sm-cc-spellcasting__groups {
    display: flex;
    flex-direction: column;
    gap: .85rem;
}
.sm-cc-spellcasting__groups-empty {
    border: 1px dashed var(--background-modifier-border);
    border-radius: 10px;
    padding: .75rem;
    text-align: center;
    font-size: .9em;
    color: var(--text-muted);
    background: color-mix(in srgb, var(--background-secondary) 70%, transparent);
}
.sm-cc-spellcasting__preview {
    border: 1px solid var(--background-modifier-border);
    border-radius: 12px;
    padding: 1rem;
    background: color-mix(in srgb, var(--background-secondary) 80%, transparent);
    display: flex;
    flex-direction: column;
    gap: .75rem;
}
.sm-cc-spellcasting-preview__header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: .75rem;
}
.sm-cc-spellcasting-preview__header h4 { margin: 0; }
.sm-cc-spellcasting-preview__notes {
    margin: 0;
    padding-left: 1.2rem;
    display: flex;
    flex-direction: column;
    gap: .25rem;
}
.sm-cc-spellcasting-preview__groups {
    display: flex;
    flex-direction: column;
    gap: .65rem;
}
.sm-cc-spellcasting-preview__group {
    border: 1px solid var(--background-modifier-border);
    border-radius: 10px;
    padding: .6rem .75rem;
    background: var(--background-primary);
    display: flex;
    flex-direction: column;
    gap: .35rem;
}
.sm-cc-spellcasting-preview__group h5 { margin: 0; }
.sm-cc-spellcasting-preview__group ul {
    margin: 0;
    padding-left: 1.1rem;
    display: flex;
    flex-direction: column;
    gap: .25rem;
}
.sm-cc-spellcasting-preview__note {
    font-size: .85em;
    color: var(--text-muted);
}
.sm-cc-spellcasting-preview__empty {
    font-size: .9em;
    font-style: italic;
    color: var(--text-muted);
}

/* === Spell Groups - Improved UI === */
.sm-cc-spell-group {
    border: 1px solid var(--background-modifier-border);
    border-radius: 12px;
    background: color-mix(in srgb, var(--background-secondary) 75%, transparent);
    box-shadow: 0 6px 14px rgba(15, 23, 42, .05);
    padding: .95rem;
    display: flex;
    flex-direction: column;
    gap: .75rem;
    margin-bottom: .75rem;
}

.sm-cc-spell-group--at-will {
    background: color-mix(in srgb, var(--color-green, #10b981) 8%, var(--background-secondary));
    border-color: color-mix(in srgb, var(--color-green, #10b981) 25%, transparent);
}

.sm-cc-spell-group--per-day {
    background: color-mix(in srgb, var(--color-yellow, #f59e0b) 8%, var(--background-secondary));
    border-color: color-mix(in srgb, var(--color-yellow, #f59e0b) 25%, transparent);
}

.sm-cc-spell-group--level {
    background: color-mix(in srgb, var(--interactive-accent) 8%, var(--background-secondary));
    border-color: color-mix(in srgb, var(--interactive-accent) 25%, transparent);
}

.sm-cc-spell-group-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: .75rem;
    margin-bottom: .65rem;
    padding-bottom: .65rem;
    border-bottom: 1px solid var(--background-modifier-border);
}

.sm-cc-spell-group-header-left {
    display: flex;
    align-items: center;
    gap: .5rem;
    flex: 1;
    min-width: 0;
}

.sm-cc-spell-group-header-right {
    display: flex;
    align-items: center;
    gap: .65rem;
}

.sm-cc-spell-group-separator {
    color: var(--text-muted);
    font-weight: 400;
}

.sm-cc-spell-group-suffix {
    color: var(--text-muted);
    font-size: .9em;
}

.sm-cc-spell-count {
    opacity: 0.7;
    font-size: .85em;
    font-weight: 600;
    color: var(--text-muted);
    padding: .2rem .6rem;
    border-radius: 999px;
    background: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
}

/* Spell List Styles */
.sm-cc-spellcasting-spells-list {
    display: flex;
    flex-direction: column;
    gap: .45rem;
}

.sm-cc-spell-item {
    display: flex;
    align-items: center;
    gap: .5rem;
    padding: .5rem;
    border-radius: 8px;
    border: 1px solid var(--background-modifier-border);
    background: var(--background-primary);
    transition: background 120ms ease, box-shadow 120ms ease;
}

.sm-cc-spell-item:nth-child(even) {
    background: color-mix(in srgb, var(--background-secondary) 95%, transparent);
}

.sm-cc-spell-item:hover {
    background: color-mix(in srgb, var(--background-secondary) 100%, transparent);
    box-shadow: 0 2px 8px rgba(15, 23, 42, .08);
}

.sm-cc-spellcasting-spell-input {
    flex: 1;
    min-width: 0;
    padding: .35rem .5rem;
    border-radius: 6px;
    background: transparent;
    border: 1px solid transparent;
    transition: border-color 120ms ease, background 120ms ease;
}

.sm-cc-spellcasting-spell-input:focus {
    border-color: var(--interactive-accent);
    background: var(--background-primary);
}

.sm-cc-spellcasting-spell-input::placeholder {
    color: var(--text-muted);
    opacity: 0.6;
}

.sm-cc-spell-delete {
    flex: 0 0 auto;
    border: none;
    background: transparent;
    cursor: pointer;
    font-size: 1.1rem;
    padding: .25rem .35rem;
    border-radius: 6px;
    color: var(--text-muted);
    transition: background 120ms ease, color 120ms ease;
}

.sm-cc-spell-delete:hover {
    background: color-mix(in srgb, var(--color-red, #e11d48) 15%, var(--background-secondary));
    color: var(--color-red, #e11d48);
}

/* Inline Add Spell Button */
.sm-cc-spell-add-inline {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: 2px dashed var(--background-modifier-border);
    background: transparent;
    color: var(--text-muted);
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 1.1rem;
    font-weight: 600;
    margin-top: .25rem;
    transition: all 120ms ease;
}

.sm-cc-spell-add-inline:hover {
    border-color: var(--interactive-accent);
    background: color-mix(in srgb, var(--interactive-accent) 12%, transparent);
    color: var(--interactive-accent);
    border-style: solid;
    transform: scale(1.05);
}

.sm-cc-spell-add-inline:active {
    transform: scale(0.95);
}

/* Add Group Buttons */
.sm-cc-spellcasting-add-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: .5rem;
    margin-top: .5rem;
    padding-top: .75rem;
    border-top: 1px dashed var(--background-modifier-border);
}

.sm-cc-spellcasting-groups {
    display: flex;
    flex-direction: column;
    gap: 0;
}

/* Button Small Styles */
.sm-cc-button-small {
    border: 1px solid var(--background-modifier-border);
    border-radius: 6px;
    padding: .25rem .5rem;
    background: var(--background-secondary);
    font-size: .85em;
    cursor: pointer;
    transition: all 120ms ease;
}

.sm-cc-button-small:hover {
    background: var(--interactive-accent);
    color: var(--text-on-accent, #fff);
    border-color: var(--interactive-accent);
}


/* Creature modal layout improvements */
.sm-cc-create-modal .setting-item-control { flex: 1 1 auto; min-width: 0; }
.sm-cc-create-modal textarea { width: 100%; min-height: 140px; }
.sm-cc-create-modal .sm-cc-entry-text { min-height: 180px; }
.sm-cc-create-modal .sm-cc-skill-group { width: 100%; box-sizing: border-box; }
.sm-cc-create-modal .sm-cc-searchbar { flex-wrap: wrap; }
.sm-cc-create-modal .sm-cc-searchbar > * { flex: 1 1 160px; min-width: 140px; }
.sm-cc-create-modal .sm-cc-damage-row > label,
.sm-cc-create-modal .sm-cc-damage-row .sm-cc-damage-type,
.sm-cc-create-modal .sm-cc-damage-row .sm-cc-damage-add { flex:0 0 auto; min-width:auto; }
.sm-cc-create-modal .sm-cc-damage-row .sm-cc-damage-select { flex:1 1 240px; min-width:200px; }
.sm-cc-create-modal .sm-cc-entry-grid { grid-template-columns: max-content 1fr max-content 1fr; column-gap: .75rem; row-gap: .35rem; align-items: center; }
.sm-cc-create-modal .sm-cc-entry-grid input, .sm-cc-create-modal .sm-cc-entry-grid select { width: 100%; max-width: 220px; box-sizing: border-box; }
.sm-cc-create-modal .sm-cc-entry-grid input[type="number"] { max-width: 100px; }
.sm-cc-create-modal .sm-cc-entry-grid input.sm-auto-tohit { max-width: 72px; }

/* Inline labels kept compact */
.sm-cc-create-modal label { font-size: 0.9em; color: var(--text-muted); margin-right: .25rem; }
.sm-cc-entry-head label { margin-right: .35rem; }
.sm-cc-create-modal .sm-cc-searchbar label { align-self: center; }

/* Ensure entry and spell controls stack vertically */
.sm-cc-create-modal .sm-cc-entries { display: block; }
.sm-cc-create-modal .sm-cc-entries .setting-item-info { display: block; width: 100%; margin-bottom: .35rem; }
.sm-cc-create-modal .sm-cc-entries .setting-item-control { display: flex; flex-direction: column; align-items: stretch; gap: .5rem; width: 100%; }
.sm-cc-create-modal .sm-cc-entries .sm-cc-searchbar { width: 100%; }
.sm-cc-create-modal .setting-item-control > * { max-width: 100%; }

/* Spell Creator \u2013 Validierung f\xFCr h\xF6here Grade */
.sm-cc-create-modal .setting-item.is-invalid textarea {
    border-color: color-mix(in srgb, var(--color-red, #e11d48) 35%, transparent);
    box-shadow: 0 0 0 1px color-mix(in srgb, var(--color-red, #e11d48) 25%, transparent) inset;
}
.sm-setting-validation {
    display: none;
    margin-top: .35rem;
    padding: .45rem .6rem;
    border-radius: 6px;
    background: color-mix(in srgb, var(--color-red, #e11d48) 12%, var(--background-secondary));
    color: var(--color-red, #e11d48);
    font-size: .85em;
}
.sm-setting-validation.is-visible { display: block; }
.sm-setting-validation ul {
    margin: 0;
    padding-left: 1.2rem;
    display: flex;
    flex-direction: column;
    gap: .25rem;
}

/* Entry header layout: [category | name (flex) | delete] */
.sm-cc-create-modal .sm-cc-entry-head {
    display: grid;
    grid-template-columns: max-content 1fr max-content;
    gap: .5rem;
    align-items: center;
}
.sm-cc-create-modal .sm-cc-entry-head select { width: auto; }
.sm-cc-create-modal .sm-cc-entry-name { width: 100%; min-width: 0; }

/* Table-like layout for Skills */
.sm-cc-create-modal .sm-cc-table { display: grid; gap: .35rem .5rem; align-items: center; }
.sm-cc-create-modal .sm-cc-row { display: contents; }
.sm-cc-create-modal .sm-cc-cell { align-self: center; }
.sm-cc-create-modal .sm-cc-header .sm-cc-cell { font-weight: 600; color: var(--text-muted); }

/* Ability score cards */
.sm-cc-create-modal .sm-cc-stats { display: flex; flex-direction: column; width: 100%; min-width: 0; }
.sm-cc-create-modal .sm-cc-stats-section { display: flex; flex-direction: column; gap: .05rem; width: 100%; box-sizing: border-box; }
.sm-cc-create-modal .sm-cc-stats-section__title { margin: 0; line-height: 1.3; }
.sm-cc-create-modal .sm-cc-stats-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); grid-auto-rows: minmax(0, auto); align-items: stretch; gap: .12rem .4rem; margin: 0; width: 100%; box-sizing: border-box; }
.sm-cc-create-modal .sm-cc-stats-col { display: flex; flex-direction: column; gap: .12rem; min-width: 0; }
.sm-cc-create-modal .sm-cc-stats-col__header { display: flex; align-items: end; justify-content: flex-end; gap: .25rem; padding: 0 0 .15rem 0; margin: 0 0 .15rem 0; font-size: .85em; color: var(--text-muted); }
.sm-cc-create-modal .sm-cc-stats-col__header-cell { display: flex; align-items: center; justify-content: flex-end; gap: .2rem; font-weight: 600; }
.sm-cc-create-modal .sm-cc-stats-col__header-cell--save { gap: .25rem; }
.sm-cc-create-modal .sm-cc-stats-col__header-save-mod { font-size: .78em; letter-spacing: .06em; text-transform: uppercase; min-width: 3ch; text-align: right; }
.sm-cc-create-modal .sm-cc-stats-col__header-save-label { font-weight: 600; }
.sm-cc-create-modal .sm-cc-stat-row { display: flex; align-items: center; gap: .15rem; padding: .18rem .28rem; border-radius: 8px; border: 1px solid var(--background-modifier-border); background: var(--background-primary); width: 100%; box-sizing: border-box; }
.sm-cc-create-modal .sm-cc-stat-row__label { flex: 0 0 2.5rem; font-weight: 600; color: var(--text-normal); }
.sm-cc-create-modal .sm-cc-stat-row__score { flex: 0 0 auto; }
.sm-cc-create-modal .sm-cc-stat-row__mod-value { font-weight: 600; color: var(--text-normal); min-width: 3ch; text-align: right; margin-left: .08rem; }
.sm-cc-create-modal .sm-cc-stat-row__save { margin-left: .08rem; display: grid; grid-auto-flow: column; grid-auto-columns: max-content; align-items: center; gap: .1rem; }
.sm-cc-create-modal .sm-cc-stat-row__save-prof { display: inline-flex; align-items: center; justify-content: center; width: 1.25rem; height: 1.25rem; font-size: .85em; color: var(--text-muted); cursor: pointer; }
.sm-cc-create-modal .sm-cc-stat-row__save-prof input[type="checkbox"] { margin: 0; }
.sm-cc-create-modal .sm-cc-stat-row__save-mod { font-weight: 600; color: var(--text-normal); min-width: 3ch; text-align: right; }
@media (max-width: 700px) {
    .sm-cc-create-modal .sm-cc-stats-grid { grid-template-columns: minmax(0, 1fr); }
}

/* Compact inline number controls */
.sm-inline-number { display: inline-flex; align-items: center; gap: .2rem; }
.sm-inline-number input[type="number"] { width: 84px; }
.sm-cc-create-modal .sm-cc-stat-row .sm-inline-number { gap: .12rem; }
.sm-cc-create-modal .sm-cc-stat-row .sm-inline-number input[type="number"].sm-cc-stat-row__score-input {
    width: calc(2.2ch + 10px);
    min-width: calc(2.2ch + 10px);
    text-align: center;
    padding-inline: 0;
}
.btn-compact { padding: 0 .4rem; min-width: 1.5rem; height: 1.6rem; line-height: 1.2; }

/* Movement row should not overflow; children stay compact */
.sm-cc-create-modal .sm-cc-move-ctl { display: flex; flex-direction: column; align-items: stretch; gap: .35rem; }
.sm-cc-create-modal .sm-cc-move-row { display:flex; align-items:center; gap:.5rem; flex-wrap:wrap; }
.sm-cc-create-modal .sm-cc-move-row .sm-sd { flex:1 1 220px; min-width:200px; }
.sm-cc-create-modal .sm-cc-move-row select { max-width: 220px; }
.sm-cc-create-modal .sm-cc-move-hover { display:inline-flex; align-items:center; gap:.35rem; flex:0 0 auto; }
.sm-cc-create-modal .sm-cc-move-hover input { margin:0; }
.sm-cc-create-modal .sm-cc-move-row .sm-inline-number { flex:0 0 auto; }
.sm-cc-create-modal .sm-cc-move-add { margin-left:auto; flex:0 0 auto; }

/* Entry auto compute groups */
.sm-cc-create-modal .sm-cc-auto { display: flex; flex-wrap: wrap; gap: .5rem 1rem; align-items: center; }
.sm-cc-create-modal .sm-auto-group { display: inline-flex; align-items: center; gap: .35rem; flex-wrap: wrap; }
.sm-cc-create-modal .sm-auto-tohit { width: 72px; }
.sm-cc-create-modal .sm-auto-dmg { width: 220px; }

/* Select with search */
.sm-cc-create-modal .sm-select-wrap { display: flex; flex-direction: column; gap: .25rem; min-width: 0; }
.sm-cc-create-modal .sm-select-search { width: 100%; }

/* Preset typeahead menu */
.sm-cc-create-modal .sm-preset-box { position: relative; }
.sm-cc-create-modal .sm-preset-input { width: 100%; }
.sm-cc-create-modal .sm-preset-menu {
    position: absolute; left: 0; right: 0; top: calc(100% + 4px);
    background: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 8px;
    padding: .25rem;
    display: none;
    max-height: 240px; overflow: auto; z-index: 1000;
}
.sm-cc-create-modal .sm-preset-box.is-open .sm-preset-menu { display: block; }
.sm-cc-create-modal .sm-preset-item { padding: .25rem .35rem; border-radius: 6px; cursor: pointer; }
.sm-cc-create-modal .sm-preset-item:hover { background: var(--background-secondary); }

/* Such-dropdown (SearchDropdown) */
.sm-sd { position: relative; display: inline-block; width: auto; min-width: 0; }
.sm-sd__input { width: 100%; }
.sm-sd__menu { position: absolute; left: 0; right: 0; top: calc(100% + 4px); background: var(--background-primary); border: 1px solid var(--background-modifier-border); border-radius: 8px; padding: .25rem; display: none; max-height: 240px; overflow: auto; z-index: 1000; }
.sm-sd.is-open .sm-sd__menu { display: block; }
.sm-sd__item { padding: .25rem .35rem; border-radius: 6px; cursor: pointer; }
.sm-sd__item.is-active, .sm-sd__item:hover { background: var(--background-secondary); }

/* Creature terrain picker */
.sm-cc-create-modal .sm-cc-auto { display: flex; flex-wrap: wrap; gap: .35rem; align-items: center; }
.sm-cc-create-modal .sm-cc-auto select { min-width: 160px; }
.sm-cc-create-modal .sm-cc-auto input[type="text"] { min-width: 160px; }

/* Creature terrain picker */
.sm-cc-terrains { position: relative; }
.sm-cc-terrains__trigger {
    border: 1px solid var(--background-modifier-border);
    background: var(--background-secondary);
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    cursor: pointer;
}
.sm-cc-terrains__menu {
    position: absolute;
    top: calc(100% + 4px);
    left: 0;
    background: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 8px;
    padding: 0.35rem 0.5rem;
    display: none;
    min-width: 220px;
    max-height: 220px;
    overflow: auto;
    z-index: 1000;
}
.sm-cc-terrains.is-open .sm-cc-terrains__menu { display: block; }
.sm-cc-terrains__item { display: flex; align-items: center; gap: .5rem; padding: .15rem 0; }

/* Region Compendium */
.sm-region-compendium { padding:.5rem 0; }
.sm-region-compendium .desc { color: var(--text-muted); margin-bottom:.25rem; }
.sm-region-compendium .rows { margin-top:.5rem; }
.sm-region-compendium .row { display:flex; gap:.5rem; align-items:center; margin:.25rem 0; }
.sm-region-compendium .row input[type="text"] { flex:1; min-width:0; }
.sm-region-compendium .addbar { display:flex; gap:.5rem; margin-top:.5rem; }
.sm-region-compendium .addbar input[type="text"] { flex:1; min-width:0; }

/* Eintr\xE4ge-Abschnitt: Verbesserte Button-Gruppe zum Hinzuf\xFCgen */
.sm-cc-entry-add-bar {
    display: flex;
    align-items: center;
    gap: .75rem;
    padding: .75rem;
    margin: .5rem 0;
    border: 1px solid var(--background-modifier-border);
    border-radius: 12px;
    background: color-mix(in srgb, var(--background-secondary) 85%, transparent);
}
.sm-cc-entry-add-label {
    font-size: .85rem;
    font-weight: 600;
    letter-spacing: .04em;
    text-transform: uppercase;
    color: var(--text-muted);
}
.sm-cc-entry-add-group {
    display: flex;
    flex-wrap: wrap;
    gap: .5rem;
}
.sm-cc-entry-add-btn {
    border: 1px solid var(--background-modifier-border);
    border-radius: 999px;
    padding: .35rem .85rem;
    background: var(--background-primary);
    font-weight: 600;
    font-size: .85em;
    letter-spacing: .04em;
    cursor: pointer;
    transition: all 120ms ease;
}
.sm-cc-entry-add-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(15, 23, 42, .12);
}

/* Farbcodierung f\xFCr Kategorien */
.sm-cc-entry-add-btn--trait {
    background: color-mix(in srgb, var(--color-green, #10b981) 12%, var(--background-primary));
    border-color: color-mix(in srgb, var(--color-green, #10b981) 35%, transparent);
    color: var(--color-green, #10b981);
}
.sm-cc-entry-add-btn--trait:hover {
    background: color-mix(in srgb, var(--color-green, #10b981) 18%, var(--background-primary));
}
.sm-cc-entry-add-btn--action {
    background: color-mix(in srgb, var(--interactive-accent) 12%, var(--background-primary));
    border-color: color-mix(in srgb, var(--interactive-accent) 35%, transparent);
    color: var(--interactive-accent);
}
.sm-cc-entry-add-btn--action:hover {
    background: color-mix(in srgb, var(--interactive-accent) 18%, var(--background-primary));
}
.sm-cc-entry-add-btn--bonus {
    background: color-mix(in srgb, var(--color-yellow, #f59e0b) 12%, var(--background-primary));
    border-color: color-mix(in srgb, var(--color-yellow, #f59e0b) 35%, transparent);
    color: var(--color-yellow, #f59e0b);
}
.sm-cc-entry-add-btn--bonus:hover {
    background: color-mix(in srgb, var(--color-yellow, #f59e0b) 18%, var(--background-primary));
}
.sm-cc-entry-add-btn--reaction {
    background: color-mix(in srgb, var(--color-orange, #ea580c) 12%, var(--background-primary));
    border-color: color-mix(in srgb, var(--color-orange, #ea580c) 35%, transparent);
    color: var(--color-orange, #ea580c);
}
.sm-cc-entry-add-btn--reaction:hover {
    background: color-mix(in srgb, var(--color-orange, #ea580c) 18%, var(--background-primary));
}
.sm-cc-entry-add-btn--legendary {
    background: color-mix(in srgb, var(--color-purple, #7c3aed) 12%, var(--background-primary));
    border-color: color-mix(in srgb, var(--color-purple, #7c3aed) 35%, transparent);
    color: var(--color-purple, #7c3aed);
}
.sm-cc-entry-add-btn--legendary:hover {
    background: color-mix(in srgb, var(--color-purple, #7c3aed) 18%, var(--background-primary));
}

/* Entry-Karten: Verbesserte Struktur */
.sm-cc-entry-card {
    border: 1px solid var(--background-modifier-border);
    border-radius: 12px;
    background: var(--background-primary);
    box-shadow: 0 4px 12px rgba(15, 23, 42, .06);
    padding: .85rem;
    margin: .65rem 0;
    display: flex;
    flex-direction: column;
    gap: .75rem;
}
.sm-cc-entry-head {
    display: grid;
    grid-template-columns: max-content 1fr max-content;
    gap: .65rem;
    align-items: center;
}
.sm-cc-entry-badge {
    display: inline-flex;
    align-items: center;
    padding: .25rem .75rem;
    border-radius: 999px;
    font-size: .75rem;
    font-weight: 600;
    letter-spacing: .06em;
    text-transform: uppercase;
    border: 1px solid;
}
.sm-cc-entry-badge--trait {
    background: color-mix(in srgb, var(--color-green, #10b981) 12%, var(--background-secondary));
    color: var(--color-green, #10b981);
    border-color: color-mix(in srgb, var(--color-green, #10b981) 35%, transparent);
}
.sm-cc-entry-badge--action {
    background: color-mix(in srgb, var(--interactive-accent) 12%, var(--background-secondary));
    color: var(--interactive-accent);
    border-color: color-mix(in srgb, var(--interactive-accent) 35%, transparent);
}
.sm-cc-entry-badge--bonus {
    background: color-mix(in srgb, var(--color-yellow, #f59e0b) 12%, var(--background-secondary));
    color: var(--color-yellow, #f59e0b);
    border-color: color-mix(in srgb, var(--color-yellow, #f59e0b) 35%, transparent);
}
.sm-cc-entry-badge--reaction {
    background: color-mix(in srgb, var(--color-orange, #ea580c) 12%, var(--background-secondary));
    color: var(--color-orange, #ea580c);
    border-color: color-mix(in srgb, var(--color-orange, #ea580c) 35%, transparent);
}
.sm-cc-entry-badge--legendary {
    background: color-mix(in srgb, var(--color-purple, #7c3aed) 12%, var(--background-secondary));
    color: var(--color-purple, #7c3aed);
    border-color: color-mix(in srgb, var(--color-purple, #7c3aed) 35%, transparent);
}
.sm-cc-entry-name-box {
    position: relative;
    flex: 1;
    min-width: 0;
}
.sm-cc-entry-name {
    width: 100%;
    min-width: 0;
    padding: .35rem .55rem;
    border-radius: 8px;
    border: 1px solid var(--background-modifier-border);
    font-weight: 600;
}
.sm-cc-entry-name-box .sm-preset-menu {
    min-width: 320px;
}
.sm-cc-entry-delete {
    border: none;
    background: transparent;
    cursor: pointer;
    font-size: 1.1rem;
    padding: .25rem .35rem;
    border-radius: 6px;
    transition: background 120ms ease;
}
.sm-cc-entry-delete:hover {
    background: color-mix(in srgb, var(--color-red, #e11d48) 12%, var(--background-secondary));
}
.sm-cc-entry-section {
    display: flex;
    flex-direction: column;
    gap: .5rem;
    padding: .5rem;
    border-radius: 8px;
    background: color-mix(in srgb, var(--background-secondary) 65%, transparent);
}
.sm-cc-entry-section--details {
    background: transparent;
    padding: 0;
}
.sm-cc-entry-grid {
    display: grid;
    grid-template-columns: max-content 1fr;
    column-gap: .75rem;
    row-gap: .45rem;
    align-items: center;
}
.sm-cc-entry-grid label {
    font-size: .85em;
    color: var(--text-muted);
    font-weight: 600;
}
.sm-cc-entry-input {
    width: 100%;
    padding: .3rem .5rem;
    border-radius: 6px;
}
.sm-cc-entry-label {
    font-size: .85em;
    font-weight: 600;
    color: var(--text-muted);
    margin-bottom: .25rem;
}
.sm-cc-entry-text {
    width: 100%;
    min-height: 140px;
    resize: vertical;
    padding: .45rem .55rem;
    border-radius: 8px;
}

/* === Entry Section Collapsible Functionality === */
/* Entry Section Headers for Collapsible functionality */
.sm-cc-entry-section-header {
    font-size: .85em;
    font-weight: 600;
    color: var(--text-muted);
    margin-bottom: .5rem;
    padding: .35rem .5rem;
    border-radius: 6px;
    background: color-mix(in srgb, var(--background-secondary) 85%, transparent);
    transition: background 120ms ease;
}

/* Collapsible section styles */
.sm-cc-section--collapsible .sm-cc-entry-section-header {
    cursor: pointer;
    user-select: none;
}

.sm-cc-section--collapsible .sm-cc-entry-section-header:hover {
    background: color-mix(in srgb, var(--background-secondary) 95%, transparent);
}

.sm-cc-section--collapsible .section-header {
    display: flex;
    align-items: center;
    gap: .5rem;
}

.sm-cc-section--collapsed .section-content {
    display: none;
}

.sm-cc-section--collapsible .section-chevron {
    transition: transform 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
}

.sm-cc-section--collapsed .section-chevron {
    transform: rotate(-90deg);
}

.sm-cc-section--collapsible .section-header-text {
    flex: 1;
}


/* === Entry Type Color Coding === */
/* Entry type row styling */
.sm-cc-entry-type-row {
    display: flex;
    align-items: center;
    gap: .5rem;
    padding: .5rem;
    border-radius: 8px;
    background: color-mix(in srgb, var(--background-secondary) 75%, transparent);
    margin-bottom: .35rem;
}

.sm-cc-entry-type-label {
    font-size: .85em;
    font-weight: 600;
    color: var(--text-muted);
}

.sm-cc-entry-type-select {
    flex: 1;
    min-width: 180px;
}

/* Entry type badges */
.sm-cc-entry-type-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: .2rem .6rem;
    border-radius: 999px;
    font-size: .7rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: .06em;
    margin-left: auto;
    opacity: 0.85;
    transition: opacity 120ms ease, transform 120ms ease;
}

.sm-cc-entry-type-badge:hover {
    opacity: 1;
    transform: scale(1.05);
}

/* Entry type: Passive */
.sm-cc-entry-card--type-passive {
    border-left: 3px solid color-mix(in srgb, var(--text-muted) 75%, transparent);
}

.sm-cc-entry-type-badge--passive {
    background: color-mix(in srgb, var(--text-muted) 18%, var(--background-secondary));
    color: var(--text-muted);
}

/* Entry type: Attack */
.sm-cc-entry-card--type-attack {
    border-left: 3px solid color-mix(in srgb, var(--color-red, #dc3545) 85%, transparent);
    background: linear-gradient(90deg, color-mix(in srgb, var(--color-red, #dc3545) 4%, transparent) 0%, transparent 100%);
}

.sm-cc-entry-type-badge--attack {
    background: color-mix(in srgb, var(--color-red, #dc3545) 18%, var(--background-secondary));
    color: var(--color-red, #dc3545);
}

/* Entry type: Save Action */
.sm-cc-entry-card--type-save-action {
    border-left: 3px solid color-mix(in srgb, var(--color-orange, #fd7e14) 85%, transparent);
    background: linear-gradient(90deg, color-mix(in srgb, var(--color-orange, #fd7e14) 4%, transparent) 0%, transparent 100%);
}

.sm-cc-entry-type-badge--save-action {
    background: color-mix(in srgb, var(--color-orange, #fd7e14) 18%, var(--background-secondary));
    color: var(--color-orange, #fd7e14);
}

/* Entry type: Multiattack */
.sm-cc-entry-card--type-multiattack {
    border-left: 3px solid color-mix(in srgb, var(--color-purple, #6f42c1) 85%, transparent);
    background: linear-gradient(90deg, color-mix(in srgb, var(--color-purple, #6f42c1) 4%, transparent) 0%, transparent 100%);
}

.sm-cc-entry-type-badge--multiattack {
    background: color-mix(in srgb, var(--color-purple, #6f42c1) 18%, var(--background-secondary));
    color: var(--color-purple, #6f42c1);
}

/* Entry type: Spellcasting */
.sm-cc-entry-card--type-spellcasting {
    border-left: 3px solid color-mix(in srgb, var(--interactive-accent, #0d6efd) 85%, transparent);
    background: linear-gradient(90deg, color-mix(in srgb, var(--interactive-accent, #0d6efd) 4%, transparent) 0%, transparent 100%);
}

.sm-cc-entry-type-badge--spellcasting {
    background: color-mix(in srgb, var(--interactive-accent, #0d6efd) 18%, var(--background-secondary));
    color: var(--interactive-accent, #0d6efd);
}

/* Dark theme adjustments */
.theme-dark .sm-cc-entry-card--type-attack,
.theme-dark .sm-cc-entry-card--type-save-action,
.theme-dark .sm-cc-entry-card--type-multiattack,
.theme-dark .sm-cc-entry-card--type-spellcasting {
    background: linear-gradient(90deg, color-mix(in srgb, currentColor 6%, transparent) 0%, transparent 100%);
}

/* Ensure text readability on colored cards */
.sm-cc-entry-card--type-attack .sm-cc-entry-name,
.sm-cc-entry-card--type-save-action .sm-cc-entry-name,
.sm-cc-entry-card--type-multiattack .sm-cc-entry-name,
.sm-cc-entry-card--type-spellcasting .sm-cc-entry-name {
    background: var(--background-primary);
}

/* Entry card action buttons */
.sm-cc-entry-actions {
    display: flex;
    align-items: center;
    gap: .35rem;
}

.sm-cc-entry-move-btn {
    border: 1px solid var(--background-modifier-border);
    background: var(--background-secondary);
    cursor: pointer;
    font-size: .9rem;
    padding: .25rem .35rem;
    border-radius: 6px;
    transition: background 120ms ease, color 120ms ease, border-color 120ms ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 1.8rem;
    min-height: 1.8rem;
}

.sm-cc-entry-move-btn:hover:not(:disabled) {
    background: var(--interactive-accent);
    color: var(--text-on-accent, #fff);
    border-color: var(--interactive-accent);
}

.sm-cc-entry-move-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
}

.sm-cc-entry-move-btn svg {
    width: 14px;
    height: 14px;
}


`;
var cartographerShellCss = `
/* === Cartographer Shell === */
.cartographer-host {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.sm-cartographer {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    width: 100%;
    height: 100%;
    min-height: 100%;
    gap: 1rem;
    padding: 1rem;
    box-sizing: border-box;
}

.sm-cartographer__header {
    padding-bottom: 0.25rem;
}

.sm-cartographer__header .sm-map-header {
    background: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 10px;
    padding: 0.75rem;
    gap: 0.5rem;
}

.sm-cartographer__header .sm-map-header h2 {
    margin: 0;
}

.sm-cartographer__header .sm-map-header .sm-map-header__secondary-left {
    margin-left: auto;
    margin-right: 0;
}

.sm-cartographer__body {
    display: flex;
    flex: 1 1 auto;
    gap: 1.25rem;
    align-items: stretch;
    width: 100%;
    min-height: 0;
}

.sm-cartographer__map {
    flex: 1 1 auto;
    min-width: 0;
    min-height: 0;
    position: relative;
    border: 1px solid var(--background-modifier-border);
    border-radius: 10px;
    background: var(--background-primary);
    padding: 0.75rem;
    box-sizing: border-box;
}

.sm-cartographer__map .sm-view-container {
    width: 100%;
    height: 100%;
}

.sm-cartographer__map .hex3x3-map {
    height: 100%;
    max-width: none;
}

.sm-cartographer__sidebar {
    flex: 0 0 280px;
    max-width: 320px;
    background: var(--background-secondary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 10px;
    padding: 1rem;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.sm-cartographer__mode-switch {
    display: inline-flex;
    gap: 0.4rem;
    align-items: center;
}

.sm-cartographer__mode-switch button {
    border: 1px solid var(--background-modifier-border);
    background: var(--background-secondary);
    padding: 0.25rem 0.75rem;
    border-radius: 6px;
    cursor: pointer;
    transition: background 120ms ease, color 120ms ease;
}

.sm-cartographer__mode-switch button.is-active {
    background: var(--interactive-accent, var(--color-accent));
    color: var(--text-on-accent, #fff);
}

/* Mode Dropdown */
.sm-mode-dropdown {
    position: relative;
}

.sm-mode-dropdown__trigger {
    border: 1px solid var(--background-modifier-border);
    background: var(--background-secondary);
    padding: 0.25rem 0.75rem;
    border-radius: 6px;
    cursor: pointer;
}

.sm-mode-dropdown__menu {
    position: absolute;
    top: calc(100% + 4px);
    right: 0;
    background: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 8px;
    padding: 0.25rem;
    min-width: 160px;
    display: none;
    flex-direction: column;
    gap: 0.25rem;
    z-index: 1000;
}

.sm-mode-dropdown.is-open .sm-mode-dropdown__menu {
    display: flex;
}

.sm-mode-dropdown__item {
    border: none;
    background: transparent;
    text-align: left;
    padding: 0.35rem 0.5rem;
    border-radius: 6px;
    cursor: pointer;
}

.sm-mode-dropdown__item:hover {
    background: var(--background-modifier-hover);
}

.sm-mode-dropdown__item.is-active {
    background: var(--interactive-accent, var(--color-accent));
    color: var(--text-on-accent, #fff);
}
`;
var cartographerPanelsCss = `
/* === Cartographer Panels (Editor & Inspector) === */

/* Library header */
.sm-library .sm-lib-header { display:flex; gap:.4rem; margin:.25rem 0 .25rem; }
.sm-library .sm-lib-header button { border: 1px solid var(--background-modifier-border); background: var(--background-secondary); padding:.25rem .75rem; border-radius:6px; cursor:pointer; }
.sm-library .sm-lib-header button.is-active { background: var(--interactive-accent); color: var(--text-on-accent,#fff); }
.sm-cartographer__panel {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.sm-cartographer__panel h3 {
    margin: 0;
}

.sm-cartographer__panel.is-disabled {
    opacity: 0.6;
    pointer-events: none;
}

.sm-cartographer__panel-info {
    font-size: 0.9rem;
    color: var(--text-muted);
}

.sm-cartographer__panel-file {
    font-size: 0.9rem;
    color: var(--text-muted);
}

.sm-cartographer__panel-tools {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.sm-cartographer__panel-tools label {
    font-weight: 600;
}

.sm-cartographer__panel-tools select {
    flex: 1 1 auto;
}

.sm-cartographer__panel-body {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.sm-cartographer__panel-status {
    font-size: 0.9rem;
    color: var(--text-muted);
}

.sm-cartographer__panel-row {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
}

.sm-cartographer__panel-row label {
    font-weight: 600;
}

.sm-cartographer__panel-row select,
.sm-cartographer__panel-row textarea {
    width: 100%;
    border-radius: 6px;
}

.sm-cartographer__panel-row textarea {
    resize: vertical;
}
`;
var travelModeCss = `
/* === Travel Mode (Cartographer & Legacy Shell) === */
.sm-cartographer--travel {
    --tg-color-token: var(--color-purple, #9c6dfb);
    --tg-color-user-anchor: var(--color-orange, #f59e0b);
    --tg-color-auto-point: var(--color-blue, #3b82f6);
}

.sm-cartographer__sidebar--travel {
    gap: 1rem;
}

.sm-cartographer__travel {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    width: 100%;
}

.sm-cartographer__travel-controls {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
}

.sm-cartographer__travel-buttons {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.5rem;
}

.sm-cartographer__travel-clock {
    font-weight: 600;
    margin-right: .5rem;
}

.sm-cartographer__travel-tempo {
    display: flex;
    align-items: center;
    gap: .35rem;
    margin-left: auto;
}

.sm-cartographer__travel-button {
    font-weight: 600;
}

.sm-cartographer__travel-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.75rem;
}

.sm-cartographer__travel-label {
    font-size: 0.9rem;
    color: var(--text-muted);
}

.sm-cartographer__travel-value {
    font-size: 1rem;
    font-weight: 600;
}

.sm-cartographer__travel-input {
    width: 100%;
    padding: 0.35rem 0.5rem;
    border-radius: 6px;
}

.sm-cartographer--travel .tg-token__circle {
    fill: var(--tg-color-token);
    opacity: 0.95;
    stroke: var(--background-modifier-border);
    stroke-width: 3;
    transition: opacity 120ms ease;
}

.sm-cartographer--travel .tg-route-dot {
    transition: opacity 120ms ease, r 120ms ease, stroke 120ms ease;
}

.sm-cartographer--travel .tg-route-dot--user {
    fill: var(--tg-color-user-anchor);
    opacity: 0.95;
}

.sm-cartographer--travel .tg-route-dot--auto {
    fill: var(--tg-color-auto-point);
    opacity: 0.55;
}

.sm-cartographer--travel .tg-route-dot-hitbox {
    fill: transparent;
    stroke: transparent;
}

.sm-cartographer--travel .tg-route-dot--user.is-highlighted {
    opacity: 1;
}

.sm-cartographer--travel .tg-route-dot--auto.is-highlighted {
    opacity: 0.9;
}

.sm-cartographer--travel .hex3x3-map circle[data-token] { opacity: .95; }
.sm-cartographer--travel .hex3x3-map polyline { pointer-events: none; }
`;
var presetsCss = `
/* === Presets & Autocomplete === */

/* Library separator */
.sm-cc-separator {
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 1.5rem 0;
  color: var(--text-muted);
  font-size: 0.85rem;
  font-weight: 600;
  letter-spacing: 0.05em;
  text-transform: uppercase;
}

/* Preset items in library */
.sm-cc-item--preset {
  opacity: 0.9;
  background: color-mix(in srgb, var(--interactive-accent) 5%, transparent);
  border-left: 3px solid var(--interactive-accent);
}

.sm-cc-item--preset:hover {
  opacity: 1;
  background: color-mix(in srgb, var(--interactive-accent) 10%, transparent);
}

/* Autocomplete dropdown */
.sm-cc-autocomplete {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  z-index: 1000;
  margin-top: 0.25rem;
  max-height: 300px;
  overflow-y: auto;
  background: var(--background-primary);
  border: 1px solid var(--background-modifier-border);
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
}

.sm-cc-autocomplete__item {
  padding: 0.75rem 1rem;
  cursor: pointer;
  transition: background 100ms ease;
  border-bottom: 1px solid var(--background-modifier-border);
}

.sm-cc-autocomplete__item:last-child {
  border-bottom: none;
}

.sm-cc-autocomplete__item:hover,
.sm-cc-autocomplete__item.is-selected {
  background: var(--background-modifier-hover);
}

.sm-cc-autocomplete__name {
  font-weight: 600;
  margin-bottom: 0.25rem;
}

.sm-cc-autocomplete__meta {
  font-size: 0.85rem;
  color: var(--text-muted);
}
`;
var HEX_PLUGIN_CSS_SECTIONS = {
  viewContainer: viewContainerCss,
  mapAndPreview: mapAndPreviewCss,
  editorLayouts: editorLayoutsCss,
  cartographerShell: cartographerShellCss,
  cartographerPanels: cartographerPanelsCss,
  travelMode: travelModeCss,
  presets: presetsCss
};
var HEX_PLUGIN_CSS = Object.values(HEX_PLUGIN_CSS_SECTIONS).join("\n\n");

// src/app/bootstrap-services.ts
init_terrain_store();
init_terrain();
var defaultLogger = {
  info: (message, context) => {
    if (context) {
      console.info(`[salt-marcher] ${message}`, context);
    } else {
      console.info(`[salt-marcher] ${message}`);
    }
  },
  warn: (message, context) => {
    if (context) {
      console.warn(`[salt-marcher] ${message}`, context);
    } else {
      console.warn(`[salt-marcher] ${message}`);
    }
  },
  error: (message, context) => {
    if (context) {
      console.error(`[salt-marcher] ${message}`, context);
    } else {
      console.error(`[salt-marcher] ${message}`);
    }
  }
};
function createTerrainBootstrap(app, config = {}) {
  const deps = {
    ensureTerrainFile: config.ensureTerrainFile ?? ensureTerrainFile,
    loadTerrains: config.loadTerrains ?? loadTerrains,
    setTerrains: config.setTerrains ?? setTerrains,
    watchTerrains: config.watchTerrains ?? watchTerrains,
    logger: config.logger ?? defaultLogger
  };
  let disposeWatcher = null;
  const stop = () => {
    if (disposeWatcher) {
      try {
        disposeWatcher();
      } catch (error) {
        deps.logger.warn?.("Failed to dispose terrain watcher", { error });
      }
    }
    disposeWatcher = null;
  };
  const start = async () => {
    stop();
    let primeError;
    let watchError;
    try {
      await deps.ensureTerrainFile(app);
      const map = await deps.loadTerrains(app);
      deps.setTerrains(map);
    } catch (error) {
      primeError = error;
      deps.logger.error?.("Failed to prime terrain palette from vault", { error });
    }
    try {
      disposeWatcher = deps.watchTerrains(app, {
        onError: (error, meta) => {
          deps.logger.error?.("Terrain watcher failed to apply vault change", {
            error,
            reason: meta.reason
          });
        }
      });
    } catch (error) {
      watchError = error;
      deps.logger.error?.("Failed to register terrain watcher", { error });
      disposeWatcher = null;
    }
    return {
      primed: !primeError && !watchError,
      primeError,
      watchError
    };
  };
  return {
    start,
    stop
  };
}

// src/app/main.ts
var SaltMarcherPlugin = class extends import_obsidian37.Plugin {
  async onload() {
    try {
      const { shouldImportPluginPresets: shouldImportPluginPresets2, importPluginPresets: importPluginPresets2 } = await Promise.resolve().then(() => (init_plugin_presets(), plugin_presets_exports));
      if (await shouldImportPluginPresets2(this.app)) {
        await importPluginPresets2(this.app);
      }
    } catch (err) {
      console.error("Failed to import preset creatures:", err);
    }
    try {
      const { shouldImportSpellPresets: shouldImportSpellPresets2, importSpellPresets: importSpellPresets2 } = await Promise.resolve().then(() => (init_plugin_presets(), plugin_presets_exports));
      if (await shouldImportSpellPresets2(this.app)) {
        await importSpellPresets2(this.app);
      }
    } catch (err) {
      console.error("Failed to import spell presets:", err);
    }
    try {
      const { shouldImportItemPresets: shouldImportItemPresets2, importItemPresets: importItemPresets2 } = await Promise.resolve().then(() => (init_plugin_presets(), plugin_presets_exports));
      if (await shouldImportItemPresets2(this.app)) {
        await importItemPresets2(this.app);
      }
    } catch (err) {
      console.error("Failed to import item presets:", err);
    }
    try {
      const { shouldImportEquipmentPresets: shouldImportEquipmentPresets2, importEquipmentPresets: importEquipmentPresets2 } = await Promise.resolve().then(() => (init_plugin_presets(), plugin_presets_exports));
      if (await shouldImportEquipmentPresets2(this.app)) {
        await importEquipmentPresets2(this.app);
      }
    } catch (err) {
      console.error("Failed to import equipment presets:", err);
    }
    try {
      const { generateAllIndexes: generateAllIndexes2 } = await Promise.resolve().then(() => (init_index_files(), index_files_exports));
      await generateAllIndexes2(this.app);
    } catch (err) {
      console.error("Failed to generate library indexes:", err);
    }
    try {
      const {
        generateCreaturesIndex: generateCreaturesIndex2,
        generateEquipmentIndex: generateEquipmentIndex2,
        generateSpellsIndex: generateSpellsIndex2,
        generateItemsIndex: generateItemsIndex2,
        generateLibraryHub: generateLibraryHub2
      } = await Promise.resolve().then(() => (init_index_files(), index_files_exports));
      const createDebouncedIndexUpdater = (updateFn, delay = 1e3) => {
        let timeoutId = null;
        return () => {
          if (timeoutId) clearTimeout(timeoutId);
          timeoutId = setTimeout(async () => {
            try {
              await updateFn();
            } catch (err) {
              console.error("Failed to update index:", err);
            }
          }, delay);
        };
      };
      const creaturesWatcher = createDebouncedIndexUpdater(() => generateCreaturesIndex2(this.app));
      this.registerEvent(this.app.vault.on("create", (file) => {
        if (file.path.startsWith("SaltMarcher/Creatures/") && file.path !== "SaltMarcher/Creatures.md") creaturesWatcher();
      }));
      this.registerEvent(this.app.vault.on("delete", (file) => {
        if (file.path.startsWith("SaltMarcher/Creatures/") && file.path !== "SaltMarcher/Creatures.md") creaturesWatcher();
      }));
      this.registerEvent(this.app.vault.on("rename", (file) => {
        if (file.path.startsWith("SaltMarcher/Creatures/") && file.path !== "SaltMarcher/Creatures.md") creaturesWatcher();
      }));
      const equipmentWatcher = createDebouncedIndexUpdater(() => generateEquipmentIndex2(this.app));
      this.registerEvent(this.app.vault.on("create", (file) => {
        if (file.path.startsWith("SaltMarcher/Equipment/") && file.path !== "SaltMarcher/Equipment.md") equipmentWatcher();
      }));
      this.registerEvent(this.app.vault.on("delete", (file) => {
        if (file.path.startsWith("SaltMarcher/Equipment/") && file.path !== "SaltMarcher/Equipment.md") equipmentWatcher();
      }));
      this.registerEvent(this.app.vault.on("rename", (file) => {
        if (file.path.startsWith("SaltMarcher/Equipment/") && file.path !== "SaltMarcher/Equipment.md") equipmentWatcher();
      }));
      const spellsWatcher = createDebouncedIndexUpdater(() => generateSpellsIndex2(this.app));
      this.registerEvent(this.app.vault.on("create", (file) => {
        if (file.path.startsWith("SaltMarcher/Spells/") && file.path !== "SaltMarcher/Spells.md") spellsWatcher();
      }));
      this.registerEvent(this.app.vault.on("delete", (file) => {
        if (file.path.startsWith("SaltMarcher/Spells/") && file.path !== "SaltMarcher/Spells.md") spellsWatcher();
      }));
      this.registerEvent(this.app.vault.on("rename", (file) => {
        if (file.path.startsWith("SaltMarcher/Spells/") && file.path !== "SaltMarcher/Spells.md") spellsWatcher();
      }));
      const itemsWatcher = createDebouncedIndexUpdater(() => generateItemsIndex2(this.app));
      this.registerEvent(this.app.vault.on("create", (file) => {
        if (file.path.startsWith("SaltMarcher/Items/") && file.path !== "SaltMarcher/Items.md") itemsWatcher();
      }));
      this.registerEvent(this.app.vault.on("delete", (file) => {
        if (file.path.startsWith("SaltMarcher/Items/") && file.path !== "SaltMarcher/Items.md") itemsWatcher();
      }));
      this.registerEvent(this.app.vault.on("rename", (file) => {
        if (file.path.startsWith("SaltMarcher/Items/") && file.path !== "SaltMarcher/Items.md") itemsWatcher();
      }));
    } catch (err) {
      console.error("Failed to setup library index watchers:", err);
    }
    for (const manifestEntry of VIEW_MANIFEST) {
      try {
        this.registerView(manifestEntry.viewType, manifestEntry.createView);
      } catch (error) {
        this.failIntegration("register-view", manifestEntry.integrationId, error, `${manifestEntry.displayName}-Ansicht konnte nicht registriert werden. Bitte die Konsole pruefen.`);
      }
    }
    this.terrainBootstrap = createTerrainBootstrap(this.app);
    const terrainBootstrapResult = await this.terrainBootstrap.start();
    if (!terrainBootstrapResult.primed) {
      const operation = terrainBootstrapResult.primeError ? "prime-dataset" : "watch-dataset";
      const error = terrainBootstrapResult.primeError ?? terrainBootstrapResult.watchError ?? new Error("Terrain bootstrap failed");
      const userMessage = operation === "prime-dataset" ? "Terrain-Daten konnten nicht geladen werden. Bitte die Vault-Dateien pruefen." : "Terrain-Aenderungen koennen nicht ueberwacht werden. Bitte die Konsole pruefen.";
      this.failIntegration(operation, "obsidian:terrain-palette", error, userMessage);
    }
    for (const manifestEntry of VIEW_MANIFEST) {
      const activation = manifestEntry.activation;
      if (!activation?.ribbon) continue;
      try {
        this.addRibbonIcon(activation.ribbon.icon, activation.ribbon.title, async () => {
          try {
            await activation.open(this.app);
          } catch (error) {
            this.failIntegration("activate-view", manifestEntry.integrationId, error, `${manifestEntry.displayName} konnte nicht geoeffnet werden. Bitte die Konsole pruefen.`);
          }
        });
      } catch (error) {
        this.failIntegration("register-ribbon", manifestEntry.integrationId, error, `${manifestEntry.displayName}-Ribbon konnte nicht erstellt werden. Bitte die Konsole pruefen.`);
      }
    }
    for (const manifestEntry of VIEW_MANIFEST) {
      const activation = manifestEntry.activation;
      if (!activation?.commands?.length) continue;
      for (const command of activation.commands) {
        try {
          this.addCommand({
            id: command.id,
            name: command.name,
            callback: async () => {
              try {
                await activation.open(this.app);
              } catch (error) {
                this.failIntegration("activate-view", manifestEntry.integrationId, error, `${manifestEntry.displayName} konnte nicht geoeffnet werden. Bitte die Konsole pruefen.`);
              }
            }
          });
        } catch (error) {
          this.failIntegration("register-command", manifestEntry.integrationId, error, `${manifestEntry.displayName}-Kommando konnte nicht registriert werden. Bitte die Konsole pruefen.`);
        }
      }
    }
    this.addCommand({
      id: "convert-reference-statblocks",
      name: "Convert Reference Statblocks to Presets",
      callback: async () => {
        const { convertSpecificFiles: convertSpecificFiles2 } = await Promise.resolve().then(() => (init_convert_references(), convert_references_exports));
        const testFiles = [
          "References/rulebooks/Statblocks/Creatures/Animals/ape.md",
          "References/rulebooks/Statblocks/Creatures/Monsters/aboleth.md"
        ];
        console.log("Starting conversion of files:", testFiles);
        for (const filePath of testFiles) {
          const file = this.app.vault.getAbstractFileByPath(filePath);
          console.log(`File ${filePath}:`, file ? "found" : "NOT FOUND");
        }
        const result = await convertSpecificFiles2(this.app, testFiles, false);
        console.log("Konvertierung abgeschlossen:", result);
        if (result.errors.length > 0) {
          console.error("Errors during conversion:", result.errors);
        }
      }
    });
    this.injectCss();
  }
  async onunload() {
    this.terrainBootstrap?.stop();
    try {
      await detachCartographerLeaves(this.app);
    } catch (error) {
      this.failIntegration("detach-view", "obsidian:cartographer-view", error, "Cartographer-Ansichten konnten nicht geschlossen werden. Bitte die Konsole pruefen.");
    }
    this.removeCss();
  }
  failIntegration(operation, integrationId, error, userMessage) {
    reportIntegrationIssue({ integrationId, operation, error, userMessage });
    throw error;
  }
  injectCss() {
    document.querySelectorAll("#hex-css").forEach((existingStyle) => existingStyle.remove());
    const style = document.createElement("style");
    style.id = "hex-css";
    style.textContent = HEX_PLUGIN_CSS;
    document.head.appendChild(style);
  }
  removeCss() {
    document.getElementById("hex-css")?.remove();
  }
};
