# SaltMarcher – Plugin Overview

SaltMarcher erweitert Obsidian um Werkzeuge für hex-basierte Kampagnenplanung: Karten lassen sich anlegen, editieren, einfärben,
analysieren und mit Reiserouten versehen. Das Plugin ist in klar getrennte Layer gegliedert, damit Rendering-Logik, Dateisystemzugriffe und UI-Komponenten unabhängig voneinander weiterentwickelt werden können.

## Architektur auf einen Blick

| Layer | Standort | Aufgabe | Detail-Dokument |
| --- | --- | --- | --- |
| Plugin-Bootstrap | `src/app/` | Registriert Views/Commands, lädt CSS & Terrain-Daten und koordiniert Lifecycle sowie Watcher. | – |
| Feature-Apps | `src/apps/` | Enthalten eigenständige Obsidian-Views (Galerie, Editor, Terrain-Editor, Travel Guide). | Pro Feature in `*Overview.txt` |
| Core-Services | `src/core/` | Bietet Hex-Geometrie, Map-/Tile-Dateioperationen, Terrain-Verwaltung und Workspace-Helfer. | `src/core/CoreOverview.txt` |
| UI-Bausteine | `src/ui/` | Stellt wiederverwendbare Modals/Bestätigungsdialoge für Features bereit. | `src/ui/UiOverview.txt` |
| Styling | `src/app/css.ts` | Liefert das zentrale CSS, das beim Plugin-Start injiziert wird. | – |

```
src/
├─ app/
│  ├─ main.ts                # Plugin-Bootstrap (Commands, Views, Watcher)
│  └─ css.ts                 # Zentrales Styling (wird dynamisch injiziert)
│
├─ apps/
│  ├─ map-gallery.ts         # Kartenübersicht – siehe MapEditorOverview.txt für den Editor
│  ├─ map-editor/            # Interaktiver Hex-Editor – MapEditorOverview.txt
│  ├─ terrain-editor/        # Terrain-Palette – TerrainEditorOverview.txt
│  └─ travel-guide/          # Reiseplanung – TravelGuideOverview.txt
│
├─ core/                     # Hex-Engine & Dateiservices – CoreOverview.txt
└─ ui/                       # Modals & Dialoge – UiOverview.txt
```

## Layer-Highlights

### Plugin-Lifecycle (`src/app/`)
- `main.ts` richtet Views (MapEditor, HexGallery, TerrainEditor, TravelGuide) sowie passende Commands/Ribbons ein.
- Lädt Terrain-Definitionen über den Core-Service (`core/terrain-store.ts`: `ensureTerrainFile → loadTerrains → setTerrains`) und beobachtet Änderungen via `watchTerrains`.
- Injiziert das zentrale CSS (`injectCss`) und räumt beim Unload alle Listener/Watcher ab.
- Verteilt Events/Handler an Feature-Layer und Core-Services.

### Feature-Apps (`src/apps/`)
- **Map Gallery (`map-gallery.ts`):** Listet Karten mit SVG-Vorschau, nutzt gemeinsame UI-Flows (`promptMapSelection`, `promptCreateMap`, `renderHexMapFromFile`) sowie `ConfirmDeleteModal` und Core-Helfer (`deleteMapAndTiles`).
- **Map Editor (`map-editor/`):** Liefert Tooling für Hex-Auswahl, Brush-Painting, Tile-Speicherung und Inspector-Views (Details siehe `MapEditorOverview.txt`).
- **Terrain Editor (`terrain-editor/`):** Pflegt Farb- und Geschwindigkeits-Paletten über den Core-Terrain-Store und synchronisiert Änderungen mit `terrain.ts`.
- **Travel Guide (`travel-guide/`):** Spielt Reiserouten auf Hex-Karten ab und nutzt Rendering/Geometrie aus dem Core.

### Core-Services (`src/core/`)
- Bündelt Hex-Mathematik, SVG-Rendering, Map/Terrain-Dateiverwaltung und Workspace-Utilities.
- High-Level-Flows für Kartenanlage (`createHexMapFile`), Tile-Liste/Selektion (`getAllMapFiles`, `getFirstHexBlock`), Rendering (`renderHexMap`) und Löschung (`deleteMapAndTiles`).
- Terrain-Verwaltung (`terrain-store.ts`, `setTerrainPalette`, `setTerrains`) hält UI und Renderer konsistent.
- Ausführliche Beschreibung im [Core Overview](src/core/CoreOverview.txt).

### Geteilte UI-Bausteine (`src/ui/`)
- `NameInputModal`, `MapSelectModal`, `ConfirmDeleteModal` und `map-workflows.ts` kapseln wiederverwendbare Dialoge und Map-spezifische Workflows (Button-Styling, Open/Create/Render).
- Reduzieren Boilerplate in Feature-Apps und sorgen für einheitliche UX zwischen Galerie und Editor.
- Details im [UI Overview](src/ui/UiOverview.txt).

### Styling & Build
- `src/app/css.ts` enthält alle SCSS-ähnlichen Styles für Maps, Tools, Terrain-Editor und Travel Guide.
- `manifest.json` definiert Plugin-ID/Version, `esbuild.config.mjs` + `tsconfig.json` stellen die Build-Pipeline für TypeScript sicher (`npm run build`).

## Typische Nutzerflüsse
1. Anwender erstellt über Ribbon/Command eine neue Karte → `promptCreateMap` sammelt den Namen (intern `NameInputModal` + `createHexMapFile`), legt Map + Tiles an und öffnet den Editor.
2. In der Galerie werden vorhandene Karten via `promptMapSelection` gefunden und per `renderHexMapFromFile` in SVGs gerendert; ein Klick startet den Editor oder öffnet zugehörige Tile-Notizen.
3. Terrain-Anpassungen werden im Terrain-Editor vorgenommen, der via Core `setTerrains` aktualisiert und sofort im Renderer wirksam macht.
4. Travel-Routen greifen auf dieselben Hex-Geometrie- und Rendering-Bausteine zurück, um Bewegungen über Karten abzubilden.

Dieses Dokument bietet den High-Level-Einstieg. Für Details zu einzelnen Layern verweisen die verlinkten Overview-Dateien auf Verantwortlichkeiten, APIs und Erweiterungspunkte.
